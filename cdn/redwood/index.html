<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e3063cb3c195b42cf2a634f670ec95a3c3c7995ef5f31caf0c972b896079c3c1ef353e6d7ac128c35fbf4c9f16523a6afed0e0580d1c7678b334921e79bdcd5ce4959fdf05ae4ba2c8629dbf1e0859b9b4129f46bbe6cff99d9192734ead9d771550a5aa6b660c3db33b07aff026801107d2ac4d340a5a2df371547f5e852b37f1ab5384d5d86acc8ac8b1a2067dc9eac971d4ba491a0d290275b2294d8bca21851496f8bca0d262bffa7c2ffefcd6c5f3fe8d349b3a8899a623452dab70018bc568c322cc1c377d39b01b9bd802ebf6cba5ee1b8a8af9dbf14838500daedf7b106c64df64e26eb9622ab2d77ba53a78b73b786fe2f6128e5b4c781b82d1c8465fd678dcbc00e9ccf84ea4681f44a723b0c14e905a6419e3f8504147672cfc4e7f51a3f5a4fbd712ef4ee724d109429de5c66d4556145cd16132e9a788175aa8ddb0edd108c63f1765c73a4fa4e644a5f367c5c6de2222f2a93c091ffbc6b46add215b610a13c849b2f984b6243a7622f4f40fc76ae89a0b4dd6203c1c5d7577a1cd6d81ca9a6c4524362885806c6338739af0bd12e86871d20461a2f5c4c7ae4867934eba32375e19752de209ff5316599d543054cc1d60f073acd10f7c7e99a63bce24a4bae3d94a40470453d9786e9cda24e3bef3ed3877e47bf411b439fed81fd7b68f369363e7d855d6a05e5a55b444e7c02479482dcda4ae085fb28034842641b382e6059f515b01a083d063759b90564baaddeb6b3c448b9e6a2645650ac01cdb82aee7b7857b5ad6094fd05957840ffefe9245b50918547ab84de850c066910f64a311b7688214f49a4aeaa2c87a9fcef1e2bb9bfde0d76c6e2cdb191728d484bc3019843944adce231187800c907d188b258984bb41a1429280d5a957e9bbba7b92a33ea3dbfff13a0a6ffe96592fd045560d664c7bb6f64571946f26a9c677cf2f03b7feb83c184fba8986e38186e4025cc5305e5d83f94d72076aadc394e99fc83748ea0bbb797c44445d6e0741b9a839ebd7801762bbfa1064c0742673e73b878084af7af6a96a9f45885ec3648378bd26adf3a29cca528a61d50309715b1233d297fe01ac752a02817c88116d567bfcd563ea29ddaf35c3b106b1505145f5ffac4024f3ec8f4652dee5c4e1035dbc07afe3ce859b5b6a382d1348fbd9a9ef02377237704e1c25877c24543e53401081719767ea16681db6d29cc107ac4ee80acf05c9be940e80aaf9924ef11e9f1618b1b5169ba4ace0d7bf871db4c1d139a04cb7e5194d54fd9d95e9817c9138c4731261e910409c7bc4781cede5e3f71dedee4d7c9a2e0c966dfa60952c1ff5998d13d1e0b32d4de8a1aa24315d48364404f36c33e621eb9e3f7c17c502aeba697ed9ac630ef1ac4741bc0a15996d08cbd3eba34da87e9f15c1865083a1f7099da0c2789d9abf2c5e88dd278a077d7c2ff46547614c5b0282786bc648109c44588176c36e31ab8c256c2db5573ba4d8301018851a5e1c63bc7ce45cd6bdb527365b17a44cf5c48be2b0b469aff8c94a4a8d234186961527f830b7e837c83c5cd39eea7d71988ee3844af344025af277d2f1bfc69649baf38819d691c099ecc206076bcee26d83c8b6110018d3632961b756a91a60b3586db3b9763203be558a73b4cd135b6abf87d3a4bf72ed6345820f4a6a4e577bf14d4756c335e5b50f2d9443267f3078fb631551b37212bebf4956648c9bc43966857c84fbf842a6b12a80b258e9be7611b6b864c878da2521fb88b5e987dbabb8b6a120c9dcab422024b0e89eb1e17a36f6ca0130ca662a666032414a6aff63ef4adcb86f7364ae8ef7c24061fc8d7c8e3405d129bc22739d23f446ffdc220efff9f58ae471c5d5ba03be43ac6b0060c4c71a2df47a77aadf8b3c79ae3280bfe54fd3ecb173b8c68464beb8df9f920c698c63f74989d69871bc5a283b47473110fe90c8fb3f12c4feb7bbe220d32fd48238ae16ace70d88329792e1d230f275a174cb9098c2642a951d73be675313494f489abcd1e629c1543047d7a95bfd6fc20e2b3dc6b9b03b8d6132136b2015f88fd1b491970f786bd136b6598d8e78227c9b723d56de51a7f4dc938096d6d46edecf221ec8dbf0642854efee483bc62766eb59c0edbc1977e44f62278772357491bede89125d7907ce1fde747747b0ece681e57e96ea326057edddb711721a30341f277846f9cbb3f006cc64c21c392ffb0016413242e01d22629d8742886544a42b903bbb8534ce8c33b675c6631ae253818e951dbe4ecc5945767c2fb678b61d4620d986848b364cd430fadb710fd96f20d44d70ae3e18d68208e65cc3d1802a6ad4598e8c54bddcb66dc5e7af156b81fd37496a96d64b611637c7b4b8a4bced121fa64554798cd4872a93b2093ff338b2cebc480152ceba4872a06704f1a6158ea87a0756c6f069ef77bd62022ee7d88a104c9e6a9edbeb3792711950f2080b5beb5e10167b99489355e07173023f1e2660ea2281ad38b0001046293b51caa1d4f7fbefcde404208e8e895368d78ef4384c6b228ef6ba5d49910a1a4f80ebd6025c9b2e6255e9d5d7b3623b815098191841498beb62871595bb43d308708d1ed44a4640ee580e02cc68876c64af6ad3eb9663eacdc655f996d8ddbafcd79c1da62bf9ae78d3b162f8926e8c81b1881fbcf936e6fb11dfa4cbdd621ca612ad881c0152b4c62e5fb08a11f38278a8f5354af17dec98b4c308fb855d343a6c607850ab19908ebbec0ca931127128d50508fb370d905d28a55d6ae205bf84004fd0fd8351e5e18973810890e1be9400c1a3ba3110081fc9a38db895ee483d3eeaa3a8fbe769ac1ce3f625255f6bf3a65b7450b122c98a009d3cbdf7c0a5a74f80576d276cb6e5f1763aeb41a185fe4ce7dd0e217343a4f15f7c0a41d160ba13dced2e5c9529e849c18d144ec13be30ff5ed8b3ce012662fd1b049b9360effa569d54d2113f68fb5bb568b13820cc8c91a6b1fa42a4af4a6504000e54860c0c8fdea0a536bb0f6852a44219684d857d6f8ecb361960ed01ca27fd45fac8e37d7808586c00b884015db61c08546ba983f6a57c61538bbc8a00e3176fd3d464216a87d75bf9dbd1cdb7fb4bd70ad70334d964008eed1cca7347cedb682f8e6ff40101436d584829244deaf90d3bb6346dd01715deefda0da61cea959231bc56c8d0cf4644ab018ec06c85536548cce838383e41d4ec68d7fdda0f72f48a56c9298159f088993afb0e1ff6ece961a7169e420553aab74a02c09cb5da07b0fae526c624167982241950440dbf1a6b2a142e7535b82c1b5e6570a183ef8abfc3ee301520025d9dc3b8eecbb26e34072fc2fd58356a3036a3d84e9348e0b3b68bea687de53ddb77ac320c2a338b5c6dfb30714630ec5982296f7b575cb29bd21cb961e1e883cf8d45499b014bbf05848bd781d761cea78703fddca27d9bf27ed2a0f32aef5cf352527a1043ddb9faf9071bd8b16323fdabda6f18e3e20f8dd860f70951959e812e2bc2bed9f636e4ca058c136796094813cfecf251154c737abe4f32d8545ad7820db7a3326c855d671f44709ea8ba00d016339ca48bec2f014008ae125f91bc85cd5c64b1406fb291aa8aaff9beace97ea4225e1a7425402aa35c69fc4b2391241ff54786a5d4ea27fc24be0fb33dc918f486cd63bfb101c2e8040633ff68775f4282cc5c9311f964ad8b5e00374e688cfb070941dc21744e9a699e4c53f8366241cbdd56718c9cce6d72c420d6cda2c4c9412a50d742febf55891a110b4fd13ef61d6217074af167968d2d2f0c813fec462f0584fce617b576e2c554f157e1fb28a4fc93bd0396d3ab6527e5b0054473a11b3cb5a8dd8950e89354b49ec15da83780127648cb60919a3d569caf378747a14202efe50fbd960be7d3b5849ab1bdb1cf6da059abffc6f96be691a541c12464367fe38adc303bb27d335bba349c1543030d8571320e11627a3ffb903b5fc8f7f95f15314a974081484570f38118f5c947ffb899676fa814a3e260a978455c5d952e8e24e95f747f4753f4a0d7e67b2ca5d2482c5863a620000daa60612226a03fbeb09dd09d010e628bc11ae599d4424a972b28b5adbdcd953765c311681c7f63d8401d1f6797624743912713dbcbd36eb8f375fef10c32168059e370cfa675e39afd3165c619ec0202e27040bc4cdf9ef4c216b76acdf32e0f630949b7c8c2a681d58faa7a84ade5eaea68c1b86b6cb9bd65b5a294dc1bc37c50a3594e7d02c1fc2fe9876017c17ab7c47c20f64b3f1c6732cebd2f2ecbbe6ac71aa1575309648b69fa79f5df3062fb48dda9b5c9a074ee5eba5f6b3198ab6b63847c456be4e633f18ed766b622148e9ab6cb99e311d6c73f1d0b84d4cc00524cd76b681cd2ea68dd21ba89dd5cbef0f9d0f4cc3eafd171fdf4e879210030435c2c659677362285c2af7d3af674b560d872c50120b806a5cb2f3c4fc2fab4b5fe96461046a27ac1f8a864d59e6fb27bc24c64f3a7d92fe1cc5d7ac43246129b7a0b147461e8b92652a43b819b97e302066a4fc8b150637ee898b0a7a88676fbc571fcc542088b3e50167beb4116721fb4fb354ef54e4a3324fd16e83d7f58d72349f133eb9ab18d5c18da9d793f289f139de066dfe78f433964c66f0891edfbc5508a569792e8c62be3e04d7cc27768b43e386a7aedd00ecee57bcd17ad0eb1f24b77b6cb5fa1314c7c0f484b8fed73da11d3bc779cec9f0a555472caa264c9682d492cbecfefc3a4ead94bc0c3e196b515f11abebd5dea3f566eb82fbb082fda0232558536bdd65c6de7cf6819f3f41373260bcefeb88d0b042959c274d224551dc2e4ac1b31524d567ccf0a5bde3b9a9200accfd9bc382bc4202093bb600a5313cd57d39e3a245ef96db8dbf1ebdfd00c56926882170d3a7a50c4f4aea34b8eee2db70ddf690465bb728b6f7aa12f7e2401e83ae977858092b780edf95d366db49a9e7b3469fd9362a3aca0423776f94808c89038c34c8157149d3534a5276784d4635b5a8ff88a9356978e441ea609cea44ac1d4c03ce55195917655a1d9613b23ee55436b2b82672cecd5db044aaa6116625d9c192c4a8e891f0c577f5294c82255537d885dbd905a214a15aa44e7ab224681a696edd94e876005051579601a90fe56fbcfd32384c3cb0a913810ce2a3d7032f0dd22ca42ec95facb598b0af6bdd77eb511b97fc53c23417b262fc09a22024f63f73f603d10aea89e5993b55f87680af8c400ba880651fa5a806270eb6c0ad125151c1f04a78c05127ac81269a69362fc9f323349dd7f011dd3b7d18220ad76a376639b0d4ea747084f0004e8f1fdce5c8214942b06e3b6d0cac0e33b6828d70ebaa3509354098913f07789f5707b27c91cbc245025255166503621ff30fdb55219245642aebb3508a049c159f9256db7b464a6c16bcc0b309451f146ef4cd3976667743a1e375ec6979edeb90103125ec7f9c660dff5ae275b358ac652941704b624c958cf091fe342fe5a240eaadb68813277248445adadfc1913ae34993b91905adb26e0b63bd433cc161421e63a9592a83ea411efb3ef0057368b4290425fc298c50c3df975b0a0743911c3cc79b46a09b9702cdfcc158b5684bec4bd922ec3cb495731746fafc519969d175382bf10ca6f72eb5da2e6957545dd5186185158c112355977942c32c01aada5ce8598715ec76cf1e5c722a6f031b3245eba11d957fceba426d5b9ddcc05373f5499fd0494ab5a08e64811724e3d3d1f26570a81ec4d4c8eefa2a8d44b6d5055dd031f20b73720ee3415cce83caef6086857566d8aef658ac3592bde7eb6376bac36f63b3742e21765531c547577e5696698fe46b85ed540b9289c1ea10504903bfe56539be8280d6701cb69eefbf2d5234d65cbe4c94530af99e876ba3ef9e2cc4cae3d1ddeb24505796c230f3f544fc4cc9e19b2fe4985aaf20fad0ea26319b6f1ce31364d8cabf9c2502d52b7a642be2c70b42d2c1db50406dab9fe9195f68bd385c16aa528e791a32f0eb90ccddc95590888ac86549dccd165cde6e1d16173115e89e32d383fff2cfe7388a680703619cb1ec3e635caca9d6bb8d819b6440113fa5f8c5377269e5b4f586acc1ffe8bd8668c194ad3bfd37da47e105f7f8c805dcd9459990711159cf0b744461c2256a9dd21488bbeafec6327f63afb651d61686f4d5827b5ee3eaefc7948c426c117d4241bc262edd4d5c82b73094205849686d80382ff05a040d16a77968846370297030979728ca8f581338a6c933d9a77526416c748407e69e03fd46ed03663e88a8bd370dcf627462bc0c36636d27ebc9301b0d9b090c895d1e310e0ec51b2423eccf7bdd36c1d5a619ba66f864a664b71046510aa259f942d4c1e562a61aab9e8caa0145d95b2b1dcfca4fa4dd8d1d98d5e2f6b7d680574f0a2b7d6d7a3ae18e11588f35ae75de8a3a76c75a6298a9fefe51d0a6ecb1beb41f461b18fe0e10bd2ef19c99a9353ea58236662d65d42abae40da1d0c75293128bf9416a24426e71825aed124d53fce33177c23421a0b7d9c8cf6172a3b85392f58fd7337d96cb53e98b98bd17eb6fd536ff2de44fc2069165c46ca56ba082442a4c63b8add6ddfbe4398eb4da9146da74e4f35d4b8f8608e309f06db8e0ac7a3dd3095ed1e658b4f1306eebfb1f851d88855e5fdcae8ca960ddf0cb6d4c6444b83bab22cd9581a35d20a68331ec7e2b5cc485d896f44295ec8e3774ed06c8deb787dd30f5a397ce3cd805e1ca5e61aa90d67ce6309f35352690df4e75340f1375d9d4751a8169280fc7ac7d39c294653491b9c497ee3337250eab07f75bd343e1ffc409236a2a9c745c63a6ce2af71e50ea8c7624c5e5dfe412582e7e09e3e42a0f4c11b1f6de45eddd6def58c23186f1fd090cc04c3e0e2b4b25599c2d870f7ca924b92ae3cdae94cef5fd7251aa646533d4cbe00c399963358b7e72300bab1a213c91f1b23dacbd70709f2e25687aafba6ec6358e482f002428a0210d200741ae07fc730b9f6d212e72237ad2ec032423d446b08ce24167697c7daf789bd66cf39bbe7b7bbe586a6bf7b276c8b07158650c81d894a51de8d91b646472c3ad674fa4f9f06a94e03afc40c2f70e51d3bcaaa658f812040671e84b8e5cbeab50ff5ee1abd625bff62f6fb0b3fff6f421d9db1434adff3348f851e926be4ea60f203a220572739b54508e4ccf16f2db08cd6784b9c9fd9ecca32084794c516cedda04cac470781b2f42d9698030085b8dec91d2eccfef742e59eb264c573a91417232b248684b3831bdd51258abf9068aadc31c9cc9edd63117372f27268e9d693e5a2bc27bf083e77ff12383795f7f249ce8c1794b099d14791a3021c2a9e819cfb8595809b8f3ff33a6b5a44c921ee754eff1eca3b0ae0671e20cd88f18105ffca1ca9f58f180725738c6540cc35969609a9b8919fcdb0c7dd438ab7da1692e532d9c90f09cf32c8fce6b75a73b138c7035059b12044df0d6cab0dd93425d2526363c669572ac813023d189d1ff6116349c0fd9b701161e1817e7530a89003894e6a9e704dc71559c2b0181aa103d75ab73814db2f139ed20f6ce7d04f67f2d81c53d630648fb5289ed7cbb48e2ac31fac18dd31b124bbe4d7fec309da2dde37c67e46aaacba58862ce70d09992d942577039485d41beab520ba38f8db6e4599c5ff845b835bbb5813946796e0c283836c5be73248d5979b8ad7b986a59665364d6b2988e7ce783ed0b337f2ac0f5d84eb8d17c40ab50a2d34d729a774414dc9c610aa9978921ced926222c1fa781089adfe7ab004b73109cf1e3ff82d4d943fc992f7ae424db7fce85c79ad1965561ae0a7c16b365ef65b439425a7f3277dfcfdc1bb5d61cac6ccd90d2f02be80b40fae4fd697f1c44a96a3a40bbcd0c0ccd7a82885804d896205ba867947e2ceaa6359d671e88338a1aa4f31f7aa3c543fc0092257f8a77afebf7c8dfcfab07fddc67e3ac806dfaf5de5b76ba4961496bed1ca42ed27fe792a72730db911fe90aefb3cdddc45e0911ffe4d1397eda2384d0a56fa00085d871b2dd8286286a2b9e9aa6548a4c308863218ed77b8362ac2f21c2d4e15b93c8fee82faca8897b2ad4b2b4696e820a35d8b9a9502ceefa330524947b2b336d19fb258b350f7f6b0c3365c1533480714c0809ea52db06edbd94216e8bcb69bd088694c6808287e51ba44e967a49a52e4c5d9d95841c89b04d9f282424d69ad6f077b8a694d11b88ab7f35c8b22ed528bcd23489a2fbdba7c35390eb8165a4cd1346875e8e88d922611090e29717ca358b0ee5295fcf25d825dc12102eb245ad1f36c71d014526389329b7f0a78d04c923daca3482df38a720fefcc5bf884e40accb8c901812f45e943ca2800234fcbce3700121d78202bff0f906b033c7f835e1327c3e1fae9de433a3c9e668a34faacea793146e1e0e93605ab76ffb582ca961215efc8077abe1f075a97e65296a50f4f3f26fddd23bf067b8a9b5c1fdf764a5b5edd1caeba6c3bb11969d796897887ce53fbd3e2a1bf565ce13c6c79426c339536f58ae6223fd508f2eca8000eff5ff7f34c8bce19681b3e51f5837390ab6d30438e7361522efed00035d87e83ace02f20c833c903e63a7b7f4c982472dbfc7964ab7215c0fe65b6964c025d05e16b7e53556a848ed02492f26aca98b3ea15239fac2e6823a697980bb4b74acb3ff38d2f9c81cd86ac2e55dd41d18dc023ba150a308dcaa0b2cc0c1265c6fe0f86cf11016fcff6c52986c18bff08929c186cd61de470bf059948ac90b76a9363ab699c8f467236bba1b6470d57d38ce345f1594c32b48b3ffac8a1b6c842dbd0a10297b3f42ba2b295ef6cc67f33d681d3a24cf1d4c0db4853a82c97072fe16cfc90236282957ffe6a4f622ab270a9be3cc0f58d0d6296cfdc33e9550862a4eeeb364f39f6790be9d307a5e7efdb94614e1ab74a896a2ab05ef71810165f2102d941c54a012e72cecf874a8d097288415c055b46498415cea41254ef7c89eca2808d665f801686f62041fdb178772ee5d1d4516466316fc131f2d3901733ad52d1a2ebbb9a1bcde1de1e995a82b15d5dfb50e185760dcf02934f10fd4889f848b45f3550b04021297c7d2fe75dba1476f3eb6b08b9daa499ac50e6a8d07a249951cd24b526bdcfb771ee6594f0e6b33caf555a08cc2ff62756227d587b7e0e0db5aafb358a8fefcb40afd6151345aae671d95a59802950251c80346ae5f9c44ea1e2c04c28230bc27aeb5b59726c6c5ef504ae067bddd58195044f15f3f24620f02b142c367e139a08b4fd943e2befc591a4ad17d64d02a2c37e327f6e39d9ef87837a178153881f7305929dd0a3ef6047da06b6c8e71893ad2b798528eb57d462a8d641be90d2c5e4983d2e6a25d8bd7f8933c190f710927b3c2fed6288ea00d4ee06398c8b3ae37afc549006c290ea6da785d25ea7b1cddc462f96c467ae6234eb49d33775fd0fb86fb1635fef8be37644d4b0e54528705db716f7513acf50694872dbf8e12f772493be2bcffe14266e6c81c2854637e2eba073d3bc103c12cd98d8b7fcb295385f57c39beb23dbf66e62a456c1768b4c2149972eba9b740a4c3a195ac1d04a7eeaa24f7b4150092c25337aabd085b874ab97636b09722f99d85193e779848fdd4825ab5d88c6745b6797429cdae7af4b459995e4fd5ff478d63c269c7ef073ca994e908d1c7c47cb77088ea888ab2cffd6f8cd3297d5df9b87bae0f5b32692853b5baaff0f78f62ce714408b1603052487e8b19cec7bf02dd55ddf3628cb25e1f60eb806760046bda08c3b28f54db34f446c20aa98cf6ab206ef6d26f9f0cab02637c44d42df9000b31b8ba7be00bfd6ccd898f284ae563912007eff9286bc23437c6f49336f9b6bb9d8eef9a609215a0e1fc748a88ea8ec2a2f63eb9b07ac1baa5a7db41fb444b173c437b889650146be254c9937b2cd0a170481042b19eceb1ad7193c25c223fb643582fb3a6bfb8e47cf80806121646e91d1cde56090cdfc285dc99f791a039b835c8c3935dc60b08a4a6ceda2e22dca686cfaa32a262a231eaa165a2830eb06396032799c786c706af8b8e5c90790c3f07af998dac53f32102290b1eea84c091fe137c3662f952233671843dd9f00572f4e1d77875bfcf0c87a32ef17592d96baeac44fb1722e907f7b63a0cb9c12017a8cf7d23d0e58789202ba0ddba7ce28cfa7ae661e6a8523b0e84aa4e2fb71209a4da11a724436a8cc6aa1773406ba4fa827f89c39232326d0aeee19b76f449934317fcdd2f65635c22864719c2ee8553309f1ef4460f81ec4c6bda113220d76e5a385bee2302e563e096360ae5ab29f002cfb8013c1008c8dd47710b0d72fcdd9a3fe8aef149747695bc401978c0b03cbec88794753a2113328f0297008c00cefd2406049d2e3d0ba0ec4c4721590a68a9d376c12e2bb4ee374e438197962051c223edd3b8753169c482b009167e311386b420cd8abebddfc91a39c9c42ef745d24a6fc21759654251eb67742332ce16f503cddd1a5a3230a4a5d42cd5838d6450b0c1935bb09516c9f35329d944681e17eeec03ca6267b87b8e5b92fbc32e947326ac6509c20e9fb9f127306c083e2f70762388b25cce6a27222a79d1236053c4bcd4b61aecdeb25794dc289cd1a21c0c47df75ef9d9dbbf982ac6f012ab3ef7a5d1357e9c7cd43ea1a9cda09f492a34b909030a57dc84fd641cbaa853d80f484aee2d4ed16f6278b3456f4958aacb78c91ad265dd53d21882346c558095758a25415590487571ebdd65c93be8725a7b99a00c0b3b2dfd9948837277e64574e3cd8de6b034d90e9a3da1a5b69781e4317e71efc8b8aaa1da09847941f1d4b08a475b2554b575bb9a935bb25736caa4abb986454ae426509659e53881df6abb7c485cf19d1895211cfe5c396ba03187693c4b9d8ce0a60c9101d23a7d81220b0f3174965418e41571cba242af4c6bad1802a0204ab2045864b4935e53cf7b39769c35aaa89a6b710f5a53a0e6a11a06d3eaf1dbe713abda0d9e5a1341c74e05ee813a957be5711e433c426d88545082b2d28dafe8fd6e1e582742891e1f4945d1a36da1fe71515af815316c94af9f433c8998d5411251e1ebf304c13811426180e15412fe79cce94803f3cb4ad3c7f0b6fd127bc96a5a581f819925a85dc6f6ab8132f1dcfb3e48c2aca379c12e75791f8438e047b487ee87ae6908e5163212ee5fcf348e9b499be6e785b6eeb512d57c9c51c016de48cfdd9b7254c782d6953bc7fc5b1cc461c16a8871567bad2759c0b8295c296dd442c3cc8c3ba311fd094835cd7c17b0e575db84a5a1a39b20d7828d158a6ee64a2b87b72bf62509c67fd09ae77715cda8c5fda7482eff64236e74e79bbcf52b2e1c0ce3841bdecb133a4e7096f40c2583233b678233ec78e22faaeb136931eb61944db85109b8b79087645a8e1eafc3fe6b23ed8ad2066d8f28368e52be4a83a4808ae5ef136f231d351d79abfd733cca22f72928aeb2d1fc67844d802faa6d94570ce94121a8a68347609a5f220b76961235bd2465ffc6b2824d03264c7cc213b96ccc17cc5b40a9d53813c794d5d621057a63cec80acc98a9d647005126c500e622f0580f9622657d0554d4fe2a5622a33d13b925882f08e574297d3690ebb77de55b474087f36dcdbb246a6d95dfc95eebc9858f19c6a4bbcb2fa49327ddeecb059f4a4f572083a1c5a061ab9936c4f11498fd7cf18ec2197a8dd772a804e6404bde7cbe7e853ed21a05eee74f5470ebbc3c80ee22adacff26bcdff23a064624c39f1173338ed74b3a043234da137d86ab2689e66be56dc22d171a7f2e02f8d18f5dcf870c93cd1f34a04f9a5d8f2650193e4b586890d95c2e892cce34d721f71a0ec9f6589539acae897e3ddb23ce726b4d34ff4a69439240a2f2f58fb5eb88f25cbf055baf52a18b67550285cc1b4d711171a76285d8d87d32020e909139d8bf0f53cf9c012298d02a0969ce61b73be5d0844d2181fddb4cf101f656f60ef4123abb3dc987b442c38aa06b1f736e4cc818b9297f9e18aad006f88b03ee932833c82b41723eab0724e9b971a66c3a56de5c0582fbf8d53254d5518e4b10251311fd4b4ca1e133ce4acc21b22de9dd4e3e0ae50c5a56739d817887b45458d43a9376df1984b0ce7aeb8070d9956e8a3b32847de2e0cedd354d301ca5744a294903fbca79dac34dff66c8a0cab9d77e1b56be2e87862f51d17e7272a9a88cd4e9b206886cf19fdb33cc0550dc37c144bfd1b09bb51bedf918e4e7bcd0b9e5e7624c900701517a93b4510d6145ec4ef406f73a86c84f37779c36a228c1ede0eb0a5ce87928d15c66004ba8feaf0a176cff675b3f1675d650331cd02428f347052f08a13c8a794fc0f5ca4307d507684b8243474e3e92807b34ea092f539c4b12c5f8438e2b44396e701561ac66d8e2543c922d0c157ec10cbc94d508a5b53323e5b1b276d1788fafef230564657493265e74f9bbb62fe61a91b05439335c3e8c983cd360b1983f3c2ee066cc5599319709daa0d2978ac628ca283b3947dbf750c74f095b56cd2b4e90f2f92f0e50bfab41d9133e552d2ad7b7691fe0c2a486ea18aeaa6df0b093dd7261af511f1ca73b80faae63840bd03e2f36fccb9706c6148fc9d4055464a42e5bc77a33214359d51c8f62cdb60e1c7af502ef02e5ac0962dbea9a839f98cf7020ef651be5d5356aa50b43bbed38d4c7b1c068439932102347e4c7207c630d0ded016623d27c4ec37fc98899ccb7fcc5275f52efbe588a32f0a84780eaa476c1c5ed6ea4c65339915d04e343f0ec7debb35643d2b07f7a9e5c7fedbe2252791f8eac2e4bbd793c0aac717e5246ba896913c9d38e1e15c50a5ba3b2be8531174a4220365029b839b4b94f353d8f34310961c0940e1c581f186ba02ec29b43d0c11008660070aa4cb8c5e7386ee884f146cf0222020df7fcada68b126d7b8a2230020e755f0ae7d40c6126e0b0328c2fae5cde611e296de0bd6fbadc2b3f35bac4e41b634f60946b4bdb52cc7deb45b8a963c3fb0a236fadcad61e308badd1e5c4402fa619efa0d4f8035238b8942e4eb67aff855ec9f693ae281329804e5b31a924ab1f8e9ee663950a88ee39aab59be0df6bad0357c20bdd862fa1fb448741deae797a15a1a7ff082f6482d23412a3d2b0b4ebc5329c99b20a7f335e831a74dd189321da210f29c13dec26f80817815fc638b6c0d021a4543ecf4ace206fce04be4c9b26e365d603723e01a8bfc428dc9be8bcd58bae5e6aa8a10d75e4f0f12e91a21139f0caada6cef64bb177f13eff723b6302542729e88e1e3eae94de0366bf79b1c756c9fa69ba565a68327e1298cf356830d5ee391ab05d1dc3fed62bfae17968a766eca6981976ec99ccc1b5145bed729deb7d4b6efce6337fc920e68a9906ecc5c8a2b34c258dc069f2953263a5365c0c70fb768578cd25aa5f3d66c366be7442154251033d3b5abf6418780f05b6d7b03a39b493fa7f3795dc9378616a49a1aaeffeb76a144470e3b110b2749243fb095ef4a9bdb9fc70eb34e947c1e82eaf6be742049eeac7dd30fd674aed78196fb89ccf953c28a5fcc70cf6813f33d7cb5212c45ab5aee3664d7cd065e88f4734c052f71d22aae0a9e1ecf7ecc585ef1498bfc6d3c81ea1aee40af58f4d89ea1d6bc400f15b49c12eac607a9ffb5bf4f737100a99455e5719285eee06034a1ef5b28ed3278e23d05aa4ce55c91be0732e7d25fd2dc8465e402e83b57598a7b7c2fefaa7d6694c1fddb1860d9e2a05b4d62b6bf3767d8fbfbe6799986ea2dd43119be852a812240f2fc597e644e042c3b3ea76b49630f43a6e62c0c12c5582faf23fb979e5cd4e579f5315f85819f1bd05a8a1a964fd7bbef6ab4d652ec478268e57db70151559aeba31c2e6e4593512420fffefe755c5eb7d14c0361944c43f46ff3ae6b1c86e501bbe7b50cb6702fc4fa9048dc5acfc4409e8cfc70dbc97178274730cd2684aceed10ba451451b48e511e7f27d09b4af481e2122978602626d4b287a53ba2b87927bbec693d06c0ef594eba2548397832f41d88bc3778c3b0c348846a2a1c6917db660a0665698cc08419d01669441e6bb222374b291d2b35cef53b50e0cd51f1aa3ac83b99ddd872d5a9498fb834de9bdfcefb245f8bfd4d7a7da248faa2cece7f942572ceca902f96cacc39df92c1d3c79f2dc9a60d8ce6181488b0be02ad23eba3bca75ee65848a830bc8ba495224cffdd58712e5d2ea9149202f45d987420849e7b93f282875c58e260880193cb1339ec3918c0f7d8d4211b7f6c455362efaa951a9822db100f312972fbf8a4dfe1ab549b5b23ab15d11c4251b408135f92d3d550122fb3351c950f9bceb8cf5642eb2452fe9b04398a3e1e0ca6554fb63f4209b0d1c0d5e8cf8d7eb05e7ccdd6aa9c93f60b590f84258edc9ac0cac5b0f46f642753cd3561ee5566dbee34c76dc21b8904ade65f52db77c57a1f43271456070153a39d782e0d408611f4bbfcecb6003a54a966dbe79dece260a962ee0b54fedaa46a0a257c922a8f32a5dbb0eddbd701d55969df65bed9ec3a8794dac289c2528b0f527fd2a9ef33045379786fbd5db4e93c6a2d3d45b790c7350709e6e9f484d364ea78ddc59d72f7625642a4fc19aa943d2118080fa8d01cdb4f47207b7b10a0408945909d73e47224b21eaa7ba77a75dd3e9a7da1e650485138241fb5c2f207233146a04b3dd68955d5336c6f122db193031ad7d28bae0e9e5f4efdfbcbf1792b9e7b314a2f3912b6d33274dcd489fece0ecf969684691b4ee7bf87d8140ceac6517cf0074abb10c950ed7c6e3f83f8b7fd152f2ce830c44272ed210c0596bc880d683bc2039fe73247b54e7d0507fb91351a39d35116e2ac554aab118130ed2194f2aa2d01b049972853eebc737f6e29dd1ac94bccd2f546bf6cb71833b334313775e67c8711598400d02a22be83e08cf62966d57a080351a11a974e7aa62ed48dcd09a318e50aa3d57c329493f7f6c0ec74bc65bc394c3ccec43105d43d350053f823959aab3eaf2eba2c1dbd9fe63d6d18fa52f6726ace121f614bd34bf82da47946f09ce97767eb7621388ac796805b3cfdba65ddba368a77aebeb557debba772e864601f46e9e8254f8104073857ffe7bfa7536c2327be290e0691f8557f7f6de2fb6aa96665eb6942b2d796bc7a2b3bcbcc7fc96f157a94b9912b3093de87b980f0650725a6b7933c8e3236bd7505a60964de505dfe57a828b3bdd9105f4cae92487bb3c5c9410595d0662709d642db2d90e09438c64ed16f4ef6d6a9a82815abad5fd07df102a28a049fbc5b3df26688c28f8cc538fa7bbb272b77f02bcdd8a1c87e4c5e13f133c56b34e70e12c30b51e8caf4d0f5514ff454e9d3bfb27ba2657695072482986d16e11b599bfc01a3cb7f5f07a8256dd766ab36ab43405e7bed63b255e9393d47c42a08c4134153623b2359c0b1594c9b16b21db413c27be01244ef0c668508bb1aac00a7e51c75922dc50f32c04d7596d039b73c9867578d05215d4a6634d8f2e979c1da92868645060604705327adbda282e3caae535ca387d572bcfc3142da4f99979b1879e60d2c00edb27f90449562e8b353997e71203499fa1c20f75405fb90499164181586069b43f496e8ad612bff0628784835e4ff7fc3081067a2808fda9f8787fbe6c0e8eeeffc70d6330d83e7706b49b268780aab471c0f739950cd140653431ef5f16727a4d31e8a3096b01281ed8d3254734807f9befa35197aedbd18a0244b285d9f501f584778f9ae5b3daad11ae48bbfcbb313f8faac2fe0685481b7ace2f792f3536c39467115fc00b34f19c40d32f5a3690ab7f6d492a9138e541ae207488439720c86029008ae97eae0b25c7adb3512efeaa99a948b68b7e22070562845e6861b645721425ad7b8aac30f5e32a84a4967f9dba97e7928886fe5308fc4be95170a1e4042262ddf546cf4735e62cc87316a2fc7bf728dfe638e0d6b3591e2768cf3bbbe7e7037a98d6c8213a132eca62623726cbb915cfdba1b5ddccdd1e8056ca0c003066dc8c55bc37a6dda60d49195a0e24e2ab2e7b76ae59875adf83439195ba61a50f4e9eae4338d290af3c9466e2bf86b6974c611277c13004b3e3579604afefda9c03e041f73af714e084ee90073a169894a29779692440f39fcc82531ee16f621486c2a9f8687f25e9c2e8cef4c9a70292e754800a8b58d6fb08df99fe9f56855d55fcc0890bc0aa0dab87dac850752339c975feb80dcafcead7edd79db7d121d442e83cc2939e422bc75b139fabfb6d0369110538f2f32b9cb5928a6e9301fc85b42c72959a6b54b6ca13ba55755ec26901d8294d12ebb2998fb367a1df55c422fcc1098a14127f0d7e370cf0719580924b4fe7dbf1ceebb7461e4dd423c77fc0a1e94710a8355dd1593b90402035d9ac20bc7f3c90b905ea53f98347bca9680c41b7cd120665ad0e8880ef1cef58cc9a8cfca3b57a93b232bfc9edf6033a556a0f2010a9be3feeb6e59810e7dc0095623760452e238a41bd026c1bc7455375050161f207aa406d0b5b93b739659d9518ee02fc65dc7c7b1eadff102a136aa99201ad0c64781be38a0c9b108d77124655b1d151de29a7044687d6fabb967aed4366e1eb111c825c72e3f7d7b6b9a1240697008b95ea151c53183cc48a12261e7c2c19fa48a845a35623028f68f837fa5849b7f7996902aa0a701eae544b34b15efaceaf32e407cdc9f4261228d74a99d63ef3a4599aa560df7a7e1db2fb6fb9335bc813023126f06cde2d3015b71ec47724dddd9e70b01ca641697515c9644b32b7cad55262d170568c077fe76528fe0a2ce93da290d6f4763e666cc885c229ead87959739f703f38f7e51e4e4b96c7f01e970f496d0d02acf00503f2b437a6775d08007a4b2dc6a09cb726c4441b87d61ddad9439fc718721c1672d0b14da997e111aac33801d64d7292b3150697633a50ca97eebaed18e43a758929994a501d99c4f7bd13ad2fb9886e74892cd2fd9ed212acc2c767089d9ad4c1573b84f5f6cc2a22c9e20b6870503a8a298be280bad3a4cb0bfb40a84667ea95128e1c0b03961a1c995645b06f0248e77ea4cbe5a09d673ac74058ad44edbe5e88d5c760e67bd3159699b9b43b4ec8ef860e63a7b027e83eeb7188d294f0b1a7ea27ecf354c4e31c6622a57825d8c4921317fd6522325ac7c8073db669c60ea4c3a7a60b2d540fc109d8f4bdc4c1c3266d46c877e755e92b2cb205bd41ab48a88c1fd37366110b2b7d6255432715cf77e32703d909f87c81c6880a04f040c598aff720cb73d5d67b5d8512e6ed05994aa9a61f24b75ba7d8fe580cdfe45350a42051bad8ac482305c78731c198919e4bbd8a534f3b2b84e1481b60081b9bd310d12d321f426aa6855173cf0e4a17e9d28cb3317a32943fea512d56eea1e56adbc9e722dac5cd93bc1545b0dff20bf8cd25598b97b068723b79fc064ba84f2d4331878ba65e3b845caf9227efe7d273f09e4a9c61c626c25756bf2e9b15268ba484a7122abaa36e8603c1e75c497dfbd890a37dc835c293a7d8ebfc4af53861e97b64d6d73f52bf86a566542e67ab3e15cee020e99fb2aa112e1071f23b18302be05bd2cb097e3c75705780c0442ea8e84dc48baf08f94b1b89eb7aaed2235db0adce2f551187bd5b2df8edd8f830330dde797eeb9d1100605e2369272a96a9648a46da7c5d1929a316408be656f042b439998dd099c767af1cc618d05b6369a232d5cc8405d1f92e4fcb9af84ac6525a2b13027091b5a9f6a01c1ed7513403f6938533745b0bcae9a71bbd3c15da08f8ae38681bcd4f22e8ee608c0ec0e4762aadd85d4c09a08f158a8dcb77c1933134d89eb8729817a6155fe6f0a40be5817bf8c137fdb382724","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
