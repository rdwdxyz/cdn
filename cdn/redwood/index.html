<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"931d24d88f46e310e2355ed79f00faaaa6e406b27eab7d01328f444081c5afce27252e158edba09b345ce091d7bdd0219765d8c146ee5afc65c297efe244f08ee0027d15bd9581e20a58719d16973c1882472b81507750d6f6bf6ebfb144be0030f70cfd24b5ee9046c8406ab2f75e463db23dc597401f8b8d34850ac831c3b3dc725c71cdbb58b6b209eae3785c124f695adc3552cdca0f44f599bcec576eed36b69d86c072d7d0a2fdc225b1c04b2be8f8cfa1515bee37ffb79d9424589d0b5d79a8d12dd3ef6d45124fe8447f99012325fc7adf8abcfa3cf78314bb091244dab04ca7b9b496750e75a4bc145102a75c13ae9c57ec837e0d64658755296e3d85049fdb1d77f45afec3244e5c40372b9f7af4f802c5864cfb5e16095e1f002471b2854552b73a63a5051dbdd3de56e2eeb809f447e7b6729477190e7c2e68149044d84f711af61cb665c91a84bee9470bed72fe9a734ff3f6e43f20a9627963e76715cc69212460fb83ac7b5453f44334f6e375e60f3d0bbdb8f393fa7fc86fb7fe85a6bbbe81b9a6da6e3bccdecd89775c769ac1874d318dfdc9073e1498956e93b2df7599321bf48d2f3615d933189c1d69ae58799e586f7e8351cb305ec8487cf808b2f72e9beb77e4ecd4de161c137e10df5ab210d73828163cf84ecbaa5c056e864d4e5642e44170cc0be6cac617dfe8c55ad7042ce2db96fba81ebfad12db81c1ca9f69d571f23c6cfb5d6b783ec25a6b72413932f1bf0ed4bc62e3d67910ad47679364b49f207fef632ae73f11daca51c1f199a2bdab4297c64134fa0932776bff27bc32a7a986df0c9d9a91fb580584c3f154abdf488c981446638715b0f9a2acce6c7a90608ff08403b4789eff7a22b44ea18d5aa241be4de2a57c93354e7901af0c38ac3183e214f7ea5bfe8bcfde9b6943909b633540bd8b8a6315483b0aae67cb89fa8d55a202efdd757ebce5435c34c057c6d1f696b4620aff32cc2ac1a7ce1c4aebb562fe10d815d35d9a2671e247fa1115663728e51a0503924e3ce8f9f5a4b5edbbaf8b32c1adec174835ab5d77f22a4ad5332c1d6d1c10cf49f668166c828749c60dd631e55fff2ac22fe1ac1ae6468fb8493cf72a666a6bc8791905d3d1d198f7288f24f8f3c00bae4721e372b70aa7d03dd6430fadaab75aaf0c40f692392b299a34a88f91352ec716f8cb4b3f15212b722c12dd8ad2478a7f49ae855b1a4781b9e4fb8d2c18d9ab75d484451ce3eaf0d75a2f9338945173e1f63ab8d5fc457b17db4f3cff3b62886a33f5825a4f6901ac54987f6b0d7c9019c370542ade50b0e50c4cc43edc4ee44dbff93aa262dd7d47adb7d09180a69fb7e94e026d74cc176f4178ec73883203d81c4f367b88fa709f742d710333c53725edfd65ab4c402632b24db26d9451405e14b0f398fee59c90fa9537f9b606aeb3db5ba65370379959f4e2062604318531321cf6fb0855ef445e17b2c1dd84d5142505adb367ad6e20129458a96343c3a93047d1c0fe0308a6c33274a56782d44712402a95e7e300cf7af151824368f9475906e6aeb381ee2082780160c09fa3f07a82ee8cf3f18009d5fa3c9fe44bd286042c87c74efcafa05156358b9841928667815db9b0ceb6af94a42e4908b8afe0170dc4c760d1f27fcfefb45f41ed1628e652187f773df3716ead1c81d37b714709fbd0c3d5227007341c56be9be0d2c1cead5dcab6a15ce04a53d28b60be974cd01551101ec8363f7492a07d80483d4795f7b072ff1c6ef0710449f5f25380e9556ce4f3ce28695168572cb054c4684ca75d5ee39cb391e8bfb3bddb9b1e02907a539f2efd8273493e34046a8595ba68c60e00be491719b3e5968602537070521036ba4da5a518cb1b340ac9367eb9ff161b9cc0512e78d022df3343b57eb05123d27a4dc873bf36107023ffbde1a8f8bb2ef3d419255683a425944d513762f92f9abe42cfb67c98ebf50f030674cb0019fe9a63993f3f2e2e60fb1bbbd55bd5dfcd26916af9210f464825f75f5a1a1e1279eeaccb20a50749dc8047cad191fc200f59064b31736584c5aebbc8f816822c58ff152847527c7451f70a12dcce57c34baa907d53dffc42b41b7ad683ed1536e89ae6ba962537052355acb3f19f192ff1551a20ba6fe97fcbfb0271ee8b1aaab4d1618809f31fb4f10879f92ee6a82382db786176501d0789b8c81341db277a2b9d5dacc4cc07dadd101fc66d18eacf09ba46e757a9cad0f2048a3b95f9fbd40f4ab56c4ca60c1c20ca3bb1571104aa5e4aaa5696fd9f52211db370a5f92b666053e25e2d12e8c82e15ce327c3f2a4549845bd195b0e88a87b011ce9b32e96d5d3b59e1766afbb44480000adea8cccce74fdefc256a99cceecc270308518f11bc607b1a9ce33672bc48906cc89ac1d758f56b854a1d94e6900d45d7308c7f8b692a996c38f23f3794f773f782ca868aad333b8cc0f65f849b10a038d239e793ba5fe54877845fdc217b666cbb817986d50f0747a6c5eb542a9f32d16f2384dcf69536e6b95375852dcdcc507656f03f77be904dd5005e9c56ca3bf4c93ed5d38473d77dd0782eadf0fdd16c477e2c705b1e6924b1fb162ce5132e72555a728f86e91cb6de95bf81047e04882c44026a68e96104b2953b264cdc8a4dfac78a1e0942075add4fc0f6469cc309d54b7aadfa75fce774c8ea2151b97528013521f1c0f0b851764360fa71fa87350c6238a5a85ecc9a2b72caaf5f88d9f3b0a007a6786a1bd8bf3b18a3c5ce0b6b9d2ca7e8aa76fb69d2cd0c35a1d5c01aab6f985b533ae8d4340a73552a44641b98f3fcee30a05d9c3363e7029e81654bf88c6f2e6c7d111c27d7525c666723102ba110624aa82ef65225bf0904638c129016390c22412213370f07cddc8f620e814d9a6109792470e28944f644e6f471b534cffd4fd40d7b081d115b4d260119ecca0fdf2a16deed1075db5401db939fd9e655e893287d30adf03def910f5ab0ba49d1a07ea2f662722d485e241b0a13868870cd64cafbb2361b3d319651d7327bb12bb9a5f9b30492900d2388b2363cd4d58d69714d2df3a3e5c948d7741663c22ed37fc6fa06c84a4192e70865f80c1a43ff0976a0c7e0564e1c39be3804236c52b74d66f4354238b1b488a347a4a2258307f253da7f1c73d6e0e0adc571b1b80b2beeffec59c4160136d6d156f3ddc9710d7772bbad4d7f80f0433c3b35251ee1fbaaf73c39180e15cecf6f46cde07a7093c724241ac6c1220f984233509c05d1f4864abf155b4f10305d17c6ac82c266aecfea4cbc05c0b21da74c7d20307899e0309d5c919ea8dc8ac24037ca9697f8f27ae27dca1cd23ae82fd7b0912b8818abca2124852c45275c5445c887134b41200d1012cbf11ac72c19d60993d46a73f6e7bfdf15086cca3226ab302ab7f9a9d4ee9d22aa70432e858b76e958d4d078b737816841271210bd639edcca19beb0bf757072218479f26fb893c34318aa2745f32735cbede56c4f77cc758bc963c9fd8317540eeecef2e05bada4018ffd3c9a8fd03faff22663ee7a55769994b3f10798b7cf3aa29f2ca52d9f077b5a4a65ef7bf22be446033ba72c154373a07131f46e244445af17d1ddf772fc5e8a687bed42a37174b931009fb9f4d58a625f9ded31d35fa4ba5149519ace35f63f6aa3744939324867c053834483ce90e49df03b4c9f1adff66e134fed4efc1afe40af50db6df5289a7cd31216a17eeaba822a7231878bc8890606117a567376c65204bd6297280b16bfa541ffe442eee640879f6a0f5e9e3e1ca164c0dc33919b21636577a4961a0df1a1fde5d7b7f4e9c98099943a698376a7222747b0048c96ce5fe4cae396136c902e05c12b295c33b2e0a22283d23978febdb3df316096e1c0f7227b458340299b4b2c5dab7320e3ca524340ffb8b84001a28e606713840a8594f9771219d72a432fb9934223eb6f64fad0500fa049909ac20fc7c4723518c0b0c49c47fbd50b9ea37c18b3453c6c8860af5c7190773402f19164295eb02fb5795de794b783c4764ef6c7117d231f0aad83a4a85afe68d7f0824836b03fce2f80f0025ef0c138dd5435ff5092085d64b7df1c79d5f982e3b1d911cc062c388e84f02c69386b785fdbcb3ab4e989fe0738b4184570a02782b1eea87fdec12aa1eec30e0620bb32ea260d8916c6ba5d3fc9987a267ac197a1df52f4b25a2885cd0187c32189900a2f572e3f8d6c9f126ac0c31fb1050aae871362f67fe3c3b25920d7be5b476fedc46ed69daec4ffbcefe456f472987be82aae2070232629db2545e9bda0b4adf84755100a533bb0982aa964a95794e38aa0a640455ae2d73300e978a51eee2573f42568609c0ac723bebfd79b88ed54deae18c41f208b829c719c06fd9060b02f67734ce59c9db69fdc43fdabc93139ee402821ec813767c612c83968bf14b4eacc956cb8f831f848180a95c05b6f4deac440e66ab9c5afc69514aada270adf48d22759bf2eac0089f0f829c1259309acb3ca584766ebebc746f3f173726c1cc7e438f4c2920940aa0af4a975e54d7cff4efb994bcf99a25e07e0b9c0ee64892aa3586392d56dda4ca581f418cb09a433fa0a5855ef994312e8d31f5d36ed89e3ff9670d64b699d3ec522d2bd6225a076abb2c24153f83389ae451e9c934b937554272a97e1d4aa5ba455867ace02b1e30444f2b4c572de803fe82f05f1db06c65f9e358843176478a594fba549be521c35cb5a885ec147cc46ea5b11834a035b1ad4bad165cd6674aaf38b3551a85024abe4678d1d27c5dae2b666ab671f739cb6c91d6d79fd2283fa01afd998a307fb3e3ec3fbffc3786e6b59e8c0c6181266ed99ae8b4dc841420cc78968e68dfb2dbc6a16436458d77702eadee8432857bdad6bb6439fab1b4e6b7a48f79f72cac8264fbf2adf65d514190f7f9fd6193b7455f2999014b7b217f81d23a0239949e51b21ed7b641e1a08a1a59763d94a9112d91e4a122e631e01ffedb76f3b1ce306722f16ab67487948079090fd5f557a46dd9aa4a4a9989398bbe979c11f288fa52244d7183ec9f475587ed11c904ee186ba952131c71fa15af6c0de56e9c73c6a8eb80b1a78d30e55270052a858581708af04d92c837d5d042f80ec25eb96952e931d167594ce5897d3eed6458b56a032b658066e07ee32f7769cc5f905d8ec0131c9536df8051ee625dacbacf5da5bd44506331a1c46582dd0ff699c4c8827d9e74953fb88ef93ce2bd19eda2f0caabd117402edea226db825c1c422487c1abca622f0e7cd6acf9417433eec7b6a1fa692fb0fd2f7c4ab0ae686738de4eea5c29b0c35553a395102317228412faf0a8e89df333f061e450998baf94a4b6e8b2d3b5a8691fca5e831f28e15f49123fb9ddf206922c11f6416af61e53ee3623b65b1248e8dbabf445533b675935785a4b647439e4b81d5b94e6b0d96f8b0deeeeee576aae9496b430bbb64a51a822062710512df99157160035cd7653b1996dc5036f123f1cd884554ec40cb015ec7621d8ed1225aa0a322e2dcbb17fcfa6859046fe8c885d9b20cec8a7a8ac2f3064b2f92ed1c46d4ea4886997ac27c3023ee0ff3599683c6e616f9d058604cde6348c34f5eb5698cd868a4575b44bd1d0f283ac668ce5aceb78691a13b90ab2b2d35b47792cc0e32c39b4e447e1803336669d36a96101c38e4cd050efed26a3a5f83818abb9ca33c1ce53e88c91531cd36310a56f8396038ad160c2d6ea997d937399c47e9d205f6540a301164dacc3c53cdad1dd7314ac8594b1d0d6bbc4e69516f776fcecd371f2e6eeec4c326b8909685a5d08eb4c6dee16accf0a3902a3adcf8bc5eb4e3a43950d6b2b241047c3564ae9c0d502735f7ba7d7df9dfb4800082f49213c8d6dd90aecdabbb940868f2463e91cfd88ff74081e7351296b2c1a673cdc1c69f693fe1eb33bce660b78214da99b574ceedc0588d2e68ca47225ffc8e3eafb6d5d75bfbc9a8af81dcb9afd053c7b9eb6e94dce3faf8d8f0f98614f4b4d462f84a04e6e0353713135faf139e86a2d12b1b960860b2ad2cd956cb7db8e5549b0ed6a80ff4754cc4474a894c083780d4dab1c843c91048e2757dfedf63860ae17e18ec539b4ade0f50ba91aaf7aa5167264f7214bcf35626c237bd42dcf79333f7cf839ec1a29c4187bf9c2f324438d0ceebcd52ccc8956874ca1e3932f2236a8f57a01a172636472cd9d35c42ba536b93c57a803c46dd41621edcd061a867de1bd7f689e736038daac9c7c0fc126b56737222e8190f24228864833f962cc9fc48410aa18e7ecd4dbcf0b98acf8789c58794146c7a083ce9246b50cc2f900460e65541d9fa363ac8f2dfd748fcc1e1630e8edef9224062b4300f876ec095e8ece81f6cef7ac3e9d2c8e4fb6de7fb8e2dc5e70fd2330daf963abd6900dfa8526573e7bedaa9d7e1c166aa65ffc1afd26a81c2f6416065d231ce96680568fd1b1aa2882127e1de07206f97c49164a5b6f537bcd2c83163f0bd0bb081218ca0e5cb405fa554c2f236eef39e2bf82607d0e5b9ecb089ec1efe6f1d4a79e46d42a4b1a2fc569409e46b81557c9a601c2e0977fdadaa91af3419692a1188522799b2245a0aefb1052168bf53c78894c37e582e9a9b6cad3bc09fc7cd536895f703bc9c7d15f3050f88afed10c934cf74631073848f949d861f7f359bdd1391b83c647439bda2b418ee856138447b6bf9748cf75e36539011193ea86df721e68b31be281132d20b62ab7e8c635768148488afe981e37be6a1017066bc1006e289e7277d6d173349c57e0cdd05fa00ea112dc98998348c8b3334830681845ed5b23c432d71fa6e643ff53a02e145499c138c0be84c8e677aae0d312044f4465ffecbfd129b5294847e514591700d1f310ce9fd38335eec4d96226a6dd2bee90f0a9943813296bcada1a4b495a9098e4eda8cf1daac43208195566f4996f011d610cd7fc5aaa4e7bd86122a6d6a9acebbe2f6c73a85133193f9cfeb9bbe71973f3753be65dbcb35f31aebb89b2b1cdacbd9368c300fc5847bb934c16a638afbba6c6981ead21c0db1f993ebfa786a972f2d71254514653b443e0b24a68c0100583b7e68832d670ea328d7498480d6dc047b0420dbae21dce86b466988d9d011ff4161f26e2a57becfec7d58555625e438bb1b0f360a8f18bdaaed5ed40a2ba7f55edfe08628eb7f099def37ab1c64be179673243f6084c747546348684f870ae693f8c7e1581dd923d5ad7be421764ece59e2f25087f511464d48a3baf535000c216b9aaef30e63ac1267b6f872c9165230a95b4e92e1b8960fcb69f62f51f1c0a8f3a15826fdc5ae26bd3fea33c5f9f7b563943737a5c09a2ed5fe2c3ae7edd4d1901304a9835d0866b7820226e244a8dcb41ade68b61c190ced1e801e9e9a9144d9e5cfd52a4995aac5425017610a78dce342aa89235f4cc8e67fdd823df089e503d32e09b86c7f07342083ba59da0ed4e353b698a2b17acc614a25b47529505203b931f9015c02164e629589ef94025186818bbc292c8dfdd5feae491320b805f7b0775648b1303b9c0bec91b930d6a3f7d441a3e2acc62f3580b15dc776a279fce66e3732ee3dc0f9241170ad0dd7f4e5d9dc6d24d8c8be07da5a37945c37e6198f4ff0ec7a712e087e703ee09579049a026b9761af5b54e04ac0f23ce62b00652beafcd0d5ed1208e6ab067b05ac19a97018117a004afb8618804888e0a6a9b6a228d7bc53d7f64ddbe1661e251e6d825dd4eb3364000fcc2cd5470fde96eb86a7ce1223c4f7194f3398337fe11b95a4c6b5d6278b0fd4fe99ffc068c97cddba7653b5d935c056d3892aedb1fefd1ba7338babb9433fa302af2eb9746e1b3f64a2328663d2e1aacf9e2b591010d37b494d14728a488636e356a2cb6ab932248bd4fddd1df0e012fe8d3304a99f1e8fce63994edfa262e8f07b31ac592d022fe1a8ec7ef0706bbe151bad3de3760e633ceb4fcccc21aa649af3fe971e019c77ee01162dd4b0344270c0a839289d53003ec550a590249a0338f5b0031e51aa325b625f8652b13af03a3ac65c1098b28c5bb6f95a48cac7687eab3c2a98246663a5b29ba78699d1da4b873ba7cbdca65251a100634a14f16045b0dce2898c650051340e577905d5b7a727febde4b854e5f98aaa18f8821e43ad3134829432b57bb1e6ef4c31a485c3574f95308ab53c3b45555be8ca2dbc56c9a1e883e5af831887d20f7d8a26216e4f9f2d5b93f4f3542044761fbad581c381d9487ab0f9639192314f071a025fa83891f854f8558b3e44834ef8acd8f247c277e2f4c03e57c4a0ad86974a526cc4900cd65e72a3e72c052b3d933aa2556c4e3df1bda4a6b6d8a62909e946ef316e4f8b98a869161546ccc1bd9a18885a4371546c9cbd40339f39dd9d868a4f6f186567546b04979d75a2c520b70879412a55a59a33906d2cbde326f419aba24a32a04da74bf9e9847bc890f6a4c0c8bf542934f9229c81d51f2c0e180481ddc09fce90d26fe70043ece2c4c88a57e2cf845e7bf45e1d0b239f33cbae71c8a139ceb91846f797b05d010eea7e38d27e5c75f44243a72cf45b11b5bd2b8173f629b92fb4b7a09ad7e501881386c1de54e4b2ce108bd79bbbfd975643b8eb7cc13712259fe0abe8af6a63806362f703cc896270e94acad55abf2d4567cbe74b3d3d770314df9032c04f4ca29615befde95f90650e44b8124823fbc1ceb193eade969cf96af2417ce00807faae81c068815fb7132fcc11c1b4c916644214cf1eb457d86295d975636323a649a8ded4ca1618f5a9aaf169fc332050b9e6201b5b36906a4cba49863d59f50bf07f95f80e921c6f4fee8c40e942f404f8bea2f6ec6463761199679b8ffd63c2c78baab171ac24f9729a4e70b762ec87f28be7d512db5c0a87f853accfe2a5c9d1300b538372d4e55d4efae933deca3ab347b55d8bfb320fcefd324bde7642569b27ff35018521feda942444642e7308b4367061c4bf5fab308b809b9487ef50dd6ff7da5634f77d42740577d5f7878e66a9e2e4f7e405c5edb88d2ceb6df0aad1c92465fdceae802627ca473ff016cb541db0b3757f5f3d0b66cffa2065d09788bc877cc747b3881fda5220edaf6a82034daa89670f4bb6e26a4a86684eba9aecbe6c44391dd1bfc0bdeed27006c64d310d59288272a2c0ba3913be1cc78c45f17038ee574eb58cfc19d4d8b1b6ff560df006d0d48ab463694eb8f87b5ade1ad8d7e8ff7ac42d3db507f8547c9227cb2b89cb3565d113d30e2524a04351f57a0f60351fdaeb2615361c1cb799984df658236a0f307394450a7bef20c37ff8a12034b568e2d3c644edeb56f5eb387b8dc802b61b08f19e540a035f90873047bbd2897115824197afced3e961914b2bf637af79ba1df77a15cc365f004c8640f2ad5d598ef1a21032126acd63353e918e0a8766a2411c7d489becf48c2e2837bcf7c81373d0b96ad049ccb13967a9d4c3adb2e391fdef7f3221003dd153f5c842898e4742c7e5ba418fb4138c3a8b2148c83349e4c668b4f2a183995e10ac757165c75e71955405f70e72fe574542351d10f077ee6c7e44f3121485a84e47e8b52e35f5018a7a019960ed36f92d7f8c3a1301fb7aba4e2cfe03e6140d4fde0b867719507d8d0c077958a3ecef1af15c6a5cf3f1bbcaa5909bb56d7434521a998d144df6626a09985fabf4f3805292b4174ee375363ca4d55e5694b449f14dd4759b72b9066362b25ecdf21941af4e90469de00fb7f8e9bc588f4221971a8f3abcf7cdbbdfb38fd7730e1a5bd7511b7500905496c7555d52031aceb24b69b80aa8c5b9af6289297d4a9001a53adbef90c540e2f78e757879ed53a8cf1ed3e825390186fd616206096c45941ccf66d599f84b6742e2bb49c56ea9e3fcdc8f15aaa4d9cc773619fa27ad1362f352a65635b19c2982b3343f51de9acd66c1c609b6d457c51ce90dd47713c6d87036e8a13322a5cf0f645acace454dd1ca8fb70e8d5aee55688f4e0ab0d49fcf3b48166eab67de7a1e98306b414deb249d85555ba1a587fcd221d4feabc42f62b27ba45098c04e8e703a10cda30554839dd096bde51f97b2b5020e1b8ed8184b2e74cffda5e027c1fd88374bf82796ae6ba28a5c4d4511f8bce52a95033f45cce2b113f89213cdb392daeafcea50d71e8942872fe6aa0e85445d366fdcc4928ac6dded0fca56090c85a6d6f16cf7a619f28283402a2142b64e1976a7d8803a955da53be66033edf0331cc860684192141670f24168f85855639144f0e6340e56b950b9811106ba28e8ce334b4599b46dab54d6fcbaaf748b32f875f9354293519eee01ad59384e7c5f57c69c95ad76a12c2c9858928dd702d97cd81381ccb315d0e00bb6e129df7416154f04db595f00e99843e998219b298989f5b57a7e6b3e4372627dce4cab13080574e09f2dfbeb18bd69078bafa0d0c79d0311d579621fddf9a2a66be31c8a1652615561b5a297742289ed6793743502761d56be5da4de7e5c72cc94bbba3bc798db34ef485718d7a11e1068788c6b98985fa430bc3d0d6b8727e8465b09c9cb0c298ff11860c2e9fe2d4d5ceb11a44462d72e26acb884974da6d878d9e80b640a483e1224c1d08354e70dfd2fac2a4d8486bbcd1899d3e6a84d05b164dbee740a7d7cb5db7c0851d9f5f739dd3eb85c7b80854b83591c3d530bf6a77a16a18adf9ec4f5365605fe303731c16175ccacccd4779e81e5f2d27058eda6969e3124717ad8ee0d038f430b11b07da678ffe308ffa9d773b13948491bca704d1f5b2c638455c658787685c7e2e253e15cef619af5d97e8b1c97c806e7e82265293660996a3f088cd711971136bcf457f9a65258cb57ac645963dc16a27ec770af1841ef9370076645960161baa9a7b8201886cbf051e5e0f62fd543efeccc40bf42bf2d828cf4b3ceca78af4996c2755acf8cbd7adb50d1087b388b226a1b8986df8245c52b3c79fe7132804af6e783c5b8b1a8dab74aaa55240134ca2cde558e8f3d9c112eac848176bbd84e52e5367cbec6f9d36fe5c08e4b13ca2a035e05d6872997df504249bc6a14c663da0e781710a8443b23d9000a4743a4898135a56dec19d80506f8ae9d4be67d28410cfa1b9f4315fc601c49464b030a961c866198b85cf49088fa8fecd8834dd214cd0a0414d432fafef6d09bfabf429d4b02a3e5c85386f76a34d05aa058823f5bb71b79713e81460f93ef2240bf78b0b7814f97bb5c72a18cafd4c866d96d056607e7eca2445ac375b0b8121ec4b2180a5a485f5491148d20d4820f1d6e363ed325158828413e82eaab3e0b78138bbefc9ffb337b6b44207a7438ed36d468c3a497fdfdced4713f0c2c1d702693c7b13732034196fe0677415e1abe7579308d447fce35b4c3884752c7acbde945580843d0d8c38e980b7b41c392200f9fa809cd61e6ab91be9413d834a9af7e1f36d179178524dbaefe6cb492af37628da63a3111b4c13ef9da92aa8614a3dd782bf41cea2ff8af537590c997d52c4bf96d889815d916643b35dca86d3fe2d3c6f4d1ed1a6249c74cc4a43cad8c3ff114b02bdb5242be3a6d836d198ea7fb03d50a6eff1cd2779349efc7728b2f8b13c87c1aeff4189534b7533635a51e2433d7c145bddff9e76a568d834e542d9c93011f561c9cb3c2ace6f5bfa7dcbad8f901f91504d06e4060df60ed776266d9553142707a60c1dabbba7788b703b4a49684b4bfe02b12bdf01a966deefa45a5385b3c9abf4cce0e633b0e88362d28213d610adbd9f3c7bd783b9173eb2440da8e8f30a6b7c7be3eca4a108f3a38660bc6cfdfec712276ebca7edbc73ff1482a97d7a4030902a32b8dfe25236d223719897c8d362c8f5c0037630f48463327ad9e1cc946ffb3c5ebe5659e6666a7b7ef15d075cea61a4a2f9fe74d53d16b77a4afb2886a42b2fa7160c3c3c10dbdcfac9e7021c334f1024e1cddf3370a82c3a399d60cbb22eb803cfb9b60371d9d5373c2ec01559e5e69841516de7fd061dd5af06a94056e7ad080c26f104f7789e8faff86632207a0e0acc018f770797c24dcb01a62a5882f0353d1b2edd539f303ce8146ea27b82b9262f0a4a688ed405b5a63d3e538d696b82af07d92db07624809c9b9e75ac3c042adf480382df7741708e1ac501e14c044c67c8aec50257f4da47cb21a5cffef740574791b81296b96a9e28a137a38edd1ce7fac7bf50250f910813cefe43603f3cf44b44c6087f2d81cd4e2c0141803ec8bac504eef93d10ff509d565c74e54aced9c0092e00c2c637b12dd0d5e2fa5c184efab8dd56660e5ef3468685d52f220a4063975c1598d89ad9a34aa0cfc910df29e7ee15d5aa147ef91e5dec754cf835c14ac23198a9f699fecb0457939bc4d797dec8f0d30318527517cc3764aec927647fdd0c356f650f061c478bcf2471b34ed7a2fd5105dbd1c46f73b7700c2151a9c091ea2c30d3a936ac54f32c7f4b994da55da224032d6eb46d73aa3cccc9f88d972c48ea3b59119bbe80b31364db082ee5af7f08288c23779eb56b663b09d9606e20c407194f7f15bdde990c1221fcf9ca8ee01437e5a6a42b311f743eb796db1c91f7f8619bf5723993fa92cdfee4a46bcf0d862a5f1d6cda6beb2ebbf1b6e857930aa5f46d9e533981b590afbd3a273087c19a813957010571b9c1890c101bd451b0a578bd6109a6ebd23884c477de4ad420f0fafe09c2118772522261a804fa5d8b6866f81cbd19f5da6ef2de783e4f677254fa8161669a812b94b06c76503f25c6cb48c4ea979c1c5aab4174c80ad32b685a5679b1bd146a41cae376cb49301a027c68e6837627798fda83dbc7ed230d99c1426e48af8eea043a870066197d8d262727c00a349984f01ddd7795cd3211a71d33b7118c6794d02e8282d4515125b77a5028b61458b4f681ad00ed62473dcdf41a7fcf69e21073aed2cc4d858a1356e00cbe16ffaf4a2e14eac30ed24bb9a13bc934b155261e1e9d8a5804652c84cfb797c90fa9c5820796b2cb7a21f4ed2e19a37c76b86b075e05ac4d9cc011114ba8cfe9bc409c83c6b6c42b7d03b4d7ec042c812e0c73cee59cb10ba088ba5bf456de68c8f8aabc616424d9cea11e3a9d8d5eafef06f790c76fe09c3e97f7d18c0487b1aeb7d5f5d6f3950db989e570d9fd787a40287d1fcab742bf52c7bf5494d81fa8fb71ebbf2530c4f958aed4afc909e5047c338f80904b32e417a509b6ff63751be7ef5423c952dc8b43b5a9672cb7c006ba92dbd9a951eac2cefde5f10c0ad5e8a5dd59dc6b331982e7c453fd36d3cb894c110ccab84c4713b52b2ea943504b9437f4743c3d7b3191e4e86100d3c1f3b31e1ae9d3d509ebf6c7756f7e5fe236edf48efaccdee97699f7daf2a3ad67d5da2149e7e0c2fd337ca2b0bc0b9225a2f13a4962b70c7bc4dc0cc9037993112014bc872bafe42fab6fc0f9b7c63a9bf3a226d07c54f4b7bdb7ccf49fef36a66130d3bcc2cfdbe978cec4803c932009954d592173150a83acfaae327e3e5ab21430c344efdaa58ad94d50ec33936dea131bb952d5ed81f4caf4a74f5ec613df28020ab34a7bded0693dc57a330c9d2c8d833f01089c368b5b8d8a84c325420d80dce0481cb170d14c55239b454895371947efc88b3267afdf70db3b844650f8f386b56902a3a3dc3a85a51efb1e30169c8dcc133aeafec59bc5e786b337e880e23ec8b3259315384d44b4bef020970c0d81765c5b63a82bb58e1203eea1e8db3feb1aa091b072e64de93d0719400c6842bec367bb35aecd26aea4b30255b31e8371713f3172a5338c0cb84310ce09540e64f04343f63aa35359a72c55550a4eb61f377cf40197d70403b1a7d5a13bd09324cc173a5648d69ef36c66219929d41fa2f83fa643799ff0c04ee7dd829cbe785d428f956ec312e2ec15db603c85b1a85018cecb5ca44e067d8e2a9a2f1d60ead03de3feb0f1bc9f0fc07b7bc7731bf6c00ba8d8d82049a5cbeb5bb9a64acda29407afbf0c7b8161fcd8e8790c989ebc94999f1c6b72f137ac341b610aca0e6b3e7c86f090847f9161fca7aadd127b1a9a14e41b3af618623d5c5f017e9dd5cef334db5dbc236333cf3a5110f9300046345ac07252ed1a11488e77db0ac7b2c8b2511f0366a6213435f24c8e8a5844a50c533092a40eafb13a9c16992e23bd2fb13af698283819b72d03f7ab0d9ccde56bd6b699c6131d2090a2c773dcfdfe55a229715a0f7aa6362d2b3be1507c60e74e8c71f6cba269e0ba45e5f850452943c46323ad324aee0fca030545001b6a92e6c4abbd0399057ecd9caf4ff76479a0551b7a79a9a7e5be51fb24663034c903f8a67d40e1ed54bc17a46845874d8d62f3021f970b0cfd737815b1084c9c7004e626e2020e5689d6606dddb3941bc638f8c6367217402029a5c39793639fcfa54fe9b75bd3478646e57d782c94b6519fc4a23dadb3bb99f18901ddb6d9ef89f4c6dde056cab949b59ebd89fa60f7cce9e8855e8c7dc5e26787801627f9b47b8c0918fc5894edfcdf73a1c2524af9d294fb1556194a67474974e70410d2e16be6f872665363d7d0493061297ffc54687f1da9d8bff733e04861c7ce532234ae0299ea1c7548a28bb577cff34b599bedb98f4f00840f4d5e49b55bcf5f87c6223d03511a525f513d1c648204da9a77c307a1b3302808c3612806cbdc6a25f2355578c9afead5308edac65b21c58e034551889104ab8e8eb9a188b818e333cd3939adadeb0c698be423c0f2053552a760dbcfbc24c8ee90369dc894396448e7c847f4cc99dae94b4144e7006e8c04302d72005156068933ce0a604244ac07ae037fca13ea1ad442d025c72c609770a9dbf011d9b75c53c695da04c97ab091656f4f68ffae237b7d44281d6b0ac95b0c017cf8aa83e885751c6cd8a92a66d9541e7165d92a03f685175fde207f5b7271756d7b5cd7f813d9862103e52bebe380655b6aef88676cf6cc9e4c224fef7914b606e9df7fe8be0e457c462f955da5ff046783c1289a188d7e8a456323cfaee32912a098e4529a686ed30d33e8eb6838c0a3145b301f011bbd7b983b1c5f15cbcc05081910f305f426bebacd4124b4d81e0f7f8cb48a85547b7072b03d3f37a4ed985e5be19057f63cacb193e7d1f058a854eabeb23e712d6d1eb35fe1e0bf11e161e79e6b431858ae620e7db70163647a85948185975372bb5631c6ba234058a630d655a25c2d98f193034f5e1827701681c75d4282b2b177d2e863c39a66c229e429511dfd11fb1df2f542ace05f81d89a96db49bacb2ff940e3b59426bd35a10cab149257f83aac468e76eb3ceec16f3544ea4eb50d6cbe17b78cbefa717aaf37684b91bbcae4cfc35b83b293b0003bacb1eda7d3b8cc0d815c4a90ad0c27205dfd57dc902e7598215479ad94337bd56c8c909657e89b38247aa85f32746ec4f810523d20307a466068b9d3f4064bf7e523f3c7a02ad8675c17f3c7fac1ca801afce4261cc1ac0c537d7e20c2ccfaaa09fb42f387f7fa7cfafbd3efc0d9310e605d8821ba1637d71002d61f51edb7c74628c6e9117afaffb9e52cfdbfed545249098874fb96ddaeb3945ab91f55fe60c3aa403c92d337fd8504cd19d3449b3d6e22f02e2121f92fa7272577a73cd6238aa4c13e8f85ff6c3892812527d368153f4cffb835f75c2c9094f18aa790964443a72b2c0a4e339c74a47d80c79ab2764ecfd47babaf3daab105fb4994e490254e2b4890294c9f45403f2ca2a519e96573f710ef1db6a5ae0e42f283a096e34dd1d9fc1e7636176b6eb31b690a20840523c447e545513b3614bd69a7de9d5a334f4db286d797ffc459c7ba6d3131e8357df880f2a5bd04268625973e483d234e70aef6d239d8e5b6990803e08c3f2dd2cd39cd3dbed51b64f954a51acb6f38e9f1fb82243fee0eb09423ce450693db642589a7b0025fcd4643c9b5238eaacdca90e19556cbcce651bd03071183928beb9f04fb4f9ba23fa356a5f2766c74404459f3bc8eb881a8c26cf4bbc3865223dbd63e040a59f5809fb4f89d8c2820e5b4cf7f490e4cffb9fab24840c8a075d0a7b9a16ead5b02a09a594de425cababd3af20efa0ca2677149614ccaa542ba539c0be58dfbf065e3442ecaeda840e8c09570bbf9ea02069a4480518ee2053e36607270a82008a4a3b1f9900cbe4ad1c986f5ed7b54ddf7bee59e734832a91edba5239cd08261b0861ae78513ac30cbba9bfaf7bc527ded514767fc464333547c94948fe65e289995dbc518476fcb2d211f02f518478032e8c0d8240401df55d9263a0fc31137472a11778819152acd7492fe28c006b575e09580e98f0c38d8fcd730c549bec5c68ec88922b23c13ff0d606f5d3a0f6658cbf80dfc4c94319d61d65da814ee0a416a9e26b68e77eb90bec9b30f3b239f1c38b4d794fd1e177b0ce11c573c520358c1feb8e05aae346e98628883f5a926495a296ead10aa9a58975a6de0516017f4ff3503974c8b9fa982849b632a49f4df48822ae7693f90ab89f576790c7979af65aa3a01401be382339a39614d346c5d61b718d8eb844c3866af079569b0a8fcfe3e4b38596bf0438150ae2527a25442e0f1a750a4f72cee45bc203ecc96a63428a68056aa2990d270634edf0b365f5614dbfa75dfa2e4e9cef2a9c85519db009606ff00c4fb289f3106989248f2fc08f309ee6f270b121686155f1df9fe081dfe10494e84ab8e153da80c51b2e693ea2576c143a7e57926ec510851be51eaaef1dde7c2ef1f1735cdf1c0fe90200cb6b87b3b6ad68ac173110f7a2c0f8b819d77308919f2381849527385a972368829ad1db10687ca27b9819039130e538521b6784429c9d7db8898db0aa78b2c927e2070566e17ba3b976eeab8c3957ebbbde60ade046a5b265bacabbbf5da430b09387283efe2116a46db263f6ab665169374c3b4f2b411aa8cf0e08dd4a39ff49d0f12ba6d7f3f462900269213dbefe63f7f5abe336f21f94f1f0cc9693a541028d58a73c48ff3229a1d97b77b894b3f16ebbb6f3f35c53e107d7b84c2907584acf333cc67d299eee5de80c1ad8fda7ad51f9131fb64c55d0be464074d1e382843464b19a799febc9c85dd4377ac51b8c3689a35dd656776a20949d564c93103e9c160178b576606c06a675dbe2c6e75de09a4af6e8443d02160a2a6382ae571b86268bca6d6b38de207a64f08ff845fbf7c3e7d8fda51ec36cad1e51f045cf85daf3f77406a2f59d15e8b64c91f37d9da9722d20e3bd9d9077a9ecd217f51ea179bbadaf024c15cc9f186b616b5b0eae14012c7b0dcd9a32f873187547f916ae42698766db5ef96b9dfe086c50e14d6f5d4518d474078c44f472c5683c8bb792bee9c6b66a5802dbde409cdd5f8a3ac2673a63ba349469b477bb201e5c2dbaef13e3545dafaa0b4f2dd2e599e0b1e5bfcdaecaa766e5b22e9bace853c8423d7a12156ff74e7d73932ad212f6ba9c63504d52b70d36786ec5c2bcdeab244b6784329c28fc234ac05dc9c6ee6134e552a60b3ea99e006c53502ba1311ab769784125762e14095805f8d52a43d828b887092594d18d37d1145f0037626d308b0379980962fc6404743f11f4e623f677e53f5f2037c809d03caea279bf561dbe5f2dd923c8f52b1c1da7b3bc9a058600cfe02563f40ead742549642ea7f49f73a6057195c711e64c46f738145daf67d83180f8e08c6737110d62c777d500cad31b77eb6a240dca9a5578f49db113306cd7e18ec1b3a2816ea429c4f268ebf4af12d7ba3d2b8eb5dc0cdd07a66ea88b73fe22522306fa25754fe5264485108f93ca2cfc77519992240c4138b48e4642b72871d498b8bc6f283e1f9b4a658aa4a5145369e5417843429f9fcd87f098e5f8a3d00ad407724974ef939607d620b6458dd4bdbef54e7c317e8806619e6d48c998dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
