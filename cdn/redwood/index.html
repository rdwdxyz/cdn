<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ec11aad9e2b66faed4da06f5ac135f94b4e1791a4c113ece54843a657fbd2b6aa9953053b81dba714362eb44e6c67a5a7fbb9b4e2fc592ec9c2b4099eb481b0e528f92141b71e39142d561cc944d6184f706846b547d875ddae4f060af80e3eeac7a99f5ffc5fdfe3bc7f0dd19e220e1564cde5eb42431bf5b462e59ced003f4462f4279dc13ad9ef7a616b8f728ec3d26d723bc81f2539358c4625d901eb31dc62701ca1f1dd5586aa5675d0b131b5882a22ec3e4f1eac54f843bad98f7487760cf376c51ddfee3d36edd66734d9910fec9db12b4294ef5f1e824a2702c5b66a80efb86a4586cb7e05e0241bef656fd79bb39ed93f2ab5d79a908ffb709aed080c314100a5b3fc1dfc52df7b0be904b21004985a1cb8b72576aa7d877f949096992ce759450ce0ff42887d1f682abaf4cc379571c89b823f87dbd4d607c6871fa8cc393d39712c7c14ebd2ff4416ebb9470b865996c859141d381dac9bdefa96e4bbff2bb387c494565a325a995ef3c7cf851e304d84ae00afb59c36aba587985cc14cc38e24da610d77f04d924539c2716ad2e28956b578714e13352137989597a4b6d39d3ba6dae6053e775667c9fc9f4f74daea3288db26a173f432329f759a92cda1fbf3691d20c0d241044aa601389fde4d0061adbf1e5c1ed073a2f8ac86ba0befb8f571eef21bdb80519e56f2692e8ef7c8a5da9be14dcef46f0f5c54818a9503a388e69f6d41d26eee1a021f2e01ad6af6468ed0b913ed571015b1b6e297e307ccd6a1f79d0aa3a9b458097f4c58ee494235fa269c834ae86c252c7b2aa00550ac79795c451d6c22e968c5c65710381ac9a285e3d79c08fb6f87e76a16581e6e61159db1683afa9010f899c0acc71723e98196d30635b8794b351e351c32a9271abc7da81f057512be1bc4e673315c8716f88c7dc3cf4dfa7a3f9f41d20c6a1a884d362e30ada9c8b29d5276fbdcbcb2eadfc4e08e74b643947f44bcbf31c453950267f20f7212e07dc1d9d06daa7ed20f0d4d7ad126bb7e12840e5e71107f92482d332d42f3b3585526076b1c643623f8f73f3be1d7e3a90ce98750f7fa1acdb4a830230c48e787fe5b8d5f44a4db973af74d7d018dd74a831a4db030795ce7b791802af5e378cddd199f61ff2e3fc73b7c56191cf549ef5e68a62e865062296dacee22c41e508f8df6600169038f610d41954928b394ef67ee3d6f24aa7c8f3e25572b5b0185545f0986c0b46c50fa882e94d715a7072a29d6b6b40b57b67d09da5fe54f97d6a892f67dc576fe4461d1638b87cd6e883779e17f151706616454dd6cdf3c0d691f7873c01cd7de1a11958c4069baabfe88b78fd4abec3e0e33f13f72342e4d98996ad83f7bfa9bd450c706774a8a58bc608dc049b96ffd77a6ca2fc6c12c7407249285a98cb4af554eca7e3e1f6b4fd5050061b45e9afc0d095d93b27276e10a93d3b1d88917f56211a665636157a96c606053c731307a426abaed47ec79f730946f24b25926246f9579674f62afb58c5fd333cc63a439cd3db2f4c103f6111dc2b40a6a6ef1c51f6aba3517501b7b77bca4ce6001c8a67471b4c3a965eaecaa5211c0a46ce40ff5133bbd263e0e8ec047622b79b311f3a4f1d686cfc2f315b1c70448839612b298b80a8de04b9c09eda3d8bf8f0279d1a1c0ae9453687dcb8c810650c0302e6902c1fb5b02c9dad001aedb814779c83d3e304cc15fd6c6468707e4b394700f4048c7b694ece9266a0c086decf14f9b3939cccabb64fd130a04e3e294d1aaf03a171103ffacdbca6f233a4d10a49eb15a651dec441462dd13069650058bf93d922785366024ad8b14598b96c08193b8008d7bc6fd2f2462fd82076bade29061ff075517c6f9717179c8234dedd259b20db48582fb4bc15dbb3a5daf1381fc1315b69c538d7df1e278937094f082fc82f79faea2ddebc6dd28f68302fb439b2cf0408aa9dbe4ea70e6d180d098b4a43330ba8be2c3234c5e5661d7781f67870b07799e2f4df44732f3690cba9342b6c968455dc9d69065d862d9f6fad6655bf91f03dd4a6ad8182289160e87f710b03bb16935dc3cc429092673ae263824e5412ed29fdbd252d69314b1aed235d29125042012923d4f129de1946c8951f2f4826c0e5e99f5333e8c544c1d6aa65412ac619b5b00ab6322e251f58a965fdc7d7560c52341f74ec5ffc2d212bfa796858985bb9821a58936059629dfdbd2181623b62b11bca9aa780c2ae2310a31144a21acf277dd413566b8576ee9d416c9da3bfab29fbd8e3b2a1e455001da4c0cd1445655bde2a146e209abaf010c3f56f67e8ea31f4c719528d996783ab9945280b3aff617d68de286bb6349b091d5e009461b15f87ce8e4ad2a83f08790a2b5caa537f77d98ad648382743d75738e473ab38a78dfe10301b7cf8af6fb7b588f5e4accf436aa1ee83451d80abfb6fc8d902095119e3d62da8496e4c9e9e5312609ec8240db20e9f5eb5f35bc6cdf5143e27557887588c99390d986f0522b9e964faf153916c568f5d4db6517d16bef91cd4483626ed6f5b1786a9e0fb2d3d3dc891c19b2353732f67c92d035489acba441f3ca160dc971c6c6f417ca6db507450fa9f7e718dd5f303c9b2043c6e103e2a3ba3bca7c8123aae1c6f11fa15af9a4e24f0dc403846e58888f8a42a29a696c1043fb24e782217198da2d5c0df18cd52c9457f8e23e1b0d8348ffdfe55fdbbee1879d34041d511c94e361ae5b8d1d338055ef625d70200ab5efabe379df3423404f618824ce3192f3c3e0548bef77cda7fd511333dd52a277a9e84d6b312b8ad91e049b957851a0dd0d1f485aa943bac1f320b5c48cf06be3ab813f56b635f0470ac7e934abdcc38af1a92ea38ee6fdeb821283bea36c92bc1a0c327e915cd2300f420719bece70da65662cfd63d2b2c92674dba0c4e040bda2bb2e4fb2fadcb2caf690c513947d1e997bb02cac73ca8191fd714597df640423203393937f240ca9c0e4c9d7d5e0dc2a29ee294dfaad7b257f75bf092ea80ee51fc789c731d330e50b907b03ea85f7c6c08b4ede2aa168a7f7edf2f868c629ae7936dccd0eb0fdd84f266c91f9259d862c9e2856e1826a94f01cbd7807b69b4aab1a72665004e079bab7eb037389f9cc76993934f9845761a6fa22a8b9266699a0460f9234f00df7526f4988efc925a88c184424bda9dae481bdf524cbf6f3b81e1a6d0eb3d76a837b62dc38d94edceae5acef8ee5b6b3b32cd50122dbc0cfa43b3d9403a38d6b5ab6cc48b23de81fdd85134205e65ddbba84200dd5e0ce4f8685dfea32702cd1e488272123c40495994508de2fc2a394b09fb8bc92cf81e63035e549b94209c29af6d9ee53f64fa048212656712dff7f5d94f82ba1196d9058dc62e4415a23c20177bfed52501f0748ab781afd5a03323f06ec4a22c4d1a22f03fabf421e2b3870a71e2be409ed1f6e56eb995a5342d5aff3d9fac6b48fe77f13a5db9d3f90765085243e73837aca986b84e168ed474af7b26064e238a1feed4072b237810b30ebb0b793ef47500b757b354dfe59f31ac5828bc448d995c6dcf687637d957510ce74e0914ca3357f2522eee0660aff2b64807b6a92adea637880e4f7a18dd47f617955a38ee3a84c8e5555ab651382780a6ad25212072f122f51cd2f5772169e8116656060b8550c93af7e653ff774b151243c94848dd74f2bf223a3757d0aadd29e6ee2fcc364a0c6070f90e3103ee242aba237e6dcd49b59a66a512b187c3954e17944f8c116fea4214a115d91e02c7996bcf5a6a13d7ca56130e8f56cfba51a98fa035bb599f30f568bd307b0eae5cae580921cf6085e1005f987a5d791efa32c6e5c88782361723853756013cde6ec418b1315b68916750e86d07caf92f86b40bb585af6fc11de033cf94446af1d735606e85433a274d044c2c18880535626f9f9e35db8a85372d4c013cc342329e724191849a2fdeb1b73be0ea57e3051be66ffc9927ee834cac25815f83902571bdccf24abb021d2c823a59d9f796e07ddccbe4006c460eb43c0a69ccf328e745b4fd73f0860c43b9235d44aa1123dfe93f7966f432feb84c9a3425b456ce07ffee1122d482dcdde5de5dc9d2403bb1a06b73dfd2ae8a0c2b2561328e469c084f75cfd8bf3759ed6725a56e9c79fea1ca7597d8afe0c98bbec88350faedcf8630f037aa38ee772f1ee2f21352f0748454f4407a1eeb3d42d1b9429246e954eec955929c18ec63231ed0e51b1eb710530da1324ea94c0300dc29ffcbbc2d6bf674c81129add4bf96ed98e896422f88725f2f514ceb2abdede469a2da4d9ad21b04f339d1a0783cdfd7f7c4906f4cb7d28ddacccdc672197847eeca68e179acc8dc00d144b04b37b71ca080aac841cfe91f4ddc4ea50b7324a3c5624a5868c49c055c6bbd60420256f63c9d16fc2a9730605fb9b18ebf2977e2e9cc01e215418ae349fa2374c6294e14bf0f51ebafb87e5aa8a04eb9f0068db4d9a09fb43f794ef3ae68433647d00a703b1d41250a64db82017366123b14fe2bf4e8b9b7245f263340c9058f6168993291333ff3621ecdbd3e18998ea6724569e9f48062359b3a4109e0b4eca7d9988a46d8a6027490ccc9a477db3b2558700a4ea6a3a7ecb4c616e653b8847f7b4165f0719f431955bc1ed4a2911c107f422db670a83fd6d29eb812b4433c8b56b24899c65db47c762fd7f6bc6359e2fa76407b4c14214a9b1b8f796c425b1a21577cdfb1939f8e80538e10ad3f87ce077e8d27314bdddce485cbb66b86958cc12fd7318a21b08bf335858f413cd52d08aac08dbda4260dd2082c1c0b3ddc0a321c4f1b0a24e9e501738140adaf73388808ef16d46563f929d55d13106bf491473a2c0a1f3320ea4a42b1f8fd7959e67cf3d910308d72266ec7495bf83c78dba70ed35982dcd26cb6b5d51f55739e6a3e5b19069fb94c743c33be52f35eaf606bda499b9387b589027ef2efefda2e7e4f68b659ac1fe976027d3d1ab738716cb9b6bc065327284adb89391cc38667ff3cd7be2b0879e773cab381907ef3870d138b382bf626e7e54347ac39a4074fddb4882830fc7e5657322c713448d92026cd07b195d07b6469fbb78049767c4ca75705f6a3f1b01f3f76fabe15fa849bb1a7cb5d7bc255798740121264afa02e615763f5ec110be8ee031302fae0cccc9871f23db51694926a40ad5db49ab1720da8ade4076f2f102bbb8ff2faed72dd16791c513b02df8db9d37268d252b85829a0f60b99d08c91f89a7f24c3c3d56cf991cb022de3b5d048fe2597f0e42b42559381ad55ac0be0e8a44688a3d21f9ceae56a1fac6389d1f1c8f7242e4d6cc075788dd155695611bf97653a7f8cd40cc2f95b9fbc272e026b66a1bc0dfd5d69cc4d66e1c994ed980af42d9af4c4d6e6262b0124558e0548cf09203d2cf1049160f8e3b76cf46a4082db8f05dcc75f71f97541bd42cad5a7880090f95dd964787d11ebac3d437c457c3aff269491ad0f6f41086487ae3b3ec1547c896ca3cafc63ef2ca410f4e369fc5d27cac940cb74c1f58a3fc5a02247665279231177651e8b7e5b8d492cd8addccde001d85c57caf01f05a23f6f0f411faeace3245bb33e4c4e41e3e34662afbc4a2dce7651dbad7ebce7bf4aa079190a7250806dffcfa319ea7d316e501042993a72b9b55d6a213d837875154e501bb0b9e665d515918887112e44fc28fd0492811b98b490a5b704d9110bda6d63d8022e5e6f284013087b65491ff4fcb8e6e8e4afa523817c82457d84b3e51966d56cde94aff9b6e9becfe7ebd2082b5a9456053b4518a67d23c1aa6a656218f9ba011e6208182314d8d5e198eefe5f3af4b58a48443e517714c8ab1bb9b89a22b0886c6dc3caff8e6b829e59026424259335df4bc869c46b5647b25791fc2b04abe2defa61c4a2874ea2181627438076f8e50118b21c019fbdbfb80af388eed64179dadb7ee66f7b03acdae6f46461a2276cb0e5aca2291e773880de2ac4450aa33bf3130958b54a37f01e9f9cfca01164acc756c9005a40f8c2a8534977c4c1b2b4fde7c005e7e9b947f593cd96a992fe5ed9a071d9fb8c8dc403f4a31dca252ebafc2066c38c76884b4626e8d4d47d107ad9a3b0b719389ff7332eb71b83ce9e36fde76da9886ab770be5ee5b9ad236b266af4c87bcc80ebcc94b99ebd44c49167ed852d8be932bd47d9dcfa03108c9560970304192a347dd41bad5d46832283f59732f064687a7fb86424a733c47d81fde19e1b65ec87fee1b717462fdc696d313ba7cdcbcf42b7c1424c0249658ad3dc0913f82d09b78e5bd767d1c9fed91ea1d25f35b24d272128d284e601e9d8bbdb7360b87b734998605961b677db5f43ee08d0460dbcad72f1eb79f73170e3e1355781b96e88d5861113aaab41908ff8004a2dcdce4cbecf5d62b06ed579df7a92f25f53dee667aaaf95f54311f426bdffc331f8f5a2432fa087ae0ed134541c2d74951da6ecb367fdfe1c7c693a63ec09732d184cfc2810b05ff943a2259f7387f43f01f00b34efc393a131d6084e3bf515a060aba8f737c18e44c52166b2457ca4b3113ddb40d9a1ac3d486dd17a140e0d42e906f53ab4afd7554929b0bdc10ecb1878d55cfef81c112ec7bba77711cdfd7df33ee047fa400f71b657fd04f10847de1d807278288faa7ab08d74d03d8a63ec1aa162febe34ea2ed487dfd6124c20b81ac3d80f50514ac5192bed91518ec744e9ea7cd3911e1c02a20fc00ae4b0ac3aa335d5479d6f69e6612731e777089e67bc8d4705a7ad341138fb7e887a20b7e5f68af37cd31a7a4ccd03c60601b77c996672f03ef87075b4bd1da1d7fac635d9c5dddefc2eae7382d47345adacaf25d41264fde0d51954fa125866db8a2d846492c3756b0f9079d4fb0f992a6f37b7ecbb58b8d63cc1b749046adc6da444492f079130214c4009761cbeb891b27f556945d082e3f7a07b26fd1f9f2ba8ed00cbe1da526e5c6c6a96412dba76f65e95a8f6bca9d722f1239cabd48fc104a0e5a5b88cbc31fa13f57efc5da1005a32c99b3465fce15d60f2e13acb14246c2b0a5183b0008d0019c5a81fe681d4658f55f2c326b325694bf869fd6886aa7a5ccf10b706cf3ee8ce45720a24a47b2504205cd7d4b011e8046ac67de4314423987c344b1c853ba271cd272c39349338efefc152bdce10d4f3e0a79e3ce136ed0ec5cb6fca9fa0c8df27b02bfc9a634756e6a7b609ce52fb8ad277f0d7b9e5ec58ee3583cedbac5d49285563e572388e12633a4e1aa31841b143344c36787471f0a9be943b878a8bdf8102ee07a247a8afe7005ed1738c81de57063b802f4fc59055acac06cdd9ca19ff7f7f47d3d1a0fe73b7691402aca24c185c24f29d71d2e369bf2570c069d81f6c236888a543e78a9cd7cdf86d7d95e8918deb7df5915551a0913954b67509e52f0dd882901ba1ec25cc876725c9653e4dc77f4bc6668d101112a15630ab8d49f6fd9b047483ec040c97afe5b152bd758ba32c16d185227bdc26f75150843f228a00acd145cde9967650c60bb6e19e63dcd3e705c99821c2af2c430b807eb09f5fda7b132e552f2f6ce9eb7e819bcf8fc4d0bab3950bca7982ba6791bc622bbdf784e7b316c43c07b9c83af277f8576af703b74773e3b912ca1d5d14d6032450bd8d87af7b40ba3f222b37799abf309a6b75f48279538b8e520cd7739d2fa98b7a81b17a7374a57e63e587ab5e1dce18a2f8bfee68a54770a520b53e78b255732f09e82229bbabaa69e001bd27ff1c97239ff072bf598ca826ea14bf43216161ebd80552047a28b7348007dde8ea44bd100b4ed1e41916f574f4e1fe478372fa4bd285da57e13a26e87ccb987cd31a15d85d24e51dfc0c512e2e764c97ce4778c9f2f8e92a064eaa43dd39ab42721ce079e1347b39aca1152ca38210ffb4f2f921e314b852c76f13317ffda64316df0ae9a523bb9377965b03e9a55fbefcfefd0f51899e471845c6373dd10f3c4e1a2d3d361a3a0cec3f1d0d25a4e54e96c4ba20fd4b7868468b8197fca119bc9a614b7a40e348cdf612cb166504197d1ee8a0b91abbeeab81369216ffaec00ecbefa22222a4ff05889a85a17cb375b5cde9d96fb275d6eb0068da9a4a49254567ef725780824a0912884e617dffd203c05292b0c421fe2ef4a2931c6e8482fe873ec9e1a75ff1f04832e8bef64996c7712fc93a519620fa4f50ffba33c4b3e169122f5aeabf04f641d809acb72c41f1b51647e1efe7023d4f2af1031fc0b05a2df47579f5bae347da9c19ca01ed54c4ecfa176272e211f57183d3fd4b59f8a69694f8e9a8fcc000aa68099583b7bf76e33784fcb4e63f6b4c3cd44d6538460fdd4892218ea294d799578208aa68d215e7d3928bd8528775da2420ad7e17b88903928eb2201716f374ebb19b759f5471bfe4c5fb564456f5629319bfd246d57f2258462ee461fc02fb1498b8ef45d1ffdc660ae5718a82b4f29ef53c98ca2c84501ad0f9ade78257c2cc39d2f795a24103a87e648fd6214d84396637c1c0d1502d17e916a0f5ea6ca87c7f8922c9c47b07b4bc04efab52572592b01c93c314ac9ffc4e83ad9c2155d451e280e8d2624db6b65b92d55b42eb2fa2ace71ec78c88bd98103f3d774a7735dd51ce1cff9f09c4bc27c6bfe719af5d92a4ee87ce7344393464473f50f93401fdde6c2ee33cfafa728829fe194420218ab581d078c31465f9f53b2ea933c47858a1151dc991993f1039d6a1bd1fe2938e9878762b7b7d54da58d5942d8fe1ff6e4a0983ba18dacb5bdd7093061f39989bedc372a9d4e43bb9dd6fd75bec10ec1a8d9c3b438acd58e3ea037176e0bd9a47c272f00fb78ddcdb428f624b4d332d58d5891bd9bf9b400c884a0d5c3412975651940b1ae5756c4939e64f453ec63dfe49071436107e9bebe7bb86f6af5b36f0f60f1bd9fe11b2ffecbaf049ff25370a4e5fc535c453377e813bc178da86338c5250d1393de22fd900f6894b840ce50bcdf7aa3cc4967f9a28d58a0759940a0e067646d334fe9e1591241741e67e27f85c0751d31d3409ab305887704be8595b27790b0499801fc493767d4bd9de6662968fb72c4a580c50789278530cfc0cb25185de8e83fd1532242333f9ba48fe240145949d3579d822bdf9fe3d5b289570d50152d8233efd836298d37f5c3535116d5b2ac34267f568c5a78f25fa5482e30571b3757142c733039068006943e354cad8da11cad9368ca2fedd6f4675a153132be49a43861be274222072345112a2b561e7ec72d0a91c568c9596ca962b7a1f6600bd958ecf5ac68ec3b248b63ed89de0fe82b3701d6d8aba765d91156517ecd2fea74146dec13e7224d38892bb2f6cbef1ebd6fed81cd6f7c0600faffe52f3ab12ce8c288c8955d8bb90c188b30524fe16419a4ae1b1911b9bb68b67298e58834e814f350f47fe21c5aa1ff2dce3783c01cb766837329c10a9a713da01e8ce81251b41a4e0e58984b15119df16298aa59dd02c314296a8729862740721f28424b7d212727370e58723c5931056c31fb1d3556c95964453c42d7488247fadabecc3152cf0e1d07d6a37824b5dd9e5a4742318441196a757c7233c4a0840212fad57fc0e3c53272fde9312858a275f16a23d24a9a0007c458aa0c121a6116641ab12af069957d57304eebb53f23603c1d8772822bfbe92be587cf72cb72de44e8d949f0bcc3a8eb1a61021293f14ff29f0f99e3a28f3b180500bdb4ba1f8fc2aadd7a7ae6fe00c73279cdd224ae62647bdd88f6624ea03b82e17a02faf19eeef0df8ebaa28c1b7e3d5ccd135a693d66c9403864f91f20c7e8886190effee3853736be75ca1c0c6286b4af13452ec545426d87203485c5044b0f1206fdf97b442ad85ee7cc5994f17063dbde80e06a0a2b3b398672b901fa569b50f37684569b983dc7a6ce7cf73604e670c8b3ca60e279b3c6f7a4d0545e200b92ba89cd76acb5cb52028b53159ea8ab936143cb8d879c1e78813d8966767d72e17bdbfa74ebe54c968e7f452a3680c74d1135ff5d485176060d30f198fb92296f837eb7e0f3bf0dd65f0b99f5bd527dfccd20ad4c83c2a60f634c6dbce9a8ac37555118994b1d6d13598d44f6a34f76afc8b34f083bd5e2eb27871ad8268f61c8e1c59784fbab26f44746cd429104e0324bad6cc274806c391788155dad73e541d621bc6735334ee14066fae012ab7a896853ce70393fbf44caca1c0c1259e4f1a9bb4c370bfd2e5ec577314912ff00ddec52113a0034eaa9c7e270674d56b777bdaccdf189f6f1e9b37ed503685e3620bd6d970484758a8359a85dedaaca584a1ccf79b303a6628b07127b009c83be0808ca829deef058b76316c6615c0b1d5c252eb49ef9e3d9c46e361169ca52266e2436ff3813ee0258f45fb7277fc22b5cceab689e16a3c4d6b6f101f6aa2ac3e1ad00d6e8f83115e70b0ef3a8dd5f63772c823fb1d8963ac621f904b9c4ced8d8316a01edf4cadcc0016bb900ceb9f19f7954f1fc43b988a85a7861310ab1844bba92423b765231b1e33c87cc90af0c8d3671e3788fb3998ad5ea72148901a51988db40e9c586cbee07e10f0fa49ca790184131b2ec5cf47803a472f95e6152285b937bb41d190367f295175fbc29ce851e32a1baf4efcc824ae5e7a126cf13639c0148b8e1b4712316b5aaa16e70800df81f819ab9fae36aa9a4699b14f3a5e00e636fc7a5ee2404b1ea3bb1eeb430c79ee25ba10b1bca6eacae808aff59945d4accfbc782c6ee375dcd0a5e2d61846bcaf8d6b0fc4f0fe2394a9380e36d23d98bb09c7cfa4c69343ce54beaa5cdf47f5a4ae8ef3362f51f3c91be3a2dc56b143b2c86c888e3c2a52abf62345305591ba73e96a5858128e9e35a3fdeb0020f893e86e73520e4041f4ff3e601d10d52968a404d5a3ed46ade7330b670bad7ac5ed986a86239a543373cbccc04cd13a46bb4d7cce76933aa8a448ee2d9b80c19b3480057c1c7f408ff368fbe0f63c52dc3685c407e2db4dd2c2ae16f607e6b2b6ac3728a3a083c9906660564669f7de9766be43a14ef50c2bddb7d6dc59abd2c0932164bd9e7d02fcf6a6d57aad451fd802863067b187809b7b5f331bbccd33466ddd9f03e3cd0c19dab85d2fc071dad753406bd278c1a4fef0639e0b1262e5a9b73f98462c162e09283db1424fd565ac9e14ff2bb36c747f3f9bd32de287097c075da516fd6e86c6b8b6e8220dc049a1fa0b9781f84df5d8f26ec061c39a967636a59360e8981b83c56cec8a5e96cd56a9b9026576a7cdc53c87ebc5a601c3c1df2f8196e7fdeb1c30826df4d7cf18315ead982f14453ba8c6679bf3c60c176d911510db3f5116e9204b079cf0d47ca7b8e23ee04df9b7d8db80a55f652c7c02ce7f25feca3bba309c8b326b5f824a258c24be9368335ff514c7810219b7073073bab4af253b174e89ddffdb256109c0eb4d3a4744bf2b69f6f7271dc46454f0b88fbe2e1d689cb825c813c02a92f13ee3e186481f8eb3aa0c0207a17edb5d6608a279dc725951284fc1737ff2134c3142f41338aaae64d98a814321a64c054c8abf8cafce4325e495f6b259b38698441ce97bd27fba1c6c11a1d0ddaa0bbc96253eafa48788ac92b697c80123ef2d163dd206c6b3b9493399c288d2719103ad9e6d61fe522900abaa755e946345959a5be4aa6d85eb304ab2ba41055222b1f4b741d4c470a884dc3ca527f56f5f8a0bb2bb54ec17b76f0ebc93d4c445c62397148de806bc699c2981ee4811482c7ed00fccbbcb4ce8ff893841b8ecb459819d1bdd443ac555151da21ac12ea34be1787d3b25e3a1d1e882bcebf2a05af4e7701a85d13154a1f72a5f69700daa5fef2634e914c68f1c065c50921c8920e5d11ce71e2fc96a7c52626ca892955e9cc48badcbe591716a3b4fa5c676f26d874966f6e0626167baba8916bd8e0316f73c3860ad42c9045aa6aff2730a8b33d6c8e7f747a035f8ebd2cba2f2a828114eee150a5a78d8264242d47daa4a3e5a55a78e55a2e40d72ad3a791f11df893089ab4ceb152b80cd13d3f4633cc98372ec704d911509dea84a83e705c5343371cab7c56bb6f883cad39e91feef808a6ed1eb135f2ac95b0579fc1157e72cc3fe91519e90624693f91c89de94ccf4af520f94784dddb9764367b67e1f351b36fe1e3f4dcf427ba522c0c21658a23e6c394d324008bf8c95935887b8fc6b6a5461860c3bca77e3dd3d591380aa5aa84f514a1658f47423dbbd93f3e2254608a232acaa32c16659da88fb897bb7afe7ab320e8266974ebdf794be1a5a785f7daa33968c2d243d957d8192560dc7c633192f826e48464252937ec7d137ab90cb7a6155b7e724c2cddfb9f6f927bbfcb560d1eb790ba5d7f21bde9d650c97d09433961d977031df03ef639e032b8df99a80167466f005d20db3e1268860e4e13d60a885b948779d78cdc8d98f59aa677711825ef3acc8bfe9ff341a9fb249a82c0f43ad51ed24cb930607e05dd11563b85720468de75998b8f639cb6c8bb12f2af43a0abdcec984df0a04656f259895d76464c7b1ea8b7cad4738404147ee8ff97a355d3508ab0f90725a196a5559e81304326c0b28a1f101ca6c92e7789d3809157316ffa093846f6c0cb76ca2fb361d49eb7b84b160ec83b6d1bab5325b33eec3f03edaff7fae01290db799d1b814e1def503ed61420ca68007d5ca9f12f2a63cf911d4ad126d8bb4babd32db08ccb3486c607e69f1c59de8dd5faee554b40f7550935421893719b329cced0b2323f851f643ac89deb38d30b3bcb56a38f913e7e887acc1e9df49d71b01e665b8dca532f67f0538e985f4b3e43d7b4bd3fa97490291cb14ba0b63d1cf1608ee4162422f8df82ac826f9d725eb979d0a3674c0f95c89a2cf2970d98aec0b8dcdeb7de37d8533d1bcc84bdd4560f26648510fc997a9cb1d0e9ea3eb58bb7e2994a2440eb49ad80439304cb819260d398780732765566f8be5a11b771fcc961c883f9f585e3bce347728a22ea7e66fabdc0878830473835b040f0cad3f28b6528068a34a739878dc35a2f22f9a28e6d6698fe07e8a79427792049a69b35a38da0f6dec8a8874cb9648658208cb97204da359dd6508bf36202d55da1aa66089e37c9cf7ad56e6f4832f72d5cd7f6825c6035faa80673c70cb2facd68e1c2565b2040857d75fb7ccc5698397ed24f62deb720b58857adeafb7f7abd1846f2f4f4bb434e5446b0854dee3928dbb1a3b34a2e79215c64526c3a1f27962a29901ff8fb818cbaeb96ff3bd9c933d89b3660525f6c9fc6f0b818490c960dfe745cc885c0999a32317d1a1d948bda773bd4a8705ac81e3cc5352e5362a9a55486b40ab9ae74b9a35e77b058f9d835d3ea44ca99769f16c7f7a62b048464afa3b756f576338c1d97740e0b5fde9d30bfc620ea7fe62d813329d6dedf81b5ca3f8afc1e47bac82c55225e324397b6ca850b16b40689efbc90f7ea3ea4b6d2f81b3710bf518230b3e349c95ef9370719222f86e7957f4b99e57c47463cd4d44903471a66054ed8ebab678e3b957f93cb96eb9e019b2e4a649dfc47b08850f32ac863ff9b09d0efe110e27dd46f54fc3a597f9489df87597d435e48013c8d605b610e785b93eec0a9228b6bff3ca822ceafbf8e68cdfb8555c662d7945c4cde3e0bcecd8d9ab87b34d1caa2902e83096c859d3c1230fa188f42ca8fcba9db754605e4fa56d4b5e68c370caf276ad13446c6fc054309a28941ea181644786fefdf60c98b21e875b795051bafbfb5deafdbede12e059f6149be5a1fd62325488297d8d0a5019b7edde9e982256108cf9e0ba9c3ec49206f77083af79fcd0ad336b30ff0b8b256fb71be4768bd39b95ada038e1ac14f398e151bf75c4b7333178ab899348b895102f11e95dc57efd1c9218b0f397963168b95dba0c0e19e5595d0c7c69ffcce6ab65944ebb781be65e5dda21b9b65c30f6b7d100855c279401e0e372e78408230100dd4a7187debfe2e6d8bbf1ccc31768577950a114ff82a95ea38f4fcd0ff6d468d92d7a0ba15122294c7178a8c12053a58fc06bfa8182ffa03263fde9eda12e5b5ac9307c69f69c2f0e55d68191a28175d030c15b39ce648110edc929f176121086718c6f2f15363544cb4d7c082668441ac8681c7a9ec5590ec49faa63581cbe1a5395861d04b20a9fef906d2d5cea65d68efce533c1820c3d312bc14a3930ac6fbccb8d16c086be5e29da0300da0fa5a8138d265c51db255f2797897ce5543e7fb796b7fee197eaa47ab73316969a480e3c8e609ae16ee2434b776f7bef112ec893a677cd8d940a22e85f8201ee8c4bacd001becec23ca9f7e244e5a00ce1e92689ca790f2d3656ad2ace1fddc3d5af8c0bf00bafd62b52c8a4800722cb2cfc0df1a487f05719176dde8eadf230841e5f45980a29189b61b5d732a4a892415979483ba65470efb30dc35045c7812be5f2262557348e8ef0414ecbbb4b62ce4a77cbcc1cca3581162648bfabda862668870cc572e505fdf864f67680793c0bd9fd54e2e464c2d723c003efa12d48d93393474ee39f2f81e9d27bfe04964ea3421f6c4ddd817ec7e17379f50951ea6271cfc9e48795c2a8de96833f79ba45170822d65a2d598352ef2fa6d72e3385785ad6c0660bc0a49dc91e87428b2de602e5e31f3ed41699572071cacab38b793c4b8251dd0a5827a60bb9337ce1e043b9bede66a3b019da0f02cc91a2f862dfc947d93f42c5ac0ed5cffdd36d1a0659232ee42a8c2169c761fe0085fc67dcc0e0e3863fccc3f4ac5af8844cc54c94cc5e9ec4e4f5794f51a51dee6548cc82c9dd7cbe7e7331113182ca6f357468f0668f0891b56fe53bfbceee806b4319334db2059ec78b331cce39c693ea860c3ab7ce39d0776e4b509cca10c3f419ace9867dc12616c0d6f9f3152c58d2ffb3f5649b8d8facc45999e7f35a19651338dc0f234263b979455b0fa384226b165e710fca8a0a0a5177c7b9b47094c59b91c9332b1d16819fad24df26724614bec5990de9da343eca00ac0a9c613fca3988b3952136fc22b02fb4e74b5c1de641fd48ccac567a0caf1813ddccd9eeef4f4beb61ef6069e181ee2e0ea1a3335216916754065e9207fa38062f7ad299a7008c6d8389718377af72c13c0fea5c5570d16aa8e70e1c9df085b09405be10ab47bf96bb8271b204ed04b961eb30c5a39eb82d73b10c19da490d8c292b32d82dd0c052077014167990209af8c58a8ba0623eb66dd2271d4915ed2b10a5c718fbe335c29b43e60a47d3337e0656b17853c6d8f83c2aef33bdae1b1550f99114e62e694eb68068d75a3c672bebb5a741b2ee70cfb50e9885678ea22a4305f13fd87a6bf65f571526c93062b7516b4d150ddcf0c382796bcc946c06bb142fd2a10637759b32cecfdb7c662f3b274557652727fb3f0d96056b8738013430c4418d5adf013f2eb8a84b1acd7b33d07fad138e32545885495d65541ff02d9446cdb0e946e491bfa052ac259bb589aa3370f3e0a81df775143f9ff83fcbef716c5b622c693fd763b056586c281d43b506f2a56ac5320602ac36998a48012af0ac43fa3a7ccfa66e343b517431078e937dafb736f37185de12d3094e2c3c3c4b17449d5b171316f4e65df599e70a70219192a8740b28632342d372710608416abb7531ac47de3e4aa9bc957cd07989d57e0ca42cf5d5017d92864b7569cb7741b5d732bb67b7f85cba96790761e83cba78a69f90b96f19808c2f34f0a4b25cecc578b010e61a802981a78ed1b67407330ab0019d61e0afdab8f71409b2093e4fa7e27502394732c1bd6c4be806fcc651fb8662a33fe95c68110b67f8447176bf4071d2fa5d4c3008970e20d7d5fbd645327fcd9d80fec365da7b0e293e26681f78365f7609d21e14b8d96f354dec15253534379080b21a982aef2a598092153dd4d9a4c3c4e326f4bb262f9bd178dd887d54e70bf054b54c7f205312520f4fc9b17ad88e863ce262f79f9753defa1d0b961d4a40ef086bae71a4443413122bd943bdf88774fb29bee87e40ea8cd3b0cc7f0c4b5f6f604295afd38e255b55715cbbb556004617d7ae746cdb5ca8a7ceb1aa0d980ec1f14c899f3d9b2abb8118e0b09ebea9135d064cbb6d35439177e6d0f957bbcaff8c859e31791c0bbfc9e5a8ea8bb9921d93a9f6fb18bd66b3fc89fd3cb81e48a65f9fba5ed3dd209f6d0b2b93040025624662be27aa7d69f637f70a7d82d8619ff237590592fbdf63bce82a427e980faefeabb451d0d8e9b95b739f6af75828df906fdefc7eb346804c12dfeb96e52f23b0a336e6874a7133bf94942d0d84b7ac41c12af0f6042265bb5f6475c50f046a0e5a83f2f75b53966812bad1ce3591d9d49df91982f697c7f6b021268a61806102c4cf0511eade56515c6a1c95f770ee0b24994107dd657a9e66fed2f645e87e0fef4c73d41b736e73aeb3d880310443b0ac28690bc974bba63982de4f57edd9e1c8348744110f48db6098787f354a66ed5ea45a524a702ce4030ca6dd798fb3766f031a003963f5114ac586a77c4bd83ed3875f94b86afb86a20cb559c3cbb806d493f396f6239fd2017becfaad036e788472566b501815dfc4194033b43d091765f65535e5c468a9fe10ec4fdea747ea86ea7df68de2c454366e9de311380dd557d544a25af926610fc8d7d0ed9d4af343a94aeeaa6a68243187b457bc1da4fb964f539e2c406f0474905c51e3c90b1bf94f90bf0a65dc407618fceca41faac1fc65b5e78091729f722e30eec481f47fe694e8050a834e8d5fcd07b10e09470bce75f38ab4487c10476d4d4e6271912f87c7903e33c6a008b767dbf37c235b3e3df7004aceeb2fae679289a7f5541890c0370fd86e6708e4669b85467f4cda697ba1fcfc9acf719ae5ef0517254ede9f1beb7e00fccbfaee7ace7d5e53c3b11b2313161875782e8b513b32379a6fdb9484eee83a4fce7649f8e163a70bb3b558bce525a45f8a584ad73574058c2773fefb7ac4359e2dcd4a255efea6ec634425fca11d52d2c44c67405ca7f5647165c68763707dea7d9479fc414ada15b6bb16a7fbfc3f57ec03ea26c52d6f5b726450dde1c1442eb816715d4bc7c16e462c02cc1a3e54ca75245b0c0e2e9ad892747c87ab0d1fd7b10bb869aa57d18e33277737736f1df82f20ba15a436b1d8c2051bf2ebff7019dd95c11c5076a0b11f1c481dea003f3f3b793ea6067737239ce2ffbff959abfc612fd18a53cf523c90427a4f27ef32684f7b37c40f0e46dcb2c259454d9b12e80eb43d84fc7bc33b2d8a3cfe065f08dc1b332406606820781282d54aa972cdec8263c599109733fae65be39f666e3a56955dc110e4729ce0e041c31c86655697a1ccf8db3cf5137d1b1980b9689d1ba880200130831bb0b4f467b0d4fc56bf627743dd4ab87866cf75fdcda249e0da275bfe7c753a8d586e41ffa7e0b9a81907fee95f4f090f7105c2798eaf7b1a02f416132712fe36086260b8a9274a41a8a8348735611cc63eb03b33278619a8fc3caf61e092d4be8dec888b69c1d834aa69aeb63a19839ab18319e88dc026178e8ef84f50130bb3eb9b65bf166e915d6400a213b7bcc9632e0b9b0fd3c7957fbbb96b51a727566f5b7f0165460d092700256f66327e0152975194f3a9f8a77b5e1aeb0edff80c8adc220025910b476396a3b1635a82b245e33344e03be9206daabc1cfe32de0c6e89f198101f1e10e622bce86ef9be2343da9fc867e90aaf9462a23924e6ada277ef2925cbf2a012a6b7471fbe0b1bdd2918bc828b039f78c0672395964d295fb7a79593574bc10b4f8225572d8957c8da50962e936fc49a152ac4eb28f6bd7acc6fadb90804ccc9a7dd494c38e5ce693699d4d8e28e3d792ea956ca015f8ca2b42c1f8cdb310263fadb140a85eb7471856d285fbca8e89e850","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
