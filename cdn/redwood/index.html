<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"512280c9a9e4c2cc6c2370609047bb86aa1ad4bc81330a14c51792b6f6669a543ac20be2952ea198c30a9c8db6b9b1a15ad92382c6a43458fd5153a6e8fd0c98fbae15b582545aa893fa4aa315416d4e20cb88a103976df5f5b270f9b4dac02f70651af3fc99fc36135696ccfb15b3af149e3772b1704eb7c435c133362f86a0e7bc1ae3d8d0c1f3a628b7ccc738a245aed87e52fd565afb65005b0a3a81b2d0d36d4f04513b1b4756f9253f85369c2db4d5724c85c352d2c8f6c1f896172ced1b42ab7e4d50e37e793aea8786de9be42c95a364dfd8987fa5382cf0a22ca792f23e9e5c5422782ed7bdbce6029789876a524b06672c0ba2a4b0f028372c364088a7307e6123a60a45d0ebd8ad327135746c0728ea57555e34b1f8958f4b0480ab8e32de1a0b54e5327f3a71cc653712dc0a37e2f52b76407bcb96952574f23815cae16a3ff488f1cc9569941010c2cf6c98a230b0c80e9d56a4f91e9bd15f62c7aa6a97d2011e5d84c54ba5e9d99d77e4ffee4bf017962a17f1631229e0b0a33e8352fbb5c25e4e3c2079b1bc5b7ed5d82670a264066994cf30650e2791345f74f9ed70b4cca8bcf4049ff56629b4b6afb3ddf10f228cfde627d8d24f6633845ff9fc40671ecf5cdbc83885c8e59a88160d5b16afe90f051b52fd871729634fa48702317e6d98978749bb27d1c5a46ea78f4411a4562e26de8711a3f78fd2d889af07a9c27989903d247697852cea0aa4357330a0d5bd6451fefc9bbfff12e6833c1df67cabd806ad3c301726365301dd028b62fa5c97c957a014fa67b7daa32e70e4643722eef13440ba478ac316ac3e1a05b8e345d03cffd17e0140d808e4a00f4690833f0ae47188237421e0af1ac6d09bac03a0f89054bb70b395185d1b4a8a50bd15d9db6486e9b215932a3664323d899a8cd42421d8eb55959ebdcb48b8d495a78f2643e3ac7833f9e36aeb3686651654938c9ebb9714dcc3bf588e3927a78d1fdacd4875443ff4615d6feb910a200315a275ee104bd27cfa0130d2c224cc1aedf3f3ecefcb374af291a301591f4e64bb488db26d24a43f173e4b72ddeb6b761fdf132bc359a6ae485e06800011ece3b7bde25db23919ecb34e8dcb8b75dae8033d4704d97df56493b367d3721945468339c1882c2073ce1260b488e37e9c9bc4f771e4bdb8b0b46ed33fbdd83c6204297a4b7d29c07d7e2a216f1d42c3be6579ec1162a895896cb0239094b0cc4e38113c096774111dfb5b9cc95b8bb251bcaab15c6858d758d60b08b5793fc5067b2fa6b8934c24d17fe1cedd15bac748ec655c62e4b4c11c17ecbeacf79e376394e121ea9cbaeac1387e8ee13c9d6fc04c6f09a6709d975ffcdb676c4d52f7cf956350cb0f81a533675dcff8efc57ac028346d257fb64b303ef9bc201f5519591ddca43fa23b1fe1fa06bdd816b0ce534230daeb1956bc9fd98b6e64b00e3037564490590ab13e07dd20df95e4b0218bf12ee8888e43deb8da2bcc34367770d45170014a1b722f4ba961aa40dfc47843fd3470da38fc12fa6b025cbff0f157dfc838a090dd0c68e3ac26dd1a0694c305fbb1c8fd4b926f825a293ba1e386cd98b3247aa0c269c0eccfba3cca32cbe83977c163b07051205c087d8c96f0321d92515448442a643544974fa2f6647f7d2ed4dc06891f78b9693d1e3bc96312f3c8738ce37f81dda49c705e7563a9ff92c34a52e448b31d0e8b7e5a1a937224495bc6b1c1a144bfa73259bc2f2c422f0e04441910a5353312097ca1deeb0b3c5489457370dc32a0308046e1d3a1053f8c70e10e689add99bf088ba4f0134bda3bd3f9e5ca265c945e0ec359220446df0dd1add3a5e95d6e28d983f7a40f29823dacb50c2fac7a677ad04197e9fc6bc8a475fe5529227cfb8094ebad8c2786021a539d49a838637ec11fd75db8aa9e743bf98bc4d29d8a3fbe2d8b47a0f572c7280c65493fc96243cb131fa2774db1ddf97bd6e03613eeafe7021884edde3662c3110d924286f78a41fbf7953abcad793770a6185c61fad56e8b95af6e99900447f72daff698139d40571eb5759813ef0b8b9505db633c58b4c5fe7f87f8e16b98aa1bf9e9e1ebf197c303a81c08a65e6f374f6d624fd151046009e074b887953c23dc21836a7f581a6d0945caba1ba50ea25c560740d21bb76800f7b41e8c2c92aaacf063a4e2d6ba4b488685848f38a3c947a0f4366987796636e7a7b70f182353a378d021005aa708407ecaab70330ab4c5dc09e5f55606a4161e4206b75862a4442c30b4f1583ee4d7cbb1d20b76d3e3b38835923d5d09c2569b892ae8e8efe09919817596ab7ebcfc1ea2f0d456871260311719044e7942ff1704becaccdc275a7603118e76384a09b318650621d296b666acca9901f0e69902212b803d3672d0c1e1a4f2849db0ca5a6f5a764467577913980eb23d970465e4ac97af1d667b45e583a6732f04e10cc8653a15e7b7dbe7ac7206db038624750fc50cdf7e1def3e35ab627602aa706058ac98b8ee9d7e1b7067b0c5e93bb2e8301e0517a77d1c0d9a72794afcf80616cfdd40f7a495e3f58cf248e392e30e06da20d16bdfd4e793a9f98ff9ec42ff799f00d76e97b14a3c76c69e83aa4a8247f0b924fe5b5a62e052a5a198e6f3d43b02b7937bbe878e190fbc39fca649e3c0d44ba0840932cea3fe9a8ad69994aec69c4ecb237a3e95a34bbdaf96199dd932e770e0eb1ff82b145af76fec3adb1867148c3857d8decc316a01722ab25453f91b826bcebc771821aa10450536a801631ef0949e643220af4525ffd99ccec31b7ec4ecf8b7428e2cbbdfeead206484aa0358db56f9765cb848e74ed38d8c6ac81e1b7b0bdcf12e203aa8d8b34008eb97cfa8633297ff9d9b1a8c5c511747be2a18fa5b5243e3eb9766b28336496614c3c69a0fe40d3cfcd3fb01d5711be911ac0ce2be54f4845d0cf915aa1def36205aae570ec1177b8487a99626eb790253bb5d6922cd6660e38955a18955201f65ff247a380dba0152d53bc636e6d357b42beced14a8c2c1b0f5241473a3fbda7833e9ad3e28b1308e02be6da7c1aec292c8e720616195e392e5080f185677f97d8e98d7bd901ce3e357a08597c2e999e6236d4f26de971ee750dd7a78879d38728e631445a58392b859b171406ba6008e88ce0345e29ff7807d560e09f55869edd4473aef08ed7b1c6925f65a3a7565ef7e07c9c3527874fac8d3dd15cc8c6ce546b5608496e047195369be0a8541e5f7a801c7ff7476c73163b9d88bc31356112d6d6456a3c6a106ca1418ae1c62040e0a22760e8cdcafadbab97a9af27e6f64da79ab217bc2de0e689868c096de6c2c385e9216ea0cf3f82ea02061f1c635c10968a8147496e8260d4ab37c2e534d9ca2cf1ef93bd79b703ff6bca780dea118924306080cd02465a55e3c3dfcac0bc991d6d283063845f6deade4f3e80a223103ba827ca01620c5f363f21b5cea52324609098172e01cf2ac27a165fb00dfe07b58fb1d4b2cd9aba05746d3d14bc8ceb233ca4a421d6a031089a16769eb08c91e758131ca437524c166c9409b47659df421f8c2d0433953055b6f30c575647540bc2bcc34af2b40846a11dc9c04c280cb6290db3ac12f1f21408c99982bcccd127fd2425fc322478ca3ff91b25a69412fd36bd6c62b0273c28fcfce10d34fc3694cbd4f496c5aacbf7a42fd4827b37c804142353a4548e3a544313f418949294c548f2e11f21a5c44d98ceb86e1ad687c3d57caac2e57ac49691b8ace5620fb1db566f5b97fd852ef182a7cf613f3209b3d2717e57a987f854b416ec10113a982020f5d4931ea188190aab6e936dfe21b19d8e7882397dd5ab3e9fb68e220e24952bd1d0b46bb37e0bd683cd354372c58c278daa12a6447f2be68a990848d73f681c4793ea53720e9c325a87c52dd2516b9fcc93cf85444cd125dd8badcb5b79379f0483c845800a38e14d3387737ebf2633b8ed5ca01b8c021f5494dd8bf61ab56e066df49993a79d141a1a3afa35c46c0bf84d4be785f2a856c723a09bb7ebaa6637767a6431e4406616dc4492dfd2974f6b9dddf94f2d4b6aea9ad2e18d4af682e1178d65ee42978d368ada57a26009ba8c3f0b810f0c218dda822c2186767c5a32be8659cb8e73cdb3bec24cd19b76c37d7ed6c30ca53774932b30a98f6982959f77c1babac6dd88fa12895c697f490f746fdc85c6b86de4735ab5d3f4f14950b3b596aa20f31ae91b8ac6626f68119be9592427298698034382c90536b9e6a73ccec6866f6523bc635b05579763d4e4919cb5328dafe85fc2cb02fa5829f0abd27e6a61f7406705789afe6251d305522f6872aa15c6d20add20bc430f27780231ddb1d335418affa92821189d51ef96c2ed811500c68fa5d220add31039993a262f1322c88c1ff4c87876052117f63b2ccc05ee3ed87feb68945dcc88218ad806e538e631eec2c09e5dd3ddabe5aac7706c8d0f23d4af1cb3ff1bb2f673532d951c66beda465e92e08b49410525279a9314b96820b4b8d6f892671edb352620548eed42ae855492a0966fba93ebd819e40363321f0070270c6204b20c47a751e186ed621d98e8242fa1a742fabfc500aad66f46e0e5db173bf27cf53e539e9f370858c1314edcc635585ba4ae89d479e3b4679eef8dbc0ca3d248f2df91f6b35a764599c9a7ea2ae004ae055b9950803210405d74ea2ed84d297474d937bdaec66a5323f3a0ff67776731f3bf56af8afd064fc24d6e2e8384a3c22e1f48639b6abdc0cf994c41146bc2f3569a4694106b3d2b72f96ffe12e24347910768f252519e1f416d2d6f91d8862203fe27998d8ce3617eea0574115b3947ac1f9d691b7c4b05dacb91bfba68b65393ee504e1b43efd4550577f15d1614173b7fba9e99882167e478ed1f7d80857a822ede5e46746bff46d0fc880834101978628c2f85bae6d99a94d49d8c3ecde0a5cef98aae16b82d54e6f97db8f268593551bdcb0a3a7b9cdae4807092f1644dd12420c97e7c8b9b373071959128484fbe75376ec183f289fa461344d8267cdb7811e432b7e5cc88e78f4f38aba089fbe9056ed3af7b638bf4d315030f95b3e043a0a1e36e736f7a07f2148ab025d117318fe4af5e0da08eb842f0f298fe26db8bc4a06d90716e810087a9074df946563937d9145768bda2df16ccfc4d9d54e8ea8bcbe94684f830ceea2d9b75083a0fafe2f6ce4237341512bd9bfce62e5636158384aa46dc62451aae4c1725fcf94c858155b6cc232f2642b08f11386934d86512c0caf5ecee81ae631fa2e64250c7bd337adc9d0685d9570062f33f1fdc318b9a3832086e0ef656f66adc52db137b5e042348471207b84a5a1045292158969b0ad060a092b02f67e831c77a25a4f16a1e64c38666f9f7f4b4f526bb054f334c8944166ac0ba5fc5d0d08ed5d7f1fdc4fd3adf2dde837958595f6d2a0584bd47de0479416077eb0f52a1e772d29949a2b599ef8c36f367f370f7b52dfc2c8316b518a43b5e1c43abff184ef873eb90391fbbfe1bcf2be866e6db1539e21a684d5a9a13bcb3cb84f74b59a47cef8cffa4e306d8db029e7c1176d7ccc2e1a24e1b566c3b28d12ddd353b179f402c3efe9731ab2ed00ca451086739313bed10c5631340f3f78a5b8787fda2ce866c082ded624fa651c340b675f0186f45a7d6be39dcbf1e50d109b72c7fc8a956f464d3a8008b008c1c7a466bbeb1d610a59f85b768a45d2de575bef681f7e424eb65b75b7fdfc9ac5ff12e26adca14c6e6302a041b8876b61fd701c68fdfb926e6648436d79883aa3f829915a442200cc21abcafb1015eef16f16bcc0e96ddf40bce5bb4e49d25aa4bcbd098a51a1992fca91c18caa89a4f8adb798d17a6d58d6b5db45b8ecfbeb6ae5ddc1b22e5467e4c5875873168dce98d70cec08ddbc2b560ab81dfcae9b51ed57e662ff33c8c6796edef089c8f599c8fa7401f0e0a38676a030498b232557aceb00ba1045ebe74577f7030fa7bb7c0d56af2f6b5ea6985d43d16aa65f8e81517046075a7eb9a4076d67830a637e4eabd8847c753c78f2824dda73d8b3bcf471c6c082fd49a9590f3459162e8335b296fb52463cd366c5b965f277e902d6aa77c4d910e93d9e936ce000878bf2ae5dbffe80752bf39dded742beb419355c0adbfae6123cdfa28a79c891f79f1717cea0931ce6fc99f83619ee9a432a3f6e723477bce9fabb99dfead4772e9d2805af2d4dc5dcb5ca8357a5b3c337924bdd99a98fc21efa14ca6eaf4707b15c261d80f7faef067cc6445b39a6ceb1d471167154ff6f3f51829fd4f1bb3bf33e48387622bfda0e9c268c2239c4a2a7b329d9ca70e0041de434dc2c6c649eaad66f62f9d7c66ee54cc7054f71838059ec6bfc7c945f41d6b0ddd74923d1682a6407bcbc739b77a4ca3b39b3b9ff275e30ca617ae8b2420210aba85c41da2943ac97a58b354b8669b1f9246c8d8522b0785486d56d3ca9dfc12d86416303e08da3c0f1be8aae999704dcc261ab8e02af06a81466124f032d14a49ec701ccc5f3d89fbbf802dea07c2b63bd4ee8dd901e181097060dfab53a9712c5de7ac0aa7a0b3223486dd6493166aae87677771418560676d588aed7878655f2c005c3f2ec3f4e1c450480f9db9636fdfeeb8f973a7c998d13d01f6ff86557588944e8684cfc61fae3b75a71068f178161f2d2043269466342a5cc715f86f1183211b18a8b77ed085cd57ac5888cdc48b81d3e4569e35a74905a20d2c5e4e3cab3c7813b8c6c0d1f07e2951f069a5971655adb7e7e6f8acb3d1791af014c266fe16aa5626f9e211b0eab29edb4da8bfb3d8f04526d230071b18ada88c759d9ae7bc03b02dc9d54e41f647a5982a9f9831063caddfa9072b9b14657748d066cb4ab35552ff0997b5d534afb47654199974101a85125fc590b753dc84b23d8dd514c8d6a2d6c5aca9f8d89ac7718471c7df2be9e506a8c387048752dc96a874cdb577b0534989fb51e2d0a0c5cae889fe61c6362921630b4f7d3198c959488037608ff9b337f75f63d421f4365d0ac88b8e5c228f1199375f3ec25d5376f315b503ba9f5e0ad70b2f679f6dae8b3abcb48839961634fea40e93d3fa7b5212b30d66e231c8df4835e59e2505cb3ee4b6be1e14c1b2aec1d592dc8ecbbe44f22942efa9926b70d64e38d70d18a1d7027f6e3877a4a037e19f8ed41aa01882167e6d2b31b81d9ffd1c76f14b573808d1eb3b24c2c16d3f88ea3eb3babf586663cb8d01f2d85e12a476849fa99c4d65f289707491ec2403b0979e20b93d353949470c91810ea29cd4eaa701e608ed29e98691d89fc133d8ae09d047b3ecb31327a812e892c2620099c90300cd70a51edecdeb9de70ba9db084a530e27922da38f7f6ba6fe72690877aee193b7c6785f68edb3032968c8ba1b0a31b8c1a6f2122ab264335c126f4cf97d7607adf9f3305b4e6ec471cafa84082d085f18665b7b5e8ed177ff6bde45dc2416f9a3c575b8a29d23aca87d2a05e3f9463f3a23b3b9ca4cab932417c81006a339ce399fed65e209ae54cab74a9074f20a627998fa64d094c3bd06da77453d01d61f2543b0ed1feac837f60f640693a817ed7200180625ec20c8fbb2da8486db97cac239db0f5e74680e62707ceef82af009c1096cae61a1dd9e088459f96d428faacc13dbce40d6c0aa08ccc3ac638ede055b4afb7d943c0f75c8534449dbefb6b57b8a09db4ab15e974761f336f4ad86137282e2cd0ce6e3985601b6c5efbe789a80acaaa31643879579c4c2d8aaa6246a1ed872dc126494fa8414dc69c2d1503cc6ace6977664d8e78b53aed869f1f334da5f533a9eb83b5cfe278c06c4e4ee267656dd401bc61e5fbbbff7b775b55c53b5fa056b310ba483cc4a8711ff7d83b404504461c30c637e0bb3bcaee3a78b0b179cbe0ad3466331471d761a970f2fed08559102f5c28e08775a5069331f428fe08457c2232184e1c467ad917ee1729a3e9e353dac19a2553c0cbc3a260089b3f27d77e69ebe9fe8eb8a9436ff0d5243bbb857179e156e6cb9a495c2ae8e3326f71508a5c23803af3f6fa1ea47874d2319b4145fe5194d19dc4d4faa2948100759627f5ec5928850d71bb4a5b2e647419b24b0d4b7a9f54adba03a051c0d70a933c75ddac945ac7a8c5a5b34ccd1d1b3ccf87fc1a172ddd37645dc41df20fe5b74d2b2c1531e64764241240b91a9dadf276dbc30a1836898b57d8b62e36bf108b603b907460706800dac1a532775cacd1a50064d168607d059063f6d288061e9ee11af105566c6563416cec6dc7da1f82080da7fc54204c10e1dda2accbca97064b4b62ecfb43d69095372e150235fb1cf1de6810891af37960aee3960ff0d1c67386d029427ab092e34967c0e71e8c8cfb1f9d0010da8f80e048357d232536b07c9dafbc21fd138dde06140f496012d5229c5762683e96b70426c5d46327e6e4385986fb833abcb8f8ccfed76184c29039ac6ef0218b420c2e041e7da72e6b6b7f758ae229a275c01054cf4ab8e55341ad30d00dfa062a97c407feaba54931f3b6dd45482ad80ad4bb5b6044db2aa498aed7e6bd4a5204e2360f942f94df968eb05c1a778bf18a19369b3a4e19d7a7b2519497872b578b26fc7fcf3fbe4f7cd94ce79e2970885e5a54afea7a728a145ec62ab1a56becb6db3647db42ad95c5cdcfe0ea117a159d1b7da4da42e3d5f8027a991615619dfd0ac3758ce76d9fced8189ee5d568f02d14cf1d8c2a85a5468984a745a5fd6fc6d19d92abe70a06502e99c48b40d50a53fd03e95ac85812645d1e0d1384bf5b5d93182be33639652cdc18ed27393bfc3284bc9ffe96364ac124138140a435ae74358afe26d2c99ff794afce818422ca13fdbe7e5775f224066d5b2a107ec4498df53a83f58cfb2252206e8945f052734d8094f235a41c40a4192775f282e4a843a266bee60ca208807b35834fc3cb3fe2a6f6972c09d66608868c65c0cd9c895e3db1733540720aee12cdee8aa32e8d62239469c50d5ee278b67b8713acc33e37d60e944e975cefadf9cad56d57108b2a9b90fbb7cd630212f7850cee0a8ef77df7da472819d414d6689506ffd07c3e535a969107d3d1860f9c3a9083c7cde4ca03384d335758405d1308fdcc12c5f2232f3ec1af46c209976c16d7db1bed76fa060d9cef5fe810e06ec23b11b1c651ed2995a0a18c3fd7fbb660c4c941910f9bb0ba6bc4564fa9cc7b0dd11b09f8ec3e2ee3542b10296c58055bdad7e7a74156888ff7e6b31cea0a95729a03e279c2f9e08ab4269f7aafb719d921880a08f7a99d36a6c3b12a57c887644551e92e4630d6cbc679dbd74e3dfa00672a50dfa04ca4ee5f19642aad6a1057fa707059259df35f71d6f30559425aeec33c8122663aa2b7595d32fe0ad63ef6d732f644f19ccbb25af8e84c4f38e7a3d59c777c9c801e7a9c85549bc59a5768a0da3dffa3e1df9bb9b3afe0192552717c514d10013dc202b377002100b1c076f0b47868d1d220dffed7487648a957a237aefc7bf1038182f32471c76b46bdef9a71caa20cc7533da01d21faafbd7b21028881c23388e462a07baedc94374174d182b78174c63bd999e51600e5c27d87c28ab614b2f91ee18eb1b5d514101990504d99f4352587567c33ab62da5ea408c636b98a81b8a8caa20e796a80700587665c9f1fa893ea43ad26ecbe8b8014c03b0e7b726a7ee40d9e469d93fa3c343225c04c267e88716ce96b10766f29b4fd9709a7b6b9a11e2a9e32b2258d122ba3ebcbe54cc60ba348b5f77ae23427fa4446328dbd5f53d72ff7c2b5cb1f33f6bbf32e2dbebdf3d51ce2ec437fd5ac91898e6549d23a6318e746a3e0e9a0a9275ea7a2c8cb2e77b1aa0ba8b6938b09660508c1f5929dc8b0651c67cdaccf1cdbb38504412ab3922f26fd7c92fddec858fd45fdb86f31ccced6da36a3ea3b40959f7f0f51f466d487c6bb1d83a0a1fde580997530e869135098190f55829ef906d4cd75827d53d85094833d4b5be51f05e48d384582894f55aed5d8b328a7f027729eab8c1ca2aa933f214fb498a223b002ad5c0f6119a37ebb3ad93c878e4d04a565d09886b44446505ea0f92fa5d9548388bf8199043a0a32c944d7fd1420e9a9f9b8ea3796a1bfb8c7612f8ec5c4a4c1fe7eb56bfd2952c3c4b72979320d7dc2c7ec83fbfdd26d4b25e05941d82150a69b86a565a0f0326946cbb2f2f24331bc77303346581294136d09fcb5239d8f43a0570d675ff11da19ca440f8a59005751e34430c633acbbdaf4e7758162e21799b6804b505dde862f60fd50e262394c0c5f8707421c50d0f8e3dc1f224d96d2bef0a3f34ce16afa6e91187a19c303e8bc370fe68b1c7742fb77694df2d3d539a2728e490d9b4be152c322907d1854a480ffc84fbd3317e91b5fc711f77cbc3a6c1f96a901cff0f8eafc9c40454a580e9ab9247acff7a3d2097fba76a926d56f5779a2080276414d2b31ba1f24d67ea40060ed57917010b339f5b5d0c9d668278fb80a4b1b2740f1c0137bb05602bf3e42215b079ee63d3640c69253cf4c2deff6e0439c72a0880545f3f25a3293b4bbc6fc0c8d69d8af5e1fc6e2f6e5cd422e8082011ceca0da4a2d207e15f1ea7ba284206f727f54718bf91666b42df1d1bd844010882522502651f144f9785bb244ed0598e591cf5ef5ac8417c9e765ff690884e7296f8ce13acf0a8a77756dd7cbe7f72bb967e7495ff5202390e34ce20f389267998b892e8edba68bee78cfed702214654b6ce2e47e6a31a8d88d4ec902596539557b020d0b2a7ee7af35be0acb4532f4d53e5c6633e091c1fa665af000976d286fc6fc09a4a4b88cd756e8d393849b4c99a4f4fd507bf97e23f7622ae1837a13ce28810e1e050144d5a733d80f559aac5a5dc0900381c23cf8d45b1f885afa5d711c9af8127db96c63f8e9df6d85a0180f94970752d07deb32be7f5f38a45f48b3ea62c9cba428a3cdec25984fec4a8a3a5ea477fb4f669f3947ba04cef2bba33db5fa5b808a1220161290dc4f2a7fe60d053ce182a6172b5f48dbb2791bd257c48f13fb13989b13a633034ee00aa20a97ee879f346081fba00db08f0d9ff89ebbdb73599d8521e2126d32013b9ffc3d2fe0b8fe7c07a1ae1e66e2af4ba311fa69772abfb8b21bd1d1c8ef97e8e5c78157fccfdc9f3f733e2ca1cf28b8ce77dd45308cf575e961f8aa77c280a9d958d28763a51061a789cbe3961a9d9db106093f13263792e19f6d42b3038af92defdec32e4441072fb15d9f39cb299145dd6b99150cdca6fc8f09d0559822cfa0b94979974aa2ad1164a89f52a4da38073e48fc9adc15f5293251a37ff062f62be04505710ec4f53b7d0affa5c98b0be8f88f30c25a0c0da66064d235c1feea56118b4807c7655f320ecd1cf1ebea552f09cad660a62736ee4f90cca97fb8f6393b598b40d2feb8ebe71c4da61554872549276c3ec3c99817e7d94fba55288a4f8f39b9ee163639df5a355483e089cce26a392c61f1f64724a8d05cb4727000b2d20739652f3a16f78603e20502093f064fa975c3538af9314d04be3f4e489fd5ee9848deda149b30e149e903d14c2bdcf0d7ef144b8693f74506e4695451dac854b788d2657a91ea0c7e93c2f6fa28ee956dcafbc84a3d32077475d06a13e41220050dec3e47a5aec5f5ca03156f42cd6e97bffd683b2093ef320c13708958b2ff27738bf32ba6551d1baf1b5b1c1c7ff99e34931adf254e0a8edcbd0be83169aeaa75ebad08e4bb1c166d91ef904bae78f9e802bbfa23fad5671f0a8da76d829c4b55d779dc3f76ee51e5c5f0bf1c7ac9ae5a9465fa5e568abf3d4a821a62154b6fc2482a8240df92ab33fff4021507a550b0c682b1df181af529b3bbfeacf53d94333e6c453ed536768a8d8dbe1094dfcee98dd3162dbe42f7e101daff6179105cbf3b4f1192b9184c6ec106926d95b127a6935e366fce4a060d0d3b9dd8d676e07dd641405ad7b994ef70c06638ee3ef5ad2e197573b60fbe0cdc4e0b7761f76a85ae101eefca16cbd8835f81f13b79bca0b07584d4a8868d1d79a550c540e165ed130d0113a3ee59d903a16841e910190678dfbd1b6ab12f016bdafed5557a393971a396d9f4c25d8749fec566aad6cedc6883040b32ca7a13806f0d781d7e8bd64f5668a2b6cde55728d27df5b64d9593d2e0b2004597b838bb4703c422803bd1748d82ea1c80e042b21ba694807fdce9a28ce1b3714716c4f65c96f84885987aaecaa05b58469c47bc17a41312ae7ca293fed8727916955d01eb2654e97e78a62b422a47cee5cdcf0d857c350361c3601b8d9cb10a2a8feb0dda5e986cd232fa70349c7eecc75579052b240c57ccb2eb1ebd087e73e844e778d81e707096eee7e784a14cba39c61eb427e2522b76b565e29504cc0f5374d2cc4c7b4abbbd6decebafdb1aea1db2ad0b76edf5ac2f9dc53d1b51bfdd081eccb3570a5293563d8c349ecabe4cd202f643bd9d9c91b04f7df19eda3e19b02d85bf48039ee5b7e214e384c8d20a5be8292424cffdb574a11fa6741ed22c57a7de185b9efd8a596e6fab80accf311b29434d6884ea7df03494185ed04bd99ebf30dc68ea7e78ba49ae808d84eef7db8007174208e375027fbf84dbde0a66c750e0c449ff81b3569d97ec275e60c56b39da04432c3b13bc522b516984713671ec3814cd6cca1e0c70c9573eb77e8d200e8566233b75197cfe5188c2939a98ca71237a2923eb14c6f087042c8443248fd5726a634c4d657281a08e6f6808672adc03a818aa7fac260c69aca2882a928424999d911dc571858aa5f20c191464a8513d7825a1fadb8a5117d00b642d82cc4f955e301e0cf420033581e53193387ca0d0bbabab6f7299ff91c121467d533f21eea1816763303810c2fc098a281225b912c2e1629c575d36a7b060b094a7df46b257c136cd36936415a5ca584886d4c22b793e6677d3d73d83ec49e5162ab309d6a6b6fd9424fccf668cb0810079d6984c1ca18f4c8f64b0157e215cc67f0268c37c20a14855a0336cc1a46c73e34e597af34cfc28871285871532bc7f06d4f58505b8687359e2f33339c9f8881868dca85ad38ba665dbba36581b0dd60f9d22d9fa60a61a5feaf738bf87f7dfce9824b09afb178baa89bbaf59818a81887b125bad60444f5e13eb246321645fff321d093c958bd7c9786bb2cd15ad4493747adac4f4e7c013cf7449b8e7d0b9e7598bbcd22f4e307e7bc2e7a8caa98912a0f2197b5497d6bc5afe18baf303c835518376d792c06593f70635c2aec79828937fa659a77e293faf939e3af954755bf709ef9894bfddc59b04248058161cfd7632de7097bdd18074c54bb4198fd9ce67992b3454759e5e7185b5572ca216d6d0b82536a00a09d3a53eb1d760bae9d92fdc6e73397b3b045801589f263085fc49d45193d1badf1e6d399a618498ab79ba6350e741bb0b84936bb822df2a63ed901dd84b05663884b41edea6a08a8c1976db14d8d5da0849e0b9b8455f0591aedb30ece074076311209e372ef45d3805f3d097089a1134ca9362fc2aa736287f8037fc5f4e563f2e309548df54c6fb2d1e9dc75cc6d2688dc71bf9f47cbf538b10a797d5466dd8f9eb686ef6451c5cdd30514e80fda897fcdb47b1475b1fb91e6ae9756fd868a01e7543877faa1e43db42e812905f1ba9082a13e98027f073dc84de7d899457f510812f4faf196c6f17d9790acb0e98264dbb54319169a13372806082abd0793b7ca03aae19ab8d96eaa70763bb2b509c15bde00aabaa81f251f33421192d13891e1dad2fee2abce2110853239fc7735366a3b4d5937521c77d9a0d663a191b4ad60d7911c6bfdfe17449a1f67b00035b92adf6b5486fc5b2aab1065c3812d86874e7b9f2f6bbe79e9b521ea579760e68bb2b6041b52c3d1cb8992369f43fd9dc6fbe7af093f162aed158f51840b47455f06b53c864aa75963b3d88c0f48e9a1e5c24c55b6d026becaa1e32e15e8a98d368bce0e3870403a57d55a495f2aace01095e33fbb9225920a9c9796adfb029b435b581eed5b6eee2431d00e354131a7043cabb04fc7e4bd606bbfccacbc6691cf519438079f9c6541d10bdd6788b571d04fa6028b212986c90343a4e6ca94dc42c991d25c51724122211d4c93765bff09f1c8cc44a91cd68da47ac1c83c4fc5f98c1f30d7adce9549108e1801e52aca42ad4f3513ebe15e6ffc7b8041f232beb3b8b7f09a5e7cf47e1c22973c74ab356f795a5a816e208c8e15502792535257d2d4d8a4253756ffac04b971e6eb35c80dc76cbb2e29a1618b7b6bf305121d382522db5fd2f2292ad7bb187b49b669652f60d4ae2738c132f4f86ef385c0ace48650d7551fb99848f9e34b52e4cd352c0f39702c41e1e81b8264ebbde15ddd27d39a950a982179d3e7bf258d342556e58abf9b9ae2e29895b4c3a504d781f3884cab494f57f62145656b4203a8ad8ce9bad324dc5b0392747620568a000690ccb5d37c862a86bf166f783b2d9a1a91e4d823833f0a9acf3a380bfaa43cbfc5ab8a4645f88912f5fdc4e7322b2ca3509d0e4d0bd5240b99a9f8f48459813e7b86db466dd41dafe5a3f1e81c25e82b8048fa1026c28dc0119b87f50318952dc9492652fcaddca03dbddb4acbce9e272024dc68187fae03000afd9104d46c4720ce5f0ece290ed736940ce9632e6b0b03b47a8c6fed5e9480258b3daff095dd0b97530c1e58940443e45992a27d8405177e49bf2ae26ae495afe2ae9e5170db0c73baed6d751fe9675e26eba21225855d11c995a98bc79fc8a538cbf37ca5d0d28448338a354cf8e03704719573d50f58e401e838bdf1d478cb12f89c1e1108a0890fa6304664aecc414851915b66ec9d7ee6d02ae362a94e1964ec9f9170e09424176c73fff0f2b1f55ef5799da738bc622cf1f89b0f10e2ac3daa5db950ab1d653a3374b5b05e766f65786b50ff575c2092c47ff9767402be35c3c3966a463494cb921e3915244e03cdebb9f7d20b9d7230d75f01f20159a7349d214b7cbc1ec0865a9e99f7c4f857e93f782759db6894877f1f3c2150651a610b72b9bf71bec78cd0677d69fa4b49b3a5dd6ec337e009ae8ba4dcb4d87a20c1d9f9a141af514b9bf0959cc69a9d02aa153ef2e2942891fbc70d3b910574c4d5bda69bb89b099abdc1934a8b2c9f8222cb48485658c52a76854e2f32239c972d5dcda91957d7bb72f4814dc5d69f6cefb5a99e4ad0b157b887d4952bef6a8ac18e5ac0cd906d17949638a0fc0fcda5b3782dbd8d3860fa5259356bb95bd67fee12d60ffd262247c201df876885a86e176e203a915430b61dfaf1fcc6c8d8505bc85c9ec376fe5da21e04c5d8301e4676c3e52a691c4e2321486d2d7938f4b763b88a643413b522dc6c224b86d39b4d470925c0df7fa97d194b0caac94775efa3a0055310e36c6b08974de19f04e20c94f7960995b8c7291aac4e2f8af4d389e84a049139851d42887c6b4017d6ff0f77c9928105d435f9ed6e0141e7f25f3fe5f6d166bcac4c54b53b7cd1af129abe83c2716bea56b298cc69a2e2a73a991a832033439627fb87700a055b64ebe98ed986010fed067e1bd39204a38dd954d800e97eebe95af4ac3bf53a0dc224400d9e2bf6c5689804582e1e727d645a4ace7fa63cdebd3c348e1acb6f2d57f33bd75a60637926ea9757ffab8f10bf0c32acea718b5d2405dc6383f3f6b9caa46e83a2ae802122b9b9bceef78f72fe2604701dd0189b6c4c8e55bcb014aec7cdfe2fc590a2fb09dfce6422add0291e84f2e9a74beb26f19116bed520115b2470a5721b049148cb464c1c13f0c8197548650b05e9fe376281a39b5ca4e8dbd1ee49a8b0f708fa80d58c56af094fac51fea36625ab277f676a5bf48cc0b180ea3623871153aea305e00df8f0835c559a995bde63d010a6d05090731b1882595c6379d22963b563645fc3f050f918770bc8de438c7ccaf428c647f40ab615da74c899937f11148b21a3a9c28873e0156e455e47459da6cea8cccca14fdd99789ca94ec73a048d538c21e7c56fc2065e8512672696c3f9536da794378159c6ce3ff1bae0fc9496c9c17fc514ab3770ca8608be71cdee95601dcccb500701029cadd929ba2bea0c29e1fb21735c742e09156b1ebf35a800b7927b4af22a9f6b4ba208e7452eded4f228207642a33c812e41b0e96ae1c7c1d430e1579e5f86866b364d6447f60efce6a6fa6ffa49b0fb58dd5c65731b5079f7d41212b315b5fd58b4bd32a2d8b538086bba38f740d49c7447d48fd67a7461004bb79019cd7255e335cdfe0fe2b33735d4771a754ecc24103a454fd784e4b213d57a8888ec4be30001fa959ab7c87f8fd5a95bfc58607459165c43d593ca1cdd9563d93072e1b2309939ca26803e7b4fbd12941e7fec3b339c9a68fdcf1cb15cae3824b89260737ca1318c2dbed61810a7c442d2886eb50233e9097db751c496a36d65cd92a901bbf44132faaafd1fd6bb6d98c438a7db051ff63b2fd50a88d9db84af2189487bebf19dad4928b139cac779d5324e380c5d3b8b93351c1129199e9259f9c602b79ed88f502bf648da97c4c127343b443e36209ffea6d0a3605671304cb03bf81a0e18d790fbc0d46c1c8bd05433d97ec47feb9aab7c37dc7cc2c6c9cfd458048ab287b54d09e5dc976bfa4f6de837785cc41fee47f1cc7b4440b3da35856286d59219f35a933480d7a69584475e525f06c7d0c8d35179a96000f1a129f104184e08af8b6e591adcf4d814016e87b9e744ee0a822e860d80b2682cbe9df63450fb3b8402f168454a18a00e053e4567644ccdf8cac271b1f4e03ab7bb934d12ce4630605180f8731f32e77515044da0a007be9b404e6a921fe778beb67d0469d6ebb3bb9dbb0e0ee09a08077dc396e0710c8b693ef54df4477d43fba1f46acc101684a818128d3f05832a5d93c639b5c8645dcac76f728c706d48d1003b452a825826a3fe22f686ba5259e94c34030ce9920f90684b704feb291acec307cd5b0a3c0d5090011b151e5eb34fb189aee3b99dbbfed16474ff6b0aa40bb8daa3ac3e3faaca4a3715eb9f88c72032e80f356f93383df8b68f6cc19747646e12768b019ffe87b13da5bd75ec5fd0e7b4a4b4dfc878119fa1b71f028bd6649137fd4b9cc59392c5e16d7ff83669d8ccff3623897976849961180f92922cde5d0efeb6ce874647fa06f3682405ff24112deb974299ea9c7601375cbb33b3315248cad47da19def394e6e9fb17ad3531600e877e139244d3bc34bfc08d47aa7d31627b79666f453b4ad25a622f2357ffcd9628a66496583ff0ca5d4702a97c467deaa3815131ab18e38684eb0ff4d926457295c65690e2189b58a6cdc434395cd15bc4e768833880e95368f44e9d9de75bcb3cbfb76e20200fec0937961bdf141b25734b1946c5679d381a38aebdb40ab2ed0cf3da735d7bd4fba33b16308ea20a97decca01fe393411b251cbc145f7a80ee6c6d8579a0ac1330d663f9165ed10561c2e7e0da2eec44ea24f6019174b0d4cb97dbe0a769fc4a153d046df7c90c3dc3bcd32fad520f8ef767d5d1ad683e1dd931f100f8acb1339a4abdeb3137b34a06d78a9daf7742edc29b4f4cbd0df45efdfa73fb765e3b22f90fc8b1db68dbfca36705c8ae8a511b8b26fbe960567a8456a341d0ea258171932fc8f1233763ff387ae90c260701ce00c4df857addacc5cdf0d9118a1e5b5c3533e87d15594e8cf891cf25320f221ebd51ab97e0206c0016b9f3a169c4ff339b469f5eac45e8c81f5d5fde5387ab4f5457691db3766c7a723a2652e079df5002af04602e30cb8eefb03a640562c0dd8438c199a91c44c1d17e05705b451c78828cbe6b28201b9b46bb3e58351336b6714af377af8fcb45ec6f748f15f2a03b2021ee3bdd788f9f3dc1871a5da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
