<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1e8ef1535678e183ed5e1c18d036867f771c06d50e731c39d36e6b58033a3ae160ef9e71dfbf030dd2bcc60017fc7afc3572dfbcc07880203b538f231efd097d3aa81c76a20dbce24c4db50268611887efbc2b339135e089aa1bb50a4de0daba9599febf40315a0c5f8a7cda3da9a790c46333708557ff175a4ba9c8d3bf3531c487431fbfd6061b1bf23ee0cb9ce510c7d62de0074e96af1707bba1625d863b167ba9b51fffc44b5a0e3db5cf5ec13ecc51a8cc1be094abb95fc9b0f5ff3db69061893cabfe9eb7cf3bedb31a46ef26fc8596e9061c2fabce71b1ee8e8a24a40e121e1082f2a7820fa48a16074db03d898f4b80357f30ed0e48a76818df5208c80bebfea8ea961717dc77dcc5648e1638b6f37d4103b5a6b7b9fe24c0eaa4ed1df080f91fe41c36d073b83a04b77df7fc4c0c648ba418f5f793fc366ba51875e784e1f365746df3b8907cacb322aef2f1ed012d68210b746736fa6176da196aa6014351f803aef532097b5bda76d8dc74108e7c31daaef58bf3cb527262f8ec4a17a55bef85b638c5454c8035727443a62537cdebe818c6d758a6efd8a0c43d6dd070afdf0fa32b885d5963040b87eb84b8415831ca4bf1fe54b7d2bf72807053c6fc03e76e3309a4b82db95d4b275b78e2c3039310a54ba5c87d99d6372eb277dbdceaa8c0db2c56128edbe5a3ca9970783b6fa3417c3766e9ed07316285b842f33342930c7020bfd549276d9128ecbb64cf912fdb8ef05306b89e32cc1dd94a38723c03ad0158df2495cfcd43b85014ee5700bbc6105a97866282322942093bac8218f1015cd13e133f333d7dd1abf5ed7b743b4936bafd699df8d5d1d1489f916f8d512600e48b3c722a0bbe12a8be7b3b1e74b3c015b132d735469ff4090be77ee12a87eb6b1cbb80f9cc7da63566af4192a8fbc676dc8e573ab5c02fee7c15ba7895731c06567abb0960508e7056fba700cabd003c175b6a026e889c7a30cd13f1f3f6d9bb1271809bb720459285b2c7086c4aaf820f1af58094ef06351bbe14179ecb7d5c1b19cdb2f87edc156d074ff94194b4afc93ee6d961cb00e27b3bb531c3ddd48b696011395c686e5fa7c87634ab6775cc42bd4a3229862a7746ce9c674519a713ef0c5c1a7ce289345054fdf09c81367e04ea80326377d57e561884cee9640a24550cd631eaff3704fd2020fdbfd05bf33bd231be5df40d4aca567e31e6f1844be4c3f2be5c726d1cc04c2a965332b6f72f230f297cd3079d74f2b2d2ea9478abeaa204940e360378b9243499a9d5f95bd5499e1d3fd0872f1dfca8b2258557ed02b5fe105523cc02d0d695f288d2891f0e89ca6b9284a120b4b07279ab23bea28dc8640d62a52f3bd3cccf9e7b53d0579e1b4ac87cb4afb6a9bf1d307e3c53e014a74efb95221bea80bba0695aa56267e3820b3ee627eca2d827aa9c4193dfa8de5e143c9a1d09ee61a750cfc9cae5041b3c3b09f39c6ea6dfcc16ace4bfcf3b1f88cf4f04124a1e4d254953ff6e33a475b273f4a3987f670f5098633c8af29034995be75da67d428bcb4a8d92a9be1ef1907fe9dd66dacb0e6b9ef1e12801ebedeb367b9fcdbb45e804a90cbb0ff410ec735401fc0bac07a69359364f7984b2e5c32ae0f0690c21b2d8941928b31533e4dd5dbadf619acfedeae36b3130cc18b6e9e87c2abe36d02049c8794454213cc9c0471ae2921859f24aae3adaae27a3b4a7dc2a425210a29b2b4e6941983f9d1d2a37778df6fac4a0351a22c43ae9878bf28c790faec3432ab766bc522b85ef7aae4722cac188972f331242edddd76d6c323f465404d1105a1b2689e7e7cd6a6a61842e97d7b3412f9546fe45f65a7da73e49e4a1e90d7d1be4585ce1b950c3e44be89a471150de4763c9718da0c25e42762a94438cdf41e2264c3b2c0d940d4502762ba0f35f904f8d5823f55dbdaf01d02c7b224bf9e24798155e63d6af277c190024e3020aaf6c5634e24fc2744f1c8d8a1d8de7dd997860a8c202db098964ba8817b706cf72622849294247c1813a83c5901252deaccdade1a8897d8a1a00aba76f63be789554386e0374d8c8f2db95b5e23366d0759ce177f605837db891f91dbb3022011d7ccfb6b6ca3080e8350aad1ff627c5baaf0a91cae4735b2081fb844f83d3df5ac2ff752025bfa6de529848da6c0aaf61009c42b8acd4d905de4390b2511c2e2d6bf55edbc478c3b178dbebed37275d49b6ea7073323beea878ea27194559b18e64f0c35686757bd035e72ba711414e77738432280f46a3e15cf60efea44cbc4e2687649577e57d76d75d057465a04321823218425482eb71997f355c8425d09b00b5a3f5bac6d5ca6452112dfd34311faa29dd0aaec4ecac58d6617eec267434f843fa021d0f8d22007708357bf8580eeb33630da93ef7c93d0e95a54604e57e47ae15dccb9e0bfbd7add3848a35b72dd252388032acbb745396eb6955bc21a526938324bfac3983a90bd0041f0e578026a1941162232a3a60cbb17b4d59eb1e0aba89c4b1e91d468a9b8bc90b5d83099853a65dbf63ced1430e6bde7c4de6c0154ddcfe06f545226120d9c97b733593d958037f656d5cbe043727f7c5043ff4686dea605eaa2494d7a3f5a868c9c55334c962da6e76a587eeb3701c009b18d7c7ba72d46544ba05ad82d5778a3415fbe905dc27ede82a7f45e8647a8bb4d665d650173656a9690e59d8902521bc958f959f76a7a376c3ff884380e6e3f5f988864bffd934c4060b31c1e24dac5097611dbc31f35b26a0cb3baf205e9cf59dabb345284ef0dfa21a69288f8419ab8417828684d4db670cc53936a253e2d3b1221cd26991cc983c30dba2d53a3a746afc5b586fa78db4dc4254818e3ecf07f8415125de0a6018838ea142e5d71332c0b4762cc5e8a5c26ab776f40058ab8faf916563e612cf462eaa3a47b288dd0811881d62d1ff530406c2f77c7f94805c469b1bdc4875925edec4b9003be1135bcef6e2c233857f7f9f4fb084829681b49f04da402a7c83b3f25d7d3cde6acebd9a5f8f687973e3109a11ca21de849319eb41708dd551e9508fc7be22d0202d48dd7dca7cd568925da5ad6d9bfa582ebdfcb72bd242308663fbd6a2e53c82b5b8c27d384eafe3ca6895e4f39327ca32eadc732903b03cb52962c906eae4aa7693494fb561700cb589ace4a8118bde9626b56958f1ff4a7836e33d729cc29f911e960528074b212da2fa21227d82d3366221d4f173ca3ebdd2889a677a3671ba1ccb4381ddf59831ba56226411554e3746dc5010a9275148dcebf68dba62ffa507cd45d8b630fad48165c5bc1b46238119afff09cac3231832ebb79d3eefdba2d3cdbb0f7c4c86ca59afb8d482ca8aedb272ad66e4519e55a8ea271fac8138e289184c8bd9b57ae2368d828535acd643b958e47494f349f3e5657b78da112e0c6674727fdd038587da55a16d95a6269f6067d14f04418fcf6a542d5c3388d11d6e8c5504acbe0aae5db89ef7d2511594efc1b9b4f8ac1c12313c79a37eca8420b63eca0fe3c6a14551d4da23cab6a40fc66cf8ada5c396154c54b979cc25eb75caba8111a531978cc85d78ed1f953083a403b1e99c5aabef396d284245d607ff1cc12fa9d5b9e0b15a1cbf3ea7c62a96e2264ccc3db67798ba6b8e7f0823b3edfa0e66b76eaa6414989b432b870cbf89fe3711ac2cb849da95a7b04df5f3d2fbb220013f4eb76b75210b67a6a0b5183298d0147eaeca5abef325efae7cb1f25c0ed0225697e9bfbfdde6c9a059efd82623bcc74ec7139b23cafb1c4044fd29fe71f5ed10667593b31f8e1bd25518c6a9b9c587161f9c521446eadc71d620a29deee8dc85b257343782d41718053a91c6c99a095853863d0f3d7862be6370207033bbcb3a93041d0f1841de3b58bbac0eab866d1b78aa43cae6c2d7e99a063499bc406d20421d5d020134a18f0e3a3641fd1dc4ebffda08fb683264f67452328ab5144ba8d65115415f19c504e96d0677c550031dae609ba61b8d30e53ed94f098018443557697df36790a459cde114f4474eb4090826f46058067602ed3ee47ee00d2292d2075606b982ff8f0e670e10f31a94eee547f6f1839ae23059e7beb3e1d314347358398b18bbfbd69df45fd58caf9fcba9ad4c739a7dc0c853dd0a07a5893130ae1efd8a42e701f48ea815791930a83c9e7587b658943dfbc6179f32a8ecdfb746619a8a81e38eb8731fcbb167c191944d9f2de4a86379530479445a51a005e5ef56cf3f55bf0a4419b92c40ac725f1b56c326c1383f9d7360e93802d86b8aa4b701dd0c31661234e67acbefa3b6a91e79a911fd5bd9a5b8f4d3338da2eee0935971116c15d31b034fb9c4029659a251ef82b225f9cb02018b794d80d0aa5fa27dd89c7d5e8c988f0dbcfe107e0b4ed2f5199b2ca126d383f753b180a4c58ea22b674f51938bc5682dfea8c65ff9f0ceb3d5a7ee8104e1b2bec339c09b4e73de5786898b2a5204223149f2beb16a8d1ce410a75852ba45826c7c901b7df87e5b31803ed0fe784906eb77233f40e5e5711c05cdad701b1c9b006cf51aa750581e349032119e898016b4490d39769214887ae39c89f4df1c995559cfb5a0bac404d96b662ed3a75613ff4aae5c3b0092214e7f2b2a4b00a3af0be306d784481c131882d1adb4b24c84c793a4a9a55445f1a534296bf5997f367551a322eb4bd52578129f610e56fee1fdb5da4d3c9bef85036f48d9c84775fe79f14b9c529ecd5371c9dd2a7ffbd91f1c370287b283095e416e664ee7157f392a9026c1d0d40ab3d75e43fb77f9c9c9278d61aae5ce4c6debffe9a13de5c74420d7bb49a5b1ccbb642f5f910344bf7290d67592448195975cce3f1118c46b666e50b0ba4934b25c1ab09ce0b71a94f752ac4e22999d95ea3261ff27d232692f8d5662e1485274598e138a6e3493cd3882936883995279eb39777c666afada1cea58f1ee8bac60a98718cd3fc18f96265bddf51125749c5107c94c67da72fc0a685730afb6270c6683a7b15387ded98ebe18b302e1c712e838f0f640e3361daa93ea6817b1752cfef5c08deecbdfd4e7dae220058dfa8fc340108187fa8ce704efd755de1d7397a8cf11f2ba0b59f99e2f51405781fa76c55aa9727f8d93fe024325505635adc434595bf8a213416ad423c96375d8bcb59ea64159a93dfcc1a9eba5261e06035783cff1587bf6f9fdfa742d2ba65f6accdd6c89f1c5883f7ece910d629c6f83707f9609ee70b8eabedabdecd753ac6ff45f3c9c95f90cbe9a6d1370106c1a5a7ceee95a3a603bf4bd1a70966e4dc1ede42f9e7af1034ec1e357cf1bab3ecfd1f6cbc97800f1d68e62c852a76d6be47f63f987a7b50900010c68e0a7890867018d3e99a2d48e5741a37f44c74e35897b8e46c097e0b95b26f7ee8bbb338e7f35c4242f10eea9d809e7e17bd2fcb9c9b116b051ea343fc16f89015a4724b8d930c8c25e196b85e1d8522e4935b5da0e59e305042a5c47bdeb9227ea79d9b7e968dd107c661947b0584c655c3ca0aa58f7eef0db01855b90768eacc87d4a61ec0f1b83ab99095a274909d88377f5fe5801e188fa0eb5c04fe4a77f9c20984d086cda1d288c0b56746b19858d3a6dfb7203257a445675d6e0e755b6ce046688b9759933f185d148a860ec7d9d8c3b30d4c632f8a971cf2332cf669fb507422a00d4d308bb6372c5a8030df9b742dceb129b354ef3033ddbe7063eb4208fc1ea56f44c72e92458afac8b801b24547fc6c787f1e724136eb02e820e9e447cbf5fcad68fd01ec2ada65a124a3a947bfed6a406407c6db3719a2e0b46a5839bc5e7fb766f35b7a93afd2909975cdfb2e09dfaea749a2b131a6da603b35d09fde238b0a1611deda739182e131f8af68cd7cbb2e0bfeac6ac7b81a19ee6addd5148babf8607139c9cff2f8c3aec4d9f41c75492c165b748aec09ca2b0139a633d32f853dc1bfade5f735299e97541e5c9d77d43c4d1fffa66c7f585704436b51a69f887ff37d2b14b048118cb435efa97997bd97512c262136d8124e7c05ad13bf7da908dff3d14dc40018cf3e69dd8f1465a3a14cc5cef759a493d7ecc4dd336bce75720b70b2e1587718379b51ddf6c79830f986d273cc54a6979ce50af9e33e10fb490ad24ccf1ecb0376413906cf7256333dbbb618696639d34ec58a9edeaa2abf8f514f12cb08aca80dc62ece8297ade67723994aca411e6a2c5af9f9597333b36b41934573006d15d7bf1f0087f84888ada4dbaac0c4c1479703277d7ed7e5ac49927d505ac15ae02107b30a607d06afda1196d78e9c5a321d9ff66343214f454c3c26195857bc91ecdb7382443ccc593984efe15a0d8e0e3391bcd07648817a6fd9be0e1c3fd20d894da63f6d47d3b50a35a33369365aabad13a77fff0bb0bcbbcf8d26da4cc4aaeade541914e584b27f7a541770d8876d510e190ba6d1839275bc4d5848d5b6f63bc20a25921d0d09d97d00d947c3f9becb23ac3935e91ea9d671218157ea29ede54eb40de420363703a327d16c94dc09cc58ad00f190b765b4d51afefeb039c662aa5760a6668e5429f7cb99efd8ab647a91c8171eb12cff1e10e436dc0e186ca575df92fe32f8272bea03adbcc642cab013970baf0d8c0d6d085efa8cf76bdd0ea6194d3a4ba31c17e6d375101533af4bff65e0c3d76ccb2c67607c69957d2a9afc48466cfaa4f40a5c993c30fc5e0a483140f63308ac6d964b07e25fef111ce95fbaca812b6eb432b264fe30200e3bd5d42c509eb00c0e286c7bdf100fd2d96351b7cb833864898064c22fea23c909bd80d9ea7d58c92aa5c3f3b7ba9ad387952ec99f95be8f7c41db69aec181bd99c9a0d3a77f47c5350ddecb572f455acfb63f8d87fcf3c46a6a309237ee55fd87fb2fba56f468457aa656657ed75d16a28feb33e05bd4333428837a24dba2a1b5e9bf1c68a31e5287c4aa4a7755ecf9d842ecdcb4af504f7c44109c8cb0b652d05a40ec1b9fff9e8feae3a197f4de703e98f5fb50eab81ab24db7d5d360f285e80a4658ec4810298a9df7143d754d31b413520fea223b3c7bed5364ca3670d040a49a96322a9605cd33ef093a164bbf3a2bc4a919730441472ec502e67473754aa152c93dc22f51aa724949ac0f77c328c9792684728622e554b8ba63d43f3e4cdf4194aaebc32f144c2b2d095911e6d13f88813b9eaa656f54a2beecc1a45f05b39c41f89651c9f5e0f0d35b9807160ebe0fcd54f67105205d210d7d8bbd85a7e33052d559d7a56f1702a0b0d90debfc569de064e575cf60f3cba0df916d437106d363f58b94f1b6463505c229548b8d8e849657b2c3e033cef7f9afa1f034186f21ccb55016bf818d13f1f856fdd7e74a97d05ba3a81666ed3997bfd17cfdadac40eda50c810db5ab1e205b31ac9a67842854d6f302b49e3669cf7d2178572c6ca1f8f8da7bbdfe8c8249debd433c63781bfb7f7e8a755e16ef31dfff29517f4bdbd413ed7c3ae10d9098a4bedcf0580b4c4ccc0cd43014e44ea59e749eb5cadf83ac0a2d3765a7c656fbad8f9ab8e0785b883d0a6c376a7923515190aae02c2a2ef7024539bd0e81fa899d9a9fb4ae9477b95a365b5d5fdd85b851b773549c31f666d7f44e183eedd038517bad6f09f01a92c36034e1bddbb2017076fdd6c5762b402c91bb8b2582e1c63355b4d1d546ac13cd3088e3126064a87e338c113112973e6185cbbe61e2349dd9f696ed57a4f67b410179633a2650f01bcc46af65a1b0fc02fbbe0abbf4b2fb10857d217fd85bda5c0863357e0f613fd4f290c1728771c79ac371e92ff9475f500fa028ea10fe10d5d4b2fe3236169581e964bba6bee359916feddd56c50a6d33b81c8ed4beb7b856382b19eb1a647ac93251c0f92a1291c9d58a1f2918b224bbf33e31336e5750eefc47016f93512f2f5790980a6d47021442a03293604ad9d3319c13b8c9d7593f78c12ada572fdb90391c6c826f707071f3ac028f8a2b1f186bfdcf66a5d05e981781cbecde7e19f1d0e3de65e4051e1e3eb59a972fdea8db123d86d0d25c0ade614517e9cea8faba436a7c5966c606642fb617c896e08a43aaed07434969e1e5205c8458db1c26e5e05d95c9789b872bfb53a74a11a0363d4a31792459b59e1865eab739ff62025bf7d7cc4fbdfcae229da668845ae63afb62a80de4f9e6e8ea030fc5383b9f0d6e15e0927df3a13d5de047d0b3c07c15e2d6fdc38e12b3fca90ff2ebb9a0461ce396f2b0b692941b2d26171b0bec2bb8126b879ab0e71508abde2acbdb391a7efa1f83bb6d9878fcc69b851b0b80fd617cb48fb0bed9ff8e2dbeca43032104054bd2e10059047fec1e7867c686d30d0cce9c8b7c302c49f744bd9e74f05ad60c512a72077c1f11666cc18a6ccaffa36330012c42f8cc8745cc0c8e722f6dee24a7eb635bf1ddd4556fbda8c4e0784795fb9a5b4556f857ce973753b85c7711953f8f2bc27df4e89de3359f2d7b746f16b90355196fca0e052def7d326fc6f668998913b71bec02ef28e35464195f3dfe1de9ba535b1f4ba84d208b1ce797cb5f8a82c0e5eeb56e99d9af11ba2fd7ab6f1a2cd43bff8e327cd593da34fd5a1b4c85f56a198db9385aff55eea1a1a448b7f25e7efe644b9c87bbdcf716daed50458a7764404b6115e9d8a47505994d125780e6e19743e22639bc090ade7465870d34be697332fcbe25e30198aa8116410b4cb0e0fc4ea30f7f09f91636e10a8f8b5b3dd30c89ccba22e6855fcd4a3a2c83e586075514bbd5bd1fc5be3569dc2bffd5cab73774f4395b3471444428f39dbc56d5a410dfe74fc7f5040abbc86176aecbd07b128113647a239e232bb0d8cd5c2537e79acdbcaafe2274cb2ee15a710d25a70ef3347bac5de4a4572dd312ff3a7b81a40ed583efba46c064f66978413e932e3c2837dc1bbe7a4ae1317475cdf92fd1d062c3fbc182aecccd24f0799b0d2371ed7507c55d2c99cce8462e23bb3e6ca7cc4500a5988951d0e8b4d8b2ec2974fb3f34fe1251ebe55b81eb1aa3f9c5c70ba269b0689eb44becf7a9ee8fb1e06ea634a7986eab97f7f5c7f79c5999c5b4210f80d554f96cd16259b7ef48b3dbbc486704d039f390774993c68b0c936fe444312f28b07a937df82c4be04a4f16031bc374d6d0e6b1f3218b3887847b638ee6a665d0617be42888861d72059546265f19680d5f0927ffc4e266e428f5944578b2897c7d5c5782b3512a9242ba8efe9afe3292ba805b80f9efcba450af4ebf7ee644ea87001ce0f4a5eb9fdb5df40ae28ede4cdf8fe0865a105ecd9062a8c75d893d0a3d817245c79c32e27040604902345951428d6a8c5539e0022f43a5a25296344026711025fad69e6e6a26a6ba7324e381eaf6c134b7862a24b0d53ff8c099ed9ac37f5adda49412f4e6eea885812db89d11d8d7c61d0a18fb82d554e042a20cc243732b44ae3eb5d018f9426489b939ba4986f0accbf07f8539c0593dbf51e848170a79452a958bb63596029c0d7cb25980604e9ae346cd45149e6a5944f658d198f80567e71606b7df1ec580c2d79c70d12a08ed918c6a55901d52d68ba91fcc1d911f5302d03b4225a9132b150fd8c3fca053bfc9c725d8aa4684c78e5bada3a2bd55a71a256ae88e535c768d5e3431c177500df5dae2f2d72f0f448f90f9e23cf1653400c9d664dad6b3ba6fda0c92dcce92fa53bc459bdad421f47ff86af0abd37702fa76c1ba7d2fba1d7e56e71bb6a8997c1b00e9ae010339c6da3fe35ace7bbf46beb3101d925b7b29dbe6e875b5456d0e2b8c4b4e83202baa37bffcbed638060d5108ba16c346fd86f809504dd16339cc02df07c7bb8318093ca7665780139741755c91bd8a7157346c95f3d0d25354e8b5167bbb9187b4c05e7f91e72c95dad7db13d67a4f1897dd9aa4d9e8a4870d3b432f96956fe5f98fe6d749cb3f57b653725c7af9dc73c96c072db562e245e911ddd77b19482ebfc81974869aad5d17604cf837adc0897ad22002a892b4ea1a184aa5280afa8285bfbd3e7a8f685a4b7d48684ddb011d46b476c37a0b3fe5abd3aeb561c598f34dbb6aa83547c0c607350ec7b08c48f0a36be83b9aadab8992ca43c9839be923fc91d50fa2482e4cf9decdedc0707bae24907a71d930c9056ac7dc32fd00f56582553d3479c6aae6edc62159ccec0218f20a8dad98cc3af5644ebc9dff78a4d3caf650ad20c551d5ff7b971b14e378e63d456edf816c496b3ffc234470c8b13f7e6446a11bcbdcb81284e9a87fcad5ca7f82b652a28e34738b0b6776bccb3d3e067766c0669b291f298790d5f2838bad97fc23d25fbfba103f87b9d4f332ad0b3863f6bef31cb932711c26e0d851aba76b0d6a65a03b35bae710f771e6897102ca31521fda1a0688c4f0f16ec63f232820d1f3dd696dd68573bb9dcfa6d79590e70a718c7583245db430b7ea393059ab5ca70fefe000893cb0f857bd48e92944fb0df7a3f63b4c87c72e111c3866b3808525c1cf591cec383249702e3ecc3acc231ba4ef1da2453a67310d4bfe920d85042782f5e07c452075825136a44ec1cbe763906d32fd0c4ed1fb3b02638302f33528e58bca8402ab13e0e143f3b890c39763d0dc19061152d355168e54e8fb30928242815d74e9175b5b4c9acf3f61bedd9503f80fc3d58b43d51d41b86a838fe618be40b0250490d2d5f45469a311e523dec02d21d189af091719142ee4b7a37dd5018272566746539a12189cb12cde4a1a3eef09828a0b307c3b71f46a6140cc02a5619cf64ea604ab9447bde6857074e7d05124004501878a4458f496336bf81ee8b81ae59a3bca969f8dd3869ab030ffbd5e9236b181cc316c3b640c63bf187ac9153aa3841b9f9292ed1d202d777f4e15197af0bc9b08bbede4b2724270d3986923bbba53d9a5d7a5247f6595b86ca2f49a64cb03ef0c3dadec0524eae194d97ac5f9ff7ec00c7016a51628f7e0243c7c42c5b3dc066e51a4d3e273637a0c7681fa1ee9773447c6160132d557a9b289e96298792b6e68fc6e8a850e8094d5ed7667fd2f69d38c408ffb478ae6e97ee993d4b3b241769b8506686f97b6849c9db5c07f038ce9f84dee256d6d2676f338cb9b4bd5f1b6b08882ba9f9ce94d4ef1bb917d98fcabf47e81dde2dab30703f91353de2c8021a2872e35d9bf2e24555e7f08e2c401004036eb6ee09596fd289c8eabff8d2a130aa567ba6db9cb8a5533230b38892b1a4868b5a6b6a2b12b56198538143ca73393a845c4bbc65a7f879afda8941ebf6b8200985630c811b6cd62bbf703cd35e67acb534d77ed3e55925b17bb24d6a776bd2af51492de988e806ca86cd05d6d684332b82c372d17b18afb4beb8296cd0d3cd8245fa4d48d4a595741dc5dc16049537c9b5e7c410914586880b478be0710c5c48f519858f7972c663a4f2d9763ccbeb60c76e2d43480b0850cf60c9e96f51ca14b72749efc3514addd7ba81220ba9b831bea2646e7310009ce058b1b4528655566e03863bf9c3ae8fe5e7ba99147031890d66e5d39b8a534989bdc996b64a078838ad3de2f9c168eda8c35f51a45bea4423c24250608e03f4b73acdab1881bb1d1866bdb3f6cf575197e53f9ccd32de3eca832057f3804e8a01d0c16ad30ee861e66fc12aa47a45f43682c9cad9eca2c1084a6ee20822201a00839206922efc65ab9b22dbc58ba0ca2b38ec83c969628c72a3e456a1f6914af6e66025395f309b6e61923f42392c9dde8910870e0efafd7f80f3753f5e78ad1c53d5ed6ae692c436368ab1cfe08a152b2ecfeeda319149e933cd449f9064694c5d52ce16ce771501d243d9c20134c821ee51ef05ea71026a8fcb3823a16d222d10f4285785af579be577ea2e6aaebdca93a9e015460c48a16f811b4a3a14e6d6f6533207851852c0546a94ff2a9ec7e970edf7b24c49dbc6cb3600cc850a866d4981b603bcede81844c3d709e6aadf18df74d0c195c9cf6f519f52542820db56c1e8110b816240adb542c24f96d2d7787f3e7dcd58e56ad1f694a3c3a00fb1946434b11ca75167b0a58846d7f08615d4da47ea4f1413b60a11d607588774c139a898026e59bfc3c98587acd8657026b4ca6c278dff64056cdb5be7f9d615a82b1a99358c5210be928cc5e367a62bcdb7533b5ea9a9b14fe769e93edbffb66936cbb9cffeed36bf63c42fc1ddd1449725bf8f0c537a21873a2757024b7c774eb8a7b272293750585c5e613fcfa72c3d82985d979397dd86074e6c388a882f5dc8158083cc922445ec5fdeb596b5272a90064a6250396f472b287a851ab422243b38bb6153c79d77625b27e3ddb02410ad237842361c411f849fd4e0072304fdd9e75c302fce35176c934c58fe940df983de33f7c55c573ce323e15601548c9f2f70359c17d9d998b03c2154b0cd08ab0deff881e929abef1e250258e822e6f4719541400620bb154ee9a62333c07c036ab1933cca0b6b05322e829999fc0ec279ca2db7eaf92b65ff075754607ea519eb2a67a56c6d98f21fc0838e694f6dee303576225da25c573449e841f7314937f7c6743c471fc5df1f8c2c985d9757c4103c0e7d9d027a6dfaa17ba554c74c14e487fdea5793c0e74bbd3f677747cf0b12b591191b11ae5e7b79ebe5f5f0a78aabc6d5e2fc619049b56a8967036a70df11ce9204c33fdbe1243f46b6fa1eb187c8e5e3b94aac33fe8b4ed98da33965e10a1b28b7ec4e28746f2e2f359315623a1777fe7577804b66800b8fcd78a353d6e92f82ab574490d260b6d3bf2d46a9f364f01487029023297a056124375a40eadff327b4fae523e798a085bd2a0b9859ea59899ca78429511fd9bc5101b0f778d6376c8572bd60625198fdea21a4c09914e504adcff9dc3599b2c536dcc69bac20c8af4c7b0c8b8d01f7053dbabcfbaae35fc5d75170e40a128d20ffed950dd6753333a40be36575540e9c792e477ff7d40f48041aae74c02c42d9e09fd42da9d1df85394dddfc8ea59253aba39dfdc6affde418d1dc9731725430956276a419cb8dde0acf0425db737cb0b26b9f56ac868cbc07df70c264ba428bd59cca181e62123834c7ba021119012ef80a23903c20ac81f991a148a254c89d9424f02b9c6d69199563acce0267d61fe9d5eada207d6c4ab218a81a4716322c9e653ddf3b3d6cbc746d95a174342b0cea908e16c85aa51f41ff64728d448162c157d5b78986cdd8f75d39677098db9e508518e066844a245e0dc5471b980297386c42cbf5ea33c625085fecac01e5f92ae9086b5c278de4d384b8f5e24c79055ccf10b8b9740c81c24f30ad90d0260d35a1b987b1de3b84e53f5c2fbd055efe0658c37b2926368ac9e2115c4bdec3bd5ade2c3c73aa80ce642531ba6f631abbf1d1b1a50893ae7d9698e82023781a6672af1ae01022b3e8cd1e0de67473accc2d5063d4b5155ac5a972199091d9fdcfacb916bcd8d5de3028c74cfa18348e4b5a34e909cccf019189de5ddb773cdf90143aafc085affa76e9699428822ecc501d9f00e63a83a73cadeb09d18c666fd02bdf8481d9594f493ba8fc775d7de415bc4e90006e4487a100b07c43523bba07db8276fd04386db873dbfbdb37820fc1c7d68cbf9483534a1735579e556d1dbe19565bf3c86576e713df3194218980369785a84802d69b6db0a37f400a08caf4cdaab9ceea18a5f5f0b991050b27e8c24899ab134e92a22fc8345bdbcaab07063e4f0b710f4bd73e68a5d9ffa4cb8a088ad23273d9756939c798426df551359246b12dc6cacc4dd0489615dd232133f0be186657828fb3e5bb0b80a31771a478deb2c906717c6f31b7b161e119bffb9047191572638c8cf4df23c8542dbef86f5ee316f14e6e6411dbcb3c51bfd067e8ace4990156c447922afe34c85a65208a9dd354cddde63544973fbc7f7f2230393b9e7b9d55a9740c9ec2fc17b2f4859c16cf58dbf0b207d975d6bbc88d49d6a095292dae5c9f761084b5f794ebf120c3b68de411459693a753e0491f786bc1a202489e9e2a073857f3bd1df5c0b50e902fb6151013df5f16b3feeadec3aab0f49c4b4f1b1e073ce7ea9afea628418e2b9cff84288e6d728387631be8c9c7cfa67b4412f93798b24a29def2413ce5be111569b9cd159788e81d74a9ab9d2fc68145c27dc591c4414f82063fce73e20dba8cc190d45a7a58159de83c13e7b4292715280f138679c9f41b4a208e9f1f9f7130892dda10461eddfa044d03d2442a8b466abeadfc5def61a98855e1e0c61ab6e8872ecb362403f95c91996e5140b4bb477a67eea66c73df3544b145b147b2d9135e602d31742030f92b459e3502eae98c9e277f626f1bdc5d992247ec8ea94f294b2a927b97d9b3826406979a337b83b6b92ad87574a2d78ba2bfbd0b3182706b1bd07d3757073f25f52e53fb0a483163ce0b2fa68573f805b088fad8d94f59b136d4c3ed0d29307a4dabb05f03aa35b54593a324f59a1e1fdf05f94122d3f997db9d3db796f0aac47c55e6fefdce2b928ca9cd899bcf85d3a7b8a68c2479c7026e34c9992cc067fac9e49e8e577f0582c2defba86494c4c41a9255f721e3372350647d09c0289099703982ba0cbcdacce8d91b826e67332c8e04cb7e1a18c0786e3a9f73e9018bfdfeb5a4347da3e284abd5763b02375e1ce2168f8c8393914988c5791e42b4be8496e83a6414f6fd94b54283135da227a3613dd0eda0c88e457f01d2805cc8db7e4adfd16a7bf34810971b8c84d71aded16cb139930e49f241d287a1f4f956690fa508366363b412d78d5c94dc956d09ef5907f3cbce19b35f6c0f021b3cd86bba912508cb9837de3e8fb70663ee2b37125afb458296b1b007fc940080c2661316110333aac6a5ca76a91dcfdd420c0bda7916548c15e8e4ac3eac3dff3ca14fefe4a59ef587d7c62418124ccfc5e10a5fdb424fec8dd084fbe23ddb5d027195f0e0778e33f8f416f18248a932e08b1a0fc6ef2a1229747a9bae6fee7de13f151bab5d7ddf8e65a0d2c638f3c8fe01030286d2f3fca07f4753070b53e53ae5cef5eb810944a6069d9b4c1f459cd9ac27b80300f39146cf53a6db250fd59dde43917b32b078eb733f7f9d50f4bd4bbad22c297e24094216c018e6290d4db04a4f6f01c48d09d7ff7aee2dc2e024c4e8af444b3c515f7fc867d9b152da9720623bfb0c2ff1bc36a75437ff4c50d7285855bb73089d0d9e1fbd084a1293665286a52c952d46e4520d90b69b06f174986c0f37be3f421ec317abb3b19ce5167a46d2442f543fae2fddbcc84d9d9dadb99895dd4dcb219730edb65bb5d43503bd59fb07fc1d10b0f7cb3f667b58eb8705ef48392f490d4b8203ddc783eb2117b6b2cd2b1147af3038d8d162fa6c6a8b8d3fdbe410162d5719a1bd0aad97c5023cfa3b982ab29f832854a8836b14ec76c5eee2779b335177787d43f67794e63895da17fbf6cb600dada45d917c7145e47814fd61a2014c3b1b77e3d6c5f8898d52d9d67abd41b8e22c739208254819fc559018d45e1f7dffe6c644becfd9ee07bf7d29fb1f9399e73cf38443e20c1da45b6d4e78b5312959b9018c73422dc0a23f4c522e1b6ae858f13b097b8e7482da16fce094670dd2242430b0bdbe53f0018b47e5749548ae35d7e01ac4423d575e311d0eecb0ac31cb718bddfd8d963de1d675bca448c9c966e47ceb9556e00d74fb42409b5e75c9d65a09453b8c2d14fb7ddf7c31be3ff26a6dd4a913fb7470b12a6fab79e2e5f21cf5a7fd4a5860f0dd2a957475a1821fa798e785dfb76fc080d0f45a9d38be7cfb04ae84f52f9d64927f1485a14970cf64183d751182f1039a8ca527abe0e72764642068686e916ac7eb4a245a8b80473d30c16526e2de19be8e069817ed0544d56ba9aa0324b9e95dda1c663b8350359fc8b5a51d1049d82b69e044ea55de4fbe1eb82c08483346105dce0cd31ef106184dc510e62cb7c6fa3969469c8bd813a8d2ebd5d9e854f238a58f1379e57e47761724e5525988d3cd086f5c098aa4cf4665b380f0df0b48dafc4f7d657128264ab18a9a4a9ac9be28bd9e87d8d99d6323e1be8dc5570870d3d828b3457bdb713290c336bf5d2b72f398625edf8db1b1b253879fa353b041c8be0c9811c06c8de815135c5b383a07fc775b22cb6d52ac80a8814f7e9cb941ddade78e55cee8f2e4376bf71302669f358e88ae2c404ec18cd1e39c0e449f457b537e67b1c0606c7bf396b1d646d5033dc77c2c14e59a61a593341202aefd5ea5b2330b6578443dd8ed737c58ca734970f6dfc33b0e9fbeb609a461994bfbb085909e14f924e372bbd193f96b4fbc8ae39fa5fbea27046ec2e847e9df4815590e41771eefd4cdb3bde0ac42ac1ca626600b65a3bdc04cc0b5e4a5cd5dda8a1e5438656d58b23e132798dcda33026aa9ecef7d93060523e68c8d3510d2c595d70961774f83698cd23256cf069ccf1d3f62c75b55bb1843cc9b6f12817016c4f121aeadb96f76c3dc81eaf0bf682c3d74b2ee0dba3ca0d2e884c6cd0140c78d86e716b1e51ca747d948ba99abbc3e41473438cc35414592b57bd9a934037864bd7ca0eb81e45f1d918e207137917931aee0b6e1404008ed10377a12aa92a2afccda250b9ee4bd1ef48822f9155097a3af094d7a832cf3056398a0a4bfe9cc8d55849bafe719d4464cc0e44c7501ade8f3f5a45a5adf62fc2e7e5474fdb2b0f658964c6127807ff9f8c027d81af720105620e5e3f457a4d0102327bfff56a0a3a26ad2a94f7d952a3cd2e1c279ce0db0995e17d14483993bf601df32397236afecddd96dc77fa4f487d683bb2a1da8242ea850ba9b7015adddade52396ffc52b93ef3ededde113540596c407965f1958cd2902e77cd7302924a1855dc2faadcf5fa6925eec66ec8398ab6d5a1f3b18d1424a84a50ae2f2783b335a4e1650043569e5b42c231bc040b59d8f99d86046f1a91adf62a11ca1d993c4956cdad9b43e28d72c6366cb907c8dd8aab7b3de5a761a2fe22b162d7a48ba11c43b0c4efa613ae21d73aaae1e93c7caa708c32d889ae6f96b1330ac0d9b302595c9ab2f9c4cf253dbe142a33f66bf3db54fc925b364ef4b6d4f91c2786f98329433b9866cb9e455dae9f15c03980467930e2c39e9a57a146505c3d323b9c9d3954b410e666663d485fbce577d843cf4485da9a8ba2a3caf7d7428cc6b63576634314b65579f34b391ec9b4c192c1489db25c08f1e3087d48fd2d2bee01c6662a28c063070edb2df86b15571dd458e4a396c3c2a6bfe33a55661fd0c6fe6fba9448adf5fd8192ccc4213c8d5c40d3e455103b4b7444d972ff4d8073f371ff2ff76aa7511321b40aafc2faebf109c642be2ebd65d373c24fd5445ee2ae4970183b75bb633178b3e8387e28c5b2936238df64325fef4b3964a9f74fccba3962a634322cf9d8085aabae6f9b6ed90216a1f43f9b15ec8a66f0f16d0fbed74e63bd07017cfe40876b69970b543cdbee9096193ccd7c4d2446a39800acea1621c230325572ec59becd42a05465fa6cf6afe3640218fb7cdb52290e2c31870008ca0ce6b4db44af40f5427dab009d69ade5ec66b10c3d07e496c147590d79b48f7ae4826252c161582d167e2ecbb186ff1fef3e1eb9b843ce2ad718a9ed292c1b8c198d7a32b09eed92e9bd4f333679efedae8d65e93ccbf7fc814fbe0e6c961952a2d772ded6109eea304cf70bd0612a1796e6288ffd1cdc11ad41b7c4efddd79b837557e810ffcb4ea84d87590ddc34e6ee7daef5adc1d7c7c48d472a988eb0124c918fc200ff3f04fadb64403fd9ecba846bfc3feadb65256efd34857d2f2f504a66fd524459cc148e2fe9385f12d511935b19156679c214d1722be7349f290cc3d962bb6c5284f5883b97de180df4d0a4e091bafad0c99433929c00ffa972b10254330554f5747a3a1bb42d55f74bd65403accb0bd08d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
