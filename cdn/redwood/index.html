<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a74c26fd6164f0a9504e9c3abff496e47e20f5718aafa90b3d70752d7fdd82c3c1fc7101864894908e3ea7e2a73014e8f22477530d1b45f1e2b74ed4badba8373ad3c97ef4634a15823157f2cc41331c671224db8301f9f7788aba4dfbcbb4670921e6dd91246d95225e0ff565fb09743efaa6cd2edd4d4dfb786c8deadf91affabf9f710013df98aaa0f6538b95712e01354b56120166e48920841bdf5d40226693e42b6b21e10a51d551b83e2722d20d61f5b991f3398d5569147b6ce6c9c6cc96dfe7d6fd66c27b7bbfe7ba5e4a785159376ff8e6178b155913d53547fed3625ddc728a989bf012b32286cfa116361e9b113ae5092a4cac1f52d6d36d52358eb72a09ce78b274867168c72709370b4b54743e8860411e35c83caa564e34204f60aa73118734f614123c8251707e3c8358406b795669199542933932a76b9890bcf302fee560b81cb183a43c0ec38790d0ccfaa47fe35fad589eb39905835fbb6f19f0f64087216ab37f085564571de008167c71f91e80064ba3d3ff4a7c16b83619c94e8500097e9f414c1525500288a5bd5dbff3d8b5ef7efde29fd81f004f6322d15542cc934f241a85e91d5ec598db6c2e1a94924cedee657281955a1e0ef492d9c9e02906ee90954622bfed687fe485dbc518ab4aabfe3dfb84a695c2faac05de46de89b5cc717f40ca374eca1ed0dd968bb718e4cfc3ccec4908440e3eabdf601e60a4f4cbd1a0ade68ef9be32f60080631f4d4c3ea5a19ae9be7db10e8e536a4ea2bceae7bfb548c21b9e6a9e973e2b2afba83b81f86d998bb7fc1b7fed51ed55c619b3d787830a0ad82e827996bad7f2735028dddb54260edf6c233ce3a59273c4a11df9a6b1359af41b181a262ac8ebf02c789815d3f32e8e178eab29284de10ba80f14afa9a9bf3da2f4b37c23096a9d1bfd12b4a25d7aa97111af801ecb61d49b5bdda758c146356b8cd6971ffe19bebaf63cb9b2de20cf502661b7f0b25701a2046a8ca8c12fd6559feecacedd5f360fa29de59415a74395a82a1d40cc57dc82b7c4cb2684168141b5dec8d43f226d27cc3651c5e1167f12b748c3a1e1a8698f256d07a6a6abb651ef1a440b6ed7be373f7c75085825f853401abe5c684a1f79a57c8cd7be02e25e76c211d3167d2598b9f618031234935ec712a3fd0dfc4323956c10bf5f233044e1029d86136de55e73f623aae8295ccb3a4ce872d799c496f2278530a710415e9fd82d0f8682e0ff0a6abf111e690242f058a11bedf2c782c4e045c2488826e6f16f1c3ae9f1df159b7327cfc5ae9f3346d2e91bf0979e57e54dadc4ceeb905e78938e1ec28278df613365eb8853784b7b081f1ca2083a8f46234ef65593402ffb8ea947360751ac150187142f6fdf23d680b2bddf14c09275905b5f1d773675fd581a5ee3cd60aa9a3db208ce49a0090d4db19c371420fa16fb1e2f1972652126b2220c2b7163fa5682547cf6d0cc8cf3e791b7ba24c947a29db01c74c3759690bc3bd58e01433e5a8075ec136eac95eaad510daae83975c94ad544b92a16f2e820f8e4186e87bb5535a27c1bf9a47ce0309bcb95467f81003e242ecd4a6a0abe5fbcdc53e07ef98d5e9bcd4df1c91f990b5c73325bee126ff3c2fab217a974ccff5d60a8449e2246b89eb705d877b7455bb980e1c28c015306ee73e6035e04c65c402604d314c1227ee598fe99735943b84da1e68abf42c842e5990568b67c1c0f31fa41a16b338958d428317e3f8ef51b4c01696ae693bf5256ee5f7e41ac34fee017a1aa568117e09958324891d63dc47cced2fcadf437b3854d8cac8f8f00b9af586faf7e0abc069f1df6963d826cda159ef774b3e082be300207af298e14288989e0c3f46e7c09f1ed7d290fd05b29731cb6e72c90460e6f09700d40a526be030980e336121072642e3117cd53ea8b0c6af6d9d7e6013e0e44f5493e034138a30ff94e653f3daa3e5633c265a0fc2907ea9b14800c7b38adb3e0923dad6c9433763dfbbd4884357746082598e53e3d11b075d16f7d99d181f2d54f2f406a11a25c4eb7691dcbe290a1bd05eb27abdc808c9c0152a7cd521acb22f806de804596350d8fbdbb9511f9baa5505f535d3ae168a290b79b360400aea5dacc6b26cbc3af08f8d83984902b7e7e73a28dbbbb831b2fd4eab923159162788986d19feb66eb96662e048f96e461c8ef52469eea6b6a2a31d110c8d1948b32d44782e3538f9a3245c8d7a3f790373e5abac4e73f64df43255b5d474f12520a4f5e47cf494dea068be51c9dace323edc5716ba383856341201bb6b81f11382c9a07cc91a5a20aab30eb8eb382028872b49dd7b018c1373ac5fa41b5e473a588f49dfdc9bfc6265ddb464c00fb153e1ae4a1f0745bcbf67dbacf16e350f96879be9c0fedde23e534ba98a5f8d69cb5143599a73d36b9b9ce66edc605da964cfffe11bd2ae415c42cb96c4d86230547bdfc00b200723c863503c802b004b7403457776eccf73b0157930c44299eaa2708caae86cdcb525fa5ef0ee07e6d530f64d2d6fadf619ce1726b307a297cdc397993f324569c4d47a9ac5bcd88663bd78d4b016073b600ffa817ae30c642ae124426ecfda3fd50abd308187df5c7f62b3b234721a23d36dcc810df3a0a39d76237e256f16be5c696199ff6a53d4bcf4b4ad2a706353a7d470f9f345008aaa566755d00ff8f80092ff7c29056993b4ed4d571dcaaa0cb4ee263679b951ab8f40386a399523d9cb9d7fc59219b325d8350e143d491ce8c553b0ed987d8fc81d6de39aef8445d312158bdbdd2035c6d46639c02dff51af853ea871d4a7ed9b195306f2451253e9a22126f244873ec05ca20df63809950a9a92b56c7abbde13723b14748913f1ca9e3b9a6f8ce20bf5b0fcb7aefc8b6e2b057703cbadd9892eda10560b444b01dae917c398180a3fcc81b175656a0526d6dbb7c25512d5d5b7c9ee372243b24174949e7a4e342a8355789a405d3b66227b4b65aa7414f7586f3b0fea6c9a8b68dc74aa9d88af2b78e4bdbefc11dbe812998fa10410978945b0bb24a881c59468757dedbd543de44bf3638342ef743e8e0298e6fe769e0edc0df473a58b22bb432bc73c050efe0d288e97f9db0f39cd6ea3d42f437b4d94001646e09b8c5a5e1101f754a8ab423354f8e0e1675be76d50f559e0320d4d7196d6bac68dceca5858d3a1eefa0662e8bb27dc1f8838971a6e71e309cc78498f049f69954f400b9231d0ae1a20e927b79ed03b43a31282f8357d73863f366e83ce49c3b2b4bd22ed078eef0ad61bd3a7b2b80d5aad3c16f421b3768e394664f44d7c9f415bafa435d5b4ca2bdcce93c8609478f0025b41b15554e7ec4dac11720c79419bc3d2a96a46cd3b4f93563a40ff27328b439d61a254b31931ecde9f5fd5489af7453d13c6398cd28db4ebfb52f106bbc5995b8d14b265e87d308868e0c297d8cdd17114a1e3bd2342ae4a3a93b7f6e277c995b36a3654192c35a2366f2fd0e3dc19efbe66af9879122632ebc2c9796d72410d1b14f35e97b78be7ed9e649bbb008f558286005dfeaf42d61f8c9084fbb4ffc3e1937df77a9fb4ac986a3d966bf3e8f76c00f5a792a9d72953d0dbf5df038f3612037b77253d9d89a4b1eaf7b0d01e48d87e2885480b3f9edd26b8c7e341a5b11c9f7d677096418dfebb159c9348bee4f0dde2e2bd0ba88770ef1c6c5afc532834f5cc13ac471221782c0f1992eade0c49281206358e89cf77334587c7c58821bebcd6aa52d71d9e312708e160dba67a3d372f259d67ec50321e51961883042468c8771712e6ecb8ac9c2a3d335581edf480ca2b19c75463e96f6edbaf0e2cbe55eb8f30b0bb9486df414119fb0046ff216fb33b80ddf086d9575fdfdd258e3bab56fd4c7248f6e5a99ccc7555245d1a334668f8d18d6a5032b8acf473ee52274b744505d7c8fc301e8358dc26bf413a820deb9ef0fcbab824e3a040fff537e206ea87344b0831bac289bfbec40230fb3e4a3fbf4d036e10b6db22aca05d7716b658ca93fc1fa613bae41ff4f517331eb4471c78463510b1d8f897c280e05a89c4047896d06ca7fabd8077a300c5c0aefd1d566d37729a6a62b06756a0e19ffb5473b41ece95343f70a9358c45c465f89d9815a13aab2f79a8378b7752b1ad4399d876c04deac2f8bb7b2743dbb914d8b8bc48669b403396829915a2c57941a0097c1bb968095812ab80e1c36d1dce6b760f818d60dc416f5a510253ac9db4dd27eb2ccc70281c12b3e8b6e1fba2cba0cd19203e0fad0ea15b7105f515745eae8e5de5970e9bebce9d2257b754be5f682842a9417925f0e403cfc59b92e73b42fbbc61e876b27c33c7365dd5f19b110b2b2c83f3678f0f7f4bffcc6809701f7a1a81546e0b1c7b91b8c987e59d1e062e54b971bc8094d6f15b01a30bdf0cd01c036263d371b050523f65f94e304fc717b93d304f9646993474aa19de95c58bce5c499b90dd00dda7600b79074c0fc75b35d7e8e079edabe83b37a6c57ab387ea493ef4958bb8a8c7f83571c5360b6f9896e8c9cf2531624e431c8950fb53c816375c479cb87d24050e3e919f279143ffbfbe2ee2a8af41b0dbdeec1084a26979c4dbc0b0a26ae233ed886e940da9b62b6b118875da7c45f1698dff5b7d4d889063f724bf78ff87237195baaebe4232cdb7e6a26b1176d13877f0c38dd368b65d11455319412abda0218858c68f6c9c9656266a72db3740f6107553b728d257aec2692e6fd0a67415eb46a5b67f883673e1e055f70d0873bc431a3ca98e92c96deb0330b08b230241471db2e118879fcad09712c593405020e34d3e7f29a7e92cf19e8770c73e3fc94f53c8b896f410c684be7f3b007ee1e07423ca4cd029895862ba32cc7a36c58c348720bbb6ad6ea80e296e45e0d6a93c5ce7e1f0a1157360843543c3c38bb80ee163c572e612b0febfea021e0e7e6836112b385da542b3b067f6fc48aa5817fc2cd7c4cd167bf9f90dc77ee51121fb55dc1e659f830c325682665be80979bd7d18ecffe60301f9f6436a50188b1aa7d98451e77676af2f362995808384d204d044ccdd8d36776b74197b1a43a1c66d991782ef65eef54a204b403af288c74716930abb114e7b3eac85554ddc27e74d3294e05168284f4cc2150360ad2a545b038a74f605d258c409dbaa3c141e1028d0127ff6d2b9d30c422939118aee192f86a738da57333bb009f5796b0962012f9d0173c7fc74190b983104628e26f81afb3b7f7f995a9c6a0693f7f0de487e6181bf8bbcd00af4f04babdaea83c277bc19e43cac1f8d8798aa6713c529f434a6d1782dc09e3cf4e7ed0c861ed5441b45c6eba674b7e28164629cd6fc0f98c6622e5504b2e5dc050da43d3d287c42029c455cc126b88756b59b779fd2e8570e3d274e9402a4ede9013c262efc35f65f3d18b8da563abc6693fee345a1e717e5676a3d8027ccf957f0ee6e59b1a6872aec01d3866ea779b0038253ec402493c72f4011eaa2b777a107c9e78969644fd1db47525da268a74a8bda68b33fbf4d4fbc737a62eeb524712e1aa12d6c75cdba738abcbd1d00104cc2d4fb00721493c729c2b3c651a78f593262a562d9d4859e8667e3f42bbf2044bfe6229d19e401d5295595ef928b0742565fb4e31b5a20557a7e603d6cd9d74530fc7671f8081a66439fa082b192eb11244977f680710333d1ab000d004563a040af583626eb4fcb70252d875f299fa39d4343d2832d3ed8c033ef2203c87851527049fc27f8bc672bf82a31a1732ab7ed97140efb5426738cbb8f853f374dfbf2b3d8cf80ba75bd8b3edf6e52c1e42d720a8cf945a35e62f0ef07ecf56a19c68807ec9d8ad0ba78844c7fd8ba75493759c2934db9c65968c9e4f5342298dd1f8d9cc6617deffe397da2e2747ce4698644d28c06fa34445e6be22f8c21d38dec908e5a6fe3c34da76ca607440880f3d30bd758994a8a52b5d7726d43a5f85f283c8ae4c21a835ff702f42065963bdf8b712c2670053310048d1e2d67d67c84b01fb558d48f2613c06bc115026642142795450ea23a21492ce2669ed68cf37d3bd35af6524e0b39eb564d2b8a1bf7546e2c04244d8f45f42e7a95ea1380ee2a41fd51e5479a86e74c83a623120a71ba7fc2deb8d7fc52c1907c50517dc735774c8cb481326e97d27a31870aac4dfb9ac38c5290125bc79426153ade394a325cf8872b05b8af5065f3b16d29fc9caae4badaca12981b72eed8a57c9f127d906a28f44eba184d4baad7f646cffc2f17304facec72b976276af678a746a09575cc66460bee84d6cbde9ab4168cbacb0cf8f10d7d482b33d61bb312e6e15d7f496693ce234c1ddf769736768a9c83cc96e2b59575a8d6afbc01817e32f8a4aab70569d5902a003d13d03412184a31b76989388ef8b02f6a82913d85468c0eb2b4f552713b50a096cbbf08d1184cd6c659499c9c6693612a5d634a4f9926ef97b16bd80ebeeabc3699019dab8a1796e85ea887929050e958e9155b8ebc1a84992acec6ffb3e6ed2aa9244b6202a74acbfe63d9e50429bbf57823028354e9f0553490f22540cce3446c28e4372c7ddcf4502837cd60c768b2c3658df9723841f5afc9029fcd254472d33eac2cfe067161260deee466a73f5b2c82a9012b3201076b4b72beabc76d54a6194e26917aa12f271cab110b622e0ad32d1f03fc2c64ad02a11a8e66dd507169b29cf51d86d1194cdeebcea35920098dec4054c8d0a644c508e69c371b9439e5db1d051acae868df59211c552dac3b242b53c1dc78f43cb96d537117134e24433c3e5a29e8716d708b6be1b752cfb2f7ad7848adc45b3ab3580434654c80063c7f45a95a42cfc0e9b2d980960b859f0a28fd27a57c3e301bce0b04ab98bb4744fff99a2b0fe9ce2fe387f446d8defa64d504355ab9d9af4f99aa336809366518bbec29dedb99ef3d3d6d40a4dc58e974d51f00fc3e04e0c7dcaa89f0691a4f8dfa3f4aa274095290302b7e7f3caa180b846d742ba1c40d27cfb2feea3f089387a7da3da282b2054adbe0a2bcc5755c60e7c693cd31e94bd98577ce00b45a4fa1b75515b36fcbbd704af33d04cd70af60447eb761163d913fe6a986c35b4023c5b4b25f848aa65f06f6949f9b557798c3eb422dc34ca2a152c8700e3c87b4bd2505175e4ec86f523ae95cafd190d5b6c7040ba407666919fe09711ddb1be58ed545e17418884d6b339b25df3b08cea6db598918e79b98aefb97166fe72783968c9928a665eb0f5e285909ffff7d87764a954483d90c7edf4d7188e4348adc50a55d9af489c7ab764f44f19b3c736e8cae50555f09687be899eb03810c31f8583681ce1c8e5ae54bbcc02b6187add1abeadd47f49e8ef1009257f5c2ef9b711d25255f5837be6fe14ced02a1f59a681566859573588fbc43594ceb7a0caeedfb466f521c1e9d15a3913ea948796dc67b1fad362be909f7bc2ed5016dd0d7349250c8bccc8a1526b7b8158c501fbf4d03b888d298d78a6380c90dd1fc307075bfdf034543c1bc8797356c7e29d01f309251fea8cb1f87d23aa58a9dbeb9d840060c366fa1e653552210b84eb8d558379fcbcf62fab2b4e788a244e368f56092a605c8ee85475ee6c6c9c34543cc63a90e29f1ee0d29a6dfac8da9e2542fd60e641e020598c3aa5c90cb8ad118e226b8a2c505506d3b30c750f3477487026b9033fae2cc7cdef34cea74a65265a641069b79b471c04b3969efe990903289da9e9b20782467afdbd2c6e267230e498651263e4b790f52c3711f856ae7c7ab4ec1c4ea10ebeb8613614f5a2df1c038bf6fe5a96b66c1d2ab25e6174861b5997bd7a96fc2e4e8de0397934345ce2a54e35dbe49d26824d4e2ae0b163fd89f41b2fa4afb5b6fc7f79d4f2d2516bf01252c5df358e9dc1ad29217ad5a91ca9542ca93edf489b12219f3b4d2b9088b62de27a91d1da4db5a36e89de3b9a0e7905b43d6cafbf89222af983257a738e5a35f57fcac0dc3391ccdb374a2acccf62247afaefb7e95ebbb9f6966d71b8b80cfebd8530385975096aeb4b9d59cd1f60f737c262dcc5c0350063c4c50a5ccb952ae85baa37611af9fc7e0fa4ab2ce29d68a068d29664a2af9851767ad618ec43c4d587c2e17a3e3c62bcb1c164b81601f46789604f2277364f893fb0d7b6c53b84e2c5623a4d0f8f9981d07adb33d01cf04d1a46387191ac492af86c47160f9f14784387b402248d435faddab2fff8a35c4ca78e8d41399cb4312a3113f24c0828a29c8ba76b7c48f6fc1cc4bcb25b724fdf496dbeebb0849d7fe2b00a9d1c5e1d490141905ff66092d617b7e18d396bc3ab87a18a3b311012d1655f422b5b10f80a07543366300dbab72c2002db1416c9ba660146d58866957ad1fa772b90a866731efa14293f1bf13994ab4cfce2b3bcdc5b99261eb347361434d64993193b8f1acabe44ae42ad24a52db80bf8da0070247f7e3aad42ec5d6ad9efa12fca87817fc49022efe88747c7384cec470d3c374dcd7fa94903a8a0216d98d4f7ca248598e3d47e109b0f94110f6dab5d87629b8c1d1ad4ebf13aaa651cb4cfd241265d5f9618b8bbf745691dff577b52831c78215a3d3f73d3a3be620dc1cb24457f720d8baaab3bd251d75c240cff22654dcc4e53de5441506f3f93c243ddde4d728e67649dacc303ac4d7a3904fa4c195cb73ad7c65485897bd0160714a40ca505c61b89fe5fecbcefb19e2adf98a5abeef5aa1fffd8df261ee2c2915d3996941dda8d0651b5591232d763ba3ceddd130c5627d3d0ff723b3df5e4584b1756764fa804ea286b8e84d72ddb35f707f88b94599e16b38cd92efcb50ada57a0b04653d956a748fc8fa0da8f02bb47d1b8e861fa3617882ad781629d278553e29ea0d2a37cad4243c3b7b5f825531096d348e7a475665d7b4a15425d6e60a9a886698719b0e88596d25dcd4e55a83735c78d0e0c8393aead3dd9b25e7cd04b1c297d96ca90bf52f9261f975ea17926cb3dc76d85c72939ba384521b755a7f52bf87f22829a1110d76b1db3dcf8f2bf8bdbb7539c71fd3378a8f6c29c8e457a39c146e9f585d0e73415c2d2f5ba69cf673397769b75bc252254abcb1aa11b765139350a64cd4883668922853c3ca75b4cba6649b843c557dcbbc4d774854bc90eb4b288cf32cd039297e317b04cb3c4a277bc0cb200ac40f9044ffbc760def2bc1a3cc328940ab59c00bfaf4faded8b3b72f7e246c4b2ac1197f0f161611779b7ed7d0cc1b0f826cd0b7505d704ce56b2158ca3fa6cc627c0f3a4811e63fa7c290446eee5d1fd6763cbbc8c885a3a9f4a9722ec193a3adb979f7e58c2f78a9e981a61ce8bb3060357381ba78e9a805d7808f5a502581b7392f18e77c874ae6125e4054a5f172c6e62d8fe5ef14572849250cbdde673edb3c2b76fd2e499dae7d573343580b2add5fbe3cc3d56f1947bba312717c67f775c2e0d5601c7f6631dd72155fe10f56761ff1f0cda8e4300108269d5bb90a5f618e92c728ddbd02a2f48c77851cf9d7b74652f59916e44f177d551dd70a0075e1e6ab9b8b7b0defce6a1a1203015325de731d256afa1c5a10b2445c658b195cfb39e56c7c17e1dd0775df3b1c1fc92a9d89b2ec107bb251917717148f188d8956ac562ea2c17e3d514bd5131b8c23fc82ec3662f18aaa0d49c0636459dca140563e0b8f1a9cec7c200aebb53bfc97522e43e168d0183156789a172c118f6ef3d4d65e5626c29873d0275fb4411e90d641bfad995be01a306b42b26d77c070f4b0e1a882714bb330cafa84eede4f7a47e683b9d1026d87bfc8a5e1e8ac4800f500f0952c3acef64f162d110425bccbf5511fcff7a317b085fd44313926535ab0e0e0ceb93daf932f3a790cc6444f2a926a5116ae2191fa68fa8c468b52733c800a379cb6e0cc7690bb891dee83b2b9c199a237deb04432e55d3128b12fe68f27479d98ccdd0ae60d6e2a9d30b0b9b5bc8d3275d59041e2e3c01156e786b11e050452414777504bb046e40bb17922bad3b7f6b71c420d8616b0d4b205e03009ceeb896d4e070793b8395b5df07b15732bebe2e04717d2320a0f61df3331f0b6f67dbcd1550ba375bb4d25e914d430240137819273398f385a0fe3e368d131c3850a7b6cbd58967cd822fe04dbd2ca2ec2df9585991343f5cceca082cee0b4c22f45499fb9386b10e2d8e83a11c5bc4bf2e6b768fd220029ef0ce5edb6d27d2175f0a03bd9bf94d114f7900f84946e3bf4ad66fbf13b742cf5c9bb5faf20284b5e7ec7638824028c11287e2ca55827d452fbcd955724b6e4835f3a5b3e0df2514102330395b8615f4ccec4b0ea32e573dfff8b4dae3abfebb206c10621bb21412c2bd87e073ef74a003d03751a5273391a603382eda92cee350ca8411ec6ac38f97742c9c3ce4d4528f5a2705855512a5d6ee8dbe4e29047c8c695f2dc7c376bc3c762ea1ab7a4dbe5f6d7b4fb90e13916bc703168c29287ec3bc75d930b2990cf4604b8c467dd06be856e8171c42da7be7a3ea8a9d24b637e96a18e700f1079afcc25c5bae6260c1c106ce4f1ac1585e3f257a95e5561feea51004540a5b8d65a0f0c62641cc198d351832d3755bbc3598084a1b33f7065197e4067a2f7b376bcf61ea9b1bf69816a16cfdf513dc9b7c8e1c1d46a3c6e85fd86a7285872ad0ae52b782fb2737c67da3f3199df056d694eb2c993b6c903d17f4e0f40ff99040d7ddc55c2ed5ae93b5a0b3230f95d49df359e8d439a1fe9c23f9b3a76dffa9b9cdc2f0b90d54759d26bc91be2b5cc88d52e2843ab2a2e5678496b65bd27432afd769a3289e71b157e5a1db0de0f997f4fa4889ddf3376015189f3958e85f3da81f2c13337a4a8cbf57a5029d0bd9a2436ee3fd2ec7cf7173b525c8dd06ce88ff845b152d96aa9851fb5a2d318b41e9bafab0134fdc2be44b007bc7c93f6847dcb1c4c55f232d0a222564601c654b567aabeedd43d1393fb054179598ec5e5d7dcad3dc117cf0b9eb6d51c2512aa76ad905072c45822e5a7ec153dd691ac4a55cf8f302e6f1bb52a0d46abbf2e4a14730f5f5c70c814deac93da6ed2680761fe742d95233202c588eb5e07067b768d834276234092378d8aec17e8cbedfb0f6be03e1c951334199ddd9d7e09cf53eaf637855ce03a81acaf647249da22df533f569eb6ea1daa7dedb5dbdea1461ac038d2522f92648f5af1efcb815b833b873567f4fec7272353137d64504a1bd008de00d429a80e75841e87ae8e6e5da381fd63f61093705a9dd789c1615834552ef16a440be7f05ef7e0c37fb5597b6d930efde2fec50fe5db59288e6b1169a6719c6f2ff34f3aaa035794b6e846e2057fc3e9184d04daee0b8839190cf8c1bcdb38d90bb15ad1dea2ca3b94424ae8280b09b320deb9aadb8d5e6b15f4c971b4e9ccd7a74a8c97bee74b5ee5965b695dcdb40bb93e2a1a3d3e120dfc097ce5b0b38f07e7a710032f07de137e28e902e87d5c52ce832d0c58c36353c41340d4a7c9838a610708be14859c95047d2dff6d597766593e17cfa59a49d150f90419462b83d67dddaea9e50ee2dee61c981f253544f33a389800b1ef2c1290190389758cc4b0daad7d62d28d9f25ccc3a8f944d9dc4fbd64fe63bfc95d2f1742525a62eeb94f61a9792d05fd746ac5e76a9b38767d33f3876bbfdba872b8507a59a82ebf4d451f7a8358d146fe35bc58984668e6a53a1cd3bd61d2143df14ae16f4dbf912206c580eaf5c6a564a72af85a99b43d41782c55e71e6cbfa00a1a379d40a2cd9486b78db133e19f68207ed485714136490b54f83b32b1c063ae1fe723029c282ba643f7202b0f3d50a49712bc345357fbe5a70dc040b43c0d689026a9c96e2bab305f5fe87d98632efa3df27a4789c9c177c22d3137879ab2a458a99c4381bb9ca58eb9dc8b9c7796a32453cc1b176d812d6fc4c58548c4c17f4dddcec635131fa6e9199f9ec83e1adcf0ecebde53f746b031424b963784dc21b7f51cd3d53d9bb9c714be53ddbbb355f6781fa3599826c7628b6e0136da49fcf582b583beea433b59309dee12c52e22591614fab64e9897c38dd3009437be616d6ca467b7e10c1383a9406c6f1e5ea574eba4e652758befcacd5dadf99b269d4fc3aa2817d29a38527cd15e9b5220b93d7cc130f3ec1086728b17dc5a31a6ccde0af6e95d12ebdbd9098fb085533b7e0eec9c006dbf69ebc79c7144125439d6e8bd090ba5103138223a8748481ddebcac95586921837fb8033114d609de9886d658ff336e8ad2aead0028045088faa51bd4692be4b341729b02d7554d0ef990be1d87d8d58dfa49b5c554d4e1e7a779b6add7143f7c44b31b27b19fed053c6ae0c4ad4449f0c0a498b359eeb4db90cd6fd1f1470e62ff1310fefbadb4444bbad34f9c766f288fc693eab7c8247e4c0999c34ea61a44f59f4515ac1e961f7dc1d45ea80b62295d82ccad9cb7464320803e2aa25acbc3580545edb422fd43a89bded3dd821bbb8b22e7962da7f2d48881252ccc44acac38ed01d24218d5262411ee59dce7e44dd1273247899f1495c001b373ebac462c8eb246c772dc78cea21899e3ed3f2a64a34212735766ee627160160f20507dd7634f70228a2c11ee4f1e57259c1e62207ff1128d8a5dfe1389bda3a4df95d87f9243d5c70ce039d9461b9903db5a90a47dd56eec434736bbb133230b3d60cfae6b8308604c7d1495a16066aec5a918f8e9cc4c96a573aedbbe9ba4165d88b53f2b8717f5aeb6e630e626916342609162cd6bfdec91867d2b3ef71ceb562c953b816c2dabf9e8543b1fbebed219a598a76a660c3980838115d8290b3025dc6bc8dfd8ec9a8772543f308b74c4dc5c1f60443eb760ba954faa69de3c9e1d63a8686705b00d6993e32a00f8c5636445acd6def623a43002a2bdb0ee9bdc3416a4f66ced42b6958d93533f06508f88229cbd1eb50df35069655fa3d2b11b90e5ad96e55b56f514313904bfb85b252ce38ddaccd98541f44ecbd91784d0e6d3746d723da98cef66f109fc29d62b3d64edaab615f2d6ca619fd877350c542664d0df2ff3b8fe1acaea6d3296873be5fa7a3a3d47e8960d3d85dd7ca4f295af681fbd817e19ea77e0a325ff971e12fe803f1b9c61a8fda39621c8bafbbc025b2c30c75959507b5eca71581b175dfb580d6e5a2d161227a1d004cfd2dcaba9360bbdf35789a0441313d973a8af55a3c9bec8f949ac987b4d3a9df8da4439ffdea2905b4d1224cbd9edbc42e6028f41d2d8e962c94f6625fb5aa03095d2ebe168df77370ecff80fc3087b75b66fe2c14d5e19d50065f4befb35713abe9bffa644a78c65033db6f6744d44068e18dba11ef930732bef7d8455c797774d6adcbdf98f983de317e424cac33bcad123aa64c27d7bc9bbd7779da7da989ff448535ae2d4e37b0c1aed2c5ac2ab43efe05ace7d8a2df5e461ad3135607d88f3837c3553fa537f39cf0bbf2297b4285247e23b7334ae6118ee1081b5c6e9b84768d027145293b174e3de19669efff011e884bd993ff853a91476f5b7e89a9d3e9c844bc7d4c10f9bc88f7ea06992d476f8cde76188ba326e3890dfbf1a65272c4a4f6007109765112e439a2ee5df51041744755e459ed6d5e4be8c919dbab02f01de1f5e0ff71a94774cb3a2cb8394c5089b4563ce80b5c94c53e24e8b88b0e4aee8bc4656263e1ac2d83791216095f37db102a0e19e6458c55573b25b92bd6a3a7728f4adce1d9800ade1bc864cb0b6caf170e5b164e1466f1553c380c679ec52ad46924bf8df53b6030c50a0032a2d5e82c45da352d9b66fe9055bd202d0ec182ef373c99abf94484ba6b4eeb347350fa173f04bbd34c19aa234fb07b561c34916240a79c516472af778d0fa834d37e2b48643c93de898f3102f46d731d9239c9f1e4a09a6c98ceedacbf61309dd3ed618215ecb88940135f12eedde91f7af25c7ff4b4707a2a361751e0a2f48af979af0da6911e1649b3dc9d3605ebd78b521dea941d025fc30663217fc995f383e8423d1ce6e664a92ce557288b919e1fbc2539fb204257d58a375d2c85a477c43206378a9cbee8197536da62c784e340f982f256564f1b5c9e57d46563692326838a9375d3470b44e5893312764798a269d71bd5b392daeb655f10557840f15224639ebb99fe20566ff4e7a663535c850313b0cc389480df5084c35a30d786cb534f2222539c7b93031ff4630e529589284da8c3c97926a15f5f8c56d0ecab37fd9446534188be7ef269446eba007fab64a70afc51b8b7b571300f2fc18f602aa404391bb46fd963c8df7b4f324bf8d21338c0650777ff80a6236a7e10171a76324d60d74335254198d491126428289c36340733c027d73d2c0829822a95e2560bf66a02cbc97032f43ca501febaadb77b85ca75a9cd521d98558742760db2e4470db7e617ce6aaf1fae4adffe62a34e5ca79caa05bae49058b65c36a7256e95f5c75fbe62cefbdce331be9b338e9cb2c4802c7da536cd8522e695f5e03259820942d0d88119a017856f377dd887ce4a1938b1b303e0f728a86d099fc92636de6a305d9f1d5b696fadc237517b6b2f1d7a6784dfe7559052ef6da0f68a90093f2b75324f3342594d87dd9936a0106afc4f7a47931499485e6820d9e36143ffa81ac5e2605ae3c886e06e6121a5cd7daaa0932bc323a1211fea8d44e349c514a4bed86af66c0a02111d0cebcf12f46a4dd0039deb1913992d824adb8b1cb190ee02a536f7dd3143d80981f7d0af52867fd7360714dd5f92cf5b9725d49dc4db590d9ecb1d046821992e4c30b671af0c5b9ccb88b2c589230d638c41f90072cc846f7f0595e44238bfdea499543de419ac6d4266bf70eb81ec08416ef953fbcdaea81c6927202cc295407a95cbca42e02ad36e4d3b69853231ff64804199c60811cc12e6e0e7138bd1ddeaf7fd3330bfc610f90d7c2205f19bbba9aae479c6e316fadc1b787f3988df82f529628ab9b97ae96bae1150b370b9355dc66aa7de3f936a8be23b57adca9f4b6a18ae231b730fc4714b90c49ad27fb19dc61dc887a49bf53ed4c82dc283719e1b5ccec7f88afec57286d4108d92f438e4d61b672be54b08dc2c6dcd438e867336ed1d404b50953ba143eb7ed55d1cfd4481543c81b480d164d7d31e0bfb75f944eb0ed02ce3cd030d31f7a7b5086b5b143a9698209cfe46b7377e0f3402af59452b060e713eadef72835fe12b0ecdb55d9eac2c48d2d7ab31ffa71d4c34dcf123369459abc3915e66d18c7b75369bab72990dcccd3daf556d01e23bd765345440d27e44b4f91f8085d2d41a02d4fffb13971b2cdc2ee5ec2f7c6b9b5f862c2694ab0498178304f450aee9438799c6c4d32c7b396376ea0d30479bd8e42a5c76ab62d41223d19ed272171cd126623b0cc4c0b19845469196499e257390b2ab1ad100328e2b0abfa841e96a7d60269b08fe7d1a63aef41a65d889bd0b75d829d34b2fca8c157d34943e136e0e85eb17045d96f0adbe3bda159e632e125b15a21e3b0762ed46e4cc53824690182c7631f5b9a5cf440c26ba4cd83050005104cf3691cc2da7065115ed0206f485468ea0dc768bdcfdda7003b96349d46fbfe724e8369a2d83d990e5a47f33077c6234890704b74551885befc81f8b09578a5732122c3dd038ae7d05acbc9f9d1aeca71fb812e91465dbe97eded0a8dcd037cee2452e4f1639d649993f4a555514c9f2a16a4252490046dcd8cee0b896ff127da0b7389bd497817b4b75aba1101df774b3abaf06f3c1425a7ce0a3d509fb7e053d01523e19fff951678f59107ac2f913d0295e2d5f207ae9b2cc256927b65ea5ebab0727ce8d3d909d9de0d29a29aa96f4d58cdc218a94f134c47518f04a1a8446ad178671e4b87117ddf9ae6009e5fd10b104c95f025f209bcb597aa55e662ec2cf50846c91a1b9d610c86369552269c908a789207177af5d760d2b67783566e5f2861fcbfe551df00f25094da0b9d73eacf5ff932b69bef3ea0dfd7fc33e610d291fd531e34b379d81d6f881155e3a067276be56b1fea740a2aaa6b576f91322106fbfd747108185e00d5129449c63b7ed5c30c9808ba5d19e248078e553dbaa645cb065a01608d1676dd72f9909894912c97f7ec3f7ef059dafae1478cfa46d57fb5e9823664ed81fb23f5b4a717fb3efdab97bfe0436cfa63d6c76b07ea546e5fc75fe27199bfd470a87945514657337d490c0f33035fb644135a77fbeb5866df52b7aeb8c75af8feaedf294ba1c0308e7d6b440079209e728f11ce99c3515779bb95a937e5ca3cc6cafc1569119537ede76849de76948f80977105a41e58166e554732cbe6c381588c62d91b151cc7b5efbb089c2e6e4aa6cd0490c34db9ef96a722f4cc0716d2a770464a965aedc0f2ae40c056e10e6c4b5764567a177eea9ffa3818894e7930e5403fcd1b16fdf6909033b87c625f78d5ca4e3539ad4188bff1712d9e1613e844c43cb5d6b3f7f5ae95f7016e9b730d0898ba7c3b91bee1cbfbebdb93d659bc9d7083230180c73b6eaf478cb299a81523ad4a92d2f27679d42e060fdd03da2eaf63a7bc47e8a3d9e52c27d210616a768e07c54f9e7306921202f3f8409609e35a6b374dc8e42470cef681908a0c736cb4d16978cca612323552f093414919d6172e1f85e0fdc6b6a50bf03656264f27f8758879fb0f5429d45d82b9ca2a71a5dc9d33ffedb08389a280eab2bf58e6c6025d69c92f4d2f7236f088c954f8448c02104f944f88a85a01181763a9885a524f8465ff336103fe2592d8f589a2268fa4dbe09f928c1204c13d710fdfeee27ba76309044ee95c76fa50df3bea659c079c1b8d0688b4af6a0cb354399b734891f5b81788f7b341164d0f9af31165527dbbb7f48e7fd2e747dcb58cc77205d6fe44c6644dfc9d49976de7ead30a77d2fde36c070f3d52279c1b89bb8f550815c29f2b5655f3d614b5735e2d00270b8a45bd68dde93189d1e97eb653b693a41ed5fb7ad54d4e4f46a5603d25db19c491679a74f6996e15bacc6a5bbb1a38c4a8c70a2c8ee9b24a7a3e009ed2f92d93f9b8bbe5247890efad9b10311e98a01c81dac2e3582506de52af296f845357141b79d35a154cda99083e06155c48ef414bf397d6d8dbca8b7a1363103b68c9c7b99ba8773efbda9cd64533289e6fff24258a24e9a7399c6e7e62f5c2206d69061b2e3bd782d3b0cc28720a4189620afb239ef3423efc3af9f64cad768da2760ffbe6c4d0588d9c5a19b6207b2dba7682074b325866631fb57d39ddc4f0efac947ec12e0685ce90a13aa93770fbd2b2d15145af112cd2c89a5dbde669dbd1017a0432c57f8ac414debb1b208a52471d3e022bff6bcf51023a3e7e1ecf3b2c4d1a5fecf8223daf4f5462559e07f9ecd34c8226d1b1ea55080352c71f15e290b978913b4b8eafd50d4a580378e8827accac75b025fe46b8a0fd6dcb0494081a5423e03d3e14c6f9d47e64b26ce5a82f369692862dd88abe024640c8eb04fbca606338fc0e0801854f399e192bb9fcb07dac2fa54c61b2e432fe91b634cb5de8e5c619c7fd8b08a15d32ca3664eb74edaa7971ccebcc6e3a80b2ed2c33ee50d45cf79e3ddebc287b60bc20afbc2c96cea2247f51bb1a0fccc9d192981f5d62afb37c82cba64a9baaf5c96f35602929b297cd94ba1d40f2ad2297c3f2b8230da8d48fe2b5d659d5fe06e57b08e316b225ff0b40b34e0ba3926ebcb2881f6ea518a9337599156a7eb341731017643630ec84d2527bde7277b9863fc30d9ecfcf6b120a3d396195ec9c3d07fbe48849be2fff7045f7c6385ea463eeaeaf634a57cb694e60b70985608807a793991b6b51658a07ec082f4b5d39ad32386e889f05e0f5975bc39cfdba4305063b435c71afc027e67051e754e8dce10e2331d1384156a181df5f33080dc8db926861039d4b8abe9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
