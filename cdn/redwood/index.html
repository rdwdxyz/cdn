<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c2680b73986028602c2c30228ab02d9bb243b4f176aa893f490b4acf9cbd8895d00410f8e9b1f713671eeb24e70ef1a576f180fe3f71cecf643e9993ca6e6cefe9405c15b0eb54fd4b270651e79abad987175cb6824c43408844f4613fb2a5b9ace4264b69d621cc7992eb2ba8b7f5583f6cc2d56d2fd4e0e1ba953cb4d7015a6923604bb9ad44f0987acaf786479daf1d79e8b3c16c8041f55fb418e9e8804f34b5f14ec140ade9bd85b463446a2e7f4b3f0397b4390d8e0eb7c9aaef0e20977f65af916b5a3e512852aa2ae89152cd188418f8d5ee7ee451de7dc3cbdd8d7abb1282958bb223364f10e327d7d3b108f8261ffe57dac52fb11dfccef8aa4c0f2365250d5127115afad70b56628c04516406199536de7abbad7852fbdac74bf48d25d858d12a05c9070a23b8ffa7bc443aacc4a46cf2085e5259c9fdbf9da31c8fea46d1fcc6d134e38a196af7a375beb5b0fae91427590caa5255d9c16fa7d91a7e5010777c2de4b7445908ab0947484e8c6647fdf4679c516eaac6ade342dfb190de130ea7e53a2c4f846de76c5c01f35d006be634755b7d20b3a9cef2f6cc28d1b1cde0de69f825277e919cd4730395d88743b74c77d43051c9687812f8d6257eea445f25be38335d46e16ff28b7b65470e63bcecd1f033ef2d1fc84b62a236e798b83f6be6471f46153c790b0586c2f36dcac90c130d0056eea3aa69317eff1bbdae288157ad4aad25f3e5354e210773170e6032dfbfb0a7cd67f74e569c28dfad70e0024cadcec645ef103d5ae00c02a0c2b567ae7519e37f12ec03c51a7924d7945589a0c53aef8853f7113b888b386298d7e1b549364ffb17ea925d1cf2d7995d51110b983192388a41f4592a18511c56303322b393d719b0c948b9ffed60182fb9dce4eae561bb011fb31eaedba042c35bd9e96533f458fbd0fbdcbef6dbe9f5be2d7a001179aa620af5cc65e6afb6a6bcc416073fc2d3722153dc970b2307143e4e1a7e7921324b312f8744bbb2e3453373be0d44adc82d58d00c00948f3d1cfcdb1654de6d080063f0fb83a05ba9bb5aa443a877aada5d3a14f598d58ece07e0be6adc29390665197b5d376397f3ee9e820bf8bdd7622a456ad7ea260d3124a47bc9c59521e58b3c8962bf4bddf07e809e401fe84e90336d67c4df23e1736c6a854868953bc32dbe8212fe6efe9e101d6afd984d19aeaed2b6a194c8a3f1b59e3f4bdf19340a4a2cab6ea63732b10ed315f6f3686f0349d7536bd45a01c7c013441f02af758b80c77214a8ff73f519e9774d720af3a013d57daad9691eda4374f8234cb9e323e4852e5a8b6667397c9a4a1734bbce086fdabad8f72be7a1315d3dffc798e28ad45334acacd13b94a8c799b19b38422e2ee36d05b78bb3d503036c2f817c353e5ced632cde11ed707b730ae7130dd5073c860141f9f2017bd07c918dbfb10cb3fbf8f14f4a0a89a0bc27388232570008aa6323b201cbde0663772d5994417cee34b530ac4c5927480a7f37344dd6b78ce10814697631884c71bbdb47a698a5714d38929835ad704831dd29d98215f16fbbe21efd67d58390281b613220e89295e20188da6c908605abf1c3e688c129e066637b07e2bd49149fad4da0d6c117d235720aec321681683ad2d1a8a19ec8709932797298fcf5ddde364b79204252757bf98ce862cb0841c4e94d9df6e7ba8bc2b054c143b54af19c5c91db3e3139b97e2a9a09dff336cbb71804f5d063fdd2d521bd488b5d67240e28c7b8a8de6d8506e5450932f01837761df7fa4ab2a21cced8f45558becf0e000bb56d4dfdd17ce8a666ba4b2664788a18b7400601952cce47df3882b28bc8143b80b70def4b32f0a156bfab441b757a71b5164ed0db4f9b0238a9661e4e74e12c5cc52ca2c005872f918bd47c1b7fe7c47c2b113d8a3d472a90b85300e99ad9a10104a11c14da2ff8399348cf51fa4e41425339c6cd7d876b39b2f90abd10fc8622c8eaaba7e7f7163387aff0cbca429a30548c1a8c30ed120fae3c44b4288f3675f8cc09f902fbdd929627774d36b980ff120185215fa66cd05ea9d70c83b79033057a707be522161355c016fe23d4c016a2564c8801a965da4a877f666ac80d39e7dd72939e6cb5c3151afa8c9484b71ed19db16ddef4ca16aff2345405cb61f6bd59492c21b883317833621c6ad95a583b8d0d7d08e3afff3bc71b89cd4b594b270d1afc78eb025688d687a93d890b932c79950ef0d027ca32bd9bca137862b9f83686e89712231ed644b94bb179dd5c0dfd3864eeb1f9601f9b1b03c85e248c1835b8c7d816c463c91296e70e0e7fecd56ad50f44b7486416fdaf8a77f3501ab9e8f79e8fceab7153ad8ac62339c3b8831a7d33a3defc1ba33c172410896b1c9a12cae55c13afda7df71fbe75b0965d4b7c8b10081bca8824570dbdf27cc8b8942b6dbccbb0c2bf740f2cda039fe371db1bf66ef8a71c5315c28fa4b2f5f94cd13244897dae9d18b6d7aefe07e9240ab84a8aa8689bec3a8ba3e0b46e11f41fba483433e1d21712f06b68ff8b9b957852e3191722c73bc6ad7a4b24179bc9aa32a925ba85089c5fc33a7e8b23ead00f68fd7cefba8c344e1d42e2153f590a628cb94aff9f93a563fbfe803533a01e9cd1050e9ed595d8522cef5f428942a71e753ddc883ceb5ce5367a59a8fcaf67be12a1912a223e6b7b3ce2ccd3f613dfda0c2af9ad8a0bda3109eddee694ea3118dc4f8dd3ed7919bb9ed83190a6aea13db01d6d1595add4aa665d4d0fe88910d3f0d8517cb18bb7cb192285d0c2096a9d212d340220d6bc187755a172de7100cde15033544348438027430d872c24f20d800348960015f028c5389ed4fb1de10a8adf4ea4fbafe8a3e2e569f727e68b282512be53ff167f4cb5e8923efe34bd80fa041814d4e30c574bdad4f9d1672d5861746b604fd2ef304c428fba0e9090dd153542fe610e0257c3ac2861bc054d03e9d141690ef60e9c3b9610a59d5727bdbb7637ec9e333b5fec6b61c97df0a2aa477fabfcb3a5c71b37f067d38824d960023e091a9a839d63782a65b999d78622fb2b67f25d04f8618d03e2358237251eb586f0acb0b9594490dad00bb1b843e2e7c1a613042cbbd507b125fe5297a18e6a7e4462d618bf41174ea8e18839f3d602ee3c0c19c6693e4ed756edf8330f0a20b82e8fae1bb008da1df269299cf47d71ff9e427923da5b9c93705037d42f40f325209337c263f6de7d1b37df12fca35fdd5714f203f4fe2e71691c4c6a314bcaac24512dcc56f553caf1fdb13766b416e8dd227f67a6f871ffb635dc50e6f3012ec6943915e1177408eb82d14c827c53849ca6262683858043d44f6537c9c3de3956405a4f206145dddc42c83e3f1d484eb6ac3d31da8b4039fd9b0366885d750babfa09240c2c983684ddda0c34c7a8758c27651655621d8a64945255fd1809d4a3ddfb47a45911304d0712c218b5fa22ffeeecf5bb326a0fe60320c377b75e49575c4064fccf792bd0c5083c7847e67c56283a015741b4abcbf24d3257289d2d13b2eabd872df2d68e97ec1744010c42b502a036f59c02bae6242d3c219044b423b4c2fed13aeac69161c2f36524bd21bd16dfb9d432c6416cd9049f33f12ac2ad2b804a9db1cf987ea5f135268e64f5353ff59832741c4a9433b6f7ae29bf102b8de2fe2f9d980778cf3b1d11980c402127cba2f97e2d8c85902c1a29165a3d080bb0cb36023657ab93cd9ec69f288039221cac4691cda80f619686d8183f78bf58ad364931e7594b3d3d695c7c8fb279281d7c430f1a97b07530defba6cd56e8e3ef1954fcb9fda512728f3c7a8d9cd564f72f2c7e87f53f7650b7bf15b4c24fc919310c9a114772bdfe263ca735cee3c7f3ff59829ccd5f5e6a38fc110853dbc4fa3acc4265aff1a19e462abb1740315b5b1e89e8033b460aba0dc6ad9359074e8c85d517d815b285e8fbe3bb612ceab37cc573394887bb840cf542ef3868087549016e4823d9998e4d1efd9874c2f3b9df026ab89308a1bf5e287d5418969871210e4130bdce71739fb9b6ed79acbcd0b6f662d87b66859bad9ac87707b9e466f5ec1295eb49e3c74335ae63537ac52766f2de727cbf0650de3f892596b5015941b0b56ea28b92e9bf535d88aef464dd4f9254219e346630e2f457c9c4eeb48b829f5ed9f6294a957e60c2759816d5973b894f740ed52f33d7de0177e259cf28c2f7819e7f99f48792f6619cee354107ba6577fae0018b64275d79c324921b229d3a566681bce19c4987c1c39a979cbaa2c6234b0665baafb78f824eb76674accdf41a0994838e54cebce9a3545eaeac71590479418dd18e623df1a1b86bb6587542a9d531bd0e859977c6f6f5f7d50b66a9c8a4fe481bcef65c94eff02cde19a7846c23e8db1fa3c252e4c49cec26cafffa809bb2f38766a037198e7f7a791cbebd2928c66482fc120df3b512022436adef5865fc9a4b5bc12e594aeadb3d13feed68bf0e0d77bd98953f01f3c21eb0d3d1990ac0227ff24ff373f7f5435e0e5425c98de82b557a3e85b028aa8a1eb1a67352dd9b0054fe591351fee801c7944edb98985f93a395801e51225e3e9c8b86dfadc1fa1e2935fb72e5deaa342c9b09928371d0310e71f27cd5e134bd87d8034fb40ed820019c24be044c2b7045f9661ba0218c13b13699849c99de219069443ff668aead9ec7f597a6ca7776342ce0ac5909cb7d9035e88117b5a3ea43285a2c005bf3b74c41fc37d6d2368d4c234c78a77793dbf594a23ae1ed44ce7bf80964a9a0be056b672cb0399fe78bf3610deda663a2a1707229c1c86a6265480b7df3690c45ddea95f3cfb9d49b365186a96cc3cb7e2e1008c344a21ddcccbca73f0bf0a75149b576b0f9a2854bca85210a3aacce9fa95946977b31e8a6641ecbb5a42d6216328698fa48a5806baf3b57cce23a0d3e6219e6c1d078982c30d4582b8db4a23d0da53baf765e622906d00aa8ff438678382d6b1b16724a2df9cca99f7ed07ba4233a4f3bfbbc8c90e442bb046bd87cd8fb4c33aaf025e41f87427aac8adbd993e0f9f6ce35bcc9e649d327f41c054935240df751dfec149cf03fd1f1102ec6c81e76372c9eb8cad512467b6baca849680f59a91dd9ce189ee0f575bc72191834727f7f4a55cf3aa018e4b0ca84a6603da38662bb4bd30ded7eb4cc059fca8ef6b89b9f19ffaa3736cbee46cf1428f6fd4cdae2ac8743b5502b109e47a81e3bcb6378ea6097538aa6b27536fb4042d76b511e514d201e8312bcfc8c4d2430976febf8639b7a942a73c4a050f5307b328b3769c86ae1bc4335780347067e8e54d6c2fb8b370a99a815f5e1664ab6807c95c5f893e22592f8c54f55e4341eaf0b183f554ed7a798f22ce9f53e01a223764875fa042e14af4201798dda57d5194929302050fcb1d960e5ab2dd1dba0d6fea8932ccdb686cb878c7e89454053de2d9fcaae1a4261a71e3ed057168c94ee9c0dced3019a27a9b7ece26c5968edaf1b86b203df758384d1cd17a248b651b70bce54cd080aa9ab188d1a2db354299209615a43c12483d6e5ca555157060412de79ec3ffe1d236a92fd61a93f2fc4bea3b6ff69fadb8140fb1b1194bfa7facf53d28d8602e854cd901322fe9775dfefa2b0f05f890e58070a78e32b41ce95a9b5c0b397163414b469294ece3c7190970b1cf5379c4ca9a27f923e9482682f5bbebe1f7f42f289f20dcd882f2ecf1238f03e99869d2fce38c6b56eb650739b8aed9a81c6e91ee7c1a2a3c667135d094ed6ab4e9a9573805c2ed9c744b9ca59a0ac11954d2d0ede1e212960d84563e10caf334fda16a4bdefa18119b5057056965e746ef0ef0e7d8b9376f534c4eb82111fce8e325ac7540f119a0553862839c316cd31f7c002cce352b862add411f6aa7791045e5519d8e3d9111adb0f890ae42789374cd5296cf3beeead9a80b9f81cde61927728bc75e607f342cc0f288bcc470824c0c663304986e3d174d2a0825b9f107f8a98df8e9b333c936b03d72518b90667255040f297b789fa3f18210c81f8af916808b78ffa4d572eaa9355a871e5c6dcfd1bff97378533fff78ef0f4a15f739c885f1a54931166e967718204e41377153122d6536249a96bf233a6a93f7465313c2c239f4cd4fce1f6c1d813b9c75feda126db2172a43734072ce39129c752768a4b090f9ea53fd03badb4a69debbffd47102a50897bbd9c0423c0effa3e1fb5fe18a077379cc8d1939f4f0452bc7c538ba224df67cfc630bf8754d69595962cadb3bd96a28f82b33ad864748f0b735bb76dd99826ce766fa2121a001c1297a07627c1e751a6fca33c0beb544edebc7389874b584f31c34912f8e362f42307afa5c21faeeae2be314f9e616913603793e114c40f7a2e27fe4ec6363dfbc72e75ade20a6236d272c6ce884c7fe3133e25415df2435a4ff9afacbadc92177dee6a32e92a86930ff730818aa50e6d4eaadd640a8d54a05737908e77dcafc00343dc3d5048054507488cd24c8f7c2e906d372e650025c92d62c94723d96f18de931634b958f782f1b58af8166af96a7ee9db8e2d4b5182f02f5ef1d84063febdb410cbb0dca01c85e6bb00cd09d94ae5343e6406fa047c62a1f542f4775d60405c8457c579bbcdda63a046e958e94c33e48292e9b47d8bf8798d0d7d2f0052ebb61de1d3a216a59e51e2100968215823307ab59b60d24110cda215d8837116e1a54a691e8d800e20bf49839a401b2c90e01198a3dcd9e94b0cf0e3c5ddd109ecc10554a3e69cc7fd4bf62c5796ca46374379245de8ecef81630c380bb93ec69c7c39e357bb2d995cab0da74ed6d858cba69baabfc3a275d04f109bb5c20f19761cac1e5832c530a001dfb1079237ace9831bfd69a6d0106ee077b6b0ed3e806a4957b640cc76221ea4a3891bb4df451f9ddaa47ac44d73d4c0a6d17d8323e0d90e3371e554b304d0a94ebd3993dbec7bb7f2b4ce22ae02260640e0ec55d19b97bdb0047caf33d2bcc2198dd914cf59df69ab9b544fb588e620ed13854bccdcca0fba07a61d53575c818f347cbff7cc604c794eccf03305193f6668aa846c25196a93e4dd8a5f9ac649277228045d5110ff90f1fb23155208eb12e1de97398997db8ea5a1095e0094d4d307a38fcfae4a71d2efb5c637d2183bdede653e548ca1f2cd5c7d46f52d7f447da9ba5173b70293a0a3f7530dcc244d67af10b41701519bf7df024fabc7715f5f9c30309c61705e3169cc7aa90fb97501d6a68f68682b2cafbad9a6be7040b61a21da543a508ac2cbcd0c5cff365b286194240efc18c707500d3726999d262e611e5b55986aea3f28828ec58836cde8d06ddfbdf1a5dfd67b8ba0bb4edef2d61239ace18998740d911545ed882d21c479650213a91e042c53f18860524a336867f9ace3a908fe4c1dcb6ebfff8179e2ab49e35769cc166cf82cd1af398559d5f6dc7310ec306a47baf94e529aff93a6f9c436f392cffc826882a12b4f37c8122b1c119ce3ed080c595b316b22c2f3d7adcafdd71bfb8bff0ea81149561bbc9a4496f64c5cd9c0a62ae2e70da5146fd48e7357a02a6c3e9694b6b6f9f6bf0ddfe99a6331aa7d03f93ed1a95e174333c3c85f8a33529216b1b7c9893ded79d11bc5e1f8ab934918e326b215c6baa06ce9193c419aa260de0cce1551ea2106d65bb30e94354018d1a586f89e780da5f12d9a38f416cf6c8b08f89c5282ec1908b6e3fe01daa59a007c88a3291ee2aee42ab383efd1977fdd2e51a69db32cbb2845a85693d981b3da70427c386d30e4c612e2dbc6952410ebdcf8ea9437273eec160077e5f2cb24c620cbc8ba78e1f3672251d5453744e7958c26ba75c210888b2af2d579cf4db83600167cfc42797fb91fe61c986f42326ab35eb306a0b7ae3d683a4194d2841b6d6f75e445746b95f32fdcbd8a388a11fc08cd8acccdbeb93b2a49dfbf42c8603b53b509367969be9401e03b87e066e061e47102a95c908a37249f3e3608a7e0039405c35c82e90d22829913266ce8bd8d8961217a96c19bd7a06badbc11d0dbc781677d6df9c8537f62ce70591a906047808e0d1ba4d6841c864fa0f67d0a0a7b5f04ead6ef49643fd2f1f6eaac8fb5764a75286c73f49811f4760880591961aa6f70475607465b23461000f945ac9b7743447b595f91213642de94480ded2d018973f1cebb9a94d7d22c34080ce4964dc0990cc21b0d671aa2bf0a56dfa160b7ac654c0033a7c3f4a6b8c5a7508e7fa18df4627e550b9d050701c44a8874c48964615321655589a88c2e8f8bc9d1ff33738903cc111c30f9c68172e842d2c3100a43cd33215f8f9311333c3fa24bbd1fca05322beeed0369c8d97652f19b6a0e109b022f58725653bb0afb0294c6ff6ed82b42b43357d37c4cdd1cb18d7c641f0086958e064646df96f1bc6610c4b37c3707d7ef98ecc31efb85d04532dcb0949d431dcbae0e61d5230a05252dcc15485581fca53b50cc85fa5403847333f7dce4c5d315d99741fb71da54d8fb55003a22955c7aa28c3c7b0f15d60a08918136bb109532347fca16bd0816919123b4b9db46932fefaec6ff63a091f6396219e0803a404f09edc2490da09c17b8e0cf7e5d4416aebd7c13e4d8464c9acefa1925c0e790c03b37330f92cbd43d40bfaab5a90eeda6f368189fe965ab7b006f678817cd3237e38e83f7fb4ef711d1d1a79ecedc5d68c1f32d73aba6a267368c4f997d093a23cc0121de7b0ce07d8e28a4655d2d230a9db967c342f790681e68141472d3162b0f97d603c341853edb053d6cd65f76891e6f36ba64876cff209de4211c8455d1ca0f79bb06377aaa0f7df1f3331018aafadf635bb4e6eba9ed8503f5a21dbc8dbe8bb90dc71d537e76e1d71bb86007e87ffdc8bf3faa0bdace8889454c69a02a10282e77ad09bc40190de60173e2e86a159ac095219ce9cfd0e812511c4632c599c41444107433016302c97e4d7dd1939d9607e375b09199a613e166bd3eefa2c8d8c848db933b0cf612c4fd3dab8671fb4ebc70642dec12d189498f62d66bf9922060e4b286e186c91aa860d03984175098993489ff94901893c76ce2b92611b13221ddab5dd4c676a4783b192513325fad87af50534daf51d03c1aaa6a194312f7687ebabc81bdf9c139756ce7d5bd6d564f63074ab17e7af18bb8c11e0da8edef424f7d501796bb8d6e8d264aed0d9a3c658baa49aae2e9e85bea7fdf10b95304055993a0fe986ae625fc587a72e31ee0e1cd3aca3e31b1a753bc65ee25ad1b41e06ce517b78f961672299b765bad49c7ba3f1f3f5a79ccd2028451ebfc06edb9fea49b084998e301dd9234e194f66a48c53f4febc173ef06dee4e72ac5ee708068c75e447539bd5dccb148fa697ea36de8142d80eb59792e84ba1ee8a2e58e2319fa7ecb5e6e25e305a1516c638bc476ef7ec494e04281533ee9a5d43593307325e281beb0968b38aa5c4f1e9ce353209f53d3f449127b7392595ce662d14f47a7bb88c2394ab8fc327289f377999c070376692002e6a8c94d055e73a0a47d92b71f4898d6c8a686a55aaae9950c2c5c03df2f6224cb66998a526b9025fb88fd4a6c3978aca212fd5640067b8fc3e9596f918e8fcdb3f51ad418cc69ba791798765ece23b20193675b33aaedaa10ebc7f412b3196cd3e5a143a4b1ff371fd118ce3090752603d52d2cd2f974fc19761683be8effa8b63fd3ef578c82a2d3578b2a92b5f60e8986d66a90d5f497490b5e6a27cd1fb3ad253c3f94018dc3c43469fbadef90c4b75f981afbc5d7b0aae4709bfa02c861cbf3ddcc191c13cff83422c1af55be4acf4bb01a8b8885b44dbd3a2738b5cd7c7967659ae100178e7e830d9557ec0c6e9b1d4641ce43af5a0649f3f13649f920d475876d16a5f8a9dc708e4d21d52dd0ae8fb95fc40d6988321c4b73fef46be6e30ec8f1898c296affe55e423c34e353f67b82f544232f2ed9eebd3a651e5f21069c289ddba21e70065fb510768a33b9e93657d08325ec59377562674f0b000e767eb7c9cd128b08c1cde40fda131672be0fcd843eb1d5abc25e080bba65129aed21c3795948370fdf7544b4836e1788187e1a21ba164cfdee64a11b5e10669b257cb449fca0ed223213c21ca7eb158fd6a433a1260c4c7cd2b08c0988b3fac8b3f2c6a77df95ac40cbb5afcc67afc4f368601a1c4f154ce0805bd9ce63ca86d6d42d60a71b50491b706aaa4fa2be3efeb2aa1e5250b656cabe97540d417a8bb35a245cc70954093535f16adca56e4464bd13eab626418e1afb024d60e76adbc20808a75c1e0bd5d46de2f67ec81bae6a738b12cdcc4cbd457193ba62cf5a298d48b547f45abe783101b68d592645c11445ac29e816a6bdb38829cb41612f6b626504d55d3c5c4e119ecabe32b7ac290271fb9cc98ad145acdde282db52b24eef763d2d1c580c84cc2ab0e0b7720c3a6a9d0b845420682f4b3c45148c33a32f84ca6f6d2a3bffc2f898b834206ce52af35d01aa52e2f8bbf160b2c3ce681ef83330351b729432f1cc4e28e13e1f4ec37172da5479090d593907e2eede85b3c6423d54c413132548503db3c325fa4c6da8c79f201707e455ac3759e347d6dc6f9894c039d57d4903743adc4e1dd19f5a565fa3ef0195b91eda70a8086af2c99fe1a2e89b8ad9827e8e2c1dcdbd7e1b7c7ffd969fa80d3c965ea5f90aa025507cb64b3de920076506c06ec3fcf34bf007e59caa3a333abc1c33c45e9a21f54b344338b0626e8a6c49ff7e9cfc50375abffeef3cc39ed9839680cf8f4e0efcc463bf1b57013d5c95448b900058b47dc40cf5fcff5c3eb729ec2dcc25f22605a84aa71300335d7d5db71d758ff088cf29b2af34815e0d9bad1cc5683770278cdff79ae98723874d6acd1a1ae555db8de2ded0d6b148d00816a9d9567cac6db7d628d34d167c82980484273a3e34ee10865503673e48c0fc0e3bd4eaca05d42eae4b1d78da65a91a628a89636cb9ac6d0b8c5029b1ffa7dd63a77c36fcc47011cb7bb5dbcea5e921f3a5bac7aa2af525feac6f776415eaa33ba8a3d4851cf4a5f7c63e4998ef424c0c1099f2738bf2240e3d60f6408830c093642b5aff658334f2b0dd72691c2a0dd5087fddea72ba62fe9753e520144b0ad33996c8c2351f242af05c206b08ba3899420659d32de76decc01cf7347a3487cdf0f70c2e693584f6a8c967cb9a1bed7883f59a541e437c96d668c7388353bfe84bdf27a38f5651961bf5762998b9f56254c7bed38c1be2f3f4730f42a43fc09bce1f4ecf397a79e196e753b78308ba67fad1096e114167710f2eb5df5865d0500cd507b60bc511438a13168c51b3e12ca30064a37575a77e03565efeea7bcb343735848e91e20cc68a383952eeb5af5d42ffa4898a8b616413477433c0c8865d8bc76b465f55702f59f3457f585896a84004ab552344fe5b6ef76c54ae60de0463251ea2700abb4f464caf0f02b30e4747686c4af343c8e220e3146d3c20b12deff8e47d1697b419653a15e1830153da909255f5381c3c891ce5fee2445193f84edf70f114cfaaf10f4da79c6f259eb0303191c68af6a083db99a786352edfd69a33138677e6002dab0e4d55b0b2465b5370e599bb91a1ee705026ddedab55ee01f12745291a441fa69d6056f50628ec2c223effc3c7d1180f510d42dab164d34befbc3328d1c17d25cc9682869a12cbc0da08b42c1230a1f0869d6ff52630cde21aeee45cc758b9e7d5accb14d4cd02332a2254f281a7eac80d672873e925dcfdf5a9724bff12f996410dd505ca2d1bff633abf93175c68b40e07754745dcef7ca62da31cda72a038ee87636a669dc04fd49b3a5947f822df46241042055506b73396fb4deaf3ffbf4be9af5aa48c9297f98a65d843db2fb0b168ed52e48bc9c403cfb44ae9e521c36bc9cecc2111308f4cf366365ad28fc00b1de1202306867f9b6f83d52eed8719796184c25710625c08877629284f679351217c6926ef0ede7f04f443a7ee4f913742d27ad44baab7fd91bd7977b29cf508c8a7ea7ae1bca205f8b089d54d4958b82e9cd29a37817a1519dd07e76a1d845bf44ef16093ddf93674fe2f8a5ced12eef410028107b640444997761213584d14154d3aec4554b00285fdef3364b6f19d727b74c90ee61ae425d27a64a2fdefb1c65b422cc8af8fc7f96989782249df6a477aa3e32efb49b1d9f09476c33d5b797dcd48d03bf0bd6c6840c3ca40964ae5f1c5e46998e40cdc7c8063ded51e089e501c9b1f970a616c418ce2c18ff387fa675c6de9561994f82c29493df2d88e277f99d460b1b10c0db68cbf83b29996211bd1440331ed74d28d16340d4e6e6d5867e71ee4756a5cafd357be483c61cbb92abdd81b5567b1e348a7382cc78e628e114e8ca99f24953ab1d16d2230da3ae55a7d2251eef9838b3150de44e9ce6b4d12835b80145746cf0eef4ae018fc80dd8432c357439b775ad52acd1c14efb7e28678f434e89dc7cd502273225e202b07149fa25f41c99088b6cb035463b8fd5563f771a4a2929bbbdc1a35fda61ade8dc5a89b34370eca55eb1a158313564aabb98ab3ea1492b52b125ea840abccfece25bd78c901c312720b5a70446211bc7efa64340c1352789c9a72b1e99c20cabc38f59d66e22440adec613006926727230b3a0f6936404b1e771bba8cca3ab32c2de003d1203603d8698d1e2c8ddfc621f66515f89967cf87a016786447c63501997e812812eed35449489143940ab5a5ded53232ba5b212a2560faa1d1e9db08909e448bffb7f911ef3079c208bc1e76305797a32465b5d32880a043990023d9d49100c2e71582f18e289459e56357f116e95bdecb7edaf016f4ea87e58444e3df0ecbf6b960e5721d7a3f8e850d9ab93bdcd7c6b8ea5c48fd48494057a1e273bc0e0030f7d883e1352e8c60f8a6b86625f52b95c9302fba4f1b0f0c48f993531dc9ec21542b823c9a39c204f10510e62270423b13c5526342bdeb509a65cd0654922f4c196c64e2c48298f7895999bfb4a395cac30996d00bd396c029c663e1a1a368db16bd264804b66ca312344310013dfdf298dbb98fc2e291082a703059cc9b0fdb97cbabf09e3451c673568c0f1ad96954c8ed2f109b05ad7b7771c5a3fe46e0c7de20f9ef9e11ccf05921f0c632667c660232bdd7632d60d3027d8bcfa422b254af1e3c8b3ea755c463810484f2c7ffd6fe7220afd18c4a07acee5909ef7fc53e58a426cdee7b0f404010357c940324120109c5b901051b29c315ea107bca0abdbe13eb9cb50b0e0a32b4337f4c6095dc04f71bae75008ee499c7655433b4773f3b489fbba37f09a12e7477127ceaf0926ab403a53186b2695b66ca5342f4dbd7daa39c680287547d30ec7deabc1c80e08f2cd624ecb3dfcca2395975a821042f0027e4644c22a2f01f7600f00fbd40760575569d271db0c830138805552394ea04abd250ea3fc6b0e48a2c715c5488953deddd52328be65ee91708955fe6e470a6a8adf189d9ce6a09665e614d7856dd64c9d93cdd4344dcaa5e012962c51cbfcfa2e1c5323e76bb282596c89392af41ccbe217e59e529d8b1e3af3359fff22ba91548e6db8c8531d4c65e38dc58a4497adf4a4a3bb5707826f7cdde16ec36659ed7fb8a78c79f5df16366004466620c20006ad85ca598d31dc1fdc6871c7de0cd52289030b32246a9c010c9d8b6c41ff39a1cb68cd6edcf48dfb1104ac48c034d8c5a69963c70b970bda41b9f9f2ad716ff83b42feb0e144bbe86d5508417ba9b3b291d613d61d02e303dcb94bb1058b6e8430d6c5f360eb04910cd072957eb89eae72e219b89aa1d5ba36c761e23bfb60575ed3197dac33f46aba3392f5ad4808a4dc004ffbe6b0d689d3dd4ffd9327220405e17b0d3ede207fecf021062aae6bf8dd732726223f6eba8def77625ea66e3331473e63b2cd3ca20a6fc0eb7f732bf824c3501eb21bd03f9728daecc012898676bec43608da8329471e51267ad0fbf9baa05dec519806c22e8f0d0b069b536fbdb8d5f386c5aec62494a3e022cf287bb293a3eba61b6adf4eeff14477febe2473302acd83170fe487c89214749e4f98de5bfecac79e7fd1145f7cc47756847b7400c8ca0e5d8aab63d30fdb77acb3de576f9e5d3b31f02e5520517f078e1b4937b4435472d7d745c756f1aea5718949f9febac2c73eceaf3d7bbad778221ff3a7b2e633b7920ccfae29ffe380cdecb5ecb19c1b4f49b3d40e274846ba0c25f3e0c361f13866638ce3fc879d9aa2d7d06aadfe9bdf5743b422dbe983d1b2ffe7d199dd06290589747408ea92bc8ae829016cffaa08c482e5d329e74c34c8e6675c00b21de12b81d04447beeb23734769023998132984653f1201fec001291b45e3f00aa2a05eb78535a42a9ed164597452031347a9ab94a91c63c3b9e212d7317b4d64a8a227acc6233d5224e0a6eeaf7741858b6b208b0b0ad4e8efb6faa7333f22ba0ec7747c956667a98a35eb86c6247e368e870f28bc7f7f94eedba11df4ca72f86a52f8d4494b784cb494e3e4498780dd49a95f3fdc18cfbc4538832affffa4af68f3a309d4a0fe46f17c7335a4068f35e2766ef649f0a1811f59d1e126d5ac6c5616480e1de932330e18ce1b28edc559034a434eb0bb93fbea742f515adb00ebe3623d1d025f32b596ff35c46735bd12b89fdc57f0845e88d31df7d0d493c996b1c9a52819abb785718af3b5eab50377f60b98f8b14db82289ac875a9d80a98604dd28802b548a3eecdc52657f00303b4847a7f9444c795fe58b64fda3e143aa82a43aa14a16acf46d36621a7153b58119ca581c26133c702d311208e3d27bc03d8a2f909f4a7dd0b2c71878fb2857970205c382c6854bc156d809844455d5c3c6474851b52df4d7c3568c4e0b43a02b2cac84a9509e5710a445fcd3fec4dcdeccb2ef085f290977ee4fd0d8598ee23dd1a7b6236f10b8515eeae4c48ffdcfd22f683ab1465c827d6791e1cbadb7c72d43d79197a0d4cfe650c3cfbadf82231e12a80391c9709565e809515ceb1ffcfa7d34c02e3d09a1442076db4d7a844b3db078381500641a2b5aafc04e0b8928ad2acde4657a45a35d7a916d1be7c169a98d980381ed0ad4bccea8fcc80a513a27e751e401e6117b2fb647d194e8291fa9dfdefec17a46722ccc1904db0776e49d2862f493db2c8e1769702db1d7ee32efc5a95495ee466de85125f4ac98ca4873ee5c060ed702cf11de7c9eceda6cd0c637688405baf4a386cdc1dcc858d24dbecdacd33e9aa228ca40739ce8ce06dc006c91eb41d07d90c23b48bfb0c4a80bd866b6c4ee7a5e0b67d74bc6d52f955ab5544f5823f21f2f39e9b02ce7f0d396057c57618b276a89f59e2d17ddd852f5bdeebb9548458ffddf5d623244cc43416d023da4dc344809c919d39c3e370d6f838bb57e889c628d3806f9542d0d7af03db793d13529340b2734872264a99051335e5c3fe5e40f2f55b8deec39e31f696b09b3eff291d519902bb8ce106d8fe1d06e26caed46641488b33720f8b5b492ded7523f3bd7e4af81c801629cc46076b2b8aed1243a9904fc82c1c541ca4a850ede2e4e5c8fbbb160dd827b2e097ff9a42057892cce0392c4780db3b52df33ae9f94ce0d1c9f960c5bab7b4f6c91066f24bdb9188e19838e90de6f3408ea541d382e688cadc39fdbe0899eb11136914d78b17053f38c683afbdd0e0d84a4c757ef14046d87a644b51e6edbed7fcbf8065f9de9f0dc93f522ba78888ef09a84e6bdb672c8a2ca447f7cbc75aa9f2ddcc6c648b1d15abf3ae42441bed5a960a02399c7541f6890aceda1e93d40afff2199a495454feb4a416a9401a2a373bfa8f0f476e9b0e8d098c38c68952ab7ca88f687fd2f59b0998935d718a2df1f0b2af511406b34ca35b126192b58e00b5f9fc79e3b7ac3f423ef538265016bfd172c4adbef4fffc7d5b46080c5e5ccfd395b93779092ed9bd965e020caaa822ef8b2c293055f6c7105ab4bd3530349e98f49128b637210710611257cde3054d058d713d3a0f1b14d6c2e08ad90eeb383695b546778ee10661036093bd58d9a7952b68965c75380571752ba15e86e3c55a0bf6a0b0c9850a6aba5322c7b4387ecea60c3ecfdc6c364b05d6f8d8ebb7e26553212d0fa6c7fd79b6f494231451e3e29375f69e2ac597f884fbb16384f70cd83431169a0bb379a0607ffb5870d622e42ccd95e0c8528b996ffa11e02d99846c63370b11bd9faee69bd80171a08b983affcc92d489500bc35741f8a8f3b7790cfe684805d95649c7083e49b2fd20496ca91951e56071645525ffd0cc3b972e5454e818d5c7573d364ef0c682df7a6c26c04b014ae18f7e767139377ca8c14214b9e2e3da3544d4853f117211d5fbb906a4b3230d021fbe3de794e6f0645ef5fdc9a9961ebb86227b1396bf721fdf4cbd679dabf6a66200984126ae067c88d9f81910564faf7f70dbe47646612437d5a87e6f8d9878729fe425f7528a185c46fc043c344588635dca938c0ad88f02f53cb13d2988efb244a53408927d503c619aef936358bf241fbb0adde1585f32decb5ccfa9b73d87b6049f4cea31deb6a382ebf9f1b2f228f79ee325c6a36dccef3cf759878973d857ff320e21c53a65c5ff427575980ea09bba04d2252481566230c9ac82400fd6f01676c1a6737718c8fb86f87c1e634dc7be950071449e30d25f85322c17c481ff5439eab0f315151d7cf045251d7e4558e18ce629757f3e5119b7e3377745d0b50ada301007dda9d61597418dce2680e95c9b45c0c11c7b8a17844963f9566b691082bd549ef59397d37514222cea7b8ea4413980f0911f0c1ae2bb5fda05fd86204ac660e574d91173f7b425fc5746b45b164f176a5b07a4d49db1054898d6452e89efb80e143ed4822c90e24cf1423037e070e35d2b6df388b3af16a56dcb085f94e58a3bd2cadfbf79a1a2c3b5dff25d6b1224ea027fd0a8996218a8ef839f5a98c648e250c490b5ea9e793e36129cfca0ca149bd1a08368195528c8057683c6331629ce08b2e84873e6720b4ec68325c2e86f1c1cb9375f562e775fe2d66743df9886f33d1f8fcd2b978cfcb5fdb09620367611db8a7c001ce70dc892ab7227bfad1d370462abdb5329481d42949005c1fa5a0dbfd5c3fa9a9e8cfd4b1ee3951e9ac3910d27d75763ecf9dcdaa322cceca45584fe963dacee921a0b6cc34ff3c8b2f49fb1b505f93eb2aef13c323718e133e3463c4a6f5f5667c625b4132c244247ef442444764a2268b8ba61b62cd85ad0d743783a0d1a3fc0f830cd22e30c49e0d68b19cdbcc3d0a0a361db3591225f15068efff2d07b5bb5b19e9bd4da48d698206cb7a33820d6ad046c8d42433641b89e05e178934abfd644a10cb52ca7a92ae88ecff372aeb676f0e0aa9d39aa475514acc87dfec53ee82cfade98d21e61b6d116cb31deea380cb4cc300f96c504db7e83c00679a66851e733a143cbf31f504f857d791e6193314b2e4392faf1ca3b7040b670697e373cf48639e0124a799fba100c0908aa3a5fdd5e86cdb646dde91d76ecd42d4fb6aa5b32d1fda84499f72a58a4d096ddb327c6d0240964783a1ba64f465d9693c33114df47c5dae5adfa9d98e1dd3da20531e1ff7bc124fbf25a41afbfddbcb9d1c43fb2c805f79c11bfc1c371182653ce2bc5e252a5bbb93a647dd8a5bfcc63e6545dfdfbcf19b9c7e27b761674ba45eab44c842be7981b0354a672c8aa724650f9a1caf9ca56e9e685f7a0311025b063ad09e4196eb3e1e08e0af543f64cbcac04e5b006f60b42138fe79ec59f6e70429472902b424237aaa2604a948389e1d69b16579b84a5533bdd48e019f2e2047a8de10da827919e2d0f1c4a185fb80e4accc58cc6a45ac7e1d637cb99dcf9debe86c3e071222ad1a39aacb53d6628d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
