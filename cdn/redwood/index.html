<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f5e3002bcbab12921965a4dbc1f09f3de37d7e28016869698cd93987a5d54d12aa482f11a5b5b06face0a1c3ef399c26686863d8096684335ed8bd1d7dde4565f1afe1f8242f9a109e786e89133e9adb5bbbe912d8a9e791da6f0b5d624d323b40544b855592badab4607fca074fe2203b839c697259e95a328f621fa8cce3d3009f90e173a48e42db6dcc73a25b6fc9eba1d6158a52d5067eee603d91901ba268fc25973ae2652163a97683ab54f940670d332a34f6edd68ab7d172b2f211c02f8296c0173158a6d261ca9f3bbddd6e3cfb9b965cf3943b598843bcce704463fed33be572e77c682df33406634329860af2690ce37c66636e81d6951bc528ef314bdebcfb566c2e18694b3edcb6b7eca9303f9256d2467f0d65ee9f72a8c16fe28a0f2d1c9120790377413f542f273c8dfdba684790e0e7eaf248c337265184aaa6c5300d5d9498ba052223b2f6b30cf3a76efda0af8dfbe5ae53bd094a5c40d59bff217ac5ec037e863d13914dc2386ca30ac6684ced8fb726dbc2df514fdd7bebeea9d75bbf7e0818274a10f782033870dabd7935b751b5299980efd2b7787eea888f1cc6fc8c6ca12e2445a53cf202c5c73f80730e83ab598c6d06112e23be7f352797ffa8ad0214b216442b961383dd4a82d34cee78ee23d4ec4776bfe9b36addb904f70984dfa4ebb9e58b49242a8a18c9601152ef2152cbc0c8b267b2886aa9c724e6830052d0616692152dbf03be5db8aaae1b7e88c04405ceb42a736f07d80229750ed854adc73ad2e61379b719f5fe2220f80faf168ff8797612b926c09a0424752714b96e7764bae3d07265bf62a0e77efa2e7e0f3c36479aca3d18dee1738bcdcbe18f337b32e4e5a0a3eba3e22980eaaf0566bc9b0e6da5c89e627a66dd69b2d4db9172c09c03d23494eb0bfc8c52157e3f62c3b0a53a541f1ba4b855c1e0535bed14a23007039f77a297e162dcb94a4b5545cacde9258377ee8c3ce92ce896d93bc90f719d650b918376dddcaf5c6a48d1db897b47ef157be890259ab99680f121b622db01fe97dc597ffd76325d1f311543fa4af75bfb125671223467c9fbc6ecba2ea867daffd62ec890620c66eefe639337b4abc6cd6fb47a13af03009379a77fdfbc1876b4c433b6a105130e991cc5511853a253f994c222a9db8ae87f1e4abb320352f560945b61beb9df2330a60f8aeb325ce6fee506070bdc4ed1761dc1c3739f64e5375f0ef9543bbc6eac742fd1625de77cdbc025073985992be1376ca5a24d223a8c8ce7d45dbb621fbbf7c73c4d32126fbada9ccbb8317df490eac08c6b2bc98674d93d9858ad43dd7dbbfd3e667036d725567c02fad9a4d629e3a1a2e960572eb4ac16b6b21ff5fc7a3b7ca9bfe7c641e427f8119cc88e72cf789fb0cd324ecb1f60e6e31fbe435d08544946e7127770eac116faa6ef38f25a2e1d37358552a9695375e2f8fd32f39d13d623131e7dae9f9ed8335a22f5f5973d0b242af754b0bb96d7538a053132bd4d40c2d24cb4b511502835c9381360b7c1651174244164dcd1782c3000c4121378732a5c603aa425217566046b853392ce591a9192830bb467d3b2ae5b8f47445961e6e2379828034a1184789c0fad65cb9b897523ae77c38f42e9a5732d47a507ff85365021c55c330e19280fc7d80c064b896cd0256c6df0dd12b49f0e24a22814b73b4742cccfc1782293e065ef844d742aae85e08a5a1a72100d6739ccb84cd278dd8603bfdf6d27fa6652483e3f7f0025f356332225f8a7f06aab380d85493f4ecb8300c2e77eb84bc413b2a72d662aa50fbb816c87f69240bd9e622576226b3d7fde9b6de5d4064bf3457283a5e75a6de0344c2d402db5501c0619a9fd0c24241b57b531384abd6cccc0ca8d2489a7b8f4e64d50ff0bfc5d995df4cbc23f28bc6f4774cfb3b4358602784ec1a4c3d7536e8f6854aaae87266bbc54f5db25c94c6fa778940f65e27503fb70accea3ff57addb79b588f4dc4b4d79b6d6d93c1a031d7903199a4c3caba92f5f560c932b9deb3bbd521f4a812c7f7f912fe14a000a128919800aa8b868f33af3518c12e3360faee71882d4d828b363ede69d296e33f59fe369bf36af589bf7eb08192209fbc08c90d4cb192f953d3d18d5d2a785fa74952367c39f8a9f23beec08df8cbd91349cecc54cc114a557d4b28a31fb6b6b8f272ab58bdc45f899112efb1c110c13cdfdcc6f9f2d77300d9fc807a82768c7cb588ea3a14d5369c7530221f50097e061afe8fe2467db73fded0a8307712cf020f85d2d4b7b78c00bfab25fc30a00fb654c868dde7f9a0a4477cab32a2657c53c45e273090b3b13d05c464f4ccdba5ca2139765032803b07d9841abaa1cc44c7428d7e23221650445bf8edefaf85ac28f0117eb62b0b5f21cd9e59e32587a1a53c95e97ebb6bf15641ed6065b4e284fdaa4505bc65aaa1bc198f5c329948ed782d2b6824ecb2db17df7c061acbc633d447d069cb425f0657346677b8bf2fae2c895dc5953f2396f686c9cd0238c1cf83ba5ccca27ca551bfcab31f3c07633c81b41bbc4e87bec5324e99d405e584642bbe53317b5ae4dae1edfa63e6e37755817068708b061a2e946048dae4dd194761e0851f7279203f8ed05f57d0dd2216637b9d356a00a57f7780a832ba77a1f4b0ba10386d5cca5cd0720341b2bb2bc0af62d6bda4e47ef6a4e8e33d7dd816de8aa527cfbdadba6aaa3f5cedf0ec15dc781e29ef7d0eea46179c8af076e4cf1686d2ec361d456633548458b351becbbdba3f185fd6990d96c6a406497bc6695902fc954ccfa4f8143f2848a4ea2ac22a125797715505998b58a9ddcf61b99cbbca493f7f1b656f8c7cac2935a7bb3fe79b465abea4cd6ba139823fad2bf2d8529c042c204aadd5e8b7528e3a74bbf8276574f51955197331067bdde4ee7cbaeb4db8d64ca27126a5ded434883130c5f1f3b29aa01751af7a4f5ffc2ba688da93fce9438dbcbf7a76e7656c1ec6121e9896e99e26d4f66daf61ce64b0b6c15e8258c53c9dde86f06a98d256ffb99da1e7162dd04e4dee577a1e8dca633a2257f6ffc9a66e22175e81e6e5e940b1aaee332bff9614b5396123fb64039d25da2846ff9223b9a13f658339d1dbfd5fc12f1ec5059dd40e8196f8277b5b2b8e4617006f7fa2d51dc979945e1bdf96ef715725d9bf497d3da471c4989e27b02b1bd793e77c23631c31f76a611b0a78b42a258b32b676273a76bd1837d02732850dc2158bc55467f287921d40f0721ed675fc891e72f49337a5474cb2c6fc4524e193d0bff13d87246d88f5c28c4f712012a696244dbbb1e7955a08309d35ce62b974af3c4451d137ee0c11b1509159cedbd7e460ce95288f3aba99aae96608d6b55fd9718faa4594e0197f9c05437a73a2ee3a07d3cd65dec4bd4c0bdfe60353c2b379e8f11987ced3dcfe4b2c9312799f4e7aa261b842e5a7ffc8016a4dc6f2684e6b548bf99492713c419dfe371e981c3ee2cf8094148504eb41afd783ea305e26e696aadd0f225f9da983798966daf63ede2d53fd0116dca1c6a30c8e4c9f521430e7e487dda185e1f6907351d89a9e73f2cc65712b6d022f8a4f62863574f0501e499d903a7663c19d838b95fbcf75b82e23955b0e7b632497e1cad89c78fcf337cf01900cf5e23279aff3a7881bdaa735b76924f7e0b7a2956e93869623355f7cc30346272c95aea1b26488fe21c9aa3589df3e558167d5918edf9419177de7658f2a4bbbe316bce85e44f5cea53e2f2ad5fc3f95987d3140c2ab77b29457cb7994556e477f31cb94f6878858985f5ed6458cb0c1f18f1ec8cdd0da70fdb843b9c0881b9ab94db65c5c5d34edffc445077503dfdaa1e66a3905bbc93e5d83e91c6e5e0cb76a0f53d51d71ea31fcf61c2bbf8243b87c2396c87fe77773ca451f40485c81e1d59da08006bc2eff8c368720d8597c38935e25be32ee5643e7b57c3c6c2ac1c671ebec979b3834bcc488c1b18635f274c5cfb9e7787795664c724a073c7a85601bdd3f67e2b21a1960be78a08f09ee551c595049895ba4959ebd797ed15f5d974ad9c527df73c985d9eb13213d5b38b9c898de1303619194048cf8504b37ed2950d5608233c5b2d253a6afc710e80ad631cc615229a73409f7a37266ede3dce007911c8191d0d8452e7c17c1ef52d2605f6fe8020e4b3dbfb5e264273cb0a99c5ccf76b9e236799976535aeb08180c23926b84412c5744ed3eff52693780b42ce9ea1fee8f023ae66b284a194f7ff9010901c714ea1c0ecaf48cb6b3362e8eb2c15c8749b55f9234b8d401b83605161839048096bffafb4bd23a23dbe68765c6ea95080b796d7748dc99e2e6f260a42893a0421634e3f6a3280977bc70b346ef16e1a8a6fef041de67fc81e0b6322b7deaf1237d70c31231d05acba4fbb3f2117a692dcf5686085ad51bb47b90720b06d7adc9151c71b0a42ea050025bf1377561e0bd37dcf913306d393475da39d7505385af59945a591da5dbc44c41ffee0fbe62e8e885f8aa570b98ced60bd4a3511f189591a2c8269d25839c6f24a7eb2408f00d9d8609ac51f453b865e6b001968ce09f8848bc8d8c67bfe512f6f9d5649d0d46842cd0d5e0b05cb798e6fd430a92f87d3546268fb11d5a7d9cb99f89537057de7678f044397a936d08e550a77ffb0292613806d2f2e0b91832eaa2b33b72021c3a40ab7cf46a62569fbee4fc6ed03ea290ffa46789d6343db70e5e8a4c100b52e628e393b9e803f701dab15cf17266a56ca4c454c9ef99e8afa3b67602d3a1ace9f60c91b26343139941e8be41c8924b79fb59bf354c95fc19b9d722509d983698cee2cc63cb7bec3a968aa7d48820794c206ae6d538cbc0a48dd2635d6fcc38765b79407ae62e7d79aa33015fad863a65b40c39c02225f14eb07cdc4d69f6dd18daef491d11f1f8fd5c1994d3bb0e3bd2d7cc65d26af57adb3ba0dbd6dbd572e4cf0b8196caa48d8202003d48075f5016205f639cb80dc6a2d0a338424cc27a8191ef811d7be03c5326ac10182d50633caef7e93b8201b24379f3ea80ad00a3e8d1c4580ad8bc9103149a7f58191852bb0ba7591a758fb4a1a3727df298cc798adb5e23541f3d5382c11fa7115411f5563ae84f9a7e6b58b2a36690c49783b5e5f588f44967f88bb5918a28c0ed5cf7338b1942b1d1b70100d2d5c85d79c25e96dafda15424cc10526e8711f7abae6b2de71da726d5fa0914a452dc8d2b7c3bb98390933aab31de8131ba713d630f1f1913fd14bde26d1cdbb07a2d3b5ab4b9dc76f4613c33064f93125b938d7209dc73aa0aebf2d603b80a3715566b5189092dea2c621d6ff7361f78ca53da32d18f17d2c4a151fd6dee5deaecb9d585b3d1222c6d982ec4412c7eddaf126fb37bac041e588435d10d2ebc230bdd71d8f8cc73942063395af58b35df737892abb4ad066e5b5e967cbb0494077c51e9b8d5b28f0cde9ffe07e829bf1f484f0b1f18146c2ad020d9cb276f3ee742036579dc50292636839f24dbd073c99787a841fddd2313f5959c9cdeaabed5042c10c2add2439e7feed1638081b76e9c33baf41b55076ca6dab382fdd12262fc2a5e89952c7b9e252870117816a94396931102e337d42d555246fd2203f6139bfe298a8dfbfc142b83b2d07fe5fe1240cee46015dfdbe2a847c0e4f8da12ba567ae96a71c7d54f97de19341d96009fc19236bf8f0598568ed4da885e409d41ede43dd84ad376b81971ddcd3a538ecc97cb59ab11b75b095e1143defc39cd036b8dce754622005eceabd297cc3c3d6af4154dfb1fd3342364b8e5dd605ef646874615a01915226754aecdc90ede4acca77d94d835d566bd4e83c6628c365e89f5cb42a31591c099026db90a1c01dd08e95af8b79b4ab4026952d294ba9dd7690924be734e6384e048f9085532e21dfeca2f4f0f1e17dc5d95b4604ae77f4a55f5ef884375896d229aee3ef30966935a75039499a126154ca3975478c273a7fae899a3df474a471e260f958de5066fd7869d35c742ed26c7a9bf95cd6347f014ec231027e121a3bf71955454009a46538fb9b96e55bc20af323cb49858a91953f5825e01733326fe6fce57cf23d1c61df8bf0db23a03a8aa7bf20fe732673e591578598019f8e5eb1b23598a6f894e6fee0a1e5c8458eb8a561b3a6d9792a9c6c6959fbbb7d50989ea2b4afcaef998092ac551300e8603445b3c1dde9e6f11ac7d29e5fd7974e0ba372ca8c4a9ce886238b7f11301ec343279d2d83b3eca992212f44bdd3a285097c5f8977b2fa9d9ee6d86850e145663f3c1d1b0c91f48ce79f0400e0540f73145ece9bd5982a363ee226bd9bbff307283cfe56eafff630c4771b3327572e8a3d48f020daef191009546d4ba410e635e1d582134c8c4e7b423cef0b925b68e3e130d3f0eb22449f9fdc0cb47ce0435ab77e8016367872cd797ae5977f7dc1f5fd1629652c4fab91bb5306ad2fe4ab27b728767fbe854121175c71e19cbc347f8167224134fa4db772d8ec0b7fb7f66cc498050f9407f87be78b683e3359c6b99bf5b2515df0bb75fc47e03a7dd00d49e927632cb9b53585e7423bc1ed682b6886a091aca3203f7e53a047bd975f715a32aa0442ef1ea1181bdc074da3f90cdb77590fccfe1921fc5faa212136207a5c240f87a914642539bb6d25048e4d79c009f552e529c718597edd6514b14bbfcf32a3c4809e6819ba59d4d2f9fee58a0f3ac1ed6e3eddaa08b2ff7671986559168ea9b9b5d02ce74468b435479b741bacb645892adb31356a13d9351f0df97237a056999bbec55bae87a88a10caefae476120117769a6f9a3adbdb2e5c73508e4c8f385390fc6e47f8a1991d3eac3384dbb9da2c5a806f2804de16b7404740af5634b197917ffa947445f9182fb5cb025cd29892a167f2c15093a367480680d40855cbf5cbfa0a86e52e2fe6a724bc5295b301fc4d474ada7c2828ebe7fc08ff3f26e6cb05b7adf3ac4f36cca79c1ed0492c397279dcb7bb71f99258e90552b0c4da5d1d97e3752a541e98e3248fbbd2531fd6850bd4279ab0faf782345e1474c8802f389f5688c002bf3d4b738bcf55ff32fab94b9815d853a46371020cabecd38f41bd899395e64027572e397c6b48dd49788e8cbf233ee2df918e02c72467b3c2ddfbca07f8a0919a018a7a8f8e7fbea1bc50239edf5caacbf0a7583d02051f773b67ecbb323b51df6d075eb61b6c7ee338b1d6cf483b1c7af4d865e0d02fd70ca994f448289dd00e6cfa66a4725444ae983cf9ee4890f7bb1d2ae1c3cb84e9077d228e3f4084614a59a626cc24c47aa67fcfb2faecedfdcf69fbc6eea408821d1138b2e4a7b5ed358dd2ecfc7ac35bd8ad51f1edcf4036b2f25a7f68b5f647e662b2cd7abf4b5afc0833ba05b31f006dc1712cba28cbdaa68bc96b9c9a69083d11b60a9b59b648e73208b5c05f1e980b126e7714d909eb1afe46ebf43bd1770d68eac8b6d1e1163f6e62fa56e27da683ebb8460dfda0796421308c3c03eb365e27ebaf88b5b94f38b535466bae4e2855d51f7946f43c8c960b4826e42706fbe7c4e3b852907360761d4b4ccea4248e63cde9a91d4da5071b412147062b2c669a1759822a843db370e7b1412bb538caba611f0ce70a9c039d2c2f4f57eb75e084f7cbc8a23a3da5f0a29ea3539e780b42d276278ad6b10f3db250634a50ef45cdc337ae751c3715eeed6c8c3bb249087c627fc49a9a2fa88ef2f124e063b2fa31dbe09a56fd0908a16e694802438209e99bedc20fb9d6eecb117c99e964936bb4fc4bde2e71e9c0e7a7ced00a8f3963f68d344b6cac8dbeab4935cc6fd330f240ad07abe4374a3942cb6bd107d8f7d666b84339a882910e8a2d05943e25596a4cc66232dd615d2b5ea8b4391987fa6ea2c022f2c2d374306b92d34fa860e399c5a8ad70aefc1e4738f3473cdd152e87f7a89ab2bff99173ecb268677fc510d4d475707acab40979ec24c9587d12c04381cc34acaa7e96e7e01da10061720fcb069f123adbaabcfd3f7c505b82f8b4312864c9b1e52d7cb85adb691b87521c6c7a7508d1e72fed51dd38de74a2e7f1b9d76473e123e49846a5f5cd52ba6869070cc6277fe4e15f3a32704862cbe27789cd39e4ebea50137b0ca3ebd11dc0a6b570143f002d6b565cab4e5bcf94e0744d4092f5245cea52306d945d01af22eed760824bd0765015f3b23db99e51659eaaec3e85929dae2aa2fea9762c1ff3908261948f74897c252a9259ee0bdac24947679d8f9d89821105dd79b6ae374e279f8bb92e40e534751c361f2a2f5e5d917d01d094aedd266c269ed494584d844c88ef3952156fe183d85b28ea6f7f92504b173b6e2067505aa276a73170eca4d45bff17cdc9424028a4531f7c9af868ecc8d467b63ce38baf214e25806597d1e28bdf59b22f366add35c89202fbdecdeceda4a006f459653118ea59fd63df045769f66debc43ee8eb6197715ed57a6ccb65099c1e1faa5c997863cbd4749fcffd195b0c0a649fc3f6f671c98df7bac733da2f311ff8eb4bcd561955cd6c2263cd508b005d0c8546908c72359a56200600a1c3b584b3c2d7d504be528c45423c41345ad3867b7d079637a97747d77e4aa4821be1153a00dedfd9e00890db1556f91aef54ea5d8c1684c1a0d09e9fe18c06e01d18ec04142ae19b4db0486671d0d10d758477ae8900997601fff4f8c64dfcb7cc3fe73f2ef5a1ec0ff77324fceaf6c5d248eec73c5b2a4bb2a7bb05029017228427847cc6cd6edad330f03da53ccf6b8c1ea520d96f4ad6b8c914221bbff1579679a9b44aa7d6d80a85d1c566444f9165ca65d08881e9ec71806b77baecf0cf657daeeaad12a7a9335c1dec8d47e510bd8882a0c2fe41a5dd3f556858829d0bcfda9bc7a7879d7abd8c39eb34836f43cb1ac4dd7343b6dc03bc7d508f0f7064f12dd39130bd21babacc79ef6c7744f1a22d6fdfab87f5092244d40d47c109270fa8bf8cb2ef5aa047c17e51e67d2b827a21f94d5dba79947b4188e5a4469444d5d36e13d21e6ef0d2800c2ea6e37e7b73c7077f501eb3399439df4a56d47ee3b73ebd652cb37fb868f2b17069d266265e5ee9f587c68aa37bfc9f4fdd07b09cee66b096e52743bf86586f64bc3056db6897546bed5faec05926ebc17b8152884fd5575817725b25538dfb0005b9c8eca19a9a1367cbd1197c15d325ff345ad05e895c953ab4e3e2830ac57b3bb24ea8d1edcd65f3e9d316931c292db7c9e52e33c75c10c578f2a78b3778844fc9a28ef9192b5be2f8c73f0e4baecf99b75357e6aeea23ded1a5f5cc3d09858daa8fa2686672a15e52baa7009abc5b5cfec22a7312a888dd960cc8425f66054ae4bbd5526d1a4ed03f4e458b5f561b0f10ceb88d6ec7c69f6bc0c1b9499780091a1e1ff82be92975e55c779150ce5930f876209f2adc2f4baadc15ca2e2da9b1148fcd2a37de4f56ada79f1f12000f6ff65d9def3128400f4a712229e2402b7e2a57492485cd5ae542074061ebabfa1aa8e7e013e096263d79fe4fcca572e91d87514ef7acad8683ffdf59b09cff19ad0ec6222d22c905b5bd28b6fe1cc9d3ceec0ba21e428ca4083e7f402e1c4cd21f2a45835e82d854b220dd026ebfa5568b8fecac45638c8b4b92197d46ee82b04b7e0fff4f3107fcc064047148fb7dc5b559750b8200946f8f1c3543be76badb4708af3ac313529b0f5fd1ff5bb2f0bc37178e9af23835d6e1c769cd044644046b0d63896246a5ad073e41d4b184b2245c1f4603d0d9a195634dd4005015bb69afab5850127719f91efe508824877be1e56fc6d87afb350cd9362234095b155bc4d130531be6280d9a5870bbc6a5a997f388b402a5e1a1cd3997a50d6357c8084c02ba505a773de75a03ba9b6d2d8a711ff5c2141f3d6d05e1fe5cd5ab5243501168ff3b80bc6efcaf5a4ec78dd024519e65d2ec7c7a3131c0a061b563201a1a65245609c3ac89bb196579d5927a7ab99337df0ca944ee8ca738441e02e2b7acc475c1910a7c930aa5f8109818761b8144388ee0beefe25fd2210029930f95f5ccab52e808890e63c9b36a997f4ee5458fd5724a3ade87a2ef1c6895fd46666c223a38648fccada6d0f66c1ea3acd041f080c1500013aea821bec29f7281d0f7f8af0df9bb09c296a5f52ed7e2ec427c7bc1414c05cd90eb9a78365ec5df20446b760aa921c228d3e7522405def68dee05d8a3d2124e027403172ecd05c767db934b134e0ca9ff4a5bb616295aec504a2eef53fe5946da01e707738ab26eeab94e997810162974f1fb7de9d867140eaa1c0f4f6f5471d6a8035f89ef4e9914cdedf02310893627b6c45adfc75fd9ed4611fa7811b34bdbc43b4abfedfb3123e5d9b6b3e1844dc1420d3acb8666e6a5b831e3ffa76be6e5bb2a1cb3dcf0272a21bc1382c1e2ed90c9a0657b1b5a6302f257234d9b71518fd1c7ae307bffb3d084e501afa7497b8a14fbdaf1755bd472cf7b70305d94dc7d65e6e22dc7901d0aee51f9c97957b4a4773bb06aa486605dff7cde24061efd0b1181fd07a8b179f61d84887a7a3fd6fe657ccc2c44062366ae913b3f5b3dedb50c53c9bbf70b43e69c72b8cbc597760a386964cb4c906aac4025cf7589be844efd96da7187dad9d69901cb92667b22505c5ac79a7e88d6cef1ad3cfa7c0b9a44bcd7ae22f105bc898326ee804a310698b054a90824256c980507f33b9850b6daec59665dbf89d1add588682218a322726f55292c99351a4a6c027170a16178b0c9bc2e308c05c1fac77f92faf71ffc2c8b63ca79bdffd0465e53035771f2d16ede41a85c5722222e76b6272c86a71e676c9e1a8f77dce4ae774957fe2d2a5f3a0f29c2358b89666e31d6b0a0c447eb4da87de9b4a8d6b03caa9e6d2cd28967b100c64682abe4e1a320fb6cf7265a6c3edfbf38805a11ef0d7d5a59b59c553afe76f3089893125771d4b071045fbc1cc8a8b0ad60932749ebb24c3e217730907fab6bf0691d21dccc98fe127ff4408ec41425d08f18bed5cc4ce10625b4f4de034775920e93d153acce19a9c914fae59c71aeca1c2c55f949f88f1ab56b8ba4919452053b466a11a1e31f42730d54d6561405b2842b7c7f83263897ed5ae86274f8745523954c188ec1cf11d9a59440eef3344074c67ae65b95c4571d633509eea75375ca3440564dc164f1c5ef9821d4fc820dfdf4cf9d5a6f35abb659c49980799bc5c20962e97aafd87336e9b743c184a064243f48058a5fe14d4a1579ba4fb7ab1d8912593ca18ea786d455892ac1ea6ca6a721fe849c43b39e9fd63967264e81c22020ca5c45ec1ab5f4e910d93199e62bcb773f6bec3fda998f67464beaaf7d586cc41c3810a46a09cbf6eece41c04284f9b65df890c28414e94074c641cddb790b6947dc1c3a705fa301a9388436165a713bcd6d388133eea1dc6d291ae67f592355d0e96241bdb92fc1cf153820f4d83b318a4d0d9f84403159bebae3dff306693e11a798e3528e13aaf249e6503fc5f985bcd0cf78b6fcd976f545f709d1c435becc88b3dc2d80bb0164eb0da9018e9ebfd16873961e69d8457374db6a78dc54f25cb7b1e628d19ed3b02e9135bd3bfc87d7917a54906de03baab1ec93f9d0d74275107d5312e7fc202201bfeb0dce3e7cfa7bae689ae0c4c7169c553b7f7971d12f74919e7ed8328ce4c1b003150182f94f0d5cf7b3a929f19bf8771af6257df8e4c669f5131959c56c45351e4171096a5506d68ce9a29b39e6c910c37583eccf58d99b163651d5bf0bc1819bda39c05d20722a7bdc8d3eead9e22218201a5e2e2fcf387571e2a9c52ed26cd94eb8dd0fd5372d70c2ed868beb3a9a895c86cc9c70cff39351765266b2ab6db6301293aeefe2a693311b59f44d08903e0be032708b5662b8225ce2d0b76475066bd866d7026c550c97df042cf071cf49d0f7b25e19b6a7cbefd1c79cc5e2e08de8a68ce1e8949fd898279ae910e019ddde350808c4b3497d4580cf8d5d9ae992cea423048489874173460c47f693c443f2fc3a0aaf6a9137a2868856f9f30284f1dbf992e3b34bf6e441d97e954b86e0a573fcaf1dcae9563d6c2af70d34523af23c1310fda919cc53a355e6692e843322dfd1f958a763ff309f48738dc76097ddcb1b9ee64083d036a5c7097ac3a985a6ee4d46a15b59e0e43919465e8830fd1119514807eb76cf510fa067aa96d03517677c45194082bb70902d51bd6b1082cd8a98f4397ab40209587217b2ec12c95891bf6f95ffc3a5a4bdf24e3452855dbc97ae2706c2b802c2fca3fb53abc729adbe2c5490b57394d80c39237ba3f46db5cbdfbb7a3d7809107363619f078813bab5203aa4b2ea5faf12fcf593b0307bd6d92d2484d92bb953e325620e0e19bb90da0c36071b2c646042ed82878c20bebe97da6dea0f58a08705932ca13b50610296eab9c0914dd4651bf0601fe07fa3baf6040b2b76db4fed0fd7d3345eb40dd321ad6fe7e926d3a9143feb675f48e5704820ae3e2799d6841cc116bce6f435dfa10d6f9563d38eec6de86823ea2d01aacde10d9f9cba874c46c620be9a29f4b910ba33da2126f5fd1de067b84f446d0b426a0b3149145148be5f660e7a066ede37be2fc863c90cc3c1494dfb8751d0bf5879d79b16d1e11da15dd0508d34758ed20a7947aa2530217bf920b1623bc2e0c353441ab214acea1b89cedc306782cea6471c1f7e37201f8ca1eb54756abf80739c7bbc0c45dc93fb701c9d872101ff426bef110fc5db246e85bd6f951c8d9df829bc7fd910be771f075a748c7c3d100040b48238018dda09c97b218182e8486309f50478052463f6cb9239cc111e994563a1c5c68ee0e89eaa4aee52997097200eab7f4e3b7dc02ce497861ac9c78a689132e5fe5dd11737562bf3821eb5608c001257cba983a47d65ea3c8832470e55183f4ce369e03bd8a174f5412072b07ff6a6fe0e6dd1cc6f0f7d59603b8121d2c53ce32fe8ec317c5c892c1eb96ec18e8db27c753876ba38e78c05b1156c5fa769dfdff93466789c50b250f41212aef5c5cd40b6789940f8ee094e9f2dabad8af8fdb2ec58d5ac8fa523156dd4f536172f170ad9135d9c59b5f1803e7adac6b557ebce1e10ff83268184f10536d5ee9d88a15f20eceb04cb050a390bc4d5490e617e814f6f2f82abc668b7900715a42a079645900b7caf66dd949ea19b289e3abe3143e7ace2f526805b64aad188d97404a791f6eb7eca119ef8ffcb6e7f52156273b38946b456521918544f7709493bc85e0dff4fa7f05d67c3f5b03152f6c52e83f79c92ec075406b830716f2d204a8000eaa1e01d496d2f53fd7179f06f0eb0b1440280afe9adefb64a803f3a39d09104716715f3570b7af2edbf115756465cde8ad33e03b103ebdc26579b2a5b946f164a0b7d4827e0f7381be58003bb737df5d5ea7a3e3bf45f8be8654921cd8568ab7bfbd9912f395ecbf9d4377dec364ca1c30345ec8429c87b5ef8a340cfd2018ea74563b367d03c796d91b1d8bcd73aa8c120fb1098ef8d885ea80b63bc3229ea237ad6de5f316b2dd0592f514267c2107dd9528b3255bd264b684d0f3b8cec1382ce506ee0ffba3c623d6ec3194e58d4da9d70458e22537e52ddff7c3ef99e9bc337e954c5ec002473fa4015d0ff448d7f380df15ad54208ca90634660a19f177e7daad1d340ca2105848cae89d1d0893b5231f6d991cc780be6939d93ef5c8858330eea0f457e5c68d1718c7c43f93d159d4925d5c0ad98b92186ab0b563b6dda76a70c78e05ea59221d981ce2a945fc9ea5fa8fc18b1388523ab5bd573a51d42578b68fb04b665beab9972ef5bda02fdcdf579e4aad1fca8b8333fdbe1d68a0e6a9e4f00ec48e05d05bcc2288501aa6f16f7aef73c71316a0a669357b9ea3a21579bb2f008819a949f8feda841a21bfd3822c69d06131c137d2c3918dc39a88db1ff1acfa46bc1b53ca5b9024b1dea131ba46e0c76051380822a929cb3237e0ce42ebae850d2ae585c3756083c676114f580c6414fef48a64a33e819a08bc98c7e227bfd59d9ddf7e4695f837b005f5404dfa2a4f108be9070d8be4c92b1f2b7ddbee429cf5d0c6836c3a8718b6570f866d7b4a63f3ccaa4944bf1ffdd6a0c737ab683ba4ceb306433e77e84ec41c9910aceb69e53f95e4ab2a108359a4a68a631f17b686fa385a38aa275df178a0fa9bc4870821d47e4b81ff27396054db82a826f0609927ae76504d3722ad5ed1aa446b6ee715837abf101bdfc073653d2be4f38ea409094686d0b51a6cc7fb037b553c4df829a2d061085849c2114f29d26ad1de0bf69ff1eca592310a862b9d1db9beb5f39acfd8c962604b36bb7b2361bb571d7c5ca27ce9771da14a596cbaf9653fe79ce12b9a7fa33c39c40ba6e7edee87b69811c2c761826d317c0be7ff250122356963bbd5b404727125aa0b79ff5e77de46997844059d702fb543219f29aa71e02d9ceeb22d4a77e01523eb31f8acd996f8afec2db2ce902c8f9765d1f6a526b61ba3805f3d3ae4be6b9b2bbf239440569c06df3cdc65a8d8d7561d6fc94acf7866a937ef46322308e244f3bee0eddc53ea93e7fb0a4c550a50274aa76c4b29bbcc86f9c6022c816c94cd27e7842308b6afe79130bba127fa665d67083e549bde24813d80a2e7d16d65fa8ec75e75a90673e07a60bbca6af50ca852ddef6b9866c338a838814bca68fe7c64131553cf69f0d372dbe85edf1909f603c03f801743cbf37c09c7ec5fe49c04c022f9fe351453303fbefbc993b26a7b01f2c098355d88ae2d625ddffbc527267ca7ae2f3d0d3a2912cb5e0a372061e97b95c412126be413e6b67b10ab278ac3cbd97e864d4a948bec8bf9a3dc2263340130919d28035f4c343b55180fb2c105bf16a193037bfc591eb9c8940ebc488a322145bbb0fc2afd640544eda9032927cfe951abd3bf7d034fa3dc49da1132627b22a4aa5382de87c885e2dd3e07f30c776361891e457d25821f25028095b041565c861ab0861660fc42004fb9147b4bc56a1f94011dbbac97db9f8441117ab624c7d7fb38cb26c27fbb8cd5df8317deff64070306eb35ccab9134b7424987f6a14f5a89983f2b68ee84dc4d1f72a51060224d07b3bf808fcd310aa643f9872b1189d98a85938563eb844fe5e9e88326a03aec74b7cd8289983947bd6d41b5ac07afba80dfe53b8bf3f0cb7911a41ce211e780c9a1b854fb7f6b6fb7aa6a91d6b6bedb1e6c0b0a7fe57310f6f630ca6fdae4a564c507da0edf68e55b06154392184d8b90a39bb2532a50294a18a00f7893d8c6f603114ba4da5c0a7da5f0329f2b3bf2fc86f0e32a2bb7ecb169dc90eb97b3e71be1a439a97c3af35bb1e59e076edb98de6f6218b796666fffa0b69b58eb71c7f4f7775b23bbbc8fd78eb77869b210d4eb13e8e3360895b60b2045e429ca802ad735896d009591b1530aa0cb5c8887454ceaaf72abdd62cab497489e5026031bc06db6447a07049a9507835174285eeed99dc8abedfc1a66d67b0e434a30f6f1f3317729fc11f622c8d6f0a257237e4a1eef3ac83a90fc78d2af242566d47866399ca04b769ca53f8328207389d4bf3dd453e43d415960f2c4b6380c31b4a284e389d1d20c0f5dcd9a93746b73892ceaea4bf7e042147a4f613ba9dec6cf15ec48c5b388f0ce629aac913cba9d805faf762be8ae598b66e1b8fd46d07c337f20197a40274e7244154f3e9f44e1d87cc5152ecd267fd4d4e69492244f32e040bffc250eb9d8e68ee4994721be844a21fbfbba7c1067a7b59cb62f312b0db45b381f9eb676fbce7ccac5602ab292e19d68f55f6b88b76726d08194f9156f0e1308a2a036da50d76967ad0b5a87282ab53afe680cee256b9d6775f63982b6a5725e79761fdbea1ce09c11b3794024991f283b0da915ea75a95071dae5ffbe628f4b4b9f929e958b32f7dcec15c8fd8c1e57e97e2eb8c8633b5e52636c9b122b5fb6a93cdd55b457b3f5bbce3eaf9a26ed58d9ff06906e63b3a29a4f3e3cc775dd8baafa448afd4e6b2820f93d786bb8c73b8f57a62200eeabc44c0996ad9a04ffb9ca27f72cfbf608c6b9ed104690d86a9c0bfab9d8872ed4a67012bab95b888f87872fe3d3b021b4aaac530a48ea44933837bc9b72aa7d83a72c981e8906fdf6bf23fad492e7b9671613a79e8fb6fe921950e9ea4299589a9015cee25e240959f7f685b4b1d2618887ab2a9406dd6be985f8198a9e8c8b45169579f80a71b0d03583009ffe952b18c34c21d79efa4dfa0b6f18229a31e6e0fcfe33032839c4219c46046a2a8439bb19e2e87f3b504ce212e8dcd5b638e1423b3f2e54b2bab1d25260b42c97b5750947059c4fe113f27d89bf43c779a02ad0bbaf1b97740d25504b31258aad51a348696508b8ee9f14ce3005b3beb950cedddbf9d38ca8d4c4e925e24f066e223581f56429b5ac075d7bdd4fbf0d0e9f151ba0d41d513ba3128a65a22616146daa3adf2e0b5af9966bd021d3687eba7d5776d625af456a80e1ea734a36803a4c2b4b0692ae0adbb0829a16fda9680cc987872606d5774ad81fda166dcf2dd7b62d293982c237ef04fa179b58a06f07d5d2ba91a898df08dc96f5379713c27a5c9954f7cc4b0e24ea37c2c9284925c084ae9fe3b635bd7afcdb6d03b52aad9f6d01f8a4c38af156924e38300f1ce7d268e11d0642e8911057b52417769ddc33898371ba9b562f19141f47116bf7782ca9e67cc70ce9382097408b6bf5dcf8b7d6da07b1fc5fbb794da58b437889a5e38c37b771e9e4bb69611f44d10f0223f66be049a94deb0dc534e16f0cb1c2d9a572b48d6251f7334a67f5d251bf346e3063637dc9ff5b2a96b1baa1bf70a1b679a51eeb6470d9ca70e06cdaff869547b9df7796faafc072b8668377479e885b9eecef8c1dbd6141eebd317fbd0f42768faf0372ce413b821f236f6462e326a22ce93c16e8ee70e47031d24ffd6ee78f4ae3fea6f123e2a5e8e669690e3247fc0993cf01842f58c1ccfa5720a260cb4c0e9672248b2e5b2663f66d3259fbe3426e5505b72024888e9b24eb9dda6b36260ff75264c980dec0f23ddecad254c045ac9ef33220200721289b9a70c444d9b0ca001585b36ae557f540dbd497dac39426e8d894ac74f556a02b2af16af68c4cb7866ba727518b3aaa413e9707996a61f9fc0f7c0f13393bf80a98748da3edf888d2b6b7ebc66aa6b6a1db38558885ecf7d85911831d0b84d7a89d5b7a9fda8cd8d20fda097d933cb821bf6aabcc6dc486eff7c78ad777e9e76788a0697c020187e005537e9aa3728a23af9f8c1c932935f50203f98b73e1e8295bd5eb5bad246bacf4e2fcdadbc30dd63b88e3d4dced607615d42a422fa27ae8bc647ec41c71967f3e11821535781496cd6bd5ec9b97eeb1aba3841cf2051d5641523f36d9a7830d85f183a7ebb160790626387575964910a106342f6dcba98a5a97f0a91bea6c36b8a3fa3349b6c64d837cba04c0266b89ad2b624bb1fa56f62363acbff62446a2acec750d0d661adba87fcb5c4e26af8edea070ba130adb0dd1fe60c88a78a166221a44a6bdc9690adedde8f92488a5c1fb812bdcd29b6a868ea3a0f958b168db60408ba9f1cbe56dd697446305091bea8b580fedf97609435c3dd4e750c85c2f2457c69eab96b52d899439b32164cef6a6edc1d42d17ac7f59b8a85b1a52a203048a2a7a352dcd5675545d3b05074440ed74b2dea4dcfb0898301a3499993933dd69d38fa43d2901a2b69efd1fdab28d0ccfd3356e0755df53967651456972ffab4225d392a6ddf2715ba88f41077a8258419cbf255739b81dae20569d959491451ec0ab19bdc111f098e34759c0d68095b591484bc90feccc12d4a026e657e507ddc9e34d7b6a54b669f78b5017c6d4ae3dd0ce3b1aecfc70361620851e7b6e3f87","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
