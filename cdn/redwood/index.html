<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"669dab21d73102842cc33685fb78d21e09e23a8bc95cfd493df94087e43d72de9169d5e59e9f1ee114f27494a0d404340f644adc146f113897275b945502e8ef3078082b4075916bc75c1ab957b8e4ee904f255e75196571b191a10b0633872734046d3acd394ef688b9250550a289a756c2e631c27eeeb51adcbb4f1c3ef4338d56b7572cea2840c0e471f8e1b8ab5416c01b33df17b23c250fbcb20d7e77f951fad1f2cf259c985c18980b8ab79e78269fead0a0084db384ac137aa952f8e782e2b34110401f9f6b43619bd9c148eeaaad73707e5403e534f16049931766b35b0f7097b329f640b1c29442557866a9a804af06178315c34cac06d867e1581ca4507ab1b0bf56879cf0552eb09649c760e3f28185be9c9bc4a94c2f6d2ef70ce9821e024888b53312905763c376c5db0b37a32853fc4d088aaa9503c8502338858f2068bee038628534e41ff066e8b75332a190ba42526d01e8b47728c95b4469826f8457011b602849cf66d5c7b7f31ea2aaebf244e2bc19a50ad292aaab11b56d2d43efc2ad4f44a68aa0cd293dcee8b88a2fc804c0dfed22122147db75c1dd38a2e78b372b59d252ef7baf0d47685ed6d431a9d851b4b9bf8fba09fc40a72acf7449d30de13d73a350115253ad4327317d1d0f2cd85b2ef2daf576108b34d324b10f7ce9405ad413ea2cc2f64545593fa25710c45eb743374060444115f6f83e0f033ca304453e14c44a05972ccd7db61b6d6c8e82fd9e65e5728753c559ebceafeca2a767f5131692e100d77c9f82249a25daec0c197da2eff45a064ff7a2453e4da9d97403b47c1abfe63b48b82bc66020b0302301b60cf87d0ce55da52dc402cf682259aa5be2fbcf87ae92be8700338e57856391a321b22ffd9e4a73f05d9c1b4d0db1cdee31771911592cbad0892c29472d1c8691bd82b855f7861439df53a9b3077b500d313f524f571f153a6d76ee338cd0d7b0c5e1ed2bcaa93d758a62c0382fc24792f3a1d932547d2e3328405fb82c8ff570fa09db5ef82ace8b6f3c48ef95d9b91d7b43c2da0a589804fb175f218fcedc9bbffcfebd58e7d0dfeef3ed4b2e9d0466ee462c0a4fbe59b211363c9fbb0c026e8bbbbf8bd69d2bc149c46397a2cadfb594e08e71c148ed8b4e1716acf7974bfdb324faed7a58165950996d8d1110a149687802affcae03321722c4333a2ab899ff5329c30d40ad8a7f7add8d84000ab4ca2ac85806e669fccc6c66bf8ad5673fc9b3f5105e9a3f56fc8e6a5cdf5b7c31e7590f59719fc1c5129dd423ee638f27a510a068fbf6ac12d23944311b6510250eba9894403df091000fafcfc6d517289fdffe191ae5252d71dac2a6120970ac7dcdcdfac95f5434d565f3d08ab8a8b8f8be29b8d82486bf34659c86efe6446f0d6667bb2c6e49127278b03475faa5fe2965f817acc2c5894f5d31fa70dac2d3414a9358372cd4cbd1c98f962d1c67829fa3dbd7a9701b99c5bbfe7b0e286d7b3e1218d4e96afb089b639aa3aac5d6a0f9b6bb4d6178ad09887db3d9a8d501a289c34116a11fa5e68b5ca7d3aba4ba5df081240e9951261625b12687a1fc0fa89da86da46d6e68022535ba1df773cd99fce22dd209cf9cacdbe1ebcba837050c0cff845dd30c7e22107f3bd376bf2837391826d10e56bf37ec0100a4f25bb6f2090bc1b00ab7ffa2d0a5068d53f1ab7fe37884aa58cfe72417f17789c38ff97b13b94c6b689a50939a2901bbc07094d93e2aaf5a1507898d0b2cae9df4173743cef9cbf0459f1786376c659e4c4810f48f84d5f2db7b4c1f19fba8c46bf6fec9917f93b1480c9b16131c0daf24490bcb2c0bf32bf426eb2ff5667324b0ea6e8fc25f06495483339c2869c06417e623116d1fe22bd68487c231f82e616aa02b1d8dad8ca1150fdca229c7465ab5b971b410d7de921410d6311bd3dd698f2b1235de6702456419f3e400e019d3295a70da9a67e099cdf1a694651f963c92b15e1eb220ee05031b07ea097b08010f66d125c442197a832261a4999bf84385744a1eeedfb395661600ff3a623ade0e04ff5cd8ab7990668be000fb950e157bd3b6d837257828ff2e54dc8e1d9d46959be0596e7d2adf7d540e8d606abbb4b9fc30f3c03a15258245c469f65006f8ef98a261031213288b37dd8075e5034739b19dac38551bcd61a3bbf92c69c4da596dd45ed9694c7c9d44e9c0545be50e11b456cb36f896fdb056b550d2d5674aa8376d22901a13f1757cb491f920c4d530df8547ae2aed249cbd5079e3df191cef2344796ada3a86a5a5102463655e087f0f71c9b16cffa6ba0d5f1b1f04a94fe486d02222b070e85a082d3514775fe6c3c08038292038b3ccb2115ffd6b7ca7d48ccfa8dc45c158b11094beec39f81e97bc9b24e3299c34aaab74a383190f4628c92cd02ee7248144ed774140717ceab2e858d5a2776574bf9544ed20e1a54f6dee6df75417bb4cb349162b037b14a0984f29112bd595398a0e68fb24aab97afb35875174d64b9678a227ee4ea7f059f94fd302d31dc4174dcafac4fdb0a9171af6a7c5f6d9f103aec32ed110ca60fd0a0fca3a9f0963879d463b896bdd1be8578b820de059c852ef6a9dfdd366433bdf16cbee1ed76b5904c64dac233edef08afd545ffc92cb71013631448897f026aeed54bdc2066741e4af21eacb27c9b9b38ebb940b415c5a61ff95215ee85e0ae529f453d436fad51cadefa27ef0a15420bb5ae9f307ef898e0f3759b4626c32ebc38ab02d9a04e8a1c90bd59f423c6a92b46847e4328667bb46f122ae7b8001142dc8fee79fc8d67067f6239ff800480ae57720dcd44cf8d9c2fda0030fe60930b5ee6349b5de0ef8ecfbcf479847cb11398bbed20277022bc607a7bc3089f94fa48dea583068d7f18305443bd1a74fcb0168aee2abb7331449dda75b4d27ddc668934ab633f4f1357200007df16c70ac66f3604b3d589dc61b3601b0ca3d9f5b2f60aacd9af29f33455e9220dd71cd61847cde8cbf84f09ffc6da3bd302b74f9e29c2f65b8fb0b4864e0e040e4ea443031c4b8a6ba862efae6e123079b699d96bf544417b39ccf4534999d27aa32be79aaf1175fe6a681212f1121180c12287f8d76fb38f6929cb52a393a09c7729620d8bfcdfdc0bcf81892836886f301872b5ba9ca0d0b3b3646ca03467a1be507d3062683c3d8c563c8abb82519219dc7c1c5adcfa671c064d36331e71655ffbe1f1e28c28b969e2cf967a4971b85a905cdc0e3e3439fea71e4cd1b7d05476f81acf3d1b2f9d69c9b531b422ad045d29d0491f021f11b4b461af38a3dac41f1e011877cafba79cde4b6675eab939ac4d476e433b872039f6ef4e3ed7adfa15bfe192bfcc3cf88f6eb9582d474124d4acf0c85316731e22964668ec0997dab3359c5ff9fb93cf37951066b67da6247e7f56e7f6b15519b8c935a64b814a6d0f443d03c47b065da086adf955153de32da6fad354412b8d545eba2ddaecd571bd6720a760f8fa35142e73c9e92d59874566c2ed9f37629df2580469b2de3ec0a686a3b75945d0a2d80f04aa55e09f4c3b24341af195b10c028d4c378762562faa8eb99ee85f6b5c2f007507c06165d8d45ffcbbc048b3d38a6bfeb7a5e3da33dc87844787fba18bdaa02afc21dcc685a36fce9e39c216d68e76bf07413fa81d0fc52c4e0dcdc428e4b3c7c08a7ea923ac6bdda08b8215c01df5e630a3c888374895eb36ad1f77e87bf8d9e083c6fff94bbbe6cb9d07d90cdde3083207b86486284dbc04ad6e04a94f67534448e8ab2345d57a42c6a471fde216d7189edfc98b41b7055a1af952d9dd9b00eccd94c8cb83bc3b99a5b470531f8e23eb5a16f4b7505699a0d319e738035f87cdfa1fea34110d58eff516d55ad8bf0c17e4ae20634fca0e2d73628b802c77a02fb6757cd81d6c5af8bf8bdcaab3898fc79a75a50a4d071948bcff69ac4749c55b228d181ea81733bbc5f5b1ac913d9ac0b26ddf924d396beda1eaa275ed301d41970b175c4a77282166d11613abcd9043aeafd7b85d65def868175615e987bb16d65bb41270ef574d3e669d34e59c786b5be93edb542e80cac548196ec2d7a197a0923db4cee13e2b11b41a230c3001de3c0f4ff1b036b123af05e7ad32599fdae9de553c1d81239f186f5c616f06ac68a8c4d356050301aa295ebe341ac4e21b859488cd3a0092a260b7b17f2256d85e4ab306361b9848e6b8a306d95f8c98995777a8441ed8305c1505f04365cacc663503037e9417d76be89125dc0d8aff00a2b026cd586c920d12044f9f0cd94ea9401f323dcddfbc1078829369c1630bc05c2f040f1a3b3d167ce3f2820cffec852240afb2e430164d85aaafab553a41d3093f83de7b24faab0a6e0e409743549a9ea567cd390972cc412962869b7d3983e15f1848a5513a338ed21b301553dda842ee2f9ee1c8ec7012b5ad9a5a1ac4758bbd4bf14a7b94d21fc7b4949290897187ba5769f0b1f75a20ad8c93fd36d78acfcbdd188627e392f2705f136b8c57bc03cd2e367d4555bae909833055085a3ba448794e965b774355da8b9697dce00753f18539fa99b5725424fa40a538080004f6ac95988a254383f8f3e9cad41fc78724896a6141b395b182d2b54607f38d45dadfa3ae2f8c409cc2a64124430ce67631d3470ec39bfdb4cf9b6d3cfeb42311db0605f46ac6f456459341fefaad2df9f8d3293b412415feba5709eb844ca009a583c56e7b6dd95263fb3257a564076450295cd493c6dd8f0530e781a433ba6e44a3d7ca66b16ec8c902101d86a9aa0994a906c22571d2f21cce093073b5cc78181ed1177eb567b93a97fd83653f8f054d8641dd28a67296e92944db43455797af11a569765bdaaaf9803ffdaa91cd90f417a185ad30038cb8501678ec702b37a36e03db91807608992c85d91c2c13bad2516a875adf31e697b18dc72282b72057431eea91f4cf5f7eaaa1141843c275c351dc365094e36aac2d8d0936a5c9c1fbfa6d71103cd4154cde2f5a94f7e2216e254349de421539c9d458ef424495f2df7839d59bb99005398072dc42f908e6f4027f9bd9bf9b256a652568dd17d505b2547dda8d4c645e42f4156b2ed7f37599e8a8b4f5b5d5fa999feaa8e99ccc631579d03453dcf77690b8cc5a7f814e08543631fc5955a6a0649596a8c08559b7c1d4698c3069da522b3fbc849e0e59d7e9e11495c5cb9fade450967593abad6caadcc160b30fe838671d39b841c18fedd79338a0bbf06004fb508f8384b7aabc7c284649609d6b3b7636ab24b1c8bd239b0de1ff5345e9e420bcb2399792bee6b0c3ee0e4ff27e3bdbb4d71d2c22d521714ba58ef8bfc4a7b8e6cf6d62f905345805a94a2240eb2211edbb40b63282baa4dcd8d5dc65b7a59cd1ec97d77c0b3200a973acbe6400a5264951dc009853c5bb84e6e57798ec384d0c99ad472a89388d7affbebc7401c3b4d59c8f2a3b25cbc4e3cd3e846970fe3c83fbb03b9ceca1192ce8f09151b82d0f896b3f4aa1cc1a2f525dabefd96eabda73d9b70265a1d154205f82d017a526c715c58e3b1a8bf84bbf59002b2ca5a6164dddde1058ccd48da0391a783faa651787705d25003a38be988457ac93a462eb39eca3528f5d2aa592bcfce3d5f1daa3d2fee44f3a920082e772c0a39170033743a2d4661d51ec2d50b09e513e5707fb5e2fde444c0ad3ad9ce232e758a39edac7cce31640275e4268f8946d98b0813bcce6b150fc012b78523dafb9d0716f5d52bbfe89abee5b4941c9b5b4316aa0e8afa264d95617880cbc822e517a1608b4ae8022f8e0d97f29cbc889614e4031dd2adbee853a173c678efaaa763aa5c4a349356069dd21d584ae71da7b2b8b2b7d1a67013f3eec35e4a4c60a0b029af3d57a3d318c4fd8cb39765f8d4fd7e976b768c6008a501695dd9755f2820984d6e66a2621e9c4166b1f5aca80839cf52e0d3fc2cf85ffe7d034b405bdb85259ffe9bb95e1ba83a2f6ad8bd3e52803c5102149fde62a19cd8e0cda0e0d254046bd3f7eb090aba73a520f94f3745037e953b6beec2e0df3b82823bed6d388e221a62935007d5473f62bafe17696157012f4ef2d354009539cb579c443ee7f74819d14898b6c87f9fc7a98e961d328e270d3dd067b940b28d1b8d517644753cc0200b975ab376dfa40562d5e4e84760bb937fc8a1fc02562c7bc6a9bdaecd558a3b3113ffb553faeb3f58472d4a1f8e30e6d74f658a4b35f78b15afe16b621955ef8f83b3ed558b5d853831ad1ac6cae0417ef3435f9f6c4a28d6716206f768bdcd7b7eb284afddb50dc10ecaa20ab43a09b51af88731a6cf56c37866b3de7c89e5a222c5d9fc7f1c2ad741c38f84cf8c6b97aebf566d3d19693d4b1f7d8db96bc3a691dbe8be5726fe1d66e653c84d66db63c91790fdf95845dd54d21b2aabbafb45ed751260cf156befd26e3d31f1dafeb005c14d370aa4e5bb91218078f690ac841717e45f39f2fb47b714831de3e40b60c76408dfd2a14ff2928e4143db8e74599d3cb41464607e8757186403d23ffb2231a7d2ca796c1ba5db44dd8ccdbf8868c6c6bdeab22ce9db78b7bcef382019605e3b8a1ea01cb989daf6ee46da61e3f6b4474739445e5242e133a33f0cb1287cc3cbc1bfc5a83e064dfb28b4f9dbe5e1304fe898bcf7a7195e8fbec33e86b617d84f36a4a079cd6d715170fa41f94775a357739917ba69b827ef42494f76c485c89de3eb0841f2773e75686d928043fcc6d5b5eb80604a2c5fdcd8b48045c893c80c0dfa8f7988acbfd5be0d7fcb1f57224b86884567fe59838018f36466a965cbbd75043e613583c3cccde59b79ad349b728fa3145733ff3b35efc716c35545061f55a44c96a9db695e45c5253ebe182f3aada6c777c753ac14ec1757b1ae1e4285f2b0eed20ac7d9bae6c42302764b84c0e139d06dad0a1272472a8a70071b6a2f79406188301b2905a0bc7fd1083c18edcd77060950eca1d35c134584ba47030100fc58b92ef5195eeb2a7afb04e4fad48d39ec016fdbd60dddf67d1c11aa968b8dbcc23b744da8185aa2a3f75029ad8bd3e023af2219b514c697a058f391b50ef2538df22c2b07e8053fb230bd17fac85231b4fcbc1e0ffccad590b58f88e3e51c7ea6eaee14d4943040594e84a1f89f9ab9e4bd9a1d6b2c564a58c78484533606f4b53f289e3a1c84046014d5b6d51ca199505908afe6dd571a23a3e49986d453a488f646d95aed847f2f0d64ecc4e1f0a7682a4f346bd28e4cb668a303b583320e09b12dfad97bb59aeb720cffb7e4245dc36989a76294a47420c56de958ba8e4b2912d94b8647fb8f0b48ac7f88e25134799ab85afacd9b73378a823ee218f38732a4d6497ccaaf3eb9fdf3c7f0141faa46091b3b38a0bbefe51491f44e36abe76286474b47a8bdd7613dc98ea75eb4af5d6651de9c230368a3ab5e259228e92ad57caf4b8a98209fa810ec28e0a98ae7ad1ad7b026d99a8101b181bb79ca7844411cb89ec16f85e387af4280f1bdf9b5ac964e867ec3f74c1afc21f900d6f98350942414704341db6559afc3a873bdf576099d250aa8f8e730801b55963d329ed6bb2eb443474687fc9d72c8e791603b6f4e3b969284ee35951b33105195a7469b7befce5d3b0f20b2dd853be8419b3f9020d092a912220bf147649426b537733706dc243b3e7501170758e70eb0007aa30115794263849434932e536dbc2003c312070c896ccb6431d1d52d44d9445926740f98cd172a842f0521ece7db07666f9a5f0592a31c6abe305e1a44bba7b9ab05016c8e68e6836b5e576cdb6b33e4bc41b2b1fecb9b50ff6dbe6168ba68147f4158b3d649c30bc452124e45fd04cc7949617caeb0bb6b9dca2e46952ce105817adc481e9dfd92700b202440f6cdfaa199ec02f68c3f22d5084ba50173aeeab81094d13f43a0981e04b42a977a60b2e88b1677ebb9124e0e3596988f17b14434bd3c3fa87df38674f2b8ef6195ee517c483a2cb08b766feea54ea3a4c9c2f0b7df9eb3c7f9532e6cc51b959617d0dd69e6d5251f4037e7a0b0a8ab55a9771811a161cc66250c659efd45c21081356aa4372507b7ddb6cb8f620a04e765bd751684ffde3eca1ef0460f75bb01a40bbbac88b6743542a11cacd636f9f9328fe814bae5a0188b74e4ff794325a9ea49c9bfa01343df062eb7a297c1278b1fa2068b1404229368192dc7a6f64336c10266891703b7ef98cc93f36bdc87b2b97a701de4def8c7f861d64fc258e308e595521ad28abf9b1b376833403396a060478fac2c0edbaaff96084a77cde4f8945ff81fdfd3702e1c8e51a1d6e4cd279d350a8e96a52d0b2e42e683ff8edb98a95bc2c8cad40c8f9c67cdedac0b7a6b688865693ea42f1df7f2c83bae3f522bd83444ac08febcdfdb456fe040cc11fc85987167620496130832e89b0c9b5f6183bd1c56f5e9a7acfa3a8cebb6c294dcab87a6db46b40fbd21e3271df5c1ccdf60bacaeb8517dad25cdd4d3f87fcfa06b73fea2f057c6259787fccfad68ef6d93022aed05ec953c0352967cb902e0551a7417c01bca09f6dd31589aec01305d6b61713a49ee7ed41d1a8db13cd5a1ac8271243c03b326a39c015fba9a697f3f9bd9e263b4767ed20fbe55963247ec326e6acd1e52dea6188aab8bbfeba64af033b96b708777ec9efe78e7019f62d3c37eb7352373f9e509dad9a07563dfdcfc83736173f18d546fb1c46f6ae5ce284da25e141c104716a760a0cd78d38ddc7d7729c26f32b39b61b573668c89f25aa2f3770575deee6d40229cd342725d5b5a4e975990bc939ff5b2b949c0ca2c0adfb1f9bf21b39b55226d58e49355644b2ad54148d3649e750874ef356256933096349baf5839c3dc255352f68b363a4bb7085f144cd1bef61e32886986c02ec0aa07f90c4349a8f7db63f42e3662e88bee30c1fe3fdec40bca6aa097df79e6b3499515765daaa4690202a03e9ea25ccdafa78666a05dc2653fe3bee820dff3f3d85c41a56c83e44ae962b7da9e8afefdb24402c649c2fc7d7b891d86a2ce68f31b982487efea4ac8d98a7ef993f29df3c7933eba410bb1f4f7c9bba7a8a7d6c183aa2624c06c77671bfdbd28d2b7f389bc88275a090775f0cba29204d7521d280d66fd5ac0e4a50d87c7098060fdd7d3e2647f6974706e64aaa9707bad0f276f0c489acf7b7019ee298a2fa5a67e2881bf7a84e84bc0caa6d187f461616b764079fe0ce1d369f0ca82ecbba66ac439929c9f251614224184d5bcd1f9d93e5ce9385ce8ff9aa155477d69830fce0bcb0ddf39e14c794968b93a35e407ff6287a0f360e39488853376dfef4aa351147b6db4c03e7813e347639f1bf3320455a5cde93cbfe6f222e4911a813ab25ce49ae91ffb62c1be7767e8bf705a08356b0fa5f66c839ec54fbcf7dc36ff04e88d5afa20e071d98c592b7e9d4d3f7b80a1b4041716d36a9ef4bd2ca5a9c5e0cd53442965cbc73d7436395f1f6fc0d94ccf75108bbfddb258c0bb5413d9fe0152a609dc45c03f392342aeeb34fd1afc97097e14662417b722caecc105b1ac71ed109c9bef4465c26ee1a9a9718fef58a65821413d5ade69b3340906f7b5e9ae2bb605e0a7531db268d645217028faab4b6a062b0bc30d597cadfab94787e89f8c85d55716db6df3cc15a86a3bd2279048d3befce87720a21fa7657f4283d7d00eac4667dfe5bcd64435928dc7fbafeb889471156f683b6500fe916346f2d717c0e84ca784221f308e4b2d0b3d37ff790e59b311b21fecb69c05f5c17d70ac57df16688ec34845b0ee9926b723847610e83c4e44a74b3b1716978392096c54d920b57f92eabe1d252322f7fb2f1b98d24fe85e3ee4e82dc8eeba331dcf71b753c685077c8a387ada5bc5eb804f02410e70e35d8f372ec4ab81b4d96cb231954fa66aba1da5595e4f7b0205ef3e8ce1f731ce57693c2883dea38612b993295dedb09f3c827163dd766611262e44ae0e404d846549b1257a2661698fee36ee900b6892f546a3cfd481b86eac6d7b373ded8443ec98f9ff97177155223b421cb54c49c8d3cdeeb9cdf8365095719a931e46d01d30a4631c598e406da004158f07149ca5222d2049ef15395ac7e6208fc20db356ac949c62502a2c6f20de5fc1998a55b1de5b89f4c5cadd64000caa4acc8652a761167972800b1db59b91cf5e0d00d20b9205341f9a7a7c0ad76c22cf09bd3770ac7ac4aa79d6670cc1975344f3f98a059976d701a4abf809d598efeacb91d04626b9ce1d2688009363b3fe8031883491cc388c5d2467960fbd0bed6ff9b09b3abd19003ed2a5db4a48680c50e5399cd2bcc00f79da8ef66b75c2fcb732f654a1022ecfd967a7cfb8a35477d2de7c9ee2ceb164d94be76d1cc5fa90c5ec03c54746191969301527f935374d28aa484267d1444a9bb5f82bf103a5087f9837fa5b55b850b30293af860d6027bae427f8ed7cef549833ad9df83f8d772d9bbee6527985e5790431c74b1d4d67413684228f9c67ec43c84231d0b53740ffba8752c233232f898e791d9fd39c4b7b40cb75d10f34f054a7e6d6f78f01fb7f272d0ab825577ed7c50af346381a3c362a1d72473ef466a7dbd3b2691a3f944fe0248256f64225c858e5a6ecb65184283a833eb0f6a0c55689dec880c6aa53f13c0577727ada4fbb0a14aaf05741f8abc06958cb173b2c41eb69ab0659eede635b8f03d3e60e1efbc965cff4e5706f5118f4248746f512a93ed4e1407b1370870554bd1cc1b90fc8102c2b08fb3c47c9d0681199c51e20f0a70b8edeea814d52e219fe5044c1dfb5271b35e87886c215d8b646de290868ade7d5916d45d036486a4fc584416d69b47aaf64f9f51e932249f9c7b33d27f2100ba8cb8fe96c51cb6ac52a17e55f4e1d855ae4c883e61c5b50ccdaa365dc0f8ac535904bae9b2e1ef44edd1f8fee257a7d2db79bed42111aa446a43aada55f1b0888400c0f0e865e38b65d410cb75208c581d2a33c8ab910ec1e44261eba4fdb595622d455f6ea4658fdf48c9652f173aa46bea495da7589602d75e43c0611ebf84fa771038e84b3ade6a32ce843101aa144e67fbe5d8d96958b12e781d8d19c2ed539a37e6e74361b03de4fa86db10bb9fcdd99234d169db964d2173e5efea0fc6ad9c1a2b8b610c0c17fab3bad1a4f465a1b5bfdfd374a377cc74417bb908745d62889c0fdf98789774e506509d7e0f751a06e95f7d64a51a19252bd3b8f00d756d243d84652a9e384bd37fac11940579f2b1e7b7fcea663cf07c379e3d21b7b05d01fbae839e9981711d2391097ad36143745db6ba01f46e1a6f31b82229a2e68abd8ab46068e77612ff808cd0a8b373d4ee02e7cfd7b16af78f684325e03b1ad17624af4a2674fd60cd61424d9e80c82f5ed1b25502f635ec043cb1ed43a5a2347f9292e38fba51ef90aa4ffdebbe3b360f903c6b1c5942e5948a66df2e19583d8e48e0a204c751c41408ef26f7c15b579138ab0e8bad320cf5efd9fdaf53f9e0c9735aba0205edf468ad8bce3312e963417bc2b0d4b416e0194b1fb891c67ea51004bfd336b8d8db934f390cca199824c234f399a9549672dbac85dcc5b7c1c1fd044db72d4a42a766c470cf8ab54ca6a2a8449cffca74973f677014b7611ab0691271bc3cf2447eadbc73bc57888682068a4aa0f36b2c3da437f822815ab5adbce72f39f418538e96b7fdea1abccde89e92e400e8cfff48fb2da95dcdb74283c915ae183862408c014a540e9877bef121eb16c1224f08fe9b8429af468bb7fede4a95bf7b09218fdf27dcf0a96123c5136722b0d118bcc0c16e835d2b0e0d6936d85cfb6767b37f1d2720c6c23c25bba6ed685eea96fee9978a5e142baee27f80a110a79a250bacb09b06e59c604217b714dfc67c49f8e1873448387b2745b4dc79ba42aaa26eea2a9f48cce9883cff43b6ce236662875afc43febd1679d701c5caa08ce1d5e7df705a9e72e73b4bee40e055c7faa16f0c6625291ed9de68a0d5c9aa4de6097786f3563898ae1911cb72561bbb46697d4122eaa718f296295ce0d535423a31154c21dc2ac3db9c5af6835734bc2a998ddc98c0daaa63b7da9f35e724bd27f2fd3e856b6c9e30ee9013be1d03d2b69c2318ef783340aa6315edefba89b45aa408f730196cc583509503e8ee86ae430dc5bc24ff777ea02f7d63def17d5e9276d02091107a79de809d68398de0ab70eea6ddabf3c887901a885c3dfce7fa8097d977cf4b769a5d8e40c7a9a21766e73430685d37223de6b14fa354fe7cdae7ebfab93a76ba6db85e85cc47872aa40e0c2ad1c767fde7c28a272a24a08dfb7f6a22a5666826455503ad577b7e551d32506d31304f41842bc90484c283cfae1e81a863de745ec95165f21b537acd49aeabd6fde8edd7c7589a55bfcab9951849028babe6d81d6ee78d1709bd19a129efb14d0460160d0813caa64030c03bca118291087a4ada92913fd7cadbce1dd8e6026a0adfdbb5c987760632550b750614bbc5ab2540cdc217eef056b286638bffa46f706c2764ed8526059c02335a1bf158f74b8d3bab7df32561685f60f54a3275cca1cd4dbdb63388d896d3768722e4fa67628166a3c5bbb57e9b45a2a7389021ad68d7db277cc9b474af74c0511b13f3dc28483da48c4b02d52556f642b6d11bd6ae97720e246eed6c36b25690a7ed4c594b7b9170adbb8ae5909ffb7ceb7c6052fb2b76b0ad51c9283e23785ee9d93a6b3f988dfc3fe3841230768a237facb8a7c37c3911efe819fc7fb4936b5430acf7ab03f5ab8fcaa9fa72f791fee8bcb17cb94687bd68627fda7a71e0b76668b90c79244adcbdb8400c5b1423028f4d957e695ce92599cd650738ea80efc9b45b5b98d773404a8a6310c434af51a5dd85d1bb198bf66fdb5da1bb276dcf3e9805de1406f4454990084b79655ab5b806e734075c4bd530f346dda0cfe8718b69474a2dcf4c65209638c2c19247e30a4c04f9567b831c2e2415b8e3662acae76002c46cd106dc0c1fbf9ca7636eed8e40bb25620d99ea49e59b5097cccbd4f9c8234287cb705f3a4316b949bbc0aba1f36bc55d3fc3d927ce515284277c6cb5909e82f75ad4d4544f31509c7aec7d73f7502103b6b1e0788243e05bee14dc12a6beafca5e53f92d0fb35cb4b8cae43cef61acbebeeab093af0361287474602cf59338ad41d64daa24f39608d5f05c6b475ff652ad6290d4d472b95e6343a6320a83b24439c6f9e487b1dcaa7395761e8403c8ead413313adaac8e2f203b19464478152c45d9c916779c17627009f6f5811419ee15d0e1693ce30559c829c0b589b4b030c26262eae309305db564e820d73eb42b4048b2181b019b3ab67436edb8f893d92870ce16ec1f66e191f9fd3c7866d382bf224c5124738d1d28d00169408dc1b366330e0b56e1f9a1e97ca4d5a44c702d43efe15abcf99df6ee1f872ee57c96d0c796d4ce8bd6a9a52195ea0ff36666a3b293c6e0fb5b075b2201e4fd377b3f314e00e95c64d49fa4da7b8d799e5fc96119013b5588d86eeeb728fd425252b66ae275bd58a76914fd9c5f226d69ba0281c60a4c7a5292a947501f8d84e2621d848710060b5b810ea1a2639cd92062f9a932e70181851d116281b195ace8973383842a72c7e16a7473ddec1c952bea2db289778d7baa4a0139a19d6ca61a374a0de5499cdb8913d47a8a1010697f25effc120c0424b5b08b13f9483b1d5d6fe789259d5b424ddfb61e965fe8190770d78baff8378b5c0e36dfd27768ee7194b19f3d95ef3f695bc9f38b9b7fec486e5e1f86f5836903969791fb1127ab564b95ac20759482409f852cfce9653ffd204f99d7cf242fbd407d07d45c5b5a6ce7cd43c2afa2cbf754fe4a4c07f9f2b00e07db0e466f05c94c8b9ada4b70c6fc5e161c533df4a2e616bfa07c4da677678ef0f8a7660e4a9db78eb7e4b331cdcdb300153c02b57f9ba665c1d522d7793b98f5409ac127d4c422a0c0f28b320bf2eedb5778512c472074b5f919a8c581106649ccb3bcfed10397ac10077d1fe9da9392992b99cb8b53155f4304dde4e0269de090301930297c54278d3ddc1513cbfc9a1be59eb6bb255b9f47dc6ced73ed4107c1e8077a40abb2b5367985ad526e59fd8a88b3b2f187055e15194e932688aa4b74672ed35a6e886e235010e7e6c1b4812fd038132372ff0d32ebe89a28f874352458fae0761d17db5467112e94680f227489de4165e8dd31e16eedeb8a1f97758ad330d07f4a75fd3ad64fec7792cead841ed49bcc45f09a28f830aad4dbc0bfa27cfb1e2a7d457c03438cca18dc48c731eaf536ba26d19f2bb2beb6fdbbfc38ff4744603bf491cd02f804afdf50dbe7351523852bc80134071cf5504eab1d4006ecf2cd1a7fd771d789dabb751eb03b0ce89d6acd6a1b7cb150d9d24a617d402c3265d4aae97cd90c947e221ef58ad0f580263fdca945ed9ce83186d54e54e16a203532dad42e7190587914b1c739a84047ad965b6ddc69ab7c48e9a7304fe0820cdba41303bf1cae601898f0dea7bd683c068ebee72848c0b3ef7ce52dd1e52ea79bb57382f6abf436aeda176241a2bd0b9bd4a40e3e55bc02dfaa777b473d1875550cd6cbb557253eafa35bbae0043a0fc9d4ab9315713b25c1b166e12b1a22ed4c019403c025185f83a7d60650de9692a8816a8c4f105074f78d71c7c3d195f5f515aeead8aee1cccabedc6e551aa0e02e932cc1f4a7de99e9bf181f11e49d0ab3656f70a89188d3e61f09406c9483a4348791aea6c70ce541b0c9da46a44f87aab6b6560ab49ec7ec756ae57bed0996fe957806ad09351eccab1111849b969e9bbc7cf28595250a31b344dd5d764db7d8c28b662cac634efbafcff569904ce620369726ae3c6591a02b9e00283faa6e7fbe548e3df525d7adb19ae496bf062bd851677bc6d944fd02803bde346fea0abdde4a177af6a6c8e0986f5f10e3801b393e5f261af224d311234030d11ac49ddf6b6818bdac1525e92d22470961a67d22ded642b34a0d69774487","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
