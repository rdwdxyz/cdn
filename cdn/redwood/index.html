<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3850cdfd20db8e7136a709e5592e468e2fa09088c2551272c3bb047b7322ee7fa375be47aa38d3c74602d7d3ace53f7dbf6c963555395221e37ce1ff14e02e27dce172450472ba8a25af802fa76697d490eb241965b8e495a00fe7939cb6a5dacaf5e7d4122fbe0bc63a788f148a23cd48e179a27461bb508ee61033272ce05d9c926dc9d3afb86c1551781137eb010849f4e87603f2ed4b53ad024d04583a9bf8667d9e828b8553966b2ee87a4691a3a32512ec20f25b0621df4b14ab66d228eb6e7ac1a0da58a363954452f3437b7a546af72be0aad9d0faead3540f262ebbb47d0eb490eb422570471fb8f12a023a11d3926b09e76444accb65c980004a498eb47a7b5e14b19c6bd77fd2f3bf402bde27a20da4a2815bdc8d7665a262849339b738dcbe5fa0e8a802acb47eef505b736e246c1e7733767aeb473ae705af2eff8f2520bcc8b506d6ba52fbc6291890ffca89fcc3e621505bef879212a7ad4ca7bb76aa3a43354db88aa8d833f27f3ca094e0fad4fc523d52ac3d9dd1036aa29fe3310361f110d491b7ab0e90fe0d029de65e63ac5fb8f9ae7b9bf18550448eeb447e5eb08a04b473b2b0bf3dced9aca8d6dc78735b3fd27c63191789db92ce5ca672ca444588ccc57a51670267ddb7924b23fee73fd3078bad1d97dc9140fd665696227290cc2c1c83cc5afc0ed58b2be9da2c7cdae1fcc42b3a1d5013b55595515ad9363560a3afeeda0e7f6776ed6dacf9b951a0b971e011a721c3227136a433b19c13779680a44aaae7dc840ac94124bf3cbacb73d6c793987ba19fde6c60451cccca95e7c472c73febf60a29d5298e32e590b5b8cb5d64e975007395dcb88f299041d83a8a5ce4017cbd1a513cc51f7cf9a144bea427b692f7aff2968111dfd4993af2977a01be38f566b28e5c2bbf03f02a1f786ae75132a762333f1a36e37f4e6b437b51780b3ab8a03deb2db9a00f4da3f10a93419bbc197458adb65e542697b73a242c0dc5ffde864bc982e043bae335741e0840d48d55837969c6c9d19ef61ce530a44ce78fa2c73cf13e4caadca5bfe23d4623cdee067311856d799ca314e6d3b979d29f3c20fa9562a280ba49505ffafc7e17ba8880302064442bc7ebff93f364edf44c8a02b81433f2caf5d75184ad89ca769e836185efafa50fdaa53254c94a3ac626aa0c97342dea95d56bc2d68c7fee2c3a4d2a70ff7c903b6cbc34ced3ac4944f0583cbc7794d480cb29f0f688c7a8e52d0524d1bc387012ae45f0e17aeeb3994d797aa5a7fb90db110ce575931791f5b424520b841d7bcc4d14f3653f6693eef761550d9e3dab2fc3653790498b99584cccffcefa15f59c9a7624c8f59f1eb6bf17d4e69ae63d6d4673f4daf2d7c716fac85ac48d184f38d641c279ffad037911c0a257292819642b33e831e4da879b223766ca56f9c827b09c272c64473b4ed4c5547d4b766a91dd8d0e1b8395a59f01b28637743527a93de14d549660072a93be245729877cf455b2623b845f32acded8aa9f306721978d12923e270f1fce14e6a5fbea1fc8dc73e6c1ae9f149aa0bcfda74fe5f510cbf40d7df308632feb39d327e248be0f4daf01fc5d734e7225f9524b5760df4ae072c53bd716ff4797f170bb897fe46f36d56c38ac25605a30913be12239868b677c8d36256b8bd778069a44d9ffce512546ac45c900de6b99f294644973e1b1c3c9050655e09912232650a11b7a681a8859401131242d0118f78346e129bfb13c972e99086638dc94bd2648da7548e6c91475767322663e35c3962f660c885a4721bf9411afb1d35c9fe68cdb0399d7cf88a2dc41b31592b935fa92d1a550a353f163ab2bc4b07485b6895bd20090c1bf5916ca7003896b31135adbf440c0039a590693434b3f713bd84883f63990e98b4abdf9baf753145e47a4f01d0cbc09544e58f77473782f05573437e23b3c2472961a88d261dc8e0af3657b398d53f43cfe8a82f7e42afd806a40c5f09fff72808583acf76368a6c8324df2345454d3cb5e23ad18e60cb2b5ad1e0a69807fe7f1b619d730bc46ca2c3bcd6338e0149cbed7529b20e93e6f4749464832cdb200f8d3191f0a96915e3ba24c20dc636ff91534599486b10b2be3a54f283287fa333b21f46c9af10ca0da01ece29b2c338cd64a952d138f766fe95bde9ed80ee23414d0cfacea41b130a2dde81beb5891221901dd5734d774818ce0c088f21b423d3cfe79d712b0cdd5d1a9c72016b41a171e65faa2eff68ede7a3a25697ca2b8209d4639b94a8944df2e525af5586938b0b71813c2c9ec93d1c095c5789cd908bedc611159e1e2bc24e92140e00a99284845988e4ed5d1636201b37faa504a23d9ab552ec70383553e584f952c9a889b3cfa2b215429aece4d13d681acfdf07da196a2bcc3c863d55c3a6b8f96261cb57de5b6cbbbf04e300050f6face49af453e18ab783f90fef8d891641c0a0cb7fee113ec200d8c83dfbad5afeb67401bf1277759c198d47d7b7beaf6075716f5821e5188b718f3e23c7548722717aab7cb4dd3186fbbadcfba56051bdf4843f69048ea49f3480262d65a47fcd7337c99b3dfb12c24f9dfda093f7cfb2325181b47dcadd2c368b7639aafeb4d317305234990892a80fc23bf06a1b9916c8842e7d2d32535345e9208f441df23982327316a7f7ae19a47b2e3802055bb0df027386f82c4d680517ec771292a30c1c49b19b698f020bb58061a9edcdd3553c9b08209f2bbf9a59238c8bbf6563b1d09472d2e7efc8bbf808dbc98419d254622b668f65db7d48b7b780ce998ef9d3cdd8b7c1e7818396b851a4112f55ae734b4de801af9fbc5784effd9fd0932c3230016bbd76eab6b00ddc5ef42a70a694068a668c97a52cd8747486e514d7a2493af320baa32f918626df28435f6ddbebdeb6c362efd30b03753d43c0c262dda020f6ac113f8ffd69f5d7b645ae0f7ce30c9f7e8f9e017ae17b8b83def01ec67dc53d7a781c839fcd3d181df011fd35829bacc8fe54256b56ebcaa77ff70e0e37b6610c75cfd9bbb7e6e9f9a0fdfb9525c9330d97c99557e175edce1f788252cc39f447996b8b6a9feb7910126c962d242cb5e9f7e181c0c689e55e0c97955f1672f8e7dbcdd105573d342a778e369a6ca56804eef3e7e47171bf4cc0f5ad3d260ff227b1703559a5aa33069c4889ebcaf27397b5b053469ae3c52f8decff8756ad1f0f26e4ebeb2beb25103f2705a7f66756492e7885b2bd8270572c3fb515b68d4197dac599db96c144e6a61b836b5140b58b0fcb882b24a480d7beb51afa22fb00538f0ef682a43792c6a6a8b1465f0aef23ab280bf510ce8b773348cbc749f6e669c881207783b689dbff7a512f84817d5391e58623d5593a8b1bc375610c2e1ff0c56b161ce8f8bf20a95f959f690ccacd3cde4186f4f137ccb94558cd943e3011c46f538bc2a7d7a54d11872c62d7fb7418be094085e5a4e917ab291ac8b319498c271871d42b96c7ec663748e7dd764263858c291521e6b8c1b629cc4d84484c1abcf7079a08afab1fc0699a517d263f181548b77b8121b0b5b302ad59e8fa9c24d1c66b7b5b93061e3bdee1e3e0ed0667a5f5adae084eb9b3788535c165ea086f1051d0b52a7cbcbe55766db65d3c87f0c996a415462b827edef902e84a7985cb2a95c859651a2a863930111afdd1502460853701f304aa403ce3bca35ebe3d3ea4b1a7f200729409674866c28e09d9e83fe0c643a0a3ba20f416e36e46373f21a61a763409ff61aa61b5458db098e1aa0e1866d016ba546454db3af13bb4481b39f0a3dbcf1de39d6788b7d2e8abb8b71fc06be2b10e586d364eeebda936292244e68b9d0db06f4cfc5bc39d5ddd2d18a3d9e321fa5beead65ae9c27ac14bf571766763903de706eddb95db943fff55d1d9bf30b2533b4bfbe80446f111d35005459703cda23de50ee975ad1c0aa6ab4f2096e62d9e5dfddd29e05534a541e6de5c1cfe480669c15110d9b694855fdf801224291e91e4b903936bbb5f641659cd8b2d724d9ecbc1e3e1486ca5c475ca2fceef2d2f16ea06c9d3002af43529ced9c246afbd1f7545e3e4173e0b6ee14d175a6f4018333d9cbbe33a2bb3d1f89f10d28dbf6e00117293b03eda92b1ad412e98335a764d54ad87134842180368d2d57938ecb47e803335701a05f2fb9a7e7a7f2e786c8b4f9b5d489a8fd38133fda67ae3c0f14e8d8d7ad146bcd268ba0e8e5f7c9a995654598c4176ad233c0bcd35d0da75fcb4a0e39232e007577f3531cf189c16325d7e354d45110dea192e26d13b30770391b6b98d9fd9cecae580a68b583e9c62e7aaa4e99ba3471aecc2cf274ec2aa458222b3b7de2b6caabc3fbc3ed44c70271d5eab5f15801f77d6596ead57efd95a458bb76e95b3a6c276e1b5d76751a6b653e5e82b30b75ce3f7fb338d99cb3d7dbe6613eaa56a2e9916355537699aa262396f21dc62967aa0f94daf82ab9207bb5a89f495f22fef1c118f44283532000844e32613b92b4273b3a19785cd17d4ece9d511533745b728e4afe0e44ce250cdc747e19f48c515f183e75730c0f042c4bc3de0a229e8ee836ba0822904c0592e18c9bb3c8b33238e8a5cfaccb7dee5ab256828a9c0f4563d5993bc1035c58b44d159007f996b5d103692ba6ec6ff83175cddf2cea318efa53fdcebe4059dd70e1fdb203e9fea50703f0ea295de285d77ca633edc86845b35ab40e6c387538735a4067e880b2ae08cd2abc275d16a5a67dcf89b2ecffa4cacb6d7515f36b6e64d2f19db364a51589ddaedfafc1ddfe5ae15ad9462a5fb869b083e710dad3aa2b0bc46763b5e97891a67d1ca8a76e0f7a2f13142d6acf3c1af7ba112360cbd5b562d21db490cf8ebbbd3fee3c6919ce6fb0891795ae761ef01971dfcc6d129b6aedf50ec5a34ce57143e1ab355d1359ddaf55cea91ae166553ab0c06c6493f71646b2583444eceb16db34c65c312ec1d3d3651cd4e693933b2c6f4521fc12881a61c6f51136f219ad487eb8ceed913490e43227b21d62151565807b04457b99efd2ff8384216d68993db5e74220bcc3114795c817a5f202400700eadea0cba9133a498d1fc993564b26c01fa6f8a201ec613e104e0febe2c24f3eb753a482a279217bd7b536a285e391fb2fccc7eeb1e12ead9f082336b3456817e417fd5130c86fdcd64ec116fccea264818a2c213701136bad2c1d7b9b189097c547697981570fcef0b38b665d11d87e6bfddfe91644bbe77e7fb798211fc59be3d53d09108776e2ffde212caf058e065b7191648197494725a6212426c47578aebcb9e438ed3136db77cfb5689f58dc9ec8605b554cf52a1dd9485b1c524d77cc326d89329f7f2d1b035d9fc5183768b79e0a1dd40a6e021e12f3f04fd3620c06a1009afe7a11718dbef252c5751c36d332634e16e236e5fec6ffd085df6f5f325d075111cf513da4c7e3729b75c7a8450d6be31749944601af4e4f009ab8d2c78a1e424c46733208dc63bb47d21a2f25887b938faa3d76b074cceb45374790dc94e346894c553557b97becdcbbe8ea8aa5c338ef63fa6668fd0ca92ab375a694f89b7fddf1772c8a208c4a98e1c6728ee359af9d6fd1f1340072da04d2b9330d4b8c9864cbb29af38717682519d6b85806c764efc78d6db280358829098b0608bcc663af742f59e0a404d638391b0aba1fa154868d8b0c2c3524c50345c461d9237bb31ba7292d01ee900de3f60616176079540d8d8a0ff77906ff2ca8c09635d78ca452200dce2d648a579ef053a76119cc9f9c337c559ac95c68f5b84814c3c12a2ca7bbbf635ed70085281e79b7550089f27858c1eb9937b87e8240402422eec9df4213fa95c6f7d6abef3eb863dde736c5cdfe179e6ac2f211ef59df5d06f908b855a88e55cb70dd4d2e17994de438cd6b975d0eb842f7bc27f24b43e672a0460ee7740735227aa011ab5d7fdfd6b46e571208d3a31a6f80e59b4822ed8bd22c0210e1c10c49260926c71db249a23c6adeb9aaf95049970f22e02f3a14fc034bbc8deb843accc7d130cd51c831f7862b983de83ca56bbdbb9fd4407a9983f9fd8e6d2d4d583055843a02ac7ecd9163c057a3dd68ac0210045494df9abffe2264d9951813e9dce6f625fb276decebb98c288d633e52f4932728b6b726831897d08c6b71666dfcc6444861fda344914d398dba084dc29be72bf33103211588215c64275c43c99f3a6e06bb6ee713f45b0ad584ed5d230bd82222cf1cf3b36f238a8d1454f6190df9231e12496aebd704c8c3493932891b766bd42fb6e541c8fd035e6f8128a1e444c0a3501ce49cfefe92a567365c6cd5611d98163cc7fed6539447598f3daca7e598a4741b81d917317b7d255d2600d414796dabeaa1c281271b5cee769b05c2c848603d312be910c82e66d21c95699c1444f103221057a77851dcf14bee7b31be7b11a44abd2d32143d853b721079f2bef36968faa27761f0df12189e056de30dd6a04b368ff8bbfccf1c39cefeebb488a741b49bf186166877853e9136cfe221a510a403dee234e355ddf76ef60d797de3b4865b6b57ed5334d1badd6b3bbdc7bfe4f71011009ef405681c83b7150b6483f6e451b42c0c7924ffead45acdace86e03a72b1b6c4e607305af617e5f149f72cf66953e3a060c9843b2af5340e434ea5bd0f5ac925cf128fa01c845b8641708f16682590ad5b7273af7d39fd9f30bfc85ca71dab169b595ddbdc27c01a0f4ce100c9a0ee6f27e3b2a4a58411a98309ac2d540c7992f043c0160c8e21f32cf1d09fcae8bb13c18ee6c3f2b233b3e33a6b42af1a479f969603f87beade2e037c9efeb621e528e875258dda94751d68bba5eeca12eacce2e5f4cbc7846c3cbb9cf3e77db93dfb83576a078b8f975e3472a9ec632fbeb31a42e5f59008c8b97f748984f31d7caf558f08675b665499b71768b57e789332952b39f93cdf078678dc7ea09e1a646c29ef5275dc3a4e7f378733c7689baf496c1e6d2e7b09c7f58dcbad18dd8b278db86559badf7517a5d398297bb420e68d42078703fba664c52c238c19b39714877fa3d3a6d37988b1eb7b687027a87a43295e7143c6fef6c65fbbe65af49b9b52ab5a0874e5b83d713e5de875a82cc5d70a0386d730cdcdf56a30facddce61bcff62c1870c06917f244fdf4d4c722527e155c5ede9b22a83d2b30198495fdfcfd0f0b2b5f7834129c0640848a89da7500fbbe3231ed948f1da4a348d0fcbd79b225c9c62bdc5895cf0bb6455e49d20258d7b7270f3fef09adcefa1ae7fe884e551758e77fecbd04d5499691119339c880238fe0ee0a2da51b499edf1a3e70f3a11df4dfcb07edd70e8ab9d6269e4d8ef896123ee2ca7ebd85046aac2f34a183cea135433af29dc06f6bc3f3f60a851ba4994d1f7dec2715bc16188963beceb6be73df045e87915515f57171888ac5424c4fb0e2e763d7a835bcaefc5f91d694b219494e6a66af1160f2ccaaa1bfb3d0305f5ad217f5367a0004099f826da0e4451a0d8512cf6720f0ac1917f3f8c3de5b734e8fd35478b4a2a6c39f4c272e18ac94bba8c2945ed511da69bb8cd67dfe6eb4d61b6bb5be321dcd89d9d5ef1f7c132b2e11b347ea52b0c2b948b8c317f1fa970d08364a427b43027b34b7916d85f0709dc15970a5e9311833deab12f69a2285746e5bca1aea60b0c26045400b0506e143457fece8481bb722d3fb3b379422a196e9b0cb154f77621cf4c7893f8f0bc6ee9be52ec23cf2f846652f08ca2ed54bc889fe12aaadd74076e1674e6b000596a1f0e1b47cbcd795de93f678625816997736312fb4c87ddd88b1e7252d0d7b282c297f2229229e50993e1a4f1a691119cf8871bfadfe18cc973be3f1dfd94585687d7a8c6d832ce34c0d23fe5cb7974ce013b6b626d61ee8b9a1e21959353f33a0aa9ee31c31e2d0aff1db56f7e8fb13a5f8e0ebc1dc7ecac9bf3dd5c486be0a03a7bd24d510afc3562fe8f8e2878f99b43004f981160c609eb442e72f96542401ef284efe6563e429bbb1e98c242d1b8747afb9ec7ad329b5bc697dbb9fcca054877c2219644ca08446d44ca5e9b99e468d5607d28c884d81bcd6ba3686c415cde4b9c1f430c5eba31ffd0a553004cb07003705343165c900968a8500d19b53c94a8cc083d6b07586983ca1515ffc7f6e9ec1c7f6eaa292795510d4a909d29dca50a34585bb761c166f26e25b8bfd9ee7a0ac5c54e5af9d5893ee0b5e5398327a7db1a2b685217d42b31994ac4a8b65d8996c5025454042c2ef59fa4f2b47df7115413ec13dfc20ea1b2c9895506a44bab3bc024377388ecc123cb7e17b8a775a7806f37fc822c4846924c8c709ec4c6b529388d46c61c58cd1125229909d19fde1236daef5fd38d39b5c7251f3b6cc4ba053bb513a489da6834038b219273bc4aa669c24123d541a2b1aea71313429b12eb3755bf32584efa74dc24dc8d2c267082811ff2fb9ac7a4ec59124b9d640c32fe1048d4c5c32f6e7cbc9ac5594a58977cba36f725816c03c7cfee19558d42d8870a58f935e10a26892b4a51f9f3f37fe60e19694675e76b07bb56587f58eb573039924f3b766a108e34a04d5e5fd647eac8d4bffa0cbebe28e858f24df6e84ed12bdc11e60edfcc04eb58ae0d9ccb911efbcd3db9f4307cf31df521c7bce290269b71c9920b7c631716e905c15646d6a73a75aed2861c840c42a6ccfa7144ccce17e6b80bab74eb688c0bff8fdee34b7ae93bcaaf8715274be062212870760d86c149198219646837cd3009433470542cb470f235404eb249e8a6a4042913da542a59888633fe8edf5c8e6be6650637c59b18044fb9a6525b99a12e0cd7209f8ab4eeda1279d85c99d057a1e50aded7ff19be172ee38101b08ec2b800f2a13c5aa57d36a82ebbe66610507ea4c4ee042b2e538dd3651061709542d0806e4dcf74361f376de7d105e05f6c94db67f107a3ec20fa6b60f085809169436fe962baa9ae78b6e6b1e4648b1117ab0a1c59b9797f278ec933bb4f57098fde273d6bf17e616a20bedbc483ec62e59697a9f7b510881ab55cdd2004f0623d56ff70053b204a585178b9bd7326b68835d7c06e6b8f20730363c100dd87bf8ca0961e1324ca74abf4096b185a90f503469d24b9f19a499da60138411b117ebac04812b71b104221e12846b20e61085e8f8f32f43c4f8f385eb2fdace4b40e6eaa40a7d180f94d8f9c48c326bd03b772d60f7755a942517faf1cf01360ec4d5f6250828d9e62c7dfbd4ab211005a76741a7977333355aec7cd5c9de14390aac0a53e24b6caaad85190bb7b2d212ddd7257439dbd04ff72dafee7ac449787becfd49043795a792e7885ac5244e5f411c55f4324f73b5f720571cc2ebd050eb951331dcb50143d8c27f290853007376f39452e68c07952a3ecf7117f863465db04df6035d5475070e58c461c652b490927ff1a0fb26aac2cf5c82466a51795f47d7c30c12dded09892f33c974bbbf697cf6b108a6e671b7851dc003bd69a39fa790719d5f09966e62e246974a5362c2399177b10be192e61d4856be6e3a22dce3531ef618999e600428ce7fc68f124219e1a73d4020e5ef482d27f6a75b5f87b2a16ddca617ae41df0ebffcce8f399499b993e3082b2433dbbfe0ef2ccc8d20b53f9db26c907a06c32e3c9d099dc143569b96ecbd8ca84d221d5023a2d52b7d9266d1d4801405ccffdf7c2d8443fe238d936b5faa5e07e533c901da7a80e4250addad19665c1e76bf80f90573222d739a89b7c424dca4735cd1cd192331b6f426d790059122c66c8a2ed88f8a48749322f9dc41240f82cfa2ebcd07d21d29d0036d0eab45c79beb0ea6951502f1abeb66f6367246f074f2a38190192ecfd71174f6c219744ec3fa35651c207c34526c96a717e18cdf41e72e5e4a0d1b8489461afdc47d41378a32a8b3fc11f58af7f74761166751eb82a821af7099445c80efcc4eaa2494d57cc3ce00446fc47221a777b4804f6a510c97dd05aefdfc3969ecfc6af2d16ba07958e2e78a652d27a6ddcc8902db3598ce0e6776a1ebf39a4b362c491fd3346d043f965a3a44612d7251d2f5fbd84b7722bb7534de2f6d5028e060271c4bb07e3e64fd889870d76d8bac9f2621b244c321c02ac6769e7a89fa55541822eff8166bcb1f85fd490db4b13411f987b3fcc013a3de7de0ad2a0e88674e598af199adb4714f402a4568af10663656a7f35159f2f9899c8f8770fd475efc3e17990ac2dd3d1a32927e5f7dbc22c7ca09cc09830870e66b69a59591bc4a3794732df335b4999c7873457fdabcf7f652d50b92f0866e9628e94bab70bf27ad04ae2b40f1a8cf0ebfec3db98094511c4470249c266cd92d0a3d33441d4b646869f5bbd01bc0640a3ff582e07e04458005dcf96db453d864b6c2e3650d65aa4bd45bb83d3b7f43afca66b627b4f4c836a8fb02bdcd36e3f0fec175b8e24a4837369519d672b95e1adea35d8efcc68c01951a0a850434ee2c3f9d42af86431823a5129170e7dc4650aebd637469414c4b8191917ea956706d3e4e91e98d786e20fd9f764947877bf2a2044ffe9792258b019234dae39ee4d44d24dcf49ef074c60cd2fdcb726ddebf81bc0f2a42b2ea47a1e60a9a2a6ec2285075486593fc528f5970d24aed612ae73e051d1aff58d1b0d38a59eb50a71f92ee94c3a90f308bbb47b7aa21c1cd33032f0ab31cf505c5f5f7ede645e12771fd0d4634cad4af69c6e1e77a4eb785919fb5e9d0d05163232cf46887ed83b29b16afce5a313c96c397eca082a290a2eb0186b362d053624a4753aa02198bb69372339c6839d55e3ecd748a86b0eb47aec728c6ebc6c06861231edf3a64a2da568820803e41325041881db10a79a9887927acddb6a5308494b004f367863f6394fa04696f8ca34bc668400c023240e4bfd7f91ad2b158916c7b3f560d9657694186a69fed94349c550149d60d9973256ecbaf31e30ff6c260578bc4de6eca88dd7603e515d3ca54145ab6e5545aeed5022e4409946bd1d0ecfed46350ab5a5819bede0b693a201b4bcd685474e56e27b0646daef239a246933307162d7763220ee1610eba93fcc5ecb28f5995b832bf8243b66580d1d4edbc85d4d139d256156e6d4b212ef53aa72c20049b3225fa88dac674a6608f31c499662ee6a53296d7fd9c30dbbbf993ff4ffe5ad96824d65d4253745c3765d7f98c95e8454e5122b8851cfbdcaecc6d6d7a9a307c46fea0057391b0d2921dd985dcc094aa6914d6d313823a4efb9ea83f1c0d259aa85d9a692d88f5c4248a05d6b0f1d83fe4c3d985c09cd7021170452231c538ead359c57cb105c9ceabb59c64703aae2db1ecd4c5d3718e07cfdfca9b259abff6a5fea1d0a9e4f17e23a012757f4cf94f4a696913db512264d475b4c48247b0a2e990136fa071d1e88b93922bbbfcc0c16fafd133e960d8bcc81a5535126a3c5b0193cbf44e3cea1b19bc512920ee3c9b96a0bcda70378ab5bbec672ea7f57a73d205560f75ebdb755a19b53f9ad7476119ddfae7630c2e5cad2f1d39bbfa122ed54ddda165363c18c7116eec97cd62665d50c8ab24daa9ecd08bde00f457ca6933dc27bd4e65cda9d6da504582ea69085b6eeae994a648e4baf9450ff571174fb8eef32250a7785790fc9aac37279d620397c09e40ae6f45e2bd521b1dde3c825b0ee2121e07c169616598a06369c71e50b90283a837e4505820e62fe3f4cd6e8810adda0d64817528940eac5c987981ec0e9b3b7bb167041db4300eb88fa66d2f3ae9ce4394bffece7575c02b34b250eb167cf13b7dc0411fa8ccd388b26f2fb5b9b000de8a03103dbd04f8c163c5652e0e749d0829536ede93f3fd60914238d082f9eabecc510a06da0507f258283afe7f72773d9c5013b02b784ae8abf45dd1fd94d4f2677da97df75e6c8a6ad481f40060240291b37a944279567be751c6763c159fe376f699ad076e81d7e5dedcba107f07c9c17bd3eda74fe138b5ce972e7489fcb65867735d65bbb1814872bd39076dfdb4965e4ec349277aabecc7abb994b37a88277143e3037cdef7e1b32a02efcc8906fe05e1691ef3616f7bf03a1700a529bb391ebd54acfb21bda86851f5ca072b7154831eae01f22f5d3cdecba37d562826783015981333e9af2f6d71dac03098c02e49ccea76df1cbd9292ac33db49795032916ff806d3ea60037105ea50b67f46860f4005b324c3eefb2abd900d5d92659e2cb3c36e751e8252e356cceedc0a296e22731737be63a7ef3860908b7862048b6ce1d15529d9c91dda30846e2e8c85f07f60ef6020fa7732a0a6cbb67d57955abb0aca81282f778723cfc59afe60b8656704748370f714b1e9cf0d54962d1108faa6c89812eacc7a9a7ed3dacff3fee90ae2b76058f578336d32d086f4f962c252d7b27803f811211ad1967ffe20e141a6426516bbe6e708120ac126a8e0ca0bb56909abd2a0122c283baeef2821b4f34c646a580e7bb987aa55adda2a22d6539f394500a958453ba798b4ab65054c50080996dd17694b40f19972fc8a66e32b422068dcf962f6aeeefddff09ac35b3fa1008cec9b2b63204c5f18e18a2f34cb569c3e68a8e764f9be0263e18243ab35ad82480223986a17e5527308093e2e3e37568922caf11262bc82df256cfbb9bc5e26250a29ca6e6fed94c0d01c51c58be1be111fc6564fe3f451bacd29a0451f9289c4c0a6518fb83dfb437ec198c7cf4772581a38c98db6aa4aa1aa8693c0f2979f318431381ea7eb48e48596eb8dfc6d811b18eff36e27cf1b23aa814a67d022f4c4c608670ae119ec69fe87667a754989965037160ee104c30d1136120ae195e01429ff0902f43a759577848dee1d0c04bad93019bb0e16dfc1ccc05cdf501c1ba03fec174354ca4774d5fb56efbf63a5d7b226e95b30032a6bd66adb88f3aa3f8c4c8801c824726c98da26056631f109498766f6cfda1e28152eb44c5564a21c9fee4498418b9658ba5fdbe66cb2299d59d8e65518e48be695c99d057eec2b936c152cabf2fe68a056782cdf66ccdf5f2bfcd1aebc6d93717f5e6a177e100d672ebcf6ad5e81b6adf6361776e38d1ff68261204d9af04a5fcf09a1c95e2b92c80db543f7402c70d4896b16855b265e5175207e18d816db01ff5d6a0595449a02b62cb1d8d41d5b20320570a07900ae5a1717aa73fd206f4b5c2c873b250b2b194f53c85b3eaa26a04135817c425b69e6674e75270ad4413afdda868a620f5c66b678d89deddfc511ee314c1b07fd1733b047169ccf7dd3ce475fc260158968255e9e7975bd08d9e098157c381ab23fb5d4eb4a3563b0927f246b718630c21d37ca876f1e3abcb470862f484f42be3546dbe391a66b92a9772c0fc3a292524c37110352f3cbb015d876e7ee16afaa90c96c9c12fb4ed5fb1429986990b35291146439f084e9ec73dac091cd5a7c4efbe3e676bc197f18380ba60b53d3827de8f36600f3654f7767a635603eb2fda666d1bc62a2f848811d0bbec2d780ac820847233c01be807960925131eeb4527001e0ca7727d378482cf8a5083f2771d833c1a4f6f0ba0375417d69098be611a937cbf27e0144f2b9dc14dcea512463f7baa7528524141437a2d07ad293e26d1d3c4aa7c0c0ab1db54db14486f871b3a0ecdf72c436bdd97d677959a1f3229f6f35df24b9ab3bd4c92a181dec826155540a237979c6ce2a1f53cd537b55dbdd5616716d0df20235758919aa7447c143a196dedf051dec097a82c31a48f35d58cc5f48379d25d031b1991e16d6be0dd7a727d6fab5d5416c3396fe84faa49b3617e51cee44f208c0bc49a30acbefd81e5b496f30df153c0f30c7b7bd52f6d5e4448a09b5b5ad31f6ee236a6c918ea5c120f33db9c954ae6f3af90d17de7ffeecd46d2faa7d0d5d2b9d76a54bef7a441332d6800755a3a3ffff8821ee1f68ee5f97f9d517707f26adc1bf50a525f2a289861035478c30ad857e1e260ca5a9ba66570647947000bedafdf7376ee57099ef71cb88d2c2227ab52176b94c62d6216072cf93c5dd5a727af5e138c1a5484c8a08ff0b7c66a02d1a8d8609c1193a3e0f517a5d7e14e72194e5a0cfc3b705e980097c854c6ab7a7f1e063f50efefcb5743f310aab9cb4b3a0c09da6daf2befcf699b623690ea17c8f8314eb7d97458996b2d5a8acecf16ad0ac1688c4ec8c94c4b9353e1187ed22110149072530d7ba1699fdbd398ca7dcadb8305a7b1c0fd692e153d27fe2fbc7faf0036ab9ec53f3e0f319c0e78c819ffa33618d38107fc0c53bafa771ab836c10b189ff8da9b15780fbb463efd9c356d368b4ef3dfc6f21db8d610e9c37ee50101568e41ab5f8a6268b9a04668517ec116819bcd8892749143665bddc98f07a5441406354ae6138a93d0759968486f9f70731c3498b81a0a0397fb2dda620a1c167db5f9ffc50dce857d4b1361593621231944d8d9c00c3afc88df48180a939899f5115f21b26221bb1604b4b4e6203428e593f5589aaf4817377f900fe856bca20b0639fd7b2725f6cfdb151764b1ea5cfc3e6102a54f739a8447097b0815a820ed709826fb64eed5f8d862c812195bb2e394740bc8d47eb6b62c08a94686e1b19e859c1e3b449cf72f6b63dd9a23e93774ecb5fa49311099d80cf11606f134832d43bf8395effdd15a77fd5b85e7a850cf93d7a7572419f8183f0da60af5a7be086b6ee8f8127ca362b0654cfee9582d6f16d0c2b7303bcbc0c9e4146d2acdfe99ee42b48fb6d195cf33bceec0b5a97408e759be19352508b589bdc5d18dd2cd68c6517608c99e6770d59ae727a885ab9f05e1956f0c324a5ff9102d555f1f161c37ab41b33f42fcb66183a2ed54c16681f8340fb42f1229d7906e0ff105a1adddfa3a91489b5dc12887185f543ce9ddd1b8b2cb704f56eca794f2d6cae0496b483fb692b675acbd4297a06baa3b770c583e78ea0df39b8d02c12966e87d197f14b21992cf2ea910e452b8b563e1f71fc075d92a9331943eb51e76bfc7be6d68a20d33636531d21f01b0eddb012785285988b7709a726","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
