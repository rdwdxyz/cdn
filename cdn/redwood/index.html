<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc477b3ea279c6b4f2a0462f944dee3161f6526621c5f0a7846dc1a8cd03e9975c262b994295e81ba69dfce535be5984c6980a3cd8426c554992fdad00cd26a4b011e0c7c09c8e0d00e187946a9be4875bba7418386ebe1dc0ae5e92882441a0d202bfad1f945e6ab339f44771119523f195123a2167f724f181ac902b3d736f30901ce95f15110acd38d4a21d2589613230670913b65b2fcf3c6712e7b4b9ccbe17f6c030d40488b831502cfddef9b1fc1193f608d2b582ecd3718533475b52aa3c9d2a61ece2b14a96be5b231a3c642dc05ac04e4749e72b33cf5636ce91059b8ca22fb4066f7ed450e9034d3a189c75a4ae89efa6c4299865cd4d4a4cc471caf9f7f9f5309e7d4ed04e166c88af305cb94571873ec82879b3ecca8627b9c3eaae0577fc8106135054f2ff409debd3d6d4ed48e8db98107262bf1a340a3fb2b2dcb2586dc8cef84c4bfbd62ba07d79d580ee095f4a8df0f00f7c1d08e7d108e5877c81dfe1fd787c5595fb13439a7bb56a0eef06bbc1bb0b211959dd5a78384a4c4ce9794f747a065cd7fa187fc423057818a6a824180e83a51bef9c443a502d84643726d38c83638c041cc22a29170df8ac3f7c35ef54942c151499e171c64a57699ac4bd3a67e84914cda37062f12539321705b7acb2a465963154706767ef7dddcf9fa1008d10d02c84fe55ab3adb759ce1fe63b44a97167d5a38167662adce872d762e1d3b35b735b729647cb1f9fb3a3e79f4de2dae99f91b3e6c63617d434018b35239c0f5341f7cd1ba129aeef23d8d5e7ef2fcaeba104368360a890dc071e565865c4c76798881f5eb091a52c0b6083d2446996b5cedf2c932c047481c6b168b6fee293528c10b64b8f232b4d50c9a2787f7bcc6bd0ee6af1550b87a1feee95cbaa21055fb59c6de339505bcbb8590b253d3a7b422cdbd6b1445d1a2b0dddab7fc51f46089920831bd6e64c618b071a08f6ba7cd9fdd3941dcc4f5d23c5d38476ec150533a99df7c30269ce4554010278b191e93f639c2c354a199bd89d990ef3f5c26e50c07149cebfc1e37b34c1f18f29e7feab6260d63cc7f4c930ed7b52e4c4de2b067680a06a8a96f74eb2c936aef6a6bf829d74d2b0341e3c771f5a5d8553ccf95d2cb8e61a216e4569698a56905849791af68bd1a372230310f9e6b661ec15b39bd60bf568c1cba459e055076e4ed882e0df9e87010f54a9e4542ca46c7be4aff71c5c30922fd1068e1b117439df5f7f981298b3386187ae73ca946622199051c94da6b401d4cee6c13c5e49565c6b5a91a4fe07412d63c41db4c92051ef3790d0a2d3043ed4b8a875f3324911fc408c349bf0e01bf17e2b320af1312ea5d13dd473425716b120a9f76a86b3d69b698c711557de2dc8d3abc2e66d2777b3a11da7c4b73963deb36bf7b4db8149afab802aaf86373aa0b78b85b72da3df63a9805f339792678d2757d3933a104f38c39f2e0af29b5bce07ab785fd02168fd435ad00a1b3f56d37b868189858951fbdcd6ae39750b8616702035b91001c5dd6460f2611d00dbdd7abc1b7aa0272832a9cd9b203263e561ce7e1dbf0f8f99ac6415a7e97efc6ea5391e69a108ee94fa3e34799f23e572a3808f094b2563327b82a197575a28e946cc2f3ada0feb12618012c584e663af32d702fdcca8c6003424bf941fc553aa2d9baa11a3d303c1a59a76db59b9a8d7b11351d21b3ecb1713965841b649c72847b4274f54ef18d82e0ac9f8c603c76dac025969c7ad3ff05fc5ef70c6d43df8fe242c8b498f92bcb6b4eae109b56c27bfaf24bf5386fda5de0ca900d0fcd1ad83978122a63115959e89f734cdad1aa3934ac9f6e27aaf1e212cdc2ffaa2e466f9b3bfe612ed313935cb7b3f110a52b3200371e39802299f7399a81dcfc383c962a7cf2136e8b62a1dbdd41a576fe95d461f2a2525b2e3b245048be823431756cc78bc48f86307c1444de736eac14442f1066154e2d2e29740beca1f45c359eb897dad0177c8ee2aac4240e1cd46cb4f78b341131be65ca3e8c8a1d2613c4dbca93de17d20ddd100ff44477ea93146961127b79a70a28cd086363a29bf23f4455d2e76de740a358b789655d206f3b1eba7d64671d04ffa02d7f558e224821e94989d8ea00b3ec0bbb305f0a56b685a42d350346bff75884972d142ee9d50001443de05664774dab2e7ef0076bc9ea1e414ec7745298c834b804bf8c64d6ec6f589cd77e89d515c08f50c0a9216fb97f356237ed91b5983a5f875e38931c7bd69398bd0667787872779332a4ed11259a2faae0961aee0184c644190ae5ef37e2fd942a4815f88b92662f6fadcffd08d058862462e09e6b5246a2270decaaccc0786c848ef054b2e282ae39981f3b6455333cd9a301b29ae74942264bf7e3fe9244114c1e4a434fcb29e85271c898bf8c92db4ef9765a30e9a06086e41ac77baf078578177eaf938258653af8f84c9f488c7bd1429b6971f2abdbd9f4c35091c974ad243a6cfd8069e86b22db4ffe4fd33309cfb8392f3653d681c1ea5ef826366afa47f3e0d563fab77c8f6f57d3859b77839ead7288035679ed74f2d8c99ce4dddc3d61cc0fa833973a0e6e31b7bcbea2a73f7ef8cd076dd591b61ee3eca85b741a920425fbf6c4b595438988106ab4f3c0cff40c41723d045372a13e7b5c5e59f277bd0c07f7ea95be325a0bd98fd8553a4c93cd6bd4aac3768592a2838f29ddae095185652278b5f5b3938c7f92776425b34d2ccf427ce6bff26a7623fef06c260ecb1d3a4c7249f3997bc5f93ad7e658c70f037dbe1ac7cce5473cd337406867f4c82d34b5c75c3847e44a67bac9d464d698547cf508bbbb794d885715f25867c0b0d36f7c12031a2239f04e77112e2c72850169e4f6db140f4542508658fa93e4d3f8f8b7cd14bac85b410e591d1aeb962941974949f466dd60a084c5d578eb54728b75c0a4e7e5b0a50b9352babc1ebf6e7f0a79b0befdfe6ef4b108f1b418a99b74a34d21bc8ea99b1a1a8e6af097bbbb1f3aea2b9306d412829b55dd332b0393c225b44d86da6fa383aabd0fbf56429b1d59ee0c98cd64dbd810ce532da30e8e89f8720d822d9711a24b0607ed141e48073bee8ae27c95959758ab6f62cc85292a274838075ad46ee7d1f394cea9d3f5135712d64513dfa19eb081edc72e142e8be209b2f6d6f67b0327bbef6d4667e18c7b230b21e8ac4dc46d23192a752357ec3b4045c024cfcdd83fa80ae591a0489678d86a0ed91deac575f961e8a8c7cf40367f73c9d7b9dca76ad89d02ea6034fa7c77cf208d830af4005e1f93b044c3c56833ed1f24a50e85c719ab0517f355f8bb0f6219b980887d04811a2a59487e76a6e91a685786e885ba3411d0302fda6d513d3afe0884d0160b8bd23e9c6df1917ca76aed59222868e233f45319155b2b23a25eff6a825532ec882b19a92464ed5083122d5048019eda9226ae0fa61fad3230ead9268ceb623d7e7ed09621cca2274e9c2f840f6158f0eaf8412ed47ff80530561de880e3c1348187652aa10a4f8410441628e7325def2577b4d4a1f98bfe2dbee98a38d063eae2ce9ba4cb1a1972964df2dc5727d7216a20b5cb8aa7ad7507fabad3800b654b6ca844361c45b9b33d3e04401d18be19159a3963beaac2fb1ade141073351440d205675a061bb11aa59e27cff8d74859bb3ab11702fd745e299ec3e542ee03875ba8c07dd6c47299ce2290a0152bb7f9788f24b9adfc2b7b68cd79f53f57feae418794c440245e06f912f9b22e04707d4d0f08511370199eccdae15bd4ac561fd317548cbd36d0865b9e9e43910ede2084943f69f7b50f361cdf671ccfda40833f3255702e41c144155773b5a3b3b325c37012ceeb8373e665caef72363e07170012d3cabf4963f41f60b058517663b1d356950c0dd6b6c93ea92bccb1d6f7835c22f4d17fb732783e51f48ff066f907158a9a231fa2d191d185001bea532b1325a50b3b5ece7a7e5448e393718138c8c00656c685c357ee624aec098f86458d5b19f4266f4c9f93b5339348a0edab208da13835bf4b989fa660aacdc6eec84fdf7138cb0a3048a061cf008da7613df5190cd4c17cfa189c2512cfce72b2fc26283982e677cd6e5d674ae19668b778ae19d1792939bc7f293c948e391de18d085782d2441830b269603ad8137dd992d175e553a3770fe3fc3662e4596683abc7c11819e6a6b52155a26935861b6834721e113afeab923f20e5e6000c15ce6bec29de8730e0f31a38a66901d63cee748fc938aad487d28034a00128bd42a2935f5ff1570be13c0b1fecaf55f3e0326b4c5f7322e7389b8e348f3640dfedb94d1e4afe240a28d1dca85f1002389c12f1c23c8c0719139c8d84d2a983445df210095114fe8d85a21189df8a64f6882807a22e2bde8cb4d7c495eba272149477c044333b54d78cb25b923d95b9d3922142016cf2dd5a11edd20bac87ef724080c0887366699586ce9df41882dff89859c3ccf520129190b38b9acc4f5af9eb3cf2af0843eacb339d0c8a9b5d20f756e8174ae8387078dc22157f9b1ac9e9f86d0bc3b0116316e8e7fc1ec9ce92b360bc3a9e3aa20de7688f6705dda8db27464eed8943c7dae8da73e15178790190f69d7b9f76cc4402cf108648eb8d4bdc5d5ec1dc9fb9b0238063ddce82469507eb4f774fda88d49e5a28bb8ff298fbf20731dcd820a8fa481dff5b69be584d6cbc1c3e77077ce227ca41d9035644c24847608b63eac3f94182359d19d7fa0785a2399f9b4e4e62ad50efa0f787cc6b18cd16345a488e1fe5b0a4ed2137344fe1b0e69df33a7086b8c31fe49672faa3d96752165bb1b13212b7148a95710311dd710b341031da73f0ac1fa237192f437e7c876ac88898d836c3b0047f5cc2e087d278912c5fcb4041517401b6ffaebbe72c89765855cc4d4470ad4200e4469b8a6c8540a1147d98904e1a6a8392c5d323732057156439758ca28ff60941557740834e1ee6821df6d75dcaad124f274547229a2ebb0a1cb94d1fbf2341b9a9ef2f8150941e72647006fd6e31698aef1b72475c147b4904eb6409cb749f7226fd6cf789409705ae34c214c50d1481f460ab163f6cd5d7e6859fec2949f49463dd5498498665f1f20f9d026f4e420b31b2515f147d1e38d3c14922f453104e53f46d37e1402360bedd33b65bec8eee12d873a06ceb40a25c5963ce0bca464c0d4acd5b86a37acfbe9591da5e6abf67fa48d600128f351a3fae9e7ef6fbc5adf92390107cbee2dd7ccebf3c8bec2ec122b359637d2071481161e40245dda3e9b0e469ab1a76182e02427b81cebba1e8611b16cdfb010628fbcf0bc5dbf43f808cbe50d42dd213cb998fc459a6ac92473a09045a5da205a02cd750141aee2553355fef9a025934a72f2fc9d02be70aae649fc5bb82d0625cbfc3195ccc604525e38eb5c0b2df27b34a4781de1456a72089bd6eebdf12c328df7433e673a97fd9ce732578b90dc811e20cac870e059c76050628a6123f44deac8d18d0b957e07009ff8cfe85f5d257d3192e4feec0b66d1c6089f874ca011b88510bfa62dca7850ede7e1758318079e1e1b5fe8e043d77317d4db8922054b5ef405fdf074f602561e2a9e08e2cf97c1b10c3fbfc6e0a1224a9200c3713918d8d2b3eae521995df625b057012b8da8da6f6c7f8e6eb9a4ad178824ba789871474f09914943708dd66887f154575bd63c05ecb01d94f44bbc5a958ed66f54aa072870e510126bd670fc450d00e7e209aaa55987fbfc3421bb10ed8d900faf6f8f2e995c5a29acd953bbf3aa2c39b0d1c13d014412799e5c9b13e39970e44cb95330d82052b5a57248048ddafc21916fce2d2703b8d7a771e04ee1543ab16919a1a456cced2c3af835e47e5fa2cd531bd69c383fb9c8099dc9ab9d871e74dfd36349405c1de8a26d674031263786a82a03103d07b04fbbadc86a80747a11b4e58b5a3823c80c7cf1f0f75a859a0b0389403ac419eda66b579fb1b2702af40dbc690660e5bba0214af1fcd292c7065e2af77f50c1b12367810b9de4c7316dc930e92445109c159107f6c02acf8a1e6082ed10635a39b0df8eaef74d0eda58201347d8241b7121b5a21e968acd9fafb83215baf76e30c87a66308cc401dc3e49117cb078487800f883957d7ec0b31a10b0e3f89d79bcc3a0c617c567f6b84eb2f236967481a5e46c45bac1bc2f6bfd92094466b56590ecd10ee95f012cfe82dce6af6d5b0fb15cd9f7b8a30ac69fcfdc0c23d58abbef4460ab075150fc6aa10bf6516b760317871fabc258cbabd6e7c252cf20ac8f5fe8a394248245903d3c4980d9d830aaaf2fc0e8a13cf9c83e041937430c8701bae7a1b4daf8e21047646399da08dfe91dff404a7f7124dc96f6e4ea8d43cd66b6ffd557c12a9a7a961df2800715f8463157194f0cb31df93fb78ba7a74e76a98abebca0a38089b54c987b06f8a4f76519a374b19575ca3e203457c3014fc7923de8cd847bee514b1f9716b83ddadee57f386ed56e974b8f4cb336852412c030b07538ff99dd9a246765c0dddd143a2ffd111ff0acd08218c1020565d2f899bf95235b2d7c19461a83eb4e026c1fcc92afb55da909929916f3edc9b2bea93d72cfa37016eb9694f04705717112dfdfb0fc2c0d55710b6957f70b08218e06439ad6aa9ed2a0fc4ea50a7e4ffae2f6575871fa452393bcafab61118b21a2033c58e768218528c45beb279557dd3536e582a892fa5fa76581248edcc2075cfedc9d0f3b6c0d305ac7c18f1944ef318b54cd38a229c96645aa2bdea14822add141b495138d0e59e015207b2bce1519b25157aa8865a370645d813a0940187142fd82d7eb310b8ced548c3209fb0eb673cc87ec910da8505cf6485bba6e0b2f5dda33a26ef15b58d265cfedb7a54fba49d204e93df5bacc4541c55d475cf105614f6449774bf07521b54783bf486c3d34ac9a3141fb8d8456e863a6008aed5c10805f4c426328d574afb1265f536f8f9ccd099804743a178f0edd77737a87f2f806cf6914122349d9b2cbfd79b421280b9c83a4698a0ab4a30fe0318a811edf01a53ee09f2aa1c54183e799456395403f89a3870addf535c0986c9bd91f801b5101d8e8ec1f97f133bf7cd635bb478ac3c7c2c1fe4e451d9b33aed81af7888c31bbb12fe148613beee38df764a9d34a5d2f20b6cc396a578fa2475b4736d7d6dd6552c061aa745fcafc35c26c923d929f39febba11cce2993b842d5050d5c0369906d5deac8631cb87d11dfc955b721262a04c99612675abdcc2bcdb4a2d8ac1daf1f8db31c88f4022fc6a938d9242ad5e579bd81efb26eabc2a7a83a9ea5051581dc882e92f02e0e273d9d309bc2394c0083ce2f2b3f0f7392799f02098846753b8f77790265efd10e6efea52bad173c6faa183df947a8088e7799e4b4f8f893d0be36e9b2d7a1d43358ade9b1833347f6b1085679845c3d878d9e901fa8879ae4117e2af9264d5f7429df2647c9c25faa1f2c59b456128ccc38a1cb7e65eee06c0d6cf87f4654f35fe5044d1d5da6a101c44f742284f018ceea5abb4e9732059ad0c14fb4676b1602a8e827d7478f38c10b5b963775bb58c73ddde6218e85d77d9fcb8f517fcf2a8d8fe8a70aab2d98c423c1ff89a665117226cef9e5cc87754813e8942f5858e521991c787dba4f0bbb1441677e9a78e5b663cba6f63a6d50bd39f8f8e53463efc05b7068d926457d4076d18219db4db3a87af72be87789aa521d30ed43005cb7823776fa692bfcf9bc8a0d00f3189b1db5bd8e149175732e20bf9ceb2226cc22a21a97f032e105f6aab555bb0647b0eb355352cd62140f40b6ccb8b667e92f04a4b682072b39b681d7dd63703728413adda0f82599c2880ac580503c11ada2cb3e2dc69da60559966e7bb069c94cd0d992f312895066692672ae1f57bd96af2ad82e80d7c8e281e3b0802a75d754ba015e81c785df031ec07d2f9ad3327987a038f6aa3f43d4b0d77e972f835f56a4a8ce051384a20c3291c793574a0981d816005c37456cde2a7bd72cc96e3e4516cde9eb1b410eddd3f3fd2ca45130a119df140b648c026520c141ba550c6a3f79ccce84bd60118d1c51240f82ddbc70d8c468ace1db383f1ffa4a5824f353a30d83d3629608010908158d0be1703c58d51057cc54f704095a8e4ea382a14bdb8d7c81bd8ed0d3ebc8fde21bf9c457f3dc3bc8da9c3e5c2f736ba52d2e1762596610b12dc4da17580b915010bc6a5713c13413241d7c364009eff542e190363ca5d7c4eae887c64dcac649f2139bf50e287b308e45f5f9138046b6016f27331d0836bb17fb12d0d8d023e950819ac8c9c6b1ff5332842c17a53ee3bc34cd1a9ca2c91fd58a551c5557cfef4d05ed87fc01c4fedf29394709377d61e632d7241cbc6abb761950eb7bbb944b292461be354d4aab6ee67a4f34e74bb8a9c9c8ecbff2d735f3c01ca7dd2b459413699fabebaf891aed4d6b835b9008fd0af60a54e817fe90d37d34c1681039ec5b5e226eb4c54a685bfa47e7f1714a77906a14a0be763ea76f563a008746386a24e206097d8750a329d8f992f13398013c3d485ac82cebaaa50ea33aea97c405f89afa43faa5e7e60364a6a77834ae7718d45a1c8bc62b49cc97b3032392d26c3906b56b1125c509b43ca58b636b3d0146f343c8f3c8e9b461ac72e52e63e593fa28e5d82f59f45575a29e3b168645f24fc389e7e85315bbf2cc75822ac13ef4c6da699195a2ec57aff9976e69e614071a4f0101df916fe59111c777522d65cd5f8f0bbd5c979f55888db4ce1da7b19a288f9479d9f2782d213cc69cd439c9aa910fe302ce4f6cc0006ab467d85d3f8428ce7b78595f23f60028584b6e4aeb66e49fd02fe52ac060248d7eb64956c117f51f9df803360eddc29826c8f7bf0e8a359cb156156b824112dfd6496675ffab5fd4fb0bfffc5404fca74c6e40873e35ac6b769b545ea2eec28a2efcf474a86f4892649f6d6e8423633c6248fad955e05c0b60e002cef2be59ef88f74323eec13d86d18eac1a1c00286471ce595d37a95433a3671550cceac932ed6b8507616f6cc896a341e8d7e193c60f61df782f072a1c3d58f5282a89e761c8a0daeac71b0005039efc36f2d1b126f1241b602e9c951eb544e98d88a628882bcd5c5ef8776f8e46878372dbb8a497f35d0fe6d06d1445823778d7d574cfb3876e1e562f8d480a6d6d4566f87c0e0a4f2f6ddb83d0d13d4b88f220504a6a92ff57beae048359d44c97d11920ed585130115a1478a1134566be5aa0d78d941ed67b596aa83952a3b474e47ef5b54a464279f2bea597ffad24ff268f21aac8b1d05e1c771b92459d312beaebbf287f9a3b4b8519309b306052abf558fbc625a2c3db140933c8d06d4d175246f3b0b72fc0b4c95f34beefbb007434ce9f0a56cf2a34359941777d0bc6fac830caea9dc777ede599fe401040bd12e2fcbed8fc3134935a658cbb343bc9f20e1661bf9965feb43980132a99e3f14164b777547a9bcff17d626ec041ef3a150ce5cc5ce8bd5b4eddbbd91ea03634dbfdb364c2447e490a3246248d83d85d5fb9e9d72fb4eac29d445440c8abe30b2c75be7a237b7417fa37145f5debf10178b2b1f166e78a5ab33672cb713afb886ee59b34392d99fea34915dadcc718caacb759be654d823bb48e4b6adb45da815de9963b3778120ca1ee224ddbb2c9989fecd6cfb40ad71cfce01d5c56fca381f66792b56f0c553c93d460c6ae3a8038716ec1d1f3c178b73ae570dbeb8b8519590e86113dea20cefca2c357c28cae4a17695eca80dc709ba89cdf9a7af347581c29fb5bfb3309ff99fffb7713fbcf1ea88cb008f8e22c080da40ab88d24b30defdeb960b20ed8de5a716bddefa631cd6c7b531f2102fd3577b34c717d8f89dfcfcad5ce4b7c3cb90006c122dbe7bc8b09fc5688efe6249be85188c43bb8bc4b9d9ee7b407c02cb5be939937338b579969fd272b9bbf881b1c8ce917f74440d566313d630a9179aa0b41bfe0b5f23315ee2debf9b26f200bc9139e9ce9cc175e4d808bd8937011af14ee63eee280d5b5e2e1df88308023aee2946b26197b19cff9bf4a83c9dd8b6e3686e07e220e1c0076952c2fadb069a1a37b56a8232e70c0d6afa3160e67a3a79164f3152fce716763c086b9a03cb1dcdda8710ff94292fa4aad5fc5516cf0566555f671d3d2ddf52687ed6c201cd35fdf9bbf710bae3324535f6334e1a31178f9d69af00eccb2996075bc5c4bf1517faba061b4f156ae541f57c61026d981125f56fa4be27ffd571ef7cec98f37cb53ab1ffd3d06ca5f7f18277125b73630da6e2de16ea2a7a0a304de6192aecd62857b3efb8f09ec763f1e6f6c3201b5c2752121c83320556eda0c48430919e1ca52163ec79abe7cf76d2f369497f6688cdc084a40bb6facdfdd1477c3818440460c0f2323098c9be8da648cbaf37cc8d8fef2075d0c6285de5e0539c451e62c9afa089a00a4ea3f69e70bdb787f5c79f0a58e4efdecbd4a376faaa23a09845c4e6287346206d213c9d4be7b43ba260ab83bfebcf3f38044de14a34247c38efa062d608e6caa6d2f8929c9205d9f8384162e31e2f6b99b3e0e3ac1d06b0df764b6647c7e1832a5ef7188a8c61af113dcc883b1094e11f6ea5f4f68ba04e9b9bdb3979d9509a153fb0b12ef4721cdf8574f7d87475d58437ca45e50cecfef7e21f785a4b68d1f4db638ad38e467a65b41006edeb929f29d31eea0d7c7f5634f0a841c77362017b807f241912d3c0a24b9cf2811a610a69e277f04fcf832c487b82c4c9f552d44c05f2fd684bc6cd31a87304ff97e6dd7e25ff69afd98c12a8727cbd992d185dca38a6a8f8f2417d32f6caf68024df997d8fb704f8cb6c629a89b8da84eea351b920130f4c1c36c2f86db63ffdcfd642bb46f605f25fc38633f47129ba0e874f425a02c05954e8401d84aedc68f788cf320238732b318f19297ed7805f03bbc001868074f93313f23860693e4873faed3eabf5804df30e19502e82e1e7dd37ea46fc3d481b8f85cf63da16399b461cba5d66493d45f2ab50657f13aa79c74ee73440653c9457984f73881596743f31c85accf0a128d277ba437bfdae3d19ce1a19607753cd79ecd4308e0be21fca8fadc59afd7b716b7cd4386c399ad705a5be041dd5b5e72bef2da7505a30dfa82ff046659e7b9e481b6cf71043c3f234d8dd9d07cce2616288c9de67ca42c9ea755c48cf5c080ad4e170163d1fbbad19a544cbfa1ec90e3969087705f6b7b39304deefca978c2ca5d671038c3ec4e9cd3bafbd89b614a96df1355c3ffdabc45025415dc842eba6a0b1e7a6fc3befda87bf965d8ac908cbeb293c2e1dc8e6ad833a79de81b8c557af76df5a523888fbfa602f12c17c813d352cda1e9ef86a3a5392fabbf1b518a5aac13225fbc847715803158fee8915e2f28063e7fd40b56032f8e71bb996bb6ec1a415dd7b97ca8da4a9c38fe817350681ae00609b6d2d5fce4ec1e5c6138a9666f2ed0b738d1d8ab6529c94088d1f83062d88aa5963c819259d8a18ce3984cbe000017c95c20c8da6705cc53a039f82983277dddb1958da374bdad5509ddc28b8a504dd0223e338593c4a368fa8c524ae2520176e09e2ddac38e4c3f81f842c9d7369c62e78878fa59eb3485e0d99ddbd82133e40275bad14ac50576b508ead3dde7a50fc6671eba090c82831d93198d8676547bd8905cb947b422a77b8f9e5fdf9b5d438920b0125b2046b11422ee81fae004fc516ddb9d29f23765518a4427f38530b2f344e7fa48ddf3156ad03cec5853e68c7895beee11ff3d1ef58f4535af596ad2afe51c7796a7cc924bcf6a2d2f1edab25ec8ca74d41d27d03215c7935351eaba6f87c4b52e7d1448dc56df48fcb704687ce36e9a665647d6a2b3538abd2c497ee1f373146cdf55c227c6cd663af68068e624d9d08b20a936ee7af4f22f99bc106961f3b1d76f98366b3d73877ebccb89c5f2ba5c756cf5b60eeb895fd11089d829a2f62485d5beec446614890a6e56a95b5efd512389b18627df533ef5cf5cd22b54f2a54665db0a58394f2407a2da63e695e8f901d24785f0facf416d6a62fccaf6887e1d0dfb2c7f8c7b686d641569ea86ac55f75a895f9e4a65933c9999a777d6362358a8bd16293389bef4ba1470c7cc6ba8154793b0ba12961d8ef0aed684f6c1c0226476149faf838860ad206d00583dd03f884c692862337d2f5a44fc2ce503b4c4cb74da1be521773b890cd8bac2626b93b3545fd782b98ea5421137abce394c38ec271dbdd536fccb6a898e7f981013cca3a59894fb2bf4ba91b5a751ea003b742d4d63f335fd3bf0030613d32e53440ceb58b41b11e899022a961f0c9c5b6abc6f951a1263bdffb534923c85a734be066353f073749265005af1e4cfcb7728ad37ce22e3607426955616381ef66d94cba8918ff1b4c2e869e80dec0f8cced7e90c4883dcd66ed4d18b454e9e58073d8ccdf53637e1558cb0f79905edb82a81f91a5a6b37ea6f98cc55bef637e988cf4ca4835eeec0f33d50111392f64b66af3d459c08c4e539431ff7ac4d40aeb144de48b53fae79b4c68979943a4cc19eb1f7e356a826a8fe648c19145d2acf76a988cf112032ce6f5a48e1fda9bbde91913f82a0e69cd6fc2c87a10d2343578fb380bae4ca02efa6ecabb182898cb5c2e1df35d6b689c9a46c6ec432087df33de2cb045c817bbad7a182bc254fdb441179f7eab376d0c38e1e76744f06a9bd9c39596918f6dafec38003b090ff09292b7a2fd523c6ac1a4cce18ceb1aaceeec6cf30b6b88ccf1a5db671a42fca585ef02726e37e58836a1fad5f1debc3953345e0ac7d5361d7547b790e548dbd2d1d693ad062c65f9434c7d44cfc413bd13457079618963f6afb1ae001ddef6d5068d34737b05a18efa8f8a76aa606440f62e8f0f0307cf71a2294facbcb1282b54f336f3a33b665859c1101a4d9e93ce84792ee8c7136886689ab991c57b56f06bb0f8dcea6aa30a33cb285b4510a9519eda8031839fe5dcd9e31938f3bde9354f6b8cc087aa1a45cafef9b0ea6aec16e472c6cb73dc5ab2ab1298470b19befbb3c3645a172ca7b8d6a1730ed0b428ae72dd85ec5d31ec79310143b0ac565d0e8ed5f6ca6700e66279b80654518c25add26fd0d0157c1b3b5632b52ad81b04ef01762ad8e31cf9e5818a7317f90d0d124fb402825367da665e579c54821a8a0420c039d703860625e59946f4bffd4e557c1c9b11928d872d7360301ef3a239b35e455029c7948d02df4d55b1587b9e22aa303e9269e4bd2b8dd27c58f8289834b30ec3ff1ed680ac9cc044785f43eb8828d49a4f22ef2cb114ee5c4e10b97ce1ec289edf8d1cc2ee18623e01cbb8b290bfa78e32b531cf9c15171633efd8cc7c9f701c9adc173ce3b71db12d577f9ca0529dc765823346b920e72600ec55e99d0553bfd0337a2db547fc4bb9c8a05029fcee6f72d311a941efe6544b7ab18e71a236c99534d1ecc0bff452c209d32b2de7ce1d1fbe067d961e51dc71f013243f95fbc3d303ad88bc8aaa8959d80d52064e7b8df10fde335619134ba98d9094be740fb5e7d1e6daafff1364678ddeb431a28ef754c8ab013bbbb1f92132914e267d9421246f7bf9d7bf17d66bea7edfe4a9659426dd89214e49ba6c84f5378bdc806ef435c1797297d729d8e2c640af62bb756d60dd9d580d583a43817bb829d8c72992daff49f99dc7e581ba81cf898b35af4b0386958907b345c3b7c58b7a73052e23acdcee5084a6957db558deff97c45b31430ed8d464c8ad06ea0a8521bc8d06e739ad199f5964ea3835d3794c0dd739e04f4f8038befab6af7e05bfa2d584d87bad08b7edae2a115875e108c1a1fb51590c95d71b576f67595a887b64362dcc0c34bb74b2665e0a301f4f276327f21cf9c5017ae396f3f123e648e966fbf55c699445c0b0fdb9bbea81ebc20b5bdbca0c02cefda02c5ba81293aba2173c5458222b9da243d72dff58fd75a95e1c81f461b3c314089bcb787a03f673f6e67f2116b2806fd3c1755385ea6130401d1b56e980427222df905715b6db572080dacf76b46edd31933a9951475309655f0c3fc43a93ae4ba9aea8e0a5e07be12c9927f7e059c24be230946c7cf48f857c7b3ef09ce667d9a3e97253f5be29ab2202e6e7966cecad4cdb43fa3f697f4825c871be51925283aee1643ce45a12eff3939a3ef027b60f8e4c6a3199c52fa8df9a80ce4e72f8547021243760d1a9ed16e803df7a5c78d85f784132832adfba516f59472e3d0027e64ed99f4d87cfee34dcf5540616546921948d358350ec8d53ab7cdf4ca22f15a3f6d2be1a99fdf1efceeede2db3796a4289a120e1c106f7a8f9a32f666727f0330241bee3f58f6d1e1e3abc352d969479d0a367a7ecea4281fd72c5cfa711f8073eced16b93ee71f224ba87ef33e30815ec33e5888c111535fca07e38607296b724401e79ed6622d4690373ebb2e731c8c14b2ae7575760003ac65f501c30005363ceb8de8748d3788e611c70f2403d2b21d25b918a95ce351b44cda231a9f4bc168b37c32b8e1db28cda9569d97e6771acbf96ab866ca6fe3b6fec4deb13ae4514e131bd2a137b9e1ee7467bae8c57d55ff243532167d7fb581aaf730adc065cdaa75e09afe3ed51c5dc3306d5a50d287bedfd702820b02c8261bc8c4d587871cf639c1a18090065d99e0f032c2ab2b94ba0c8bac492022a90f219489500cdf512afd9346e3ff62ae439fd2e07f9f49c2a4046d61ab5c11a9618361428bbcc3712a0eef42f9796e3d8e0250b85a9bb8df3f278d7c16213ca8ccbb2298ca2b2b7c2d1cf58b18f124469a8b90947a8d3bdbca70927e96ff717ed3385321d7be77422acb670033f5ce1e64a3994e165ebc984cb2d2a7090e95c9113f340210daa6967e2c90fcee78a97b81eac53a318156302165998806eba67cd7be4244c2605819e71e0052e85153b9c7d916b285ed1a71e40086d72e4a4a4c86daaa1cc6c80f8c85ac304862c53fc8384e217dad303688fd9976955fa402b993d16a0c47a242d77bc9a4084722da9704df5e1bd7f697d0eb0b1c73f6aacbdbba57378f0e96faa233c774e3c0e7fe5127539d19864a1d1f0d288ac6a820208e621be0083b8485dbb6e002687bba65b07702a13bd8a1b54e75894a9f4d2e44e8b6df6afd1d6c45622cfe1e3da0809fe0ce51c8bca866c51bfcafc94b4f4aa3f6bad7952f49708624a70472f564c0e1d93d566a5a550eb9abb27719d964610988b4c5dc502e9c20bec973d35f475fbf32a47b00da65a32a9eb6a4978737570d57eb6193aba381a1536d87555511b9bdc60f2c8b29defa012322cc0648effe701f31f8337f51ce5f9d0b93d4ec31623478ebe3d92346e2cb04f02ee15a6ac2f516a74d592a3ae0947e1696bc8d6b8f3d413327ab95c301cb35cf9896f959ef88541df46afebfff6899be1e9ee662b960a9a4c3b3b567c8d22e3cd9aa06469994025672ed4ae2bad56848cca2916f85c0a3324ae31d1efb9def71cf263b5971ae6a03eca841b54928a0bee0dd33d65fdb5d4b661387f82abeb558e0587dffb64b4cf2892574eef0176f97ac16827439e920444e3794da2fed9c55fa8566a5261c0bd4b76cb7777ee806334fd0f74a106fea08bc1c0e6705ba746ef5b7200b7f43acb1d2a24de4593d8bcde004e2f086c82ca274f54d8adb827de4751bf56161e3d5a09c4b2d99bb5b81a549fda6f238ed241ba97cb0060a734f6020823c1399986e2edbd9cb1684953aa4aeec52c3bf75de75567e124154e817c60582f6e265c11069b889839dda7beb7f319e3b7b9c73c16d05492e93bd0ee6f6f4e0ce75af6034c74c584378dd4df72a67b67e50e00297c340490142bbabd5e87402139dcde7f5287281b1c32a50c4d1f68183a0fd31dfde3833805f56feeeb4efb7767a2bfa4d878d5d8855076b0a6ae95276f186cba9718913f42f88fbb5e734bc77d24a1f5943b8f74f6293834d1aeb87a7889b164e8445009d4d8cf5ca700499a6aed244ffe8356dd2bfce2a57025fb89ad0997318a9c6ceb09f26105e50b288c91289f538d23b8010160c9a91a3079eb57a8327ad0d42c6024bb1e7e214aff418ab26c5a43fa411ea431a6cf0b20c2d2e891576e2199bdb4e28bfd1a80d51df9bf943a2f8e940d166476c8891272c590076358feedcebd221da350613ab958844f0cd4c53ad06d4316f2d2dd4cc05570b3f66470a47de3dc7550539a475eccd1b34aefe0b7be33cd05851d86c5e719888be65307ac31c56473f022be9df3cd102bcf5e76e875313915e25a26839708c88ef26c1fc28038f1eb9f2c7cc01f179fe54a2991a9927c3f806b23922c6da546b25a0727214207345c8e88417eee6345ffd0b27e0800308b3d5312c95a8fd7316149bfb0b71b74d7e41a8d4f755482fb667ca946d4b1e7e323824da6922c151083a94482971a9e14fd43b7b9d53e2a73f1a69a31b5ef4b530831dd66d5d0b54b3d8fe83e6b91e6550360b00ce8172fee44a7d5893dea5858cecf610332511970dab6146513c3f5b74404c9185cb80530e299d5359dd0e9779eeb293884f0881fb600dae5207ec491b56523fa51d5be93cccae1aeeafee6726da23538de6bead7c78fc0271e669d714efb61884fed224ae2ab15a7f40d514929580c2db75a23d0e31ac4201b7a98d26f5919b2b46c62f422f6bab60cbc30bc4390193a988e2371fd6d9bda8b3712ca79120d8ec0fa5219544cce6469345acd22589f7b77b73a5dceb2449eddd372e15e4de2d3fe38d809f92f89913805b338fe6f8dba66a628861a6254e1eb9d45014d9b7bb69410ad800bd42f234a6e27199b42dad94f7ef88b39eadad2b28fb794a2cf36afcd9fb26d9d4fbce6b606df4fdbfeb0e2b16679910f226bbbae3d89c2e54540521b2b8c7772e3251371ad7cb86dabf8ab2e3f84dcfeb5dec49309e0e6192a236e224e16a85b9f41bac008b7be1a749db3da3878d06440441b7f43b6361940c548f66424ff2539c58204c2acbfe9d813ef9cfbfd63945969a723decaa64637106eaa6b619f8d4e821c983f6088ca94100f1e533b86ed38ffc922af39f057b7e1e3bca2d2b748418389ad397e461ee07d4636edebc6da41719a3681f51ab242c0b042d67e8e7ed0786e5a41968e4200b440bdcbda770217cc5684ec770161e4e62de17e32cfa4502f97a61db6fbc07e355c7e92754778c95237784ee09fa80247c56f30c48626e0f62bc6a372098c8070a02cdc6809367fca432ec8875a9c67fe876ed6a7afc9c1b26411cb7adb3e50189b266403c6aec23c2ec806833a361eb317b1dff970d15a705e5630c956f327d065dfc62e002128fdebd6e705028fa1d894a514d4ea1f650790b8cf9f645bd3c96130ff2d8b66fc0e4e9b6e2420db1a473feeba122151f7972aa8bace542d588f7a1c6d445164c1f9b172542f72e9dd7b4ec8cfa8e43744942686a089ae70ac751c55648136ee7c343884b1c8b64a8b182b603045e8771707df6c7f9386869dc9e0c86e9e9a8c31d5762865711258c87b18e2e9f1ba516baa46f618844eba3e01fe732b96f0072e7f0577c578b8a5213d6c92a688cb40f28c96b2ba893b4a1bfbb3fb02353c7b83db6357c789383f21021f9feae11bc3f152cfcc2696c1c646784bb662b771d689eb35637ae2a605f0e120dfbd527bb56843ea9d56331d5c15beb555ccb7995a1c264db4638d827579cf8d971427353fee19e2a812762117a7167b72b6c56cc8165073a35c3c85760fe1e3ea8c357de7300e0196bf4dc97afd3bba18717c0ab73ab4bfc705b6e52e903c19ad0143b36cbede27f57330c6470e3e1036d4bb9dadea84177137d6ab812310c36b0fc0c04ee6f945ac8defc309242d7a0f5a813f5f9853741b07f0a03b6580018b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
