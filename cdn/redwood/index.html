<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46140a2fc421fd6d7516f8444e065c81d4a676da1b4e6e9b44136bf53934134a9c78b9637707b7722f2b78b40dd3f0d4be7a1947b84ca3578f5206c4f7f9afcf0f156d166a178429dd566446fd5c32d8f4f8c4cca68cd8c46074524e12ad23486ea59274f433e415fa1f75b617238bd1da55a33e16076db2f110fe5845a51ae840efda80614128226731fbc0c2d18778ccd42510cfc75110b16c8095aaee9eb7cb609d294207abd531121c1813e84ea329908ecd2670171beae13dc537e7a9a7abdf75185f8cfb21eb1a6433bb36cccad8706c7019182b3d32e5eea6b8edc76d5af672c3c4bac7d53e4e2de4b4909be6942e1505c1a473acb5d63d915a451931df168c0f3334e8937ebcc2c941de07eb81828ea9d48d29dfd249baf59f8ed15fb1d443dd6774a6e01c14381a8da98af4d5ef2f6d038cf675fe154b09a941cd0607e4dd405b1c0960df54e017a8c0f3f160902e55402faf8dd4d1e0b039e0e1b36972fba9314466e24b2cea9d44634be825993c1c4d2468aa168071a7c70b148e5f957005204715c18873721d492fcd2d4c4cb593dcf369ae434a63277bec1d2be4b8c3c5b929bb90aa63f5161ace9a6826d67b8af05b2f29328ea96c4f5231730da2e86fee900954777d0d58ad22083e259e17077ca83edd2d21b7cfe89489d02a16ce324632c7ab8894bf0a0681793e30e7db3ce15089bf36bba51bed0ef99154b00b4e77123523e68af10c9fe1aabd4dd7cb310edf8aa68796c4e2ca939fe021a7fb71f9128f24f0a4e79cc0b63a7f875d302f0e10b36d4a205931d179d8f70d5f02723d2b40ff0fe8c77be3114c060438f1e531a32cba5ca1fbf27e2077b48a88dfb65760002d694ff98e0a6ca73899d052761a223a67a2e8b34a41cf387e2aa748c4f079ce3e45bcf1b1607620a21cbae2b1b8097ef7c08fd5b7f45077f0d9a442865cebccd62072a18344b2861b4ab061a85f1da0d5de8271e7b199d4e89c4a9ba5fe9f3b5db10eff95d2f1a7168fab7dd8e3b969a16de7b02f95e340fcbc880092f8e5973478a7505ae3f3d901ec22082c73b7c4bed6496626ab18f7be6d6c34fb1e489b1c90de1cd2ae40e1508157b6d25ae683d42d58554a5d56359590d0128fba2742515ac603bdde04d0e898450d7f57b287105ca381503a8bea9992d5a2725288fa54c8e9c60fce2cb2cbde1a4686f1e2ae76b965fcc32c7687ffa2be09e13abe77845d61d6bc9756e9f0cf508e738b49c777e47b5a2d2c1b9e495de835a638c5c4b10ee7b4486df720026254af46645e06e9aab578b3f4a47fc90e3c24038fb559b3933baf76d2e7fc211d9ca37dbe43cf9e1904fc534fc18af0ee3f6e869bdac08396c46cae55a38b0435e6a6e308c1fcb4fabcfe359376b40db469dbd5c150853e21e0bfea0c87511dcc176b7a3ad4d6c71ae5900a69caadc755da42d65d29d234b4b615bf0b54bd6b55ef78f99b725431a8c28c507159490978b409a4f1d0dc18c9cf0fb262d455a6f0d5d84c61197ec961b534f931a55b5a3854922953eb033c28fc84f8e8039dad85db922b680199016bacaf22f9c27fb1708de166f20b013be80babef2fc2304f75580ffbf5b8ee2b794f13c471ac49304859f7320a271a5bd0b6ccb25d19f2ac3489477ac727edf468efa29c921baae937e1069500bd19f6937e9a86cfe16097e028091444243d07f3823a1975e583dc70e1267be4f0a5dbb39b98b873abd493c0ca059647e0118a4aba329e3288dd7753c694175dbb149896dfe8cc028a076b23b9425f9f4cdd327071d47f9630e4b58c6d8e8379e5093f957473d8df755b3045acfc9a6846d6efff050fb2bdc92f53572b8096098e64d63e1279a0eb684236a215b89e7b7ac3f1551afc26cdcddde30e68e006da229dad973ca5493ea8d8032b406960bd1a4ecc097c01e01cdd9918fd9ba3b3f42db3f0be9d648202aeb4d961c115de10ba65736fa94fbf86cc9a6aa7fdd28504c1def6a9227c942c30fa502d1ab0f5ff3b7e7434190bfc78a69fbb1cd8bc5c0ecb3f0b68e2a53d29c436b2dc261a433edc86fb4e7f73f49457b53ba3af3e3d81d61a442993233acd14c0f5702132d78045c818e32405d06db3d8a5c4b52aaac8aafc4a3ce7e978c833c32f966382be796648d7674af070159a64fd571e14ff840420b35416805ba764321b55b7c5bc6a7ab411842913880b1f868b6f6786f3e030aa3a56c348037146d8914b4db566a15a2537ada6ca0f6cda666629996da909d58f4f624ca9ec9bf1b93226dd092b67fc987aab1dddb45fd083932f24712aba84e528ab261320f6f788cb05924d68ec8b37cbaed6b680f97b2abc24eb6ab6a60141a9184820ea4921f7e14e38162e8cfa9cb957ccb98f99b4873e66b55c200c0c3b71b2ce2493e7a341f08d6e2a59b6c7f5fbeda6e118bc14b059c328200d9507d84ea618334a9ca0df7d3b957ba2ebdb811d3645f02df9fa5b08b66d9454f1626b976718af04e282050e8be9cf12fe94c8eeab93e2749ffb8e116c7273569d557909e2fade4b4ef6773963a494c973ced7eb48434d0e8e52f908156f0fd39f2ef89a6d0821583b59d05ee7d44809b43df64c2ff7484686edeb02be689bb46ef5e066234a04927920c1886cfd0f21a66908ef9ae250bf1c32a8411105d2e9c5724a852ed13e7aff5fc29e8af0e25c4ae3519704b1b285f7d3d0afc60e5638f248a5543760b15721d13c49904d9d39c1c6bc46552e7936a53364d91ca6afbaa97e95ca09f477e305b044558949bcf9d05cd67dddcef521bf7f5f22b750b1b651202a716109dc3770e41948ae515a5442582be912472ae891bce67ef68160a598a1a71d5f703163f9c8f719c00af7cd9577a4b3a74daf0a1c4de2ad9526b414ce80c191a473411fc4922080649dbd299be54992e13b78d543119c62a6adf30c25896d55e1379382a1c8afe7f39305a07d6e8bb4ac801f362b6f2e56dfbf62fb2d5ed777990272bfbac31c1ae61cf7e4b76f441bdbef9b9f103625483c0060ad8fe83198c3224b8292f235b7d650425852834abac816ec442b2567008b9440f16d0f045fe585e656962df682ce117d433b4e11bb88a7fdcd580b8b75dde0940ecebf098e594e20f4b261616c5ec241c1cbf25f50876195b3641988edbccabf3f03e0044990aa80cff7f527281650830b73d999ec6521f54671689485b1849878eef07da7bab464f0b6c9f2017e1d4539f3adf108fab06108dbe2970e5f29c182dd2d5d82a45eaa2f86a205069402fbde2465e54299c384a3488047fb2da7c83c1b9beb60ec67b6820e42e15b6c2bfffe58428039f7455f3f94c55b314f676d937306d9efc0bbe96ff0f204f635e245b8eb80628dc8c408d2eb9c387b3676312e39176561ed5d2e9b2ab52c5b6e814de2d59c52a52f9be09da31ded6da6e88dd3c97db3e91e7c2ff86a85bcea555e7130c5e9830db5825dc13457aca5ea68101bb2200408d6a5c4cc4269e09af7cbd3d37d0888099258e24c0c51b1d593a3bca2e46ac9f1939abc6b7e0af3bb3f7821e0451137eea5e21301151776cb78b04e27e783b17bd8cb66c92f6bc4124a5a5b8047a82d3b636f67b33c2f283e41af002a4d37de7b186eb97e1e0f7e99a234f3ae81d76c09988902df9d3d1e4a35f566ac768693c84e933e4a316403e35f8200f051d7694952bbaa403c0d9402b657a7a17847776489c4948b64f98d3a51693ec3ca8fbcbabe92046834f54973dca0ced258d609ae34ffeb4775e496acfc1bccf0941b78daa8619dd1f6892493c76c8b3f7900a8c37b6cdf4d08dc6e0e64c4fdb5da3da43dd3f2c26cabd39e5fe7587cd16fb876dae7b1de0702f4e9ca6788fb40055a6ef4efee0489ca5babf07b08a3bb30de60576cd5d314e8dd91b655e64c155b1a50cb68724803ca5c387e1a524db5db8fb79654a98e5cedb0ae75b731c11c85c6238889bc68c0a27d74c8b39a7127c9e2c9e94c57b74151800a65c135dfd0dc83015e37fb68a355282352d1d505b25ad18f4d5ea5f49524187f0f7475a9e0d9b8ffee4d2bcc79ba238ba75c12ada494994af7c85454f70b401dbe97a23fb0c76e2a0e766914f33f8dbb0d6f28bb922fdfd052362af461a02785204ce52213b803ea3025199d119eb73f540223cadad8f198b06beafb85bfef9297aafd7f456243ee944ffa76b893ad5d40f2f88eec0e40900c83d5eac9a957f28ab9e92b721c06fd9138844ad5f3702044424289fdbdab449885f2b2118b8b93f38533ff8c47bf7be47e568dff19503f66e5e9280ab6b25604325f0fceaeeeb1c86a63072ca9c305d204564cbc8ef1afd2f91c0559c381b7c823830a9b5fa6be967bd032a3f2e1d32f996c374651dc9d6c5d3f5784c156d66e0fe81fa60fd83f15707dd5642b2f881cd2f73a5ba1114025f609e71ce68f9af33e5ea36592d95cda1ae3f8f9fedfbfd6d28bc54ddf56d8be1e69cd76a8e1f3b7982bae56ec1a0ecd72aaa342951c21bb501d4dda32d0426b355c87b255becd7efabbb699aed55dd2a9ff6a4c286fdb9a6e3e96b55a9504a25e157b53534539a06588fc3a115a33e6c86d90ffbae3976bf4d1e942d56d1ab0f38e2967216e2d9d7855f5aea107596e3e52cc4ba1e1259da8465d912ae3fc2ded725921ec93af8f0ea1e36f2e5b2acfb4d17e4fc8b1194053057d45b5ed9a3ec01f1a2009a151377c66474a7061b78bc7c4eecd73ebaa3d5afa76a1f863439b608ebd9bcde96dde162ce9c67b77e41420f413cc3f87a56ffa282b27908597ef7e15bc6c653baf9a19942df5e463b5fc0d1c2f9d3360438cd68026dd58e3636c148ff2eb32255379d2319e2292e6d1831f1735e8abfe6f771161e366b7ae5f3221328cfa6dd3093ca41b9487c5128299de6d3c65d819d1a6fcf0ae694ea5e59eac82abc07cfdf7f6efbe1bc5bb3fe13ff4b21753cc08ae1b87691bcfa1181d8da5e530ccb39cd86003e221180d201667e1390114beda81e831cf705bfb02486922e0c289de564c7ded6b51506543e2ad7490d955a26fcf0270eaa74d34e2c3ffc4901663c5869987bdce20299313c9ef95e4a6bd6d13d2703d3c73fd341d37fbb1a78d926e7b7d7e341c6559fa3fa8633164bb1a4a36c1525b3e6548678c27ff55afb87d521158a45f944e947be7474f5a403cd0cc2ead85a48a0971d384452425b393fc30f53a13a9f0c0baa69b8949afc395446d3dea5ff6d32c2d95e37a161fc51cde1710fbae13f7c3b3dbd2e33811133461146908440b347c1f5b873cf31705af23dd0a13bfc4918ca374a10d359527074bf69803641f0e5982e1f51507d884a7aca9a9c8a3d4c1f196bbe601f52c2b2da4a57a99cd896bc33a66e0ddda43246269caaa3a78420738c6e1faba2f05ac0d4c7fa40d8b80c14bd6cf3064cebd0609e2590b2b9f969aad1d7546057a07ad97e007d2577ea03312c87e73b2764951b04551478a8f6f743e9780d41ebd90c8f33088e9778a107088b15e82d3cb351ae3ef873a7637ba77b74c932ce58302332adacfde93cfd16c572abeb0acef5b6acf8751faeb8348948e07bcca391bcda5543be290dd4c291634eb4d37229a9d48b67e44714e6872f9876ce2315bae963c1191af0a164081ab9b5e23869e2cc4fe5daa4d7c592fa65a22bbfd6e0d38972f7b633beab86586684d8c0563958cebdcf55da26210fd898bf9af0fa6c8f325182300176738b4e7abdc6a0db19f85ce02a77ca9654ca00685493060151354c03ffa4bfa12e0cb66eb08693935099ed2553f02378ac91d108f70fd6b620aec210bf1bb0ca4b0fde1ca3cdcddc6b0937aced77ad5744b1aed69c6f02155f6f13d9813b322dc30bc361b7043213a7e7b27e1cb0276978aa4c961a9d63ef24a9067c3473a77277f3cef31c591761ad53fb499fbb82c90252b346af37a4dcedbd1e99e01fa3a3b4e2949edc6f899035815edad8e96bf63a3c1febec08e0060f00aa77f52aec5d56cff44a90f619e2838d90195973da2c48e042ea8e9144cd9b6f3865bf55a983db52d68c5b61b13a93bfa89c94b5a0477db9fd9db207e4c175ba2a1df508a6f31a7f17303425ce858af3519a9a4bf644d3c6c32541e5929a5177b18d7e265d5960b70d5799b45742a4de81b60987b363f131aa28d9fc4a285e5a90e9b4dfcff743d8f5ee0afb9b915e00e856a4620f7490c5b5485f6028bb434ebf0e7f49ee6075b8b4a13612688f6142d3bb97a869be5f5caa90f9c4ea38470c4f73090261e6c0d972413f0163d67285392182e23ecd93649746130889f3a74adf0eff28e784c47d8e8d1c3145803b4a7b26ca6587d0202bb44c9e052e73eb7fb35a42fb0a9da2fc4e87530bdc236dc7e061a3b5c2df90a0a502e219760107c90e7fbabc0d6963fe2b2ace739ce852564ac243fd42f8f0ff8b29c5a5e2b612223cb22b968b485c4396e2250f5e9085f2abdd79f5c3e6d983790989d26c925e93516fcdf49bea7bbf7d052e79ab48279da3b9e7eab56db6d0e170165351532561134a0bad97a8ad995e1d31649be58c9a1f383929c1efdde8cd22505b0e61283c527749285b0635b4c9f8fe2d2a62e8c4fdd794f126980f58babe4f78905b9a2fd5ddf6dedf50714abb7dc8f87e846ef3601973d32b0bf537cce5c68b36a7cdecaa406acae084bac18c0ed9b3223790393e3d7ab177d56faa8b453262e6a2145f7d08b9eb0e65cce48f52fdc0fcf9197f941641f292b5c0a01c8c4fec3371babdc1ae7ad3ff6c40ec78b90b778ed52bc3ee50ef3a77bd01511818d4e80b3229e5bcacbca7de3d2470f187e8a3a3e669db5bab85956a3d03cf9d89b893ff7457768e087e55d6dcd9a753c62a662b587a4b6a74b43d2ae66d38af7c2ae22c62ba3efceb53b14043c49f46e9ee8ff5ecf9ec7b3ca2760606d4f762601c60d6b5394ca8ffc2cd5734f2d9c3176ff432499eefe7e44ff78ebc1f43b576edf1872b874bed2f920a303c9c9dd4e1b615d48b3cf0bab1285a027db74148f1ccf801b74b6f67e95f43c7746ed6a1df9c2c05109989fb3833a7d2a7fd1f272d601b050c35c051f991d85772645b3e3aa36519766d835ea25c97597853a436d74e514a662072b9fb794f00124dee069305645d8091513161ad104d8899d93a5ac6ae51a8252778395947e478918a42c7ec86e0d2f793e49d31d734da72d01696f0546d775dd873498ba5fc5586d34393e23bd8cc3bce0236a14d49fb8744aeef83086f9330864e3308f86d8382cad35281a9e7e8fd097bf6da6e0ef562aac64abaf5a003a0f541f58da11d787436f5bf7a4ab314f7cd1ccb0f6f4918456bf9821755d91c3fab513fce320c83e7b24eccaac0ab6c1ee9e3a5abd22df8e7b158237516e661b6356706dcc87379996f05d7533f05e26bcdbae19c74251571e391830e691fc989a9826b29dad786613b5a353f58707d13c5d4e366e96496dcfbc11ca2662304efe42d22ad76515348f4f2283e004bcb6420057290059b8e0aa7d6c03ef366147bc03b2001abb55ba2644fa70cd6e73485c72741b460e99baff7b4d2669090cd5e7e93779d228510ca03a1dee2430756e2cb0d9538f089f01a649e4dd94545ee1410587dc749c08703da3f8c1b489448acdd32afe410a474af4a4b64e3f286dd8ac847eac17667770e14d6dab2fcc25aa18be46392a323b94af05b620069051b47d43083c61c9535d6e7dd238b6f57dac2309bc1b5d787899f4d2133df7ba1c64383d54cc4af985297ca6e0cff224cf2417cb05918d95f7c90e502a98a11f4c9e334b9d7a18aec748b875272c48956227923076aa4bd1e5a560a6de07871496b52c1650a70ce11432ef3de116e33fc0067e84f8a948f8fd174e27ad345142963225de99ff4efddc43658a9e0a27cc3a63ae0ec6af8520139177dcc855f3c4945738c82e2cbf6ece2ab89a779136fbdbe07b07e0a2b7eef05856d5a3a0e145904ab72ee7237b0aa2a336d1da57e9d04cc58d0986851ef0af018143f7f680eaadbea54fcc231cf749e1a790202fac46e434b46268e831cc9a590d6c3c1484e2a2b57c810a64d3cb4f5d3214bc74c3f86dd3777454470645fa6e6d6fb6d81f14e5db3b2cd15a6a95fd516408fea6adf90ef87bbc09dad8c20dc802fe32d27ede7df9a0093b532fa8246ed6f3f6601060d2544d1d256265f0aab57ea348373798bbae7735f1acb95abcbc25785a36cc5aa9170f6e1de6c07422c8e5203c648b57ca981f537744ae29c35e00fc2016ca3ada363b5f30d3d6a022e5162423bcc1cf630ba7817ece88cb56cd40fc4f9dff33839d8841bca55e52968c1a9b9a0126f56783cd6aa03f30173247f721b270353674560fec4d095a561db3eb7c97b3794b98733e131fa11a51328e455ca93df907779d218cc10a9e9fb657bb29b3338531248dd9519703cac3f7863e0cafe9e662ef2143f28eb6f98d94de96766fb023abea906ebcd3a08fd7f8f63f1013974fa423ad509492a08d40db61490810db291aeac1cb0c7d7cc65d5b46a82061b3df13076e1124f1a34ee57715acae2dc32882f44f7e9faf7c5d68f9e4c6a7b79a5cf2965a05832dd98a42568f09a16da5394cd4fea451a4c2079c130334ec1038a6da843703129dd742dd978f9455460bb1ee1b840b919e4928b74453214d44e1da8cafc9defad81e79e8c8d9c828a63c657ec752b24bebb134b1c4d9f2a0d1e6a15a08c7773138d5e711c4337b13871f6b25e8bf2d022ee01337035c58327cb32ab4c2916f39cc8736802891e2eb6a00d7bd0b521c3c4f851e8c70ec7582028d88e6175f97575c0261d5e3e25b7aa0bb50f4583448b64fdbdc0b90319ba3184fd94f2c1d1eb5fd8be74805a03ece13e19527ef52a56d7471194559b1a9cf880916d5741410ccc0ef3041b70035c04911ba49f91108c23890d8493a7b1f17f1c3d1d91c5c61a30b0fadb64ff8419d94895b9e3053edec1d2fb044e9fef929cbacd196ae41a746c4b251a4e3e3327ad35d88b12d786ab4e001089c96621b1151473c2f2b16184072ba1746b53e427ccc3aef70764480747c211301cd8fef25feac0f69abf345d3ae4350b484fc15be8669f3d9457b5907ce6089b3e9e0aab4ff8ee40011e6c41e94694ece0f9c6e03b8ac86e4d21049a55f9947ed8d5c510ac953544ddb87683ea5d4abec403df22a8371a78db9291d038b9f57ba4925af6fe30b412a1bdb365b1acc6a299da37af8d4657fbbd0a4e0370d5a9a8c9d8a91828f112c78fb387c9ba56bca15567d5df6a1a4de971ed9620570ec963c2f7c3419488700d6be6074a1f205250eb0da361f3a37f5c66bafa77db8b8c455bb66bbe675ec514b132fcba511361384b9a5c8fbeb78e9c31db1e7373f214756d0c809258486d3bd875a2cb9c255c15fa87cb9b5bc56409caabea3ebaf61ad63ab3680595ac1a266ff2b1a80cb41e07c3f8f8df1fad9d135f9d4724039cf7548675262fbdcd396d5aa8ba44b9bf1e69f3177d7fe4324380c20539b27d3eb6c4a29d73b835ba51a2f5ac584282054829897ae1aa1a47dc2e8ecd9bfa245c9d4b30a91523cddf0dc9d72ae2f535b68337da6aff9dd1acd9835452a3e9f621f90d28ac8227f06a3091005af4261d50087b909e25269555db48433b7e8f8dd7daea643071859550f8536ca8497fc3405fadbc68d7d1b1b6f3ae969ab787a0886ceb74b85f16290ed295cfdfd8519a2ce74ce57651f2c8543480e61e2fd93e40c8f8cfe05b7703b784a894150656a12a33fa88dd41242f1996e2fd7097a92a008d8ee15a6b0dfeff04ee5776088247760f8bd21249492037a5539aac8bef764d2fb872f12488170a4815c0567106d9686a32cb07d12686326480ecc709811c62cccb4e5016f2bfb682d54cbf69852e4bf7ee89e597df8d062707c32fecfb5eca5ab87a9586e6ad90f58cca58a701a95c4f39c4cc97c55d856cfedfd8da433cc8079a4575f2f6067e5616f9098f80868a417bef7cb666dbbeda3833aa6e3e92b41b505cf0036f96c0bcdd6e66ac7192ac7aefc2f5d6a68e9666ac28dfbd1c88391ce3770f77173108272f8f78356932103228f89b200eff10f3ee14cdc55875500af47f5067ca5cb073d47d69f854b0293165bcaf10b46080054e9a357b8c6cb970e5ea4ada2c39b24abcfe348e4f4da02bcc9228c852e00b0d80d6b40af037d0096140d0be2560f6eddb433d0f420baff010ec160984b10b952a991b1de674a6444c0b76c98d0b6e935f8769262f33890a983e6b26e4a7e64f2dd1002ef94aa80e5f39ee3ec434c333038e982c0eb5fa39a05f4f82d17b04eb1ca8e73142964397a3e1c434775cef3e3219405e91b81c1cba997d33a1d7b1c49bfc45986b53fd81913b357b280902712882e25949b380e854977bf40d8cc496aaa649266c7576f0d386f6bc6e7d75bd5bf73bfd6b88655450974a23abc97b2799e953a1d3fc3d2baee999cf2139ee7936065ca18bb19f2b7c2202db2faf143a6f69c80e89ec764d4fdad13b688c7eaf528876da7adc7a566ae28157ea55d335153aaaead8caecbab975176319ff357e5ada33d01dda8e04391d00d25a8f1e2110d4c16da91964cd002336d7b1257f35b1aabefcef1b36ed95399fc03fb52cbbfefaa92f57aeeb04e0eb3a0434627dc0801c0a793800060748f05747078f1267d1915680d1c66eded02475ea5a42fa3e7d7942b61bd01bcec0cfdccf47757f942ca85503859f12c4e33e299052685425ddc8e6d51f75f7eac3f803f1561bcc08263e0d6e519cdb323b4b64ec0eed0990671662d1ba1bca5b0722ca0978877257055d6216823dfc9dec3d4be6adf87fbe612bedc2dc6f3dc1ce6c66f74875bc21d718df0afc685ac5ca462419727ea702fe38cc608469eebaae67637921fc7576b206a4af06384a5fe09294dce6ac2f9f976622ece5174b34f1dfc1e1c2db6bb7633be7823a8e1db52b22df100e5e5829b5f39018d386d46d4626527c3e15810eb82bdd29c16a8d2f90b22efd3c5789c76d753e4cf860970d6c17ed360e116863dfd400656be13503539fbf607df458d9ea7040f5cdb49532a103f14c730c3063a6f66b6e0e34cadf2b72e4c5805a7adaa8e6784ff04f0fcff9b7a8183fe59aac90da7eb23770a4158e7388b458d776063a87d7e629a9345c48645b95b08dbf0b49d7b2a7fb9da9858f3d115c1cf683a0cd80f92c749cb85348bf862c957315c69faa59470da608a66ee012c81d05d33f3a8e4aebbb71bb35dff652be5fea48866ff3bf01069c61784dd6d7adca1c35f84a166da199fddc09d1ac4c4ef5f85fac320dec653de9cb25654145382e1d8db9a920f3a0091aad93a76b49aaf685a8a14bbba80a235f20168571889360b4087c5cda1dde76ca0b8773b44cd7860296fdb65188bd58c727ddcb537bf26fe995d8549d95ec0feff3916dadc574501811a4f42f928654ea79885f621c1505cb27c92221841b30ec56871e2678e8d7f1fb06edc7252b8b3e261da2e24f173f6f682e79d7c85fc72db5c32bc7d40406977ceefb1bf060d12aacaf4d7c217682d29ffe70a6502da2527c7f90ff1ebd02073cf5054df87b6af7acf36bf7fc85583307d824de1c7420249c9a039665020dd391d190fe0e6c428b74d3117f98597548753972107f86e831ccdbdd75ef97b7cbb30eac8c2b6f4fcaa970d411f9e44757773dd83c1ecfaf30b54da2792ec032ffda41df35cc98d8a782a424bad935d8e5cca7f17dc0b6ec96f4ec660ea14946ebdcad304e34aae476759f5c854421cf47586b4f0d3a834bb5f71de6e971ab6581323ad690498f2710650f31884cd651cc28a48b32f62d71ff351aceb34fe1a0fe9ca504a94a4a40edc84836071972aa49e3cee6680879d5bc4a62991951ff1487cd7bb22369f3bfefb5e3359585e76fb948f0f9acad85c53c99457ab5a1431abec3d26273f568ece18c33103369ad330d0b68f5b5605ce6bdd7ae441e33c62e724104893fa004d775fd27bac20bc62e7ef6c572716e44d5ecb2169a1e2034bc7c41f338accd4da963d0049ef466b6919197b7dc58f38f2ecca63419472d87266b2f0d265495b0b5d917cfda3f7749b64f222dde25c811d25c31b309f033c69569a0379e43fe7aab1c25417edd04bf0b02fb55da754e0f07828099faa54b389741d82de6ada660a278e9b04149dba657e646a38059d8ebd81ee6b9d042e397f688b8db85e2fb5bdbc995571a01c8f901ce1201688945a8e9a569ec5237d7c0ba40f2b1301b18dfeaf4df1426ba862e3c143201435cf872268e665e6a445c3c0e9e8bba60e89cfeec87fd576f15ab995a8ba55fb4884124e9c4941eeb8c37240abad48c4969a0558f001af2a13350acdfa2bea223a1d8a48db037b6cc7c820591a381a6dddd7d64ab214a355b411697bd845dfa1317d67ec456949be4d558361493af6ed1f25e9066fea431bbb8a7cb7b0ccd649b7eb4599dec7a8e2e8a1f0b426f946968443b73651a61432814f0ad1d06e38a68a21392a1dc4441b30945cfa50e8fe01bb9f5b1ebf848a0090fa097606faebd57b76e91c3b802fa1a4d1c05fc345ac6430e4b92d826513eaf20209e899c02312852d43f392f0a382938d70044962801f8f08cbd16f6476a0ef153bdaf9ef440f589c484abee1d64cd43040cebd57e7c403d79533e3eee43d9b00cec6e11fde21cf576bb0cb64fc5be228762998568e6dc8aacd8dc4725a619c70ed8918c4a73e9ac88344accdd5e0d5c72e2ae0b7b5fc395a7fd5c450383cb3478ea1691591099bba4d38d29aedf487796e3378576b21c0aeac9592308c816e963e214e9bc16f69e97d5eb031538fc7e0855ad9f5b2a7c1e7b919d4cd5090c09bbe06c97086d95dd601cc6a905690e63f8add06b2883b11cd195ee6ce6a8c8bac50de41758c17561d23fbb679b9329cff6c0ed9f9290b03e378c6566b5efdd5baa7fc1964d59fe0573128d239fcc476fcc4d0d3325f74a794987d6bfa578326c2d6b43bc6ce0c617c5a2cdcd658c9100f28507cfb8c9a46fcd98c3c6b5d53643759d45962add781995bb67685ff7ae187b4a759071f8909d56f39e01039d838b0634c9787f6817d71a19b85c5fbddf78c672865b2691c2c5d5cbb4df646c364c340f0f3b6124539ba7062441f7312e1aebd977d07e53bab9c08e3db08f6831d57a87e175f508d8cb55ceab53eaa714e98a4933dd1f735f566d4e4866340b8bd557d810f55a1b1165947dd0ca2ba1fd15342a1e740de612b21bb0c7b9d35a6ba6ba21146cbd4471bbe6934294eac2b3f3fd62ba247930419b8b30c2b600aaa2b35ef53ce37b1f9a6cabde17d49409161b73db9f8998cc86b7b7932dfbc0b86f16f86a2ac8ef4f020b9ba41ffb7f79a69e488fc31123196ecd4518f37348732f9d060366329a36c59ba29c69642494ba5ccc195465d0b2f91231b66bcab1d7f7fa981fcc6a7babcc714dedb6d2d2b287f080e6818f5d258a89fde8db8a0e1fbd53c509a5b62e427a2538cbcb8df8c55fe1dbb4e8a32f0ffa0e349c52a6aa607ca09a42db6f27e3a84a2cf188424d2cf58c9e26da4a1d00e939104518483b48a0ed0fff63ae22e4adf57684b3864ab98a415fbd5cd551b580f37720d32786f10ea5990b3c3baf2b6fc2d6da1c50dc9b93f685a9a124510428a14f1204a9c18c3f8b46e822d9cb38b33dc2d1d1c1d15de2cfd23bdae2496ece91f4e6a7fb671ebdefccf55abf9de985bb9e6ec22b05b0b3e0c2bdb7f9daf7998b8d29c168fe021038d668d468c1ab3bfadb6af484f0e25a2995c672cdff9631b8d08058a3e4bdad774f235744b37d17be78122b5c852b8808543ab012107fa976323314cfe59de412b44fde733df7b49e12357c607aeb1b536a85744077ad04574276ee3e7d83d1888e4f3896eedaf5ef8705cede14a5123cc1ff604a292251eb2eec029266765acf5f55a69fcc9e8f8e2174fa76e587506c46b5c68ee4d3cacdcd8539f0c99f9f33987e0a3dbc11ee1f5d5dbdef773be98ad9d355d595ef5aad324e25e6371febbc388bb162399c68c196c8e605501c09a8bf80d895087be565f916fcfb2124024097cb0e338ce9186db6740016245405db2199cca8e761dcdef66f9b22546e3f85817c0e5e49f23094b7ac5e36cab28d3b6cd0ef5c22aad9b2ced0c77baf032f9b8c14fb598b5153c94076544bc76fca42f836cf89d1bcaabe90986910d08e97693138bc03588c5f6f59cd9d14313672ca59bf2a391da319e315a0bcb22cb0b4c4bc534fc8632ff0c8080a8b251b755cd3d4f478740952a8f543061399498abb8d908461cd3dc58de99e248dd976f60cec1e250f12f3ac5e073bff779bef96962640bd46eec9624ba74e4c9ba2452bccd04ca2a2773e6bf558e0aaff1c4f9af9876235cf698c25835291b9e58f973ff2547432553bb926ef890cc75cf8137e4f87c623d9d82099ddecaf8b5fc2afc7d7292952a460f465d62f89ee9d142870c7910a7fc6ae0df3602df6b5f8bc02e465f90b8820b21ec1b1e519fa2b6d327f4c492531fc506800df84bea005848f0c1b0ff4a0c308a360f7053c2fae51ed02c06310296a6bf20cc0d8ecb549bc83aefdb1f3ba9524030b41d262fe7552dc5d396c012e60ce65aae524e29e0cf4db37f2a5afb3e26bc6226583d63c36f73e7b47f4db2f4941b305313042ece008f8659f03d56f405453e615d2ab0866788d202e8f9884103d2529ef59c6e32f0611a6c6dccf3f9da0cafed993fbf61c1bcdf4f0b95bddbe7681ae76c85b5115ab73e3fa05d8a9a09849b7d22246f522151ff87d65a5e86f8e19f10762e4c0babb6cb47769cdac68b765890d2f0454fd3c2cd7c442078b1117f01f1bccdfea491729940860861929d09eccfb5a6a1c80e647b85682c5d8383cf9659e289ae49c36c4bf3c8d85f99ef5009facbfd8ed6dba5fdf91688197c6ecf8b012ee1bac5887786660f8ffb0dc7affd1bc6416b8873afc6bd787f8a4c581f7b4c164718ea198dadeb05a2ebb5fd84a6f55f203d8de09128deb00795f12531be34eab99f95ab330be94e4a83e4cd6bce092867651c13465aa2f4063792e03b1e93f8851fab7136c92dc5564bfaf7bd0ad40838cd2239789be5549e0e4d10e1413381a0d6055f8b2e4808af13c468d28f90c0a56d905fc8bc32fa1079e7dec898c1481cba97e3b49562b8eaec24365b6a02fd57c557c69b1e4a7d2a2baf4cf5637ed63670bfa3725096aa4edcc48abc7aa4c28c3e2ae0a577ebc783a55241551a192c368e87d29e654bf614c9a6522c53200fbba3c5567d7f4ac974f5a59d4d50aff227008cea724ddc94009bd4104617f57c4b504bf1a5c6e850b44086aa5ee28e6c0ec7c362f844ac379765978f1de8d078e598b782f53625967adaac2266dfffd9a0366a8839f75aebcc1fcdef54bc68fbfcbb29899bb3a03f084de014b58abf957b0f60e1fa05e30e7603e1b0f15f7974b4cc7bc1bfbb7e65f149d2d8c8461c4b83d270fc4bd3c72da6e3a487c3a904c47e35f022690b81f66cea84e50bb9e6bd6b78c8ee47298a41d9618d3501ed6e5693c6f580ae5acbd28ba955bd621b0798777e2956ac28ebd4d638e16d602211161a1ad3d428e1930a4c11f491e5af8134adf3c9b32fdff710a52bdb2733384c30463ec3f9370692b40c62ac40f578e30b9013929383840a91b01ef9bf1d92262e2d77de8f5c952e02ac5b43fa789c6db4cf8ebdd1a4205c017549a1a0907c73829b760cffea808322c088fdb9098efcde682b1367ece073e362459824db40e0274d697fc371b1ef90350dd29e0425c7f4436d21e174fd99006037851a5ab951c565fc8abe98d3ced76d5dc6db921e0ab8fa9835e77b00bffb4f4c6d5beb51e6691f47d1da984c3716439eddf96a79e75671d80da9da15ee39e9a1f3d313740a151f8b6fa8b281bebcfce5417c3e5d83beeb9d09502cc18d6ede36c751f853fbac789858ae74bddcff96fda76f79101ff930cc226a449f1230a2a6096918d3e9854e539e94590c1a41d5b334ee1e0999d51d6803bd07712867756b6e19d72e25b878006dcb68e98fa4407ca04c4f046cd77b6342621b1d2366eea17753e8f7fe2690b012cf03cc8cb11db3b47d7b3ebd1184778fd5f2befa7ece51981308c0bc2526257bb961b7cfc343197af289c7fad5c471a704cc187b9b5f13e7b4ea35cd729b73fef7210efab047774d15a649b145041d0ed07c62c3a1cbd6b0440980bdf4f3e9cd55a99c4a6e23295a3d0f54bca2b44b76ae240c9af8d7f57c3a6ab47849bf4f9a9433467df9eaabfabc2023cbe7bcbd544c5f8ab89931067d657903488b89aebe20bde7c08d621bbd5d6d44b3a51c908932e170cd1283de719cd0e9bcc63e096b3a75376b128166f0bd45ba1c3dc2d4522394206771e200dfa852aec8101b8b152e2291b97ff34aa15711c18e37dcddf2486c4686cb6f91988ecf3450b4261ebdaa4c600a3783e5edea4dbdde9bc5538a94dc69c19e599544867289ad4a323626a7cdcb001b16a1dd0d00002ad9715c3dbb810e2912e1b5c17a437192d8477287a5ca68fef872deb123dcd31f11cc5af0412e4b9439336ba153906200339ed71d13b84d4c3c1773aea1c4abdd6844c44852c57450d31b66a47bc202c8e02aad0179b7d4ac03d7f5c463f3cdfd42a82096b586ebad69032842df45c7bd1edd801028bf953524188d4e847c04656edb00ac612aa59984e4e692ef9a2c21f4944ae77a57d76a019ded6eec3d3dc6287d586d40001f440fa54e556b56925ade5b08195fd552d716e50e6cfe114ee6ec99a0eb8144d076dae38e3bd2e720dac85fc9de8132f1402c2f5c1626146687fa390943f67c763d20b5493f86b3585d5812025e3540ec69115d3c23ed8dd25908b140a05ac53a0894f2a2168c672c08fadba8cbdd7297dafec8ce1831b7d414eeb43d2224373d59a23a8c831cb87ce210bb908f7be529eb8cf857ecff223fa6efecd88a6dd043a60f7d01bbf2a472ea45cce57372a182f408a1897fe6452b4eb024a493defa7ab78f06f4fdce26a301a54c6dfb188f4e128f31a5eb37638f6d74061158e3145156186850e1118fc1cca73cb99d4ee47ba1ea8da9370a1e3d0c5bef6a2a7d17ecf8d48bb7c09fed1442fbc37cf8d73932dee49bb5bd2b61f5142f56b36182d472146082d18cb0418b3f7573c14ec4feca08d1ddf23255faf1a231410357b1d4e857198cc17f8d02899aeff75efdf6077e3a7c51ba719e005cffe36a8d2158f5e56ecbbf25503ac47f03ffa079303f3ed357c0c449e8d69a750975db23dcc4d0ba73bbc0580b854e282d06935b80855a172bccac7bc799686d53f53898c741737a9fb7620b4075301aea847d14c4bfe4d233e70138da41bbfefacc2a6a2d98b6fa7172351c95d153946851a7f0df2e494281c10c77c7e3bb7ba4f60bdc4263d4f39bdbb34adb03d54b13a1ea3f4327ece693d9186379024db1414d14f7a8f648a361df6a4b477d619f4e4e5a57f6e8a9ce2d7bffc69f14f07ccf707e2bcbdf7bda46f3493f80f5f3425b56ffceea5ba1756571d5f5236aa67d782ab26c494950237796b1e14b111b21ae86e990c73fdf027e52e60e59a6801acaef89eb2185b48af2790783569ade8df0c8d8dbf58759b02c1582a514ace45a66d62fb7c0a4a7a6e0f11ea03ac9ed0515163bcaf4bfb74e8a66b4190c4fbb6904c02b182eb013f1ef04a81ac8c37b670f484b5a9920335d9e644f7171b0df49e51a6935d4b06650ee53e35951b08b373b33159efd4548b52c7ec08672c55b078641277264f13e5b3d594854bb388dd580b5b3ebb1926da0541b8e72ea552520f7c65d4b119dfbfb028fc8cc2923cb152b061c2286904b11042ff41dd1602eaf4a22f18e0df7eaf2d4acffe9e6155c55021017296798414bb370fb232bddce72f9098de7fa89926e6446875b75e45c3c7aa9e1a76dcd574864cfc3734b7578375c39efe1e299","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
