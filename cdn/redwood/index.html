<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e896cd3ad93e713c762bc1f8e7cd06c77b7031144bab887f5479d6314d8582e1804572bdce1f0bfa7bccbee3edd4550d9e602088c5d423c9d5f35779beb4385030000ecb635937cc0b20d4c689ad6caa0e69ecb1f5cba1af10b9dd41308c833bb75b6f168e330bcae24f066b38548f7ae2080e63ece380baec3f8bb74f8603cffbff423deff315820198438fa85a98501b2e59674a0292011dcf6fe020134d68fbecc4a6fc796a16754b9081056aa1a18fe52e758acfe55a517254c4f0c06aae797e5b8a7a061e769cfcee50a5dec2296783792ead829f821a83b5dfff534a58baf1ce3dbdb091d70128fd131104356e8b78d408ebd3962695231f2b55c6c058c27b1e643d5eab0cc631053d03e110e9e6b614e72ec84469ad641dfae7d12d0b328a5d89030d70d25ad32539044f0ac8f1da6ec81d849c6b2781679b04cd64c9d21dd92664f0b1390e888e2a9f4d34f85ccd16a0d83a4c2a600fa3cdecc65c1fb948ef8fabbfc1e1a6f31e1892a4696e706c67e323d74bfece6949c8661f6620d79c0884f977f4c31d7aa4bf9e3d94f9fae8222c7d6f11be8468f5120e475d93a6620bc74e46fc8fc8a666d97fae39c9bfeaa8ef691b7f40fd77cf821b65cb08e4c6b69202cd881499643d852c094e397a63600ba3fdf41606c8783e216c2015072031fd9aef3402528c31d8d1d4de30f95baa59986dc6b2123fa1cae4499ea8094fb21ef3ec6c0ea0953b8e3cfed95b17d87becad9f24df0701d2c2ae476c601e20152099a09179b9adfe2ae24ccffaa757de8018e4055debf20a3c95d899d980c90b7f3ac273603414eecd8ec6cc3f6ee8b4fdde12207c8a5beb2fd9508e20c8c711ed3de714c261b836add23dc42c697debef42e8eaf5e7479f924a5062696f494f9d3887a260dfb4a92424e9a79edbe52dcd5575c19f3ce476ade322310333fa969533089bf4eab4c685a47b2174e1d889af722dd275a12fb6938b42639994e9c0705d9d468e61becba05c2b2c3c227fee2890925b3144118fb9c19d0d3835ab71450daf7f367d17d4449948be7eba0d5a47d92e35910d2bdcaefa032074d040c7b7a01e6bea86d891bf05989302a44afa4b3ac9d1f00b93202b51bba6d023d4333bedd3e8c9b91c37e19dc289e720599f66a4aad3c0210182ff54abe078642ee5ad0c1cdda8121973d28ac89980815b4ee8c9e128a54a96b4fb87cd23fcfd8edbe96c35741026c589bdc1e5fad925c05c6c7beabea4be26e46e1b9aa85df099094ed6bd0cd82252d12cfbb5e568fc73e003cae97ae8027d08afeccc9665d4b1beca45c2eb3df4d4043be18fe119c90033d5f57d7dcdab460c1600b295ff66cbe790763716a1d739879e58e49f77b350d69502a50db33634fc34a98087960ec849ef9546d9cda5721765be5343ae9abe09d877f746b328cb1c25dee3218210115fa0076b36e36c3f6106fa0f2d7f7842110245eafe9cc76125a68c48d98cf0f21b2d75d6ba0af95a46cf61af64f2fba83f8ac769eaeaca354ac0135e1bd16b53f2b0864c5664c81b51e38f1f81e5a024b97fcb5040aa0687d2b540313c344de371586d7775a45dd8f979a57205407d118177d64aa6050679b57e753e0ca6376a5595f45b8ea2e369f9305045f97d11c7c2822d4f5dfa4198d8e6313a19b0f5a381e030307c2a401f6695d19aec8ae4c090616078eaeab422749e8a62e2dd37c1393022717dd300217e4db1113b5eee23e60e281478ddacd5d77990250aec7bdde246c722f0353f9e18c00a52db595f78ac612b9dc5f059e29d069e3bd02ce02cd603de35cc3b3e1d01ca87afe4bab96b0f4b88fa8443e281f2fd43009c89076922c7bc0e21311f577a0ccf2fe518b76b79607eed529349e460fe2b3a1d1d6905566a65579eb08f2d80760ff387cb93bdb063eb6f88fddcbb981833f5563a8e11e8538d6814a96de6a81591c36dbaa7702264dc7e243cf5563f45e4a7c550bdcb1267eaaf7ed2a5da0508d47f231b8a5044e729240420bfc4f431bf5a518a777892257435ed32f37b683ff1297a02b10a16a4e686bfd37337d0c11c7c899f36ad278f8d2e58e94b9011be89d97b362710f3dd53e980da3b94cc5a9ceab1e819f945f4c6fc840cf321f6cda4667a377d4e67c3c1e914dc66acee5163bdc12516f49f9f47e1c6bbb29bbc81a12df917beace2c2589e3ea6d26c5899bc32d77c020491a28280687d9079b6c5784d72a09b28d1d717355916dd1961d0b9f4f022927ef884314d9dc01821382a1e1de805739f487498c378cee4f910f2e92b637f5d8f7775fa6aa37f1d15d63b886f3c2b3d047037996d9d7ec8eed5ee2023cc99858207d9023c53cf80b8369db641a2b0af9133e9a324316cdad196ccde769ca458032331b82b428affab2b1b61f5a20bbbe1d7a329733c48a9d34840aedc9685a2456640b01555b9151f8bdf4c4639a431f7fd7c039832830d76ad3e310690c4043ad1430ece5a7b91693e585e6eeac38fa14fcaa5f4b51056f21a5a8397882868c476e50ab1569223750b6eb9c83e32cf53d167a3e1a2bf385757e7052b67b492d1347c67f082891eaa15de0c459c8575b47fd375f2dfd39634212a1590df81963caa13e418e34a3e9a38a9ecf684b3a6d9b3070a8ad2cfebb008e9bdacabce8858eb68b84b145aee71c0a10b40b6319052026c7c56249d1c82edc239980ec5f8882ad3a4ba822c3a86fde4c943876b601379598b8dea7640790701025f76083d6a0b678e4f8f9beae0b85c33fe2dfd6b813bd3f7a23f9b84f36b9c5fd5d257f825d91c0000741d3805acca99828d9d8ad62f6ccb03a2ee5470a848a910a249a1a27ec298253eddbad4db0598cf55541350fe1c675c3e76efc119b8aa8e0ebe306177d847c4b6e398747c7d7af363f3321e614ab08ceb74630cca4fe47de661a352f9bccfe5fea9534f06abb83ce307eaee01fe4f9fd4ad1f94a273e10a05a03a9397ce173b31d0d4eebd047aa075cdbdb91ec80a1e69652b7f7fd2853e50616bd29513a04677bd808620af6fbd1dd965f14eda2d859d4929ebf519f01f1c666f9849968b96cd79e16ed4b97405f8e4dc50a300e67091708f2185fd9e0605bcfe27d89cc58f3f35ad521d625989c4144f0ca6743175308a489b7ee16bedce298240cf4bce523c70b2888f805fbb1c01db3ebd29c680d9f71b9b8ff1ce9675e661e82a667208d7af0a75c003a75c8f9072280249aad2000b177c685998c002b89df50e20b16675f0d971a1ed045e8bbe6fabe4f63e7d77f5ccfa83d6cf6f1e37705480f98e6ba40f299a21a1ad0fa16a7766dbc701dc2a0acccbb448273f8ef55ed9f85aa058de41608b88ec9869a0ef42fb714c03fbf4189c91420292542a0f7091c1119137697bcb0b9cd27be6c080c16681ae00874535d72ecbf5d5dd84bcbc365ad2a13c59ede715e39553c7d62a275a1ec70efd283189bd9561f9adfca5b74c63e709b23fb3b3acd38e39452a1020c546255993f3ec21c01696847c023f3aab64e9ccd1ff924000579a97210a4e71521980bb14e8333c357de0be9d34baa097ff58f5b953d117d15623c05cc73da883a322cd97e202cfb0e9a392aa6f7fc3a66edb2fa2d7ef2579c755413838bef13f76c9ada8a6f16dd352c47189d35a117e4e7e3c74a779564cf1b26152a87f332fb03752b43dfdaf3745b5736fdb61fcf2fce84f3426e1193f9435a711ccd94a38225ff7b7920370cebfcb0891afd547639aa78ffc5ccb79867bcc4f62eb6792e6f9f803fe43be75f27a0d4dfa0f0856b215dcec49f30ad0a73300e53bfc7982452ef067c4b2e277c56719a453d2ae0f578f21c6698f6f5d3a08e881e01ccd2d4ec7b482e90cbb07ea80888d4529fd71868b1915147f9a8d07055f5529525009ac20a1754b867dd9f34a288ee88c687c0f5c15ecdde9901fa8d6e5d15263935614249cdf2ab604906e6ce3465b5f98e4a4c1ec4e7b67ea0940ccbe78ab6920fc59240dc4233d76361cdd178e25472d8dfddad868d52c42d8f8153629f512b99201fb586e709917d24e499df497f39d201095eec3ffa5c4231989710d8f67026d086b6bdbba5fceaf44a8bda8a385e3f78c4141b97ae160d615dd6080b27d9efc68975db5e8759695e3aeb0f50149ff8e6cee7ce593e6d88d3cc444141fce2797b1a3c819351f2878fe347d5f23ebde7eb3977b24f62467d371e3c789c9c30d90b01525d9fce9ff643e535e17ece600bedf90ac833395ad33fbfec8972ab52e3617658c3041a1229863907911da209d48b3c2400d572a2f74c71349cd2bc99e84ee0a967559d01f0f2323e692a0e2d6e626ffca85aa2e19e72daeee8b98aec512a7da5364ba0011decf86099a4128a65ab064a396c993bee36d78575dc33876e35d9a9fb1c9e239d0250a815130f51ddf51f1f2c8ed6621317921304c2f3b195889eca621f62d109baa8ce6a455e8b39e5f9a5822a49398ba87388c3391fba8e2bddeb1e94cb7a893bfc160af42ea0546401deddbb836c1405c96a9ffd032449954577b92151cbbcec78cd27fd6c7b9b87785aceb531a8ab65134ea9f101f9b72fd1f2b753b50fa83e6389ada74390ea780b68eb8834dd45aa355ff4052dea5a5a7576c47b59ec8cda01d5ceb924b5f8f58ece97f28707bbbe3ee03a6dac18c30227792bdd86cd04213906c57ef1c101ecc9431d89343509891d65cc2e05d7ff090ca322f61e8c315838af33c8f05d5698c6ba1838415fe5d37820169b978d8e702896d27949dbad35bee7bc1a7e6c3036a8a5c124e41f33397da94e1a3b5599c926e9f21510e26e3d7009fc8ed2462b4bef29340ae4aa6f2d573052261bb68240071829c358b41586177750bccb032dd4997a88dabf55e4a4fed01f2cf398c2beb3cbcf6f3a050476be33d297cc7e69e89a9fcc593c14aa5b86c1444e6e3e98b2da029c6cfeff37618952d10f7446e89de23f95894653dc99d5874692eaa8043d237fe89ba59c3e6773ce0f46e852fa8743541fe7d4a610706ae88c08816e06a95e483fdb3255e9ffcc9082193495b2aa9e4d6c0238a2a0d51e31e7447d023e909eff67d627ac7853f1ab9e30c920c38f2d618257ee324e09582b60ce8f51a4748c61e4a89d25b1d3cb3adb2b6e69fe5f0171842913f2f0b166e98afa0909f0617a09478124d627f092e793200c104f65638fa53bfa3fddbc45d4187befb7576a8254ac9270279b6d946fed6157a0fcde76c3031dd0a948f6200be58c6ed2dd43e3c9683e7832fb1ec605ae2d68fa66e01ea108c6b7f9ef8285a3e7fef1986e1c303508d57b2309737fbaa227dedfe04c560bc000fc9cf478c383ede610c1fdd372e8ac4d355e13fb25027251f40e72a5d587a9488bf17f1d93ea884063f59b90683c99401ec6a4a89c3adc2bf7886fbf0774b1d3590fa45ad68f294db9622cd1473cc60d7e602f0eb44fd1dc03d1eb96fa6023328e71ebe23d13cd802217f9a636eff2098709767fca72fd87b6683f7ec9be71c773b70270e9f83d12382dccac52a5521fb2e5dfce774c39dabf0f802621a9c595e0e6e6f675d14d6ea4e09fe800bf99e6fb6690304c45634f07d8ea6192303cdc99a6038ec12bda8cc360cefa4a90604f03a2ae24960b12ef14777a29f87a10e73f78affc0a7ec6cdc4b3a9180fea1c7ba2a357de78138c5df964af1991e8a1fb8401d1ce61cd2c6a46132410830a5f1a3abed5a1eb4deb120f1e5ee7a22ed62cf2e1bae71a825df6879a5059688187be639db492090a977e020f12ddc673bce1ad5758e79c403c9271d8d9d03f69c943c20feb9ac74fdd7ce67745885490255f608fe88012919e89a722ff4871d96f4d33c2aeca0ccb785e08c2cea4500cb7e8b8ea7947e2fcc1362133744d9d175f623682059b15a2703a7a02b0e8fbdf5f68537977f72faa3da956f5cc6fac511066e73f572a8078d2566b90d26f9d3db6947b167e4da5f1aceff31be20a66f843f0370fa870359589293093ca99c59507416588ecf0a63bd5468e13c5c0dc63cd1ba4cfb06257b5731b4b06bd0c87f9722569c6578e3a9b923832ddcd2993bc366646ca83d7b6b87a7eb634551a5db7ce6cbdcde9358655fea305c4e14ccd5cedfb78d793d78589b8ddbbfda744c9f338205654347228e301eca6c7ea547488f2ef8c2c535613f90d590476601ff140d2856b7ad816db59c72ed6cc9a79b09da5313edb4c044c9ddcb6d5ca26cb065105715041869675090e17a1ee3f75f09f436fec155f7957afee555f7d331c983606f034480ebfd1412a4ae2dd77cdd6dea902907b297706bf4df85dfb82f44da996ddf616d8048aecf2f356b5765aad8220fa5e659f4d62d06fdd69a9df3713b8580c13930a9141844d6206ac68dcedd81c80489eaf3adbbd84df5c6c5defb13f7acab13d4fe9064df90a1c2f28f72d0bda2b1f9031daee129087c7db068087fbd5a4c50a3d4784aec60165321fbfffd7ff97a718dd61af3687547d9844a6c0a6bd59c6c90a0d0d14eb870bb20fc3a9c63daefb56bf069b53f4f2facd67f7c207725b10ba6420b0c681cbfb3d7582fbebb3fb4e8f08b35ce53fd7c1dc1581835315d283d252f77c0d0ccd2aa6f4e7180be5bfcd0ad5da82e83dac2fa21cc02aca7de28fb1e57e1697f5ac5cb31e15a3af1b2d6a2e6e00ccfa52e23dc54dea7f684a3a3b6ca52281652ded8c05d6b728c8f9391822baf69e810655ff8dd36566f9dd6a63ed6a0b6ea846e43d946165707930cd93c05bbb10827cde70c298bc2a0565781909681feefc5069af6407557af532fdd9db0254f6a91d2cf3d9f2fc26bb2deb93ed7de06936b0eac316950b83be9a2b388bc8ee3eec93f329831c5e6e3a2b568a1906dcac65dd1ce4387a459ba32ef1d7bb1d4584f06dd50b6958f3f4004d5b9fc1d2ef7911eca68eac850b35b4502c783ea939aa929fbb576ec361db690140de9bacc473acfada300b48b65b7405ac2ecfb3277ab85d16b5495f661f73fe18743a6c7cfa61fde6bd14367f41e4573a42431ed70d3c8b247e1a602b2aea01febf5f09971f9aee264b0749d6f406b9315c4818f7cb7a6a00225167c4231b8f71bc67ecbddf9374bb0a2be71b8b99f004ae11a7858a358b5c0533da196502b06f5e9f87d7c03344003738419cad5546bf5eacb52ea29ea0ea218456ffa591f1d46ce689f5c190be25f19387f489b7e9977a610e273d738e41d58d6fa75f417d04b2cb6d9355a2a96b8ae984ba341e3cf758dc5209dd046fb9f54dde53cd5d1caf4bfce6ff7909f5def567f7939578e7ae7cc25521b74ec867cdde3de7eb0df360c0aa9441591859eeb6a5accbd250826f8f7ebb941bb4d1f65fbca562151ca5e990516abfbad770e2fa59684c850c5c6c620d0fc32f3a52b80be0371c0ea32723ff38613ec93ac841ebafbe9770c83d37fcabff3081c28fd2d597c84bd270412165a55ab4e6c3ec8900e21d6a669b60d578b596ac2bb891b070846b4729ede1faab5894c45ae02f822f4c216642ab969645610fc2747260f8e5f713f5d621280376323e67d1181ac6f3fdcafc8616ad3c3fbb8d91972dc40d7e42a031fe7522bee1b6bbc3481f9697f4c7e345c5eaaa1d99a7a15dceb82a2d1e43ed59ab3c5f18b3e432136b2bc7de279a39029a5373aceadbfa1d0cd692bac08957a57fe14cd09c83ffde82bed401e270b4b07e3ef2903ee55c4734a99a6dd37be21761cd641cf6e0a4adc2aae4dadf17454a4e274615e10536ff543eb41c82580a31497080ba7d8958a4537cbf363aded5ad7bd1198199bb12b792e0e1d7cddaab1288ca2edf857af0f3e0f6ef53e5e5ec73805ec161b48ccaae4d08c24f8c1ca8310360ec589d7286f40fcdec2e6bc6faf365ba1a6ecd2f14f47a6dceab6a8d50e238cc68c6444e774f72994245afbffde3a10aa8c61e534807c737a8f95340d2352548686d55bfa1463f4c83b7b6b0671710918583d73bd78ddb7b9443c3d936485c7e73c38033c79c78da4d8a798b51cb6cdf9619353d66db8b6be086b3193b2ee584b4071b4d4f8cb722ba3b89f82c2e4150aec635abcba7b6d197dfcf10db1635c82447054626af51c275b5a542e251b39dbb0ad2b666af44bdffa0c4485e639ff8eab7be429f7581a998e8f27fba52d512a91ba9288c14ee32ca3b0068ced7864969fe0b7f876a67c4f6aaf924f84b61f9c4b331be482236d45ad2a3ecd5c8429634a0d07d314d1d54bb6b5dbf605beae2367843b42bac6cdc1916e8441ff4ecc1e56ddb8e6934abf3cb31a54253da2b6afa6bd10ee6ac0824920efe57d0a9b8e45b32a08e4f88a370f8ea53b4b833e216457eb18b08fba1e40c8098282fe0f74804f22750749fca0d1ae43b1ac2eb8e5a114b183fe1dde04f026c2867fda60e5ad2278fe29bbbea582876e393ddae49510452b4a31c2528d58b9353644ba3f0dfd4623833d4958f07f4a6f8a34e8967444163935429b714e1bee5caccc9d4298d1e55db84900a3d38f1f39863d4ed9019b0da0e6c98128a5e026f0cca63c2cc899dfde14b843901feb227a27a9e0e62ea61a96f9c8cda57d04c5535d550838d9ea969e6fb079c43ad4c771edc18e03d335497abc1372ffb42d530d0ed5331a86a070768701bf698f8cdbe7c8b4628c239b3b03efbde7b6e67d3ce2fedfd2da0be0c465683877b44934bf74335556a868747e7f9696aaab9fc598f81893afddda7daac918623eeaaaf479196f5bb374eb06d5f1c870d4b5dc0c754bdc27cacf8b4626649c7166af01afd203527a266d52de28ea6212bc089205bd3850d8b5d25827ca14145f674879a4054353b5a9f033dfef1596e3e4ba5cff29185b82aab9b1d7782cad9427a98f53a562fda53daff370beb5d5716f9795510ef6677206c3f23ea59d24a87a39209a98a355785f0681ebf876305e52d0dee3de24d744512a2a17bba6027e9f49c4aeaccd76806c052bf6ecb51ddf734cb5c154d8421c724c4fd37fb9aa0bc93e7cced0987af2a07fba33113032869617596348658706e4d000823c6cadd2218c3caff91e259fc55469f2717895640a9a6f726ff64cbb5eb8aef50ce55ece3da62ec5ad2542bdad5e41993e21306823811a46a3b334b9513801e3879e2d45d7904659bbb36a8ae9cdb29848564f95b875326097d8054ad7bd8893d10a37d4d5b8c54671d3521c400d8db1f1434375a64b779b0675c8f09f6b2d56b9eac7def2a0712d9489cde6e188aa6645ab7a2830dbc6e2c0aa9a7268d84099835c906e31c9ecade2f136c612eea4de05fcebec161abb1a606828535cd8f63f2ecc5e8791c79618c7d6e6b8bec52394a71552825a494e802b2c41adbd9136cb22f947108f52c05e9b37df6314e974f6752c4b0371fb30113410d18d31f28c7b7a6b800cc557fb214ab35c64b99463ae7facec6d144ca499b752c598756049fb9fddc68cbc1d9290199a901fe9bece4c5481209babb5ded5f0209065bf36fd44358702852366aeb6e25d392dcdce49868d495b7c7627367d7dfd45f43de10fafab0ccf3e709a4c94005196c7ce61fcd34a812de1545c58459d2f089d969e1d50ce7db4c53be94a0881c043b2ec7e56e74c1b5c4e408bd2bc22ebe9c5179912abd370852e26695d45dbd09362cce44e139376f3aa97789b0a760874681d474e136c1881a85874b38f75154efa6968711d2102f85e2b6b69e7147a99dc2adeaf86f9c445e1756690a2517b9f78aaaa9712ce967cb36791fb4ec4e41b2dfa957e991044dcdc9ac87556ba246de202fb79a43e147ac6dd46d0a64dd41a2c0c64b74fd84f1a745690a31103e377b3acd7528de7b19cf2825cc2c26e7330e84c3f08922ad9ee2eea8c360ef29789446f11d0f574013457ad83c3925d0f8fddbfb15526708ecbf5b2b1794efc9d11c03eecd3370b696bd452c3c01164f736809aa60b232610c15e392d8b95c28b22a5080ea4d22de0c6abc9109134ce3dad49af84d51a1f9aacfd60fbf722580658ef6858cd75cdfb1aae188a02c0287ddda6afa94cc6ba6199ecb315f02620610b3bb713e861ee39ff0381dc577217902920053d2e0f911b6ad1bb9d992753e198eaab8e69adc4b9ed8f8564dafca363df494b169d86d516c32268f1f3b1f48054f6c3b1c7b9dba82af99c9906ff34718f60920e4484820f491be106e14e31f425a3c489fcf84354e0d1e427e1e617e7e0dbbc52eca52b6e0c9356f01281bd2633164cc957198be35f1a434625301dd9b21efb7204c8b67a4f7afdd7e3977eb912bf4c152a7032e4deb2ab35762ca87ba25fc7f33d68934438e196ab39072774bad27d4b2bb63cb3468d4c06012aa1c5d7f8a450e1a2c4503c45b066063de57107058705655fccf1df825374d6a90516b766181cc507a9d7be2c7393f7d36b785d575246b4313973b596327678c91f23b28fea49b394ff2647700ece7da354eae9dd00b7ba60b4dcbf085f01c87c5fc26cd9816b864c163c23a8e18169cf6b522037784226f9f81f66583f91682f0ccbfce2f2b6ecf8f251e0374c0db733df3cb78efd759cde398d25c45665a15fc96fcb21164d40ca59960c20501bcfb3cf49894b08565805758e6c3d7cb74fc9d41c99e8ecc9d4f86c5601ed3c61bad7b830ebb6010beae9dedd9e59d56ae434dd8a4c5674f5797d0a4d117aceacbe857bd3b94d7ccd7f5670ebe2e980da0842026a0b0d6add9c879b08a712903b0a554d4e69f27d8280669da3cf9156361726f11573878632eebccf5d196c9ed4b5577b81ba27f4933f5546b5b3e7ed28ebce4d1e88840fc78cde8767f6e298a680807a6315198ae99e01ec1303b60bab6ca320874d1a9d6b390b50dd604f932db543181c589731d0bc5b8060c7d4b118dc90e46f83acc48b6061d34ef02d19f41bc7ca922479467587331a9b7c743eae639bcd913c4b13a451108734a894ee8c5d8b95f2e60b55ddf0bd2b8e24c74a68b2901c1ea61845a43643947abb3009014066de070dfece2eb9817400b081a93995c9797857175ae6b73a9a19ac1720c09fb6e83bb325041d9e2da5e0ff8511ecddd130e0bbf8c74eb205a3d9deaa6cf6b3dc21c98f65a93b436736e6293c5d2c1742d4d92c62de654953b001a90c55a832207ef437af08ac01fcecdc90eeebeed5247a160306d0e1c91c2a7d801c73e6ae9efed2b06067f8ebb1c0608d7e96ab3b3258082b733b58969de20020940c02ee4a9c9ad0a3ebf192fdefcdf01cb0c57a41a4ee66bb85dd2b5eb6ec633c19eb44019361738c4e3666b0ef2db11875273e66b116f19c6fd2a652663f1b1b91b69e828c6693f19363e02fa6329d16ce90b6b4abf85d2b2df7d37b6040430538f95cb39c2801816447731b19dac4e4bd5171f9abb614ac992972f1aab7be39f81749204975e6b67db6f9c27a79b81f24b5dafad13faffe602e2c63b726ddb0ebe125a81db154d2c75a368ce9d76f87bf5bba117af05c98337067c6efca5c992ab7af40e24dff57a3f0788c2c072745951a0fcae08c2ed074d4b1c982e2f056b2be674ef7304218ab4cd3f216f72c4fd5ed79cfaf7ea14631bdef2aec621d068697505ed878a2eb93e5b8d3dae6bf258fecfe48896e9d9b3d3f3cc8196c25ce7ae81ef994051d4373c6223d63769a1deea47a35b67b0f92119c802351da5107b3f0eb5035722b9b0f04ca21341c73e2c79ff2aee6e9f3b42aaab08b204faee0f195f97159032fa11261d62dab4c900e7347a5e4355bf8d816e82682720cb0d5801625602ebe2e93d53d2fa4ce67d76eaf45937b561159dae0bcd925642fdf6b735e34784c511884cba2dac6c58903d30ada1587906a5424d9eff25d57d3012e33fc9da758c41e9549b55960a6698d35de786db5a658cf54a2f3b039611ddcb54ac30c5690767997ea4fc3d51e221fc368619e7255c17f9faa35c0c75f1db8275e9df309aba513e70af97b56031ae0ea7b012cdb6034251c18b7f2c7771a939f9f45a03b040c54a65b3b8d227b07e9ce97aee6dbf1a0e0e553ec802daefb4e295ab0eef73634736f80c5612e2f329b7bea62df1d5a8da121e5a6145f7d4a3d5a89f57421027ad271b9abc63b4c2c61397f6efec26516a3c5aff93cdc67d75f249054ce25677e05e7a3c569b0fca9a6d39a50b530a0b89d7742bf84e9b761a51b7b931e0bd1952180c12f680f08bb2065107dfc554cebdcac78472003ac316db9b4bfd6e32bbc265dabf728c2e1d987729f44b433780abd14d3a21bbab98854a43277469e14167957f2a10e9845761ad6d74a59e4a8575f48e2345f2fb5107366f0d71bc8c0316471b2fad186e34009d9ee28c7550be8b266a49c0b6ebf45fcc51afc4efd08c1f6ac7aa4699593b29eff5710b22d14d9075c5c1c2e957a5e0428922e11c454d70e0ee4bf221dfef58f32f5ae7cabfba8e9cb68350f813dc1d4ea47570e82081d4a33e8a7b5807436b610ce2fc1dabf3404ce1b416b5d700963e7bd12ced4539078b27d9863a284e80ea5f4321b49e6e9de4cd0fa1757f712c722f79198220f8ee16e991300a4521739098260128f18cc7911cad814e0858add555139c0cb80dcbe442373cc55d7bf4d9e62981c5a6ff987dd6942a0cab935863ce876ea0852a5f9e5b0e1f9babc8f2137f52f6780921613c07a82fb63120fcdfb20551d51ee76c7e6face2576321b473751ca9769405547387856e130ef8cfaa618029f0bcd49d982cc2b83cfe7064d869174690f15c9b7f4c066f928027da24d78fd3a3f08a91918dc294565a914d9832b1fa6f3eb7f42ccbe95f109258031c9558264d354cf2efafe776c4c3a519a03dac50319bc77cde37844a9fbaf63faaaf172d6ab23159cb7587312a54a2010c0f67985045c1a4d85ddd9fddcbdc37a050ef134ab196ba02d90d06628726a2b158bd7bbb4797635de7091fd5576b867a4ba970fb37c58e5032dc9a0828311157eb166978fa5c8aea6aef8fa76a0c1a1f5d9992fa7a6483c3c5fffd8c71275772b873d6982b790811401961d8c3f2a9effbccba527637e0b3f8582c6bf43be0578c731b80ee47c9d33dc4d50a7a6a0431003abde4dfba2e1ac02d9077fc93db058fae34769d632458d97c7f4e1ecef7f4dd8a424838d4eb3cef4aa078af318020fb15e0bdc41069a4c6f9c503e2de1561236df295a2f6e41d1deb609aeb1d2f55ae276e5db543edaa3e99af4dea9797efcb789affed4400d9a1a3ed7b6ede6dea60e82164d5a2bd1dee6ebce3501efbf886b27b15441afc89f0d4bbbf06024caabe1a610493fe47ba5c29486ae2ed509aaf63fe7dc72c6e0a9c8b5e17d3af70495376112abe1f88a49c64c7f3b54f043201f5b816a08903c9391d0559c1d995a78a427b79961e7645a6bcfb0c4f0714d9b7081fd88eb46fdc4db2ddceed2f4acc24662899b71b55b1ae310cdf2076c81d19de686b2f9de09d1a3d0cbe473ecbd726bf7dab2803deee7b9e8ab64da61b3f246176c22528d68788449a58d16a27562944f7690d03819f19823eb8f1048877f51924dd158789bd7b80daa11d34ec026b4409c8ef394463c48993da9a4b6245797d468081619166f2b3c8457658ef1b85de9d88529d36d4010f5664149f9fea6409c026e921cc5df4cafac31d631aea1f42f3b14a13586219e53faac8c9ce36bb54a6d9595c1ef1a48161b247751176c9be567a534ed454b2222d463c4e83b19b800316a41816e9f4cd164567aed76378661c42783382c465185f909457d94bc44b87569152932c81095edbc0ebb3e4a0c413d3f519d8959526b6ca5288abf7f7e968c7e8ca5bc839039399458cb1ae716a050eb2b99dc180bf8e48cf28a67343ee04118d1d3e141507f78a365947d19ca1ae5429ece49e84772d66932f61694a09e998ed6d8248eccc7ee4eddae4faf1f03ad6b7bb37f84960dc580973250232e135f4956b0f048a73817a3bc99898c8a3c325ddfc2089456082eabc1b74635a00f82745a5675a84069b9922553ec472b55bb99cb0b7708e162a0e701a27ef6cc9bd4642d09941cae1e5a21bf054b39078babcec04fd3e2b8bad926db2a142e397199e3854d658ab8979495594c6f5e4aee5a16d4a3f0c991afd90bab5d63a5a61fdc31c078e5c30215266844a162a293858a4279555e7027149af44e0ab67779cf9ba9f21086c76077769c3ce73e18089d80c875d56b6e4769354e83f44de7ed71daf350939be319bc5b3620d25ddf6a5635229fda12a30498f9fb54b6a6096daf7802ef971fd28cc54c5ea8b39a0ebe6c2b98159d334da9e3ed715aad578275dcc71961335231a4ec262bb1a1579838528fa245ca1c8d26d33995ac3eccaf2b32bf6803fa8fb6392f4b10805c59f73f446e45b147700d2534b02027b46121a441f5a831cd92f59826f0b169e62ad53059827a1d1622a19482aa24b3877fcd0e31398185ad61c4c1f8cbbd87f1721047f881e6b2ea15c0cae8ee0c34c4b3b2c60ec6f4bfe93f51377de77a19ad365a864d17904da1db9828c0973e52dcb235d3f241139de023621cee61f34234b91fd9357ec04b9f6898a77dacdc491f2e4ab087bf20ea259e9e7cef800592c595c835ebf3e284677f30ca5f3b989f34244e46a220031c8ea02710a568dc801b8bf0f180cd69613cc8220922d30d1530d9fcad1145df5c3c67f51c8cfe592e47d37bba711d2ba21ceb3d410b852eb2a276a5990f673fe67dffe010e66fa2e2019dee21dc855bee76920913f0423ea881689493816ba1b3d07d6a83b4b6ae7a5515df1aa56f2a7c983200f992db7e7f3c941b9e1f26d9adcc18d59e803feef9fac3159c325de1bc2c59c60761df521cd3bddc6a123526cf6579ba6e631c6d4e85b2ed2462166fe9a35606677a5d9e27c6b3df5ca730c213d75328a09d0d836f1518584e063a1d643ad89d93c08f2e3a444baf9041d2f0189b61171ba3abfd9b734ebb53007c0fe19e2a6d2f5c68ce95e4401fb04979580db66b26cf1dd32a59380fd58b5a1cf72f2e4f55ac4ac7343cb4f7912669e3036679ae75c3d35f0ec9d26909c1eddf993ac38e3b7b68eb0f7fc0b2d1f4596a89e58ba9d2bc7250b87e5a8957eb18ab4cb4c4bf32a76136c0cfb377342126ceab6b927cd95dafdcf110d7cd1bc039f145010135d29f979cc95127a4805055f69802bf4ceefefa7582ebb13bc848eda1ab76ccee29de07fa183afd27ebd68ddba61a1d913598d4f56a892a781cce1b6083c7546f1c8978323780475d5ccbf1d34fa0d44166b39cb09586d867c5898716767dec6fa11c8fd1aa1b300122e8ef116a5bb8271a85f5a9b8b2bfb1f4541d2878d036a145352c8ee2b2f1bdb27c51c05e92af58f74e15f446a92057e1cbe7c8d603e76095a7341b1bd33f3bbcace5a3ff525fdba57290a3efd4b368c56cea692ac5ff5d814f2242a33aa89735ed49f9f53734e73c40af8dc55f74e37e096b55a4ddebde711799b0765a39aca43fe0c14bc3ba502f6efcbc55a10b5b0a0d0ab1a29a43e794d4dc4c272382747effc759d64323073e43e53ddc25fd1f95b15cf727e2ad61c504a5d0b3a343b2e39d44eb2c429489db0919b180a5f4345a8f67ae95bb9c80531e092d0852a114fa4ef43ec15a734c8f00a046ff2c6ff35f4c865b72a8d76c35f3d56781bfb7de4072e468cb9bd2a7ac75d2aa1b3c8e11be82e866fcec547406eb28e868a6f1a8d2765b7b8a93341abc47c57c4521e95478af28edf1702e5dd719b0bd501603ecba877574190cba45d864ed819c025360704bd9e5b24655154850ab026cd2939ea5c07ff4eabdd1f6420427d90bc3096870915b5878d9144726db11925b90aca02e22e8c38b8ca606d27c4ecb66c1899d45bce47ed9daa55a0268724e1d976bfe78c785734507241a6c4a6dbbb55d4ebdebfafd09df643fa8e9acbfe8f61a6ea9493c6d5d7c964222735bb5beae085644188a7bf959165bd675262e01dde44a2a56e5f2815881a93227ecd84fdcc64ea5eda8dc096df83055b824ab75ecdc16179313f00b9d767fc0f1e4107bae7a7328b86acd2b1fe7d0f93321d80fa03293ea80596c79c9cc534de72aed870b37e72ed5664f3c9bea5f9026da43aec9a67e09be1f31cb7e034fbdaea578299e528ebb9001626a728406f3f560983eed6af5e99c903c2f3296507e969917b5356bd9ca7d4020c49c01fd0fd03fe78f88fda4062c69ac0f408cf02e0945c8165d2b8cab18bb5829c522d20de4313e52c94eabb42e00ea08ea8090bd6f66132cdb59b544807955f8fb90ac66f11c800f431b99b45ea4c708016196344cb6144a2609ec8689d8a7a0d9aec4ea67858b352d95b5cd874d25a0c4beb33b74490afc8a03c7e592f6abfda19b8d694f8666958835d696e738cddc1185e9427aaadc0a0e374692033303a3076e0a778eb7b9a8ca4fba413e52d6dc18935e9da0c928a5ea88c2a12f881cb94d6c2f3a25126866eafadd964893174d263e585189032ed9bd326febeaf5d08e3f7b2614617e0efd4f3da0ad1d1705b8c61e7df1119b1599e41ca6634ba5ca0172ebe234d6f60f669d478e6ec153560f78b11c9c360d631b6ee59a63cf06e56fcaed39b07c4c37808c2a33a06d02d20af9bfb61228b4eac6abf4bd6c60b2d56549e2fe12f299e46681db9d9b6a1216e51307597b96ff7911f6ce357c0414ef45cc048c51223d1c7ac5dd2a9d8f408b325e9f9186a2185fd1353213a6771ad24bd5db88c8c3cd82363a21cbdcb5d2a766146c11a8e32cf89de24c545f9985d9f81d2c8dd5bdf4467bf61bd9a784fa4558ed66ecc7338848fc4fc3759e30d3519e437d2064d12d7b9bad8398d7cd4c9b39ef2b533bf043b04df137ac15cda7b88c591006a1c1d5243ef81c15714119ffd73298bbb8e27381a5c93dde5efbc1c65b1e32dc1b4a15a089ead585ad83ab00b8246d75e8ae34f9354c238612a6f191b810fbe7d8907552ff9cef8336655bf51d8bd5fc45538f787e9f75eca26cb84424b405867b46e541bba53e27ea1cd7af9646a216b4fd82d8e112d6f3a65f9ce7d8acb2b8545c83f9ed34a3a079e3c67e656d809203135dc5ad60806fd24e40be7c1be45c37a018e60119fa09a469bf4465cf6f781d303f9f81e7a1c9066a1dcf6dcd99e429615e2235ae1f63f24aaf484d8e4d69fd3b45e092bdcb9f229a919e6f29d03514b2ae6384ee9288a737fe0b94c338f6552dd5afc7d47e9a50e730d3f8ddd7e86a783334d86cfbc73d65e954a19c71c4d1435446ec5fe541f82f07ee944dab869ee2884bdd56d39d35b7ce9a8564aea7dd0fd829e8bf10bba5cdce5b314a4e0dea7732c743dbd1dbf335d49b6c1bb904822700c431ec729bfdbb926effc61eb468abf095263d1e7fffd3199c380adf25ebae634104c89992333db6a2aaa81cc37bc57da3ec4d524ecfb4b905d2c1317dcc11f6e6444bfb00c91491d35964da0c97c894da8b78ee5592c8caca503a2187128d9501f47675edb116805b867afe5cd687a2f6712bb4004dff013f5b47af2f33d9a5395f7365528bf877475635470ea4486f6a805974b7772dc24ab67c2b5a23614964344fcdfc6dc69900f4c356ad327b94ce0e8c9751da7db15258dd596dd8373ebc89a5b52047eba25ad7a2d23939e1dee0db3071894f7ed566234c794db450ca9205f1f4beda78a34473268b69f491b28ba5139bdcf0dee7c1e02261c1818bb6bd39f34082ded20dc06c476766afe408c3c78ca8d2f2ad3206697b8f97b0c7cbe9b1ca3ef774c7f5107a125385fda6b74517c8b205a401cf5099ebfd2ea4325ab22241861c4a433371c3cba206884bda650cdddfa17b2f3fec6921c6e73ae2f50a577fc7312a112caf653e7efb38f0df499baf14cf7d8e9b8df7f742d51e8cb7e51316ea877bbe19dd2e72b210765baf0fb915bf804f01c12a13839fd3cee4c8d02d57be6631d06d03a61bd96385dd0a2919dc8d09b2f78d18e5a331ad7e09b12ee775511017964ce86cf2051fa045","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
