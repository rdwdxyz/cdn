<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2158f3bd6a496fb514fa24259e5ac2ad067aa217412c85918a872c9b71fdb9763a18a2cb33ad8fcb539a8041aee54b64db1ae493de2f5f148fe3625aa9514180f97ff51fc4c4b4ee4df238027060c3c38362584fcd4e80de1ce79ffbac7766a6ca00da810854d982d6abbc0d9f1fa31a86ceaecb62bd481fe5d427b13d97246e32ce669de589cca01dec5e4d3b11e7fdaf6a3490889dd4209e102768bb501d6847dcc0e9f466b6dd1d4889539645104b6295a0ea645cf588de8e837cec7b125a44fc58224c8752d2fd19c21b1cb776d9988d46ff1ca177e99f3dfecb8129bc04256f895656e072af53c49f33bf8a5afd181bb646b9053b406e12f4ea8cfbc6c25e05babb96a6556b512f54e80a357fddf1c750a49c6e950c0fa32468ee802308cec0b2656e9f582cbf95d7e8ec35e8a426d171e611dd8d7d04478ff5bc5b01d4412858b38046ee3ce4ab07f6de3904f37f894235cea072b6f2cd0dd42be08a62b290c8b6515669d19ac54a791d088e6862d8434199948289616a95a4fd3e8d8928cd4afe589918ee812a767eed1704bd909ced9a445292dcd79152fb7dee4feaa316696ce4a26cd6ffed18031defce4c232dbb9d0a2d2da3682302cc940310dab19b231a5600e0699f030a62fe7dd2f1f074182ddd911f3ad2a5faf7bb6e2d1a2fe98d6667af23e446d81d53f33f7942a96dbbddee9587c8f9e93aa32cf51ed8e1fe832ad394be8612ae6e2390eb683af1754b11e0e9203e27447f48a7b2b9162cd4b02c1e157119768190cf88acf3312160af05b726f017bb2cef8d8f6638851f1c8c3a602eb16cb11014898e4ec0151d38bdb05d467c7c24b7288265a0619b742c306785a2afb48de3202480127225e74df365f47e59547ffb8f3f0b20005e36b1e285dab15bf673fcbc0e47a8cebc09e2a292f62f3aeb37f70960e9a8271a2d1c89142658741a6754616003c224912e4f9942578a66ead59d7cd8e680ead0e4730970fd6ac50e9595cfb0f78dbee7551c00548a8a0507eb7b371059adf34ef0494fe587a7a0fc5238b0699e67715193da7b8b4898a7ab880d254813da2efa93d417926de4fe8a6d924e34c8fce93579ac316c9a809c8833bae8bcdc7741a18aee4a0b85cc300159561422c58cd5ec51c06b1e18d1f387ac2144ac8d278c63150eda8d249c35d4f3950528e0c7626550a5b1efc64d42db450bee807aa3b462ecda9a672d0c50a44de453309f3ca5eddc02fef5abd4a7e713d1970442a6e616e41c08828409fd110812bdddfe1317216d567f8d981fb466f164f277126734d071179af42b4b1f85dd8a7bac131b4e175f1d45c3770f2c306a5b9cf8bbdcc8162a00023716fc7bcdf98ab6933aa8e4adaa127d9db065b5129506a79930306dc7eb965751d1af1f6aba04238b6d69bfef02f108e889376b52b8979a71f8c19279e1e9fc364eb0abd11eb67d0c3d7243e9ce873ea9ae6d0385fc79b5d41585fed7030bb547007397531f299a0ce311360c05672b4da001eb32b69ad751904e9aa133294b6c8b980b9ce9cdecab52dbce11f3dc7061bdfc258a2bddf4edb4fae9fcfb8d088dee2e4ceab2bac538ec0f3db6262582bca5fcec57b377ecf4881ccc0f813054a87d0910efc39d10fddec90658d2003c48e8c232b608d5d4c8e25dc69221198abef70dafdab71f96a2c6f2351f3a8cba718003b0b68bae53ffa5fb78e74be0960c1d3bdc381f5d67f35868adcbeee5f1aece95a390e2072cce9928b0b7da4e65a03f6bc50d1bec55d55dbca431564bc59209cc1c0bdf011eda518e0278c09af7839873a74ac18f7580c41e006e1d92e78d68faa5e7597496e2797ac079dc084eb8ccf626d8033b9a9f35c5fb236e06e8b87feee21914dbb9db08271c118daf37dad1c074bae5eaddbadadf3dc8bad693493c21deb341dc23323b1bd1020187a3661cc1507f7f3f9129c009f05410824115f6e77211ad7d7e52df8ec310564b4075eaa8f7e69d0811b64caf62116f22418b36f0c1bd7d1f7bb434532ec4ca2e753890c97a913e35755bb159b06e343d072deeed6d532869ed90a2dfeda9b65ad46daadc8d288cdec2dfd9597a61fa12d17a8c2dff0df81b9b5ead1e3e75d8940678521ff0f8545f44acf2c7e0c90c4b5726359b4013e6783d32aacd45765c3861dc3b8c2235fd43ffa1a62a19a4406d0619e6d9f97620e83d323aea7d6ebf089640351f1f9c58ff00b55d3d3e9ac80017c70faaa13f5ecc7a40a8d90001ae94fd7841db5423b70cd3fe2a2ffc3bf981e4501bb83477e2679af90b6a0a168dc3225c95c2a4e86aa79cd696d8465154eb2ba7c24d8e9cbcc4d2b3d2d146a66bd48068f94f1345da937c8d1a55a50c8f5790b713cc4d4a65c5a46a1b78d9a438f7eb0a32925c7b63b752908787a04236b4cb4a6edf7f2ea815bc46a8f9ed089b1d4272a537dc60975ef71190be601da60fc3ef9e9843b12e81405b5e0ef2389c2812b83e2c8b1f995a26378bc8094f0dfe4500cb33b124c4bc044ed64e38228ef15a63302fa54a9109141172ea31fe810e83449f11a7f0e7b1497c3a3fba2dd289f686c426336707d0c692baa8c31dc15f525fd3a4819c77e66667c4bbc3c38d8c12affe0e056f1be25cd1060054388329badbc0483cb286de8589c835a4b875b7b6951152f364a59c3ab6ea6da0c65c80b8cbc922f79445ed352b14d638d0f31393084f16a255c191c685b102063c98bb344efa0fd25b2db190fc26ffcfdbc24dcdc8042d120abe6eb79e729da98840bf1252be6169ddc58f2e6fc7cb61664668d3f99e2ca2f598fbbbf331c0a1e5fbbea85fd267e5bcd7d3adac2b26a3417a48d856d8c3ba97002b0ff887fa4819753352a0aafb20a3ebd2a1cede26b144ebd10fbf710c6c9d7289c66720190b0215437d54dd8d076d6870c4bae3fbc693481886a34a01f2c7bb0cfc5df9cec8fc8d7ce2006ac33dc7ddf7b7b83b2bc675a539e33b392749dbdf2256d39d85df23df155d2b3741ec21f1f5a9934791f8e13ed99c5a565dd07a67af3b49840fccc34c65b97d9b9cdfbe193aa50c50f1f990429246b7352252f5efc23375b3939661ad19276813422df178b26b7f229e07ba4c9cb4e84f702710b4a44b6e442c5911383c1f6dbbd59953d53db3fc6cee6e52a670e7547ccd7742bafb2579b441297720e217067064a18ee98035e8cf7a54f9ae240429336f112c00edc7a5832a72c292314b3d6bdaedbee031981098eaa7af6c75364d5ccf0ccd14682be54969e7fb967c114ee50bd09a42a3cbba1e849f54bd1129534ef2c60ce3900984840c2a6d77c3ffde495261c78cc5261717dbdef6c0e7d131c0f1f47b1484bb03dadc15717bbf3c9e2bd4ef07025f8ccf89a46723bb19edc11427bf15159c728c08d7e470a238836c30df63a517fbfabb3756e0e16f8e73866586d7defe5541719704c0d9528191043a3b62ebe74ff92ce3664985e116a34378da83ea9f5f26ffb1249562e9119d37c42c666c35531ae950c031805bc82cbc09db5c8d1b1a11e5d1095f69f623d39306eeae4ce9954c4be4e00f8a43a527798fe5c92ca18fa1d6b47101118edde448168dfabfde0f6c027b5bb8b9ec7b1c39e2091323ef7d678d0af0ccb41533e1110d2a213e66cecb40bf563f4350ca0ba31251eed17ab83abd40438fe81aba9cd3b77c1665b32e3e0e7485241d13e56a1660074457e476c3bf49253cf310b3fd13546578885bdee2c56e35d4bc548f18c07a5baada6f14eb01a634cedb07762d37dabd3259fc694972ceb36fdb0d7f15f88eaadbcdb95f12945fa2472c879d0b7096bcc70b8860209a140a6a12c95d5c986d09ae2cf740b9e8b6b3fd348d6ab9bba5749916dd24e1b59996e8f9b0d403757ed4029d5019fd7b08d0fc8cf4bb0cb9cbc08bae041ef7d9b38a7bd492250ec7154076de8e73af25373929a00e444ff0be09a32c4abfd61c1042cf2d4c5488952a8bc83668b17d0e77d0d11a6c7c5bb89f7f96efadf4ab46c3e992efc81584919e2accf935792d397256f6379e3297dbb5ca927ac97d58a57c5d2f6fd1cabe2a3d610b00cae36daa5e7c24082049d15af2ff92e7c5f37bfabf8609c6813488459328348ba75a2a80e36219ff5e40f909acdc12bfcbac9b81e3db2db6a9b10ceaf553aec61212d9fba026efad4fb06cbf72a1b4723d0539b4b43f6e79c4060157a0d562c866207e62eca9565eca756b2c4b9c0e03c7725e5e32963cc7aea09ae562952201601fb3336a7b05fe7324c4bd7dec33646f5d68db35fe0ddc17b1d3c201894c7861c9af3717fead811664412509b183063f96496857907482421c23134f5bb004764091e0b970fe90c7af250b9fbae950b4ac52b7bbfa2b6b11bf527c02284c306f7fbdd25b1886490e4ed8c2bad4a942811d4487ce58c7e293ee45f081512b389ed19ba808160da1c1629270dd27a6c92d6aff99595c7a82b25f4c6a4d390ed5b6e33f6e6770fa093279840e9fa29ed95aa9c4b35f79de7ac301fcb20aab37b4c696d321180635c8708065d00c9decef499bd5c7fda8c57749f345af929bd9c38e2d99f27b2d60c5265235851fdfc51a1f723209beaab55bc0e8aca9d589298965c31e1873e6bd923178326a3f542fe6bb470d1e3a9a4e02ca9be1185e99a20bb484e4ba687c5a6b18cdaa7fd594f3ba9d05900e994edb15c248a78937a70ac0331fc8b33b5be2c1e432e3bcf085fd1084385487142cae1d4a322d2b7f25169a760a0c47f501df2bd6a43364532cccea36b3cc67ca406c6f76873230d17dead1138e99d6964fd94a8b4adc2f30f6767f9efda7f03af8e3d884dd7e3fced9d5a20b1236f7c92ec14b065a8550c08b557a15398ba5052c7e43c2000ffed26dcea746ae8b5d3fc6b5c25df50ae1950323c78ced73e664cc5b640bc750256ddcacd710c4e7435c13c10dc09768db92ef8b0fa2e48bcb5f90054df935e9c8eff9ae675797af1161c186dcc8df5014815018db07dcdb6af6ea7943f83001cc6b91905810bb4f87eba7c17a9206bdbb0131635741b77ecd573903db906f1e03adee18d9c7eacf73b0ff6ba05dcba368b2a7fcf2cf8d97bd6bc42235337fa834ec418ebc2682a961cb39d8fb04bca7edaa37aee5882ecc2e7652bee4f20410c90172c1f881118908172dac192092289e8c15cccc46bd916b96c1435d523cf355d17efeea4e8c07b4bc5bbaacc96ff18d690f9621a1caa51c64ee5e723eb4733e9a24632f1558f11349537e3f98853c5dfd6e8bc7696d5d44926ce483d630eb6393b66f59fc4db8ca8f11cccfe66f57f8ff58f9d161b5701b437486fc418ae73a09699e179f7af2258d1210ea1c8afbf8c61bde6f481e06bdcc153d7602afe8a0627577a0dfd338c582334ece869dab54959d9551690db4e8eba451c94c000bad08d7923038624d3af74aa1560e318d3c47c5c8ab9b16eaa547d5203cf6f61b10033801b98e73d7a8b4c5322e858c70dc8756e7e03207ed4be0519d0c13eb869510467862053f5fb2830e4bdd30915fb08f84b5b5e3079e1042ed32c254f58fc4b82678e776916d78fa6f424140938cf4992ac19ac9df08faaffbe11c9b5c3922e76c9ca8c6c34abd071b9c733b943cae1ed51cd4a77a02177cc5bd0d2993a031aa854c471a7fb00456d0fa58a8063fa237dbe609f6c15c16946468a87061cb996fa5b06d9d6c0ecd0624711097bae0e1dfbb1ca6df586f266ac04fb360f6d59480919e5c5bf8a67ecf54ae1b3292760165c65898fb5a88d263f34404202e107a1b8ac5565ceeb4b98e9054a2f856091218d37d52ac55c62f7871a5fa6abe9336101911a7c2bf8ca897d3dac93bc9a51f55c137e51d28dd476a3a58af9ea3e19948b604ce890634348b22e73bf27082d59b56d9fd4c4c61b39d9bb611223796e8f5c3bd7d5eef0970aace4fd9e8ee652ada5d05b68abded943dcbfb36d34944e1419c58197bcdc4d50e396ca247223a533302cb93e731be9971ec7abf3039a91b90bc9ad6abd10fab436f9440247cda241a19bbec69afa51b74e732754218051eb3c55c56fa99f69261893004adc4cb2f6a6bbdbcf07edc083b704945d17938d63060e118bb2a466a679883cea24890e44918402aba5675aec0d9ec9af1019b3713428f1050239adccd514e6e5de6d87da5f41b35fe42807412911990f08297fe8fe95796e8295e04f2bebf7b6261558e578761384fd3a1e2d81a3da2edb966bcb65b745cf80a36b631a1b8c1c98ef7de115bd04af99a8154e3a6723f8f4b02a7adaf53643d4e61fb682aeab06ed4472f7ddcd7f9277e105f61adb6b465de3f3387a7c440ff3c66551823e39af0663b84849f048302a682062bae621add852f7c296b3e70e4ade97d98f819ff2c352b3d8ead18c0beeaca0635af61b26ac75a15b25f7c38766c634858e1438693b145ef6b04edf5af0be2d9bb6cf9c927f19ca9a2072da2106754d959175c233139f438afdb151aa4125d60ff57a1b7a9aea2082cebe6d859e6fb71d2e14b053a7eae53004db363ff8805dc831295c198e1a799643767e7aea54ab0f15f47935994207bc894216c2170eb431d11e6c91db34052248aee4a09bacfbee9f893184ac4bc2f9c3505aa97e8969ad7f3ac7648a1fded02e363a4f3f0fd8b2520adb859d1539b500e00427c76afae2d9127194cd56ed74a0e9f5136d8c7de2a81eaeeff766c1f1cd0e032f8c77c75f67f3b35728c99d3175ce883f9152d7f5ed4fa892d927d48ba55dd46a5a09d7648792c07febcb7b677e78ced769c96a04b5abb21cd43dfcfd82e8fac70fbe54594538b3a72d33ff8e48460ada646eebf5186d7224bbf92d592df988887d9240d79d10ee3710b2ad3fd10e651c6a2fd5494096397b0a26102ca3a4c97b2c6a520229a44aff813ea6affcc3142de16ebf370c32a3b2de5bbd952d665e0bb7deb6e176c07a4549891d46239adabef5fc555b29ccf9e9f68f5239f73e3cc3edd36a3a262d01467ca30f48dbaa093ddea3654ffd602bd69ab32a9cf5d65300f889848292b460ca704eed838cec34371be37a4471e1d8e99284f0771359754011cd4ff97ae34d0da19bb992638822e0bd41f8d93aef4ef691e0dda1fcc465c7a395e59fea8ebffe934feeff273692379b2248df3e3368763cada9c9766bc2160c3424eb1daa17ce7acded31ee026ea303367e7900ee1ff80f66cfec19c3b9e23b593a4fde41549467d0718eb2cf9365134c8cbe682b2379c034e96ad1581e3faa68cccf7848151882697cec15e05ce0c26d3ab967fc3fc224538027ae2eb01416d1b2c4c0593d1c4fcc4383faf537e6dace7e5d808a70ded624ff594085523755ce097268c779873ddb80d61986a230b9a8854e97837a16f0bbc9e35f6d7301c07a605fd3e970f86fd1657b2e89d1651057f3a6d94da808a2b66f0fc6fe9fe8328e26ac167187cfe431f0466a424dee735ca3d56471aefdcbdd5e71566323166d5a88d3733f66f7d568f5d3d310d6a4b9cb549e66c101cdd75ed8bfd0e31b1610b4cc7ed122e9bf1803b32af20010709e097b8a5c26e0a3a961659350680035721c09344f1adf53359779a0d96344f6011a8b8136ec9411be604fe04250c6cf407b817df413dde247924b76a98bb4ec639181e0ca89ad8847601481294aea8522c9f1dc3296d814f378ac2152f17abdb62566d2a5dc40d6be86c24d6a59ea9efd6ae980c07a93a4a6c037081876add22ebcd56de2eaafa9f44d7d7d311d68c0283fde8c74a5bffa4e5d64f3713229d8b9fdecea3810245a15e19e4c22dda036cc9be7a0872ed6903f643491d5792be85eabcbe2d995dff424f0fac713280b0e03a0be0a507372d052ad658cd33192ab36c46edf18fcce0000ec830643387c9c4a2382a6c8a4595be8cacb5a83e024c561acc51525161005c277fdd1439c4be765e8e5473ed8e47f047d52c2a098a7ed0f16b7be4d8dfc93adf89429adb8bdb656ea69c31fcec32ac622d3f474e4a6489077080903e3490885e6cd43a215484395746767247286facb6346a66b3b9d1e9a0436cb4824b3893bf62a9548cce6fd55279c859241fd7bb7e029793db1ab4b62d22e4d799630b50a04d151a02bf354d2a6c46a7fc94a02a9d2cb24e220aca034f3d9a3a3e9012fef20b09d1db339d0f71066025daa80982b334f9f29aeecf521ae58c16cc361d5a11977a7397f1389d06849482fb38008a0ca25623621ec663f42a9fb553941d4067050ae7ea05a79642345f7441bb019dff0461592db84c2ec407847c68025dbc8e94f7695dfbf121df8151eb7b48cb15b8e24a6986d91fa8b566f0d64d987c926e78228564b4bd4a52d613dfb9449ec7fe0f7724458cda58cb5bb3a9e1c861061154c8fd67797624f121fe51821c53baf6f382c9dffe6d42e62ddfb5b892f15bb67dcc5b141c975828f9a40860e86266f40f610e8f116c675b1d950d5890436cd868ee397965ee430ad169fd451c49c8fcaa952b061ca9d23d9e3c4344b348b40e019658ed45ddabf9e5552e70a9a2ff60ebe5742d5649aefff962534628d2c6c6b72702108ac03d72d7dabd86c704e41975ac6290399e9eb7f886045e44db8fe8dfb0bcd73debbc01623e7c9b06dfb36f885d0b79f23ec8ffc8bb802387560f8351bc1477dee292c223d5b5e431b83d6d33bcb448124f70748f4347ee6c3a31b18029557b71553b7a5f02b5397e556e59daced47aa717bf5f30b245bbcd07f4c79ba66f79a92803cfc8ef3677a2cfbeaca4b8e1f276598edd6d4ceebd94d50b2a91f446d7798ea12d21fe9471f772f5ec24f933548643b02bb84ac27a1d29e0821d18493e43ba036aed0408e4c500860baa766557e18d652c88bf611f84e96c6d6400a4cb5b42e906e6b318534ee07f14c97d645fc90a9c333e407c4b10a45c996012932a0bd08c5cebde94e26bc5214d2df05e8e2967cad3234c5d72d2f89122a1ec0c66f96866e2815ebf645a40f319a81ce1ba57bb9eee83cc9ad3432e2d088a4c01996545ee63cc7efa4dbed6a67fd95101fdd8098ae4a5a9d9acf248412273f434eea848522fcee7b390d05e2c463c0eb6055e5157a2f7b06d45f541509d63f55e1e5f145466f4e4c53035d6107d492f1dccbd69a5e6736f5f944c8862ebaf155bb062b0dcea125218d5331a9c53c1ce872fbe2dff9ce66b224e1331b02c4fa83a6d4215139dcf4a6ae67a22aaf8973344489a10bdd810315c0af178161773c5e759b905a5c98dac32172d0a31a5223e9a4a23948481d83503fbc1170fed54db21a0ce4db5dae5461c51815a184ad691b0e1fef7e9c810d85ac278483cbc43253b853add37b17a70e51c77b7fb0929f4f0d3a35932d2801de5ef50497c3a7004d86ac18f496eafe76ad0140dd5700454c9e296a9b6fb445d14a10bab85661dd8c7e3f290382d44b901be94216f1109795cb087f9e64b290ea3e4921fff0f60af6f59b9b47b17341f87d3ca5c70ff00c1c50e0a2e6b683426a31c34b09066d25db52a6225cec75b19ad6e1a3dd5ccf3adce0612907877105359eaeb4a8e29a46a4db0deabeb634d12de9cdebc2fb03e4fb548bc6fc4a5e7ab49e7f1892678b6c6c8026ce5001aaab71c7274287807e32d4eabdd3f687a6ca3ee5e44b36351af19e1c69974472b60d472a9b4a613dcf5b2170b291a61d9d7e338e252f18aa44372cc096503c2d399ff8d4fec6efedcb545a9deae25843bfb0d2a2791411ec68b7005702d67487120129f6c7a99bd9a8e90ed0ef7af283e4904985c347d3ffa33db4e47feef2c63d5a417e6e58852ef52a8dfc02d2500c0715d382b042178bc56ef320614dbc2481aebebf4b1985dd89048370ee1fb0d25e89483dd9377e7821b02a8b2d003caebd2d447397169b21e0ff276aefa0f0b9445732116fdceb5d97c3cdb26053fa50e1b73a206e302d09d2e7f4c7c1e5b710f0f3a036a42218e20088407485c1d54f679c1e44bea365f038bf7286a4d5194abea6552cb438e20e92a641db7de518dfcf6cce93562ba8003202988808e267ec3258027ce1978eb40dc750a12364c59a993166c5c7f313749eec603b4f2a8002e953dcb9cbbae46666185cc02b223d065fc543284b5abc052ad1610c67b030e79783aa5ebdc042a82de3c5a23f3293c956b8e7d3303fe4ca1e4fb2ff643adcf342ea9fd01e44921184592cead9dcb9570787b13860a3dfd15b564eeae29e025cee97d45c6b2776ce1906cfd6c0b3df4306e029e2b149a4acca5a0cead5fd02b285dce09a62c27478c88ff16175511473d9f9416462ecece3cf0970b7574f3e1b3be91dd29d1c012020c7a6184baa9176198ccb6914b7360145e3405108dcb8643cc9b1e2a94f6052219afaf768d30b611a6c0a59711d7b881a2cae0aa8fb65b8226750deceff26c924c1aea5c25ef0bcebd907f0b504c1e0b14972e9a2db4d366d93de92fee23804ab585ac60b75d65b197310a2fa5318e0558c46ed6c0201d283ae26b86dc3cb9dabe8c3c1fbe66f58fe69d3e85de2a138aaf1ac2a71a85299e342feba72e11e1f00c3ebd336f066ddd894b7b12a9e21ce1c56a480a1c974cc595d9121ea27f79e0c272a16df3d47af811900779d5fea4cdabcd33ae24bdb83c18556bf9c0484564ff5207dfa0e4bfd64825b4fdffe7e57aa521f46c26ff57eb6f748d50820e7c24565f0d9f05dc64371757be9742da9bd6673170c38ef10585169dae4a3a60166ed46c52bc4f4d78e73738f86555ee6c70dfce85c2d3b1da2ac3967cd6aea336d81d3c04259c63cd8bdc1056cfe10d775d477807efeede54ddcd42d101cff5d67d248ac274ed9e8172b206fae58fc7c38d89cb7585c3b099bb5d9f8ef88b456c36d02254ae5301abcae0ddb898597340b38df67f7be7ac227adbc30ea391b5b6a0ebda011cb24a49f6125e3e1d5e9144b80eb956a8683e62a0ee4b8c47a72a1f7ce5eae471fd25e2e071e54cbc55c673222e8b2bb5f26d06a283192219baf11657159a1980526151628b6253327b82a5396835c024986493f7105c93a8e4690cca1d5ce9c57973249b1bad7677ed0c797b47a5e05d2e69a6071f3a6743e5769d95416e87d4e70fdae205761c5ac0c0554464388d37dab28bddfcc3b24da793a8e30a97d7631b1318acd191b55a04d3f6991c0d7baa34c3c55b23c659e94b4aea5c4d0dd4665d9b21b74ef738408180958e97dc4e9f83652363eb1cd3837af271ee323a6aabba678aa223a043ecff0b0bf5706ad28bd9b8303e95c90ac00561032f0d2c2d4142c374e83da201b1d633dfc809bdbb125ee46335d6c4996e4aac6d7a4f153f5b3e7e4475bf222d04714ee103907cc6968d20e77d1f6b6e6b01388885310908a6b6ef29cab337bcbdd7195a896236e83a68efba621f4855a1c06921f4cf2d0498111e6a0d7b4e4ae07d08eee9e221c31f04d27970b9b6f433e3e0b5b665a444b9c2f1495046e4074517d2e507f63f43d9b98632aa56beea449540684f1228f25a1f3341f1bdcf763cc7059f2eb383511cc35215589eb4a3eee22ccfa444cb7a166b5873ea57b96a67de6123046cd93e0136ba5f3efeb58b72707c5a89604e153ae51ddb9faa38bda9d8fae63f9db5bff705dc9904dbd7df55bfa4673625f17447725068119a992a1041fe65a3e35a3c8825abbb4f8731594756e083e98df474795dea4c47813e88a6d7d368510c945264b8e08ad2dc7c8e535cc9974bd7599d25c192865fb7c15b664c98e2fbcb45f5d2319a6fba23a2fdfc15897656d74c81f883bc6f5d8a892446c59bc78b1c6b90f827ba2a63dca2e675d6a82ca517043e4750178e9dba144df7e2c753ef62a00df84d55d7975bc05b290314ed7dde7ad856970c87ba41232bca3e7487881e33dd3b252775e5afcfadd51a800d24373364734d3e1770dccc6c138d3abf027af770173ad73a2ea6bec751a0f74676b4907a6b62cb5fc0e1e53e4421d94428d5ee83d917097b29763cc8391febcca4b932dd0980fdf60f612f4d425bdfb947154c1a66316242cff1f62a12b5e2074c5cfad838a337c5f3d99a6ac1ecc2a23788786efadf90da2c5a6d10c60d4a0afd7d33de0c1d63a9bb3f208ff46f993b16cb37f0a596966331d383e1ed712416b9fceecc56ade11128853ae9d434550e4c00623e8b0f183e1f7098c579416242f001f2c3d93bc863a798e9de575bc072a21f931239f24d01d684e4de661471ee72f205064f8d27fca4d7c08a3cd76bc2b9a8d06e6ca95896a987a2ac27f07c9863a0fc077cb993bdcc7b59ad173eda0b83a92eeadd4774ec7dbea4cad4eae24744413e46b681ef84b82eadc43c637b4a2c353594da252fdcae7d3d33ed6251deadad56edb7016646cb4c8cb64311cdd30aae1173450c6df7f3fca17316e2a337c65898590dfc34de31f7c9de8f950c09808112d88e12cb064e708cc152ade773904678fc1fa3cf2699b6836d3e269c8262705dcd43f880a26136a5f1c9265e600d0339b6a75720a67b67ce67e05ff5159b94e50e8c9f3edf6838a024972a6a854b4a3402619fe94efc4e6e2dd6bd9ca2f6afa473183eba2225c2633098aad36a8271a10a79c44bf911f7fc69bfcf9e2bcead4aad9a12c7f8777770ee66b81b2fc63c7e09e1b7dea570574721ed736809f34a49f9bb92a7ec974f8811420e89514e9c1f51a82262a330c918886ced7b4b44e7e16f5ec32b511dd7634c929bfd5ea252069aff003171613ce714a3590835809fb9b1a05aa961d5fcd2f9ff89fea92411f3c7428bdb848454f5fe79e370dfefe7c3424a76aa1f42c955011e988906d8ed5eff9868b87231f6c138e2e79506d73b2133f45721986b908f47770c16c59d98944162339779951d0b36dc63edbf47bf565d199f2977c21d7e4ab26db8e47ee933bd8d723533db985fcf956fe98bef6f938e861800bf4c256e6e8e8610f187fbd1f6705d735b6fe01610060888716dcd61f9c24d0dcabd0f2797f5b1bf3db69c95b1c9cd502e4957e2191a50f87c9b1b649c8cfa91a6e1710937c62d2a668b734d224fb63253c87e468ede7cd11f01a7b6a273516b40b3ddef2e620318a69fb6ce9c5d1f7f82c12d06e8756a8da9b2fe5dba299293d4a3769479b29600daa86efa180489ef68b0b7667cd6dab204b3e3e3a10eab47b7c2d2ee26e26f0f970e745620820cf77634c803a0c417705af31975ede21fe97aa197d5eb9d6d910713a9902b055b586dcf4e3cbe251c95dbec1c6ca3947066b802744fbb45d79b9eb863a1a365c15681ff2f8be812e049a3b05d3860ecbffd5c71683aeb2625e6c89855ec39c7f2be5e2df04fbd69b0820bf008321dd91e47adde75d9a4cfdff07a60e0c879803a714d644da541d1ea479d93528aa6526f58d2dc4607a604ae91c7eb55869f6c22b2b553094dc61d3792a22380af5aa03c94ae6e9f7decb50ea01e0d174043c186b9a5824e86ca28ada6d10635cd3401ff09cb1aeec045d3581af8e96a253c152e97ffa93b3a866ce163acb5e2fef568a0ac736e8b039b33d77a628ad952c9028ef833e5a97d72e4718ba7e44123f8bf8eab74a140c8732fecfb55cd59b364ba70265d75b998eb8541b75d30620974f70dc818c418888c54167d79ba655614a07c499bddfe5d9415cd571413925fbfeb8bdc863c9a8c67416baca663aa79aa6f5f3054cbde345cde15f540daf310e1f0dc03191f3267c81c99db091941df077a895b011ef13c4cc99eeebfbd731851ef0efd8ca13c11ff2c8f07e98a054b82879dc98668c39f5b715db9ee7bfaa8b01795ec201a5be0c8c894d84a58a242a663330b99be017fe4371662380eba4727d91aad2ec0bf557b5f0caebdfbd13f59365d77f58d1ebc6118d46cfc63265dc62e8ddd18b88fe3b0d5bb87d3116dc24404f799d7ae73746d2d1276a9b9322ac7d42365e6fec167d40b9344a554834dc5f5ff8fd9f60adbe311016da7548aef9282422bacef9ee8823a4d76f6eb5bbc8089f9f1f72bbee1c70ac026279388014d2a04a59b328200abca254984946bf546f10d7797d9c6b577d052b632e3ee993839f53e6587df0d76d80c576160ced6bcdcbc5ef471ad2e2299c148680cb980e00f280d8acab86dcf5b6f2834fd6c650df98f22d3389d7bfe2824d51eb170a3bbc5c300eb26a740e88bbf47c070afd64e52d657e86ff049def0de17854509c7483defa6d7653a88c6643a5e0a2f0a0228d7e59874f1f78162ffa6df067abc07d18d2150591587d4c2df0bb340498eb8d07ae91e4b3884226c375d6e8d0d079e9be124629c2fdb39378a7e5f61fc8c8b7017d27d9e8896db91be3269809dff8a916a82974be41a08f4e406d14bea2151d22ddbec585a85e3472e7aa6b78e3b5e5d754472070b8ef56404a793bd9f290c4a32194bb5c87261561a9332edf0ba935db53ddc36cdb263172fc5ee0f454c5f19f67597ddd20ba18a974e38fa6a9957d4bc30c87fcdd3a443a6c9d2741a1ce9bb46fd075877e0d774c8d4e9b9cd8e2058fff22db3e5322fbdc39397d3264b96b236f555b89bbed312105f3869216b23006dec82ca8d257114ca04668ae87bd62a6335bcc987de89bdfac6d54d2979f5ddd9d904779dad164ac853cdaff507ab95e16e8b25f8c592177f4ca9ce2bf495ef87edb3f50a818bc017a42e94fde5b9ef0323be8e8fed10e21b97fba830ab113c623d2f76ea8cc9f0d4c36355e3d1508b42b44f055efbad93e91dc011956be1ba34199063fd2674a6163735d1b1f053536d8273e98ce97b53617d4382fa8b68911a354092100659c4bc0dcc318c600202bc84d98711fb6f0de833e6e71157c322cc615286d7824790d897e7c8946e46ae1de3a9c5c52d4f33d1c2124bd497833a66828975075b0881493db703cd06572514e8841e18fef1e22673085bcce09fa7aa1892fbbeb5258a58dd768bb67951e7391dd16ec73e92ba1dfcd3149f87c4c3ec0940581657f571d6191797821d9b37692c2eb52c238a2504fbab2c4c39639230648536e7f073b4e4ad76327f26ab35dd7f3a2db05ce05b4eea41a3157a93ea00a440bd68237fdcdd330c1e82485210ef8cbc5235d63bf3c75f39fe3d8714161176f2a791359de6b3fde62639ec3aaa4e7d86df20e5fd003238883ced259833e479e60522bbf0b303bcac376ea7d14ec8404a614babf3fa8be58888448c00dfe2474a86649ae394f7b025318492d8dec0afd0dd32f76b2cc828b0b3bdfd03a2cd2f4e4bcc786ede89adba02ec857398026077c2adbcd4cf41432a861d66d0f01adfe2717c41ec4c4fccafdac65d97da8f078956e9f6891a8eeae93efed3d88ca92cdb8da6ae07f9cb1f8116edc5a4fccea3736e3982e9b8e96ab68eefe23bb89bbf89b781a5fef44d2d469f8f84935ec6986cf83d492a57cf3e9f1b6ffb2a7e0107f7bd05cf1c79d30269048f9a46c3149c568cfbbe9945ef5a3feb5ec0481523b2ac8b41c5635c040a1764ec907243d11fd22463748404949a3fd6d072733f3d6ee0841431304b4de459015d9d5076b941e37ed940c8860082635b796fba30e2b9b01725961d515bd78e53610a3c2305287bf2fe6463da91674eb54cf0b21bd37873f31992f68179e671aaedf8097c8741f846ff9606b957926c9b1730d7bf372fcc9d591aa2588fff14f27fe021df196a0f98acb39f22894fdccd481bf7ca6c2c9f0ad2086815edb31fb4bb30a77cda805013435f4fd39c9aa530209f8546571c1609feba0bcb3cea227d119417e7c792135114dbe66e40d886175f6864a845990712dea74a012f34963e424fc61e27077b6c7a3424e6bbe36eb11eea59ea2cb0a64de10e16c69db9a713b33455198d1eb1c3033e133c372b15eac035e6f41afd7041491860316fb5adeb7f21f6f4e6666d1ec683b6457b1105c30ec7e5b14d53e86d37bcd09943843399dd739db8c33659cbecfd622d5ddfc970f7df2e60fa79643de3e3655a3b1ebcceff8b2ba344f868bb40982b00be0e8091ac69aeb05433641b1151dc110f22178b2754badb92b132c9dfab97676d1d9a8de1d330bc39e2e7ab49f9481a8921ca9a76fd8d703bf7bbf7df417e1baad446b3a8cbdcc5c3d1b5288f09050524e760b8df215904b070b1f4bb7dfc0511a4f6b17ad37cf8deca0225363cfa014ef5b36894e82232dbe1f521d308e2c093381d465371e8e9d7bc829360d4823f7923b661f3a2bb95876c4fc6d555c30789e0be4248ea216da01a429c0e0629da9275f9f630102273f065a840303b83e13657048438f94d6cc658ed19156c4352380c0babfebc6713a02a25e51ed1b9fbe92e3f6b4760a1152b02f592769a1898c220e9aaef46bdc924828d3dfdf814d89b99343c56a4c99a1d0c5d66faa9f8f718e79ab554c547eb6ae46a8583e3621a35f3ca8b5a9c72d6c2d28f2abd3488dab723c1512dbb1f06c495b27d616f6821e61d6247ab8429615edde73bf622d2bb894a78135583537c11e81a97529172fa472456a0b8991040cea6988bd3f729763a52ec87c318addc7cecc52366ce3725c93df408a2670be06dd1fa2ab4a24a0fcc4b27669e057b89e5c634efac286615d4dbd52d89aeb57a39c8fe79b9197fee773a6349bad869d0f16756f9d74908d3130cacd142799e6368505a807901b3049834b744de7ba02713fa9c86079a127ced481eba563fc574bae79ac6d636818ddcecb3b28dea44dff5789f291654c72cfd4011ba4ddb57e55532ffe3631fdc2b095e5092bbd48bff65efe4620fd0481ae9052e15dc4db371ed0e72ba9d4f4e26d697a9588ad5e075bb3521217cc5b4204b850c25f549c891fe6511d8df4119f0394961b5e207fc49e378fcdd9ca8f65dd964bdc3bfd595665e8bcc7a39cffbd6ed10dca95d96fa911dd7d8ef14dfc77fd932b6a8f9f4e18688fd24a0dc245ba5c5c109b3902740341253796a88cb1cc761ce99e3f7cc1dfe4436b2e590f6d287fbdff5d3d2b4a057444c7faf4d0e5ad6d602229039a0ff0e05adcbad594e7c3c754ef01ceced9139297afe9d399497cd76490d211a974ffbb14adebfc72b3002bddc7be48d7b368b88d01ac67450218f33e16b964c48c22c9e2f9caf498db6fc0739715a603e2ae4bf55d9dfaa2012f8a949a7fdd45a99de016200d868dc4bdc9f36c091e2d9886b8c3297b8be23e69e37637b1b256281c1457e94e4c134efe08d8eff8cb15109a113d0ff33fe2b52cb82c11bffe7a77fabf07a75f67e7a0f690b9a11595a308079d0913a9b1946d588a0d2aac8efbef6679b0953560aa6e203a8571fd246fbff92f751bca0b330cfc30e55b38500537905c7dae9d46b5271da62c9aa15995eac90a0387ec0308466bfee3079793c9284fbc7b32f2e787a50c497b74d77d5ba39eeabc0564f18fe8233178ad9b9af022e9618fc28215a0b1cc1d89fd43bb5b984f673fa5ff24789991e0c91d46b6a5ba4b512422abc02f600675d3c8c81a0feeb7ad1e6303f5371a106028affe451ffe4d884a0cbcb148dffc93e9f2dd72f27ff94f9838c3164843a27904f42ad52e330234cd0ab540c1a655b329ec24edcfc947bb44c02f1020356f2be8ee3e495003ea98dd0b97c3eafdbe39b2cd27e18266b781a11d937ef83aa670f74ea0271610ed01310072ce9927145255c7bf3bf5eb4e9c57c7fb2906159ae846d78fa1b56af3c5e578425065ffa334edac321dbc67b561fee354c8e6f9b57dfd4ccb6105873d5c635de7bc23b4cfe4045f78cb4b4483be22c565d57b4835518810cd6b7a44ba0c7ec626b5fc88e878fc253468765bb9417edf96d218f10156e659053acb985f62f410d12871911c6e928be9b414745021c50e8e1419fe969b8f4c0f0e30b65f5d6d1e51d460c6a007b71679ca7d6a2c0bc47bd25d8066c31024cf2e5e7d18af5d0192d253d6670cc2689ed2a370bcc7f2d3beaff38a8c125917a148516b283cce7398ec6de7a2efbcd8e84cccbefaa86272b1ceecaac1580e4507","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
