<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a92c882a063a84bf34c0f2d3b822f4f26d67df1899817ffc2c823454f8c18f087f8735b26b0ff3b11c18239fbab9645eb7923956820556b7dabdcdedb33a3ddb6b8374464bdf58dadc9d2a93ad2e0f3067b1c5aa791e15c88d21c27e8183e919d31bd6e1f9559023720e35c9bff75813f3aedaf6fc4e9a7f770a87bf3189a86175612d4326ecbe891c3e42072ef7f073e8728479fb9e549dc063d3502077c9c5de01f58eaecdb6634177923e5070ee4868ffbdcabb15c8ae1761cc1172b907d741162a3f638e0284ff9437d932191ca27cf2055cff362e29cc253cf9e83ddbcda5d8bb9568ae21d462958bbb2c970c94494dbf3ecf65ffea1dc9c08d7a17c0404b7f987bd4ef1ab8b19a2fc79b90497f4d54086ced99400e428814bf1bf0ff2ff70be0bf8b95fa3d1c5becddf4df5d0d7ab47846406d654ed3cbc930013a70fb599ee510892b98235effc4a77486149e208f844c972065fafc29037747ea832ade6008cf02fafbedcc8c96811e5f7fa09358943de332cb5ce46e08e5fe8d48c476da8aceecde299fd35993c4ca5db97558554446f44f4a3844323ea0681fba34edc428b65d085cfcd5a0a124b04cf24694caa21431749df2690d10e273f31dc2032a681d5f92a5f7911b15b1d0f83e868d7d1d189933d20541c08c09c2ca1bf91eed0419ff1c8043114845d5db998524b4a6c16b697d486248ce6cc7d806ba462f93126b4b0c4a0c615a483c14b3a55d842d8ee9b02839ad37de598bb49d1c067462e5936b007b9edca5d76f0477e891242d5a3e741f3ca4265ae0c378653192a03efe7207effb77828de4a30dab9b454fd5ed5db8fe2ce168589ff47799b9452910e900457c9c134855b7f1e49b8aba2c15107ff2cd243525e22819e3962735d35974e09a2c71f9a6889b62847879b084189f6739666061a60a9b2e5d58258f6cb498afa58d41091e17829f1a188103e582e86fcafc5913ca8d0c205e0775daad54f20391ed14322274da83d26a117f717861f5b4cd18cee2611ccc94f845c0f9c7ac424362f7fc7149e8080ee3ee2afbb2e69919215245651ffa153b185bd33c1a95719ea7be771e8b89b3e718241a4cf7af7dd3bf944e377c7599b284fdea1cee86460abb10ce417d0e66f6e95bf8f648c3f974c0d848ce4c665c7e1ed82ba0f0466764ef5a657d75b8a46ab9028dbaee001e2e70541c61c2dc1d6d817827bafe2c4d54fedcaeb34f6ad430caabc634ce76fed5ed0bf26de8ced34eb820dbd00ca0e4517cf07e2ea3e2eaa2e9cf2e375667511651627c54ebbf2c8a3cc737133be9da65a3ca69c7d1bb6b835c11edebe669701bd137d6f98232cc597d67e239fa82b8daf467eb179cfc9c9f9d7f156e260ad0e58ae8a9da08f1adea4296501761ff0f4a39a548b6ee47ef69d240c499049a44b992af2c70499cc66a5a5b33f2f1644b096da328f3f2121908319b4067571c8cfa9338a6797a3e35c994a3f10491f1b3ce5a7d6b7bbcd502d0193b928eeeb5d01ce7fccb1fce02ddb7f736b81f728379fc705e7134e41c54ee184aa17dbab8c4de4658f1501088f22467338f31a513c45519557bb68ac79f3bde5ae6d55c788ece5bd536e4d60f85e189e04d679fbc0d96cd5a03daff17e4be54215fd750671e55475451ae550cf520e3c25306a60a1fb4c78f0e9a524234e5f98dcdb5ffaf424b64ce9ac59b210148f5f05df9940e91e306db3574eeb88af9594a05802236af5a47e4dcf7db4c2a0d34566dfac47bba6b801cd4d3185093904859c69f5b74e484f76e0d3f0ad206adc6deae26ecca8a316356320e716a2e61f78cc1dee99f6865333a72c25fa58aff59890a06d97fc87a19ce094f983d358df6780f1dcfe403be524f7ffa764216e20992ee70c66c263e8b53e27222473108f750d31581dc6692a35e31d33490771b149b8aed608b345ae2445028df3771618a946d053101b7f5db239627f47c086fe45cbef14ae278f2e5c2ae0a70b7983dc81b8c4381972785cd2ce7c4a8432105205e8b6dcc0206426dccd249f265e66108c8a49d0dac935813f862122140220f81a3524ffcd434b17da07c1befa7a66f36df35ef9fe73468fef962ebee7c0bda19ff90294f2d81ef920fd440616775d56f0e5f4dc5e5f70e57afa147d115a91ee27c5aa0cc27fb65b0ee25f386c917440d2eb47f7c9799f492dd1ca4ce8d76220d770729d7f0580652ec6ebd95cd547154b27f090f54cca38e20c7e08a6f0e73196f455457ff64c144d93f20c461ccd514617572bea604834052bee438ed9bdafdd7c2e92893c8e8117ca9c1983107055068e9052c1efde5ad481ae9db86707cae9205f400a5e26817ad4865e2ab771853bb61f94e1fca44e4555b8960ec1780af0b4e25d90907dd1c3da8fd493390b5dff26633b2c5a816b16cfb5b6f26effd3310adf2af639415b15f97c95179369cf3a65823152318d96ecd96c0f106b5d3f1ce960db29f924a3cb3e2ebc483b6bfdb43501dfaf16e16a0887f0b8bb792ffb22daf7694f9b264312461ed1d80f53eae23b4bd3bb2fb44e0e1f5a2d269d980503b35be55a36941a7297f4c5efb29a20d2504b0a77a2544144d84f7fa773f9eda234b6703dd40b3e03056d7f5a775e6b77ff41cac15a361c3d9a1acd5394c6d2e3e627a89c277292dc108eb3366f4766383ffe7403d15773acb1441eac1a2fa5b7779438c9368a8a46a7da5ada7511ad81004aec7a783510f5ea67daf9bcda6aee9b68749e3495c11216d4e73791e8a7f5edf12cdce610f08ae62bdea05e2fbd09bd78da110be461b71e781a9070cea77f8e20569f1042eced368892f8b2bf3a5c16dd03d1257c6fa55187cc0d9d378fb00985ac7fb224a9e2e620708acc1af29ba4ccb0d388f0ea84fc4e1471ab5972a25698dad39a8cad1f4c7b9d629b6e57f4579d080fb0fa98f65d19f1f45e7a6d7ca569adbacefb315d939039217658f3f9cf3e97d9d95c99dfb656bfde6e3c50af9fca7660067276523f5499572ec212fb1690981b1bab7768a2bf518938053ef4bafee4c1ec6ba34f5967092ca0f47c160a537d370b97d701b5c839db3dc7d28be0b13b764ca5212945836ffbcf81d383e2fbc7e98c352a611f4eb834f153bea2f349bac2c662902281587f9a1f27a737f98cd230dc167e715414061f9aad0e1d82abda38e68884509ac0c2b64b4562b8ed280ac853120663c25abc6be744d0323489e0a410787bce6ae0831205047d0c3824e2cc85dae768628312f0ea097e053cfe6a09810b426a6a9cdfdab212210088685ff65d8d3aa32fea1fe4b4c0595ddc3109dad5d2212503a12051245a6a1e2f79100303b6fa68f6c3439a2c57ac01eeadba1416c5d5704cf5bb95d500b87bc3121d25d2648ba80a7421e907e381b5628360130ab1330d1882d97d52c698a96259df7ff40ba8dbe977186bbbca7bb19336b4ad53b57a0fc59638c25bef1c72e68e557063bacec8e70e8f98252d0272d2f935b4fe8e5ee4b39f2963c32efb5e6bc84b15f53490cd52c3ba799d985a3dd585c647f214b645b99d3d11848c91407386ff0247d01d239571e45c614091daf364d7fad64bec1330cd02f4ca42b9e628712aebf60e43de33ed117c77ec6cd23ae0eb2d3b96abea5b7c4ce1855686b7f536cbf658d7cbcd019fa4b8119f0bbcf51c0f2e6d58c2a9d3fecf599b58e94adc15db4f01bd062750b8fd80e851d671258d5a7105a60b6b270fa63365b4b3d3b74e258f4b8ef6fc618ba2377d4e8975b88f16aa5d9f2fab167bb97911db6ff1aa5668a694d07b285b919e93eaaad14f361c62e88d06bc2a79e0bd128113e58cdb8f49a1ab32e283a1796d6569b450690c863712cbbad28043470a9cb515b0f5795d2dec1fcdfa8e081e83512ebcdc90a06281cc87420bb22121b622d1de5769d913f83a329bc867cb606c055e58b92fa861441b27465224de7e39ad147a864d6b55b712861b7007fb144c11999c86064694b877d62465ab20168604bfc6f942448373565bd02941f32d71d9598e5d6898c62b0ab8da5a2d8d4cc2ab3961acd7fc801b1be927549854f62c0e73a7f3cdbcd6ff15d9f5957949eb34b2bdabacc9b420c35d9b9eaa96dec0840c59e11dfbb8c6dd7398fdfe03db335aaa897662e102188c87c9fec114e2081c959c5740685a3c2d2f68fc71322e043741a4ce3a5cd1e6e44593cdb6b87a12e2f46265436ebc5fba1c78fe3e470eadaec5efa6819703162db29f4c3e4d0a8826d1d7249a5f97179a15c28a11dd01ee154ced6ba667a61f11cd6c81a17a0b02acbb5a5fa446f1888e778458aa9db79365af5b537adc76e341974e14f60670c9fef49ad62db04487bafdc969d6b5299d5a1cd50db7a7e3e3156db7c5103faa2ad2261048de18c3c645c428919df5130fa5a1d80c28836101c1cc394466baf94cb124ff0a18348d5bb243db7bd2819a7ba7cbe4479952418027c48f6efabeb1f5b9531a6004901822014f3e7a383053f4005b7ebb7330bf8f84a47f9c09d82f6e13eac1f939949622c323ce0510595c1d670d511f887c17434df8f8291a6908057496cefd124241a05f360e6980dd9cae53c08e961d6c85b5122311a8769fd57938d1e965a33b81201220a92e20960a8c6b07cd2e81c53d7b2b8218d402d1883075f54928a987a0505718904eea560e9d949a33a8af26328853e81bf1726d4f0d709d24bdbcc9d81a28564572eb737166f8a16c50ab100ed3e8e3f9c325bf47ee226fb8f380ad49f117d4a6a7a9c6c6191e7cec0684326a63b7e1a08e260f98b97240e009fa62cb6f90c0e0ca97238bb30fcac7807b6b6f5b3241febdde548bf69cd72231117b3c2730fa8429d602c065038ae17ada04c6f3a11125a67e2387b168dff643ed0df9e58c01515366a7c3450e7733c9aeda009139570113b7b5f8662c9136f83adadd613958e9491bbbe666a53b09c7e97c58347d1a574ab2056207d7cf0cbfb5b0f19c1750a25c3a6a34837a42db3255e2446bb6a2b0909cea8941f8110d1356c8374e7a583d444651db03f6f740fde3cd252f8dd0ba2a16cf3e5bbef6eda29bdf3b9dd23016e1cd5ec07ce8646e6a09a182f65e430f43a220551b5e8bda548e7263eacac24eaab299b115de96030968a710bc78f7fd2965e7e8a2f9b31a5ecb525ff4269bc078601f36670bcd75673b0164165ea1140e48c1fe56af574cc5965ef8f48b24629a95bcd719c807cfd38bab4ffe455ec0868ee529fe31e935a6d51471902188886c34aac78776ae4c82f709f225026ab2772b80c7af64b84950adc95a2aefd3e90a12044c77cfcd379b7b6046a60f8cf9383f58ce865cb0408c250ef00227a8c546c91c8229b53ca8378ac2504e27d21eaa5c23030b772b0a8d7dc748073af9a6a20cf83dc518557d523226d3e6d9e1b183e708188eaa8f21ea4c1edba992e4aa3c5bfadd00b2353a989bac0e58249b1296492b631093672aff8bb4a5ba9be5e301b3051c31320da9a589dafbe432ab7448d6ad82bbcc1647cea9c52f5e5c9703be609c37355ac24c63d7552bf07138e732743155aa774cb1aab680740b5bf01feff8413b0781264d0a5b71ae69c83c1c65d500607e05f2754531848b9c2f470dcb878a5b1e3ed929cedd7b7ca76d4f9f8e48d85b02845aeb6e4d2f42354aa082f33daadbf5a6e171497ef114a2b7a413bbe61d5a3a456da2fd33e797eac3bf3ca39c7bab10466ade16944a926d1c9636c21d50c7e819ac1c90d8544c68ab6b184172104396c036a4a2c177e27fafc1d095c0c1b896f600490189db745825e3c568905bbc05f5ec8dac95d1a77b9e3c07bcd3aa3ff40537933021c27c74f94390b9e7a7c0f606c749423751de78c5464e6adcaab7168e70e1d0eaa491bf8ea78e7e48a8d809a15f30ec7212aa880d610b615080c0f68569554cb4cc9532f7d1e0c318d5d93d539490e8e21d4108ce42652c699d2ef5ce873c3fcc012c89d0c5a28d84378c39f18ce7d354a5ee624d91f21b4a327789c28f1ed3cbcf47170790ec53c23d83fe024cf476958a3c1920072289440899781e5044add1dbba901ff6196c8bfefc8f2b7f7421cfdc72faba7778f139ce1d0647b8541828c7125ba6e4f567dd2c99b1cb1abcf283143ae531a2e82a7afd72b2802a307d6b472cde929345358a33ddf7463370ef7a97c815cf5dcb8bf664e9412e048c0a91c0dfba1cdfb7cc1a16bc29c017e8880f28aaebe304f3bb5676c9dde02724b561acb7879d6a098034d5d664a0aac6dc3c013205933c2274911f46b5a6622edb85f57471b70229df793d74b27c3556a41d077276b11e0422a299f4e372812eba36d91d9921577247d0f3c61104c29c4b30ceab17dea96c7184c279c04dd774c197d18b3b397b302c3f70c3e72bccce9143b2376cc2b44c235d2880a696e14c088aade4256ee70167596538c8a2acafbaf102893f6c2858aba37ae2630766c228555e1871a3b1d841fc76ac0c3b603911ed1f2f30688d34a8384975acc9c6486dcbc1a774a7932f4f94d31f81107566696617d15ab9a89d16acad5ae21fb52ef890d7d7c1e4e9282f183b756fde4dd4cc4c8c7cc4f00cf42b6984f3ad24bcb8e2702218cbe7cc07aa11fd2367dac73f112460c4a3f4206732ca3f83092931be824f5513dc5270bacbfdb41f7874188141c7139d7a2e32aa4059f78c4f96e50ca1423398c133d8c8daad87ec725daddf442d32c1f6dbddf0a5c36d1eb99c8312662e656033a1dff1255017493e153592846de2b0d895d3d281151f9ef0c68f841c82e7a666187bf330fb6d47327ff6fc3f3d8b1360e3c84dadf547857654ed6e9712228c462214a39d27013a086105d5d17fd05621bd6c05c239d22186111cdefd458a90b4ae7b8a7d86ace6c7fd97116a63c140a25e25e00ce4e34469e16119234e24ae7a671a48ae14d213216db48f4d42f2064ec5b45a2aab042ada9aef8d629bf76a6f8b998c3456229fab5ae7a8b25d9552c497d6a2a1ca6018af5c4eac6cca25d88d898bc60a7af556e079b5e56063e55e074df0f8e8de570ac9160779db444a10d02b41a5fa647ca27535c3281b91bada79cd77b213106336aa99894e7d435b69bc3972cd57811f1eccc6293b4024f80a55a2565eb86dca38c32e1060fe8ed43f02d988045b56eb3d546c5d1b65741c177b515bc78b331d6e6d847e75d821a8ad30ac339915e53755827f1fc7d86e39ff7cf04a130bee736639bdfba98458be18cc628cf5eabab1d7ce36815539e4aeba540785a22c9c0c0447d873ac2067a9b345691dd0318126df6fde7937773ac68ef525ad4590ce1c2539da58cf1ddd69a373b073bf7430cad390ffe2d46cc7e8a95c77325abdb7bc5350213a94c30708c28f472f533d1641bbab15f8ac46be6e804887741da3d289458b6d3a21803520c31c57a5f78076602939a8ac98cd3d5f44f2453dc9f367f28e40da757b075eb2ea2d6751051510ad9b86405df6468752c1eadf47e9d990853730e9548909d691016d5426234604e009a5abe673276754153989ad3b6a38b8b786c0771d64982970e8615b97ac367f49a08c6db17555a9ad22522c48aaabc9a2aa04c4ff8610bb3a8ec003158294584f4c8375da49e3fdad52b53de4fd0254773cd4378cba350c9a1b517fd9e40a58bacf1853056cf57d7ef8e3611bb3f6afa54a47325b9a057b32b5f5cac2a98144c5e38759ef567f0d370d4fa69c09244a17fa8dbb1dd91eab189adebef6af92a62d89e354ccbc98757785c123d23b45b438e0af50502b675841110c23b9daaca7e278ab383f82b4e577f804740593029e2a978f00a3cc3eb712fbd8fe3aa4d788d45d0813add68b185565401be2d8d29eca155fada836e45adb724d2ef535ad1d826793d45e91211428f06afac53d10e6c0f0f85520d18fa67a9f33163d50b30b4315117b74f80d944456c07e341c5986381411e05107a8e14d8d33aa4d141746cd74b32fb20e1ea27ce02c2e1f56c807233a606dfb7be5a04f1ba5f921f2c1b3769353172b1a343ba14f05ef65140d66d329f239a2311759a4e3ceeffe95977afbc65cfc0b38bd5bbd313493d7deeb475b7b42a4e08c8fc0409c95f1dd882506ffdcd8819db2c9683cf3b894a3bf9bb1cde52f364fa1ef02b92e24693cffc4980b15ef0c864c0b5d5a70f3c7344b293d8134f4b222776676d44621fcc805dda28918ad401d13210458838cadbe4517398bed6027da14de259ef4b99ead88cd951dd23a3751c462cf13a5f2e98c40b744319f1859fc600abc38d779ac567ceb2a0d70e1b6db8927b644e4d40c774ca08ab1c289c74ca68aa75446b58f3b8e51ccf759df904bb32c1669b5bc1628d0e2ce66a209e84633251d909dfc61fbac12185e68039b43d4187ae3f0c03b50240db38b9a3afafa049eb78d2dd0b993d36b25a57ff4839e2ccdaad3d986ef92c69e31107cdffb10fa5596472e55ba410068c4a9d9dc52add750d4193f35b90e101ee077182fe3076c0d69c7d5a6d4945f0bba62b266c84897cc9bb2474001cf699637022d3df87398e27e1e3fad49b4f0c77756f8f99f6832fee818233a354587f1d5d9249929f6ad4f04ae62517252f49076f09647cc49d07639877e166075c87462a0db39e7cf55064bac6214a36bd1482035580d250b67b08e39f6f8cd5178acd4dd423ffedf9780fee1400627e1f5d82561b4a80d09c72866069717a8f6dfb5117d15f4c59cca0c9eaae791452bba51cac9a7a74ead7ade7665f848927fd33329975682333241541073bb9af2653468c4de626d4641b3fd793e66d684c8e463b3f423ffa47a992ffc598391d244c1ba74f512c26c4df4779d355f0f0fb3a1a1af7a79660ae4647d28c517c6f2782f012e3865f5c9e4f357f87c8e31dd9b68094c0768e2b28d004ffca541fbe75cb05823f8b46e3357c330ad1e304c972af176162ebb86faa8daf7e3d7b216c5cb83c84014d52a20613e942947ad00588ec333baaf5509f77976a2ac6f3f5a6b1bde7ce920e2c9cd0028dc99777c54e2c15cbc40e0b6068bda2fe755ccc3f1116886226d5ada4dcfab0b20e1c18c7769c6abe14e9066548780acd4db26dc9f2e95740b2ccb087617f7fae611d9c93b489ba485ccf893cde94f9fd507327ff423567a8efaca95d1af1ac1b368346702b4cb3ce6e915c58b0002c3e0e43d50aa6465286d2e7247c1283c9872fc6db4fc8b15b474ef3d004cc830142d18a7ae1828049d2abe9251b1c96636452c5e0186bc5ffbda2b71f5af01f83782a24e9dd4588a8d93675b447fd85e045198a7e1751b584a83c371d0c4b416f29c4556d17b7bb2733670b1066344247016ef2bb337682ca20979e87d8e52bc4bb60fa0ec389a7d1b2e149cb1f84939287bda6488cd3af03841a3b005bf9cc808a9591c10447e817b831899a52c25bdba2c7971d00dcaf3794673a99149c904685a0d4469e97b62095c469989ed54ed59398f4080324aaf9f79be88d244980bf151c9697d3fae6ed8af93b826653597cae07c7a0019dcb001282db6384697e9efb5c778dafab3bf8c6402e4d153e9d0a3ac439b64c71c23833fb16ec2ae90c48f80f50e12d2507a3e6e23001a0fb866b8eeaacb7f14a4659effaece70b4dbd644c8e8307a783155d4f67c60a8a8d5ec3b8e23fcb4f7a03a7f07a6bef74bd80a4a50787f0c5a70ef28093996a3dda46791dc13285effa1893f0fed417db6109a0a13ab8d491205c4098552fddbb638d2e6d9a0dee3a3cf6a8d2514c9680f753018283deb9205cfe72e31de786f303ed261f820ce4556b6119abda15fb211a5dc055a58c9ac802597055c1c3ad0a2f4a51c03f0c46ecfdae327cff74c8282a4380bf55536f5e2232ed63ab24c9072dd006ee2a5ac2624ac950a3ee1db01a4cf1f5f096234d9af44615b06609e0f5c4975bef6aab113d463c46913dc134c802d1a05a9aa74ee53029941f9398da5e2eb5347748b3f0b3ff9cc35805409a5ae1b6addf4d6644f1bcbb27a057e6741c4c72312204c823807c0c3c8c29e482d42a906ee534d8a72948009eb0338d7ad90c35e5ca6d8372a7fb6385b474dc7fe9012d47f9e34108c8aca14d043a5d8c88fb2d8a6830b1228342ee862868bd751243e004e9f85ac26ff6ef96359fe4e52e8566725efbaeaac8938b7938a0801bc33b92349bd703034e30bea53a99e005ac0af793ff731ec066cfeb75c1a88e15ab89a664f32f5e41d646041eb68501f3bfad378d0eae75da80001d626269e8cb6fbde1bbfa9e8b394eb04307f733a3f6cc714dae7bcee92afe67be30ca07bc8d2c6f5410f2df3fb8532357249b98c0eec4b3fa79fd47e8e9ce6ce9e5feb2d59a740ffc3a7a550e32e03972fdeac0c415e1296b65dcbfeda22e45b444b183e15395c4e8058843c95f8871d58d490f2c9c35c1d9ce555f312eb57548cbd4524303986564fe670eca7b809e10ff56b9c74e4e4108cf10a14a78fdb877d00dc7d0a7a67c7e3462b1b2ca2f0c201b521dff4d4ee5f9913e0248b2a206d92d2e82fd82620a406d0b5032725e4fa8f0b980319e13e29f935949eea403dba86ab8b10d2b76a60c8e3eb40b8079c534bea333e8a6a44aeaa6a15d621eff242fceca49c2d891a4cd0516367c04f854cb74aa659141e0818bbf918f54ad6460a6f634dc65dd425c5c4d6d44037e56e035bc02634ea00f73a5111ea1e7163ed0e54b60854163b62837ae70f792e27d6956afc859b7016ab38d2c3c0359ddc166c4889a5cf6450e3523a843ce5f0436886d936d2c34254162d48d2b3acfd559cc63c886507c36c791ff7b60057d31232867c4849f6c12a1d5e19b98b514863ceddbeae616e689201ab66550c2a98d85e095efb6c6e625569965b8098ff413ca0fc405601cd97b8a40aaff2cab3f0a89a542b91358087316cb885c932c3cc9e5c9a0f3c74c3bf810d7c4b8b28df9de5d2b5f2b7d3010b1506b386424357e51c268d49bced37d55ae9257ce37d00a17e68c7403c8afe7c8c07d03f6a9d023ab8291161f93a404442bf4cf61326164a465abcb79e546b008ec59a18443c8f2d8159d30e55310a8f9a24de02910007e3739e7f7900178793d334999b377f13c2c554d33c9539ae37b1deb704a244a36046153fd497f058ebf72009579e7f378c3221694839b89a5f019d4f4d9838e316f321871e5efb7c41af8e9c7cadf6999f217378c6c0874d5d8d9a691306844ddf5af5b38472a91edfb862b83d3cb9ff84b6dc00c5fbe4a7a696c1ebffa863abf9a6f6de88175d39ee15e10926b8b9cc74ab5c546baac8cc329d40138075c78b8bd023263e5cb146c08c04ac612b29c1f71d4ed450e530b71816bb7064a0f891a3e357b00e69f3c80eca1802df8567b9757368fa9da7f7972d8088fc07d5fb9ad3c2349ce05fc98c2c3a7f29ddeeb08e98871133a91c0c4501e43a456a1445478082952e170bdf56b7a78fede2923c6aba2537a6758b96b4b56eed00ac3b39be9b712e3fa6dd5bf138f20642e4d0c00fdb506ce46a9d55623940e181aa9a83e5dca15b81f1cfa350b91593ca8890394a241ac2f03de72aa78d9472f0b94294ecc3440e5c61e3f43ebbc7e30aa1933507f59dc9e0498dc005721502bc421bd518b0864d7e9341af60560bcce98cd9afe18512a30a08654b7cf976ccd482fb0e2f7dae1cb0e7aeef5dbb0eea7002b2ea6945639c355aad99e976770031a2c9d054411fe9af66bd6da5fbed5c44766733422e01b88d88896400ddf1b4d65c3135b058809e0e4798a47f5265e3d8529b6f1c5f8b555a74218c327fe4d64e8b185997bf9f8ac72b391c384d3f191b8d66070908f91afdb3d34367e5563fee683361624fb868fe51f6e5ea9e6edde2b4664e8442f39fc7b6e0024787dfe9b183a5d51375639eeb9c5d4643ab7173fca2a1186bed8cad38d13ddfc9989cb98afc69f287ff638ca003bcf0e4d2b1d01fadf3ce10c7151e761e61e08e3d406a0af26db35a3058e923965bf8957364eec83175696f8c740326680dc16fb490ca06722b4ac7cdc10097839ebbdc7b97a20939c3ea3b2dd54ed63c9e7d793646e5b4ee694bf560a566f77cba4669b343e1d7531eca12fae829f9b85ea953f4c3612937e01de5b864e48b23d27443be1c5ab41dbe9772ddd27df3b8f902c370c25f17c32b3adb04cb7e68a940d3629ea1319d1a03c528bcdb4bdef4dabcf4cfcf06135ae3a53d2f0aeef79f9d3ffe5b6a29cb65ce287aaaa8548d1885787a9c0ebb9918d8ad9c660da326dc67e90050be13c4e64b77f3f5140dbc5e133613386d7d8c1518639c3b693dc8dda21e9f424f674f36eee77b07e6647e8f242acacba7183dc53d8547a94b05f287f15470faea87127f08ac683612906192c60f0f74ec5ec8e4cd73915d66bcf9155dde1eb4fa885bfd783b91942954dd8cdf2a3287df9062d00266c37233807da786383806785b1848d874ed411d0d1f8aed80cdad6e013ff0bd286ddc5e486c36eb59b12ac885d269370ddd4d416a764be4ba076e2371f17c6ac825b08a465760a2173b85fc43a6c6fd22d515985fc41862fd3a351bcfc7f3728a0ddfb62ccafc4102d922cd5d86eb9493a222d2208040204d34ac93f25a05e7be258ea48f02dcc56f4b592cc4e3f36c600cbd4c077a69d0ce0ef0139b17fd9ee42df1aa051f7e8b35c8eb223aab593b0cd01f5b0dab5fe11e26ca334eabfe5c4061ca749b90f29c936a07a29d732707b102db9f32609240d33258651deb6824662ad72c8fca36107803891d2ecd47b2c22932affb3be4a0b583893c0a494917c522b3b9a342a79049863ef2efbf7a22eae66dc6fcd77088e97a66987f30be95c891d4de76a0243a0a535810b6aed100af465dfdb51e521c351099e6b08694d53e7930fbccde0a97cf4a3b7d3fb923a5f6f279e7f208519531f27c6577d1c1d0b7f16deb394fe00e3dc3028275d71eadca60caa986df7f27807a764057a3aefbda7bbe3d2cf71d301c1126ef4c1ceb50bfbc8cd0b74bdcb22d7317b858e05c54687ebaa0d9ab822e68dea08e3d719665d35a9a0f1bb871fb2013837af9b5a84bbdf216176104623859fdf2e3ed29984ddd784096f1108a966cb58c03773b6d0d92b3be3609ea769168146f1c1408f8d9d39d1e898723595805fd3803d7a22ac044648a0c48ca0f400573eb432eed27a98004ff88322dcfc8b3e3a3104db731c412dc4cd3fb185ad2050b18284db6ba8c16b9eb29ee39e33274c05393ca706a06c9af216a6772901a6807c868b517c3b9fd8c9c386d5663509417cb534a461abc1219e35e34392f40a29379a27982aff82deeb9be76bc84911ad3ad8c1daa2453d570d2f3142f4935a8390277a65d88117d7ccf9e090659abe28ee6c5014d86ea9beee41e6b6bd60411b59b305a1bc1679d8d4c1bf446f3916956696c7da6f879479020f8c71a85a5877d84ee05f57fe5b3bd0307ec8662bb5e39fd23557d1a8e1a2bda98ff6316cec396af94cad3f0477933e671f59b95bd9e5c02450e2faa930a843c3db9b08feca687add806c300f1d9ebcf575859ae5e29285c9d6c77019739a4fb2c1a9371f1e16e2f871e8e19140656aa0e741ea6650c221d0bb1567e8c1d4197bc1637c11a03b3e2964528caff41e83680282277594caf9de7019d6d79eb82617f9ba96b7a49a43be7c4f39f5c9a6d857937ff59999feb15ff444ce823bbdabfb5bffa470ea2755d907e232c816a252cb96606cc6eeae96890615859b2bdc0a9b7308efba8d8d4a58a8595154ac4c19b9ae72516fa0ed6c6f26c6570740672e419279b42f0b528f68308c7531721b53655ea43a87879a55721f9c3e0d8792d883422712d33599787cd9e41867a390d7244840dc8566d6f9c4956d3bba1711be77cc68af7e09abe1381f6bf5e96ed38baaa4b74aa06d6b83c1038837bd5e59fbf0ed8c591017ac32de25de5faeaeb65dd8813d34e64a8756dda8c309dfe323832a8c640b84323f60431682c7c2cc111e9f97b586f02e7610fb707a5e4462eb9a45042e96eb88dba1ae9b314bab166b5d75a26aabc4fb330b5fceff5151ab31b4d1b1b7fea8ff175aece839d616544a1ee4b7ec42fd232cc3aa3bcab042d647599b155b91a7bdcce23991ae16c8edb7102b51f2579074c03d40c7075fd2d841a58a8ea2bea2cb5708200873b61cecba6f387e74a2141f3faf6702d6ca63c8978d0f3f877b7c38bebc7f21e01dffb3363307a73bc8bd3064c3a49164523742be27ac650ce70b644eca28e0678b67cb8060611cea5718b63f683bd26ff9329a7c5302cc5b0ae30476fdb5cd36f60acbc608677ad0a0ab1eafcd99013f0eec9cdbb7d6ac2ebc4c63cef4814ad749ad418ca4b4c48578c77ce44951f3115857407512bcc0edd41373e39e76beb40ca1991061a4c5ec096bcbbe63d92432dfb41a9c95478c46b9466efc8fba53feb5d2330d9949b04b770d552bcd4be332f549f27f9e468299cdc39e7f64eed8d68ef948cbc62299dc42229fd47d9bdd4dfeacfc8de18d123a4aba68c5e06dfae02a1cb8fe4a808340dbcdac8cabea4da72439d7a1af9864b53e55203fc693bcc12bcd766c68f80198788949eee66dd5f2bfd10517816cad588bb8d6f74efb5c8e458da8fd29fe9fc6145007791c2e58ffa97bcb2b9d6e789ee6ab05f4364347c8daaf4ad4547300c1258be2f658e499cba8e975e098367228cbad1fcf5dd322769b9005844f5b242a8339f896e416c815148a84c2bbbe28b6967f7f2757a143b8fa7721f000202182d21fb80e40ed657460668135e23d2350db83e6759b8fb6be4a4b11fcd5e7f7df619f77577d7709e6fab9b74f8c99e248da0bc079750e94142643390a49d14ec2230117a01defc7e5532f3e263be263f1f9e5c68a264e1c3cd8f08dd8ad65fa5703c9017cdbc9a907d41b28b7b0337a5fced0ec060b65abdc118c48d66e5d7fd8b26a0facbdbd7ebea3ac1b6daa82e7de4267720aeb7d0987394e826596d514cef35abe2994a789162b798382e23af4db816b21a07973437f7996d477c2ccaa9dbc4481afd908eb0e84590debb508e1ee72325f6c9956fc17566e06e9a75fd5a7e3c1432d1f92639cbadcc697bcf0eac245f59bd11a751eed868752e1bc18d219a5b1cfabaebdd6e6d11748ac6f87796f4f566fa83332f5afd3901a6304d50602a1a8572127763ffe3138d2d7bf1ce84fecf1a037b1f4e4b6ffceb568f081f09630283691e26231374cad97eb2fd3a9344d4f896d6b9f2bcef4f09753c183f1f9fa8b9f8c3bb5b6ad70e383f378155f1386124f1e5132160db9d57cd9fc39a8f3a368bc6c17bef19758f45db30c6e118f2ded154907f394805d4a92587781194aecbadf3117406c2f0fad38cd415244545f670fbba264c2544e87ea07b8fdc76177cdad7882adf9e7bb0e8b0ba9b7ec1a88c1b998b23efcc40bb6cab7926e2dfc85e14e8365b4974b6ae373bd12092a9ff615c3a9faa3d3a6f38f62e3d6ca4aaf96538a7a20cd595a814289f4bf294637d4136373f429ab57d6e1e1bd1c6a6cad072ef713a8a8e35a93f0830da419f672340b7346948d4ef3b7c3ff0d748aba8f9e7fc9a07e804a7aac342a505d0e008aa0ef95932a571752dd5a6d604e41e336019e58ee2d78e6e3d879ba3f231b59b216a83c5b77c40bdd69654b7cf965aa069eaa392c53a2eaaefb095c444e788485927b4b9f101ea306c9ed7d65f48284fe9b4e98b31a6f86e076ed70ab3768b6ef8ef743e3375871f1cdae744c00709da712826018573fa220ce1e5947889de1be5c0343754b6b22dcf4906258663c9c658383b75deb42fba29f16081b85c76ed418e0d78297278660d5d29907f474e42d738e652825501399fb12ba3fffb299a5f59f785f80a25881f670b0a092ccd2e1db39a57ab8d73bb2a7aec1f6c240cdcbba48044fb7450fb8ebdbd10a8ef7afb00e6365a6cf924c512670ef4663a01b2633ff69e34e2041cc287be7d5ff52e0e615e6481ca1ce2b404620de371e5728401bb4e78861833d5ce1bc442f2e201a6d325885ab32af7dfa92015a763e01fba58bab432d0f69af254477680b8de160c9df3a9b0aa2b5d7d2fa15d70a1c4ca574b3eac113b8d6d49a4c376796547ce1dbbc21b91cd8e7e90ea1d9f7f83953196f4c28f27a84f098cd6a40b331e7a2799106b44db2f07dbc4a3c9dd436381fd7094c81dae15d90222ab017e86120b2c2804ebb2ae19bcc8f9e7311cc208ffccd420d0abf7b6e6897974b5a61dc7befcf72637c1b0f02d5a55ce9db0fc82c18bd30f0ce3ccf2c419faa1c5fd2b76ebe42d237ac40c0d582b369c0aec335ceca5dcdccd3e3bb2171bc122bf00b45c1805b5f43026f3766a616d8e45b07a0b5ebd8779d9191b0948ede72953ec7a1619aa01d41240d22e8b3a4d2333dbb1f4fc03e84d5aae8a0d1dfe27b0517cc4231936a0e721699dc4069ba30ffede32deb7ee9f4b19012c92872a5a5d75e6686ca6ccafbb81dbde2628e62af0909afceaaef732f66ad88d13c18e17ba91f344e028b651d0f8a759efaea158aff499983935cec07debfd313ed3acd945e20d4dfff690021361580dd26d53bb84713b2c326223809d2475eb6dbd8a00dca24fcb8fef23f6406fe764570b28ed4a848be27837a4edcfefacebe2db8e0ceed8cbeb6019850db9b3169c44bf941f7786563bcbccf1cf9d0b7d2d8158c91fadc0b610b4908d09c2fc964fb2eb8c7b60ba2076314a24b9b5bf2de1afafb050d3b20461f7e855c3366445a83c1c03480bf914c15b808df97d4a9631b13295749996a303a586e746883bdc1f2710bba493f684fe20fce025368657b5128f94d961114ea4999a733b773927f09e0d7d3844f952998fb0ccd23939916423c94869181e918a4cd0730a2972b12bcf7178b77088d4ba3d4e924864c9a9aae2a79238256af1ebe63b0cdb7ec69c5a10f77589a5f176d2693448ff7e4e49533dcda22622be3950dbb11d155dafef6214033ae64b347121a48eb9bc45f4f4a261618ae514efb73d41afdf3be003ca6e7b4bdfbe692e530afd3aa559ef18ab8893cdde60ba2fa2015b899421e9f3427f425bd9eda20a2ae7c55aecfc70a252dcf422c4cbf212eb73d2fd37aef0294eefe0c0e6bf9f93d9e7bbf73bd26d4db9e5fdd9377702f7f533f0e2a2cae3774fc2513c205dd708f8e8e611aeac76a16c792d3c6a735ae392c9b7b371eb7e6c64865f7e51f989d826e65344225c180fae7b5736a468bc7e07677be25ba6c168cd84345d26431d6530cfe033de4fed79638ba282ebbb11d8f1a8ca54f70f71df8b96d41e56da125232f08948a83e0de2c8e67c58303105c2b0b7def44c22cec227984a25c860dea19ed0be51c43b7e81011ab9a3e4a75bb0ba81a5baaa743ecf9a0797af39f4b298c755fba199d31f5810da0f6db34f7c2f6b5a9d35c455ca765827a629fd0a497332835081f2d0487f7b52e08c46cae6aab2e5456422ca35280c75c70d7d2922573bb5f2fd3fa24f8f4a05a3d77e2c3c39b1c126b24c52faa6864974b2e89adc78f409ce391fd11ada01a2bc78b2d610b2b98a4e647790e4d8cdebe0bc3c3845f87cc5cb134a5d44f2ba35c3e004702b1461f2fab6e801a6db2b765f240047e940dc924845250461f6f1f2956b3670b6d31f70966b4d0f1e20d81e995fa0c7fbdfbccd30977ad67f75ad051bddfea49c7f2ffa584afe069e937e4fdcde6d6ccf3fcc443ce221849726f49503926876408a88c78a9e2855714940faa9a436268f37830c644b0d21835734feb74bb6819a95d77e94b316b1354333c6fe0ba40e68715ec09277c88ece787d9e373b58ff729f9c6a14f21f0a98e3e8f67b6b62d35a9c84763bb9a83f61862ada953292ea355e90a27ebb679abeb5f8428f4a8ed4c277600932e61abb13afc317f728f0a37ccb962d440867c8d9e8e6e8e88d72c201ee139b10eadccbe3120e24137c83b3647d0f1c8ab8f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
