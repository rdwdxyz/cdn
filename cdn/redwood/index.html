<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5755253f4625288b06b14135e2fd475478d279ccc14e3cfc655bd37c8f77589ecf043238cced9db0dd27a5d7e9b0ba62a5522699863e6fb55b14a5539c3805afb5cb16af0d996e4f7785f3b67669e66dd6602583d182f5b426b29cc3c2c4be15adfbdf92554984ed207b4f04117b538edddff3ccc15773bc31fd5d0ea1bb818d9c0e3e5b3c3db9c12a9612ef9f7c9277dac6c37a66265695bafe5142ee86eda4547fe77719c294f45bf8a160d5b19cfc659ef0f6b73bce84b598d85fca2d6c68b65cde47a2125e784318061816d8b2d400cd83373ab5300566630981933bf34db7919bddfbe663d162ac2ad95deec0649864b4a969f07feff823d307b5f0fc7773ffaa220ee64018aa94701de67591022a54190dadb7e5acfbb34b81c5785833326024ad55b1b153f2b091af5e397bfd5c9af82ac65f63ba52aced25a5a7cf77d563a0de447a4468c3e46086dc7d339b3fb1fcb728bd482e994ed7d84a2f8f0201d0721938bd75aaaf63da9b188965f8ba718c23c337a4e1699a3ec329b1d35216c04d2f2bf110a7d924930c2190858446b135914792a465b457dcb541fbb7271f70cc5c5f4c0b9f376a9b635682509d044fa6942ab646df1ce5e7d0d715ebd34746021af4ad68f43b5f4287fea434afe6f5117d577c63aba146c161ff4a1f426b150cea31a492263601a160871ecbabc4eae9333b0491679706b06e7d07a8a6a15582a17b0647703517367e6ff71821be0e74b11723064e6e5dd7531ce53c6468b62029d14b52caac2a92272fdd9d7c08e55cf107f0c87ceb9c244d16ca5032f289b2b4b636b8ba97a78d2f7d1227bb315ed50f98208fbfd9cb92abf79000643e1ca26d4196742b7e4064f3975d0105a8355d81ad018d77007195e2de39ac2c87e988baeda186405747993070a06c0b6663d0e5c6e8c3ff9890f86e79f70ed9eef1130a193cea8e91ebda3e9033c52e3a78ef1cee7c1d54417808c5b3c55d3ed7bd40d0e2d5395a2833df06b42602cdef94f16f2477cbfb8c99edcc422f0c97e2ff52c8fc3c85175c2e40d86513e6476f4f586f4e7c97d5d7e4754a51385a2e6250530945d92ce610c315b7c09d5c4aebb41bf6c23c7c80f8e9ba17f1aa191f4eafa0b75ef5d1a3ec25eb7e340094bebfdf186b4d71b05fd73226b5aef495a41e73d9510908eb0db5344ef7f3052494bb88fd4f73f0cf165a08558d98206a2abb97ba94b4b1b7bf73d0ce863f064345b7d6217cde3f3303559f51bd9b893b935b962884e88a8633b247e351f77178450804dab2fe4e9ab7cb42e3e35282e3539ec43cad1dfaadf4ec7b1e48fa64cb4cda5227ed77f815174ef378fb6bc4adb4bbef2a8e67d3dfe05f7ca0d8240ada08c78737d00a07ef748b5918bd0c9b912f5c389be69d3b8a2ffe450c2ec24248f0308d524a22ba1318c38c5931f5db2f8f62d16d24c571b0e43e2f749a65382848b52c9b683ac38b67227015b95b6f676dc1b4fa1a139abc7485e1e066b21c4bfd26bd5b37a68f954b01ca344c344144fb5e12d392397c30e89de73dd7c56eedac6046de18494011d9c816249d8ff94ced2b1b90d33a0a678cbb38b737fb15ee4d9611cd7f76554b328b3347632881a97e89929d86c660afe8e5661d9a64a22493dc44c1f084ef34b7a1d33432ccfc288966b60781ec48220dfa1ba188de65be222dfb94a6731103520e54fdaec710240c2279901e8445e52a77baf4b65c02abe2053235da973c309865c158d396b8c43d6d9b43bdfa5e70825dfe001ab4dad113643373cde656394a149cb767a669c97aa1734a8730d3b292ee87178a5249fcdefb87c4e26228289e0dcf043b923fe5e1c0ae66077ae19d52613d0a5050bc9c649bae29239e7f0c76fd4c34f12aebeca26d0a1c2cbfe2ee5863acaca3bd32558ff1a1c9bae1c6fb5c691d1e4dac43d44c9079262b9138f0d7e1d37bacba43e3189b7c51daa2a17c2c38b6f6f1ced56bf2c5df2bdf2aaf804a72529b6876d0eec83a1c77ee5dd9872aeaf28100d03a6904ce6f13fc59e1e48c2b517a67bb7d195a5bdcabac1ea8f9d301af40431197d3f1ce07cb7d4c61f044a38daa3fd62f587e3c523f787b19a227d0309275d4feed1b217d0abf43fdba42fea3aba5e5b465f52d59e655c9db6f4c2d2fd13ae127e343b66faf209eb552075d0dd84459ef95776797d15fb622636c7b39cff2d191cd425cab0658a782a502ac5d64f5c8ce606b9572ea6ff627ed5673f9f80287087f63421f5f5767080cf88a90a4ea0c531110ca6d1038ca7916df99494a72e38ced5fe2a024c2b9d2db19b9ac4af0e81d6ff48f6bb96a00a8ca4fd2eeabf0200a7f96e4ac1938b5174452d68b40f7be150e0a364e5841f93c41fe64f50a9b5f97b37cb8b463d487adb4da110cc11448b0b907b6a090f68bcd3b010bb3b2f65c79c35e981a0c2c668ecc51e87a34101b9f2fbac766d90d03a6c0793fb1dcb87db8dd6931bfba384d58a743b101965281dd609fbffca5a552ee88a4e0454effbf26a19e532e4b333fe5b97829c31591e74a086e9911111f1df776f6d2bb27df8c9f55b9220fe3f8c621ea730cd025eae2ac405c208ce96823bfac20176c2d73ba0d6b99e47cc53f66246595d184d3fbf07c55a5107c5b80ed343bf00f56ce736e2d20820b8313229d51650a043d2ef114db67397540a8d7e481cb93233c904e18463275d27e9bcfdfc86462d3bd12cd7bfb743ced0434d58951e28a18de65a70baced91551819f2460d3d669ebd7c77663731c3ba799b732c3da1a9f0813cfb7f53c55404f02cce3f9a2eb41743942be3659b9550bbf66e75c3ab1e0b68a83ea95aa132da82d13e66c0d6c32783e77f2a918b8775918547d233bae97f67afabfe7296646b7eefbbe2acdb389129e921ef2ba5b8316f7e8be2773ef2ed7d8bf3f78cc54cdd83176f648a1215429112f975ddcbc84fd72bc0cf1ecfaf43ff3af777819d17319c4d842271eecfa7b25ac45b7e4aa335c80e718aadab6eaca1a329e233a5c0426f23ba9ec830e6095ba6956a599d54279e20c1f1d736383b47bbebb89d3b015c5a5109991c4b478893303df9bb985a14b088cf2416ba1a33f0d9e764f8b3cbe706f71a2d397545ff14133cbd97fee2f3d264ea11118dd97aaf9b21dc65824374a91dbf398003ee20eb5d6615afa374445e573ddb2d8ab528740945925199d8d0f6297979fe099a80cf8d3530c872a74b16e65b7f6ab8a37f99a59e19e10eadca502e30c5e1dd915b35d960f79f7142b243556fcf34e9c75d1accdfcc8a6fa0c15ea4611e008e3f35ecff94551a01afbb0d467433a4fae3d10223ea9baf0cadcf3728f62c832ebf27e3a3df885b54d9319ae5f20b20a02c1cf833b97e6a88a8daddd337e2d756ca8ede42f9c5b56477e7731569cf51d74431bc2f6d8cdf355cd581a254bfb9f9d3b22e5b968dbdb333b345999fd4c681e3d184c8d6b833c187dcaa009753a0ed4cb31a523d8e842da4589b3ac3027263d033779232bcd227627f9a9d6916c31f15cec3256f6eddcee8bbafdae6cf1dd4dc5b89a64c3e33a49b0f7d9598769baa460fa294186f835e231ca5f91938af371651cb40c23425d31400596a675314559e5bf4e03bfe26c643ffb52e437cfea0b374a5fa179a691d3f197d5894b804e6cddd3e2b8fed27be90df7725323e146f4e9210200d659e867baf9671e8d9a910c8e2ef5e6492989e2945a77ad3b477303ac2589f1fcd21648baf70ea9dca7698fc14abb55ada81661c49045c51e41775b6b60859212c767eb1c449903dfe946125c8bc74fcbc9548d0bdce841101e3a0aaf6f02a708f503d56c325d7431ed06ac36898b8bfd0c4ea755154c6aaea0000801d629c31f653469dcdf7e841ee5d6b1719e0884859ab2bac18eb1315615dfa9a2e0dd8f8a483c60c4949b22bfbcc013cf5edc9915d5c185e8e352883f1715827b4f079ecda37a9fe6e87c28b57de8f1e1849c84f56c9c1631b5284658bb3152698c48bb6ad0f7ce3eb56eecee07a0c6f4e2ec00977b0987886ba623320983181a5fd084e71aed9b5f1815179630cb12cf892a3136de9c2cb31ce41eb962df49eb8a3d25e6a2411ce5bc917e81072b7778d464a910131565dee674e67c22750a649749a831c2f69589a0fe546bda52df91d0518399d4da57ceb2a3ca9d0b19879e2cb5abd016a35459eebbe054602848b4c8d8ec3bd0aa616eda7861e1d0eee9a7949b66c97ef5e4fcb4e0132d731a01443100c017f08e61193fef1b802b38149166e1cc41fc5b8fbbc2a880898b50ea9487f26e96915d42445e9e3ec939b1fce04c260bb94993e2784eecae71435bea081ddc9cb00222985252e9c7db48448b269ee5ccdb498809a5e49afa51e1f472a87920e33806b00765a0fc0a723b011fb4ca8af95cd133d50e54e48152ea784b398024fcfa2ddf3373532c1325eb937dfb539ad0f29b3ff5376ec0ee045783e92f3fb713f6aeccb58724091a543698f431b8226448c2bef98677f6b637814b9cd7015e9ac29b6e558cbef3d5e64b71fe647f83b64acab31fe31000bf1709c6d3d901fce5b85b4d88b3acdfcefefdca40381830821e2e3ce5975e10a9a093e5d9e2a91af195b863316408c867d9c792862fcc5897e53af8c7bfc5e9d9ab0256bd52c4cce4bab3e9ac9383892d8da3a40731340a1ae3ceb1b19279d8d69d924fff61462866a223f56239e1f9f937cfc2698f612a1842fd98c03280cf2c210ce9394f67fa07a5b5002d8fc59af46677d245938828b7ba755efac205cd92b8b884c29c96d3d4a0c2093e69a442ba37b5552040001971a5a41d2a0c3e3b8de2d74b7d6a20f65715a447c5057f0082a6a64581b81562e59788fa770a3a911ee35df440d128cd0738e4ba7b404096b12ea1c4ad147fdf41e80527ccea74255ecd83e2747ca7e9a67fe2548e0ff4e00f3b08c9465d21e14b2ff322e6c3e4287e26b3aa815568866fd00b5284d3c7d28b8d95b30e595b62c49efd5e2d16b39e8f27ff2bb107c87ff85cd2a765bb75cbc2daac049374d2e1f873e78f1bb77e2172454411ee96a5591b201f11f778930634153ae60ea5323280f5e471f4d608832ce76f9b942c3778c9faf431a5f33c4366814b18642e4c8b0f28ee3ed04bb76efaec8993cf9f5c60b872357c8d7691d7cf6ad262ebcfd606edbfe5a2e6496ec90198333a29c82d72fc1f71b8d118781440832d3006f0a7fb7e2fef5ff5472bcd4a8ce9b2777dd9884cfd7253600e7cfd0f5ed2fd31be89e221294087f7849f2ebf44a1e4a45d00bd5019951f1986510bfde84e4bdbb88c236f3e4494d579f229443f7412a74482fecbfc4b4cdd17a70cd81cd34bbbf5571ec245fbd90b122fd21a0c27c42b3a737d4e436a8f45f9d28f4b60ba10cc4ada4efff0d369257209cde1d081878ee97dcc2ed6f0c14428928d10eb484210a69e21bd31d220566152dea586daee4151a95bdffa7e35fec95242030302c8c0ebf4abf74c44d44537f95ca2ddad726f3163f0b4069c5c611a1cba6271f86edb3c28665724f0c486122c7a8d07198ba1b39f17ee64eb042ed21f7141edf1d90b34aae817346890b922d36dc85214e8b272f7517df7b9ede8677e1d41f901c911787387fcb300a4f9033f6b1a739c23a017fffddd437a8141bcbe5e225cb324d2e293a9c09eef8bef8cd464d2966d188c2dbf5a424975718c06b99d159a1eabfdb26820b59f940c24fdaa17a96088a8cf4723fdf16f57ed7723dcc2374239e7d7294f03dcef230d5eadfcb6ad62c4e93e27760a565ab0279a8445cce599e15b2b37c9193c78d3024e32b031170042038ce791dd1b48a20c63a0c160e8fbbe9c3b4b121a528d55454f6fc51e086951c2a504eb644a9cf98146e60b7268baceb96b8e3ff3cfeae7210af0128203676b3a6ec38eba4b154113ebd351d8f03d03bdfa2a930ee882922a990089a4f403cbc3818a5d89fbc841fd604f7804db64fdef22881a303c432973bdece7cee1a3605e258faecc9224bc403f4676d1404928cdf588f06601dcf48e3c211db3f5ee5080e736f44d7b0e9d385872f13f35cec06e6c80de094bfa13edd482faa8de7b1dcd300f4d7a43e4bd36cd51197567886f2342149e81ef1aae4a638ae49b50dd532045a9d3266a0fd8d72bca5102099d4f98bf17b612da0a21df0fc641492664e1fc6acf1631de9f8087bda06d7958f0161a195c7e77501e6f0681f128663dd885b118ebae6e244b8b882fa312f976067606363b923881a80c27015400456bd1439ea159435b05431e01307f377f6c165c3bafcbacc003b7e4d92f06e57f0bd5a39cc85ee9c76998c952ffe7a11422e813be6e2faf254395dcf9eadcef426a7804fef41a8fc3b53078e98e11d9843f3b816176ca91241c87a7fd4d8edf1d49eba8a3c5359d2c1107dbd2efa1313b2d1d1e8cf7f246c8bd636312a5b1f64ede46e86cf479ab3ebcdf91d58000d6663d438999ec9dc64c09e727d6905466fc7f66712f1baffaa68f2b2b6dcd33f7350a018b3f96c22bf090e32673479e913094ca3f51886a2b555253b4cca5b19cf6bc1e5c59b4cadd4b6840c3e8d6fb029d4291b8ba061b332b982d484702a78e5da680c54572be541e959418a33196a414ffa1fac4b1afc04b3204bf0bbb5e6ff66c4a6e8e8f476efe028e3f706af4881b35d66ede2c713b84f7234db9e72840434f43bbea3812b52b863b1eed1113064d0bb0cc1126dc28a2a14da3c574b8b235d690b365fd0ba637c02cc1709e8736870402c360eef1ef1e2ceb7b01c267e2631185e19c1b52b87b04e1e4869f38c69e69ea873b522f54ea3c14b4db47b19f09ff84ede744354c97edacac8e8b1ab23d4dfc98da85ec374a3e472597c3eb26016f3d645df345e406058da864562ac7459bb92de722f91a78ae95b6c0713700b608cec7399f41a368aa1abbdb2ac536232b668cf886efda54c8ad58ece49a53d0db9eedfcb072c0ef8d2c7a0ca127c03dbc750b2e604f1b78e85f2085f6893297e5a701b938981618873cbf916a5f922f3fbc1f8d8cd58ede4a3b1c96eab693278c27477f4a35b82baf01dc40f78654e205b377ecea4a24da971a38292d91d4f8da10b7d02c72bfb2802824c76d80b912be0725e65949f5b71567c8d0a21481ebeed053c364ee82f290d2f3cd55c6d3df8a0f66c94cb94f42a2d8df23b801244341f538a59cf0c92f11304b8a7ba9904eb7ef692deccb4ca88734ab9711bafbe0c7e2f8f8fa1a2e1321cd458683c1f2891a1070f32105c31c97c54cdd7c47e54b52854347d059da8e9ee302ba5e1b06a8284a86c1a74674b93e07a503854f967259f9f5465c94cc4029fb225d75d4776d01f2f39bd68f28efa190038406e796a50776a96b00d36581752c7c798a68636fb19c0eee2587cda8c36cb41ad42f2ba62a7279192c6f6ebac33abff1807cdf7b81a28bfa0deacf2898c12df63f3ded02fb814a33476a01c2b04e0d4b2c00a518ad5119080e0923b6ade1b2b6ff15364e1491cb1aeb52454a7ef8f2ede6fa3c40804572969cbdbdcd99154e6cd99156f87f9b9059cd55457faae74f8ebc4109cbd705a1a95219aa479424a990a45ac8645fcc8556146bd18e436a10d175b2b84a5fe33cf451011265be2c51b24bde382bbfa02ac4b0be086342999eb7eca00e792a7cd9c7f4e2e9c7f6dda5b0800822a1b1910c358b1352b534913e702f51de9c1265b329338aab66aa7313f323b612cbcadc6cd923a0c9be9f85d41d7aed2c5aea9d6157d1c2eba8c1fe9263a7841e7916298b6ca2d2b872609b448cbb84bb1b24b956e21809091f7feb73509f1ca06a173473c9c471c4962b87840d2af6f333d54c7c5f26f44ca01e6fc5afbb1df8fc4ba5cfb8669010adc4a2f1999ea6ecf34aa7a0b7d5a5ea8ff57eb4a0b57d6bf0d3375d9cf6be21373dd105effb148fc4df15a55360b12fb7e5a001e68285174533efe963bd7248af3ba6f39e81ae9ecbc2f024b79b9307901ba2d22f3586040e18fc87a35319cfef1cfbea226c72aedaf72c78851359dd8f35e27abe6493f2bc6c02022b0ca71a40973de4c7a6138a46ce3054509722499dd27f8809dcfb66cf2a6702aa41c3a4a0325b4b973a5d04dfa4c1cf30b9dda301c58c2155859f582ade30e4915ca10e9de6ccdd593be7b44f132f2a2d5c400d4cae71be6b67af97635f906b473f17fb99d22a04b53052177298edb8b897822d44bd0953b40be1c702626eeb09fa1de2e7d3e583e53a07030e734ff00d60e46aefd1daa3e202311c829ba0b60fa53b37e79fc6d1801e65e6e5ebb16bac2753c21c4bec7b4c5c87b544c40b7de72d7a149c12eb643116683b6f91bcc1e40612a97cd179bebf051e2c24634beaa9d7657f01c6295144f506cd3142567fc99d6e0223fb170967fe6b20addd0a9be72737450939eef64041a9fccfef6ba42b1e08a6be6758195a5485c8408b1d050efa6e4d61c5fe9eace51c9439f4b6cfc8d894df5aaca4f2cb1120a171a515860ae5bdc25eeb1227a434f102132971359655ec807c30b24034b566e3c510f8f4d60293ad5ea8ff724e33fca255b52a8282b903a20c794895870e486311083ede5e757458511e7122b61e48474d4a3f37f2651617b24d33b5b873f9aff69ca35f64dd2bd515f2f9e4340c1c952d9966c77cd4d075a183e3cbe7a439d8f6636d45696167b42b66da38674bd03fa5d0186c4dbd4fc8ec66953621a752a26e66a4c41ad2bec4ac23615787e2719c3fae1f4718aeda1a25f2ec01994f2b132a1eb58e712c74a4226fac8501922b03fdb0932a49ad40b72d547e5ab01e29b3d14d4b7725625880c0f57dea522ca310d737abfc83e95762931ea61b5ecf8b382e4d06cb7d9f25ddf3cfd4dd5f3a318bc3e49cde29b0ee78492e5f09d963427cf13ebe82dafa418564d454ae9f597056f4d944b050cba45a15061bc9748935c276326ba6aa9272f51ebf1d4fcc1cbd4f57208282cceab0615907ad4790c6b3af7ce157a4aadd829478045bff9ea9ca9cadd24d33280761165361fb48bca0fa2d01d91b7eeee12d2cf2ea801b2c6395b277e4f7c742ff3e6ba0afe47faa1afbc2e15d4a67a78a330b3568b090bbcf7c4272fb2beb307aca91a14f342f966c8c1fdf590e6d97754f55389bdd273979226fff9c3183b72748b219c1bf3acdaa3061595b1b805e29330102be2ec62141ebc11cc48a84b7b9cc7e63b1859f2ed39c87d923b1dda189851eecd7141695b061d8a5746134b4be96fdafdb82493dd8485bcde7b619c87493b84aabf49da4f2912c69aacd9bd95df953ebf72950cc12aea33ea2aa6d22c39db81075f1e3a547b2aafdbc1a52c0c39aac55dc49ac6310b304259fbe039fbd92f907b650b969e0b66255d78b0f956c57612962051c78548d1c0cac26a3018d45da6814140ac3ba9404ace3c767dfbc8b01bd081d90d9804a7a3d68edfa827ff9534c8e4fe2c0204a97e917b53589354873cb41bd986199d7cd4e0a78d23a4d4fed860b102f623f7f6e58a7a83c5ffa5d7050db00c1992d753bf007b5e9303c929d4916c27143a9bc897be28fa88dbd5525e6a94372e4ab4e68bcb8174f73b85028836e5e2721c4aa953da10e861bfc00aca342cd6988f7f859ee0e5de8a665e844d6366bcdb4294e58aa6c34813dfdbf41b569d7d56e871390ea17521ea9ef2b03b5c766d0b326493d368d449c9901c78851c25702f0f8400b3f10d95e7ec524167b41414dc537f19dc25be16efe976ae2620c8f6c3a400ff6cb425eee66ee922ff707794f890124327fb1ba53553f7796694c1f9d1d8dc906bf0eb5014d7f09ea4b05f0486c9ec2cf444ecd6e3ba61ec9966fe8bf87b830fa6855e3b89e8f1b22c12962dc85738f1a31666de44c4fa128451f4684560d636281f12795f71ea43fb1ca23b262fa3249056bd0522b203e47283b2f68483fcdf4bd1ea52e35ca262ff55f6db87efd4bc690f2cbb02c34f0ac738f0b681a03626021410d500c105a7df7ae3965e361cd78e2456692f9f7d730e27bea3082716f6abb4b854e4ce1c65f3298dee6b8bb929f90728d3baba419424ff73306634b143ebee2a65ea4612b1eaa55ad2047579127ee7ffebf27b1b33a9ff304e717f5ac481c85226a09e4f67db2a0a0138807118e8aa53b6f6a1cb2c1535512351f8314a91e40f49a368d887adb630c0a93f4e0f064619bc99b55b7e60c0639a125d5a1dbb3b1f3d2e129a87ea9a7538472c2c7816294fd2552c877a62943960b4c8f693e4b808f9b4cc9db3c4a51adc536ea49d0c2853286d75b8d27e22ff2a1a82f274f1a7ac50315230581768c268d55d73bb351daf9cc645bec51aae01e3ebe335f172120456a25815f44e13688d37e89b950655de03b638ccdbb6d8e343e5ee11b69166892fba670a9275844ec1400d46df74c24bab30841229b141046010cf124fdcb77db60ddfa63a9d846e23a255fabfb7ac862b665115ae0c19497b08809cf15e6e96c525863a6273fad51e3ddad2f9ac25cedf048ebe7ccdeebd397bff074d3fe42b5129f2bb55cf44ca66fa5ca050432b65a130122c2ac4220a04dc145ef000ceb707a2d249897b8d087927b7d2232dcc772ce968c22f2f6807d00358eb96cec084d7178c5ff73f7b6958589260549521fe3aaf9c5925ef819e0a2b128f3dcc79c82890be5fc1a6f6d89b202779598f7f8ce09c4ed134b573c0fc580918709ee0ad41a2031aa821c61d25e89317d960a2ba500badd824ec3319f8b09f8e8ec2b7b69a3016bb467a6039dd3964f7b5e9ca149308b39a9876804e198629aad9682c6e614b4042425ac2586fe72dbcc72e3c5c0b5f02c7c3dc11a66daaa94974289cc2e88a1d159e1f9432c8d65aaa82938ed4ca8bf25a3a90c38c040cfc805d64f8443ce5b34e9b108a1df00db9edac1dc97e73ea1f95b3f44df03479eda04cc8324318bb3a28bd6ac5e357747fd2a3a0417bc134bc08a5b44d425e92fc67f9ed241845c7d1f4118b4129fc08ab0348fb0d7ae350106bc2193bd581a63523afefeab178dee015a3004467513b05f4c50726618d55494a17009fb5e7eebdc6ce50c357e547e7189db4688fdacc1db8cc1b7fe2f9ef3b99edf9433f1793a630e9b5b93897a57445ec1e3f1ac8f2602f63a42840001a0fc9ff2168d39195555d75ba8b626a42e7ebfc7b8815a66dea336d8d4406c0bb4b66b55cd1d3dbafa048d887cd9c9dc9a80ce4c325d1bb387d40ce3478d87d2ca18578ca4e7014a9a05482e7e2aed755b38122cfe2243d67c936cbd93884a8413d7e959e5e2ecd189e87e3b4924499b8cee0ef745da9fe4dc2d0e99ed86208ecc40a18167f346a83e9cae09fe610adf82b49a452d81677f7dab09caf923d59b1a7349df06d7ebeac2ef7a66fed569fc099def05edd1d4cd47d6e880b97146eb0826cca9b3bcad82298f58d4e5076a5f7672522763fed7f22fb74bfd208ddacf14982d0e7b9ec741ffba6f6292900219c1cb71a74d9b2a8eef437dce1c98b6223b6f7aa85a39de4133a8f76a8e146fa5465c5e2071e0797fd470ee9d12730d104b8685687aafb798a3644bf084924cdb36082364b12e4efed035b5b4c2e0c5d54dc92fdc495d8c7dd63731c75c2cfdbb7122f919e69fdc2bf83b54ba52b857212ce84bce9cd4d8c540460c852ee17f3d8d632e114f360372e554f20d84babf0906994aef8be29fad17446dac240a49d7146569d610312d00b792ab4cc455eb12b63f6a1b41c2db2dd5efcd93b4e297cf110a1d012b50645252d13ed98d907d9b7f0d78d418c2a58c2a70329fad6a948c87d078ad6e146785f44b6db1ac26f24b28f6b51d36b3ab9d9dbd564619b1809069e2625e0a0022b99f1f8a29abad417238864815e70fc03484af0a5fef21fb007c9916a29f2a60d46de06bac1a4c957264dc258cb55cc083b7d8251b8992011f35b65fd942dcf78cb64215f956dc1c34bd1e8ce3de0495999740c6be9db65787fa240b4e2974fbbfe968dc4241635fca6144461e2686c55b7a2a77423011501eecda6529009f547d172b1a17bb6d27ea8fbac4704256849a93a7bf10d4bdf20eda77bab8e8e825a176d6c7b1a29c523b3e8f69a054bdc75c2e58037dc46777e2ff668356dfd08145841df71a0fd5d658c06da3cd153641458e29d23866a8fc93cfd06fc6699e2bc1bc399e244babf55b12f5fa91959f452ade8b686c2099eaca93e95130fb06b315d6ca9b9de68811b7fe4a560f16508c47d202f0cf4991f8b1ce83cfcc1909691072837ef9ea8cd5d859fbf5d4e46f3ef7b8206d24ae765710b50be259f85b79910f38a023dbd7e5d014259a8b8630e1beaa16fb329414bbb225e7579ff01ee46b02bfeb9a0efc888b287a7669c3d63c2ab43760dd1332c2dea3f69e3faef3de3e58ea8397acf7a0149204e7df1807313c440a0f640cf4b28731b032f3c0745eae256a1e21854fce777315b81f4b6603228895a2b92ddca7f46c6d3c4d2c163bfc2bafb3cfa059964aa2d6ba420e316d999ab8ebac492feac854124cd8f4e1295895d2f28b5d849e8d0516d1f5535c646a5da0003cd69e6463bad187d47bb4fd4bade4edab3dac8a87cc08449a2848fced3cccccc3c1ddb0e8df8c80ec821726af90628639c46030550c2f2223811119f5b677ff8f9a9a93fd9f31a031113f09d5e8287da48f9fd0dc7af8513dfd7b1bc4d7891121b1156efe9cdb397dd8f4e53c5702800b769a14c544323c3a74262a164f7bfaa2fb667fabe6665bb7cd0cf4f7d349b8b504e9b7b67749db74ca5f37f13fce14b5b5c64a66369400bbd9bd9a939eeb0bf411adf7a835d2ebe8846a86750a7a569efb51a55bf02c933ee229b49cb0270fd9d94c86e92e30cf4b244ea6c1ac0ab45c69b994829258799a1a3edcd12866e1cfd8bee509242c9c00ce2dddc22aed2dd4b2ba0dcd2a5e163b8b8a2506ef0aa4496c2fcc60f62701dd6bd3b5e0de9f2fe7cef14462b4a224be9279e4f6716e859391e7522a489cd3d8d11f511eacdbae28dc4b10df2732eba7b3a06099f14f2949310a6b0cac8ee80170934bb39e472ed228dc5dcd3dced89420681de24d3ec1e59b39da63d6443342a93ba339ba86d6809e602a71a82f0b4ea0e17c34e92a0646dc0f86ed72e8066259629c95355cc0ee93b9866c790218b74cc8c2c34a31a5175dbab4dc039bd423b8fd71f94430b2513115dd351ab544dd652fe18414f6467b65afdfbd0d010da1a0348c07a9e07b9df34aa27d0f9417df53757d38bd844004859d49ba3e7f3c946c9cfe2139520b7b4b5b758eb1dba2bf5154d521d15e41fb54b388108215142be5575cc081cdb40079724cb051cef4ae36e88b499dc211a874e901ec8daed14c82db8ea8e63de9c63790080561f780391db5b47d551a0b660967974c153582002a487208d1849e3d4c56301db3784d76a37b9d9cdada557434fe9732535f7c72bc4bcf0f87b6afd7b6720ace8c2204273942d6f164b140460df84013c2b616702a3fb1d7292cfd5291165061557f35b3426c74326a5ca6f6d1a6bbeaa14a8bf3245ece7efbd1ce45e0f51022884f35d145a8e1dcfe93bd392a0503f92ad419e83588b4a49d8ea9242118785dfcd793b12594067acde745512838bfa532055e909a2adcdf13d90f294ba531a75bb6fa6cb557f2868dcc767c39ffc27892634b99accaf82661b5275af4e3d0593b17c1a3e66b87aed66dabad29340b85dc9dc4ff84fc7250883e7db8c1632b0625ae9808eb4960956ba083bd7c6a294095206229df3ffa5529ac6e215213af48df36705dbc19c9128076989cd442ff6edcc400fefb520b92ef6c669eb80eb40889b546cd0f874a36052667e3438014cf4d67c840bf6983749d391f0794da7a9733c9fc1e7f9ad6905d69ab20575ecc2ef6fab89790cedd0d12140844aa3a25cdedbd6a111bc176a5642aafa7d4ad4d2c7857205205070ab2d0b6881d7aaedfda99823cb1e82f1a16f3eba4ecc1faf1c0e9e1e00c0fa72e59de9a914ac50363ca5f7f7b1a0e305b4e1cb724e0affaace4acb6ac64417889bd0e41c7203e001346e1d78694f7cba7eb33b43d528b76b8daf294da1605d166f86925d92147a44f5eb1c8eec4531875767882a61a758c60eee1092f553181354413ac94904963bee0f8523707e5c726f472bab9c61c8603135914bd6fa07e07e3729f5185b64de2cfe58ea142fcc6153351a32517161e44afc1e764b9268081447f1da2de6f380e93e98392bbdca5c202003604fd3fa1f77d657794b97dcb3d0c54331d6d2e27a037709b152a0c4dc3ca132010aeafa6cd9d7242acd96144dd12e9f64842c87ed6adf9d6ff9fd3e4516d13d282c1756c3248756ea99e38436e581b730147573a30281dbee509f479962ae31c4b92edf3d5f66b9118d927efc488ef0c7af27384f94508bbc098bdc9557d84ad5c1406a4fe531fd2f1d2155585c853fce1570843ce3fccb90d39f9dcb1d402cc93e7b06c97b91c539b52c2a9bc29df3f17add8a6a15985bf98ef8a79db1f7248e8eb97906144693e2dd0781beab24974807f854cf33f7defeab17a928c526e874a63ee4d86fa91c96162d92bacf78680a9b87440fe48591c8bfa6ba73d027cce65e3126192c3a64285fd91ee21efadaebc477298d0384a5a44bd3b1a9ff82a5d29757a4195c54fc677072c27219670a159798604f5e50d2a6d78e5b5569874562cd2f4ed6900160311c3a68b19e01bddd459a86d38ee836bd174278cd4452e489ca2f0c950da0804616bb08a6d62af5e51ce4b10f0cbb0b09ffdc71ac017aef59f4a5cddf2a9e5a01ea9d00d2425788c0d5bfce675c7292b29424018e8c6bd18ae29c0e3698a0e07c6b1e30e5b3e55c3cf955b1a0e4d6edb39e9e450f484b7ae54f971c56e17b1984bc1f9c4f55b22b0d114ebe3bc8a1f3b23449c8ff0c51f59d1f0640bfe71ceb80ace758c0d5ae8eb999bfec81f510fceb7ed1bf1d0fe6534a89aec2a9db3e473b6f0e1f1273992ec28bd7f5edfe01b4b9a589626617673df909b166cbdfc31f5a965e10064e6f00748ca3f38314166a8ae5c0f0953e262d3fba8db6bba360c49e22fbfbeafda0f69c6ef3af41414e981069f51e4bff81a54458560c7765445a0a14be8d41ff4c672fc096a0e01548c93b787112641daebda8ca7ee0658edad8d9b5b7fec1a5cedfda146e29f1daf42df622bdb71d7c1972f516f259d0b1a389cb6923b7c8716452b606cede09bc34fac330faf48605d76d8d617d5d71fdaa431c9bbe371447103d038216f2f6670b5389d0401431eb3c54910cdfcca1a8603d2beb0d582868559c0bada4d97f1f1c868d240c7c70ce7808bca3f0febeca910a6c7dc493ff7e1d11f576a59c3feff0e0ee2bf59b4db349c9431ee5188ec1fcf30236363700941e4a2f286fd56289692914a1e901fd820ca9aa2e94643e67d3d1d933531e37ddad4cda59a7c1c7540fe5f599efdfd86a7362535cd941cbbaff42f099744c3792e18c89a4fd76294f3c8111ddea7d1809b2106ffb3440166c55d4dfedf09861985093d5a3f27d3a9b1ae2ed35251a421c056540e1c82e17984b02677e61e230c0f5d1774a4e2b8db2117ba1366fb599e7a29e0621a4daeeb4a311486780587a1deca9a7f3b292bc0f90ec463711603c180d163f735f3dbf3109b8f043d4e76e540449154c3dfb0b4d14f1245f13e185b77e6df26134d3a9b2fc5f1dba46cf7e0eadd2211fa0efb5582f35bec2144ca9e91a623232ad3eec0b1d4471ce01cfeef09b6d5c758735a7169af1f17c9c72442631d46b51ff05c2ee379af239ba9932522e4f4a311ce819e473413b81255bb26abcd25191b6f1a2c21a87d80334aa78efd98b15c728dcb8a7eff9d63943ecc7b63630760b717a624a79cb15747558fb9133198bad71163be6462b073dc69621ab91e4b2aebb3ab69d504b9f3519a81361dd4856fbc20e56e5924cb834e7b4d82f3a522f72902250a2175a7d07cb12f36a069e9ac73bfbf1e566b5eef5a491dfe78aea081c78323d3e7cb4c61146df331d1978f0e14e1c3e8823d0cde9637ac84cc898fdd1dac5b0963582786f4d2847d554fb86cc393ed7651a98195ef409399ce19c096a31d5ecde2c0c8bde4d69c99a6543a1b92da8ff09bce27fa7c56719d3dd62dd27a56dad4db1ef7e4d7fe1ecc8112c364fa430212c8a48a7b1d0d3737a2dff8bdd4f8185449fcd5a3d518f1dcc5ec71d655a42210c0b57ed8c0a8c05dd36444027698c00ce554d6d440433f80d7da97f1ab03a4e8504a81233b5aeb2bfafdd3fa0498acd5463e9eb217e756d16011e43653b8eda5db2279304c0daec033459f9fff3de317ebe103abe22af5ad5e43a4199e9831fab81396d694f784097816dc8f7b45a162b1907367d65943916c3ccc4d4fcc2bc4bf8b5ca490b96852c5e2fa6b98a285905dc9e794727d751d77760a0a85d65f81a9959cfb05c22dc74e16bc341d9406b1221f7f4feb568eab4edb73f4eb800ce247445f9b018a3cb3ea0e995145525795aad57eaf80c335ae070ae4c1a0667317c741179d82d1bf70921cc8ffe228485f3a9193e9b6331ea5b999497f8601d213e098dde2ccb1f941ca5dc6267d12770a6b9e796e9bdaa78e1ffa386e7fdb99b0af257188fd8e756f4387c5ca282079335bca5fc77287988c095f16ef016e7d6b8895595174a86a6e01e745c5afc31c5b5542719e4ac984d7f16d03dc33192e80a9b5a25d0a3a86038d198121b197b777ef2d74a5dd678587a336380820be004e67dbbb75326f7ee5fad311d631effd13c3e067f06e328bb71db9145a8ae00988b3c863e0b04169f3b08369f59001130f334b90da0ebd70d7bd0edae4898a3beeb113ef73349c4bbefc48f25ad8b55370e1d90ec45476849c2f0280a97f671409b80e3e714b13dc1139a7b0cfe2cb1b5427c5290a7d8788f3765566951f471a5bd03f08ac7c268a997127a66e16d6e0846e612f4bd1b1ef9a98d7c1820f12e082788c01de6415747d10f6dfeee7d1723814d3d77d6d7f700c33b7980e23efc0305900aa535e64423a4ac768f84d6e21b08fdb44f0a741ac64e102a6b1f3d6d2a4478cfd78c9f7304495af6daa0c30245d52a34f7be85deb9a581d739a4aa613de6edff1dbcdb885f296ec89c5e8c21a81de9cdd47a28d8a1f405eacbaca61bfe64c6c5dca21b35adf21b9a81be1ebc25ebdabb5d968171aa701b4a75a1bbdb812c548bd381360935bc349930708fd47fae835a35dab2e85b97de65cf1247d2d20c97575ee46c226cea58e36ae87ad95c56aa84889d098eb269904c2da73043246fd633ab96774a1001696b9cdfa4f035424dec9ef4d68197b1d7233b3148fabf858e93272e51fc63d58b2d1342f4bf6700bdf2e7c1cc858600d009f30d4c8c5d73a6b7a7fafb31234b12c203e08bd4d265fe009b494878695dae67d478b56cd401466a8531da902b00d78c48270cd59aefc919d5156c05b01a25787c2b2636dd5ac3c756eb2141202a8589ab3c534f869909a1883a109fb4d2d5cef646170b37838a14a3b50a3263a8646352c9d7303987df9aacaec78e765950e5618f5a9bae05bd2eae95d1e318456e2b784a9494d5989c4c4bc7c85e1696e899dc5682d4b4184b523cd4bd23650e4a572a6cae9d7b20629f26c965e019c7316e10a7cbc9b017b07146d7c913fbb5f2b5a25a9be4e03e99336e084fadbc7da5a7c62e3fd8a12bae7758312bc4f8b8fdf4f53b688ff0f645ba2ef07542fc4a8334d33d58c230626711dbcc412ea39c9325e4f01bf0f2bd38c7b65525f7d442159cbce73af4359d6d6cd935416f607dde96dee98d718d57289349eb62cf0456e44ec5fb02b8fcba625c5b7a6e584de68ea9c4e64bd090834d3d6bb216dd2dec2f85fed6c93b62bd9d199d2e5acd2b7ea94c5ab726fb4acfaa850d7e81468dadd2ae31fb16e24f67c200fce04feafdf39cfe3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
