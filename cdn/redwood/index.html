<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22077b3bd729ab16a53c8a3ebe63c80d573f54e2009d7ce159a90cc33bb0aefe2315ae018a1b7d2e6b9f36fd1346ae63bc3467b5afed22d52bd237338c53809f788d1466cd385ede3439411a9506b56edcdcc20a303c9639183bf942d585f82f6bb28befe9725fcc8f27905e0a716e050a44b6ff88d18420757b28626c5d8c07686eb6e8d62ad6c35f712575967652ef671ad4ea5d046ab684575f0ae05c112f4ec271d75c56f3d8c535dc3c6161abe7c763b0ee80650a53a7c42b814ab8f224c8636193726c7d982acc4a204c11666f8cc7cfa7546bdf742c248415586021fa53851334110ae773a578646ba1899be700562d3cddb213f578c8b74e89a3d8f3a573a43acff783d374383d12d3a8cf18be70f12e42a15f3d04d56bb8858cede531d911200e2b06b120bca2468a59ec08a79763ae297becda4a8986522327393e968c4429bc19d1bd25a706d14631b4d302e077f22b231904ee443bd6f02f7b2d0c5764f9c2e5768c53427e02f56d1841ea7825b63da298d471576a0eba105d381d60a4f87694e78486c4fabe6ef39afe879107063faa71dc0ff9b2b3dbd8658ef517973e5e0cda4d6e81df2d9bf79482f21e74154a28e1167bc39fa6de6b3b7d76b16f6a4a3ea525f5e4e8baff8581b5460b10bbab7a6d2dd6b051278474852e9d3a2385dd801605f4a25eaddf4ac9a094d0ebb10501fd1899d153b02196ef7441b63aa0202297e678bc0e945278cbf407320bd19994cd84dc235151d25458caf9d65afc62401e267a34ee8a8e74c81a44979f8c7408a4ed1635d558b017aa23ca6fc36010c1660c38ff8a43177b4d9d3db17742d86a7268cded8e4f5d42fa11b84d228f92218a6828434ae8a6c5b8ee448dc582964edb97492d1c5bceaa20aec51313bacb89326243d348f221be49ac23cf1dd860e19796c6f1bfdb57f3f136508dfc265048554405830bf63d1c68b8d029917032409f6769b1f65f14a7f1d4c3a286b9d49148cfeb49a421859f718f6b3fd620f36c38feac77ef3c61a6d9db4bc228ee7d74ede09718d73337112e93f03acc80546b4cf1284f4578f48137476665fd3ce0b5583eda4674abe8241bee69c9eeeedaf2e95ed6a51864cbb24d09429b6edbba38e99119279d0177b028333f619b3bfae24bb55dfaf840ff655d9b8d613bcc147ff2a78f17dd6d95a09c3957393b164bae571305787062f1f882dfd3a6da7c497cb323036a430af4ad62816a9c54843ff7094d41c3d34677d30e92c2091187c7147dec18265d4eba2d1ba9f19e8bb8947aab2ff632bf3ba9e84aa5641b402b6cab9772d45df4a48d7f4a01f96a1023c31accf70b549575db76aef74017a180bf53bd488e3859db82e04435113898f1ea588cfdde251ba9b8bbd35a698bbdab57f92c9c4b67619f4932a2095a78868df56d004e004c232ed6502ac3a75b02e877f05f861c5236a4302c3c8b915142631c5058910bc042eb051800ae96d37fe443c9567da029801a88ff29b75763e3a4bd1a1e5de8933964185b82c5cb4845f837b213436b3bdebcbd2ec8d62ed0fbeb67db62ccb1ee268fda55d2319a91f8222e39e2cf547b0fc0b024914a107b49b7d93577bc3579be442f63af00205534c74e7ebbe99f320552c0903d65e3ff26ba0c8b7efcccf1fe369fdbc0fd905ac4709571b1fcb78d7a7425527345f7d252dbe10d701adfd99f9c94b6fcdc5f5466c6de2179252e89c91f8721d97fff3f234ee7d814381524f071ec48856a3ab2c7c15e0756a9f4db21cb03198a9c4b301649e2c39d200d24098dda1538abb932ad5b81e0f19a7b0b06b4bf468798f31b8f5f7f6adc7da2ea8aa867d792255c805f9258dab9c08f2be0ebd9311feb744a08b0d65df479dfa25ad916bcc57fc736c67094e1f7bc1fc6dad08996a12beef83b10ff74dd91b4c038348243cbfed2e7211f7f9c4d982475242cd02970a814f78ec77f472a4ee3adfd38e552ec28d32df6ce3ec944b3e392cee5bee9ea78c4859f33718e4a7016fb054356e388878e4fea1428fc4dcde0e0cbf040041ed41895085f9871e9dd704419f34ff351f4f06d68be80f470b7f064981f84386a294da1f06c4241c94b0810c597661452757ce3738318109e4c79d79e8128d0c44f3a04b56583908a2e861d9801f6bdd908929aff3276cd2e5e6fec1249c1f44ec7bcc8c94cd1a3a245466c0728fee857b0de3054893e9a915341ab88f232f4dde353170fe28015bcaf337fe7d0975d1110f00dfbfc6409f68f171f030c9de7992bc42efa2858b062145b9c669008e01e5e985b647600518783fff959ebe0b53d2f613011c68965ca3b2126b916a4b699cca15e2d692f3c54fb360030533267bce20250deec06dc86683fd89f94905b64a21f3b2a0782f1fcfa7426a92d90e131f482764cc613cda9a7c217ecd0a44eef1858c3bf437356f87cfc1e284194fb67b4ac721d7f14c97311df427ccd39be54120b71d2363d15af25a9601311c5d2d862875ee06fdf55cb400cf243c8050181a8e0a07970e7e3a97a6fc54114710156bbf495a7b310b3b27da02ac22f8387dfc01a02b56d6884667fb0738fa4a00e16eca37b84e4f99c6b22ed1e412557ddb596598f8543cb66b3c1859ac7894400f32641eb85bc2a83791c6c866bb507f9dcfda84c8791c5338f0f905ccbe13b658d6f5fe29dd96dcfb0e380a043a330be27f8a7139fc7d4fbe0397d2f8a537b2491e3a916f3c9ab86ba10926f65175e236bc9987579a08d84474a62d86a67c61ccb79af547e4a9da0e2c5e030f54c87b1ef0905f0405908aadd5587f5671c68abdc29ee900a2059a9e4acf4721bb4c2a3b78867f288d26c252dfa84f1028d55ae1a764ac6c7196a4b4afa3cb43819881e5babf305ad4ee67d02bb12a6e1ab8f7a14927db9a3d8aaed6c8a375e2cd23cf92262064d4d14fc568b32fc6abf4cc3a86e3fc0b1bd70710656defda0598319d9eb65e45a7901cfbc8c547d4b75ef73cf24f1ab9001d6e202e966c19485eea8179cc5aefe4bad7446bfa58570f6e34f5951d13448358e4a778fd031e5a7824bb95446333010517233366b953bc1a11aaa41f7216430b32c984067c77826dd43ba33655cee1cebf37b5582014e7e504b7f7b76ea8d547272905111d24a9bcdbc17e57d1a4f803188a73db04a097e663557a6cc6d8b3399b919b65344a588dd0530235fce2772bb9c5131f8b89b69d0b31f9f406ed8c2f0e11829b9d5840dd19e6b7e17a5f0b681f7930cc6635a4d278eef8e0ad1f5e46ff8fc503edc0f4bba66e9df0933b575b56133ff36fa64ec5d194da0e8098e35b526f0c9b858bccf8b15df1914bf67ec23774ad45a0c77cd38ecf962e190650b03c0e2fd6b7b07450e0b4b151b2b399dd69459447840e5a566709d9dc03f6fa4f1844774e5ff73a6dadbd97034eb4b3c8e40ed8dfa1f0d27a6a4010adc17361b80c048deac83bdb52dfdc57696a46f512c58a46c25120d6a4094056db59bf9f1679208e0cd6e2bdf1252b27b038295c765e7f9d972618e5c2ed451f033becd11e241a237117ce1e7b0b6d01c64216a45660ad178dc2fed17f092871c073efd2a6fc22dc46312c1e15877c71a869ab0c0e86479a8d69237b0125061c5bd29bd181fbcd4d90ff54a4c2d017e1993b795438bf33158389e83f7635f0dc339e5d34296277928c54f4e6d31bf859ddb33e0e83f4344e4b4eb5fa7b3f7bdbbd0e9786fb50a97257d3b23c4de8e21b22ffc6a763e2880ee61586739e0f1cc649419f437c7ad4374024476b340d1b203ad394fc669081b7e8313c20ce1611dbcdeb571b2fde23436cfe5f6ffae1092352b64f1c0dc1759c5a93acd54d985318bf86c68bb4ee2a5a3de31b52433e21170ba593eeb53963920c10cf1fff9f5bbef7e9baa826c09fb157244cdb8a396c40e6455c00e469e3b89335c19f71a291655dd93977e0cb821ae5032c4d921b4692f49630d0f51702d364cd51bd868daee3a4a91cea76ec3307c00dbc959920b011eba4183f606741d7556126595f0fb5404e42c5a0d528b9806b9d2be6d016499c72986b84a2b021c0d1b1fc5d5708fb9cd52b7282532e03ffe9a5fbbfbb5fbab2a43777de8976c441bf7a10258c3e3a69fba73c8ace4c98c85aeef70214abfe9b0fec4d44e9628360cefd883121e1e60282a26ca1b88f441e32c02d45f11088aa15f54e79ee0ce771c627657d0db4670bdb605c11f5dd71ce3aae0a5102187b1404f61a602c87270495b239952e8103d73b2f9be981e8bd060d589cd7ca41e1e12deca7aadbbbfaaf455bfaf61ac8c6846cb4a6a28f08257fec014b705a3de46b0a43f0d0d3d7763490215ad8898f974784838d7fbf4c6130fe094966909e2f6d64ec2e72a1d9bb0ef3aee6e66887b7f5f50c131562532e7f4bcc08e43338297c6d164a427934f69b696ad93be991d7ff4f342f25dac485f73755d5947c41131eb924f7c717b34a92abcac285bff879ab1e6de896764b42559794a6523a0d88ba3ef43d38a769290562dc6d48408e87d10ef2c69d2cec9fae058b6f9082fc698ec4324af1c3ebacee6e014b992e93a918cc1ed8c4ccbc30816e1da768a42f679dce9b1f9ef967674fb5d8f4563623cceac83681a53449c9c8d7ed46e0b34a13807d63909b6c706a11b1ce0e4150f8146bcc90492a47091a81c195b568bf22457c5a2b4f90d664a87dd1967e182abc0a1898325e24e72cf91b625d8bd2251aa1336534ec79835ab87e85ab2188a876c32a93a00ebaffe1a1077cd0dea7133bb0e4776a457fee98865dc14d93826c438d2c793d0665be658e230ef90560c0c98e5526e46df43b8c524b50f40ac46bec7da843856d2da2c27d8546ea451ad77b596506984a0f06328d58455808c18d41d68b1922e661dc952d15f0d41e8cc3d0c6368a96e63a4c988df80e058af1c8166dc4eddb9bb0c02e1eaa8c0648455f35812b4d0c192f6d6f0b0ae7613fa995b495a29b81b963ac0831cebe54c6e10adc00c1875110608b1093e5971f75a7ff8ca47c33c9ed2cf18243441536fd3b996acb218fca781ca0ff09be7a925fb31e7b6657984ae1bc2841f4694f6f296585f024d052028708e5b9b07ed56bf454e520ca424a53e4947fcc4b7678eb4c4079bd0765657a0b800603d7d7926c8e1662ac4e4153c21dcd23a4fcce55d85fb8ed3dd61ebe2d75015a8f512b152945a5de6375a9919de294e362ba939f58c89382cd22d80bcf2cb0fbac75a2a2d8b5972a542936c64f4e05505b345ff5bb74614170770421965ec6a1acb70bc697a5e50151590d7df83937b10bd2ae9ca95097f1286a25540806fe919652f7b83ab4345a16d34faf0ce4a455a98d19f50704a6de92cd7b42095978b718f894d73bc74a4671b9837443e03f2004c9728d8035b3f3622c3c2144e11d58ad6bc50ce0b390d87d93e0db4f9d82f9cb7b7c2030ca43b61bbc8f82ed7514b54a5adb6233b4648e8e147a10d53bda4779425c76e93d0fd479bf2ee9185cfff49684dac5c128fc0ca2685893f23b79c7c8088959fc67242453cfba8c8437933add801363550bd72275c6fc20591d32ad10d0e680705364f1b9b5d3dbb15c3c7ade960c4ec811babfaa6f516c24aafa58a15415ceb774bdde88e90d64f759eea3090c1d21fc55fd09c749bb0af7637ef238afb45ec8c0b3d102c02ecded4be42c5f32df5d2fd74c4a1359edbc134ad6f32b9a9fc414308a16a73150d239857122b12b02ecd563414600965599949504bf219225069d8040d4379f80ffc70a77f53ea30bbc40534970d20af66f4e7b398edf643dc65df3706db8019392f6d2345b18c65b4aa65df1932950aaf730db49ea9f13874f249c4d986585fb5f4a7659934b4ae81531513fb2b21db0eb9a80c3e17584c717e18454a8f586b5688f65c567c4680a8d4094f65bf01704a01cee6f99644f72c80999f3995f7cdecf5368f6732b6c11acc18534bb5bcc9b188010d3c417487ddc17eb2f75aa7207308aa96c256e1f3237f01922324389a6d16b40b4d3045ae26b52d834079571744dfbcaa7f8f9ef4c28e2bc1e724204ee6f89e4eb0ab0849c610bf6b3efe485dbbdca494d21024f3eb3ae2e51737fae02cac140cee4890f482de6bcc107c6164a17449e6e41de70b35f59d3d153d39cd5fd8da719a00269e31df45e6b4f6f9f920249896b4d8c857c6a2e56158c1223d3eec9616f1a1bd304648d8dc7f8a57463f3d6a3c7b1025df24836d104723205e91caba66e6f92cf71a9553a90b11bae21f73faa83dd2748746c7b280921d369fcf6247277d71c75776925909f3563636b15f01cd6d19b6ff53d39d19e2771ee64ccb4fc290c7f48a569e9230c01457fde825a90117065757a8c62b6bc3fe6d2b10265265ba199a3e191ea6b573fd8c018b6d6d7d4d0e4f74e19d04d72dfeea52e0837c306550164e730405572ff8f741acad6bd9b987c2c2cede996912fc34c3f8879b1bf2181cb4d8fb8a9548b64f979dc771388c0909cbe6ff416add0f8036ec622eb5c19ae6bccbfb5739397a9495c0a8d4524bb74e7869bdb5819e45ea3c4d1e823b4d2c3f5ef45a48be06cedacac9e51b4e6518dd4cc1f3d8cecc0c1010f778eb380f8a9d67d4dfc5ea2c348c77f0e8cf64989e95fe0ed537f60ed385f151ce536262527374815984811b8e6d3120690c728e685bc2a2fcca2e29cda9c6efc479689da0ad252c2049ba668c920a25e33a6217b47b43af46438debed9d2308505146f255a7e840601d31a5fcd5c78534228a6a378675cf5a774fb620b95cb880b4110eadfa0a8151371e0bd7c8e225a0f5eee52bdce75004f8f478dd9e72f8551ad265af65db65fdea005e244c1b654a0d9e4a9466a5e99c7e5355e63a733d673b50a78c85584ae5d3289d172cea5e72198344e120832d8176360935af9c9f9e15fcf487f6cac7ed2d4ebedc45cdedc000a7fb567c5964a78874a64a6883f6de17a8bcf17ddcece34cf925e913b6f022377b2cf7af95d6cac2ca03d73bf0b69b71d9004795ca3e5dfecac8c9546835c93c6d1fd55f4859ab46a77bffda612f2fe0348eb3fd0bb6334382c1274937a12685a7583bc3034f532d712814c56e9dd4d01fb67e207676e8de77eca3435d71e3320bea0590d9b17ba88a1546825e8dd7fa769079e410d3f0e4ebb333615aff26b61406af0aa20bde1868deb9ac93eecbaa4ed5a9b79bf8b8fea593bb70683f1f98374c5dbed48b38a1283cddd323fb6dfacc7a5cf92397644b3b674da37772f9fedff1d3056d95f2ba6050f7571099baf5e6f223c7b01d0d9b35ed247a7cd200a42de175651424d5f44a320c14d5fd99f7860662d36353bd792354389a55b06588694616b1b6e5647be12b4c8ff2f5a8f35843c886d97a61d970ad9446b8b140e48bdb86057a5bb6cca323c88606ae8903cf392b7d296da43b4b9d83ac4918d5d79da2eba17b6d86a281f2480a49680b593baa9028ce82adf03bbbdd5e13b42e6de2cb302b9ed2e7f420f66fbe4683d7a4a02285c783fdcedb1b786d97759988b7b2b0c5d406be3ee15b326f9a402ebbea2fe2d8dd6ea20706c6ddae091759820d4f264ccf29a070dad71a97917986251b6050a341e18a7a52632cee9049b2f107a1f99b95691640168a94c5ab844dc82641f49ccfba08aee8b77ec7c5396b3d18e201fc919098ceeb415b1a38845f17c2a4d3fa317d2b51922ca4eaff691a387dacfac1c60dba56782f7203f85a367b7582a8b628f30097857bd46ca6b4c79575ae00245ec53b2220fc5098b51a9621f90d287f33fb1d3506c0d545f9777344eeb055a869c975616274ab022b635d2c58bebf83e24296a89a12592e9e92c3215bdffc0aab80d8f4764183f4ae2dc30539a1ee94106faadbc62ea238d111dd49ea1cee1b4472bd8fa97a8730f826f92a8c68021c234ab0318d1118fa036ace9929ad4018f7e5722c7811d003546dbdfc94d55829c72cf93de97546def904a61ba5f0a83a8c160cfa24429e18d640762d90d0ecadaf84b9a2a79fe2c09747289b19b06fbf1883b1ddbbc4d930b04fb79ffc030d43e0fabac9bfa8ae28c4677025e18ce6f495949cf42d8a909d8e499e470ff42dd80996e5a215b0d68d19f1676a90145279a102556fdd05abd82d4490d1413bebfa23210906dd0b768abb021f42a80fa54829c5ec318301002b4755fd3e0efb4217e01ce6f2315a2ecc169c4905b978408d57e9ee33f7384c7777a05d1f53e50ac6fa803de814a74614218992903caa9e04339bfd7de576bdec7229de8eb9ba3e256a9e32b60a0aea98fbd2d627881fef22bacc3f69b4e7a7845a692ccbaa13a5880097ba9bbf0f8ebfcb57c751a051fb2fee70f2624b1d49f2d9e8a59423c1ae0f688cbc87b0a2a3970608369012c57099859ab58489dbf32c2a5c9f41c048b827e9b25fb7bf9ee02f9c55e6aa0582813d18b580091d6ae0b242a1b6412011beb3de806f1b032e8c25b897c044e9cfc1321613ed3598bba35ffd1d60a6c3267fb5a8c0807c4d10220476e97b0c90e8fd66a88cf4fb3ddf944b2865833f414e8e18d27513075b10c39ed6733145e6ec21baaf464dfbba9d3209ab3af24b891ed03ffcc4f9438e4d7269a873eef82ce5642978c6f59d377a78cc44dbe2656200fbd4a99d0149e2b9901c7f0078edb52620fc272a07092378ff5605c06555db74a51bc1225cd104a739a9d6d27a39879f6ee9b5c0c70d7334fab245d1cbefed18215f0d83b57c6a30aa8a5c464b084ff8168d3bfb80a21b952c514e8e76114a66460c0faa2767b1390e2ff1d82d7683c013cf4371a3716bb7593cb22a76576c1c4b3ad6f41944dd9bc88887e802fab87d02db6d332b803e359cd45faf0a640a35dee18c35080c2d46542c478869ddfaa35f8f48651068531f2853ce28fb2f2cf7995043b4ea4c634ddbbf2b6597b573c88624069cf1401d7f402f2a5826b373bdf7987fad598c2005fe8bb094f6a6dfe9d3380d0d675b830fbf79dcf5bb2cb5c6dfcaa4172a49243ac5cee95b94e0e4d82f368c1e34db9a9c4feb176694b0a8d7e47dcba50ebcab0338ef65b564a9a1541bc6a2fd9bc8f144176bdd17e8c16bc17e1ada09dc6246262b58ae89db692193c6b282316c8bed558acdf71b267dd8cd0101825ede06ae42ab32290dff8ab680a4f2c320a30bc838731421c7276a5059f72744eaa08f5396a30dcb20dc2211b46b4735e343956aa3421fb2daf1ddfe5f5ab31e82c495825c48643d5e1102d8e7809e45f13885c457226cc23679c5bf94d32b85334f9bc06e887cb14f2de37706deffdb1048d0db7bd241026b8e9248d37f60d08caef209cfeb780dba313cc068d077f841f759a41e28b82e14b57293a60c3ae64f512ab47a0919702ea3997ddafea0f935b0e4406a1b76eae7f8cead8c298c1de44cd773884b2e72f2d493add6949882a4eaffec0b628a1f1ad3bcb101ce8374625409454d8e5da12d7e8cbf8bd0adeeee4d3c6971412a49654c981247576fd30558f4425a865871cc9362b12ccd2d1b36fbb594b9fde327df691580775e22ddcca92015d7a779806c25edd9418078dcc2fe1dae09b4e428cd78d2cec1140c21f82478ecc389a9ff6fdf6f015811ad4d06e25334232f707303f704b1b288105aea2a5590a814f9e82dff80fb399120a25c0c55c94881c30645cd168fe54248253e0b6d7fcfa920eddb300cab2378225430308de0435f01eb9060f1266ecc031e302e17c1ea3e5b09ade44b4b4de728e5f3bdd736f1240933c8cf790be20b2a4c39847cf8fe14a8ab5ad57d5575b25e28e47ec7267ed701bf38b2f7f1551fc9baeb98b776deaac436d5256552747288af8f282ee2ad621a9cd27a220591b1c177e11ae8cc870ac8b2f7636540eae9acd311932269d19acca4820304ca320dc1cd494caab77a4d1b52c16b1fca40df95dad28eda8bdb64ca0d3a380ae7616d60ae7b31eaff9cd8f0a2c47ef4b0864db7e6250a3c4cbdd9c1c3561fe4ec0708c8d095567cbb49fa91315e9236b0c3bb45b10a8130bc3a476fd195d33ed15367d8872c1edef31e482246e7274cb5ae00dba94338e9c646e464381318937616dff60377333a9a5a0b43bbd40fa472130db7e8c21ec36fe3291abf3d1ebf12c8adc363c0b23854468bb9bd82d80b0bdc48bc4f8472d099db31b50450c067478e73472644494c85e5bf460abad12c98fcd657f9221079e20461e06cdc99f6d3fb60f2b1ed0682e0bb3bc1715a19d5719a194e3d03729f4d64307264fa142f1d5172da663b4c58e2764461685bc899f71ce38f0a042ac0bc218764e914655381591b77956a51fffdc0f7550f508cebc1b31b350db57ee3c5b1b552522670b6c19f6750d3349c3d07b592cba843ca0df4daea4760f5877de94ce58ec9c39353e3f5e030476dcc428155e52d459ae880d0d22bbe000d0a78dd2a82d1a698b3c844ce21159488a2acce83c94dbda08edfbc42fa396d19a4568ab1016db6abb3abf4c0d4dfd62b31e319e66197563c554c19a59447ddf07eeee4088d143c2e8ad30cad270bf6434f92565d6413fda3eaf8d9888e7f5975592324fb4f3d751e815070caebfb1834f9722397e492faa4fb3d05c7134dcc38a7df8edcb2796d4b09364084e966b72a5059e78fb2d50003c363f4b2de2d1f92595f48945f30980ee1c3da936dac67057492e51ae4c821cfb86f091aedb35e982fccf1b4d329ed68cbc96e525e0c7469a68f49ac5c7ab45d9bdb34aeaf0cd939264b0e5fc7633b0d26433ad2c4601fa680f35cb2781b2977fad48548b425c70c8f9751103177e1da0cf681d3f26b32ebebc01db2a33fb2023fbc09e80a903c5f604c8b1c75fd24c456b38639a2ac762b9d4a7fff5585e0b1d6dd186df6fa3e1b2349161f52886c0be2135c9348a225499dbad4c5a62b91a69e29a0ab9224c05eef658a921e61e692db4a3a849c889cd462c6d061b9ac9845e8c3d9e7827f78859cabeb1ad5f939b3239370a486ce67cfd9ef763bf8512466b4a6dd9293004e3aa81ce1b8b61d6fe841643753d12b9f5892c6a244656b6ba2577e6814478b67c971de0519e8bf912a05a888f544f4a1655ef0f355693e2712d5e184d6ca43471c81b5eb7a3b70e76362f3c09c5767329b1ae3dab134538c8e9c30e0de0fb16bc397927c9778a81842caf7e9ee7a728e2bfc6633e55f29b160035c3f766ed5ec66b6704d4bb7d87a383e0ce5e38067c1bafa2b9fb7f963bb994d9e4e6c0fd1ecf3c830e593a2dfb982e18122444c0dfd547bf594906b04c3aed5a14702bb92b83b6a01efc097279ea4774a9a973c30013cc69489945b3f449dbd08b10703bd74f3e4e4176b9e973c687f8b02ea08d60789c8748c4278c7392c09dd1a03f439a605837dcac3b52825ad84dfe36b0bf800874000a7f0b7f6b6c9ddbf533b3747926addc742cbf1d4a3b4083df6645103e8cb70fcc2ae0fe907086e5cb146ad30bab52a319553f9f854dae42e84f0d1771678171721b48213caa76ec1baca4c0c0eeae3a0c0e5eec54a4a37bb961c6b3806faefd36f264baa9413017592a4a418b4595c2f991850255253f5a43f8dfa299ad8ff45329173df6a201ff3f651fd24712f604b95fc9e8537e57f20dc746f2d46042da488e8401eb82828d4d70cf74cbececfb7b7e7ea3aad593d114fd169087a4565c4c3ccf7823a05d02b91b9057e8adaf00238532af82d6672b8b4932d8ba2d1a95c3d727be3276834faacdca41ece759762c5cd0394261377d92ff3e719f77455f5733b4e2ee4fe0fb07f23ee562389c6329684129b34ba142acbd710e444a98d7a7367dcd3b80079351c99c99dcd350000531978d5dc0eae83bfe7bdf2de437557bdeaeebcf811958951f85517cf6386afcee29cdc1eb660e4868dcec30dde381dbe595abe0c3a09fce6301c7547603ffe4272d891dae5a165a9948f309065512638daa4429a37fdaa89388cbf23e8ebea4b47e18fc6f82e581519b107efedd0428e066d8ea175cfb7b183bcc66f77ec814002543c9663a190f5f990c3ab37d87eb8bb1c0c162471e6d0e97881606672efa14b34b0cebf31d77100860d842f4efe8aa7780536d36161b2c443ca3821dc8751c10126399a6ea46962c6da20c76f6bd85b50b87c9bb287c4b12eacb9941fd0369c3f8b18e6b5f0723f9aab36927b73c0cb830202e6c4547856664f3d50e1ec6756310bbb5e4ac047a5bf3463dd6dedca8562ad1d07ed310f71bb55349bb001b80fdcec03b6470e1e4641fad6ab85f808e3150000c60cb529ed482e301534448323385303e036393e906c785b59e07d05fedf02d482f0adb63534e0a9fa70f54ef9c706ad507fc92310c3ca7a833442e4536e53d3058f19a7336eee21dc78bf3b9c860f4f8d5170e5c109c7a81940ec36673be9a611642b07ec1b9589f6a09d794aebeb07caf767f6f6a3d3439f8e0b7fbab8e9031a66c2f46dda8db06e08420deb3b114b3f274684b49c2918918689d2daa7076337f4f99754f80c67081ddcae89b9e7bb4cff657bd92d30bd6fb03b048d7a198b5d9885e11677b99c2df4f157864ff754baea2410683498bc96ce8cd01829a6bb392cc252ca90cd6fe04aa4273692d44ed756f36859fcaeeaaa3b21e5c482a00a3081e9d209f720707735a3e693b6029af4d2b009b6eb9567e9a554b9f03d03d23d1a3cbbad743ec0b1d6091c65ec057958011722828513604ce75730adfbdc903849d0ee70887c30a516a5e3d69e855255e4cd0d08b2645f9d66e522423e5e003bc38159478e51e9135a115249270ed22a43780477ce4f9feacdfd5d435b96020d0feceb9327eb82195cb607b17383cb6c8d9c1b066f1e01bac09f181223ae0809363f7335bc716eb3dcc0573c7e76b5830a9e423dc6511264236e9d85292e81e5f157f4a7203f2f79e98cfadab3d4fb39b4075f23b059ed75d097071b2cfc25fd583c12fb2907ee208366e166c41040dee30284b944beb06a97ec34fb4062769711fc1577a9483831e7312bf5c7951e2dcddcdfc2f972e124f9d11d178634ae85a4541074539c1516c59388503d10241fa3d2734f0a80ccd4bf02e2910bbe00e4fc89e08fbbaba14d772cf9f6c81d1d76c0b4f70d454e1137419a300e47df60ba7893b19aa42cc25540d7caab8a1a97cf3421b18c485049c318efb1b297d2c20659de5f41ed0572b77c208de74387f919943db1ee994937bddf30ef0d5adeda92ba1a483c79ced63730a5d7885ef645e57c3d6f38dcf539fb4057028ae84f68209422e17d5ed556e971b989122e49d02d5b968bcb39c58067e26decad7fe0c73aab89053843e490e926f0d7fbcf0f7100483022e1261e6804c24dc9266301a537ecbcad344596198a7519afa5c00c1d7201f89ece72ba2a734af369623fbac2079eabbd7135e2b854d4e119d4537c4a5748d0084bbf8f0e1d68ccbdb31545083de2c772326ef41b4ddd07080ecf52bc4d995d599a7fa82ccc711778f39d2d14999892501d4b234d009389bec1e799d4fbe0c4d8f28c4d105fdc9d17bcd196cd6019a4658ed3a63b1841931be0024c1aa12683a4235e62780be33cb0246ddb4421d1abe076eef3fc853a2897ffe0c8ad60427e4a663f856935807a9e9e69750b3cd6bad65e2fb8104cac5ae7eed92c3a66c9d82643797b2022c6f75f7e5e4510ee3d433fee2eb07b37e6a253160ab153bb27895765d36a30a26d836edf0e4cb86b92c7d6c4162368e1f77c58a12ef794223c383ce40101dd5ab39f06d83ba79910b8734b8e4028e84a85f5411160fad5e1020ac49f1b2313e50b200a04646149487f952a2e5024bb2e25218a2d25507628e2ba109dbdcd38cee5f0252451177c654fc036f365469fb1ef95f3159752793de91403d11b4628bdd7c52691f61f7dc9b9c95d6447b81e9211428a4c3e032325e4ae34b8a3fd564939fcb419277c06373cc846faa410fadd62d1f47757003db43f9743a9e9d0e006916b6d938263848f22c91a640e2575f4c4dae6a5bf5f7fa61eb8a50f4124340e75214954bdb2434f3a2336dcf704f1f2b2107ec131a0e4f6b59f6828ee1db3da71263cc6502e100272abb0ffd7a39abe8dbace4e02459797c2dd56c560682f8f1665f37467753fcdb6fa11ec5ef78b4d7d1bbc0c210a0cf4b88919d6a812f917565b4720bcf5345541a7c55812a6b8a60cd66917e7121d5b44ce432bfcff67d8c1b2448dfebb71d8ca433175f4d036e6d3397251e82f1a3dccdf72ca7c943206185ae38bf2216deae1fa674775dffe652b7b69f17d74ae561d81eb309d1a49fc95d4dd4b32757f434f01d422dd86a75336325cc4e82123bc78496f643c2a671706e9af003bb23e1e12d72249a0f4c547f65163a9fe0f43e5be637afcc87469c2b1ea3c5ae1b706a684b4b15eebbfcce5e75f27411012eb6abeac3ecb5d604f8d97458071209fba206acc447b58e63f88ee8e5b47acad8e84cc9677f345c0799a4459a51b821da8684dff2fd1822cd5f8cd8f228a2ad3bd8532763f0d393752b93678ee759c4650860b35385e2539ffdebf47fab0e6cc075319c227abc8279c38bfc5881daddbb3c2584b8e5bc9d9f36b01f978071678717f23ca5ace3698f46334063941fa610cb3bb63c711afeeae953089bef6b748df123e77081410dab8aeb7658177d8799f214f25c962927d7296127603970e4d19af28db92d199cf24a24699ad551c25dae4ba3b38b1f5ef83ff28ff077ec02dc2a6105b8a0b6824c2394670d56b5375322bb5879ef8dbdc5e326eecc697cdfefbf97b764e66f1eaa7c8226de3301e52708770b2e7b0a935d825dea08be57dcd0b1f36e09f68d4c07c1d2d7691bc3f659c0b0f3b0ac8c3b09232d7bfeaff7900cf25db9db8efc2c997938eb78418c0c8b4b795a2c69d590fb2f879ea8fa00e2b2ecc0d3b772103d028fb77b2f0d9391b7ff9cf41f199125095a7ece3fd39bfeb55f327106958c013113d51f16667b16f39d42215054b2356ff812e5a12ae921302ec4e9be48d63a8d2a78647f14d91d5dc22dff4ebd811cc1d4806eb5677033455572f892d3bab955bbee60065e8f378aa27c06919ac2007402bc6f7486c6fb28b62300b1b092ba72a3258ea3bfbf3473da80b2a8be6b70d5d8b7a610c8a38411cb271c9a14f33aeb7ce8d9427d91dc5130687c4d60ca0c0c663d76e2dd6fc598d760c90ad7a4d07be06abf3fba732b136fb07d3e460660b946784d6d9734824c1eb5fbb2aab37aee19338778e279f8f941030cf0d7cfff9902513df4f9b53f13c51c8f14dd44210c23e73c4546549c0fae32d8d610413b1043dd414a45e98cb841a4026687c1092483f8b93a9a753027c90b9f65e3d14c86f9ca73ff112dc83f70db7c8a13506f72c58b27065c9a66dd058f9437ff3d73abbba95c121655d5122dce391a92d8d9af8b6de552fc7ada50802eeb45f063357f7f3bc54f15ab59389a2c4d205ff54ac65db8e1f267d5724fa1c1fdfe90f43b4caebf02ce66b077c939e6bfe147744655ec8b8ecca82c30649f47dbedb2cef4a2aac7f45b964c6964bd8d0da50bcc650f1cb9de70957b2cd4915bca26721d98c8e0c956317fc3e20c60de607e1f44145ef23a58e1a884641e99844cd0007985135dc2b72011860b3b90c6a1641a04ddb1a8d533d2ce4c6911e803ef19d6eba3e6b67f5fd796c216c1f746088058c1f1408a93e69548f72d6b0af442cb970a69ac1b2c2a0acfcdbc5de2f4e2d73ccf90887f92017d17804855bc3365a553f07542b34c20587e4ebf2efa294a9395dc9dc0204b9e6d963a776d30ab798ee277e7d7c63c4bb3423bf6d01914d232f40b65441eef08f2e40f39c1b116406f2c50d5a356ee7b08d7e6fdb9ca4bde0889170c65d569b4c4bacf2d8360cbe659ab4f2a0335a534f5ff9e77b8eee5e2901f7f00f7b47196aad8a116f9425391b7b108e054fc743f03fdbfaf86a56ff225db886b1d316288b08956720eae86673cfff056ae8d0007f3f6104c97fecb23f44834f391863ca473258e9b7333bd1d0d8706af5418a5348173c84016b6127c176f2e8f41121a95348eb8710f28d15857ac90358fdefa6739d38f62325b50279931cb9988f51a73db57892b4dc006d0adb6684b2d2e1b8594f770b6593f76e642501e05b77060cb19afbb93acee769f48f99bba53ff7637080d8268d07d8a15f2fa5348389607e418f5b41dbf337b976886aba8ed914963293ed94991864078a9b36965c3d184d255751588a59099d47159d48c968bb8b7acba9346491257183151d4cb94769fa5df4c4bb7827310fcdc63d0ae1e23ec7d5bd1c79e6cd68cda13c6610afe34fff97b435d9ac12dd4179536a7305d50ccfcfbf3eca7f7dfa4b5cbbd1be048fe25a89aa9b5f94a9b17bfbee41a3156c6611c6878f16b1ad3753d372b0f1f325971f565b03d04343c91bdf6bcad2da72ac4b75ebb294d5e193732d121f33b69acb029c9a438c61328222204ca2f5528c3d6127f3908fff1e81bb1ba6360387d2f285f1d0b1e20128afb128b56b6f3cc884a242aa481eb22f1186a1663a0e2205a33ef0e0973e26f2d9b0421ada42ddfc6b325e28f2d80d2f96c0353c76f24b6854a73b5c5cb5eec3aa9db05d026be4465992b329de79d4c8930b40933147e833c58e5225b50a1361a1e11dd177fa84445da7cf932ade238023f13cdc6e13afcc5d951e9df20b4b97b7b725f615833fbdbab32e14c973073a174534b7cb3b5f16676a049343a5ab8401b41f0004b7a657803be3e7496c4f96816e3b65db81c196225c490a12c3f3398e4806ac891ad77ac8b5c7de7650c16ee12bf5a548a351f2949b4a43737587c6e7285e78ecc53e2f07bd31781857f42935ab11875de9c81e8c209b614932a75419a9c833672f88697d30b6bf95e5882076272b707287000da4688c96f3c2bd916fe5b2aff7fdd88e5b73da9e5523832fc1491d2cc1ad5a597449a8be794731af377d4ede4ce4c67a33b604b70604aa0c8d8193d77f8adc2b0a48e48e6f4abcbdd590155f6c3f273a28b21b997cb9997f79066c26bb0ecf8b50e4b0ec31fe0469757778b23181dba7c464400a585b86e30161e739eb0f36794d81d4077cd87dd6f7c3144d5b4be0a30421c23422aeffd0a4482045d6d06a7ef8f1e2b1f8e4377a686fc76e5127966007b6c1eb5ce5ba9617f37ef301046331591df77a4ec9f65ec9ebc57c3871a673d678083e24661007f7bacbe91c7d96cafa7901ba3ac1f897385808d255606fa83c3006f766c0dfcc45be4e29664bff7b139088cc096085654a00eb9160fda6f9ef26d7f9483229c4ebf16f302f90bda72144e0a8162f89a6d0c1bbc3b8a39190fcf8abebdc67278c8dfe3b098971cc5dd668c17b83a93ec60830f2e7c467d446cb77d061be29f8da779dd7b01071dde569967f391d678ca2e8dc0e7499ea923f4947c75d1b653ff0769efb945ea91ba8a9550715bfe5215e85342ec13a8290ac81d728baf204cf83acef5668ee017fec047292f4573170d4cd933fc9ac2272bfca87f57951a7186b1d158d70bcf9f5fc752454decbe2917967d879b0f67b8ebe520be3b4af7842d9e7a01665518ea02d0c2a9f59f86879ba21fdbf22e82cd58d828a44989737be32843810a0d6a6febebc6958fc570927e7aa413b0b7f6a2730a005b0a417eea299d94a399ec3b0b0bfde80b2e5933ad1dcf948629ca109b4d2e3ce30143965e515293a17988d5e7d35772e4a13b5fd5f88486b34cc196bb6937db5c84f1a94ac8669082b1a0c31eaecb72b74d36e91ac53b943f6362a345243a0b2ed6ea1e0fa7fd8c49335318d2efbcd48248028a86c39a3f8fa8f1bbb8b667400397a790356a00d435ccd0df2e1cfeca1de3a2e7694f2f4a2f65bb55fc53c10e828ad6e91ad53ff89e644ed8e95b09e72cddee12f24f4ac2a7ee834e1b0724659d3232695dab1d4ffd56a6178d88819b418d8cf5a1b2d33c0aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
