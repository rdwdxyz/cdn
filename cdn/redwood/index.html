<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77a67d813d7d928c8edcbaee9eb750825f18f18456e177137a28c79e9e6133dc3edb31f77191feb982687f2a3b32252350476be525cad99186a781a22d6e8310b995c77eebb850143e6734ab3e81e55c00dde8afdd5b50d55165b36c2ca6a2ae7990181d1abff6e52a452fefb9b88e05476c8b75e91544a5d76e59b6efeec66b93494ab3849a3e8cd0395d892aa53b6a8d2107e3f1d0fb65af1e2b5192e12f2b9517125587037283f7d8cb0bdffaf27c314b74a869b5cc569a4fc993e2f1816ee9b9f83693512693559c8e600739d0423758e4633e794f634bf9adc0725a85fd446eeea42e6c16a33142d5414979edb60928c8d88831d880b36af1a1cb68f12bc78589d6ce09181f7a96c32172a6d9c60be5be7557ec57afcac09adf280b15093f2c2f4a1843ff12e18586390c57ac28a4eb396a385b034321394e190faec708943b325a6baf666f1f690c57de6c4463c6137fd0acd1434668802dd6035460095b4498d7b6f1174e31146adb6b5a2ba7e829ad7592605836be9e218a455490960c75dbfa4f99260f10c5f35904afdffc8b28ce6304dacd98cb611558abde5a4c4a61640effad825f5b5e7e5a6f0314890cbb717e602559360f1208434c3504907691b95899894d21c616cad3aa0c909b97666b0644e94fa364f59bb04b05d0947159fdf270e0524d5792e00c440afdb29dcfce77668a07c1a1dba674f8f0f73c0c1b28724a57a6108a105aa8b5429b1b2e3542da4d6cb58565c5e102eb72b72253c5899687ffb29e0adf0bfab108882c34665b0171f88bee4176043f6ba6811b0d3c4c920a585e0e58d3a08f8836fe2eec4ef8b02db8ad7c315d61eda504d907e201f04869226a093c49e3a2905a08fad361be24822d1db9cf0452c978fd6a439594feed4b8318abcfd0933fcebd8143c69ff1c1127047a80d35823241f70a0efa904f9b17158fe1e3ff26903bf7e36c32e30faa3b9571683ffe22fc1bcfbf449d2d2e3efaa9b60ee24880d1ff5808427696a8deec0ef493add11e28577e35c4f59f4e306264b7b7e3705e0d04239241d254e766fcd23e90e3d3e1053b6bc2bf8566d9e7aba3b693fbeff4fd594f362fa2b2a92a2fdc6bca1af0ce32b7c9ef022bf77758300148536bd4903a0e347eef22882199409313a62b2ec8eb6b4e1588b3693aa8fd0a7771b1e79820e0c6fb98002c85828e629b99db666a9a65dee8194b1348a4d385c945d9a556bf8be95517cd9d76e796d2fb14b362e4073a582e747855ea636fe861b78c7433abd6d731701916fd9ddc80119b0b3e81afe020134adacbd6ad4f552f74285809988482e1174a07bd98c12854f5338345418618271b667b24979c2a09a91344911c797fa68304d3c77ad2a3b821e065c91f2bc262d9387bbad339cf3420c42926aa8a1aacafeefcf73f0c95d5047c06f15bfd47ba3cd15ed6752527795773d167b547fd2acfa20167b97f35c0e99ff68b4873f0a8b6329103bb7f2c239d4dc2c0c10dea1bcc2c395d164ddd0cb1dd0f3f9a8f55e0fbf206788f191246cfbae6d55d11dc9ca690ac8abe4cb9c443c14a10eb0018e2eaf31305c12b66c7bfcafb3826bc536c4bebfa68ae5f8431182ab4578e0f2379bf23166a5ec1624ecc2c31f151fe1909fcba2467fd9bc623b2fcdf728cb3940f3294c29b180c9a9607ffc38c0ad4f3107f47e9c1df430196a8a5c347cc7df8e727f6f042e358b8bdb8d07a83c07636f10106900b286bbce7cd1a39cc18a772d6b1acf48ecca7afb7400b430fea7a4975208143a22a2fd05ae4c0a814755cc58120b1b170b720e7ad0a2e023ef7bf291fc85063ce75c5f7d39719c6f63dd962cf4bc787554680a383e206f5ca0778b413374248e2e6ca97a1e99192632fa2576a631e1a96dc9f05da7c28e7728021f9045d3c3d32f0e0189850cc4cbd4e93ecc700d9e957b5287d6483b91d8d03f18a887a0c1564e078d2c130f22e73f5d133363310e9420ee6778ac9e6054789ff99cffd5c1a1c09916fb272095c453b7c936343264dc6d1ee5dcb1946a66c9a74c4494a655a01001d027b504847c72ed4be6e0175d5b9b7ed9977dfba88f8300620e0f63b9f48f7fbc33bd654e8aeea06b0fbbbbdb3a273049f33d6de24f717447a837232e859f99e2ccc63f06758fc2b8638e8bfc9cb8c7202b8e5416b878ce874e34a9814b640c823b218008e0ab85123c5b097a1c427769c891cd87d21384840dc0a559f2efb139cd75c5971ec8bf2be7244fc8023514602482ba947a62374f1560300437df555d0049fb174a7fd098d0c2f984bc9a044e4ba3e28d568507f08df4c2a000d8504962d8532844af9a1813a1116764513bb583432947738b5d8da1ef277eead4b21c587ba74725eff78ed54b4d5d1e4b7b2e8d4c135480e5dae74fab91f788551e2e407f70fef27e20e4b1496b8a79b6f7cbec2a6b95ff345a12f5c019233d2f6f9b33c3c1332963c7a2482509a5f3a6525379eecaa6dabd29406557c05d89bfd308cecd781e193accb3e6ffda88f9a8bb23ef8f11c133a65531927d062173278c92ddc36d86e774b1288a7b7da979d1cae86be22de2d4efa3648254764401a64582e2ba610869fa74ef30a811142d7b090bdf7f2cd6d14814916ff817e84e22031f495b49d4fe709b465f54784bc968bc7cbf43a4fcb11ff2c80d4b00908658c7ce343ccc1b367f863290d4c88c0eaa4bbc93dc52260b98c8ac6e950f232b94cac8a1b4ef5a3fc5f31411756298068fcbf67c89d81cafb904e18939e08f5deb4fa914c7f9d2af91ba9dfff58d88212c8e35f69e60c3f471b6b884b93b53b2359d4b68e20e39ef6c84777f00d36138a91ddacc040019133fc694c39114ad04aeb6d09262bf2f4de66d417236f1891ddf3af8f573b152cfcc2ea1986cdba84c2cb98170ddfea482e093e85dd8249f5b4b9ea91e3253c350d6d3b80ccf3cb433af2b3854958bfe30ebe7033ed46bcc1dd10ae8e208f9074faa010e6a7d7a03782228fabf3bf2504cee2904a5224b0520930c5205d7c193ea0a99fb566ab84b47f7f349a4927fd02776664388e1c1edda65ba9fb9194c227a60bb9aaab60d927324d90559ce5b78ee94f11fc6fe6e175d2d87d96b9bcc0404745f0d1c1841e7c1bc2468a43df55d8f48c9979bb51878d526b8278cd23799443e102ea28a1705182482436da6902ddbf668c4063dfdc9b0424695a122219b047ad8e888f6bdc916712265471ddfcedd85a92a64d484a71501e0f39f76748f7013b37d560e616581edf6fd83c67e28636e6399ab53602a823a253c11c50aea22e2d78af2aa1a0e7ddaf92e5476510f8a934dc827718131548234ea0b286629492afa94836ae18fef0f3fb12bfe3812f2bc88a583edbdc7a63742dbbdc377b12cf8415ff5e492a07887ac1c20466494781d6eaf56e29b3a47bed0b3fe96a93cf1b65754d1f5150230ef297d87d969ecc5c14876db6d06cb126d5c7c2f768fde9e268da9ab1ed8a7d4093d7f614562b9c763228b81d1ff5746f99db622b2cc356c1cc19b68659f3d24ec050819ed7ea16def132ff80f2945c601b36581728dac200ecd85b2eeb6047288d0c2af94bca83797f44c9a2464b325d23d367c951863cabb95f71d768e6fcdf02a7d7007ea8d86d9605cc044d26ce7501a91c203e4c91c3ef7716136c3d92dd49a281710ad18aacb21a94f1e0383574d3ee043034c039c0d8983e482fa018ac9eca4d693a7bf5f3db03f16893902e7795c4b140bf044feff3cc70bc70237ecd3306d87c699ab0bcbb419f91da33a13327d0e53bac7a3fffd1341aa8b808c65c2ff19ecfacbf3c3909b831eeda4564cfb5c6b73012734311ccacac5c0edee9631ffe4a81174ba62babbd188f4674a998e2e31e2a26d8e42b43dd969a3a7bc89c522cea70e3eb3d98b7b4a10617c536cf87f269eabade333f012167dcc440ddfb8398341f47ac1006d86d0f9fd13322d347665a2f890f5ac2a09ded0375e9c58258c3b2ccac956bfb1d1a1c0fcf842493a8bb34fd34262cee85544c0c22983db8e8f826a2d7b8e90029c6498a25b92fd69b8e12d9c0e7c900ac257a70f0114937115de356c88e7fa488c818bad3690d566584683f376971c786e5e219ec9599e88e919763af0e8937630fd1bdbfa249b3652b7d0df08469f671c22c052927012b6ced323c5db417b5529fdc67422a1cfdfb116ab5fe32455d49f2f093dfe5e4f3b8a48066a8f90c4dc868109ecd16786fd06cbab2e09c3f97a08e0c8b5062b61630873fbd2185cde32459ca44876635c218097058e9ad2bf813e95fa721c27c049d521c9d6d634f2ec7f1edf5dfb7f2877d5255d64deacf1a5f926637ed7dfb903c6815ca25a3c88e4f3e833758b428280fd07ad82b1ca0cc21f8ce4310a41146aa9bce030088346780fb3ec0eb23fa2956df265bc75142e215c6ed22732649640d05fed33aa3f662ab2fccfe301cf41069627710364adf8bf37312cc4c45714d8433df0131c924791ab3a6c2dca42015f0ae6b4f3058c0271d5b26e4bec14393e9591b07df53486c52687faf32a9c2ee1365273cfd090b0dafd2902b2af02904172374e2964db9dc0bbb069c6b9ad58f974dad9ec254739aeb097b57410bc2843931afa3e122a8f91724895719efc64d6131ef7217447672fa85488b9c6999c0e2ceb0783099b5db190fda9f68e55d984ffd2d0c4ad5d9f0612c59ec768b4588dd1f6268040fb65ccef1f5e30ec3305367a73682bcf27bd0ab703e7c57cb5e90047a5ee17f79576b1a1ddcfb76ad456497d834a5682a3e94283a4793b425b83a7ad8b6c36c7810acde0edaccdd2985bc973c347ec11754848a4bccabac0c09df4f3c37511cb1b600f4d1bd7b9daf929b8c0c38707eab8c58302cc51faf5867000dd90265a9886f5c37d27c6ac9cef62226c32d6ba07295d8db59aa811334b08ae2a46e6a38aa1f0477bb7972d5988eb3342416d8a7c76ba6c1671275831cd062e07b2dd737605bf607056f7ee423b794e5d121775d2b68f34827569a607b3fba19f2eae15e9ca3172bef694cf22b7a4a01c19aea4758a8b08b3a264a2208339c1d4ef78bbcb09c24a1d26b95bffec2de5ffae6751c18f01e4b0095034029829220d37f932b4283aec7712b216b9df36195d2b38398c546789905776b5d10435aac8cfe8e13e33b63aef471379c8cd3d42130bb6013b07b909c51611d9f23f19219a529ddab1473d1c3718ae4923cfd8dd8c5b064d63620d6182b98462804bce7886ce514ae0cad4d763217fc940864e04b916f042b927dfaa464b2e96a65b71d6ef02f7a45323820635debd70439bc43d687b9f885cc9fc25121d70bba64f0e0dd6fb37c7a1a43aa8abbf3743f4860b6c08a6101e730b9008058d8d2e36a2a7434e44cb8239d972c4e629e1a0b32a64558124a72b65ebe0340802e70f816a6e8d74cebd0776fdb914e86df7c7ea3000010920faf9fac18c86aa2836db9237f6ff05a0a8092ae2e46138987188fb1514f87a4cfe7200271a3723eb6126cf660fc43ee930d204ca58dec7f038df8e469a49b5c899387aa6adf058582ddca8eac4863d4cbbc178e8443775268ebfee51d5963963bcb077bbc17693c1a4ec7826cfa15800c53f29716758a9c78cf4b387186d5f92c39e3b0d452c96e7f9ca71802f87e7c600401f880387da91e7c1ff68932c57415e84df4ed7cf7f25882f8b1a945ccb76537e7ed5de6909e43493ebcff9eb4f46b68555faa7726cacb8eacfa778b5cd5194bb61fd20d29a9629111cd0e738497eb27e86af338dcf5f1a51a5fd8a5c3eab9dd2844ca62e362ecf13af904199f96c288d2583e31762eaf7cc27bbffc4c8f1ed045c70952982ae9e671df472462763c7c5a1be4f9b388597ab1869c46fcc576f3c7311baa92caffd1cacc115f0a6a99913ed5402b37450843bc5a9041383782bb901c476fd9acb9d5ecfe6431433206360b518c390c276578b7fe1aa879ea0c48c1a9b86da72462fdf00109e1bf8f51de7b9b3aa63fd568c7d09fb786ecdd00bc00ed87f402fb2f208199dcef6bfd3d03cde0fcd9df5175e32032c691e16df41b165eb320d2bb7effae925060d571cc884c94a194034f28f21cb987cb251a2a49c96d3120c4b6028c267c4267c9f01f47686826b106bf5db145b11e56c538b093b2eadf4be66fabee3eaeeb5730709b7684853360cbdff1851ae1b672917464788ad2ffd01c5ae5d64bf79102a5442abfe3e0d002e54c86d7142bb33dab43b5f256eb70ec10d4c0ee69d14e0cffdeabbd093e749f27f04b7df6612d36ef0fcd4b6f3f29c937f388161de0b8c45772a0b1a97a70553d0554697d271f859a874542bec241db9f76a96f51c24c1795d3c354e764654552fbf0543ba2f830fd05c16bb30df81ab30222d8580a8cd5e1b49bd4423989d689ed947d1512da86ccf22103590d5775fe63a48795f3ad46dfa02527bb305281c1406a90bf82a2b95530b0d38ee51101bceac992145f052c405d87a182bb43a9aadb38017bbdf48921c3d01e814c956d54325fcc23087e05119326225fbe0367cb876c325b5e7985b2a98b5167d52474d489e28c4a77dcd8ca1fbb3dccf6d8a65bae56eda6d6c2bfdbf8d2676b6e822488f66ec85add9276c4853b6d13bd375be141759c278fc6333d312bedff85b50bbe7eabeac0ed710438ef9fada0d123175a595810bc6ef8b984f668062795f4f1fb720783eb78e354582496b8a99394695ce9e80370e116a051d1c8268cb3f3eff3d690f8c56763e2d65a7696fef63b80a9caacb9bd7894384362b6ab4ba94deeb8d4d01ba7002b78d58d8ef69d28ac75140a0af142d6f03bfc0061883c1b368e31f1ced0bf5f5f469b71f19b42c309304e1ea6f036405e7178830bc8a23de34b03cd83a2243fc59011554ba20cccdce6c6ef846d6b0eef5f8066fb5257e226113eeb5e7c70bb106a32d83a9085ec4b61ddd451732ed7cc333a24806a33f05558d8a7be255fcd5d89039ec0ab8de6752b26f85b7b340f450d079a162daaf392762b2311b18e482cae46a264b8ed1c5c01b1d90cb6e33b4f4ffb5e35803a77df4d9e2ec04185ad89e67b6f27ef2238feb91e2dbcafd1ed5559ff9b9f5fe880ce1a36c41006a9b614cc374d30d30dff5bf7007f0dcce9d95a624856904fe3923738cb4605fd3b08f6d7aa43cee77fd1ae08edec3849d9ea1fec645ed90e2ba8e368bd8c0bfad865a5d893edc7673a262a826a9c90d1561762981c2153ba6bc41f445cfd106fda0d4e20a5e41ea4f1472abd03af83918e856a99d6ea9570347234495280601006a674405cc1619498dc0b80facc450eb49d893985ee1ec9b3ef63177dcbcb505a993a20899a8d63d23fd3c54980e6bb80fd75b70dea0a230954d0f0d852c014ad5819b40997824a808f4e218f0cce94038acb85610d23325161eaca078e173c301fd3a18c9da110d5f4ec25c8edae6de4f6133746356609bd9bd49da551722ff063946ef08913670ef49966571f7a129ca81b69b9fd9fa19d6685008aa2cba1751fface47e56911bccd371fff35600566739f875cb5062cedcfc4ad047d90e8a7d9be1169104a3631bfddad9d5a90e772120caba9eee5fa7e88d2c44896f54af3cbd119f3afd2320b4b7a25c718d574fc4ea2010ba065239e8c623e5e086cab94c0d5fbed91243d59780c07019bfddaa1e86bf9361b0904a794e9327ca58cc197b10412f9bf8df5d75df7606d17c5fbca2793a16049b57f51551f606da0b342293d4517638689ba1a05f0b7c4c25ab499f1ea8a2a06e026ac11428f23383131e4e231c64e0bff9ce1bda20394908cf2bb2e3082cc2ae93c5d92670460950214f1fd44cbea6ec090553fab7198390bc455df060cd84f581324406c93753a7307c4f163ee67be026a459461a4fae5c014cca840b170f2bb37420f3a4f704769a6c38a42027936cdfa596008ca06ab711f5da49d49e515542bb1babb8681591e512fa2c3b6ab856971015213b58fb562575c72a68b29a2eba45d66111426addd22e43eb26ca1f0e3e006720d81a9a6da2a844ef2c093bb9a9a39b204fd7819b3f8602dbb9daa69e2ebe43acb7046cd589e9cc4f64c666411c9a01cc396cb62d6d08fb420fe0ee98141164fb0db6d51873d8577ba5c7b860ec8b2b7d85caeeb2b46e730c32e1b4450a7c6b313f8bba21c13918eb414ed97efb8c2115f1a728c0c21eb403a2f6deab1557dcaf71e67e52113c38404b5c4d6648f7ceb3726fda127b7ee7ce44012cf0cbd94a8da842f9dab7018d9c6264f49970bdab2ec27f3ffc370165fcdb34514cb32c7ca1725db006adc1e6dbf72d644c3c1106522022e511945b19b81d805a88da95904d1da3b6cd122f3bd88996ea730ab8a5c9bbb7e1b6023f0054cddf960e40aae8078721322dad5237710877d4daabff78aeadf670e797ef50f81623ded5def75cd761971c0387bed44fdf3f10595761eb411cb30712dfa520506c5eb969c1e43f1f7b3f35ee2240dda64ee18fbfd435af3f7e8212b7f61ab4293fe1c6077292279be00377778db2bda3f62c0457eab250b2578b21ff47695a7a8eb5be099cc5054b19471388a720f7f8cb849547c5cf10cb10bd791f83a5193aaecf5c7e02bf7ab5b4eb9b74b21b520c95ddfaa4f8a595103cdc74a4aeb8ed81594a09c16402eb0876522613e27147fcd42945b15fffbb9b2e92ac47a466edc43109d4338af5879bf8ffa976897402a96ae052b6d56618d8265bedc341bacdbf062a5fd266bf92d1c328b41323a2ac586b251376b4ae402faeb6842ee7865fca475a2e04d8b4680740af21d295962557689f4a2b4b51dcbe108133825fa3ccca611850a41251a64ac9f4aa7dbad711306a47e8924a969ed7fdba6c78caf1f7cf93dae46cdd386e8928d064e5d104268c2af8ec34526442802ae7160f8571575d1ab78426e1345bae3867571441860d6cbc05a8269c2c38775c4c60e92df153154055669966d240f3c072e988da605fa3915af81efa1f5764c4430c85cfb4ba2e6e939e965c0179a914cc7442b5c52391c96fb1ec10b89bb42a649fa19f781e8fad803d9076fd62f3fe816f8bdefdcc60460b48d31aae52f5291b6fbd6b549cf6253fbb4adabdef21cbe6f3b11f6e0f4fe891a47df875a638fdf75ea251d08f98abd7956f78f73e36caa0a2c64561b47e0e3fbf81dfb07a63c2dd546799235c4b826cfbef6a00fab6f450813d7280b6397ff62e71106fa354e7991db3708294b53ce8cd169405beb89eaee954d5e739346d7b5118458e8a9e6986e54a815a62245eb044ae62b865940d25e09a3ea66d4545474ae1aa1c3e120dbf9155c02be6627f52a616758646f3674663a2f44625c288e27900817ec169f551bf92d0bedd293572c51fc9ecbaba9d18c60b3b651a7028517f8910c6c8b72c83537fed4de73cb0557f0961ead883c12b800aae43f5df7c5ba9045b588af7aa50f7856316310d6590c86d13f7067b47cd83fb95ec74aee203f005e4957e79983dbc7457e85cfaf3c29b3078d1023b1dad5ab6340d569864e7668b9f63c2a7196f1f453e134ab81fbabf63e978546ea6b6335928826111a85943e1bebe22239f4e0f13eef814bdb5eeff61a03432815dd913477fb8ee8ac8fcfa242941fb52ccc7b128d257879cbbceebfc174ee3e4a98e2f50f787f88dcd40f72b24c0831cffbc547245a094eaea50857e31f25541f56bf77b60faeb24af1969d238aebc7a359bc39eafb5b5b4db2c8cef52eafaefea660db93a43314521dbf945bd746f87546b37e389b8bcbb24473a35cab77271123915b5cef8c8da6974038a7d8baea25d1c3a321cb3bc76db1feaaa6fe74dd5439e63c2601a24f9ee3d0cb6af0597db941130dfaad5818ed7280ec533b4336f03b06dc02c652c0de55bd6d2462f4250626b7f7087380299399e4999b9755083b5c4efa49903163ab35ec4af36387ec08e9570dfc6bf6755369a275655501235a8de50c224b4df64cb475c00085f9f4e9eda74669c4f03df31fb2ea5c00f28e332d88febddd4662bb04f0a2933e19dae0684774480bdca97ea919643d7595daf7b0d2bfa8b3c144a15c8b445302208d9bbeace3471a26ed27ed2dd035e0131f4424941a8645b201dde8a3247be37dfc0bcee6febe40e277c8dc79790baa27ec76a56bc41334b5dea14f400df3cca7f940f4b31839677d6a5f74320154a84519947167d3d67d70376a4fc177664a0218bc68e5463ba616305850884020a04243164560aed7caae068a81f28df76e32fd52d72000d6f0143acc566f02c8c76319ea4c971e3626fa9cf37e1334c9ef46984c33f4636ae4ac3abcb53cb3a12d58ff9a39ec4452f71bce9d096d6b255bd1705b9a877c942f104c6bda68688d15aeb0ca913a7191057ba5ec431c4d98897d5a075a9cadc9ca40d1f5a69695f1bbf5419e5ab1ceffe375d5a37827a6875baa1ce0043d9daeaa3eb3c01ff0c16896dcf1fbd5065badf6b12a8ae445d22e1b9df94a8276d9e76ddef7a539ea61d891ef81dc5a6cdc00994041f0f2d2bb64155c990e20faf7b573c5323927fafae712fa381d8ee00f9ac684b1ef1cae41ae6c1e71f5cddb313268a5bbf08cea4afa5290c680e50ff7b1d4fcf223cf5b01e1340c3a1e915f94e22f6d0c170c23eb882adebb43e31a20fbe313e951cd50ab479795c9b8166ad2686fed9a125691e9fdd3457be06afe954c509470525352ab3056037cb57a785bf99f7db97105ac3b4faf722bcff7c84108717fd7702231e0105f182db34ebba06214a73c62943bb24fe18d75b58f7588f41335392d5b6d69f839d55939e504994974830e5a70999790eb7f752737eef3d8899791bea48ee6965cfaa7b1ca74c6c4925722fb7942e160eae6c86e255b20ff30fc2bb186a720462064f4fb4d03a0e3b001137d3169e962699a174cd695a3203bce376a27a798f2d02e3b798d418edb0160f27c32c79355c491c55f4c4e7e14c49a8c254579ffdbb744d3e211d670e722029b2efa08d8b11d47986ac6b6287d374288559596c1afd5c509815af4823dc12164d0ea8079ebad75c203e7d86b7be943df34fa2c78838a7b82a8376cd45a643238dea0e2e7a1ba2d509f2c032f3088b68ad5b20856eac116d8d3ed5fe75c02dcd0b803c2981bc67b372d4af0e0fc108b0d212812ebe0457922fa93d71b1dc45717588a7461c0cd4fd830b9ebc1c4a92d5c1b24ae37df05344393cf6e87f0d92ee81ecd1f17799936f75d478cfc77f494e9c7a266b6547fee5cbbeec2200f3991ac03b54bce0d147e9c16fdae740b703140017d64b68e70330a50aef2868a55084b9fce08317b8d65e8d7541a3a963ee64b94640e9327d4562de3fee8631cbdee0a3e6b2c35e63a63994d351fee27e38198259a6af1beb32ed1673fb6a6dfc641b27ae80fcf511e5840c40737713ce6eee67dbfc4d86cf146277c168f0adc4e4d80913b567954b542ad6566dc8ea990d3fa2d4da0aa9fa89ba545553ab8b536c59265f5dc955224f6837fa44c4942e0951e8c606382ee49defd465c5f0f23232e05a266e33f795da17fd2407420de707239c0a7d419fad1b95e9deccd92695a237d342044d991e50ead952a22db4ad3dbe1184ba3c6345b47dd4c1f7c7d9af3fb191226d93f5177dc204ec3c6562c5dcadfaabfc4715f55f1987a49fa5bea871b5c7656d5a09f4ab0e30e2768f3953701cc581009722218a762c4abc71961130a5ba9ca6c2299fc5ab4039d8aa716bfc1f7bf7f5551f18855ba8bdbf39be97cab5496595d569ae8abcd8f06f835bb1d101a41d6b6d4438d4516bc30317e766db27266a321a5be6eedf1bd795898334f8c3df04894150c7e72125d09c6b25ca3b24899a0a77a0dde279a1992b2f6093a6c6bb328e8fcced1a120e821886def445afd546b977c9138a70f2b6489d8422cb06d9c454ee2334f72622b405707416ed3e55d848672bd6df75ee31158a3009ff0bd1a990482b4c904160f284ea72c3dd4b16e44e2116950bcdbd25a461f3846fa7591217b1da0ce5a30c2b693e73311e540550c5716047baf4fe5fc90f90f1f317836f2ff19ceb8107d175d161b4d19b5f37e1bcb3df12f0b16523f03a04877affda497dc42b22fa497c4d669b005d5c71fd12f1a80d896cb7280df22e9b752d90dc6afef42cb71ec3fbbf9aedf76fcb33978181ec1fbb7de9050e2a8f5c5649a70ae72b7687caecaabf04cfcae884cb8d52df7c114a6383f702af57944bcd51e2cebef90631cc0f8c49aeec2875077506e5aeb8ee8b69c046a4f50c98711a2758d062b529168aa052572c60a04f9c0403c6803b0cac2a7e0806ac8b030180fcea5c9858764ef5f27dd793571cc631ab0ee2412442fbdbfb12a95b4970b14291b63cafbd4ebec094aa9cb9a7ffd804a381b518c2f3dd00a08f1232a39e5abe889fe3493bf2ba130953d662ffd0d8c9946045b5c3ecc92c69e13150a30f07cb1bc02ce8e98050585ed7682beee30c9dcc26e0c6864a269c3c39e0f3371bf6b0a5656a7a7aaadfa923e732eb85d5a889ac5fcb59b9f9dfa6d56b40b01d8f746004a149ebc672138def10c56802439571e40cd5b3c935f473dfac29222c6c614d2f2226d8a9af20a6a9242b31f4318031aea9fb750fd8834a31c1d320539d9b57d0479ffa9ddb2d445edbb6a9f874d1eafc01520c05d2ccdf0b52079cc7f330c05bf1c50390dfc4de7da6e3a7d5978f502d94a1b8d6f12670ee4c3c03cfb5c49a382f209ac1c1acebbf84fcc4fd0691be2bdb514f483f34fd76ab2d3ed9a28fec0e06b87ad42911c94cdfa00e7a9801c4d4e79aeed2552217bcc5d78c7f829db181dd8667d4578dda83a85fbc4c1c623be12eb2673a158771f923fd990753f8f76f53535c5b20ccf810fd18308fe8204813d29e5d870f637f5489b4624df5e6e1e9dc78e67e58a6883f1a34fd538599d23df5e2c738f204a6d2f19c6c276cd21b4446b2f4e26ed816489c13db2997475c66ad0c685c18e07c8e49fbee0fdbf1056825f0110b6953bc250418eeee1bff067acde94450b4e09e45463bf33cc4c1c1df2c191ac350c7330bf929e471b4027953a305afecb61d8672721e62abdbae8cc5c194191c832ff31af45856cd9d90f51acc734264a33c316b8026142ed4296df471f6248da2d176de5b735c41d9be983fdba75a29a31d6b75b07ba99476f6a34d43632dfe4487d9ad827da682880ae46ef3366f31bdcf691c69ccd647385f7ae7fb5ff6e0bc7c79d672391f8150279b946b8bd3ca6064cbca7b02a5976c268d0789aa5e88fbf39eff05c8a05c8b2471c690c61f31069a0ce918e3b6f4fbfca4de5670c83e3ea678506503b84a24222b632998dbd9c1ee80bde18315453b7f6affcc49bde379e4cb3e2580be27835b937dfd615b93a76e0a83ebe8d0262d49f7003b45e576f091b6cc2460a315d39914960b9f52c774472b3e406adb338934cf28ac673575bd6acd2526cee8dcd6e1b24bada0947fc856e84cab54d62a59008fc35de9be36e45a94d286fe1b8e69f3cb36d8372eee56b7a5bc3beb23b7436af5b86400a4ee472916ea46d2ac09e2501e84be50a1c4bc35a1a7ddaab42be8d9a31db964c1c6e42420832771ac3801e2b3409a4778470dc518a420b07a579a106d3d1c6cb87bb7c4373b30627267f2267620dbe76f6c75b92e53c755cd5c14044a72933c561cc00b433e2bc772827ad01fca39dd7152b0a838067671d2316caf45e6f56e28806b6f370e5d27aceb38d2f6a6fabb4d49a3c538d88baff0ca78522ca6027a08e8e4a2b1d8638c39527b5437f3b48a8d40d9bc165ff04e2677d9bb9acd509180d8a365f82bd597a369f45f9235037c085c8d6754e4c1c3fda6eaba80bb16eec64c79004458423e48db36a5c6311d3730f9c6eadd76d5217d28bd0a511f8a55ec53a2d48fdcaf8f952c77bd855f394822b9afb5c888fb61c8f757a10af887f745cd7e08852368cf0fb1e9e7f2e3f7c2a1b1bd630c8edb416a99313615e558a2179d1b29365e91a81f7edd6a1806fa8f90631a7ba48fa42983661ec195b5bd49a2d6baa0eb209e9d61709867f37344251b357a205b8b32ba77756da0094f7c9a1dc04e7dbe0fa8305501f5ade533a777f1ce60c644ab27ae4fb908752f8fedf60da804d60c0689a8fa0f717b38b62e35e77048ee7b60da745852b3fcca90291d22f78adc0029346ea75197b5750238962871ede6c73536c09cc41ffc82606b1a21426e41a1a8d2546676f6b469353a342127275ede4b918d52cef6bf5e383b0f930d776b8e049713a6bfc2cad0518ad1580f3d57d525078bb263385f75508be96d01032a144ccda7014909a1b0f50211b172b6d6ebdbacebec609683276cb193d13f331a397f4f355a59a106ccad3c6df3c69db4be84fb0d855e91ce8a3a90e27ec775eca98a5b75b9467c44373905715691ccb55e7c4954146b9e723577998623dd2f0a30990938d723b895180253f33feceb89bca99ce6ca7e8b565cd474678c1c11bf0fabb89fd821b43e2c8b87f016e4184aa132abb11624e7d38686a2f7343d882dd1cc838e5535d3686091d4d78d0eeb3d54f87019ef0e3af72d86e49210936f9f3da3d4281af07214e066ca97f1606b0e82aa2e135e2b7667eb973d1f6cec4d5cbef588f2b8a6715317af90822b1ab61d0a40a177b2af21acbaf48920616237357aec69b91bd8682d9afdf330bcfc1a55094caca363b00585d15a17671dd0fd467731ccde1300e8d7b44f8c1898da2399300248c0b0e9e69b85f537cf169e23f2424ca010178ffa097eca51a00ea38dfd813b6b549da81bc1e2966e0ddf7df01d8326a27091810e86ba102987c42b1635153248fb2b22501109fcbfebad5ba73f8ba0585696355cceef39f15582544b0d730b9085c6455093e25e1cd833e50cf5cf3280443fa5afbd105f89e462a7fc8c8acb7ed6b0eda8293a7301359adc2c75ab0431c20605c9edbf03183029f54820936b9700bbe0c1dd81175ba33018342a7bc318f8bfde94f61caf3795c07a563ecc804208cc27776be51ed1efb97df0bf465263628c5c3e4a2b681ed66a8f4ca6af5b0db4b97e314bbb84e4a42c371478e5dedb2b2cd07a8736f2384b9f751f4e8d0eef917db4828ecb9543508d2076b209946742ec01f16c07d4e5666ecec6cd471732e9bbde86002278d2ef36ec8e7c0d49e75f2e7ffa2022fe62bab6cedd9f27821abc1c79e012967dd4e550779e95a9ed079f10d8cc896c9acdb7eaac91a186f4b1826b9a1e0e2cbd9185822d7d9468264cac289af068601570f31c659fcc6aa5443b1601d9ee912d4751e4be5916606498e5deb1325548f9142358a8edbda360408ce52bdca5b78a9f92c54fbeb03448b4b1bbe390b3e38d0fc35ac48e5f0877b7218bcc29ee98ba0c328c58b3c218b638ef09dc8d5bfd402eb37382c5c3ae29eb63895c598d9c4d6e90eb25ba37d7fd0f18e33532952ba94b54c258a9ad45b86f182d631a18a948c32f9a940fc442c7ad70bdad087248ff88097400223a5122591246101869cd93035421d6274cb9b956ba31a4062754ade00ce751739f0de84b656ea6878114c552e3ffed4e93646afbb02626762412c0510e301d680489f4c07defeeac5f14250afd3db63563aba5550e46d174b7aeb395786ce6ebb73f80d06759cf9deb1026cb4b5cf7c5812ec101fd63353e91a1b1de25fade642d4f45fe4e61efaafa8eb362d56abf473d8e22230e66e6348cebb6d19e75e6b5e8314d17195c349ff764b8a53ccd3c95f8ffca49205836b491e36115204e4759e50f59fe5a3e9aa535a6fa8e526bf24acf18b5d496595543fe895b7af0fcd86e9e0c490e68d4ab9e3304fe50e6e1f679deaaae8c6744d1b903c16ce1b3d66439e6f862ff8415f85cffb8246f390dd8dfab3cd28944fd71de032f48be4c33cdf21b92420cd3b12dd056ebf4334b2e0a8e16b2d9f193cc5852a38b886d57364bc84bcd5bc30588909687348fd930f74c42cb1d0dde2d69232a130ff87d98ecdd377ec6fec2ca2be76afc570865012a329b36f4237f8b62587fa26d5d108ad56bb714b41e9d7e441d4b71ed968c10dadb98a336aa4b7f7da3aa8d8f0c00d9ac43b9fc363664d8184df1533f41a91dba9716c0dd3d5ce1361682b4c97a2619372a32d42b62507771597faf9b9e25be51bab3b3dad5c0d7527e5b905cc2272344fea83435cf6b48a1a079119342c91eccc912558a3ab3758775b4993e5b32fdf3d7bccf2f28dec1cc0fb83df4c0874327123be2c9c442c6d02945b2c95143cf2868b05320ed147ccc3b60d2474dc0a49b85f80235e54fc3bb6845ff428a24b1446e4e098380aaca3dffc53bbdcce6a2a7585a1899faf172c129b27c9470ea15e8409213a7f91ffb4f123508e77ee46962222e03b515970cda7f698000e3198428586c3e6e7157d7fdb48046af267e856cdeee244e8f9448e189061dcba5136c6d153474389cf98d89bb4d671c1cc82c859b9855c4f160ebd0fc44aae023215f80c504944ed90917c190e7f115ead2130b19ae7de0e21e46f25fe140ac74b9abdd0413b970489efd26432350bb94bdc87e1b3bfd5798fc76260cc38a89672ff205afd531335ba41b642d3bad88aa0576e8ed6a52a3d182dd285a8245ba094dd962420421d5019ba6c6c986b9947118ee22695df8d3c0dc90451ae53c5bd5d94490eda5112c91a5b81714fa9524bc85e1afb65958ad5262ba35423fdc791e9b234e1acf8f56103a4d0362007f032d3d3082e5f3c1d9652917470f64ad840e712473956fb2e5c1a5457e203b2f84f6d1c7e19ce037a3375dd8ac8c88ce39653d535f47bb95933d25e3229b04046fd409499393aa9f838526c2b4efa3fa8d1c179f03d4aa48569e2bbd82180944debc030289375ffbf291615b63b25371a6f50b1c4813bf3b4c54f2dcce58dbb2bb597d607a799a0f32dca57fa541a4ee3f0f34a539ebfb482c0aa47f4f6f0a1afc19a0e32bfdf2e4b4479ee3b3079d78a5d1c9a366350483df006ea94306eab1d03379e9906150475e4a1c5e95a8f3e2aff72f28b943ea9b3a800871c3cf4d840eef96e07878fc0e76a722fc93fb4e54c22d7514dc304621ab2091b2e7420775285944fa60b1cb9a499620f5f9f7a74f72a9572a7933127051aa2156b93afd03da1e8c6390cb21f4ec2407aac745cbbe542971b365920186c38903cb194bd2a92fad4c847a5e3ccbb04ed1a5b4d899eae1ad3007d535bbe3577a61ce85bf7e0fa3af42fb06c9c256473410dfffc98b8fe857fa0e2dd7a1083f3b798dd21d5ff347745d0d1bb4354c6cdb19f007218545ad33acdde774829edd5b511395fa05dc1258493d11c65ba673e1b63e9fa59aa4d8ee96e554bf5b541fe3cb1bf4be3d9057fa9a92fa5993a3c9a7abba181f79ded3252803c180e15e6a3a59a89e5fed1ffc597d48390dae06c44c7330543e03f3dc0a8cf224c202f9f9909f8c0d15a5f67e9cf18603d423ee29f5fa17dd04909922f83483318e4729227938b5950af25edec04e47b5279a7145878ba0119adc6783dcd8c1c86a324cd019e0bee9ac765e18f3feab7076d86f7d0a16346f9dcb7a6d9a3a5e2fa1552150d37eadb0938efe395d63a1d3e8a484ce27125e91939e4ed6a668e8ff7a31cc1eb28b0947affbdd29a6ff5b21806aa7c3333ece33082584148edd8129a65327ad5a8ed444f7ad671aeb0b707b586f5ee7d95951674013b72e70ab0a926a457c0314f9453dd2f5d703d8b7c9d6a2dd2fe989fb32557409883d36cfe8bab69b1dc17157a646d6db935399ab9eb63b8bfdcdba24ac40175d664078468cf300983a19fd2d7299871658ecc9a027d9bc9570ebdfd0e466e51545ce58af494c9a674d3ed772d6a5b397b4e1ac248d04d9a598e6ec6582d287575b6328f775699c795dc2d703e8955d03a9b75aeb78652ed772ced20f5dfe3fc927a6c95","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
