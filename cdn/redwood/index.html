<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efb99aae59aac0f53cafa5f0736358052142274ae4ec0b0fee380f0231ee484c339f3bc9b87634bd4bee220eee5c0de717a5c5ed9083972bb854b0eac2e09fdf697172a6954365f3e6ab9bfe3bdd3f8ebeb1b34ea715f9990da2e9fbba7a7694730980879b657561b16e69f96e6522147c9856c32f57c8a58559862a647c91315164fa9f1d3b9ceb073168662c6520fc743951646b06059b53acba7278befa0856fcdb03159c41ee7cb599fb30d76da31335c309dd5a0e6a071ade1cd1c07af11dfd70e9adbaef5f32c59d9d92a1d2aa1c5c1737293e4cd84aa737d17bcc5a2d9aec1f483f4687582973d6fa8c50103546a4830f1ab8ff97a1819ef1dcc4dd865510f1384b7862c87884efeb38f041d5125ee80a89de4c9721f4b109be0ef513ca105d079bb5b548859c2cdb2ed44437b75ab2628f4384116c9dc4fa7b8565043a5920714d9a2adbf91329e71b2ea0dc12ad2bbfc569f6bad99027a26555cc198bfbc50c8a8ed45ed5b6bb76e84b137da8b7285b8f10b7ab27f2d48aa22d6ab8ce382aeab3237484cdefc4ed9ecf416cf94d095a3c06d7a207fe871bccb1290ee2bf36bd0aa2d92477a68eccb21b01e1c2eb3d9d8180c80195813d129feba773f382f98d0ef1b1c6430ba34533bf994c90539e67e91f3ff9c34f94b697bf875c88732e10095693f683415eedcd177e72d28ed0713e09adefb0b89fef58c80d4ae003f2fe81dc7a5f9cc1ae6700643c1c18a2d7d68d2f9c762336c2bf5dbf2ac5bdca6e8d9a62287230e039bcb4693fcf8b7ff2b43d9f6e61ad0eb17dceb9847aa8f9ff4dffd36d5a8769ba462ec157b98c0a722dcb781f8566626434a78b17f641a6bcde8798e805588001b9f3c0d9b3c9b72b7f390717e16286af98e828aa4514e53337778d616234d0ce2ac1cb86efd9c85e269f3107682da571b12470bd4cf5dd43df5a3c4da4f6f472d3dd6020b51a64c72909e9536513035743dade2c97ca2cd2c5e226b73fbdd1e08f755ebd5b616fe2288c2c3a5620fab9f888e83052cb1af4b57473b0f9b38c7872c3b850e1f6405a84c2cadd280dd4896016b68375929dec1e2c2085b5bf45f7e652aa6db0d087401042c39e659f2cbda1ded19975e164f26e7b760d32fe9ae652c9bbf1f60a5e27a1dba8f4981964d39a4488e92a87bdc9d59acca5a8ad203328d64ecec58c840d191d101069b2302689af8372b7c76363a36472ebe428bc6730872ec07efbef7d0eb4490a0a6a0beb94a8f05de8ac6a4f3c194542f010db6871a248783b8447bc7dd514864d98d9b84cdb797d3ee632626f6c87a94aa263b7775528cd8e1fb2b24c94300110735923afd71503169b91976eca19c63be21b59ad1e268645a56e4889f350290298336d3887a78f94267b59a852107c98f59b346afcf642b3bd05a9405746fae025a2d01889b32f61a977ac4afbb1d96b76efa910c4b4ca817ca4894c0db7b9ad99216f15db279e0b760fff3f0a8e43237a0b04805e455dc51acfbbf5128b32ed1ca07293fc8da85d69269a86b90d6c6f46c66ec356196068b2325b7bddc9d5b863d72daa549ceecd4e34773097ac97ff46b507fac4b98300f46867da8c46d81f9cf41a46dad5928ba109bd9426fba3c5cb272ef897bc5046c37fd3ea70415cd7030f104249458d0bb93ffdfb2d8f04ed7009197a6ff26acdd2f57360158d3ed3a32723163e228721c0db4f50070ffc550df7cb5929f70c3c03d5d286155f4adef6a84574ba79662dc60d94df05af1402d514931120a9854c37b45b29c911d417b7a3d10fafa44e5cbb3b68c89ddfcf037869445caad5c24893133e50448437adb9b0bc80e006ad474ba5aa48122a640dd0f528c38463964001e791f08772c960665a29236df93473916d8a14a0ded4e4f28a48ea0787e6d3cddd2e3b41768c6ebfb8edfa00d90b390955540d153bee47be7180febb63b61d8d6f650e9bd02e8b472793423cdf3dd81c3e114f7ca04ecd8f7bf7eb7f558092d0587bf87f7fbaaa311abe4db8ce776d30645068c59b2f0f125f407103616e1befe8ba6c4d4a8c0a031d2050ac966126cbbf01f99b55284e3efc3a86aa96ffe2580830de9c30421116ab7d23726138e3d933a0a598110183693e67ba2740db1c6d82e90829dafcb6cc890bde63fc531297878ef689acd9ff844cffa27369e4856865d3e3013c6df6781a8d8f5051a6c0dc15f6f75e1c6a08486dbd30948d7036f720b19ea3657235871829beb3ac8f9fbcd61f6830f1e981faa92db8f486c45f1a53858de0968c33427938b822455264a1f5bdbeb11d2f578f1a2459242ecfa9a6bc72776ea86a4f2328ec2954e3a73d907066eb7e8667f669496e4ba231f8ff7561621c69d13206bcb84a21490412294ffca04c8970035efff91d405fa8885806ce2d340aed6f0d87df31d7aef03a35d1d3b76ec6083ae881d39a264f6c2499cd7381624d888f6449209d031c6b3f0eeb12d8118dd0f7e991970967f53b0595b1762d75ee62b1e58049a182d494cb2cc589feb70de30f0717f46b1a51d66c885af1a21ab30393ff80bba08d1794aefd6269f664c1e09b75c1dc65c107a38c90e638784b880541f5bc900b24f1eac35be12dd02ccf37325920bd61c918c7b8c72f633c7252fd6ce8d8577cef1ecfd515db46213d58ec39f817e95c718185562f8ca75fbaa7af44eeb3c08c95b4e17a7c172be60fce98d5ca23b7e2fe769b18d5b8fc794480b5fa8ced039f6b64fbec995da051b801248443135249e16b5c72e9e55ec8bea58f3388296c82c8d03069f7648fb7d8b0ff88d4739df4023f5f97546594745e51f9b8f506f07dbc8ddbb6c6dc411eb4e1ab6e3fdd05dcfefc6543222c821d75ed1471385c16c8db0721bb2a75d403aa6215c9ef391b0052b7786314b430320f7e7c14b1652959fa8a1bffe517b8d766aa1d591e1f93fc027ca55f74652344efd18ac5d8c27debc630fddf0b8352ad2ec15b914dd7bc28c88d1ed04f7724b0bc8b1cf936bbc2f30e0fd3fefcc5f75d81511fba384adfe5c8dc67e5368c3873da732f42081cd593ffc1c04042a3de001fcb7da4f20bdd91e1618d42ddf00d1846ece1445c58819a591d7c91a8ad3034c3d31fbe602e6e3fcb03919c9efb986d9bb20b37bae2e9f07a7ea500a74b2066d29cf5434c7813f862f084090550900b35019d8a95f4fde678bc74b52d53f85839e9476288c861edba795dc33667054f2eab6e2d024d38e833c071cec19d43ce59b8f95ed47452010d7b416a9ac543dd9b735dbaf2baf2a8c4ca7f4914571a25684efb0b9e91d6fac5df399a177146b526a01246810f473c9ee1ae35c63070e1d1fe064a33561f0efbf5a67fd44bdc71ada4761058ea243973183096fe241207c2ecf1f32c6b86bb55802f659963e23be295a1a8ce9e2c17602a9254945d122c9416d065f7166d125a223fe5d2335463f209685ad9a1d1fb0112bcedf066351df90aae5d31dfc1047e36933dee5f49e527d7a6dcdbed7acb117ee4b28af419ca67b252b35a491dcb71c5047590792260413df321969dd25b683e9f35a3e7a6c922f88965cc2d2a4556b17b41f212268028cc740acfac94ad2bda85c616fbb3b082f1af33d21a014d1c29e9dc5a61bdba731554f498cb643e92e852bc2364fd76351a53ecafc0b2417effae39adc029be20ef61254a7a32bf47285c62935e9c73372d7ad9ad1456a74e13ae952c1346aa291258d157c2e25b7bfa1373b814edcb1706d27a7d5ef44cd92dde9312a8f70f90ced22347caaa678de52e42676903ea1b1cd7e499168973bd336b3155d0734f6484c8772ce63a11f6988e1b90bafd46236610b9641d0aa7abec7ebf067f293ca782f898035d95b9a25de546e9dd9ba54e8c1c6b93f2d0a75a85c2f4cd4d902da8ef235814b14a1a248aa136e9fc7792c2e5b5fbd83529ce2629367544440b11a0bc19c7b1dbd9e4adec97b563e168bd4699cadb8617db84cd056112c6f508f5395ec01e819f251ad654dc09457c58c21876f2d37d1e250c1049bfdac1eef7d0a658ad5efe7255d49d5402581eb7ec7d3590788439945b7e92184af064e468361cb32c719b50a0a8777a802107a991b8a11b800117d04748b6a00b77a1b6857718711e62358907277aa725e27a1ec08078ef65a720d6228765c3219729430e201da92d0b35a4ed13aea9114579c74d5bcc7fef8de99e3a4aa120de5779acb65ee74b8fbe77b2f2cb542d9d883c662b3e838e8eae478306fde2db155704341b0009d178101c0564629197017aae1b9311ba09d045956a90f9c5990de5ed55fc0c02067aedf2b0dac85bfad6ac45b76c9ae352749b09a3568e6046696b36a26f291853a9110859b49094cbdedf4c3716dd6ec3fcaade5ff2fddee75ef2bca6e7083bf8eedc23c94ef039091e5bb9b61d3afd586ccce3b19660da964c912e31342da7baf8259dad7884d12a44aab5f2de9ddea2c1dfe8d5a85e32fbecc15c0ada76464db91b094f8da18f14ce1ab06c8316f3a6d78e623d35cc48f79519dd60106d01481b6ea2420da547855dbb6e63495559040ce56155f60062ff70b82d88c1f60ad8b35c6b14799303d3be2959fe360bbc39bdd00f528b87c262f4b468837737a906bf60dae37b0de1a1d04f03ac55022b77db278815cc1bce568a483bdc226c52259d86436441134046a6d102792f33dbba7e42de1350a24d51b29c8c8e4a8b389072a92ac39c125949fbb36c4f5b7262c92332217a97f46233677e881ff44206f94bb1cf32544354bf2337a9d79c24f7a5d9fe84704f5cf371e632fe3cc79b9d972f987c536a6c513f936cfdd2960708ba706e8d29a0a3604f7391c42c6678108ddcaa84977f245950b4a3604574caa38d51b48a3442228d2bf92e888296246e5878da6b6c555a646215431608cd5109d108658cd9d49c0d3d6195ae467c85a39b0a65104b40904bf62a645d67a18b372c3d9da6837b8c0743b7c7de54553664796f5bf2273b6bcce4ac24c6808b94080ee2908175cb652df4a13a7000f1722643f580f87263d4e4aeb3dc3a52b58b0ef322537f1f0464ca6400419e103c7e1cba7d4b49fb501489db0dd47359869753dfb2df7defc044c64a5394517593771ed1b004dfc8cfdef5ee30fdc2f80a0332eacced33ba44f0717c2e8c2a545d4e21c4b5b7eb350adb82cd2d08fcda9408aa804ae2e8e75bffcd2a1560a318d878f306cccf8c1ff6d255c22936ccf7caed87f83dbe26dd8ebd316631084540051abc510eba715cd2f7608b30a553fd3363dfb9f2785b4b583bea810ba24c46588dd61850595397dad63d7f2156e360a437fa8c2e60782391e823fc5807eefb6ee8ce8fcb3fc4263c12083c4b4287bf4418e11302bca74d24c06d576d999fbe7a0664856cbedaa0a217855c111bc0469aff610102015865f4e18ac90798d97111f134bb13c5cd863281b0dbf3b2d57d3e9ea854ae8e445082f1c5c59295a9380192f5b15086c636823efa0314d493ad56a3b4cc8842e9f80c9aafc7a8963e2e90d906ec2a0ace03e2e40106469d95e3b94ef863a2cccb5f9d11e1420c8d3ea259d066ded309c9100404151d4050ddd0020cb7d76e57dd4a0928b441fab5ec256cd09a89ab65103d615e122ff469393a30c7c686ba7d89d1b2d2172d2a01d6fd89f995840309b5fb46b4bea5907e3a107176452f9b1adf87b2279dc00e32591e14b57fc751f50b0b4cd3baebee4ec9353bdad02dcacdc30e5fbb08c4fe1f2d194240ca97d3827f0286210b8f2a4bbe6903ef50ed7dc4951a88ac50ad2a4c021b9c17aad4470018741873bda8fce35b7692ffe8e6b16d1cb148ad41c1bfadf7e22f1499b878849f8bb127a7de046004486c976152394432bf5193eb7bee4245741f5b3eb66ee8c9a1d9a7237fac20bccd99f144f241008363f9ff437a67b4a7848cb54f874a904abd733833f97b850e54b218f826ef4d8275bc2a3d28438cc4bcea20092c90ffc28307a08964c28a78bdb16aa9c32d9b7dc36177207d657f88fe48c71d0af57147ddbe50d49f25b6348042192b00eb6dba8d8eccc93bc37e25fc5e8351a45158203f79c036cc62b9dc9fa2d54cb282287aab5ca479e4ad5531f1b87d13ac0cb1245e57f0b442f65b7ce660bc28f44f3c582dc8a1805557c995e8a0fa42434d49fc458e5569a7a30702da518a49fdb422d4cc67d12a5c82f8f91b48d50e406cacc308d99fa110a12c5fb349f21f4ae897d2823dc740c41beff0366b92effa7510c390df4a842aee5e4a0deeb70aeb0ab14769b122acd3c9763ca6da11496126b5738f7938d8b3e1efb168f9a45943dd9badcf011378a74726ee808c82ff54c4413843371fd0ff9341ca0790b0d5f10e270bf3904833f91c4fac72540530855937ce6a06ddcee10e4e1127894fe2b7808757a0d4faa269cd63630cb1c7c1452eb275dea4cb92e8b3838bff47dc938dae9a1fbfa018d1f44f9f952506e6f4b9aa1845442cd8373d9aaf91a77a3a1d36f485c6829d19ba109c777428dac9db890bf5a5856dcea586823a83e75c8fdbe1d605552f94be301d742f2c0ffa3997d8d0bf60be7f7ee4d4350120f9163093dd51ff068c6ced8b7a21be7d9a97455f7d474b225bb980e88e2bf0f5d9747b46c521aaeb2ab778ce5df7759ab9c43d8fff0882121f16a77f7962dfb4cdc7865886848cc8daf93a070e031c29841ce9b4f575b22e6a2448c6c945673b3f5d743f742dd8658ae310f0bbf05a3d6f9e81b17d7e2813ba7f50f420ac7b1801cea608ac1328bb26907295a2ce2bbd53d2545a66877a59a13501be5a1aa575c5fefde86f3f010f4283e9cb2baf2c4661b46d4c8ee3468d4b680502837764a5ef66a8be07a1589e16aa9ea3b8ed51f179fbf277e92f48e2b6086ed290cce591e5206293d84db31413442cf5a344a7dea8a860adecbb0c45321f3bd56f4d03a4d33e1ae1867da8846985f409d1403e39fa798ab67830e85dfa558a13ef401a0a9638acd4196108b1e9b5673c8131ce86408f445dcb9c3b1808294fdc251fe23502d2f70bfcaebb15e34676cbce7e1d88fb85fa47d363162bcb0f1caa9970d1e09028ef8959c21f1f94688ecba8d4133ce48b39d019a5666a2632c8476aceac6aa5eee9fb4ea8f2539d9898b0671ff3edb047c7d7d09851da6f6218206bbd707776d63e4d79bc8669d1373068e283ab4245e0799edf4bcfde497ff68b604ec0577fae8cfdf5a338747419caca556dc5966967e9264035704fbe730efe9c71f7aba4c052f62a4e568785125ebb6b5c07c899ab39a4c1dd0fd22cd6eaa6152cd2ac2a3969cda498675bf75438c1983fda5c60ed93357b5f24cf3a241e132bd0372bcbabc637f6d7028a8d4f86c150916c623e9004875056f9b581d8fd86a563d711dce766d013388341f0b320322e63ae1950e6c1b973a965293c50d1efc20fc25597822cd0571db388d1b201b4eb3bebd2337a24cede5f67a8da15dadd1c6d28a91ffb86e137de25b1c5a2c971006736e82e63d931a7b60116891f8d19b7399102fd3d7f7287638b61c25f004f5fdcc0711b5e753ec64af809b60eb55f36fc3150025992a0039f2ee5a7bc940071c7956f0b15b4f34542645a91d672048331f14b9569cd8c214da2d1681e3ffc3977c74c6e4055d813651ddac8c47b7a8915d69eab03cabc6c19a0e46dec90286cf85196b0744e6544a7fbbb657643d06aba90217aa8188762dcfb2f2ddd6c903ad59423db0fcda4cf7c08a7dd518ee624bf5e98a6718d89136de1cc91b8254494431a7300f29d80d075e22050aaafce9a353c0843e2241c5762f68a6cdb050853d519fb48b1674468f1199d7aa26ffd47b516418bdab0f86012af30ecd9c2143de1b07045deb474e5b2f9e4bef75e916abe511dd0856d0a5895c38f272ce6d741c1ac91acf29c38d8984a9383c3af3de9ff985c247273ef45046eb3fb8d037346343b2cc7a3a113c250c43a99b94b41f5c8a80105851e153b3807411457c4213239542a4cc21c74682247c9e8370972392fa1e72be5b0b92c1fc89d98e57b02d4b4a8554031bea8c803d004a6ec5744e13c91a7e567b203cb4538390a228c4f461358aad9d897c9f2324cbd64ff442708e668aa190587e7492600821e431f8e55fccde870b35292ce281f89fa0bf6138a1625ccd209570a208470ba3d3310ebfbd078e9272dc3f2476855cab761057df3436bd79b8183f3702faee6412a93a37f27c5267234350ffc15d124685a5e154971d1725cb0cd5c88fe63a61979b4a0e98ac1d6c01dec0cb2357a3c8c677e279dcdb6d91c4071cf8d5b981c2c5d7e335022396ef89082414bdffd4ec2355e8138fd35327d0d37b18f835588e1b41f2662a67705e28ccecd17c5ed43e68cdfe12aecd3138034fc3d7481b8e057528fd6c509a204bda6b699ff7d862cc6181f181454da883f0b38de49ff4347ac08134329d3c8c35d9e949c4d7dfa6acc6d444da6dd08ed77098bacb31a8450e8fd3ef7492d6d1ef3b11b782a7415b8c20c22af7d4f27a098ed5865a4d9f000e0bf04c42f08f9eac58e9883394dac71534d1bba7152f305cfca8c9e99876b95b5d218c0ec798917d5f1a6acb4979865ef5d3cff47470d3bc998a2613613115154d0cdc2a8361cc8b290884146abb4b9c86e2c0b1fd9a6810b6190dc7ebbb21621ff0a903cb5f8dd67b6f732c2e68ced3b2f3c13fe5d74739035928a0860a6987bde2a6e0bdd5dd21455d3467bf57f9b8f25277e731ecd55336e689cd3a5e9495df9f69bcb01d3646eb9bd68cdc563149fac98e523ba07539a0549ee8e203a9abdb1ae3adf01139d71039713941e702daa1d27525d297c06659c719a7792e1594feeedb34282f4e01dd9aa8e65005982bf813e08b3d4118e7b1b328e85c433f1043429abec138b6a131ba907777a266322880de128738606b34798b109d42283618458c12eca6c0d971f78b643316ab2c193dd20022ec3b8579da4df784595bb4156c1b3a1fffff81bc1a4cb329b113e870ee00fa0a0ee8693c90dd5e1f02d57874d1eb8247483cbd18bc08e0c17dc2e8b92e0fa754155a25beab3340369e53dc3037a35c40f77df81d37d76c575f2e684177cdfd98f40a5aab67fda8dc4e5d95f52a00f7481e2cb4efded847990f4da83801c1f205364f89d0c9134a3b037f76773093b10622ed570fcdef5b4d6d139daa9eaeb0b73719b0fcec478a05cb574c1f93ed0052b31754cb3d703a9206a644ea57b38608dabe61781625b4467f1389656b195c3584d94377fc5134709c4000d5092cbfdbbb0e95dd5be029015f351e37da6b8d709f47874a71d1b0a4dcc7abef3ddf27668b083f6ddeda8c220cf8947e5f08160ca28fd489cfb132bf0350159d6d9730f199b952e0e97045d6c9d69328918db460632d13d736b8c14a6e06d6081fe5b13338f9ca46bebba0d080436824c15ef595266b0653a627e94fa6e0635d424cf24f0e914d38bc3c7cc5450b8c49b60d81f6af209e9166193e9cfe48098639934d63b68ee888b67de9d3a179ed2b600ce43c54c6f20262ef5bb4369dd5930aa2558ef61f7d3a4eb66f81f699d06aa9ea86062e713029a2e885a7d5a56e1030beef587bce03943b9c2e8c353726836077a884096993439e8cc373aa5c60d8242fd5da93db8914d7abf72c840bb095c2f7db9e25f52046044b4ee9cb302f8433438848a89fe686bc438f8da0fc631433490d53db46e0c565dd91ac127dd1bbdb5f638047321268d15aaaa763d7ec969aabe020a5673ba1bbcb332393cd60e67ea5b2ab287c33ca07b83cd4624697b1cc482d08b7d81f49f83a86900ab83594fda99701b8d3daced037d6bc065900ad051d54e11f371dc7b50cd666aab4a88410758c9406d0d285350ee3e9bb13fb79588f192fbdb46a6ff24d8d547f75d7e7faa68eeb2a5df193927f5544d9c9457917c88f1d81eb1efe66227e90ae22fbd37e9dc2db940e4244b9bf64e6bb463d038bd3f8ece6d08a3928637670ce5f5cbc7744c86d410d3bd565d8f3e86142a2e308cb4b40a114c80b712997874237438aa542deee886b9b5889c9a318c7b20034140575706db818db65f31e5861c27b2f17a897866152ece62029505c108dd773f02206140c95cf7f2415ce95e2f1c53820e45990fde1a0901c780867f35c46865724425aaa3513003ffab547aaf2407aa70a559426e9b7fdb0ad12b0389697b69fc8d76edf38a6b6299ec9e39b30a2b380ae2b298c6ae28165b92a2871420c28d1b2a6c3278114e50caa6fa7b512a670b18131c487c7e80dd46f6e18a27bad4f0883d3c59ac0760f4c6a003996a1e469185c74b00ea04ceaedfbd7073cb8ae77db894be9b046e58bc3c275e5d0ccd01cf8cf57b6e45ab8358d0f5ee6e2c41f757f08a130d4e78eb416d43eeba6d52356ec9ed6d653009fd8763cc3b459d40017cd5356daef3d43459b8098d08d96575724910e4a33203d0baa8db19349d10f2cdb20cfe855c6fed184f0e741831c915d95a4e2b8f317ebfabd776deae91eecfb8535636411014881e4842db59dd4e86080b1352d23ee830cfa977ed44b8a7ccb44c1984b227fb8572bf8a1c3678287b6e9a4f4be3232eeafb65e0fd7c63886be10cd48e64880a36108adc9bbd322285db83fc74cc7968dc5e4ac822bdb8c0fbf9b74ab52b3b792233f6bdb7e6c7cc99478dedbccf77435787d0607ecf781041c1fa71868e93bbb14dc859c0d66b40bad1a86e64d33c809868c88fa9ac154b8e6ae22f77d9d8d8685a12976dce3c8822932dd002aad391b41a29d0285fbf15c9b8d995a169cada7b97dd3dfabf75feed20f0ab4a4a58d16e3d66972e092f50c42e131475cfdb0ab2dc6b122d9f230177e7d5cfb6a4b64bf5a37db2d78c65d739d1a1d908691373bfb9fce408a0f440133a19c99236135c8dce741cc45ceb9f13e27ed522164f35d14e9552fc9d668ceda6d3bfccaea5ec57459248f94f99f00f4d73d7a398baa901cf6399e4cd475d3c91303f7028e161e872c133a514c2e5ca81526d81c8b28dee121a457e7e7312c59fc14f6e6ec01d22947f2fa701ccc1d9514180108ab100e6f8402120ee95a91360b0a0eb90f7a5d6dad55cd0ef5b41ca74a144f5894f8ebde46a828266ace87ac4ccb6808c736fb59c91279837ba3c47e5b915177de2bb1fc943faa79447363f201807e39adbd23ce27883483fa2de39e7735fa4d7fdabfd8452e5e9f188fb7f17b8e38559676849409c1b9a953a511045ed780e0ef77102692cd5a2b4cf9ec6eb7cfb9fd54b38924ed4d23c5bc39195ef5963cd9a3be8a621e8a7546936dff18ed072ff3cdb647c5355f7eea59a23efd9c5eaa5434fa3231b794ff6d1355a097900529c6bbb2be1c9dffac3c0773eca70695e8caab71fb117e772da43b7b0e5d42889d265c92c3f742a855034af8cc8cfbf96a25f34924ad6bbd5af2040f8f840ba71a335d958f49829c78e6dcc6976290ca910e7d13f1e0e8efd566ad9db88736632596253e98067e06e6d62b967ce29c40e1aa8bffca39b51844b5fbb1def3cbdffc5bd0e8e2e272faf2b73c3128cca15f151b1130498aa4c2f875cac53a8058c481ccc1dd244318918ea83db99ff9f04811695b85b1ef5b5571a78394f65986311ff7bc6927d95c931427d8f08b246ffb8528e632b1356a87f0538fd43d7f5a8db2f6ed59158361183a403ed73b32e5cbb61891a7b3df9a66a74186d8e96120c31154e27cbf95d290b426dbdf9f560e515d9c8aa2c92c917528d31b57e54865e9246f858af66f23ea1cebb8897564b7879ce9c48d73f0af91fbbca22b71786b3f73566e0fee9e7f4e6dcc50ff4a32b8d74bd119cbc92318d74e4bbad6719aa23fb087bd697c270f9c26bbacb7f431fcd0954565f6b22fb927838a069172df8d11e8207e94e16d8f2d3488d67577b4ae380b3b59603cb5cc5a55e2a030600837358d509932f023f0815e54fcd4b83cb53d6915993c8714464296fa90487c8e8e6895010d204412ff089a30cfbb063aa39d56516afa31b85c09d5d46b32b7a20586f90c0e2e20d1e3ffb456218c60f9e81d02fb9be0193a39dcb51c145d64de23a3ca64241d3fe7ef19a52ca658a393808e31f856172bccf80184fe27c3ec407e811662ca15cc58f282c268ee410a5cf9c6da78c1e7d22d65db1eb66275ec7ac4f4a28caa7776a973a19a0bdcb8872219001e9fa6cb8c3edd131e2827704219e04f3c002b95850e3a5fe7b05511a7117a074e2cc7462dbd836b9f801bfc15acb0c7c399d8d7572440d4f59a0cdebd771ce68988cdbb82d54d4f132df79ba6179ca35784a525e404dcb22048ded9ee388355fa6a96af7d23b942ef00683ff4d214b630bbe8775fcfbcec4c2fc6ee26e8dad928da70ee77bab947131a469986f2a85465475dd7669fcdca1542e8c62f9fcc75edc08957e103f2eb68855c422b45ea7a7e0d5cd17dfb12a912baf0cf218398e2574f6e2182fdcb7c91280388c164e790ef9a687dfb76ac54a670f4ba090d938cf324a00bf769d8fcc1662ddf999d6daf01fcd459fd3ee5696a0e800c697943bb246a72983381f6b37ae50410250ef18f31d227d5cb4b25c8e5acf79d0f45cb7ff3dfe982849982510c434dc651d57ed8154c791b2d3f3bd346f2c9e3c5557a446236b13fd25871db20e7f6b22b590e71aad75963ee6ae4467902f04950346bd526dad7528d5c98574c90791c34d14c3e3b67cefe032685241cbf2d482c0e55f205a8c82d3306ac5517284449ed2a54742ba0e56344835f90c10d3d611aabfed7f466e007f64ab982b1229480270cdd29830ed8d5078b28fcbd6eb9b633d1323d118c906e13cf874333f8153cd6732fb5db6f6ba18dd9c0efecc941a0f25c8dfc7358fc9452eaddb39c2f939c0112a25681e27adcdb9aa6a9fd8c3f4934a63893e077545767463f7fd6f1752e239170c1014827d50a60af43d6fb455617de57a790d0fefab8ae87736e1931f50c8369179cbc900cfa58bc084e8cb73cbd591b771e7b216438af057d0d054e92555923873909f651496e235724f901f9e1bbfa5b0847e4b7074b2f0f189f64a56fed073694d3efc3c032d63df2277bf3a1dae5e659dbdc3aadc90c5b4dc7b4414645ba60b6d8874ed79fa7b946a150de27d0351e57144f1ebe82a2ac5026c398fe3965e345e08a434c1f91e52e17a936bf18be0b66d61d33068b51258a3d8e53e5a16eab2611054d4fd1ea60a957f5bf3f737f701caff9989ac5bbeb919dfa8a98bd665ea742f042be7fe2a1418180be22f5e6a8ebfcca98fd3fabd84263b0c735b0700d1e66c4fcf267772fef4e8d4343cee3f0a26e5545cb35fcf0a4fa99c73d7e83f208513b6c04d2e85adfa436373f9f5c7b740b208d190efe12fe58771d55f2e3a324b1213aa2e45d9c12e751642c09de17d65dbfd987ce2e91701de598b2e2ff98d6692f00e96d452746d4f81c6df8055ed461ce3ec9490ea37a49539666674d90edbed7fdc024c4ffd6b8ad020c90ee20c451c7f566076cfed7103c0e777334db62f87a403503c2ddf5c12a50868e0c66e98a44f4581c7e2259c01a5d40c87ea0618f0e093eb7181443fb194ac27ebd0b19c83b24bc5767cb8e5eb98b5bb2164e15027518ce41479206820c82eb419f591614a5f6544fcb5f717ab894214344bcfdcbb5c3c9acf0f40936fe47cdf48df6967083ef5ab7d4b88217427dfcadbe7bdf2f5aa91f34a634bfe6eccbd9e22a3deeb3e1baa855c5e0abf723dcf0bf49d22ad634b59fc3a5d0e4fd9e13dec41802a92ec335b54a3ed9749a3c5dd3d400ef18de3ec24e707e80109b1d9eed63e35add443d5d68835ee603c2f41dbe9be11244e014f76694ff605532b8a77ab744b908b721d2eb5e293d4946e7b1d60b3d095078d314b0019c0d974bfa1958d901617c5b226d45e684c1ca2459a9fe44a56088f0b5dcb392c5400743e54759b1318b5805414ff71c6b1306baae85803912b56f61b17e2255ea922233d83744efbe9c3b5a1cd42472acc874db6f1ccc9d910d1847c3d1e7d9fc28e3131ffae48a11caff008db8509b789fdf6438b05ac9eb902afdeafdacb8cf0f164e6cbcdbc5d368df8dda24b61df34dac38afa7c8182d208344a99dad6dbff7d5fd8095bd15b2497167b0517825e1906b138029646a2f00fa017077a0127170aa00a6995efad6e22ba16aed530d8473e5aa9108f34cdc4f2c781c670354fab5c76b65d89e5a196380ba5a8d67712cb0fcf589bec889053ce51b26fc8017c1c9d51243825f6ff35f2baf3ea39687fb9405bb181b1b940c8853c8f30c6cee9908ae551586ea7dd7e5ad9197b5494002f0ad69bd68ff56f4a4ada053c9e3567d89bb77f51d6306d5322a7e1cb9aade63f4f9a406a4f35bd7a69da9226f6a5ad0d03dd1a087f07ecf7b4c133f294c894b462da488ac47ec678477dde70d0ccffdf1749c7440546b292cfc554316ce9c5a023fbe8298f83e1910ad5a69e9a617ff61bbdd6c636177ba9ad633f950af71cff5a74a4c88ae5d53cbd7403f6acbab7aba8fc4821e51d575db9099215af92540fed37ebb180ace243fa27637e156d397869e6d71939f88d10c766bf9a3d0cc0b3bb85eb67ad9fd17edb740c03e368e3caf9c5c06108d6df6e9b4c4fc7cd765048bb79d56ced767f8bbfde8d68d1462b390ed02e498ac1afe35edede5b3f46fc618957daa5a4a2fd8ebb77612f1a800ae4434ff43ebcf3d9646e71ab59f39e064f29c5a9fb2343d08e365ffa7a84e553bca6df918372c76421d2f349551e2ebd74568f91eee0e633b84062c89e21b4f258032353bbb8227e7393e2938161cddedd7a233c8385038746fbce60fdc903438296f78f714f681e9aa1d1fbf221a4722e82d1cdf97eb2d35ab5bcd0905a273a9008f53c08fc479f8aa39ea30a7597cb2ecdbaa5deb7a56d70b10bfe7a83804e9be718b42cb2cd44fafd2b23bc678b7c401daa67484f7b07d71071fe84e8af82afcfcc7cfa9f31a445ec4d4fea9173e63da2a8c6be64732238a73456376af831d644ef78734bf0d32cfb5a0f894437a3258c41caf8484e728c9ed6ec3d7c2b842161b5c5168e175ee90e7e153a9801639dbe82dbfda6ce87feac42f89dc65eaf08f49c8308bb7a2ae58429912617490dfd222753b269e63d39bf102ee45407ae2f91a7b3b4c6c1fcdfcde24f58d414bfc3c4be43890b8defa2f3fef0e04fd8e27c774e3558b0d2f5556338a0c058ef1362064e3c9b1e40bb0b16e30cb0e5b6d045db989ffe7eac2356a0c8f9cab68a421ba020f07449d73e34561eec2a278f79871083402eaedded3def27cc327036baca7cff4359a2a20341a35ac5932dbcfa54c31fb39e7a2c64de9b14cc392559076388a3e8471f45a7d29bb861f0bed75a8066fe954c8f833c618b48cc7934fcb55f90fee0ebb625f5d02c2806f7459f6bdf8908da9412ace74404c330db6d77ca990413b1009020b4eac36d6f95beecbf63fa9a1f984edec730751a0fa41674c124770ffc33d5259714aefe16dd249588e07329d39c7e7bebaad80f68a12a192718b759d334e8ec5b81d4a6b431a7024fd236c164089841b13589564431211bf1274be4950f45047c3cc7ce014c534b3298bf7a9b8abb18c5927740cf41afcaf3ccb626f5bf3ef5a4e3a22746974c63f4bf85e15ceb3254d37c9e1897d288eb4548654681a0d1f9aad9afb2aaa26c851c0fe1086eb64050ccefeb8b1bd61f6eabc1a7975eee79b5e5255aea33d7670aad2e4c83a489c1284c2789e97c0a4a104adf477bcfdb784b5ec6d950052368d291c8c73e749ff74b9c841acbec7493cf03de11046e7ced44d613b243b1141a0a377eceb4f2c3b7ce70e204e2a33dde3ee036ebda244485fd0b14a8c4e320cc0e197e199a1cf884bb66085f01df6ff90b1c245e4d69c1155c6a95f8dfd9db30efa0dd10bd80d2a8cc8d282af4efa5e110bd8bf37eda5af5ebaf10d3c86d747ca6d8f5f18738aa406c71898bf3aa7d82d4ed16eaeb450fdfc8f0a8ef59f31bccb5a1d01e2009cda67898e7bec3cfdfe66d07ea8ecf2078778148bf19ccabda34678ca5045bcd3ccd9c6198848332b878db16a888dfa9ee860f76957553ad26facfb339032261495b9418289bb575e9d95268efd9639a4fb2dfb45e19ea117917314322a4b3475081c2fd7d361b75a65630a30d2a669c10e278056d7d9b242fbf829c854234a30a0f298908083d9d08671ed37d255441640fc549ecbf5741f628eaa9e6d3602cde6315927c03517bf13dfd7b09135d484abacca924b341b335b5a6680494cb891d0fe44807dea02d2446d7cf3e5508d684498a56786b0176a5c3f9645d0c3e763c6200496b54f4ac6bb7c6a6e37935638645c5d2daba390a422f3b2be0d035e8581ee3fbfb76041ff418ee2c3e8dbb4136d034c7a58d668f86c8abb564da24b3fd49c95c99866ce7df7d465d3bf323a08e0c4de11b83967ad5e72370040b263b79f93c16c1cd2622b740dfce2b4fb22aeb565b164c2169568bce613cd3575a754a95c8fed950b92b02c70d7c3640f257200e0add6a1c1337f4919406f541444da6b679311189ed99e9b00290d8dd31c3a7613fd53790fcc84573de807eac707f1878537d147471b6276960a7e8ad46bd7d6db1922001713cc33331f18c6d50a6ef9bef31fa06f51f326621e0fa86a6eda417ae07a20075f4ffc952a170bfdbd31c86ad155f8fce8be19be4a0f3529218cf5316c6e1a0a9780ee421301188e3fc3dcfd3863548991a5b050d210a71d99634ed2c577118f9cfd267e91d08b0e7763cdb64c12f97f0696dd53672d6a0223eb5840ca79b2bf12232cf7e60a60b808150773fcf905df8100277e843ad3ef0386eb8c1c814627bff155ad7ee89cb36049e62b0b1c7fef860c79a9ce458369bcf50e78eee4aa2791c9946e204ebd70d35cc54755221bc192419e9b19d0ec063f72c1c07b8c1eaf3a3211a20d64f1435932dfb57e1ca6368048d0bf7db5a62ae8f9c9bea9f036a62736481ce44c6a872475009fb54548fdec22c40a7a549472cf4f706c5d3b3c1e24b4e0e6d1cacb3465c3df73717aed52043c41b1b5391c9bfd63a787a96c0637b6c53479c767bfe9b8b088186cfd16e452ee4322f85fe9ef5dd7c67b723bd063cf8f035cf0cd9b36fea4ab07e7e39f551c9e02b8cb755a8990d9e10f22a0789b3fa573cab6613054563310d80eff80a3302d8671300a3d27dbaedafc017fe8c1ffdcd5b5c8b076b1f077f2d2e44b60592f0d7a3bf71dfdc3f80aa63dcecfc9901eecebca303fb0a5e4e63a6636ccc2b7aa071fb3cbd584af04d65f76d0e3c9dce17a8b9000a4ce54f8397e883af8219c6dfda0d59c0a2556290403407f0d121566a522b020b5da17abe96800209725089dab8d0cdf372cd1564aff9125b1f93b2142563328eac630c32dfb10b4f6924123462d7aa3a1652072b80172a58710ff3da9af7aa7008542c5229fb3d85eb02f85f596b390e03ae0207b3db45c663d3e49ed0c3dec22a52d6157587ad046774e1c563cf5767c20435399f9fb1f6e578ae1a6a61bdeb145b5c5a89043bb47a8b5c9935bf15d7527f2d9fea611b87cad5535c3f25a5f0ead3f1459fa4d292b69e105f95606c5d10544a17a1d4d274c9927d7b89b0b1525c107475c5fe15255d3aa0f3be33811ab69d4545d13453fd8cd612c150a2c231a53f5755231b05dc846b58b0e50c3ced4454ba8256cffa8004e4e2451eb4f15b8b571e3a8c14f77d579f2441509e8e5a9e5f2f2f4bf4bc5380a1a59c1d6f15b7489f802f7cdbe578cceb84b3f101e269a31fa74a00f7406db1a2fa7fa403e6f41623bcbc0e16d154b40a35a50f61aba9bed9e7cf968a4f60bc359cc2f5f9196464689811621084b5feeb3bc6b99a5546e85d8dcb8fdb26b54168f88114091adf193ba8ce9a063ee16d73d6f079a20f2c289fccf82e26b32a6f522a8a0c51","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
