<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f68583ee219698a755d2074e1c419549331e3b1f769fbaff3570a081329c4d6e7c4faf49dc356529bb752f01d14038efeb6416e273f15aaec16a6b38235ba1233480984a15a94864d864862ad72e8907a47167a6685a11e12bfc7a1ca595b4c92ba1b933e7af9b5af26f2acc9f49dcd87aecf06aace72ecfe5aff9a845a0998c6541745116d8e1c3eb3bcbb8c5e2488f9baf1ba3ca25e3ea840838639914eac73c06083d7fbc06ca3a816c91cf824b58abd804b6549dce843a7c1f3957dbb9428e699b5d25548094555aa26406de59d08169eee0213b9e9e72692ab864f6b9a99c9132c07c977da18d624017f18bce6b56707bb7d2ec238552372545e1feffa8e98a24e4e21f5e3b211fa51b4d8d0ef2e1a593b9fbe47196ce3e506e55216a5d81930c2e7fffb04f20a139a084b2f07769d32879367dedc004cc1280c06d3cb166d85aeb471a29ed9be41c20e5c4b674f6d88e9207d506420e8dcba729b842efdc193071c5293608e0787bddc205d89c28abde531438e906b50b3f9903e89c31cc5115ac302ec618cccdd30eff4dc35696dd47bebf8545996535c726a1113c38daceb87ee33cccd32231f8f0b43deae4c81c31062b6e0bb23eeafae5450ccf32a81dee2915f47f678762ca0b026f5217f1495c86fa26dfe9a2b63c815c4bd3eb8354ec2fc4ec60a833b046936d8830d694174374ad4854c8e27494cc88748395d02ba6c4846746e5e11ee0653bb77f29f571872b06f1d9a07fe4be9d64c03fcdaf487c66597fdac67aee2a90144e9349e384d36f5f4955423c3290fb1a6871f8f98508abf60bd6debb985bf62f4cc219b700c3b4906e37d8e153c760d03f2deb8a2dab8f38588264253c76deb8f121698cacfd054af5756112de38143619752f2abd83220cc99ca35a4a40a52b54b0a6557cd51c2fa8bac700f281e20bd9d52e82a5b24fb6c67225db231c090a5ed38d6cc0fc576860886bdf0e470c7e2f33660e822fca722bf3835ef5bd553e63496790f72683602f75b8e01f9b1b3b8f4faeef4cd9d39310a9911e7d8345e0cc026cfef6b192e78d2be09bd3b12ac21ea13eb596f238c3e12ce5d923c0d5647d6f8cc8cf2014ab63f32958df1ded2a23cf751824a798d0bba2549c56b4a0c3038467ce9caaf786ef631d999d0e129df1e5cc52649e7bd9523c9e333ad193ba58272cf938eb901bb2f25fe34acd67bb9a13841556569040ddc6e43c8c45a37f0fea15170b3dcf1b0277340217ac88972482cfa9b6b354d30f3731a608a2658d35f40cbdc67f1ef8b8e945ab738556cedecc473e4319b80513a0ce98d02536f0bac84aa2c4745cb817a24f692d023001f2c7961dc82ea32d0b37a3002a1db67b6426cb227377082a26579058f469e4be4b66bcbf149ac0940375048bbe45c74443521c8aa99023c14882228ece8ba7d8087cd028793eed3248a16f378d86b2276ff40311335d421c4b643dbee1c7fcaf40a602ca71b974e62058a7aea9dee9d30f0666feddd1a062051e20eed732c5e9b215173084c741269157e8c3d7f34d40457ba07bad0ebb59f894076940783a4cef5b84577c3b7514a0af7b6eece1275a1124b2887a48df1e151e07eda991ebf901d0fbf6068474eae392ad068b1f54ceec7efee3c4a361e8558bca0d91baac403823bb58126b178d2653ec49b604d7b63621b4dff7a5998b26191962096cf817dbe6d7302eb4e47b359e44c757dc36826448a06b57198ac7e321646e8a17469b3be9dfc85ad6b1bb5bb3506406c41b870510d65365d13cd4270f13e6c43441c0c7cdbba6944514ac881e710eddcfbfee0e800c97229dad91a137620d06fa060ad51fbe221dcc2935988f5fa6c26158128d2c05c86623a40fec534be6ca5d3357b24da23b0e70a46936a5499930576c8ba0fac0bcae7b86f8f4628ddcab87a6a76bc30d3f1a06561eb1f74fa82237738c7300f10759d6b514c1ac934fa72b111765f010a7b091601ac3d1bf231345e48544f49c4e8fb949df74d21549e008d9a22c82648cab024e3a07130abe05cdc513ef3e0b2ac8792509543f6f26afc79533133839b9174012914e217f17770a04774183300a38834962e8fc6b3994e7c27ce588ba7897c7fb2c7d550ec0f8ebe7809567d18c759d57db195dc1ed38a4085c187bcebbd0ef86295bdce3e068228bf11832a64d2798a92320b2f091c3d827e581c37505b0bd6a661f394c2f0210500bab60959405f4012e0aceaf2e172688b5873fb46e8d1e1a4e5f8a1f551e32b46083be62cc0bea8591aed0d89c7f937d86c4aa3f233363f80097152e65b99d582661645bee16a3b74a411f61288c46ed016f84f2cd2f30b1a50d0cab6de8c2953710a4b18130d19b5fa6af1e5f208589687f4625581fa8aae240471d98525b51c1f22b6dcc148df6e584b75ccfe2c3131eaecb62c5e066d6276f54d0507700ea699c541556d8f956c55762d880cbc4f3d33aff246e2e7a5d8aa74e757ac44b4c1aae0c1bd442558bd6664a90274d6ed58522b13ccec1bab3d620c698d8f4d2d715b522005d4c3d3d17af6bf69534c406c683b3e55309d03109a3b9e8ed8cd984588d6547d1df0ba1edf055905f66222376c0c303208eba5b2292c6a2f466e96d8832ff0abb06f70b832fd0b4fcbb2e09bc4238bb39c177ec4d2ce1d6d0b81b6598b7e885d8ceabacf56673cb08be85202ec4ecfc57f0fd7d7a017abbf052d015b72196484a70966660e1a6f4ae2e80a71fbb26979c77da3069ef78e4156006214172840b78ad80e8a75a860aceb77ec7a2c1be74f274943c87bc61df46130a79101f1cb86b222185d9fe2d759e8226c63c85c54142738154a052d216714ecde1f573cb3de68ab4d68fcf08fa5957772df2058fd8f184791ccbe7db69f0375284f9d62193cc8b72fe68fcf78fb3748078afe5905e334b8d53a63f5a6531426c8167e29c9d3c6d2853e11914eb2f6f7df8e4583783610cbad24cfdb897df58d78608e052b446ff1128802b5c680f9dc56df58aa09a8801abebc842673f92e4480ff860dc5a7c1f7e19cc6c47eae8d981695c70dbda975f38cb8a9ffb6eb922e146ae6901b8f2dee476fd5f0d5096eb5d6b5e50b8f6bdb267360241f3b16f1f621f135403a2a08eaa418320bc2379934adcb3558372451df60d3218c5c4ec7256f7c70eb21dc8b3a105713679675d5273fbcd2e3e1bbe9cf6b706fa2603e52511692e82f3ad88479e016751388ff82dbd3d00687dfc2b2b09a1ddc7b4a925d8a6753fccfbec63c1cbc493d45f3f6de3537b8d56a7583d19fe2ac9d6014808142bc47df234def044dc5909d37d7e3dabc1165833e2304def95d0e35fd2e325be66aca6edb6f94c99fbf783e02e596df2025842fcdea28f62fe6e12e5336388d6ad3e71b23ea0c53b662608682760c5b9a8e2477118f90e32177da50c79dd9a49a85545ff7466104fa640c226c84593befe6c42b0abbfc91f3f65f16ab519bba05a06e9f4916c8f79db9e3aa4919e61bf232de99274730d08f56a191aa52a28e5c057edde97b88ad959c334ea501f71ac3db69deb9b99792550bd919dae77d957c2151e5cb6d77197fc56360642a50462fcf3b34003e2acecb5e95f73f019a881fc9c571e0916369e6ec45a6c5d1ec16528257d74260677297eeb4d1ab4740e8062208290f95d22fb0082d0e0bdcb26efb36826dc206b0a00444bec9b18172f8f8e5f59628750a323bd5d04fbbda370de8eb1ae5e881fe9a5d0df9fb1fa1bbeedb2993f7614027c24dcbf0c15148f0fd1024299f11a90f4596f30969cf8c82ff4790adce07c35a083595dc1c885f11a5a0b2efa66126fb8bf1ca1e81237d7b81dd798b7babb97f3de8d4008db0d159dce8e6543c24a0a803cfd3afe6c185429146ebbc008d137632b16fdecbda61d54e3c7a1f45ac89987377c51f86ceb01950e549c2e1101ee934911dd374e75b69881c95530a28befef5bc22dc160e22a07c47285b9258abdc67bb0b329214e6c0519c389c259b0984c03265d3085a5ee1485ad7810a3e6860490cc3a94a009c06a5157dea0d0107870652ad06aa73ee15bf3cc6c35a0f100e09add5950a7ac1f9325ff5e74b9219abbd898fdbd229b81b5cd7e296dd6b1fe0e9dbd7ea0c938091f3b38bbf78cccca93433e70cac6db03b14b303cd869caa49baf84f46003c7157d6a9d69aa6198b157dff86b2db149ff40872913f16cb7a4b28832818c8d2ad0c338e12046037ea22e38d08a60afb7f513a321aa5f770a5b3ca85e901ebfd4db721ac580d90ef5451b701137df6082e457feecf6798a9692821f84dce9ddf323a73a1f077ca82493d1f2e894f25070bbfd16bb6892e3f225a9f1768e69f656df6b7ae491652382f5fd437551e83a1f4e1151198ed8a4c8b2c329440496c72a78c934537d2cc31dcdc043a9308f6d5a09fc911d3b31da77ef3a520871dff2c80086b36f1bb62e3785b88f14f57e7611415c72006f1d8bcf63308c799935edf84e4160764c2729b1d29cf017136e36de7208fe77a13982f3d3b0dd664d0609787d33f22804843db6f119bf5ae3c9f8264bb8c37313945c9a279c94505c1f109bfb01785011a59e9a5f676886a8c1244818d068bb70db37658662a5f5ff08cfc4cc293041e3aa0db6b4b448d7954fbc370de00223a9fe2ab85a121cd604763e577a7cca91ac2301ca332666ba0bf507d18c55f5c2ebf4caaf51cffa9885892e3be95f903c9ddf28ea43b5a7da89a66c77e1ad45c062303fdcfad6d17c3c1d4baff12fe53433f53aa97103a0806ed8d0cdaa89eb12ff58063694e546604362f76affdc715919cef91982130847007c214ad588a0363b134ecc4523b8b9f253864db35366081d1603dfa712f93475e734907b36806ee68931cba02b32223df5dfaea163c83838be1988eaac56388e4df0ae8b418245bb10912f8fac0c636456a90c924aef41891413e9b60322b30f067dea5cebc72f30282937e81abf04cc2a9ec85e7b79134f6e234fd726edf348569e1a931fbc568029c152812e4ca3b3332741412658c989d6c32425757eea4f970af58813e6457db752f0ea71ba9a65cd33f24b33a2687625b4a5411e927e53c2fad4276d79e89e248195c7c0d83d255517654a8eeaf52fe7f69ee5b3455a8c6eacb4ef70c054d6a09e449e17054b8e29021a0044076e5959dbca860cb5ed640f93b087e5797f84abbc875264af2e1c028e7faf4f255e3e55c871bf16f853ae12cd0a9b021f7c914a50ae768acc1e894156d948dcae95c60cd4634ce704d3f4ba785aab0d976ea687cf43ea781ccae28ebfd28cb611226360ecd3cd7971729f0f4774e62f41c5899fc4abb9798b949f1bbbc81d3d5318e3e37f7b935162394fe3a12a4aa3294695602fe43d7856d3af2404923b1d91def401fc43e729f2db4e6c1ff20b066d6ac2b05a7007406ab6c419fbb1561d897573dc60db6070cba0c5e3a6f41f1037a9d564db610686fda9b6cc19745ff672824cac21c2b648d1df7b8de7ca289aa7e72ab9d89476d794be11c8524b1cdefbad4329582d90546abff4948552c8e30d2649207c504570d02ee37bd19c7a1a5e4fab0e7354f73bcf2cb394508ef1f557123fbfdba67baf9a6665363e748839e5fe7ec6636eb1aed72457f37d854038db7004ff30a199307b999c2d1acdb1b8f06df8e0b726a905503b5d569b5af8fd55200a38bcdf289b298efe06b3261d5d12c64b1150989d77e4b7ebbd7805d2d3c997953fd9da13fcc955460e21e20e1b2bdcb923bc25275b2050c852047c05b16871c4fc4145154360467add4d36e6c29cf251d64dc4ce252689ba90b1e3bb285bb1806918cbedca4bc09b35b924b8a9064dce9ce625e031b4f86a8074b3a8c412fb7afb5e6062a892ec9cc20366d6d24bd0bde404b258817cc6c57a1a26d31e146a968a8ab5e7acd38accd992fcffa3fc8c7fcf971e982a3977d04226c45648a36938cbb0fd1469b0837a0a4270285bcefc850c67c6bf0b9a5e05ca225d4718c845b1e95cec53e900b5749ed3aa058b76be3e59a8ebc6078e8e28cfc90017bfd3e5547f2ecc8c580627d89615fee4f2af2b5af45ad3d6ab9b30de43777f769c81b394cfb0a3ae9411e79f8b01e83221c0bda9a2ed223c887ee6358fe1d6aa08e1c95e2852104890dd2d9251005a853e1611abe487a730898955095c0cd1b28ce425faf592e8460d96adf372cbdffe7172bc788619d22ce2e4442779372de68010ac99943a1c06994916f901d3a5fdb8a3743aa25346c52e1656486ca11ff1c621134365c1ef2f4cbf2c9a979265487a7cfcc99bfd78baffa0d10919eb68047d47a30e4e4a4a940f0815bd9562816876808defb4107dc60fa667928806bc3e22df826cdc8d084e9f2baf1291522198ace82ba1c1134e4bf350d7847c2530dffe21e6ccbcb676f37a69d0e80f5108e8fe04f7a471a6ff63879e46db7c895598949b55e85ee82b749150ad11c87f3a2e84c0ca54e5936c248f8eff79321e42bde8267db12f10db83cb8b217592d092661ef0bc7c094c847759edbd178a1d7f172388bb66db66291b2e20fe64c7e877cdbc6d55b3b65197aea19e3e271647a29631bc31a6da09776b71dd64bdd8d5c56e4c492dfa10deaa14a0aa640225fc9f4bb8dd51142c915da31a777746044c240d1b0b37b5e49a394eab1f4b1a336fd02256f3bfd20d881c74e48dbe3acd34b7bb977715bf197b5d3d5d5ea5b40b19cc52ee940371c02913d958e007ecce3277cd0800312ec5a493a1d91437a7d6eaa26ea94e2d749bd966705c33943be5ecc108506e4020d2aab34b38158d128fa6706568d2184b892e3d0ba2b7a769b919e304983508be7119ccee3b802c38673ed99418d61edc7057822aa6d7e0ca901d959e9aa4f04edc3be65a4677e2b2dcec0c7b23b4db83cbdbc09285dea0dab9414a47d27f237d6fbf5fa267719dee1149675d372126302310b2dfd9a8ddb882f2548c514604ded90f0dba0f0f2196cefd59c803e71d617df1645c53ada2b6ea00b25ffd79e1ba405d2fef76666f6b07878145419456e1bb40fb013f32b37fb79e85ba530e5380430e49ba53db48ed3720ed9676709a9f843307fb9e6999cfa9471cfbe7c608a09ab1b633da6cc67439ff3d56c88b16e9201f6a585a5f01e4f947947e600b8ca54ea889c8bd61c032417ed8a8cfccad7eef3453ed38099a9bb8a7c98155c6174866f6c7969f59ac6fd1fb105a7ad506fb2d686b1abbca82aa00b83aff74f7f1518cb66b74ce757bc1d046bd1df28d915c6459edf4c011efb862df8f4e2eb8cd1f85028432a0ea7039478bc3b53bad79b2a85d901477f962edb3a071e6d58bda3af30f027502abf4003fdb045aed67e328ff1c8cdae9cbbbf11cdc66d25c5a19db40dfc2941ce31adb0d6ff1051d732b2521eb2304d6ba205118d3307bfdc0d476ffddeecb9a337ddab3b56d1f85fa08206bf5ad5c0b50c81a68592c114131cad61cdde2d562898691cd0f128a1c0300ee99d7509d9aba7114996d2de402b219e507da2a7e2f49e494dda4865cb6ef55e25d77644081b9a2256aa075c832d2574523c783e1270e051d7e062ed915897926360c03e5e0d9b9b879ab07184ce05d53e9dc43dfca53f9087bc09943deff2dbf6826bd47e05d4c3079e2cb1422b179ffd52b7c337e29886b247bf85b030b9b47f89855f41286eae4ff8e0a2bf3e30c60bcd897c877d2c003e8fdffa67206f7c5f4c802ef71b92c88344de101d22cbee862701cf32d13011537e62e29837b54683b3be558b552be2a2e5ef9da2e83092a412c115ef4357353493e3867a4b619c1880fc698f6474b122a0b0bdf5ff8584d0abcafeebed48125f91b96a558ac8a02cbadf4e20846bfeddcd4b026b4d97189333c219e810dc2eae50875cdb44c1f91d40f73c384f2f05403d9ce9ea711aeaac8e5f40c68a594563786bc2b8b78ef458743b1423a3e90ed0f00faa1cac254a82e1062cd8f8b18a53305c43086d8773d28712a313f58c88e1142a50a5ee498bd562b9437d7f39c376ca0ad9ee165c89e9d84a3a6be581a0b4b45982b794f5d7584949e86485180358b5343fdf0ef8c3e4fa4442281afbf47982217c00e1518251b6ac306c7d42e666d45e46206be1f9f94afe0633d8b9d1803a42aff10a62099e9637332fedc96167753836da009384706752315ce1bdf89fbd5e8368ae4c243c2ceb4a2faa30961a39cb8a1a661dbbf0bb2a7086ce04f4ad52e37fde1716cdb33a3f55ddc5fb18c4a030de7917a8f9fd99b1d03049133221d011627612cb580b69c19f9d42dd27bdc1c2ed37511d88e232ec9e17790eb283050cc48fbda60f176272aa3f3c6f339f7fffec237484a221ac904231f69b0f77738910300bd7de22565402ea27c61e82ebba676de435d39d7d0b8d58edfd2c4d145437ea78f0b6dc1b494d04665bded9e63964cd678a3557bac2c10c6646725d38acc1cae90e3a77d43524b46e7c679ffdb71b29dcd690b5e636b476f10aa643ec7a172a81d4481adee505c14694b2ad59b953143c1f3568ff72a3ac8c36100a018f2a3c1bec6ddb259c579a870f0a282fb76e7e14970bf364259372617ab7b3884fcf50555b4427b0dcae714532941f2c14d982e8622750dd442adc5d894e16d2f384efd340017a8372fc68b342f4c1cbc69ce6e6994d73c8a9530ad5627c8ce6d813327d2019e38a6968243bb8735546e64fc47a8b5590b2a620cc5fbfa8ef1c4e06924205e1af680d877004ef97a33a9d233b3fb75c5e326f682a6e18e9a9db90e8e54ec159e17c177e4cea39b027b2caa25d180cf3ea3f2533e51bc8cb35935dd5465557c7665c938607a4db4f961614d193195cedd78b0d23150f3c9db07f4ab1498f1f5f77736821e6b013a293a4fc843179f839b65a26c5131b1690c83891046702ed267af59830a3653bfcfff0f0c9302384c8633560b827aface7c2e6a070bb707c11df4da8b46ec21e1462773a25f0e0f5558528d8533af48d38bf4b3bc916e3fd1672b24814e816f8f63d87ff4adb3fe9af2466f70c0e2d1d6214effa5cadc4f3065b25f96643366913f03cfedc68ed4f63f370a7743ec0cafbd00c26d5289ee9cf04acfef47ab96e6024685b6a0ad3bd9f1b3386ad450f8ac9cf1b82ea955ea8ada3eae20018820724e77cd69337e7ce7b251dc2e7e185eb3619f7953232b91f475d704c9bb42d813aa458552184e68e7b3ff0e19076bb7bf999b67dfd8cb05e66d236fd77b705a704e38b3f9a5c86e44c4cf891037fc35de9c4e9d507024b3e52d73000333aaf78f38dd1485219cab128f76402b680276ce4f1ae94c5c4bcc23b375fa096df4ea990ea2062ba0eeeed362a8b7c1f298ce67c76610ddea59dd19836586b8221b38643094787464b624f48c6024fef964128182c40d2cd24b347164f913a5f97735ce404175374c144e78e8f50e0bac778afa341a098acde9dc0b5aa6c16a8f65bb4c1a55e5559eb347368a1932f7c015aad5c71dd2a4efdf8057eb73a1a2752355312e1e1f55fd23acb688ab8b2606449fbd80675cdef7b137711936a9631a92a8e2bd34a165f25682a1102a2434c7f90f725c249cfccd573f1aacd0b0ff46a926612b4a5122aa4123b80bbf157a7be8ac37e0a7786e76a47a264fa674e4ec0a8a1dccbe6146f7dfd961b294403f0882239291397a51c0dcef7b2ab8722b7d20093079092b452c5f3dd005464f6db1880283a518b477dd6fc4ab85898a79ab86453602a3c96b0451c848c6df82cf8b4525dd2ba04792d0c2f9b45d3d79e3d8101768ab1ea3fbb0b21ddc8875d10545232979ab10e5c740ebd15c5538ba6702a49b3e1f4cb24a6799afe5c80054d40be1e1da279769000d8f6e2d94b3dba8443c0b55b826e8bce1a274454d861492c252834c398a17f19410b8d7007e5c91ee4711bf2047152b64d2900063257b340800efe57148d6166a7c82976e2b48c7a0db3b6fa78db364b3d514ee22cb6f1a7340f5907566e812b4fbfffa7d36b238053ab07fc0b788a4b9a81d596889e80e54131c865557bf2c93f691c958ad5488de1b00ddc0c029f14563b212ab23e66c0f0d1f86efbd8dd4264a734be49454e63b8f0ac6efc9d21d3279db22204546b1b4a0657836e316f13c748b97f798d4862367ac3587ce82e50164c3f362e46fc77e982dc3627bfeb1f2cec35c60f7a3502b24da0df70e8299c93a3e0c67c787ee66e8cab2f295f434907fea01b25e9f0a9b193452acb2a65cc339aa8aae7329f01277254a14ddee834cd04391bc6c7635e170a38b37b647bae21f80ea196f336162ad38379865846509260a3ba53fd2a63ddf8b4e0c2b2482927df97da445ccbef2ac44f28765d07c2c19ace3c6f18d02a00936b93ce0c6018c43aa071c71868ddab8e6f7b88d18940d9a642691cdd9a16b5ca95a39c3a8db9608a9d5ce593f1063b9a459ad1458cc12d397734276c601b81099e30982a90bea79a0bfcbe6afe0702448d719e997878a67a83bb3782409be36f85122ab1d0a06646dc52d7805bbaf6c2d79773922e4bf7d6c5025822301f14f4321e9ceba0b9c673c8731ec5ff5d38b38e458a07f55aa8eb01e58af229c66ad93a0c670b71f3f7b996745b6076ac296d6e51dd84486d960adb9d2d81f256390e5644b669d23571b38fc0681b4ca3a31d898ee251669418f14b10ef4fd21396bcdf45d79c70ad84b5263361b101899b9e5e340231d1219a18d102844c0f3c27d850c96234014d310950ae8aa89c223782dc6c92406a49a315b8124f61bc640ea2fb1acf5346a8975e99d4b1e47a2e799223a51b3b096b14b7e4b5ca5ab49c632a329728bbda9911170f7d4ea239c1309b03f5af70badbb2cd360fc0c45a783206c629bd916f6a6c8c5b242823822c1dad005b2fd3db9dc935a750fc118942b35b523849c57681328c432a4cc7aae5ab9f81cde9d08c994179e5a5f2b5fc80dd54774b023cfa6e5ae85e32e71fd4344b7d50e1146d280dcee3eb0177bca64c27e13b52985a9f9239596195c0e3f030a8657edd0f6c2e6377e706be711227055596e6b44536bb0718f1cd2a059a7442457427080ff10e8e8551388c3778d4b71c39691c230bd2196ea42aedafc7b43ebaf4d6b2f10495628befe446b97f3b74e1dfc8100d479f6c406f0ff1d8e305829181526b4d7fefec9951e267de7d5212e5dbcd3e2dee16366dbb0df7c3b730e4fff353dd369f202fc5ddd8935c13a624853e493358d0bad62b7f130e525fb88f12c29bca41070dc84679f22206de4687b041b7433ecb4cf664da01bd9705b61481747dcdf7bbdfaf41a25ab72ce99c78fdac640b14797fb0dc2b4babdedfc0ca54f199a638bf284481fd35eeaacc2cc9dd6bc9df244db4b8ea2fe5c7357a5359d7905c2418d8da1302a801bbf33436e898168e42a5b4b0aab04be97242eefd8abbbf2a119572d3f79616be09b07abb337f9f3acc0bab7d49b2b345b8e7d9f812accf045f9fd34cf33cb3fa3e812e437e4ffad74626bdf7aa77c12c058b2a3f4050986bb0e5470653184632e5e914e173a7db1e3027b1616645ae7077456dccc19f7d7083c8c32f4d3b8cb7519679b897f56040734abeb28034d4a48c01193c96a054a85717028938439b930a12b1924ade0699de0e7cf475323f96c530e45e1352a4e61146a8dc4e5c5a8530a2882ab09fe47093554010db4462d0fe8783b0e3d758acfa761a1366e5de3e2d937ae09f207ab98f7a3cc2a18ac1fa58e0e683f33b6aea8b0cf160faf98c86fbc813e77b629f0cdc68ffe7447df02ca6ee2f66b36a277246fdea09d0e4275ec87164e8c7f7c9bf1d5a6d61e2265507a2d45cda1685deedf42df93730c8029f1ae0e667df656b0fc6fa4eb25d735c6729865018a8ca133cb1ce71af92891b8edb0684121daa0323c12d2cdb25893cfeb13cce3e5442cccb9226539dcc96a116f7d667ba5ddccaf25c9bda7888073e4aa1c9ee31b3a711b4f030b3f5e7cbd01e2dce4951be452f392c9c5d0f7c6dc9886adaa081530e54da482fd84e6d3e038411c140a477c80e4ebc04657cc6cdf5e16242a7023de2221cb986a5b0e4a76f7dc586911d2d2e623369c3ec658b32b11a2ba041a1b409546084d363c92e4bce8dcd3ea33f60186e1f41fd75672d04ae863913e085da1557dde4045e9eeff617d4ebd702a4e8f2f26291a7b63aeaa2ffeb52923fbcfec3b046b30a9b8b78f8687527de96b6cfeb65ca583b23328085d5996315a559f7346cbfb40909b66344b60ba628eea39150a259a733268aa8a1a4ad184e215bac7de81805c2325498c557b398e90c280a7a71a135df7f855553fea883cd45430e2b986a79991efb6a2db53ba0e3d3c7fcb5df090e1b90ae7b7dece4387852e3e702aae92e3cffe449b21d6e1e687baa1778f74a47eeb828f2e06bb90fb3465d80c80a8e55621b8af0f256ad9aad5fcc465fe0cf73514ebd14bd3140f497294fd37610a8a4c0366429a29a902133ba887b1f09cb5b75bffc5896fec09dfd7444626977676f6c485deb6d21c9da57bdad40572f0ccef0897e398760ab087ed80f2aed114dfe7c996ff6f37460495c5fca25e94564e12a577b9f835536789bfaae94a570c2d7f685b1671e556fdf9247e36b3b22920db2dede19dc83e2bf98e0a4a264b997ee0ec7f3dd9c5bf72042aa525e5bcee9bb176866895e685ea5f870353256517376093c7b2bd16684cef90fc25208a27efde2876aef04833d0daf78f7f4c6b777f64a49c1c9d81046a301b3070ec315c352998ba785a30a77ec04fa495b20cc43272e03ad9754493d4add764e508f586bc9a4838df34b1c921b77f7d4bcd784dfb997436502f233de0a082def714e1598e1df164da4d2bb7e2f6ac4cb2368dfd374c7ccfe95d51c82cb6b7c47c42966c466cb54d10d2d07b7fb0720a3b065439119668aa58c9b0980c1a6d2a1b334be86a95f92f4bcdb119d815e90551dc5b3ee7c781f1fcbab5d5d60139c796bb988d9f1692cc7d6cadb3ce10d13c36f7e9f598566fe61adf1e368dbabbc0984843ee5ebcc0e83251c7fa1ce1d791840289fc00735c996794e327c3dbd7d04d9b541fdb8ccd8ef8cd2bf086866b9aeb13b29386d3f465868d2baccc955df4969a9bcda774c3ef5829517599f2314668002807f1daf91376a8cb65f6bd30e527d77f937ccad3be6682e8f0a64cbe68c14ac188981bd1ddad85fce3915dc380482a347e885dcf9a12059b2396070b03ec8d2ed1d1b528bf33e134bd94d4586577bac3c032815f5eaed1ce8de323acbee1b6d3e790191f89b2985821660546d60fe207b1eea9167fba42c2a95254cd573c99e0214ffa78370cfaf8e20f25948ef7cb28a8685d81db909b001912cb719bc7081736a6309e6c888393b61863cfbdcfc097360112322b178f6bc7b628640ef68ad1465bdabadc5c1544a5020734c03e3f0577907b40baf7de6be6c79acffedff6ac530faf4d9621d7f94db51abcf4214d38942b560b1e88ad9645eef53de61b9b394049f1837dce42f1677cdc5d78bd794330ece034349198d34117141b7f5a67c4119f6ed354408d12389704f024a9ee99909c92ce06f01d7972ef20141b285f25cc7c12b4936e06a9a075b3027a04a522f8e4efe72835d0a4cad618bc4a46a116a2128b9e4c9c86be40e56c59bd95a287182815b22c1dae9d4ed0056ac826ed2214682032d678c7c6378417e5840b2b545f07ad06c2d68c0ded8171e27ad12a30288f3c0efec80e037a6348306b47f458b4434594261690da13ff45eaab2c2531643199b1dd6594fe67246b60c22b7ef26c1bc91167d0cfac4428dd8dbe54513165da63210f845f71918b9c5067b3c058dbedc81e659a110b9d7ce2ece17f8713c79962a17b47ad3a36d63b162836dc3c52632362c7abae610bcc185450c144c49915f541ae7d0966ae25ff213cb3ecea7e0215a9cbc9cc7bae7a4732c8baf5e9b2aa6fd2765797259e150f353ccb1eaabd53a32fda0f522b792c3e6ba8cb47af672d627e92542a7d2a054814e6ddf503596c91e69be55da784621e33f0eb52188a91500db0eb89a23351383d7315c20d0a28761bb296c17929c9573bcceb8d90c41e02e440b61718899739b590b860c18da6fb2d1921f8f33af28bb90835e2cb91e301c803c20d53c5645a14d9ce8ade3670d4fa549bb9cf1c9f6f9ab3e32faaa0f006d427ea0cf875e4232033d99d60f43b9d563ec5893808664768b27bdd61d453b8da9f4f0e6992145fbe3a53b34d28993bbef748178fd6a1ba4a603a806229d2830fa98a54f46aa7c5474c19319a31019ef3474c32d4917a3dc319cd53f129de7c21bd89c6f61e3ac3ad882f73cabdaf4d195271ab2b1bf4ec02dd50561dbe69e24ad9d3b0245d5ecefb6f66f8617794bf61a26b6e2c38ef5101423114b90cd05d93d9e4a77d686b4bb9a0af9b879436c70bfcbb10dbff05bf7ca9c20582a107ebcb5f1cb004dcca6f9536f4babbb4f36a3948036bd8be49fa5093973fd8d08e6a4e0f007c5324aab0b11dfb0b44c6fbcb476c879a14a8511fc2059d0ca5ecb6b67e4c621acc5ad492a3a5782e444e3b116741254a2b6279f72db784c139180c8ac749c2c1e0aeb7315069ec28b9aa19732e3f5d0b11f6531351a02f8f14231d1eed16231bdca6730a7c60c0c5a4259791a685f6e3e7513ea0907f62f2cd40dcf873006b0b99e3648ffabba171f1a5305cbe02fb6670fe356cf4c55ca875f86fa62e3e76baf248d19f92411eaf90c4e3ddef881a4f5aa023e765cdd60b23b5a83fb09a4c98824bcf6b78662e659dcec1320ce4c2d99b4abaceb33e9d1ede6c91510bf2b840d93310449659ec9a21d38832d88b92e5a46866db20377b5dca53982eeafcf499bfb6325cf9f9762a9fe4388855cbd6c547d0a12520d79149aed188c51d9106976340edc8b798ee316696e1c5540b9968a5c611850d8378c7dd29519a76f5733c0bd8b00f79a5dce42e70790da9dae2738753a22fef96d0da47abd7397499214e60cefe2ae36d98b0749618213d1d47b4ac61f01a740c57d04aba965df097f2200e6f14c822f535cc746f268c51169541fbd69567c73f3667d63b015099bfd2be7a807b8a6524729d8d37134c4e22348fc7bed4d3eb67b91e2677ed59a85cff49dba9f45c0409ef54b62ba9f3d88a03cb5339205e77590511419e8c38f23e61188f2d1c1f92fa1bcee3507a013fb9ac6763b181f900c5f0fdbfa6069f9d9788d0043d86c5d131c8010521ee577675572571c62f690e7e16793b55e775ad7d66a8fc1474c69ff88e3385c106ca6c32dc207e0763a79e6eaa18a1ef35ded3c9bd75001ded6c8644aeedaa945229c12f74aa529d93888ed7f2add6737f2cffbe679dbf84bce94e89c99dfc87bcbbd7b3e13a71b57e028d2f5399b83c703d5404a432baeca12e8d33148dcf4e1230e284c602852bd500d9cfe0d718c4218cfb5bc2389b6852a650a61422c3991983e8e44e646f4bb12a9d0d9a8e3024789c31e10d389f047a7ef197ad2b501f0dda7fb18c6c140ab5edd1bc88070e094f53d6531591ae04d05310488925f1c2f5970e8cd3e4f45d0fb3d6142c08f5d954d7265134fe8682588f062ea86ab46ac3bfbbfe7f352ef0c4d3f409b8421c9d4cfb848fd8911af9724b4e5da1b5b37ac25810cd176655bfc2eec177f22172e7d30ddf4d8bd57453710f00e71cfe7b28279a489f2afafb2ca633d5bc89826f3f26ee755bb1d4b299b17a9d816b798c02d693aa9fc633ef8708ddbc4fa7db4c71762bcc590508fa1e4a5268e0c6b1a0e6e9cbc51f0a8c3a7393b2417f5c8a4ad884389758eb39995605970fceb80742f681c1fc93ad15644819ad824f918cf7a4a0fd6c2e18844e2bb6d377aa4795b09b64a014e7c0e8203827f9443df8ae4ba10672ded0aeab053ae5d060668b876a4c01583f83ae998e30d2376492585856fa0631fdb7b5aa0aeee37cee55792e090674c30ecedf8c87ece3177f86c9039b8945a08d5f533517e6c25761f9cdf2fb58249004922ce926410e31a4b0192a27a92147abdc992cf6f8573c5a619fe3796a8506751cd979cb9ea732a7089cfdec1fb2116ccd958f9816ee7574845ec540d8659d15084ad4479f4c8f4631b293daef68b9a1b938edd00d06f6a38a533ce2961950a82ca203bd9221f15d5bcd42b4de906dddedf076db4ee2edfd7a837fa25f95b12d3c0ca54c8bf2e1b49ffa7a6fa2305da921c97daa0600e05f4e3623d3f575d9f5b155454e6c868d24299753241e81772c6b2a98356cb6cdf84f470241c7fd8b3ce7256381f785f84ee580cc7c5c882607f661f529dfcdcc6590f3017c92260a573990ed7130edf0a7be02b43bda01c4b18bbb6e99155fd5edc332d19536d43819cfbf4e428b672796bed2a847115a21d42d95be1fa1d29145c6d633dedde98eafc38c6b679a4127c06737c69fb778915aa888c91854b978b9f2f3265e83a23af4ac6eb323d8a0e08b852ed86d5e81f3202e31e98f2f957bb502c777334a243915ae4a1c6dabffbeb4126712d36b225eccdca73b7c12d63b1d531f67d282f95be4333e97810c6d5cead6e7522197335d18ceddcbe1725fbe1c7811eea2ef6451eb24ed77b80b23883d168bba1c3567a33da11ea5f7fd3c220fc7eee9558951f13fe4e21f1f6ef232e1f3bfccf2d62a435562f8a538a67b2d68752282d4b0471665a02b5ff20338384544784b356ce6036c94043d9b5ac590afcfe42354d568e8ba9cae965143654c931ffcfa1882f7a6ba1df62e56fa27bdd7ec27ff35ba519539ca1998816a96190df7f1d9d74a90856d7553a82ecbf0bfea70feacae84ed8c68260a5df5af20847f4bfd7cc605696481ce78754090d3b7d922f733f707650037329ae929b73b8e094a0aa9b9e1b181664a42ad952afccaca0c9ef59e687f79ae12e4507fe03db930452d25449cd4249314109a95a375020ef8df9f8ec336680e7591e4e70d4603825866fd61c5fe737912fa873014832d87d44299e029a57315a6f70f313e433ec37ef5ca69dd041a5c289d631027faeb3d7e0e263e7eb1b412ed8f3210896288cd92a0b81081ce01eeb246b8ea0dc131e66f869c81890cfad88fa98e3260e12ef029956226b084723025ae185724aed10c090385ceb1759d76a99c6bfee5e07e3f907e2f080247248c82e21213641cee2c723ddd9f0891ac5f196a3b47e6ec575063082c77a1db6bd0265cd0c513c424edcfec9849d383ba0f12673fe354cb509c4afad16e65b456883ea9f8308ed18c958737eaea5023f4d349f10b3a2a13b6c7535f0adb2b2689941c2a796dad7de385ab9a2984b9cfce4c0744c14a40813ae5e0acffa3ee873272660d845bbcd8570889ff8449c3d721e4dd68a5401547ad78c51283631454a1237b0b9b6c06c158b590314bee40b13c39331f46b6bc6c43b3caf1d1841b59fde2b53f4ac89791fe78e514d40d73320e00026274921c0f9cedf27f826a8a98af88dcd57b4f1a272a9a6b9ba88c3043894ffb25d46aafc3f712657ded98312f705ed7db9dbbe2e8e95a3995de87213a6476de8c6a36a9d842ac1c7dbc7c252c545db0a2ac1fe21489c6c6f72deca982aec43e2f79b17ab3b76f9211b5d551f76c533203e4fd27e4743f55785e9da3936416d989131a99f743e1f39a0b5a0701b76491cf0996290da85b051ca262f8d5378bb43a9bd3ef12ca668ddd6162a261a8b7c131c631c98c6d15967a06e59b60bfce2af11e66484864123e18d3bcbd18100fa99ed43c82cb01a2e4ba333f52a12eae51f86c8cc37a49bba94ef1eb987f4ecd1b2809db6b903646d64b559eedc06b149ca552e4d80bd77e815378bea726a90769a79252c7af7117eb6cbd7c28264c9a5f6f55ce0d9d2d9c20d7455dedbbb86ec8ebb34a31423ff2d7deceeb8df25c60cb4bce92aa9183f40e15730de3b7a35af8726266a15edcfe5d1c41","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
