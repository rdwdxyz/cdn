<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"82985ec632f4253b5d20f8a1f6049c6e314603f215692f3678839a713aee81bf5c57348a8fa8c1d733b9969407a8c3eac0cfd7efb6d1b03fb70d50926e70ee15aa00229440113aa4e58934c9b411428b6f6d981a444d05210f30d54fa555afe73654c49629afd82735783f92c8217718317b2d9982bf2a1baa6d9438527c780923fa9c7ecb95a8fac69bc91912822de49ab7208fb36fac3720b70bf3345c9ebb2cc16b41fdb67d3cdcd890387bb9b7dd54ce39a72dc664f449dd40dff347a2ab29d506ce07052654eb5b9a287873e348bea848d294b8f62c6eb9b43bf8a61f74f5c22b2aec7b67f5973242d4e3591b3db338c6a229cf83b0e8c19351fc8ddb7cc0702837077c3947059a7a973c704ec51cac4e5567f833f0b42194101eba6b67489a77d269b0f71f278af3f0383a7b7fa3a430028d13c08e66370e503a842b16afc0ee20c71a4e087d7ac46d751781e1b29fa511b4ac57da7c77891fae13894ed8b2c8dbb60e90c5c0e6f948ad63263a7b500de2843e1d29a300823907cdb59717c3dc1c45ed2bcb86f649e7247ee1202b84f98014cd374ff8f0800e91979d87f7b852085ab5eb95244e10a8dea566bce9b27ca774214977646216f1459b0429439e9363c4d88b7e1d266aa1671953d9603c004052c5b93b40bb9b79018760ed8af58d88c4453983b2bfebba7a7b74d7be92fed4105762a1078cdf4847c0291f553c08a12b95dcea7117c2e84a784be008fe92753abecda0862f01eb30cd9f218a589442340217909930595a31737b8649b68f0d271382343a248c52cedbfc6e754cbb92ca9c3f1230c26f78581ddc6a39ad33a8aa309342d5f98c7426dfff0e1b562b97de63c95060d1ad8f2b5207bb59d2ae3da86f0a56fad605119aa582eec66d8e6d71a95596a71b4ff9633a5b3c1f90cc02e513a61ed5942a44da65537f7080431a6bb1399bd0b01308f95c34f9cd2fa1a054b4eb3a78d47f9838dba1f2feac99b789d4faea3d26d20be5c3e5844574d8febb0ed46eaf8454186a1c5ca77746e5c0848c701903e8b3394202ef05695f7da5416d27db5d04d3f030eb91126f1af665dad3f76e8aba8dec49625afe49e96080859b65fc26b6b377bd3e634c68196a30eaaa81b11a5d5ebccd6bf534efe2c0830a4fef3dde416f0a322276caebbcbb88210c81f9b7e1c6bfd03b192c6fd4baeac20184245c35f2f26be5f40953490368a7e2ec704ea81cd0244b542f40ba1aae87b51ac4dda088dc7f973620aec30f2e46fe59ae62991b420accfacedd10400035f80661f567b444e848c0506141bb218ebaf9ca791b1c10e3c781bfa77e823e9df1d435e82404b1d394fb9bbf3838ba75b8fa7ac56d2aa30b878f150dc65d24fe3ef2d8de6e53e0db1efed926b47e4fb6fe1cbf46b8b8434d3c939c9f564d14e201de77964f88584de5c3701803466f278fac4eaa22a5bfe06be46a291c608012da8058dbd71531250fbfcb7077c1e881016b9ae48807c825fb2821f3b7d6ddb91d6313929707c1b4d615c066f839522a990c4fd307fb4d32e2d11e4b2023f435f03663f4486df8fa3afa30e4870c7abe098ae803d2d379887edb8f04db83bb9022d8d8eee9fc06a3af8545b8946386fe90e434accdf0c050f169790152f56f7fb5b97b5ba59875cf1b001c679b1bc5f553dd2ab4d8107443781b06a4f08a0114eb03112580a5d5fed6c80985ca96dd7f870818c9725784e88a9e75f13d7dfed355ab05bad7e1c1e8a408d3c2bde501eb6260de066841eb3fadb137f27b0f3f72df3e0575ab0ba9bc705c569fa2e6ee6dc3b9244099d99f72291431d633e3dc67cfb8dddd93af664cfb4d5b720fa5f926a712961adaf86e927b7801e6cc944a128d85993c8db6e1b0c31425e3812456f582c6b657d8e65f8b1e2559db1bdba5368b90443df218ca5648714bf363c4bc1feddc1d4c0ec3178a6ead875607c95296feb62e830e01b101bb8f457cddff4ff6aa4d76a8733e3c972ef7cdd99c63b1fe6ca60f631797a6566361b506af30ffd02c59d771eba74887cc16d49a6e0eee47c1903f65d60807a150cc8f259cf38ee2850fde6f4150ffc009508d2dfcc84be30812eff042872dc02cbae2ff524374fc2553e27a1f61e7f1be1c1a95a1c3121bd30aab72f261b2acc227f5fc2cb9ffa8de6c1c22267ac752898c1f37b24e53ed7c76d050055b8b932cdf6a35aa45b695a5a9bb198ff913c6d5fd997e6144a0980008e82e6ed854d273af161d06f7430d00735b2b54b440e6c761e914868195bcf711681b8e040e3fe2fda4b5e7d2c39eda64e07aee3c555c9c45f7885df01afe3a98a98513443e76d58e153e3baf148eff63fa8ca5d53f2ef518c2d300a3dc68094ef0e3c21ea8fd0569daaa5d051b4b3cdc43318dfcf2a41cd5ce6154c0ebc0e9ab2814a476ef935c5f655e90c43852f422aa3c689775510245b01e65b1e3b9f3f6ce9746d9f3b996487af6a6c730e7a16d93bb5b18a59da10ccd0b162aa43e070ad1667ebf1a25cc2a24b7be5398c4ddf0104663eb8409b1cdbfaa151f263c3f859cef3e614497d8df1d38a30298f706dd5136bdb008f309f1bce0017f86c8e400df6a110819b13c5ff210b8267f82dc7296cdd7571d6518bfea9031d6cabdcd8e4a10e056f326da218b7d312cbe5d77d3e08410b4bc120f3d5441ba6764183b93da381a482865e0e54218b490f9dd3254679eb4e3b1368970b783fa7b9428e527ea31398a8a22e56bc2a2e3359cbbc7c9b80c1647825219cdb81d8b9869bea93cce046252de9eca60379c06d2a2cfdd480995917aaecfc5721626e0987fbdc3f76128b87c29b69604779c932637e8dadcbe2a30c96150417685a35cfca1248fc3649356a4c3881125764d84b458806105f3b562d81bfd96d34d4f01d1581c5712c96d0da37d49a32eec4441e6093389ad92a79a066b4cfd57f0d2202cddabeaf2bd7fcd189372eb11ffff116b9d772c9cdcb6e63edf4c4a14a58e1c87816dccbfc20cadb6239d24e8b0c8f5eb49932b5c5d1d39fdcf858a5e3016330663bb5a5b0a8ee7011ace0ba7fdd7885102ad97682e068693f8a2f5edc3328741f9b7269150e332baf306af731ca8761b7fd4654441a97442f155bd7e96cd18a4b1d57066659251f48b9136716bfd83cf0757a6009384dc8773c72ceb8ed55d84cb775c9dd741b96434cb11b0a769037e507e22286f8f82898ea8e81222d96a5b702d95e3096b81bf1d35922aff2840658c6a37a0b9c3c9dffe5fc147e174777d0a1a4a041ef7ed3bfa0d8f08553556ba5d820eec7f05fe753afb4e7a7780750c91f9eff7fab32460e462bd3cb45603b53f524cb90dcb631ea0e925317851d469b0db9d4077409215ccf5d93f089dc6cae4fe758230d973443aedb343f050777e6a1d37ebca552c02bc83712b5c5e4d05c1a868affeb1f0a983d0b82ba6e73bab44ba02e8ca563e6657d2e35967d59b809360b2ba8d855b1038bb20732a69de5419724c85f574a95f05bde4e504f1e7e60ad7dc2f2704b5666b6d8785b7cf808e7e9951d3c936e13213c07eb1992378cbc730dd71c304b70395018741ab7f1792919ceefacb0c408c4df8416100a833c11a26f1907279225141313548a51aa27e20abbc4a209d857dca9b81654131e73e2e1e99964b37fdc7c3a5f5d697ca5f0e9e8219d18afbdda632224321a703d173f1cd99d43659237a00ade389c1d0ed0051fdb88f3b9372fae326a7798354723e8dd32430fbd962d565cc2a86bc568597b28da5324416c4897c65c7e01d49298fd443e1284e4456e8404166cff53d9787138400e5c447138eaeebee69ec37d795d1f47077f0a23909329c142eeebd6f70e5ea862cf939c98d57a490f8c50529e13b2574915738aa919c517e8af00815aef619a2276b0e08f6a1709ce55c0f48fa6a68790ef7792b45cb63ccbb3c747886b35ede9b684afc3cef9dab45ce67931e16edfd2dca0ceca9167d9cda9c380f7eca9cd8c64c840609168caf3eeecffe4bf10cde9dcfb3f0c74b528a46f5e96cc1ae6e24f79fff8f8ee0b0b34c0c2e752054604b78fb2d13c737df40fdb4ea5073a1b4e1e0c266f84ccfa9d51e1dd6dedb84c5040f4f5aa8d78bc48a66258c608b2ba305ad53a56e364c1c98632e6de929e9f737a59c256dd8fd4bbbbb9bdef67c0fa2a3edf77c0e62f1a636fe335d05f935ee58e96d5d5c919b52e803f5301cb840a2b8abef02c100d6a47de8a989b13c93542790ca832a36d4921e9afbfbf23388aefdba13d992cb36c42291c6559083ff17130ba5ca3c6d6f45e3e5e8fd21eada2e763ba8cbe84d8012da01b1c50ae0066a373fb61f1ac150853a24eb1e7f65727b126d2774ac8ae701866281403bec6031b24ffe7f2439f2ce6c9f12e6ac932aaa32919e41b6ec64664bf67e237d4bb2ef7a82552540e3cf21ad12cda5da73e0dd9efedd329893a0f8fbee4db45eeb451e8d5821f49c9fef8d6cd60ea098efe56d151f9c191aa8a55a59ea1bc37c571f7382a103dae407feb4ea0d310fbf2a24e8c3d6f8d82c4e91e36f5bea555bdb73171f20eb472b63f737a7d12d2752143855aee2d69290d820bd5dff935dd18ce764100f1826f50975364252596e2fa577a6999ded14c61f96e2efd83623c9d6d3ceb0de856a955ef07d7642a9ecc2378ebf629dd723f51adc5232c880190ecaa27610c8ddaaa3ab6f5555f204e72b3f56bc2abb6fefa4d71a664def5b5e66c411188b38fa2fe6a474da48323a663a6844cfae49e59f3095ddae4fba8776e4db46ac7790fd288c7b0f0244271dff5e7a806b45739c0b4101cab9b01cce65392cab02b0909d21cb9fb06138abd759855c9de3f110e7c22e3dd46f2513bcf805c4a5f0891780894067bb97c5c218c1a326077efe69bab7c17e2b56773a2e01b0bffa7b2fa3b5b85b7311467d9d83008b07b3438a8773959267a2d0e1908cb0ea9083e3bcfa4115fce7dca091a272df1132c79bb04a4889b73adc1bdb00beed858fe8b5fcec8ace02354c7f7eb877ae8ba9c9729d47db96cab48661eb4a5dc7fc558861468651c354858f6e921a96aa10ecfda16f7f1c86a576514bcd3ae6097116020f5847c3e1a58c096e43538fca61966608d5c70cbe5ca5f9ecda4fead300e0ebffd4178445aa28800c150066af13d46f70b8991271279c2f70601ab21bc643f592a0badfc089ee637ee33574d590b52fbb2284437ede8e46372059ac6ed3cd5cbdd0951d3c3aefbd5058f8edbb557f0f01d9333b57ed44b8a496640441890daa824e3bde546658d287814e01bbe07bea796b593f22579d04772a4c6850eda58568cd323f4426cbdc1cf68f56bebacda078a23e29e32847b6e4e75310f3b89ff504a8d854d6185d06e5c7c2162bf43c4ecdbde82227278d2b0615ee7077d2cc126397b04a84bc6bf2fbb5f3750c95286011c6b6b1a4d359f31893d8c6374539696a61aca9571feaab92e00cebe4f4137fbd0ac0341c23be53438c7769bb265506d86ea5a49f06cc3bc7ae3488e53fcaa6798a362e21d25aea63b1e269602b6427af61546721847e40c0bc7814759c1db3086719fb521dce8c31e245e9ea294b127f7ae1bebc2d152cc37f9c211a17b55be304e192aaf801fe122070a794e8cc60538688e248cc7d3a5e909c5239392d0d244fdd29d1beb54e2bfd3b0316dd6e6b0a8db33ef6c99d4fd35e21b31a8f30780d6f3fcce857068dec541e8c80eb6891f5d94f87c84a6151c4caf1b817815d62772ecb3b08695dbe2af9557f36a9e02b475803651c204a6c37b3b617f79be40a4fb5027e8f4c548b88f5b0356341027ceccf8b0a5bbb54ce75240dc9bdd0f2495aae11da10ca831accff9c51f2326bad9832eb097a543497a7162c0c9fe8bcef37ac69d29962933e0aa6fc93e7e0bf864846edacffee9fbdcc9b3f7429f3d214c32f4d89140989d123a746c6ce6c4567a3a3ae97518c9642464408bece991572924bd6212f4f833e277c51bc2069c76aa23df7e845c25086f9e505328f31e95e4c989b4937d584ed5e701ba0fd9c3539161e7fd4127c9bb47bae85ffa02fc21b9ae56cae41c2caffb096cc2e49d77ce83652c09220b869ea93e01911578a65be0722e882e2638f023ad1c34a45c9137b28daa28974873d481188a8b0e8f417d5ef41158d4436e345f391bf18fcaebe57a723dfa56262f41111b47e16c278287a7e488eaa10a2d53147ef9df96d20f8c1a0f8189265d6f79be14d3a0186b8fb4bc7943f0b586e4494a41b964a4882fc8aaaeb32a8d58266efd5856d43d6d394b2823d7a05fbb1d3dc030f7387a09c21bd5442813a8c7fba6ae5ccfc046056599768ad1d10d01af6f02c6981fa393223fde4b14eb92b0509df00a26f5bc3d7a9b4e6e74e6598173ab1d3e9d68b67d2308a2f3f1e0647b7e0096566341558f30aae581f67a75368111a0e6ec0a9b2f311af655f609dec9e5ac1cf8d41df71d52bd328e79bda4e481483905060fa3d6cc68ab366d452590d25dc114805b68ced4b584b039152c807727f02bc38662af5d7134196b336f150da80dbb8923e74382219c3283682d6f44e4d6cb484259573a02ae586fd9360ac9816c6b8b3b138a6a046976a14339de26ccea014b9da4d8288c0a5b0387317527081570ea5fc608b63a3c82eafd1e58853cbd6b5e330463569ed162777bb5390dd5ca6ad96034d9298ecb68e16ec0a477e31b049e25b8c53237373527b55df4030c79c2abc13f960bb7a1b996e7f09a28d56274dfe4ce93902fedc9844aa003361e91ab23fd73df16313ba6d3e86424ef0b9c31a54bed3e4fdfb9b4b9711cd424f179a23dca1221765cbafd767eaa1d8eefcb944afe61ab056e783d174dbac271e7cc61149e54588661d6131a510de3fee8344f35682c48b01972231c1b8108c61e96b3c94ae138b36bbb1e7e8d2d4948b71fdaa3a0dd0fa5599ab1e448db62234149ec5a955c196a2d01dc57f1b4331548d774e8036a764286baaaea072dab333f92dac82a618d1b3e0ffe0fafd92a8629a028b411742883c4d2206ba6eda7af8ef7088c3e1f0188e1e9e6946002566b35f53333e642d373b8a73c38954065fe2422db4645ec26b1dfb7c4cb3e901f56fe25658d62b194b00b03f4b33a8dba730b3b636d37d6f5ca34378540ba3e8ab2db55379ca673d9c267435270a8245a6fbd8255d95df3b90fc13fd5edc2c78cab5d2604de51119e3c33fd968ae41e958e9f272235bf38cdc3644264f118ab9a17a3793afb7495bffe5d61088c3c79aa52e8b1ec103374b8a5f572812b06d889748f5b243c472dab7245904f576ecf7d4794b81547838aab02c3ef45b0f36ccac6b2983f30b2a8c172a58976d7f636b238cbf0021c8f9aa4004b3c495413151bb3c8d357cc4f2f066a3bc76ba7791703122492ee55aa2360854748217bdc67f8bc875e5aedb62a2291204eb0e5fe52a824b2de1910b255a2162907c259ba6be7c1035ada786472562b2be41cc4af4334dbef7a4f0518fed4a5b9b917b2fce1bf05c88f781ca46e8817022999b10b6ed9a6939736edf5fa3ac9b155db34b51ccfc51401e4738ed17f49ee06c493f7bc85bb72d884c1ec322d8024822d86934260a13a864f9632e36a21ccb57cdbfb5196f93cf094c079fb55a253ec38c99a115c809ea3b1c862fc03b95d75db83e4cb005680229a38a5a4dc1d5fe608d6197e5cb1bef8b5b3c0643b05fbb8ca0fab14007c3ccb57f7eb61f3be15903b593e592d2c7aaa23d63efc63a7afd9cc0334932ba8d46ae15e133db6e18cd2c51edf9112e064c679aa039d520c9e8f5555cc4125f94a5fa1cd32944088901f51b907c439600be60dca3f108c3cc0d75794a2c03779514f0d71aca96bd4525853233c1ff566ab70604b1e9043cab6bba81f49dca6d04a0a75d663e7f6a97b994d694a315937fd168cc60b8edb2921e15abcfd34a8a31e1f95f4910b8fc1d66440842aea260c9343314c193a1bb4d0647b25bd1dd004bed821640854a20001daa07f70bfb5aa5affbb1c6eca73668f3339b2a094af0e91dca254eeea99088c7ca82344ff7783bb3ff797787d710c72df43fd8e09c52aedcec87cbccfc19f2ed5a4bc3b24607b44e41fdf946db14ca3e5439a33a355e03d7133dffe98c35efd22ba072062247a24557395a4ea34b16de05bb7513e8c707f860a58f7590a2f5382a7787461252043d96cac91a382ec1bfa9b60df8004579e20f90a82773330360b3232591f3ed5784c45921455dcf622ef7cc7382fad4ea41dff2f746b06aea60a0b46d14e7fb8f7ac866d1a985988c0f4e8a748e891e8a3e4b4a5612d9f9184f308879eb275779b835d59d64310c46acc7eeb031de2fe7e42ca829fc20057ed15be65823f5d78288f9e54887c4204afea3d8d5779ccddac79515dcf2a62af3da8bd9e0e2561ec2a66c457db4be1d1a1e87eb21d0a0d5fd1e86d2974a47354e2f16019ab8831286353b924541baed36264e44c21ab2dc37d760a6acd48bfdc50c81d3539b31d410dd776a86cc7584dfc1be97eb809aa17ce7b93647902b9e0a01b8d7afbb032afe90f639e68566d83470a4eae1c1031e0440679ebdefac8d754c0df90f7db782079d4d0b20caf756a5c6bc5e1ffafca7b32e496a9ac06e389b6a16692e4f29f6b44f247983b8af9dc66ce34a210de373f7f85d9e0883a81ea84f7c9dad94c1f04a522d4d252d881783f49010f6766a8496f587bd9d563003237c18fcd85e9bcc4686f313ab72e77b6ba5b0473c4acb369a0625ea95f9eba5da07dd637ba39e8100c380d68efb380a8cd6f755b616d17380fbe52259fc25519d67802fc52828901ca573f97fe04e76ab413af43b0259b51d2813cd77f72464472b260c15af509e0077c2c41c78d04d0f220743b204799395019310d3e63c6f93df21cef8963fa92aef563eed399d4e53ac925b5f93b95657ea8b4291c425c94ea303162e7c20c66a2a9391edeb03c9027e4b8e45a671e5d5cb244f36974ccfb44d1573281931c9b5260464c1ee3cdbf6740727329013ee3557e385e7bf0a493d8a464fb066f0a48e36c78cba48f22edc4ca3cd77fbb171949df20bd83bca35cf6bb22d4a02976496ae65802a3fc4d667ae18b8bfb86407b93827ab8fa2f5dfb01f4f3eca2ee5232122db06890d0a2cf731ff3ce2ee41ae48b8dbd37cb4516cf608496d1a09ba8b6a0ac14276b3537ece5e499b7d21de64fd5ce70995b5c23660f96398552365f858f1cf4b45828e01033160f06e4839166ec5f31ab0b96ca9cc19c0b855cda7b8dcc629acf1cad84b4e5ddd0f967dd794748836518f4032fb93ca4baf3065230146fbdc8c696135dd371caabe5afeb64df88241ef95cdfcba51807c6eeaac6e88d2de1151f4265f75d0f698f60081532da50ccbbe5d84eea6ea97bd27c571f26841a4454893ce1b389e36fb7198392dae8679ccaad48fd1fd2aeb7f19be9b854dabea6f55e186236dc33d74e07c60d9683b73c8f1644d20953124c35e3b669c73d35f0b0f2e69563c324cfd6738eee292b7a0b2469566d1cf2a4c3cbe0baf4fe30555eb708d06803b3789d8c1a4666155d672d68b30aeec46412c76cb34fce2cad1351f88e21ba7d2d987b903f7fffd0bc47318077c907ed3fbcea00d3f10f7838196a3e45e083b8f98cb78bca77ecfefb77f2ee2c6ff71bda141f811a03301a471e4ae43e35c8dbcdd784eb78fd315406fcb30e6e0c66e98b06f2d637dfdae511e1845f745bda74ebd3bb3e34b21c2a096e7e325c65d9ed1a425af1d2bb01bd5eb70c86fdbb6fc3b35e85f15b7fb96bd1048e531a183e09e0899e8892ecc802601e8a5b0dfd17ef8c97df56dcddd21caffbdbaa5320c2027d02fdd4a2177c500492c23a0fa042a01aa68a1088bba8463bd8b9c4b55fd87340eb0e0c1560d1db3102315a873882b073c81183afd6d4f6ccdec9652255fd17c3809253d17ad12c9423305a4e1dfd47cdd4500ff45c39bbdce09ab0e88b9a4bbdcc4b16908eee0d0e04b6067e82e12c69505cc0e905e5c68c822dbb4cb5188b75a5864a94669cf69daa073981520d563773e7ce984495537b61cf1f563570d18967badf8539e8b73444c225884b7e690d1a5c3a6dae087a7ce1c30d1c8d914017d1671678b8e9303eabec5370b21f5583a3801f33685d4568896b1bbe713b7f9d6b7c50bf65b1349e3bfda0fcfa58f5fd261609813eba62874db40649badc5e6fad064cf50345378692db566dcac42b1d189264ccd640ffb825a31a9b51073f1fdcaa72bfeb6edd5b630d018e8abf84093a1467da1bb3b31067c82366a88240374e57a4aa67e017afbe6c1f32836e12aac273ca97af3d1f4b83f11da37f6c18fb66ba7c698d29fb3d67cfe0d1e28c9b717d3a094a2d053deeccd2754a5b6958cec0e839fd3de053ec30f62e9c3e02285f65d1d554d38e1a9ba07c16454c85774e341487c834559453e2b03d458f63ee6e40211ea62b9e9d0f30f8b9661c06cd65ab87f09a51fee521f36ed2438c678ec8c82e16868f750aa49dede74070a6b5d39854b5a09f0bca287c1802259338d4414a3a74d02314004bdcf2ea42ef3c8da434d544bdeb7e63473e1e74d5c76d9d9ecc23d4d3955b2889d652fda61ea107edd099babaa0dbb8c0f321cff59aa4e9c746991b56828b77687fa28276c0413cc53a0231f9c50b5ac671c6dafa6304419e017391dbc51188f44578f4cd3a8c1ea41e302dba642922af8f69a07ade7f9e7c192df0d90c0f79b32820ea579aaef8692f98a6fc075bd2dddad388084881d2b2aa4f5923f8eb01a8cb4cf70c48192830915eccc7c8843c4ab0220995a9565f63ffc50b363966aada2eafe2e22df4d3c083d4f97aba060fec38e4aa1c9f1cea030ecfec26e796b669b1a4aefa57ccb150327dbcd4b110fe338cc177a9260f5411b591049608d7e1188460adc73f9db4cb9a32b861892c0fc32546735a969632eac47b4b6f748d4bcd9253fbd848d83a0467db5fce20c8ee577cfb6d274c6605e0f9c6057526fcd02f77f053f6f79224929ec1545d5d21b92bb3e50443fe0df8f3969efd816acd0dbef98da7fc8a02b11f7ad20e642969c432a09a0dd9a0bfc81582c5adb68ef132e32336d4b6f3d5b1a5d6543a2b629df668e214c3f4c9d5c2e0c1cf19150d4f47553367e6937549f58ef221d67c86356c5ae804665f90b1d83f4114bb011c2bb67ab82a868757755fff778ddf46f651bc4f301643ae1585f4f266e19ee92ec13c1a4f9392d58dd5f829606d0195bf5a355cab4e2fce0a287e480b38ec4c85e2eac08e4f9100c83d5440dde45b27c2cfa33a3ba4a09ec204946804cd6c4c9b3b8e3aa2b3fc1f94939004eb79b3deb634e2a7f3093fc5182a890117a648c7f771f8595ce4b78cce9b3b75f95f6b1fb3ef1d64e11bb82ce30412c989ca9da26b5137d5c8f1fdb83e786d3d885fd748cd443020fdd5ae59e29812d5c358583fa824b1eb8a255825513a1724338263eea05cbcaf8a3a86befdb749f835d736909cc24cf5a2bc3c0d732c73ab0321f734eb55fee17528263cf2b74a353311bead99567a1c4ff807c0d64c0a7229b08e9b3cee4ea7a61a084be7244bae4a533239ed9fa19fd4c68c8605ff0ee631dbcd247580a08e07437878dd14ebb70bc1ef09290ec3bce316890c7ee0e772c783d857af727e6a33b977a4c1d548e5aba1d33d49d271862a6d96d6ac206960e857a4f17b0e692b1a9c7133bc95b30731dfbfd37cb278609a7a1d5b09154d9cf36c2deaf2da6f8bd443b4555037f30439dad46211ede6c33b7f9c27d672eb685d004dce885478dbc2a35fc5d86309b6f05bbf27587ac3a0d5f1b17698c25e846054997b95acccbe40f17e21effb8ffe27aeade285081426b0dc90d595f6180e337be818800fdddbce0ad2f6f31f50599f72a3db539d86f98eed9add7ccff6e346576d9cd037bae0b0a5b5c704de0792246216b2a50c6731ee2e91d56fd29dc78936bea07910857c98d62240ab919aa31366cf47fad7d33f08d44cf9aba956514711b2ba9a36d6e317703f2cdc7d9fbb5360b4d4ff987ecc25e74e707af4d48b6bfcce5cc101b93288de989b2698e14d411ac2cb546078b5f284bcbbfd6f43f332afc8c709541509118c66a3bcd4d68a1f601501352301268de024045e25f66a4fb99e03db36dc063ff551cc6046cf2f29bc11fce93aebc908f641008f4bb779e2feec54a29ea571c121af6a15ca6d97ee8b1d012b297b924a9865ea4dc13835cc549dbec57c3d582718e162c382d58e2e38a9e90f9d39b2ed0ba67a47dfc56a812d4d37e867320aa13e279a0f96430c55f08a9dbeff8f17d46208ee4a30c7d5bbe3737010d5be9eaf673c30cc3f9ed0adf0a7a447b2d477d7b6a28e75b615a184de664a2433fdb49ee585603b81a01fa5e8f24b01531a43abcd40774193df9283b4826f044c7001ba1deb4f6cd53e2fbdc75f0b1cec37bd2e32599ee9a11f36400e19878151f3ad12b4a469ca7475375d3eca164b5d765e2e667d049126eb610491844f269cd0c2626ed54a7d104035333cd2b35ffd7529934055d1d55c4f200373884187b3cc1ae30461bc733d5eff9be15648706d4233976fb19c4b2e823dfc3cefe3fc438d1d4df966fbc5707ec1bb025c4a2606a500ce6a8193cff04263a8d437fa9e034f496879469e2ea704208e647f2d4275960fba27524c746ff2f824a3353cb741716ecf7b288046fd9b3fd1d998cda4898a46fa82621b5e10cae65a0722d91fc22d77121dcf060f915950be738717475ad31ac327e53acd03fa3d382197fadbf5317058c3aacb2146376b5d0f243f40ddbdb3308f45e62481a6876281142a861ee7c2102b6fff79a5b566c85d7b60c9385b85704d497615b1ef99433b5d1cd9ca134a79730d7e9dbd951d01e592f4ce78017b01364a5c3f6e70fe7ac1050f89ac7c190b2d7518e3540fa5674a87633943971f1060c0eaad322980885bd31ee4c2aa5e015dad0fcc3cea65bfee697a929a0823f198bb52e5b1c7ff8b90faeeb839b6df2a857eb4d13f6ae0021ba5980a2710dc562846b997cffd5ac73c9a40f3f227c581c2f2d9093dc712022062e0fcac25352cd31f4feb171b6e43dcf89b08b3c8cc10b28d89ef6888d79c7382ee4b2298122490db99dce3528d0d2ffa1edc607a2003f5d0709f9cd97a13cd49f87d605759ce706ed6e92f80f53eef645806966f1ac28a205751515de5ee23b716b93aa9c962f24f1dc153cd3adaa9dd0ae448db1b8341271c72fd97e8fdb499f6e0e4da448596ab33c6e0f3ffa3d774177360e70ac945e96c0fb17fe57e575e435bee4bc85664d6b85800311a41268affa55861d2b32b6267696a83eac840ea7db06026fb431366812b48325bd8b78586791957f5e4bec831de8c623e56312ce4bb2ed8080e195044ffca485bb9a0cb4f3658c4267731e23d9cd2ca4da992e247c1cc608849349cabb44c9032201c24c2e4acc2e93a03398baef7861822a1187c6f113bf6fbc22cac4e6d8bab34cb309622bad20c27191cee52a7acdee7c77b80953e2abca7e493fc10f17a26a26756ebf3aa6ae8d547c0086dfbc76bc0b993c567a03d0c247b8aa744bf367ee5e3e343e4812f59d1e2a1110440e9349e4756e23bb8b0d6e51a3ebf4e04849bfa316e683fa62247c4e5b872510e10e737efb83e02be626dc9163cf5f497c17949127d7108cbd7a8223648dc55ce89e238161627ec872989e01c1403c9ac0ff10c044dea31d973720026b35ff078da4719886700fe0a0511a815cb8fbdd4678f0f7c26c41db3a2cb8a5a4705fe8baf786af1679304cd09261c147bb19172094ff675150ca695ed912d8a78ca318169700e9e1e0af686ceb24607ef39262e514f1a34d5196f8273b7c62dbf09a4931771ea34f59af8ba40b5aebbe0e7630a2cefdcb34f000c4808dfb33272d3e0c4753cd623e37475ba4cd3245535012152b71be5d6c73882816325fd389bba0e9d7a36ebcc4695c271d3248c554a205ca9f01196cc5c910890df767722af9a9e8725ce5aa5b466cad48bc7e0dc8fe0c57382a67c911fe3a2abb571ca040d3903f7d6aa57d61164501c02dd3849a718d2b4fdac8e7c042e211546950e19b39ad6eb82d0d37141e5d675402a457d9ef4afbe89da36718c3fee2e14fa619a7ed3aa7a187f48de7034f4ea3dae23d5a48b7e769ac420b9c11008a1a75a4d4886467b021291f362780f491884f251f2972c03e3c8ff411715710b12a6e1d1c2ed895f6159a2ccaf322169cdc2d7115e21093636fe1ff04e891e327f664d3da8f825321705e45c040d98b956a9a2d318ec226c18731a37d6ec8eaf35a611d3e06c93345d07f9f2ebc328b496aba86ab9840ce0cf72e6a15d9bd4b3c88013e8449b3f3e8607e0e04718c926d8566807e3f45c99ed55091080ca8f275f64fd194f6a0d2f8e4bea4398fdfd373d2c851accdf1fa22b6a451b2fab7932a9bcc7904b6dc6d6d0e94456c1b40fcc2a5ee443ef4514c31d6e127fa3d6c5cb835cd2af8575a812c8e1c296f59c42cd80cac26f0ca9543e22ff56ff643a6723e90a64359e47ff79404cf91212126e3332a6e2a8288a7667bfffae02d0287786b2ac0db039ee04bf8f66b58b8a6ba834380f35012db1830ba1c9698a9dcb76d5d59e50854f2099cce3fefd222211bb400c18bfc64079f3002ca4f78767e1f0da6a9ab55d9b9e7d5eef69285e9235197c7c48953d0b12d93127c2c13952bb9ce04e5d28aa28999bc28fbacd1405d70c4731585d624c75f008c77ecf3a0180975119264bbc12f855932acd7f8e7073a52b5b2a2789e89c1f4811cb9d175213562304e243e470f8843be1d66f8db2eb609746102beba6c3997f79fab2341bb0b864ab0093345f2fe9393cd27d8fbeb4f46f15e1fb9961dda3f02f6eb3b919355e060ffb9e6a55dbc02a350791263b3af2b3756a25c34a4c5a4d7260a48db7e2f051286e05d1bdacc569a2efa6dbb027463cc26fcfafb5194002f15ac7892e1c821984d0da043b76a185dcfc36b30c049c2f4064cece9ee79633ca138bbb0ddbb50d4a79e50e9a0f03340a0eced47c25317fd746089202f1a0eb3d3fbbd744702be0f7994f9300244c0cdb4e064916b7d9f2c7254f55d8ff85acec3ef1f6fe57e021efb748e0d64e86123196c5cb0a78dbed91b34e5cb3f41c009b6e57932fd77c00bda7ac4d56cd0d5f80ca49f2e2f3f022c11db30eafca8f50d890f2d29f086ddd04cd913ee6e2d08a751cb45f8c9ee2e3f45e684449b4d42298971ffa2a914d0c4f87263c101cb84fe80200fb8b4e045e38c4904bf8d901cfd27c9dd88cff49c91916d851c084f08d3c780320dc09ef328e0fe5b3ab3279a16951513c3e0e3a127ec532dcf08e7a668e1ff79009d7b989493a86e4ed8d91e2b6d5e3f23315e9174849b545cbdc39f8d8ecfcf3853af880796511924e91449980cd01a5a051fb6ea485ee77879404b51ce952346bbc2681d77981320866bf54034be6ae439833afdbe9ac9380993639aa49c247c394de70056d5f2872320871d790654969590f1c75fec5d502d926b2c151c763f11bfdbe6c0ce17bc40800e98d8c14b261c466b0e84a4f84e1f82396a4fa45b200c1f0a639d9e5a33d6933e676e00d7a51fbb893c2c3ce7c89ed3d275e7ea998f939d54a05ea7de057128dfb1ddf1e94a30313478deb067c415a3f164c210f8b5c1a94883db38d9b1b4cec676efcf05245624f2f9bc97f4270065d53c2c2d04d0d601cb1630e8a829012ffe1fa266c47a605b92c69cbc05f977ca290c5a7b4180e6785fcd1e434366eb9b25dc12a6ce49ba44a0f869721ab638122719b18f2a4c68a45ef645e6bed01d5f9f89ce41b878ef15e12b23d56537f2471814afd4cc8c3868ebb38e9d5abcb4042ac7e5beeaf50ab7aae0a1a8d59824ce4d6cfd93086e4bde2aab23f02b61a861fcc50d4025a89ec30cefdae4de10ac2ac66af111c46c8f70648db9c1b0998285d8f9b7cab5869039349a6ebce391f97b07d3ef6c43bb6383e1295327275b7f180e4fe4e07cb522c472f2b00348bdf11018b71271e2d31a4a98fd457a40c57100c2981a05d231e2428b42859d7a01a97678de2b928fb32685c09d268491c96c387e3c93957f0dcde357282c4724d2a7c7ad5ddcdf2603f32dad67b47bf0ccc8df7393f598c3be7e4687429e765be0633d4f9b448f88da514b45edb701fd6a394640ef0ff9c5ed6b295a6a361ba55e180944bac62ff51844b5f1e226127b310d5670e234cb024989d340006d3880ff4472370e228b6549331fed7b84970e3973f422e4fc74680afa719a13dfe5c8dd436025ac4d6ecce804eaccb87ce7014daf47ad5e6b5eb7038fbe3fb73c1827628d3e1f1b594af48590c2dabcfe0754df94844feba4da88562b3fe22f4dfe769bff1f7414b6e7a43556e68fa83c1c7a02bb3225193b1a546eabf9a0a2f98c05af96b9d47b96db7f9c266a3b97c9e9ebd0ac26e0959712082a412339edf5ae38b37063c55ad8e940fb19ddbe9f14ff7bf2032f219c755325615cff05d1df3b2e6841ee38018e7460c22af1e4bb7265a84576951c825dc7d68fa5ae4abd3fe0a85283eb6d7791af35a4b6c4f9a789babb731a7072958b3a4b556291c2b9ce9c7fd676aee47ba6162b5917c5754b19d614212c6b0514491f20974d41c0492d6ff7fd8c57450a40bdfc5824e331f9507f180aaa91441b64e8751a42ca7b65ab82c5edf3654c7347bc569d75f1b0bcf4fcf1fe0f0c45c3cd969839804eb5d3a8df4edc472fcf9d32fc23ec36ea35254ce70f01023b167b4e9f20227ea55b078f46f47baaa73fccbf6f0e6228c79c8bcbb60d8df43ecb99b48d85d6fd3f63bdc76c9a3ed164c09640073e3b716e192bd85ec288cad4a8d0fd212187a60a3d267b03a478800df1784637cc2beeedbd3e0924efdcc874b65c4a980ed0c593df8e54dfda7e389aec467557a172509f929f5c4ba864f212663f1231b04a581c635f9d71de08a6612440d0b290acd542c5a6be2d8336edc3d46b2ef991a5b0110db6ba8fb9b16447bbfa8d1ab18a277f44b601f9b363062312dd6cdf2657467f506bc573ab2683a5f5c70d2dda18613d2c75fee9bb6171f7af9c73947750b59984aa24e8042fa2922413c7534bcdee1c1cf61dea646c53cfeec426943338bcffc50c8d182d77a4044f3d7860279b6e765d7fb2f780ccce31ed276365de94518c2d402c7a31093844c2a2a7e1678e2d1498e5fdb0699ec8410e6f0f559a5cce6a1bab20bda0c59cc74316e6decf162fdd229cfc21bf9048e5aa1a71691ffeed6b46f1d79f997bb4311ec8a4ff8456b2c979d770a208632484dd2de85a4ee75fe5ff186d9781003e5a0e32d4dab4ab9928740f37ee3f45decc9366a46dbb052d9cafe775d9d90089bdc962e0b6764c5f15487022411f535f274f42d0d98e201b275b819dbc408e935725e655edbcede750817aa7cc396513e5daec2a82c851e72e6788da4d13c9d7a431d1e952c7807e7ffef2c2a20a80a467f630f2e0a33f35d8adcaab70a4257ad87febcae8c4823b6e14b1c06f8a49f8dd37949f5ea8dd7f47b896fe09620273aac7eb8d7d67fd05f743735c5ca165751ba6aaa2b31ce56e3c24eb884a556854dfc3f86e49835aee785e67b0d84bb96d77f10fdb81ccc584d1214de1eb01586ade10ac5fdc76feffb5a755ae65e6cd860438580463d1886e37503bdbe2f5ec72ae991a0b7a7123f9d362444c2532804a7b41f04458f5cdc0f82ce302343e02a27ebe81944be0e95d3e03b4711e1d7e773f573cc8e509c17756d48821f612d70dae5260282fb405a1bf4a040315f36085dcbb744b8606ad6122ea02f4ef78fb9259d1058df78ed9b0267efbee9957f74ccf90211576ba14e4f60d7b0f86d9cf8e2e0d8397dbbd60b2e775b67d62d1acdb7cfd3442b43067edc15a312e6360dd86ed1058","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
