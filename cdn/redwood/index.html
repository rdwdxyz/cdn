<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79110b188f2b21ddf8f1831c2633c770e16e3af6867df6a4ace8a51e6182601f5125030484bd46f4aa5233ba0b2f12e9a0a95feb306df549ae3a5872ddb35754eb4aca31486697cd53053465746ef15e11e0db508f6af6b422ac3a54fcb05c6a1eb96ef91069a58ced629f7ecb8a8bd46f3f181d9dd50eb75a812dc0abcc4a989554f8f7b986e2a2c6d6f1adb3b1b81541de7c77351073c9f3ad799f6f0e0b278589c4370c1dacef5d40d2b9fa442b7c1d66fd39c1ea79741f992f7e7d9d72c77bad2e8e47ea28af2e86e17a6813e631759c9a49031b6fd079fe96d0b639197b395704a8a70e7e5d2b9f26ca79565ed4198ad4497332c7bf1e6ca33f2d9aedd101d4687bf55c73e3e8d6b3981d6d6ca286136775e21eeb1c8395173844ebe55105e86e9ee38e446c2966b62d97d13d7208773b6f2ccbb6e1573ea6948da53f82ffb78bd47517d7b44883d3f55d175c5b3cd45784b3f11d9ff22bbe07ed4c56c033d23886eb07462360a56ec31a78312a3f4caa3fdb7db922613fdf1c18c90c5c19d64e84b0affa1326625b0fb9bf6cf1e2e501cd28df1fc19fa957e8ddafcea583fbb4ffe4b54c965a23791bceff5cd1e04172dc98fc3f811dc539ede11c208c8df1ce5480e961d00eb4bc467671c2c034e6c947dfba57865c8c37270f7fd1f3a1bfb4e0cdd69294ebf2b2972fa28059e163ce83f096a3d6666b06d11632610d6e79dec0b1b643bd95f4a3aaca099b614186ea851a4f32e8e7e1bac0de9ad5df9bd56b4cc6abc33c49a2ccb40f787663f22153811a400544035e1e141f09bcf8773360d33571724a5d688b1993d35984066ca88e3a5a2fb677b13496be8adeba4d137cd8f367a565d15a4ed85650376fa34d6493fdb54ba7df31d5d3db3e8795df87b3ab0a8d8c4ec931c9f081cffc60c3e880b102dc651b64ca38870f74e466e06f9a0fb4f0af4a24d7243cecd5b4fc715670d94256ca76aa8e9d7aa71f9ebbc5d7f2a77d0fc65a29a603f200980adb736ba7ca1def6b0a5b2abd3ee9b71f00189ff76f9b25058991bb0ade02171f7eede3ea33fd29c9f46d83bc55cf354661168e2db051acecea7d33055f8f17e2cc3792ba0b82935250c12724fe530f520b71ab2890a0cdc5c47c36bce2088a40558b3b9d767f75abd63982842f925d11d5afd613c30d9ede43d052bbaf018a10538f53aee88e72b53bed7c13bf582c0f46f2491b44daf93e8014eb89a84d929a9ce8e112168cc5670318fa9e41939e83e0e2aac9a4cb161ded83c61775c89741db32c1f18ef6921054c40ead14e76b8116c45fca732a729759b3e2f35b33052a5ce815d392a7b79abbd0a5cc3c505031625298b704ae45fed3a4f5e99cbb7a5018549f2a01c1763666cf1afeca55959343083c83e438ce7b6a8c60ae8b395ffac69d808c835754e04bdd9a72fa04f89b3dfb10aad513fe56722e9badad7e2d247448052766b1d6027f60a99f6593ed965595b363892f405a4da71ad0fd8db855680609a774bd4e5f527b6fff2faa1e5af722a0c58c24432689444d8ccd7494b5cd88fc0b5ab4dca35bcf9ec9267fcacaab23592126a2be1f4cd77b1330555f23dc3d8a621709851709c98c487ed6816a952f252d908e701e6cef7a204bcbbfb20e4ec512d651d37e3b09e26e586c5879a4e31ed7b4fcb2008a13f6b2b750d440d44aa4ee850f02e65f077ad8ced31e3d6942c44f84da5aa851cad80ec2cf01faa5fd80a99663e7452c2b031ea38a15e0cdaa1ddaaeef0afd21e754defe8d94a50065c5f254ac936023754aec19e9e2aa0398c9d1513143edf20b2c9ace614182e7c6fed3fb1f9c09dd5f6a1e6e403e93bc9dbaa657e7dfe1d29126cbb1d54b0f23ce98d12ec73f30f9e5b4f8d89b03de10ba96eb4efe618f5fe43f397f002c2dfca5626ced024cb571acff2eb770464bfec2515ddc85954b5bed6af6cd27018d8779d52b738e62048e1c8143c6fb40061839c39931659a1c973ddacc259f36493ae2535cf93cc7d45e9158a7c20d142f5af9044f01e7a251bc68c5b1536dbd5028c4bc3cf2c158eaecca0f3af23cd2b28cae6b2450bdca0d2a5cf4f98380d32e7a64586b0f761a7e20ace87e253d8d84ed36d227f1e544c97ee37b3fd12180e55c02971c04ead2af45f2db367474d861d56b7d09c290b83e077bf3d00d2cea1414b4b07a280326bc3b7e8a6ee7245d01f67115429fe70fdd4f0c787c07b83e8aa61fa11b211c5837c9954105e70a9c16fcd3a087c55733afba3c0fc39dfc902dcb317acee20d88fa4eb6251f49b0da7f548145118146be9f0636bdfd52561fa098ea55779bdd23dde7f1f482af5c15b48f6c04d67266ae4af4e0fa1fa9d9b9c5f49ca59d97048f45a7b8ee3ff1f2e976926c7d47fa01a7f2b526a3fb1634fdb4372f2b47766407158977e0e26438709ca590293dccc55106cc961e5b03eee557d2c7b0eab8807389787b6fe42d95bfbbc005cf049ce260bcdc8e276bb7bd7650ba31abadc34e213da60d936fb008e5de515c05396a704d95c3f254a33aaae4bf34dbe449953aa2c1fb60ddf693fda0eb0e15b426d50652e0b5f67a1e8207fc5762c11a20842e7184df2968e6ced40b4bea4d4dbae29ad8df9b5a53d8465915b6efae4742bb055bec4e98e2192cb54e990dc51fcd9f4672831af6d90a4769055d6465798223d2cd2769cdc51b0d9636b964560cc6a346f60bfe3b37e20c67dfacdb5eea0516ff59b97c259a86eeff5f614e29332ba929a15dd9403f3c2f07e0ffa644c8f7ebacf740a37261a14aca4f9622ab3db111e19e8f4a8d1ecbf3f51b8696a0d464de24430280e2e82d3c5aced232db1b53b7a36ee52362f4626943df6590eddd44ee8bacaa6c0fb604d465b1025699c49ca3e60809d62639ca70019dbbc770ede6622eae4a2d7b4005f0095f523c9d41f16ea069180d29b3693f8248222731dd6d0fa9d908d8689fee8efdaa5013262ea4d5e3e056bc018cde2fb9cc3d040e28731d3ddc66db37f9bcb588ae2f98f4f2854659d0a79add8e6ef121d83618e376ed27bcc2c05532cfb73432944a14f94570377547dda51a30657ef42662e576323c84424fcd32114cd6ab35ff6491d1a2496626c1e923f07a2eb9e353e129a09aa761162391e8fffed15ffa50e83033ce446dd3590f403744578d6c94d07748f54824e7861df7c32a221fb96f241b6ff634d665fd073ad6989fef07f4a886997f6d5223771bbd05d8e9ccee31591fb6e0538ec8a1a7732ef247d182f3c461c550c1c2c765442459a26223447a7aae6f7263d214ac82684d1529fac8060ccf1658dffc08ae03a65eeb1499599060af102533c01950901a47a95d852c085c71a7fb9527535151b6aafdb7efc4ffeb70e74c010203e361d269a067f5c824c25c819da5f678f7f625e4f04906f59d4be89cb6a13e52e01e2a17c7703048b87583cbbe8aadfa68104913dad8b3239daf6a519652386f23ccd726e7f58d21d02df61df3e00c9186f84afe76227c2f109ff37e4b39b0bc1c6245029ec33602ee22b2a6452685ead63c13c0a4bfd287747189814de945c1a065470b211e960e6039a7b7cde26abd66c4dcf03e71adc6ab46b491e7834d40122b76270a827efcaf1c5730308e21b5184037d3bf8d7fd5daaee805549b69082fa5a5148ca8dd256e4beefe686e40d07992b1f147635af2515b4b2dc3ca54710ac25ab56964e3a2210770d2d18c2cfba84c952c7f26f04dce5a61a9d8f6491c429f24374e9831f7f380940c2abda3e05fbe7bcaf8eb38da5715fb217baaf7b5aae0ca4a0ce975e8071f4619f1963b8cf84c45e66a309cdb2da26f54f0969b5908f6e64281f1e3e1cf00684c5d18d65c33865172b5fbdecdd12b4716f4b3dc93479f167890c5f503abacd7f1a0e58773ff4027faee7bbf30989637c895d505365fb68d3ca013343441ea04cdab3943c5b2973d5562e0b3d41c1e2c2e2c671b20f159b8b58e25dc6485ea9dd4bddc6a5a45b7c286f5b5505ba8eec44b18a3eea97a369df7a4b99fc6e7baa37463aef094ea99e7e02bc71ec414b9c62403042bd098ac85dd5851375924ed27b79e3c8de8165c5b3fb5f693950c77e7b62ccfae7e195782f0efa1461d1272ddd0176a4b6ab7686ecca323f7fed3bd050d9c655645ea41ea224a66f03d321c6b7a9afc4c85145c202c003826acc7b1b5290aa230426edc53e287d4a30613cfed863d0cd380219f26af55f1bad0305e00ab1cf11259fad7dad15d275abefbe882f72704ef8d57509d1a8d0ab4b8b9ccf56c8f50fbd32618812ce2268b57db169ec65ff36184b0f89c61fa7e0921a91194ab05b700ccfc0135963864a1d5124d61b74c9fe91b10b4d7f8c517db0f2eccef585c761b9702f375b4fbaf42602b785caca04b6352e36146143f7a7af2395be5a5e90301cbee6c47a45e2d749dd72b4927facc4ef235ff007c0fbdc1f217e2923e1d20d799ee102d7a2967eed110f36927c4c080315a4453539d3007a5322f057683c7fe00c9c4d6f5062c33d6323e45b073787f6604d0461f1b1896236a1af325803ae9350de8414de503ea1e4f413a0039c28d33d3d9de74573a226c44c88d6d5776472c4b3d9c09cd52d942da18d918fe809e82382a9b770966670891d3d16db6242bd32f95856d25d76927918ac004b1aade9491678032b874b75ec4ad34445220cc76349358a55d4caf758a8a48ecedaedab855f63b107d75a624d5f72d52693616b3c7f0840fd9c2bf3f0178441debb93e6e3defd9ae17726bbbd6a5ec0c80bfe5f4cca76543e0a3ba52e6704149025ec03eb74c7240a2049e6211364b94d8a3e0c23a7ec20207817af5f23cb48e9964d8528b7bd3e4c66ef1e8e7eb346bace86e2325cead4dbe0e4d505e003a892bb48e3c49dec53e9da8af755e2decfda851088eefb538ad777aa8cf4af4c536a00a2337c1d90d781a0bfab66733a71b24aef47d41f7e354859393e2a83723f519da4309d0922cf924e0515cb701ae60e0619c4bc2307456dc44972bc656a613f29d6eaa35de80260134cd50a29bb755c740f7a19208b21243af34f15ee7a316ec189c3a82eaaf4e21ea7b3cb57a4c5defcfb44d6fa6e393cb66c9071fbd28ce38f295ff86fe0104bbcc442e0ccd7d9f356da9f3623182e114ad7a9c93ed0d8b7f02105aeb91bf424a7b4fc399d6af7170443214f6cf78bb6a3bddbbe5aaa7146077d0bd9fa516b099f679d32e1f72e96b8a13ae59d8119a8d5237dcffe9492b833e2f7c015bec1cb621082dc55d001649251140a3d441d60baf668f035c83d7f693d17e247e1f00a9b998525630118c08c2a53b3b899f02d66cfd4339986ce343cd3c98dad05478bac12f3f2166b5b1b3d58e575bd6dfa424d34a3061629f17da21e7a17f08f39697734161005e01140870517d90593bbb41695208e076918c1da67b68ef880ff6c0f93cbdebe9f202bb0b702b390758c26ada6c9ac79ebe4277a0e26cd76814ad45d895cbdf3864f9de868fea48eea016bb69c9e30ce59849f6e74b2c160f4f4fc4fa8b651f323d8c126c2ecae3ce1772a7a5cc474279a5b916a46dc6c645c9d94b0751a464baf4584721d1299075281f95d69baf3d849c0f27ac0f59bd29f887a18a2cc1c730b00172ccb453f3d524d4115fe0bc7244ab56ae1713a882d820adabc13eb7787b7370153aa017804d0b2ddb85b8aea5022a9afce9dd167897fc772e806ac918a52e6709b1647576b93ff994df28ce9e20da4df639289a248b7409f54d2789a43881106e0d4dc263e843ceb90d5d687823db7bec33e4ffb4b4d4798c677671e8d107aa1c3391aba27df018bd1984f0f3dafbd7ad7306313b5dd8306a0af8fef6e04dcd28b1c7de7df100202bb39265e786fe0c7e682fe9fde48582bde816572ab51386e1143b4dfe268c9176741bbc8c644b822f2e27a0274539d86e4bdf4a724304cacd731f256ba734edfebc54a23d07ee4b3dd53ed865a763a1f2fb4be1ae2bc4125244a18cc9769b8fac13d610a26137c1abd6c47708cb6766f3eb99776219040351952042b78f0f1eb0493e40b06a65869bbd266536f9ca78d60aa32e158747dbfb4c1d96afe6e63b26d658a43387bf851d03099ce618b6ce0ff6d0daf41ae47c5ca5dafc1d189d010f44eb4e5a2d26bda5c014bd7e59ccde9f38632e44b6268722afce1a7b1fd139207b7f4498c717b9b0df82900fb6c1e210aacb583cd405795b8603344120b9ee553632ed246aa9c8a013af2f7402073e99124b298e6a5d9601af729018889d6457fff19da119d2fa3b643342a3a81c32b8943e546c391954237a0abd3d8e5230a2e2e8f5e01bc610d335944cb8840b611b2152bace8314f658cf83146ea4dd9f527aabb78b40837fdd166454b45a0862b244e63c42e222fe0575c549efe4b57eb50c665e46438f98c3e17b96b4ab48b022f59daeec777bb5380f4b7457ed6284398bd684ec257de0f63dd6904414472d0eac9a3cfb07e8673e9e953484ebe0027321ddf4f8e37cf4bdaf84cb694eada2a933ef085637ef8da8d08af0654f2f5cf9e10f0418874d39db4d12d6a8bd5271aca6f7074637223f09dcf735d60dda56f09281081d17d22070b397a63675511128fefe1e6af30c10d71cddb79bc37cb47a508dac96d577adefc638ea980ed6590e90377b252d4fecad3ace21d2138a80074790c772073870b439f60a289dea6bf808587c871b28ea51c4d4b78ca7b6e883179dc09de91330dd0595c184220615ef98094bd77b4660d049c8b2be44e47e9ff546dd5cceeb0cfa2ca17a77c9425bf8954837bfc7006013d19a61225563190dcaa23883e492069db1183ca54f996328c74a3e66124af63d4e3f104aca783bba1a135eeca2566926fa5c642a88f99b145b7994da26f8407ba3491d137dfd29597639eae1e416c0598e4d2c41c21e49d9ed8ef9a11cb24d949885b3a69a0f9ebfb734cf0cd6ec4f5cbb309ad621838f41f3f2a8c3f6e804e8a74ea4f26ba318ba69095c8499f4ee440ee99fdeca6e0ca12ef902dda94dbc38890f1fcf481ff4d7627e551bb51c03ac45050709e5d53367dd1c5b7b99ecc2482b0dcad3d53d8d11fba4225580402fed9cebadcd28bbc6161c342c9597cb3fcda31d4142f141568910bf6d9bf4a056abdcc25accbc46da8d9dde7cad58884e056a746a39d12b0798a09f0df18eb9cdcf41f3247713b8aa7ef4e9915040d57b61d04cec466591bfd71dab17bb651f0f59cfd1b216f4f4ad4c79d1c7f14fa098e9027238b1ddb221a63ff568a7460ef99b969ab5c23d9da000567a9633962272aac4ef97e7339e4029b8775d745a0d3cf1c8fdc87e096835126ba48d7a27ea6e10136733cc6a6c348cdc8b61a179f0d958bb942ddbcd0781e2d2e8b81a756454f1dc579c8a0ccc39280f84f923395e2331b750140ece04ba137d4612553d442b7b4101c39e5ada0a62e273e33a21a0dbdb9b1ea2d3f87ddbaeee67e3d3518b9e85f1e6d706b56c43b880e5c64676f38c9817256dae004756c62b4332461ac00756d48d9e5c577feda8c6910b66e76585c4633447186978563aa91866c9ee44e12afd9b142d1054505bf7358294b938c930744a48fadacdf584a4fde6635f957a9332d0b29dd50f0163dbd563838072f81298b557768f9b342fd522e92150ba0274150e7653f0b2f279429dbe0bb5df295077e7342b161fbbfdd32d1f7ef44e6389ebac78221335059dddb51bcc98a47a8df5aadf24d26868218bd0919b04f07337c781ae25c0a3ee78e121eacb70b5fe501b39f1b03cfe70cb0d119731bbd886d9a86b9ea8d228ba52541a5578d28fd9b054ac7009ef3dc7af4b88f8287a4a3e5fcc06253291c63b85cb4806e43758cd31f0493ad9da743a32490806e5c4eb618266a67dac9f9b46a8104a29f4dadf4ff7d0fd6f5206b306a6f6f9278df08880bd3b742c62be39917d9fe4e17cf1f05194f2444021a6b07818bf02a247fb0f6116a587bcb48b037635186c7e30f0cee2bdb4e82e01bb607447002c7a269463b7383270c481322020e218e8b9d6bebe926c2f3b50225181e25887b504b8a82a105f7327b407acd3ea48425f341d2c7efbe5b6d270adf1cd6eda7d0fc35e5adb39325b224522b41f6565b6ad91f30f68f11973af766c8c1cabe911155743075962aef203d4d1aa97bafe8eca966f3789eb5634b9b843ad843ea75d38f88e44652da2e6aa32877b5f5a15c137f4e6a1dd7b63e0372e27ba8496a93c045ce716b81164c27d4f91aab66d8f715640fd3010b242c581118ae45242dacd48f29c86453be74dc98cb6ad3b590905de8b6103b78f7aa62a363adc64cc0c197003cd32c8e3a4c41400dcd9ec51f4820f78edcdd722c7b24c2e258574ca64724cd7ad4999c41fd067307297c44f49be82f472bebd30c86dcc68cc1aa89c1735d9aaa9216f6e22a9942c4b377ba78b6401a77b5913429510e655b1c76888785872c20f7aa989ab08f80d690233f50ef7f3169b1f7b8cca2af1d76d705438fbdb95fac83c7de6c5295165f49573b9472be34290c6618592867c88b8bc49215a5f7abeb5624a02f6ec4a07b608d1e603554233c47e670024172fb3c3dd1c7b2c9b74d28c7f1b41c8f0b4096a07b42d14a5ad8a9d96d385f70722ab1984ca85872a6648f015c2e8ee6fcf5db7553c10780067bc362810cf3909fcc6ccc6a35e0e5a2513d3ca45934fa7d80f1631c0719d9416a1a731d0b58bec40f1581218f39c8d4acc69ab567e88a62ccc7840e7d35aaaf975db13484a80455156541daba8cc997bd51921839f2ba74d01b8606139aad1649487a122a76907550e231f7d3fdfc3aa73a747384853e70cd067f7aed7678cf5dcaf8c44e2c077b721626b8755f010fcb7f171e5c4633cb940bf855e0d4192ca5c9374fee86585bd27897ae5344b6ca247c3dfac0fafe24b7cc0407a5a21722512f2bd054f52ad613b0ea8d1ba1a9adbcb0dbe96592fd4ddda6fdd52a3ab225e0133a31587e9c0cd5779d487b2ab630fad890c29256613bc74cbd335108a74377385724677363b16fc61d81fd2a722a23c71ae0f5afe72563f77733f6d0d6eb8b8914ca380dc3c30f09075b904cf3dc187ccb7821b55ba2813d71b2b680bd47c7a4809cb78309d79063bc70ecf61b3d35f43f21b9e43555f6ca2da31c1094de170d515c0699a580e59bde96af08706f1f3085705ed16c581b315bec208c1e1170f5ee14553010f1061ab17b4d1189790dd5719918a2cb850d6b8829713dd9b3e59ef2c31e36b29445cca5dccbb436c8370f3883f21f12a9c6c247c34e476bb7abf204f1ec7a644caf7fb31b157a670e503572b4af449e1519c6363b5653cb483f75a817cb3db4b84161b4dde2be6e43844a2fc46076be183c648e15413505a42cceb4f29f250f7ad65c1f81523427c7d7c7b7255b9012418ff30d866ce568fd3884c42810eef55fd20ef586ab196292f8abda352d9814a39dc41d7c6b0afa0b63e5b00e55e6079bdef16d7299103af87c96d8152f06e5cab75b93af8204bae3505e517678034daf554aae72e8fe27a96888a2754185df0e0f330e57261621747cf434394b11bb5880cb779fd16998ca18c1298f7377fbb384ce93d2e88e494e2e3bd0fd5865eddb3fc843e54a205078cca467d332f528f8fd44cacde93e2958f454bab654834804edc1b264ece194b7faee0de0440586dd33d09dcd8cd32cf423054c09f3b5901491dfbe5a061470726972d2665b33898f724eb82b2b9675f384021eeb4d414f620df4ad79d4d4df629faaeed66e83baf6d71e29d7fc9c63140d03dc27bcbc2e5bc616eabff9f3572f7f1493a41bd94fd59d96ec6ce55ce7d08715cc0c6742228e6b285dc70d62c858acae079bf0845d142e780c51563b3ec50ea73f9725519d7e3513f14ee1267ef1e27f0afd813e3f649428792d9f866c06f3a7eb01932283412d17437a25c73fedd8dd23f3797da582b50f289d9170149969ed1210c5b07ce9e7ff6a229aa1c6e9c3857f7741b643b614416cd86635d48d0b767fa2088f42e2302b8cd721af2fafc366af28076181761a99fcb0b0a06f9898ff055e26ec849c9dae92cdf18e60c14f3f826bdfe21521b8eaaae34855ce71b65aa63550c053409170aed9498e20472d8f104f70f32c85b6a27f68dda855631f7ecd56699e6f447ae7607651fd8812c3cd81fbabdd3e0ecdf36b7b217bb859a73290cda72bd4d44b5f4e6c4878d02cd52ea9553ccda8a4635818b69913dd52daf3e529050e595da8fd35a4100461fdca67eae15a27ffdcb21bf6cae251518126268ad144c8f4f949947c12dcfdf6ddd517854939a9a55fb1832766e1b3a286946ba5291a73f86fadfb8a2d1851beb34eea8258fd859e0e04d6ba170d6fe258cef7eb404ea32cc307036cf60290381d6be6e2a92fde677d7dabf2d9e39d1709762b0ec334541ba3c92180c58fdb4de1d1f5851e60e968bb85b40e5496d55552f75ea81da4801ad2572adffdd714bf12c242f29df3f9b490d93922402291fb1a6ad9a71bdce5e306edc5f71f54bbedd1dfcb48c5977d696287b52d17d3b1fce04ff1c8b802b404fcd4979ab800d846b2e2ba7fb784894dd421739b8303dfa0ad68df0444dac5d2a360802746c0f2e9f7b3d7fae664ce4926bdb8239f46e5a75d7dbe772904cbf9d059f44bddedbd68f6194c1567612c143078a16ac9c4aa181d75358f65f23dbb7a0bd131589b7b05f29379b656f193ad94159f2f0a8fcf5d5c2041a57671a53205a3f159a93deb18851e3c3f540db06945a28f5625eca531d82e1b012a3ecd56c2f3601c1035df568610eefbaa7573e8062438597604cc3a839a2cf07bc6a998a3e5e835ea792386e92d9d09ebe39e657d02ed694783277320827ed4b5ed9bd2648a63e72cf4f9ece27818ca3573217479a3bc2f9c7263c19ed5cdc4fbced762f5839209e16ca76c31a219060a40e291f35337a6802b17fa43349638abef96d24ff688708fc12ced45f27a93451c063b3b466d84a0d6c8d0e4e276883e252b9e109dc0995a9c5378c6a28392416a2fa7951686ae5215f2fa5f19832d9cbb53a67ca342c6034aac85361b331fcd6b976ea451489f3d355404793a120bdc552c1be4fa8c2d022ad1df41fdc461b8cf3f468e72b06c989dd761ff4848062e90769ff89d5c799b86009d337e489f488db0c16d4ef1930df815a7a3f533717d19f6119d2feca297b46bd45da4c2a5b1677d7610dc558baf0f9f5f8fe59a426188f58ec820a09044a61d79b55f0791ed13643427280f1f47abae8617c33e223fed06178ff513f488d66a6c6b4e8a5678c87d036fb32932cd38104d4bbe5367a70f833bf88aebcc9c5d9bb43968319e9754793801afed71572d2148624b3a6385b5f7702eb8d3ef1d2c76d504698588fd4c644d7867bad724489236815c37b1cdd9090402e2dcf3b08f0f71a6c570827c36f0b792a00f1279cba00195954f49774397b4d19eba2af1d609b3ccce926dd1bb8305b208ff9b7e45adedac18eb4e57f5afb39952381d5da759efd8122809bc0a5cb368d96e54602f87cfd3f438a861d887eed1032e40d6e49258f5baad8800fef3506bc3e899c9ad003dffe357134a083596f8b63c9231578a073b5c484f3f223a258527d279f3d1979c0950459119139139c181624580911a35caf009ae66a722a65aa4797f39029c67eb260a83dbff1103890af395f010bf3fc187ac96c200aec919bfdd0ae1de3f1b3f89b18c89775f89c2200ce106b9b2037df302471e57b085d89cfc45c5448044c961dbc225f6aa442cc57263b6212f7a9bde0548bd53550c2dfa749e32bf76d86513b927950d15751dbd6af3f6a1517e181be3736b7ff28d045874d97d8ec708d459ef90568e1d31c7489be75622fc2b971673c96c39b55f913d411cd106c15e9f2c081a4d98b44507f203c9089b96a832d1df9fd8b88be96bdb5b469a62b57a1ca2c614477f6d74b30f32f6e520c7bc8a18abf15a0ab318ef76eea93a240b5c0086a969dca4ee5f0aa7c34cd8f2ef83a49122c939c04295e3ee5efb8f28ff60c683e76a7d2e5e2e51ebf3faff3d4cbe8a9aa0425cbf564bfa3d8d2e82309a8162812b6aeadbf3a8da969810f201c0268ca2b86b853a2d8472262acc29d400fafe728487f78e0a1947dccc080a926109056974abfaccf20ec630cea6e49ab7c99714d0b366b6009a44218b53620f727b00d8455ffa01065bf3cc683c25963acbb54554078d307d79fc6264bebdceeb361c58e1b9fe9380e18a17460f686370e70ab3a7bebf9eae56928141501ebe5add02e5407353c70289caaf445a36cac9c29f0f6b38ff12cc487ba0eb9a2632fc014d284099a1fe61a17db30b1c5db3219218877dd84d643a43ced8b2467b8099edbdacf936aae9d41b51a7fae1e4337b6b648d1c669673e9d8d1f3d58c6002b78360fd154f62e20304d6e1c445bc97bc1deb1486332fb2f6c7483a9cafc12c0405a634993a747530fbcb59ebe4e214af455ad95d54fc5259f81f8d9e0ba75e31add201659cd195c2516d12d3ccd7486c98968ea728f22b10a921d62fd854193ca55888b7b36cea21e6b288396f7adcbfa1a1161a656b2a61562e9e5e70a6d0566bfa0409f5adbe546d8597dfd3b3df6ded24339ea7ab481e95c23105b0bccff507dde0f8397a16832fac4d8a267f7dc7037896906a4495d2854521d9e36b6bf2ad4bdc083efc30a19983a67abb7c7581bb6faabee96cf89aa2cc1bccbb819a9d62078534bfad9ea7f5f13fe6e55c0ff7ff86a16bc61d3ebf0c03fccfa4bcfb95e31d9e02e5e960ea95238a44e9ea4ac8acb136b3f25349876a1391515f2f13aa625a3a3d491a696b0ef66d417806881fabc053d25507fbf18afc3e2f9d16d38319c988e8cfbb432e659bf0676454a63eaefc112ddcac14406faf4f5a397b6814dd0f4136d568eeebb41fe15b92fd7d78b3f3fb578e61b4343c5e7dcaa2dc420013cb105e6da9224f89c1d766c2bbe499ef2c768393e058f189ac4b184cb151903f4bed8b1381ae681a33c2b22e4bec1b536f53ba4a9f4c6f30b2e82a47889d1e7e8990fed1279c0ad38072f58646820a0b9f37e57eb784991ee8c1512c180df854fabccb7abe541c30fe69ef55c5a297ef1d7455f9b6fbd67f2b8f2e64f08fd63196c2075d6bb1becf17365b3afb21d00062ae13164bc7a5ce46762b75adbc937202aa6e08fe9524d903fb3e89255827d65b351bf7281e15960bb18dc0f817e7f4befa6ea8045bcdaad7e888139d4dbb4659fcdb91fa8ebf0ba49bf2c0fc3af727b5f75711b8c2fcea0e9b36deaf8343ff4b01ead22e2ad6a87eb9dac5ef58aa325d0be1d4a460e241aa4d856e1194e69573184bcc0568a01eafca20f9a3a2498b4aad8dc2b77d2f8bc5847996d233328f458a5ba544ac0595b1acb214316777f5fa5e07b2a887414279d84c9a247bc896def8d5dff719b26ab3de4261b35f3b516af22253f5dac0a4658347c7946c5650a31014afd3728f349a67ec45e034844f7f83b4f94787770a8d8905ed36a901fa8fd387da3e2ceb28e3c62685e34cb898bd71312a394c5aa4704379de7550882ba86260ffe9758346b4ccec8233477362ffd0706f2b10a4072cd4b7cfc39b6414ca3c62ecc298af4056abcc4c596270a90e01a9677fed4182e2784304d6b19f24bd0c156599ac96fb0001d7eaf3a9553c55092d82b7d4f7e176cd942f84d2b3e5d8837100a3d4c69d43ecace498d9b25d8a9a5de2a8ab39e1d7d5c37d0c3b4ba7560932fb59b89949108736f90ebce39eb3b6c014c34741b8b21d706a47f5deb6d49a672313c48d38c5b5067c620e0289dccbd722ea6ca9d4a37bbb4ff0580adc59a84a94a76e3e03736171f4b00cc2165b9b799ddf4a6ae72699e4b1621b840b2f8b2f731cf17d64d2b2eb41f399a3ec0fd3b9e515cf61143c37ee462fc95d1d5110373b3eb849834abb181a456ccc630d807b604e12b3cc19871a72f866b312b5d128404247547cb18f1e3f69198ec90eb9c06b34ce7ca95e348a6e0b043dff2e87ef9e0486347dd34f60dcd9e7442346b5dd048ec55e55667e338e28ca6728f296cb87234b41b53704b00f0d72895c7d727bceb409a9eeaaab14d74f8db52ea8178a9581e2f30b26fc132816238a7975d5816210581dcabbe0a8d60717c453989baee54b25866d7f386c1eaea3c21a612b07d19eb1e5840032525100d9e81b366cf5ace9f1f6a7481cc1f588d7dd031e716e9b9f5f29a6c8bbefde74bfeff6e8a3a64b02931a9c236c531d7e009ffccd650a6105fbdb78467c72917c6ad2735b7010108ae2e29252dfae956563f6da294d164fc67a86d2256b044592942befae57e70ec9de80eaa3134a713a7f6b156bea3976cd7b774790f3f7f4fbb8f0acdde8ad347e4d1e61768fcb9b959ce2a419ee7dd05a1763780a5926ec9abe085e5047a56342bb0cd8257c97586672c647d84d43959efdfd5d1d65236f72ae89135d6c6f32d2e01915ad214bb8fd093275a7d61a386ebd7916fe4a8961c92670207f7124aed76e498e3c8bbff2dee5b940e5f7c40ece059a227bea5989d5f2e2603c661f2ed20e52627788b5c1688c37df421748d2e31aff46970164ec5bd92be8cae21300a482800f5a3621b1552314cc8002c129aca43f65e94957141b21371c50ec8486d68979a9c77002f8fe197f13d6576552ebd222ec07aec45ba753c2fb68ea9fcd8c52a322473167d16bbe1f3b20875890e0c787970594a4439958148754d5ceee1150d0d5bdd78f54f443bedfbaa4e5e81b99944b95c4c936efb8db8890c53757b9fbc134b3ddfa34c248a2032108cf8a1f1da8e7a3cdf0a4ebfaed9ad99b20cc7eb2f5d39e65b3a044ced3929673fb5bf9ccd71d4c528cc91a23367c0f362e502fd1ae36dcfc8580b1872e6ea06b8dd97fb17ea6b253188e8b71bb42e82a6e58996100025e5e3a81f3a43f3c443798155957ce3b2ca4071934bb94b0702235017e09e54ad80e1295178c5c4d00f811b0412794fdf3f9172623328ef8eacaba32db7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
