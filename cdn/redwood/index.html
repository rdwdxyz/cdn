<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12a5e32a622abc48ebb505c83c3e08fc0495779e852bf0a6c7596a8a43fa84c85c88aa6c1f37b6cc719c1ba037386c3914a4fed4a1ef59203b00a4d8750114e8b722d1e1bc64e784d79cabeab24a34d5d11dd0f85862985f64a821317b4d9b92d386f43ee0a001eb2bbf1c092508fa0a559a0058bf5b55a08f2c1491bd49b051fd472c85de1559a099876dbf9aabfa72a3d449d8eef13bd3d6fd24099d41e3cb022e0cbf76fb28b198a43d2290ae2172ae3c6279b38f8b63c34699c4e4da74b08ecd65106b7279f9bc9f52e15af93d4660ca92f5ac1264f43f9195e53aff50f31c57663f6f097e4417af0cde520603792ebf7fc01a1e74520388f1a6dfce5f14ba5ad9d239fa89c3cfb0f0b8f977df948bff9b64b4afec257bb65dee65bdbc417499912627ac7f1f1ad85441fd09fa1ea51744f749ab5d38744c99cbf06291662890dda65458329d67017f11dfffc290ec6b4bc05bde6c6b48727e11cd53d3efcd2ea3dbc85fd0635b83e32a8dcfa73dcdaa3e3bde9a377046ee25683e4aad436cdf42da87d7c389b24a0bd83cd4cba9172706f5b57b78323a1d93f08528dbd432c3ad7803402e3bbe2ac29d9d52ce66522781a4a52f1134d9c95b54b3df363c5fb835eb85d562d362a6e5eb493e66bdd805455d2b15db87ce89685975108da3e862c2d234c1d0a56324393fe6c36a3421ecdacd35fc7e680c3898d39745e77b7fb4691c15f98bc9b9ab99b4cf47a5da2789d71715fd1ed22e37bc4591cb99f84f6c5819ca1bc67026ff103a35317389e505de575ce4b3cadd3248e120ee6737c1d245631ad9c82fc22735a13bd09b329e628b7f31e25e6f6866ef1c1fbe68871ef53c75e0020f7df52acf03a087821c248391151ebe3364a10da05941e4d717cc41c4981d9447bb97378732b900564de46f613b35ace662c5ab603d31724436be2a1074c3cb08b8dc9b68e4f32b304742636b42614e4c5472207fdd8b3f72a827aceca0efaef5f3475b9ae00a856b605db0e55c2ae959461ecffb63a5b31131243042262ae21334b33d93e759b9e9a4f84c77de5c45333ca1945080e9f2176e0373a76d0f5e218bf3c2a5e44df40b829954dfb6dd996380afe186187a8786ec92fcabd611e98f033b84243931d944886e69b6a43dd887675a07f052213b954ce8a5dea97eb342806345bb9d5084534b35a143d4a06e0d61d48779039dce69578ddc502be9d638b233b5a29c184202e10c1a925cde02571d41a750f9238c15df81c833cfe915a8e164850ef00de81adc0ccc4b7c8a9be16fd0e150ddfe52e8cd4fc4ea32bcd3a2a95cd1bc8463b77f4c41f9defed2d01e08bbc3b7d33f2283950cb67d9f2c4be4c888f58e0742c8e546dbb2cf8fcb76db9696c09a220cf74c3525d222955be1220c79e61dfbe64a09700c834760b6b93c11205942d8bd999cc33ff73ee38746a34764a4647fb52bd15ff284616eefefb82c959973ff10a84adf5845a1a0fb4bbd04478cd8aec28912ca559cbcf4466caf69f1fa69fa4a8f4d087860d3e509f4e3c37dad89986ef0803b0e439d7cf9579ad10625de8f177153147181c596e38cb30dd385ed3551a807c210f96f28135fbe0a90ef5c9dcd8d750add57b41bbe535a90fdd596a0e10b366a585661dd7b425707552002977883720c4360ff77b1f1360384a32fe8e5ee4a284a2c3b5671d21776335d7283be4a4c4783c01f71c2eb25d5640873bab70149ec06c72bdf3fb761e59c38a421bb965e5494d6e2ccc8db15a85d375f0825cc72f968b7acb1f7f2b82bae5e105cce0a8e38c238414eac08feb42f41893fecf12099655128fc6ddc24f003fdd8bfaf1166a738650c59c147b4410ea813e793f809bfb7eb3adeecf64119e32beded8269937f68eb5d59145d62f8597bc7cb8f8cd6e999d12b121cbe8da8f6904e665a96e4d7a056aa6e2b458b93767c03f561e04392b9e6eb4bd0dc6fd8b44cad6dbca1b641b77dc993e1ebd9e49783b74cb095a4f02a3eeefed672f87fed109e6e2a4319e0546abe97e5e9cfbc75d4670c8def8875a39d8bd4b0f3b85ba5133ba77c4727c856f79ff09e4c7da84f79bc6098d80306aaa7baad2c815861c7b689e041a49b4108380bb5c5939839dfecfb5cfc9dfc8f9f639dd03a5fbf20b46c0d51015810018ceb88f6eb6397033d7548eae1faa7454b20bdd81a56adc3d8139967aad275a6ce1d68f5fcf64b1d2c91047b11fbee5fcf8c37588197d532286469b1af46deee9693120396033a3df9411bd978076e1f64515e85024f067312977b0ae7627e76e2454ffe73c0c8dfeeb9f99ab762d0be9af8d42614462b90b613c67323494151888cf5ddd65686e41ebe331a14bd2097ea9c40288c4873dcd1dc5fde7ce4b4a88b01567d9914d8a1de3473f0cd740f7cdf231c8f875d8de48626343d79f5b42c9a18e2f6963520dea2fe2b2d94b2128cbf7edcf3f08b93997fc0c030f2967a88a03822caeb7d6c1fb87943e17426fc3c3449412ab8ebf774785b5874bafdd1a0b393869a25649b4dc8fe0cba98926d6e98f93dfff605d43d8c1c869e470fd3afabdc6c0aa3ffeb9f75f10b956cbb7f0f3f7bff8b1cd9ef3096ba06d077cee84126a1dd46aaa2636920e7a109da91e26dba022d34a12b1f783dddebafb2895437417b5ad110007e99c250fe61ffe536bee0f23c5ebe6994fdfe6a4981a176e3d8fe19821c2495ce7f4d06ae5f64b6842aa957f157054958fb8007637e6f02f2a5c9b94bb515798d43eeaeda95d3e6d9b77f6ce5e3ff0a544d79ab53916c2ef6e0035f5f571f886e353b38090e50969318d43daafeb1f9d89d78920f536224b903215b12bb55f8121d2ab32f044a02f81c7f09fea73cb6dc574c4603700bdcb4f9a16631874d74fcfa0383053a53d89116c937152ca59f42aea5aecd8516692ad04ba105d305c54b5c4925201ce977cb4efcf07ceb3cb46a8bb576a6087f22d696abbd8cb1b8ac1e06ffe8d5bbfb69facde8c57d2e57f733df56ce4381bab6b4352351c98031129d010d4cc4621ce3f2cfc6c0679e563e9bd45578951e8f3ad43b5db950c68e4e6c59cf3d1a08e7081bde2ddf5c8b15609b175ae647b0576ed2a6b152072df9ae3a6d9f9c1201898b515a6946baac2d7c726e4a5843b87d192c8e4faaf9658ee2bdea25c4b54c02104c97f93a6a393b701cfe9b322b15202f8e327bc1d1797be523ef2f9cf5d01ed211cd81dc6cde8ee7a6f0e86af5f506da6def4fc359e5dfd092af0a694d4a5f36392b859e9c117ba4aed1a00eb5334481326df50f2daf72632c04d92be5751c5059b9a9990628ca9749ec290fa966cd5e41eef2ed8d7477feb9e8e079174cd2c3b13b4b6473098e2c2cf42865ee87ca650847840374a4c7b9ed2b5238e7617d6dcbbded91893f0d35805739480e86c61e2d9054420952903513ba6f94a755584a21556fb3101cd6d87c497f71354953af80beab4eed188bc6c5b7563a4bf04fc174460ed52404427220868890e32ad7191ba6acf1c5bae10473ce69f7f87a876dbc3da7726b30c3cfe8d05fd3eae2f0241a1efc80e00f926dc4d9bcdcef1b10e1d329103541dec466f0c8ee99e4215fe1e65c71fb57cc6ffac6fac0cde04dae86dc66b186c5a2f0d1c42c44c8aedb31afd2156163338b01fc977d3d2f795fa7b26e2f73be5c7534e96bb0c23e62976b2e102d7f8c94287d081f9a02392c53ccb27dc4b1d2f39b3de9165bb5f5dc24e8795c21ad134cf68b11b222a0b8aca8477e27e73c9ced59eb0ba6fa28c16d04290c9b0990fe689a3f8c030703a10028b7eb4814b2202b01678821358eb00b688e89327af1e6d9eec7c69a97d68aacb8fe93b0ebd2384ba6706716b6f1574c3ea235672693ed00e4589322e9597212cfd68c6e6d5d35daeb642cdd88b81e01b4a1ada4e062f1b70900a96740c62993fad9a2651bfb1e79a3cc8f51563069540607400556d0a96a7aece3f77577cac1f233c5ceb13879952ca6825e055d4122da11519ce7028dde4c8c8c507d2d83e4bced38d5ef210a797ad00752910c2dfbb94ffe47c6f9689aaf08b3371b916142f12dead074d6b0fe4f643ae718e36febd1836f3af1c49dc2c0c76ccaaa93274dc190c02dce1fb315ff4628b00d301ee912d2a4d98fa231032392e0840833a4ef5022812a8d50fbe0f31ab40bfd7b6bde1453c1ebadb8da1a70915ff391e7c8257e1c4ddc931b42efedfb2af1786f887a2217545c9b09af618af58357b83752c916a7606d804f09ce10f779d4069ed8fdb0a70b0dbbd41e56c558bdd20092bbafc4ce494d6580d4a179ec42c13f443cce9298a1109aad33a0dd3bfdaa3ab8f24a714e301ebfa61c20aeba502ced5294bd6fe77d059c62c548a496d259c3d3abb55fb3cdc291d605020fb6a9fe24d8fa3d94cbe82509b0a3046565f12ab38f164f5a572b836928c13fcca1d3c4940267799662ef7904a5beddd59f332820fe1467dc09d8aa65a44bcc7e79abed46f266385a8b62fe82e63e69fe57eec336bcc320e1b482290785cf3090a469d8e2386287249213152be099390151b25bcc5eb7b2ed6f0e4de2d5073e25cfd6a2728ab51e6406a086df6a3543d6701d766320fcf2bf9eb13410c66b77d326b86560dd2ef2a68075917481d612f9c335b6ffbc088202efbfc6c67a0f54805ce206408b647eeb2bd3e36d6addb51b1dcf2b8afd6b29f2416a24d239f631bf0d74a49aab13d9baa22dd11f6ca66270c07bb999ebab632f8bfffb3b7fc448b884e566b9b09aa5876f87f8a5426c499e848cd87d8682c993002408d7c082adc14458f8bca99360a4fbfdaf133a077c302b69f01cb1ae07d4597fd694d3750852c6db0c564ef40cae89da6daee1b568d971dc37cad60fab08b27a5e24e1f522932d0e80f2231a9d7261257f51893c20c6d0bd352c839013dcbe4252310e2261a25b66f5438cc125e34ac4db8b5792f2c09aa68fcbb504c2898bd64e0578b17ee2c2e590cf3f23118eb4c2550339140f67e6460cfa927e96604abb3fe28ea17310f2c9f0bb1b609782eb3ef027c809e47009c78fffa7f1aace3a40b1194c8f4b89facdad1ed86b1da292765d60b8ca3d6b66bc6a6ea6dd38e03168aae04691da809edef2e84dedba1d850ce19f89a996dc7d8d0cd8d9eec1abe4a7f6a7a95c12fae38a1ccf5e8af65a71dbe6dbbe0260b032d60fb92a0e78d0f1e4d0e879454efdf5eed8d63189ead37aeb05bb4500741083da59e1e9ca2710fb7b9aa224fc1cbe1c83212d91e0e6155b38f29998cb27b13580a2038de34f6c6703ab8fca9b07ffb5ff1d1177ce07aa5e06023c240848ef5c294a4c510c848410af5fa79b4ac26fed2f744d06b4dc9dfaa4306912de4f058157655facaceed41e84c3188ad84f76deb6fed5549330f437ec1b84569c43ff2ff8d1e29ce2465701203e861f24b70a3bd87f3cdf9690e79d55a87a3d703bf90d63fd3e035223028e4f5de0d6d80079d1ad37c320f5ec783d4851c344313f7246e8ea73140e5bcb3e72f4a826e10610450db15e92e76cd151e66451707b0f6ba4a78395422c1b591a1052afab8fe1acd184c4db1a631a6d76c545ee061e17a2db805c60b4cc46d0e97107f8e6ec57f40c205de7b2c153ecd7c11f30036ffed43ef584628968a506a9b87f3cb26e3e04b3d27dd3fddc8b5c87f19b320f551c2b681feded57399a781b291d5f2e4607bbeed6f5fcb4cdfa4f5e8a9c3cbbc43b9d2b4470bafb66d9a910869a26dae9752cbbfcc4faa1a108fcf0511763c42103ec37a6fb4da547270f2e9c71698b813221e2d43fffeafe79a84319dd6e952dac836d16c23f1755baf403883b0bd8df408899ab60603289dac70318ce5c0d75d36ed126968d319f111b2c7340636cad38e52367be31610c0ffed4c426daa67d941a653d4eae2196c6a76ddfff5c41e81f84b54be096add22ba6d1ab65005936e941f5efb81a92341282162268d21806ec41ca6cc38fac0395c02d3a88e2beb74ad3a9b5698f18ce9f6541d02a1d4c8cef81b83f7207191361192475a8427202521e22b08126b5fe7c83e352a13a89483e0927569136aebdb24c611ba9950c23a872c38c3664a297a97e552ff36b5abe2290c9064072edb5744c5cbd3315d78780138ddb1e4bef245a155f2430cdd97bb61378f0956267a209c2abd22c8931c1a53930cd5fbdde611f45819488c6f1d26d7ccb847cd87c1410d11843027557e5078ad70d2d111f39f30b5469a95ba214b34da6192cdf15f6342f5f2f48d52da31a411c0d93f9f361b154dcaac6f366543822943c50c0ea45a27e4483bdf60cdb2183fe6c77aa38e50a40183dd27984b22634d3606bbe9090a8e1a726c8b9e2e90c6b02a926a1a90323498980c561bdbcf7dc21e4ac3e4f23d149b0a7ccbf0060f2fb8bc4aabcb2e2dacd05af2b0b98226aa60117acfb75da4ec5eba7d0748a7a6bedb3dde67102d5b86172d1111c507b64c6d7bf2d28cb66890f58e1582f962e0a05aec654f7303425769cc627aa5589f6018256eaeebc21a774dabeed36e94cc6a1bb5127b5a8b23318667daeede6c040a4ba1e7d512054b0af64dfe8635e690a35cc70cd21a233a862bbec693543bb168c8fc7d3041074756b0f6725b9c832c4339107d846a368c2e15facf19d731994da05bbc8589a2d2b1917b011ff3f6480cc4f6c6350b5c873ecf3231580372f945d4023b27a16b75ebbd88e2756c0d2a2896086347b8cc902087ccced51c89fac12aa54a66e02ec0eb5769652e4dcce8e7dd6c9812ca007e1819a2ce30493633a2f936723819a372ad3043b807c1194e552de5c2cd4bebf157848eafb52245fc44b4335826677d365ed8eeb2857b12efec3c3a72c6e8ba4ee317927e04c50062b96bcdeafb8d5f6d0d32dc2d9f3a1befa23016f524dd293c77615462af962dc09da3678892e09a687e05a4093e84e6451ad5c87b50bb8ddbf1b4ab3b42f5ed07654ec782bd46b040a3f30f03415396e7d265710dd74696d1dbbd434cf0177b79c85f4775889ba1d017a98e333d5274667873a7581e9fee7e1661b4a8ada9a08b7e12cb580aa69b6545725ca54dd6c398c1193419e46955c8a47843388b469861d8e0722f648bf4082390965059bcbe4ed5c7286899d0b013b93c39f205d3ff3db1c06b794fb0b03e6af90b74e3e3cc1cd46f37bd55b636954e93a0a013f04121527a2bfd60e288b5080a063405dcda1e135f92d57746912c952c7bd9916b9e7a799b8549e1002e64a7a3d906612124b5b3d71b122c03fa9ea892c428122d696cbda6c3e1133311d7ddffeff468eda7d0f143b3358b2da04d8c929563811b961bf98080fdae14ea40d034d3c6fa95f58c094cd39e47c5a7643b0df230f53b36ba3f60efcd23b2dd7b3c88bdc3514a67e8bfcb2daf82d066cb7d62f4bf32483d1263ae42c2f761e140a99c8b438b58d642add98a41d8e5d9cb9d35b04253fd910698b9b3b8ae1c8b201c3b60777d3b3c94f77ae185af27ef8951a97cb22e561a3ae400cd844e064d37da2404cadebdc8e3adcdc9c4f29bb57454162b478bfe074abf92dc4f102328bb1062d840309764054309c9e469f9405cc6be654004201f139ddac208b64b7a75970c700690b54ae8152deb1883753942dab308226e9f71434caf8af7235e36bf8e769b6fb41322683cea7baf4de2619982019c15d6216d05ea86dcebebb537cb615b0ba020f750a372b02b9f8caae996217fe7f01e81153134e2dda58752293fb87135581bc8a690ba428da6268a71c05fb81e9987e23153ffddbe192f3a3c93be4b40d179e4a3d452eed82cdf2ccc519fb2cffe6fcb2d8ac4b55542d72e3680691d63192165fbbfa6b71ac67bb4c78cb3f7cfa2be451d62f6e1ef62ce6c28ee01ac417f8ff87c9f248e2a1ea56b6ad1ecc2692aba1c3d94d697b4fa66519a2052c619829aace7179565ee52c19377115bc30f91d588c1e642bdabcb70e894f656dec22d51d02921653dd0c79b83f980a259b93b34088ce727172370ab9853720c1c9fb27673fa786cfe9cf6dd9af34d3ffe01e0734ab0c62d099644368f78a0b10c4919fb9a8e478623dfcd9cd593279dbebbcd4379ebcdc1d3b7243886d2d3544c3ac13ccc4ce2bffa73a3aecb98b099c897b1f44cea17b1001cd2ebe9fa55911ab06947e499592546114ee0bd93a5d45807a2c4b4497c561e56983c9382f6378b1bddb4fc670dc28ba458c892f793285251ddf993ba61b9724fb950169b00dcd4ac38a55e28a73cd94d4a4f7539c57cacf356432fb6b9e03e30b031604267aba237c4d564041c8f4ab0be33ad70d8292fa08aa1e219e212e9bb77b31446a9a53bb60a99d2401509c0dd46eed8422d0d44987c087edebacc3f1737851294d4a36c6aa64c0f30f0a110ad6e8cc653c538257c81d0ad9cd663392ce54c9b0c3959c25ed4ea1712c0d7c620f529da0d184dc9886abdc39c672e474daaaff12643835757ed58ddcd4a99812368dfed2640b9204df3cd273e0cfa22f461ad069df54ffc296413e8ef17265260a5c910a999e9fd7858e463870ff668b85750f50d41602783e380c97b39d8488c5eaf01cb8a2ed4b8ebde5153b23d9a35739222be523a6fb19786f3b2ab6a1c3a24583ddf1d2c00d57169159587129812121b864ae86dfb5b54545e959c4b5f7a2554e6a45153de84b6284ae1cf0b498d248634e08ffea873e55644e876d6d91b593901a3d77072b242e4dd11193868fbb794f333f3f1665c90f370c54870ed943ed1433bca011c6c022db59fd945d50e1868d36e81101e13d1a555542d7b74bbc20a29aea374a002c52d57464c188cc6020af53f92f299c908210650ff26f07ff395b4b78edadfe50d8ed94cd4b88345bb2ba7af7411ea8e6f25e95bdb0c6bae42e77eabebeb18f7ac0d9ca30f71eb51eb75a43d73f8f2223bc5076785cedb92fefbb19ef9a4301869eb5b47e4c16d804de29f89196d49a52a0f52ca76fb7a530dc283bbefcd56eb2926cb5c8c9c253a6bb0e46bbf5d7892ba22f70e7448d9c4e1264b4599561800dae999fcc9351d0592ab6a69f3e2415e2a38c7eb146618e2d68565aa233989895e2acfe5c821553ef82de87c2fcd2ab4f2a0f5baadde366a56e769a671c4edfeb6230d29ebd06ac2875da8f51304368b015c7aee64c022429319a869685f09b0f2ebde2f5033ef202e44bee91f352185cadaf0b0be375008b12943e31ce02adc12a56ff50e8687885402294f9080a0dac3fea2619685e4b1b18d0760ced1af8f4d54f61b33aa8811720baa90e5f5596a141e67e0745a33bdf9a616a8fa3249f0dfa478ba50f856b03c5f20d21d1eab81113eafe3ec3690fa94d6afdf314c5947ecc4298e52fec5937640dc1802e9c17a68c54d1dfaa321005d1cc6ff778ce6c919c958a1a8b6df8c7b8f7933e1c8901854b980a38679275dc3a787e429bbc4e53e4e435d1362dc31a0e1e96ddc5ba30b22c318b2eeb2c8c4d26869d64dc1b2fe39f80a1f1391518b580ef4b4bce9b541899ccc504c525a9b56ccc0bfdf7083cd452be35d5770c75b848bcdd04d1b44fcc6b38845e8a307bf8b453d8190bbb0b1440dc997c928acc6fe4423eaf4c56d0770b4f4ded983587d718a98e26cfb4dcad19231523689fc52a8781d71d646db912224ea02f98a5302c79127b9ffcdd57df4778f441bd49a33d534e506d19d0068de5491f664bc7af96e903e4b3f694034a54c608019999197c15bcb4440cee4b582003bc8ec7146f9214f931c064a70ee12fc79ffd83eb9d56e8e35bf8d9a72d5111117be20cc7a35abf6b2aaad4cd02af9a99fa5c17f98e8ad9a8d780029a9b337df0531ce08f0b918c05e402f3cbae96064e0c4c610e53130d4d93e335bef70c8784aef2325db0b0f10ee8d39806b69b9a4dc7b1f1e34a80c9bfa485cb0e4f8335fc8f7bbcea0e1b98fd44b9ae0f616c1b32d102465ad6d3614814e8b907b95f912e4cba6201543b317d3789a3ac3ab3b051f0180bc2d19bfe5efd64f5fa897aaca0d25cd2bad8d7bff1c21a6f1285b658801a835b58eceecb236ad2aeed6dbfaf3aaf3a05cf1825be3485e065f25ab3f0069a3e132cf6ea344017e14fcd0b2e7f462a1bf54ff4e26c9e7ecba28d106a2cc92da5a9269f2907fae78c81db00636bd378d6f68476c6702ce34eefbfc2868e0757c5b5e49c78736aaf2e93b23a1e3cf4beee08ddbe6634c247f1c58f8f856c228ef5aae68bf04fae20a677551701831c7f9682a7d5b35a0c09c97fcd714cc9ee18039a40f7c4a42ae826548b389b5b980452335cd582d1e03e898b8d427441d23c1aebda9049091f93463c539b66d9a400ec8dd093cbbe11411111b5d929257d9f7d6d6ee5adf8bb224b81559e88b6e299ff7d8c6b1c71e83a7fcc0095c044ae642169b72fc22bb1e02ed2aa6e51d14b735bb8d46bf94b5b2293bbe0354df62d472e2be75b7cb9873189a9717b1db43e4b0f53bb2752f5cc8364392b09eef2c4649a6da98bc4f1f5f4d425b833fb15b2e4a6a6d432365eed7822f067ea7c23b6d0d58eca9569e2c52ad2aca801bdaf6f1a80ab8c3a5180b2a8912460ae8e7096a9111d6468c0904c959a3f0b49407a8370a51de9ff6e75f62e4833316f280aa4d5b32f35e06cb2994b2d7bca0845f2c63bc7d4a3e8b09090a7f0d39dd8f0679193518af2e1b13ed21fa2459f2bcb4ed6714e017671ebff8c556a22080fceed1dced38c277b199d60146d8014d92c4a7c703256c066c562e1e0e0336b7224b7ef29bdc9d8237661459b634c5fdc70ba303866a6fa4bfdbfeeb5c73baade6ff1f11561b88183929547ab940f1ac54b9822c598896a8d26a04cc36e8341c83130c5f62dd24b837f325142d038aa6a107141842feca15cbd5a21688cd5445a724e543e9b8a3b717d7ce024f0625048cd2438b9e8b57801f678d637d82bd0441e256495870ce2a641a78ccb8b40c4c6e2e9a7c1f2bcf6a67ffa96fcf063b0ecf3073f4f221aa5fd5152342a424e15597c285c1f67bbe2845341aaff8a1739359d7d5422f82471a769aab2bfa7ed28dd9277ebb076d8c4fd7c50f8beee71ea82173c192223492758aae6384b41f83b83689b38e4c9f9e2acfd76fc741569d823a9b45fd986299fee49495ffa6d47a925c193a24cfd591aa15152dc8127a08203b5c9a0991d122a3dc86833933f89f3ad1a5205209c8e4c0da346e27fbf7e2395811eecae3da4c4a843cfddb276b661833640d8df5acb6523696a9b23f06d567ad3a82aadf6fe2d5ce2b223e05db74e40cc43325803ace2ab82c80ca720fbcb41e074b3e2de432e2ab8e7153a56ab757c05b73047e07d68e43b9a71418748244ea9bcec36c0fabad2c0ffb0bd633b745988674529c216f4864d9f2f5916ce88f89c345faceac2bdddb187b138398c546113d7d19c96f911fe9de4512d7ccb475a732ed512ee3459e860a2d9965495744852e855d1898fb737bc9993d8028b8cbb164f76c8ecf4179110a1a3180857e5276e56cbff694f2d0c02d4eeafc01c1ec58c6f7c8222d323c55f88354d4babdef11f4655418f1c4e640432480e6273b21af1fb895ec03547876aa420dab924f4bbf2875f30944c6d6c77ac7e37cbafbb629ef815985fe719e58649c51446232c13d40333540c5a810f51f0245b13c740988b5388302dac6bd6738f14509a552d991972e05a8ba24da03cc05d6827db94e4ced7139308ac11db4047faae9d39208477e3401a11cca06ae5069062b464d981c0e9619cd627ff63f89b7ab891a0145a8a8025fe748e5239b565911c36d9241eaf916f7d32d747005ce6479521c6812930d9bae0ed576413ec204df4d86f73e389e2bab0555e17762122bbb9a1f219a1a27e44a90b4ad21a0dc7c79fd8129022edf0f124b37bdbb4edf53f996b856544fb8abd912ec44688cae2b58aa3a1df388c68a623a758f9833067213c3d4ca5eee75dbe9e896905810412714d72b2edd3281df70f2b9475b5911fed817122ddecded646d2f2c3117d959bc6d0e951acbb27a833186070ac9360e07b08fec3e9b4b1491803aadf0c3ed244e9716e2d2bba9dc1d134213d9c7fd25f9868d6c06ef3d3ea73961219c4ec4b97e88d48ad10e050b9c3097484518bb00f12ac7c485efd5c6190a0c98cc8d64f86f3b52af3bdd193d2b70b03516275223da437b164a26e348b2fe60fa5013727f68d001fded951e6fdade66d9eab8b54c1baac1c1ae85572ff00b8b2520a82a09399fc87be08564611bce17efaef4a82ee13ce9c3e3aa2bac1b98aa9ffa077d508401cbb0a837350093081c0cb6856c0102c273b49aab525c57987aa7dc91b87f8151027e66bf9314d8a44c2be098bc856fb6afe7d757dc71788cf13332b73e77c8a536803a132703a3640d20d2df8cc8d306df16a9c61786a0d2aac6acb474e5ff735a0e56f955a3eef00fc03d16aa66dc8322343c12f7fc676fb731da3a25648009ce9e405c298a186b1af65623a8291068fe2b99d5b80a6362b34015c6e2ead8c1b9fab21c319cfd68683e6256a1bed64de2699737185d18b181350d92f6a880997785377edcb67c678a356886470db46f9329d582ec730838e62adc53b007877494c0e4d6103c43046c49eb8049b9715853c67efb99a20679901a3acbe8623607b9359a310e02b87e950d84dd8459d9450817794b0296d4b3be9e7ef31963966f764ae7df99fed2a9de18f6f697ad319493ebd0500aa6e1df84a8c6270e1b4f8c27c86b5a6d71dc21f54fc1f7691074faa7d52249720e7fcb9b7e3a70145b88814994f0ee375e581d932417d1c4dbbf7d70c1ec424e8f86f10132ed21c6ca0f73c5440dc78566c2bfa4303650163e9160bba29b43ce38969ea46ba4d68f2b886791084926252d519b7cc183f922cb18212a1a84b4d9307d755152bbcb185377adc1fbe8fcb41bc55c5e6d3de0b0e648753f11dc4fb5c70e753ec03b6a7d8a2e3fb4a1aba1bb612be4d58b41df9381cdbb67c31ab87f73fe624d3ac6752d0bf6045d15ca435e72660f9f7beb6ea104ca9a4209144a52a5f61547a897c11951ae5a50ecd26de7c18df30a3763fd57acab5ef87f533749ddc3f21280bf3cebb7da2d98676f44cd2d895b3de496ccdf853a153388e5538f43227ff59709ed84fe33a5fd0c52db2cddd8a8c37720877da93f952fb5a399f5c39ebb0c14c9abc0797317bea9b3c4865148b82e2de0943a3cdc716791f91e9f33b690d61ec9acf9c28bdc2404d6934370db8411e1818a9bd993fd91162a2c656e0b8e102d9708c8ec9b8f53516ed6ae531d93b15d402ef7f6e2ebacd8de9ca8194c3ac18a06356b78f605d8dea44c21ffc27d3f76eab176a0d3a6343fe19fc08fa09f97b85557fe7e6944263e581ea1679b232061e92cbf0f78cb0892c55bff5f83fc72b3af56ea769123c6a8ffabe086ba9402b8f963265377648522689b6303b7ed9948c2e7772613e44c5a60342fc07d6ef9779165ef0fce48aa505caead82485094351ad4cc8e110354112c6dc3732429a8ec4ca0a64fbf9c3958b302d25be16cd78fef9fe6245dec802fd8a3a7b5c40e00927569f51ae45d6f2eb11017aacfbc69305ee571052079cd5e20f6253636f67c3415d4980f34b7992083e72a1de2d7e54b755086f36c75eeed4bc076574be3f601f85ae79a0aba4a4125cf9b64973847b6b4277378ddc56220639f2c1fe7fcb137fcdbf569b8a11a1b581cd28a9998beff56afc30a5c30cc84e34ee79913987dd2abc63f7a675a2a55febfb2a28a9efbde91476164fe631952981d321ca99e0524bb0ba6b52df1f85e14a8f8d4e06fe10706067041f594ecddba03d6eda1e05083c4e89d40dac703146334fb8db48551c7bb2bd40fe5bda36b718a43b402c898ebf226b5bb8941f93a8d0691ad2816f29d61860854af41e69818d60c4edaf9e24e4a49ebc83a7bc59057e8f29e3798a83f819ac4f965a44f9fa693dc0e34d313b29a524904aca4f05e2e9b73a049f87c6743a0e345e6553ab127d9998331cb8d11895a86eb58e2489612154b9b4a237ba1a4378ec38b7ac68c5618a8c7af34b51e7f4fa534054556cc39ca68d9d2ba175226aaa5b4493d21a95882d8f4535eff055c29af1e26cdec3543c286c215b53084f1713c8679a49fa5c9017bb91478b05e7e5226326bae41ecd609e371efa02a3c53ac73bcfeac9affef8737928cc59ce410d755c18f7368ce234c5672dfba8be1510ac041537de87c56d47e6befa48754e9d66a8725e03b2d602ce937c0c59d1e2e3017b1aa5139b4f5512e20d1831ea88db49fc24317b7bf7c8777bb3fd4d789df9a4904ab2ab8fc1389af7927e1f89d1a2564d540047a06d49f2d559bef558c10a53beeb5b3fe4164d952ec33664a03d8089be98b53e6a4f250eb9f2f445977d53dbc10853a7781db8aeaf775143cfa241954d4716c1f6c464e6a9f437c6c6c79c0a438ec0a93c33bb1ff8098a57b3a164d60702bd00e99090f5bd62fec819099b4eaad3291937ed9b9e2ca06201cff166826157e0c18cdef05fb89f40c39f58338974ea7be1ab1bdecd6514b0ba3d2a34a870dd3b4bdf025fb6d2c01903a44d317598456a2bbaa52d97f25135d9af9f9ca3e1d7d8dff0d290898b24da6cd8cc801c7d61afdb6c347b4e16c7c9f33fac3e75a515e9575f076b96e194e1e7a93f6954d6ad922348a4517764e9bee8165f0f0c4788c66053c109904f5032f66a778c5243bee8eea99f3b4cb36f8c8566bff383aca1c07474e31b1eb2a959c839d2972f50b79aaf877145dc95230cac0dba48dd54080ebe7bde4ed5296790460e5496ba9e741727f65f30839d0223119c8d0a108887b22944bb4ded9f6f0ba50dba69fb779cab9dae9716c560b7cb7cc64950d41afc08a318255a54b686115a98a3c6663c2798b7fa07b6bb4433fcfce499a06902fdacc1bd217edc397da69aa611546d326204353ef15237ae8acade297683c9bf0e4f76805637ac9b1e1f4c1f9aef7fec6d0f37f347b404728e92b1a0fb9f72074ac4c00674f987828b6dbe69622ccc752a2437ea101ad84b920d5c746f3e06325ff8b0a98703d6ad081d19fe246906c3c258a86c8d8a1afa2dbe5c3a3e0356391e089ff3b09fe77ec2cb71f472f64de4ead46da38fb2bc8af143c5ae645781e6f1eebf06d2dbe5ea02420169b0084c999f9b536bc81cc7686888aeae33f86e07c555449279806fbd7d15fd8b3101486585c3f3b0887f581eb69727abec16a46e5eb1c4b2a68dfb77126d4513247431d374b8cec76e631cde7feb402bc93900a0914494501a266d867d649280e2b0583b6e69127716ca888167d4eb09845efeb57111edfab7526e6a85063fc170d0774d66f2db9c8ef7787e6e2422ed69a0b3f2b150ba297c3c59ea10515f1595fb25abeea844cccdb24426fbcfd3c361b27b30a48a9831cf027a96c97f03c90cabae36dde167c8645c7a942ad4b984f643187ce4a1c67c2d8bcffca941ae819a2306f7457e384c114da265d12ba814f299c4fba1ade3b68c09e3a5cd7e5bd219db1edfb38209e3a8c5d3cc84f8dabd14eeaccf6b8f238ad561b4734a8c475e6bd7022f74b08c0d583098c6a4230026e26c427d418ccc4f904e1740537302ab0e39bed6468986f5fc6bb213ff7d028c41dc2d4314e12dd08d993baaf6894e9ad7ca2ea48100b7ac5632d5194d00c607d0e69a7759d385761b3622f31efc8da89504c8bf7419a32b5c36369c892170b9f354f8b56cca94f874866b0b2882db98437b61a69125675f4348598f2bce840812f37488b904657438fe2ae75ea8ae1d7f88a3bd1d877ad072d98c5cbf9ef170b78ea7dce9a1b27acd8b60c66a398d8aeae7a1fc3c2048a8d5500a75d750645808698e0f27a33ee27cd265a2f4536494dd3d05728a75d99760bc2db131a185aef2abd61f0008416ac48ab54451a7d3d1d89dc34d5ed4b9d6dabf610ea84ba23dd6c0ba64f2ce8bd3bef77f65d08f9e494e6e683c3deaa9048e3af56d66b1d6cf5fc7d3ee08e5dc6b59f8ce1e1acf51784b79a3b70ad81a1ea1a2dec1ceee803bb2891fc38b6823a635c04cbd2af6fb2532466577c5a151a476aeecea263273c6a7a80c89bf9fd4782a0d60bc6e751041af2bdb67908400bf97cab8da8d7ea946e09572e46d02eae0230a3790df6b80daf56e9b4804de27bb33a770f11ab6c95c7b41691f365da8c9603fb4f01547f391e7ed59f9880761ddbe3d00d90b1a57470476fdc8dd21aa985e30f5dccddd53e81658f34c564a03b48c229d61537ef6e7ac7378351d418eb3c799b1d4a3e38db9ebb87c44c5844148542a8c77f8e5f523c6fe43f81696ef4bd1c1963c40cd46e6990d486e9a13f2e46c7f2c8aa69831aad89721d66896921ac99495d9419ac6fd5f0c2ba68f441feef79219bc02c894af5f3a6ab9d71252a18d466f39e776a682a30b96305e7386a8dc869ef40b7ea507cd67c0c8dbb5a3eff82c3b9986e19c4e7089b9812fcdecd14d05fab24aea1f417b5eeb2e71da273dfa876943959c76a6559ce933540e8b81276f8a366644361df7bbf8e69a41be72e1c8c1203decfc0d9e85f7ffc25067648fd2bd37af919e41996081d359363c6b77c04e6adf560fed0d671413f85a892a935ac1e94627ca390005b9c9cb0cb7abaa11ad390052feeb48c41425435e2a6118758ba6b8a9bbf82c611e3e260bc887ee7bcfb59ca01ef1c7a33d0bfca5a3393aed72b0361f5b0ad37625c82cfe6be383d29132fae714b5a0b01c150b47d7b219ccd8a0337d45b0d0290ccd7ba7515f8e3fedb1b141a72889a9e115754a39e5e9047d0b37a97d1229474b86a457663fd3c80d53879be5343b41f20fcbce785f914b3406f380c41ca07e526985753eaafba6ad3dbf916060a2ade5678450666aac2935d1296e2aa52062faadcbbefdc2ab4e0fa48960900374259bc495270f34698733a877a98aa403791ceb984fb4ba19927021e3493784cbd032cc396bbaa11c518c23d69b5fa9197f7fa1cb6d35de2018bcb325286343a3ffa38f844bf523422c712c0e78bfcfcbc21a9fc63e312fc4ced1f86d8e6e62b59be2b453d59807427456ccecd92bcc75e56658482b015e81a80e97778a28af1ff6273b6306d3922e18d5ade370dc214a96a373f29b8d89895b39401b766089d56505c5308c527246d528cc7350c7b6c852c2241b63dfb954ef1e07e13333fb42a99e3b8edcc5be3836ed232d2c4e80722d385942c1477b26431cc6128a2705bcacbe6bac684e3a5100b7db0370d63f833c1e978cc808a039eaff41a963bd20fbf48f14e97fd58ba0d20bd516807fcfe8556f9a8f68881b2201794c8af07e22599ebe3da9cb1faed91a36bd90f1cc11929f6ba19274f51b6068d1c0b27182dfd4b69dfe52dfa0ee663eb9fe2eef25b7c05f482b0ba6fb6f0d11b7e793a6ad334fef432f441bf8a169a7c156ec6c597eee751843be6e64786de99c948a06573b22fe105394080291ee22e2baf1ae4bae6b9880bc4fbabd44f0c7f58dba5982e899863ef27e65ee0159ea4335f43d21e1b6db222e9f839c883e57fb010e5c23ffe3dcab9644c3ca1646bd06d6ffa4c68ec3dacf673906fd6b6215b3ec97a8027dd598e7b29db0bf43b3b6b325751265d1806adfa5679bff0d496a8dab52093b7ed64439f7cbd3e714b8d2b5e00cc2b072a40d037b2292776309f66211f55cb761aee3c11a9cdbb9881a0922c00dfec52d75cf0315e42aafd66da76be99909663cf70a5dda27e5197e91d673652ebe8d271b22a6e428be595a0f41bbffbaf93da26c201c9f22e548cd3f60b124bafb6a32946d1335cd03c083c6a12358daa52f889d7cc0048dab47913bcc7237909ae74a37fb69665606032206ac03332ed6978116f66d254cbd212089e0f6ffccefda80eba32b2cd048f434f828cd8c3ccd9b5961831ff1903329adc77500c0ddf49d4062662ddb1ec79acc15ebf0a97383","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
