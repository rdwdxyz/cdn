<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b19a473734fe5b72f8ea30528cc1e1ecd0871d35b895c831c1cd5f1ed84f833803509d11b81ec94c432f6bdaa65f5526208365540ef250d7c6c137f7d7e11ea522bd342d46667debd935ba852c2585b9b551cda6dbe417333fb0c3672f6e0d04055124af5c441170574fb2828a8237f8ab3f58524dd4ae6d5f760cccf7c2fd7d1bf6015b2640e60d973af2b83d3113889fa6375df630da41c90b6dfe0507d84b91a378717f3b5f4ec105fa75567e88725228799bdb994c8302f928c28ce204943d10922f6f97b3cdd78a4614d26e38501a52a02bd1e5f9dbd0da63125a05768ec0c27d87066db56d786c17dfed953e6cf3a636667e4861a165adde2266a6a31f23ff9082fff3431d9c3bf84dbdec03e9d907fe54b5947b28101be03f56703b62754acaf5a1904b733c766efc8f3b978c52892a16b7eec1c2d1e792da1772639fdfbd3240f436d731a1e77632833494a09534005f8bb9a78be7c4557997ab053f9ee6ee607f46a2b837da4e13060ad69acd0abcca5bccb09da6a77371f55fd9b381dbaf90df59ae4249a20e865931ba271889f3ca752f20b2803b8b7027ecee8b2ef29419beb1977da1ee8bdfc5f4de73e6f9e23b71f283f678bacf6da37e5d9719c14e33f511022e42263769c617cb4e116b5181d03ba4656b2e65dcbe989677f81174c875be5111cf857a1321989094e9be0f2da571de151b672e08ad60b282678275cac42041cef6563ca19fd39b7f102874033a769c57626a0943a938353600e596856f447bbfc94ffbdbf7a297c41e6ea5beab8f96dcbb515b824feb2df4c52f0b7c7d68f0c2a02367925139f362f76245dea1ef0c2b65d06dc02eb4351d8711be727a6bdf049191b32393b690220b8caf84eb691ab954a19631b9e55caffcc5325b701338b1f8cbee38b6b83c9e6a25f6051b1c97e163edd24634043cfc764331c46dcb518fb0293a5a4a5e66742e8a9837e0634b2211c2dc37d356510730cb67c9d09682f8f54e98d04adcc504bd62cc29a3003fbb6144c96215ca3ddd4e173b537c8237320a9c8df646660fe3611ab51c610d99ca974735a5d538bb2f9af122086e677be6a65383686cd1a46624808ade482149cb3fabe6a1017c8b761b9b1fae055ebf044324a094dd04c870d07c328d94414e9dd926ea19492f26453d2dfc65d31fd1ef54174cd3561ef147b706cd326987f26d525bc82f8439def6cbf14634223ce60d8f7ec9b4d19e51beedeeba00d27f9b97b591b1906b06c44fab31f7c81e192e3e00d0532e5f9ac9f4e2ad6bb6a966285de511c77266782615063289e577266ed2a778e7dafa24991d03f5d631ae92f3ace1dcd77f5d171aefcaa481edc0724b534b86a75efc2d52d9e63205b3d032766d4969b8e6daaa2d69db0d5ad1fb147a05455c73877aa72b18edbf4779140a31098d8e9f6c7cba7a83f9ec523e75daedd606e8b444ca6f31350b4d5431c69a1ecc763993eb230153dc8e119ac775efb08fe3627b3d94cafede115af8d31699b977ff8c1d3dcdcd72bfcf06dc415c196f2c75310e96871970aa85d953b5d727360b298eeccd3df82da8f438ed815fa644c225505bae714071675059bc56c3bff4ff3796406697321c83bd4e6dba1665968182b65b45ed194b1e34c6b17a5dd37f5b065b65088e5533fe056ac883f22044c1bb9fb6303fc2a8b501e1432b1babeba49640d0b8e6d2a104ced00d4b5d1e1bfc5588efde09392dd9659a1664b6e48924ca4c26f9ab0fe3756f69c0ae1e722e585d198ae7a672c7735ff4d7adb64aa7779bc6b832087b98d6ccc6ba85d9d83923efad29d20ba7f744b480eae60fe596c4532ea3ac0704902b1310c18a38c1a9401cd5deb2463c77eb59d5b8b3bdeac2e85120dacf35597b9a0c078b2303e5e4a58121b7cc335e2f9060f3ec2b1b6e402d84a521c211d935296860d6210e0e48da7dcbc270dc2d652a4ee6cb597f6f5177b83d5d60ee21e924ea80078927e41e98e420d19918dadb0e01b442498f467b9fc9ba45a3a1c3ebf62795f4ba7356b5462b2d8d6e3a7046ddc3e4666f6cf8d8a9a6408d6b38a2c6fe5bed4c6f36cde90a6be9b96d7b6b91a8ab37d611389d8c5ba3285e2f6924d55e46bfd54dd7ca0348d463fda11b5833751f029c134e4ca5ec7434e86c410d178ec1becf85366245d1f5b6aaada494ea53e13f8a8df63e4fae97d23088122df7384747f4ee95f1564ed217eb9c0e8f4efbd6ca2870c60d91d54cfdf12f5d1cc0de860917c570b73663e8d275341ca5809cf178de0bb115c213770c3ead1732a164d4ebfb82e87dec45b9eccbf92854d9ac4a4530c5d00fa5123db5dd8fbfdd5d3138635bcce0b2650101ede2913f85b649b4255ef3a3e4a455c82f4b7f337e833c80cfb95d3474d97e69bd69b529766c8e7b694ea0e1a38f93559b16f2855dcc1aaec5188f82b061080bd76848702aa112ffab5d227b0f99a256fac09bbd2f3b76f429ab43fba7f0d936a8a627a3236833ffee4483ee59bd938250f3acf4a6fc8996ba56cd36ee9df2d295d609687ca927fdfb50c9770ab91ee5067cbc788634a05bcb4c2c0b25db8a58b702a6e1d9c3e19bf89c27a73f6d5aae7feda41b282dfa5e77d245b9a34302c3effcebb91f52cb085cee9c9af412c212300aa11a13311829ebdb7022b805f726dc66b5ff143216423ef617e7bc1ad3b96b02cbcbaa7aae07a8cc14078b846d06809e5b3e2a3e7df52b492d6229fc2410f3a15cbe26dd822bef6e8dfb1f4bae860b303153aa33afd96f70f7cd4a1e53280393df20a91ad7af2b181aaf53c2633c0c1ace39e8ca69213615233e4a1c5efa4428e4b55c8ec882e64fff508d6051cc34a55bf6f5c6562aa4b7233b315f672be61210701683c754ef7e70f5f0453627c14e77122ddf6fbd8f6b2a1c211606ca316f2d14aac730ebfed252fe2f930955a363e0d2aadf70875a345c31feb22ea6f0b72c0fdcb4878fcc1c47806793dc1fd2940af8e6c635190ea55bc4d5ca6f0d55a8d896481e4ba495996bc38a72d0d6cc2f04c7cf0ab9d7d2e5a6a21ac9a30ca98226974f54b852d58b8750ec476d05d0c92aa8efa053cbf65c620259395151b6504a78ceaee887658aa79d8229095cc9610189f77f00bb079a44ab5224978cdfe4a8ba1c139e241a7f47e4f6acc81a1023430514b3d402a5e7bc79eebabaa3a2d895169013c29b72f98c04b72f7496bb49b7e44da11fd0f0d00cb9ba250dd61e7431d1d59d73a572bd55ba508f153945ae08ee0af170d6279fb2d5d8ee41af98319d72955c6a15f2c720f17f187c895b3e2622b40ec0cd25229cf27dc731bc2b5d9d111887154028b20be14477c978a974ccb4b741369055a3ca35c8803ba908cd98d33b29a4af8b585f2eafb6294b2169692735cb54a6f9a076193f2a720ed0d424bc91df4d5cb92e06cc214133de3c4d3458baa4a70dded4ab900b7bf1697f1b85ef88590c10e9426adf909b295c23571114452c9de601528c64e3706732fc50ec026304d1b2870c752cd34b2401869d358665777e0fd4f33a3c007ee13a741eb56495fe252a81f2832aff8cb28fe8a2a06db07689b56994aed64e19aebdf1b4c1ded777198e464d25eec36d5c0d14e6c3f2c76efae47a4e5037f466d2c225ea4250b0021613be46f1e73515a73f9c25d2890e757d7b29bb9daa3f1e2bb9be3378751b757ea24801f479f75970d6b88f4a73e631caaa94c7c0eebb7ba299982d5ca0ef9b81defeb4600bcc53b0c6780c12bd50272c870dfef1c65993586999343bbded71c2ccf95d47213eb40d1ae2fe308669c0c925e8da8ece8edcad7e693a76049b3b35277a4e8bc6eb85987c68bb61cf23eafaf9bef911e65061da33106bc89ba46e0ca7f9701807aa78c00614aaeac5bac0bee2683fedbd2fd41cc47c72e3462f638e7b7fb8b4aa0a64bd1f4eb7013c05f49a9c657cc3bb8b50b442855e29800fcc0f6e170478267ceeca9666576ee7cc6255129768cb0d67e916a34379e48c823e0de407623bcccae27e3f6e010992a1c9c9c9168c9d51c4e6b18f255cbdeaf74a07521e2ab276ef792ad196fc3b699aadd4ae22a86499ac3c6bc99782bc58a385ceba630f2c15b4d60dc86b5c2b6f9e6faad3bd184c9f9f0408634cc5b3ddf2e687173d839f3a274e8ab26abd97009494c5b10d08324485b51de93fcf4cf4e5e065e71b11a716962f8e2b24f8f7d02a8971f713ccc0ee17dd51f4bbc6fee86dd6d81c9da475d5aeb1a8c7bcbae5faa1e2f3339e5ccb9c8fbf54561f94fd44c093a6d076fd189ecb83d7051112433251e4e76d0cf3e93fa385b9f8a79a7a8c3c65901aca7cc3ee10d55866787d3203025f1359d842ce21ab88b8bb359d4716f4b8f58d56c0edd82cbdec8ff51758b072afe6b70666b4db969a9b62239604ef3f97ec4b5342e3d3c7e8736ee9fe720de9c156e62556d06de909c44561def93796fd799e97ef6a0df5ab2c73904c67e0386a1ca5aa59b75099bdfdcc58d513d257e885cbf0aed6f29a5c20a491b010edc0dcf72ef088ff0f15e9e500b35fde7e353d9c3535bf2ed4df1d4a02fcca7105d206046a0de7a37a43be6ace19009c3868d40669647554f3a5126ebbeaf400135f5c8efe722ea5da88542a800b89e7c5d3fb1952a0a7832b17bac7030b7ea495cb6c5580cad97548d280a1b2cc89b33277c707f172c2d49b28e679a61296904207d22c580f83dd2a57baa3a59f2981c21f5084b4dafa8f78bf94949a72dc3b83e6addd7b4c07aea639a7538e01fba58ba6dd477ed71f9278dfff0b7655cebc684fc365587e4dd945b6bb363186092fd481e8625fd909b89976db2f0ed044e02e7cc0829afa374d0da43dab8e1785849da70af2b35986381182054a00b7745372845004558cf7f457bd0ea7b82068aad398a33f8e7fd1ab5e33bf9c535a567373afe526d4a4deb551f92206184f5dee94bda01ea96cc22c1a56bf194ce4abee4b45740748a2fe374b0d83fb53d0db0cdc82fe444ccc0f6ce1a5cc036ef2865e98ad5d7737b6bcf4c2b2a3a01ae125426d0d2096aed4804d3970d1f52e1e58202d87ed5f73732d6bc888b8640b394c36b46008950db599d0afb7a4263451af1a0700e39813c6e44445a2212788f4b998a3a0f41bb28b65f735fb94e93e6d8579a03130930b83e3c425ebe2632f638b1b923012fa6197e750c4a662a632ba7686b5c617961d0c4f1d6b6e1b84701b6c86dce19c1900c2e877795538a82c0c20236dcf9b681d2af9179a097a6826835697c93ba0ef6f67caab5374c4f3d0b9a3df7ba5f6092cf0a0121badb4d4fb14159ade8af1e77a84ed044f9f320d7c95fc515fb96c2c410d5d7c7a17bdd8f665288d2a9784d5c184a657e0e6e0ab1903ebe9ba772a79e5c4b8838c8cae80ce877afde428ecdc739c156c7217ef2ae123f56332650003d418575abb2b21ea0c40ca9c31162a5df5b43e8fe6574d2a34ef9a8ecc9c8ac7acb085beee268241484fd26bfe84a7a4a146f927bf6b6849204f5ebc48838d9eb57d42f09c8023c581234f6d65712a0b08387662779e87643edda8d3fee5d27469a4e9db6335ee46df80d4da330c744556eb63f8952b44161bd86908839b66b252c2ffb893b36673087dd34ef5be0138382b856bf15f2e474e01d47ae0ec7d8ab0e0f2c78fb934d6dbceea8a86c109b2542b4615936aee6390ae819d4fa90624d7920afaac651fffe6f5d0e6ad30b869a7f4309c53935874efadc87ce8ef160d221055ef5a150bb5b8d0b0e7d0b27b553d5327678e4545816a40ca6531b082c6726d2a6f8508bb1f324a3aeaca165a2bbd6121ae31d69440fb369d9ffb9cd0f3c7bf99d1b54b6212d940db6492a6875bfe7eedf599b5d1f86edb4dff67b975a31bb2e292f94d5a0cb95e003e9af1472987cd37aa3336d4a6f076b1518a2d5802055d6ec07228f1e632bfb98661b593d9456ec4441e5e3d91471d61ac1934a98d2251640d05dc1744be078fc1a29e68df336f7a7a91e01c82f955046b89b4cf3301454406aa97dea059216181d1df5e71d0dfc3e0567befe04a3ca8f6b0b6a6de21386b8a5aa34170df3cec4f3a1e0241d98c0de3c9f02b042e7320149f516e66e7c1710163851edea43597de34a6a76f74bf21df8ca85f7dfc0077e1f223e4d4b422bd2936c575308f249ebce335919689458f939049d963b97b967d705556e109c064cd1d68f5e89eb7ecce749ce660da7a63abe6ac46cc6b46a52401837e7e068ee1d9e90ea7a75f641b74d372c3a58a167bc6c90fc50b82a70062c4d6a4ab7a6d5ca9e8107e6984f838713f7851369a9d2d885ffd3ce90a4db6b19be6b7734b257cd40cda91ea7c446ba3134e489ad3a39f98f678b3adc550cc16af312f0600e6bed813325d06354b27545cd939cf83874ba54675d31a89043179e6e0c17687eaf60fe8b93ec40c26ba3e84a0d9b9ea2c7ba9cfb2747f458c0cb96f837324d324638128dff0dea7f3e69c40efb496f61a456158554242a88c17a48bc5277d3726b655041ac4510c653e504612a99866c8b8a8abefd9eae5b6105102917430295fe9599d93302942bf8157492aedec10e6d88c1a46daebdb848a8b918a9d6cd3873c1da3d7a89c339bb76d0f99297209311291b8e4b43902f970e9ea612fb6c3af048f43ae2164e04568899d580773af2fa7ec84b6b30450ee9d784867c0c2855d8d059a7f851a5083f6963608ede47f6bea398403610bfb5e924a70d246cc8221ec01f4ec4c1f57bd486468fe56196a246d7332d1faa3306e8958b91db393aa70afaf27a7457815412483ac81d9c7f5c0fff8a9fca44e0aef8e948020769a98ae4d72e5c131a919839366b9f93e8f2ce605094b2b6a4a1cc4d99b7c70056d9cb3058ae56c15d07bba0e06f9e64a7c2e05afc28d43f03164a6d30bbb72218cee979de3fb3cafb2d54390e928e723836910ee6e9ccdb02cde681d07bfa542d0573df4d4aa6a3d8f938a77f46603fd022558d5d720e482b20d5788005a59186bf69d1dd6a40b3df64a4c4049389e5907887686ba61b91341d6349c69c486557e18face575b37ba1b3657018d4c53c0ea2aa2c8436bcc85d3870581cc36433999ba7adea5dd0256d483315f995f39c51f10517d95a3428db868d7acbdbc62dac1feac64c3aceaec81b52650ec72260970a3b54d0d22464eb92b74e12ca862e2e8d99c496f99385e635e5a60381a3d09cafca67cf4b9ce2cd8f0c418ccb861b9df27004c3259d2e1be3488eecae543f9962bd26b1f1b145a065958e71fa7f73308cd013b72212838d7fb8fde0a79250d80555be5a93e43de4c1fa5b33f987d23ffbf50942f3b9f6cdd230e94ed26d8db1151d3bf5ed6450d309dc9a4920fc4dd3134f164df6b8f359ae568fe52b0dc52139c891314b654c7c23823820eaa7105adc7a537537bc14bd3693c3b49a7b7d68367f544de7c9ff1ba4f9c669d51d500071dca31b907f3f10fa7ca322e9643a77c7c00054db9821d4323d085dc8a17337db3ddb2979131b68ac74c530a7960199bfb64d18c3900f09462b29121e451bd170bb0db2b15d4a5e6a6836b5af4fe9775bc2a27efbf03e503586b750ca21da4aae78e68ea9e9128efd7dd2fc01f858788148b158e35004d75402fcdcb6b480dd15d7217d33940b03c0fa994b0df8e1c64e03c5bd4704106ace3e73eb3e69222ba49e535dca9f311eb599614255e360ee8ee5b5c400e75159b17ac2c317af896f5d8aa2d28352d254a8a56ca1a432e4b85bd35ced24e7842fe7fa6538a0b5a1b176c16ec9292277a1437d6134528c7c9b797e58aa3675b66fca0c9143b8f5ce71b69ded3f78a038a15fc1d9edc18be85b5cde1fb2fbe27b0cb5e24a5ca6d5ab774e3ae88f7a37fcb55bb14045ad5c9896134cd59a3c473f964ff8aab10eb1ba4586c4110a3126c1dde4bf17a8daba49eaa80110938d8cec2969f45550ec1420f6bfcf530fb348c1e476ae04c49f40efc563aa890c4b3c5020a8a519ad81d83f5ed85b3f5b524fd25be9b599c85179393ac7b460e404d7d5f36219769030bdbf7e58b0dda0efacebd1e10a35cf5a06f319404cd8be51cd51188cb9453f8ca3e03422b484b037a7a2d288d261fb05616922a0912faf3ae4cf38305ef549d1219c2f8e40a34410b12ffbfa030c0beb4f491f69521c7fc7bf26a40580b313b0709acacde977cb68523cbf8a8b9f53cef66c3fb6a58d3303ad34dbd83c0c439a9565917ecb14187b6164629f8e8ce020a918492bd0a2dcaf3482b8f90caf6094906877248250a731314e4d7c6a6fa2b0fc913b198423e2f2cec5d0b7458279ab17ce08c140870e896f427c62d711b5f6014d506960ee89d965b5d9e76fead71b29fe0690945c265ef6c779856a1c0475e043265a60054ce74dcbd35e67e3b91a1a686ce608bda3424e1b39967b7d9e00f81f04a99df5c21aa061679a11f1cb687269c065461f0961b9176de67a51af77424df1f095660b6510717f9095bc91ee604a04b655ae199252100850262e24a7682962223d9a5ae8628986d97e759c386ba3d6fbc394d8517ba7ed56b35bad836fcd721faa2233a905a709f782947d525e2107b963181013a7c1b169e7c25be86e5c00ef423614bb8eaeb14cb59a3be0fc79a160f395fa34a77acf463bcb970d84065cbac7b36ea65aeb67fc60c1e82640f43d35ed6f3568fe4afd4a4dccbd7ba186cb83ab26e156663f5f0a3e5b76826d1dc029e8f08f399dfa0773b19873a44820d3ab59e007189c563b7f63b426d0d5338261b72f34f41b7240beb32aaf718c5e86d14a3c69bde68ca503bd9ff82555fa05f2fbebdbad4d659aa9460cfd2d3c95578c85e07a84dea0b5a10addf63be45630e0b14106e6340e99023bc3cba217d6befde535a7d1624473617e0a54a52ab26ff84a16960bc204e2d068cc4765fa645cb7e96a4cae946fab4fbef589c0074874bd5f0ef92205188211533efea09e64dc5a8642745e93e80f2f617bfd88b1d71c44892365a69ce7e1f6a0b82d6c3eed2503ab86ed5f56ea2dd5865f3e0548f4585f4ce56e412c95c91cf629978a0379b6d546432be11e6e415ae0695d3342ccbe27729d3971cc173924bcdd01a21115c072e806fa8b1a75ba3ef9ec873fb867a1d00e1bb98890bdbda8160218942d435aeb06ae0ae3a7f0ae56114f020976a1f470327b69725ee1d21ae38ff9a4f0940d4e120e1217c232683062f90a86773c69c54ad1cea63cd0b6f92a3f5f422bcded8fabb307d46ff6dc6a77318187ef072269158de3d5249e1ad14d61ef7b4e08bf78fd7b03c48f821e03ec97e5dd36593486c249bc08a91ee41f94c05f78daadcdbefe3cf673c9c654399d66318082af4a28f4156a1573557413427661dbf4a72e160b1f4460531a3ddda1b307218c42bd00b985fd5b6ca2d42b9fa5f83d6a98d124ec540886363fa6da6fdcfec2c1e8fa891546485ee0a16573567fed021fc5d9e103cdfb329842bb4ccb75273a995a75336d75e8e1169f663d7fd97118a73c8887fb3f7d1b3a59d8a4b9c9b6f7c6e30f9c67689cb6199babf237d7876092c80d2bfe984aecc7e2a3885b393e7b73cd9b07cc508597ffceabdcc4be3128529763e820ce5642facc3cf1a9380aa4936db8cbfaeb43ecd78431f1a87d2ead37301345f0b47c4addbcfbc21502dfc4e1965b2dcf86a470a0ef799ee81a58605e65fac3aaa3b4f3dfcdd5722b217df18a68b372e8ac505ae0fdb22887043969d95894b9b294c9fcf69b55358423ef6ccc22747fa7d1287bdba56cc5eaf79ce9d160835f328e2fb6e2e71cdac2aa05be6a66a654addfcec139f21a353ac98542e4de45c4ecd438b074789f117297f5496cfe9c9b562ae4fde5cf651ff81663c3e7bc1790237d5ab0e53c971384359b98026d163893ddc02448672de3384c1b9fe2e2c33ef547f4b2dcb2147acfdc015bd1dcb50b5092e2b2042cefa958dea06694b445e10e4aa410d83e1d4b461748af408943b2396a55e76defa675cf361613232087ea5e8e7a8afef70d9606af53f51908e8e367cb4a665eff44f29a0f392e259085c113502badf436671fcc63920d62c7edfdd89d58fcec48a4023b6cf5509d23c25191149223aea2abb81759c3d0cf6ad8d409d1e75dd735eccec442110f170f25b517ba0127327afa9133392b2cb804b41ed8897b6c346698fcd93177a0521bab95d621caa04e3f0fecef9fc44f31115b08bb92d2264b97e2431be55db5626c592098ecb3cc30f6bde5de62e7d37945d08a1c4c2cd77d341178f0ae15f4fd6cc15fca0b6bcd7895df8ddbac3ee90f1340c809955ca1387bd64e225b06f3b70910b6ab37158b4c2a44165180b559c26d757700ef83e179ae0d49fd7520e63d2e4f007edbe1b6e920eb1d738eed424dfb6819c2560ff483dc7598d91047c27df558b76a59cb0bec8124ec6771cdfc3f90158f1445042b25b5c18c1fde3a267b0de8c7bb1600401041b43350a4eddd829fad57350dbf36da03a69adc99cfc862aa37b5500f3f35a17f3664e9490fbb07ce3a5863440c48a1b90002a0a0fe6d14bbac4b9d1a2413525c056b4fa1fda4cd805a143a7382fd3dba5701b4b0824c70fcaa457971e1459216b7eace91a3defea59b7a318e9ad6e3180428cecb98d85d3587036f43b5e81c7809642b84a0df9f926ec53d804bb2cdca87cc55a24823aabae530a0e5cbb4c480f11aa6e01288eb13d24663f3e4eb3d53f24f4e103937523365ef00d9ddf62d63ed2185856f650a9a217612ffadacf26f925ce7228fa118b8d208249e640858e2760351ee8090c2225599048a136b9d8a94498263c5d831e705cc62a5c790941fc21f4e6d7b86635b6258bff61bca05bd264c8e3db01ed1d383b70f78c699f8b06e372cc8f7e6c5186e78771c307f3ba7d2c03bbb04acadb85bd765ddbe4e689fc95f812eb67e04974383d2f65dd3d198d21824de138da472bdabc65b3f5b0fb021d740af25012ec6d22ac1fcc778937f2f4c54bd32813316a2c32603390bb199c01ae60566b6223cc96191f9e5682c659e0cb7f4a8f3d10a4dd06ba217f7b009330a84fd4492dbc4c46521aba9fec787ed37249692c64ca9c745da314a8053d05292e2e9eaac9ac26a0b50ad65f72a9b3145cda02ad84a11b1b2ec07ce06e3c4632195cff448c76247e4df6628c8c1993cd58bda79bce1be6030348c28625afb35b7f8aff5e47ac7dba940a9705c7a3fad103b32d476c302b115c508a15b084b015fbf643b1e903659e154c3ee72185d5c73d6817572ab57b077a4c91ea2ec0b08b3f557f575a77d973d2efb7335ed39bffa417023b4b85ae5b03cf3f6b5bf98d3979429930a1a2c2ed30caab2c1854961c6068a860a62608e4922fb5cecc1d4ef5b61a402c910ae288449b6879f5867298936587b8daa786b794b380192381f38e4de544b76569241936f6b9b728858215f4e6cab8bed7992c85fa4e0977fd4c060bc46fbbe20edeb4ff3bf7c3b2f90d780344aadf7b7682582f000e391d59c087dbd092abaa802c7ac947f7e08a4cd63edf06895b7f89a95959a1b5fe41221dba67d4de841bc1c93af8b814d90fb574b2d8ce473eed6fe691b30f06bfdf1e7ea89a4a915d29ddf3481f036764e9fddcadfa4daf15b16be2abb50467ba3e66afafb0c4251f9314b7d9f992f160c342301a15d2c750dc4c4411da156429040f398db908134a5e31c1e4961e41637c6842016f2a08aeebaa3253941ab3e3beaf0036fca3bfaa8972ff7e8a7a6b0adbbfdc65a03f772604f6ed23a0f3eb5633e6835d19461ba598fa0588ed187ec39f305d7f924479bab128e723cf173cbd810c26a7c6429f8a05c4c4ff326be8e2bf6f63ea8d241ff136ee9432e6ac8f0d68bf9175ce2cec4beab9373a876f398454939a428f6a380421a82113190453202b3ebcc634e4c5b747dcefa376469c1cfc336cc9b13ce4b1e7141fd2992dd92a0589b6547339164f08342cd8d36cf116d8b70e66c5d94ae22f696213917a342c683913f5d9b0426fa23032ab7a31e62917ba3460128631864de6cfe20a8550d9da5879321d1fa930718068776815825a405b20fb9529751905cd4d1d24f4a6bb5e6ef170463eb85a9d359c776d53f317f1b84683f5fe1703e3a1c82f7be68b62cb33a1ec7325e6fb811ce85c21b1d39e5941d89ec0e87631b572eb05e33027f33603e352f6a54d221fb603d45926ca72bc7293517116271cdd747d8a7dd66dc476fd5bcf2de64e91cca9265cec55ff972bbea023e9f5883af21b8d537e467136ef48929a314374fca4a7c6e97851a2056d8a527b607e2125eeb6c8c864b2b5df6f8d541bf97acdecfc6991d2c6e4aa5a55dd7733e580cd021c4a2a619ba31e5099ff1c1e51aeaf4305a994d82e78ced8228c8df283cbcd8f656fd68d441cc9f334d976e21d9627695225e4f04f63945cfea0865b4927d71167dc09e5ba0944573c37e0e4bbec68be540cc39f2534194b9d560a7d7b9b66b8bd484b4498becc30b5a7db5f99e2fd960dd3c1c7b85ac6938a8a1c2cd3de6cc0127f9bff8bc77318f816cbd20f02c68e9406ec1df82cf09062618492983276409935c18938e327206ce4697e7da4a2c3f505e79f579a5275b40f0b5d7d52540631849d27f132222db1cc932d0a8076ac28236224738c68e71defc3fff95c11a8f730f5cdf593967dbbc51a8789d86c20393bb6e04f222c360e8d262b1586c16a932b61aa9f2cbbda682033ead3588711eeded7a0db10c3e2ae0e9f7c6dadc3435ac3e5a213f004dc958b02540689575f84a8b9a37ba61f9f2a1d4e5f04080020279d75a625e9cd80b9013225a8a62451755f35d9e53fdd4585c9104bbbd97a5bcdb00bdf85d2e0d38febcc75a46d17205ab5c0b56d73add1c517887bbd0e1d557ae63d976642f61156db884fbf5c2c5a3b52ff63fa1309e0201b1fee99567ea37275a287f8cbdc6234ba4402dc8be2ed715871a6f1e923669e5f1180fea0b0dff8aa73daac386fe256277ab69f731171e76847340189f6508448c00ec02ba655c8f2eb451e62b28475482c6c97d02806509df5e0cf32eb5c456b7be1170d91fdb414acb2d9d82973fcabc6c5f415b798a1fddb3baad67e9afa27e768bc247a277e99ab4fe428a8e8464005696d928c4f8f731bad9f7044c3d792ca464566641513ae09f189b8b1186eec8c731ba05e3a20196e59512b375f85808d53f60d113942f776e8e5167f628e4217b516d037c88a1df719703ee7370fe25732a80e31ce7c2cbf27070767f09c40d65a65277d3ac7aef6f2f325f79308296796a6b6d5e31ed0cee132bcf4e600d8ef7a2f11ca02b73b8c7304ebd1ecf330c6285a265c4c7977a3e8e45b39161ac2e4e42ac0aa1b3d92969bdb5029dc98e4a6be47994529cbefcd1504d6aabe47ed91a212060b6b687981858e968c1bdfac55a6914ec90a2c66f8544e5f85fd9a9c79c08d727113a69135540c1ff8aaf336654ec18f250a50e5573cc06663fa712399d10d06d17aeb589f19f7fbc96c563f6946f7854b679d34d99913a0d0870df36fefb27251d461d29fc97675e83741051191684a2b8c9242b56ed36583aabeab80408074f8fda3b6bf098f340b7e0b83b8794efcfc6637868685e0fb470f385e976ba0cb5fc7ca64562e626d4d503b9628fdabfeea2dfadaf8755cab31cbc8953bbbc543a393fce19260f079e07df91c38afad92093547cd2852c2f2cdb75d9c4cf4ddd495d8a925e47ef09921b490e58c09b36d7679348ec0819b7537bf1ebb4af6f88b20ad684e67747b1f7e0ff4205e7c82fbd79546e93e13491ed9707120c045a26a45c321d5b3e5771bb5a6545ac018fd8f800765e631698a36323415552a48c779574d78e1f9514547a6043b29bcef391eb7b3aa09277dca2e3f24eec5a4ace2c83340f07e68a969edd26aaa7ca2708838bd85f04f1ba25a1377bf61b648023ca5c60f136a80197cf5cf418f7b8d255f3a6465d7c334b3725776fe9e0e012b2ad6c81b35bab487602a4691212400d2dd11206c59aa6d6eb6d512519d6466f9fd2d9a36a9cf16f65abd78371a8852e1a1dcf653798424eba43d9a5cbe0c398af45c1597fb1a0f0ca24aadf5e7269d9d4d42bc74ee4cb95c01f4dbc1780742c3f3bf6b11efdb36056b54085619686bf9f34e8f8f3573e6af15110221ee0352c2483fae7e06a5426b67b5bffed63fb456febd3d8fc951786442389b7d3363aca0581ddf0d08aa0d3e7ed791e073365d659c7665891d81273ff9f690bcd0b395b94c00c1575c6dc9ed3f7a7442b120f29916795f41d9130dc7b7ea0d04258f6974b25810e12014710a7e6fb49b5745e5ac1080dc48ecbc3c008db6f114c25da3067ecef8e9742a552bc583c48417d44d1f2b324bb373acf40154de38d6f61a8f9c6e374c8aa046140f1da7178dee5bc0f088a5f0653c76fbf018d4ea131d4a922ccdb904e0f2ce547be3b15d8476402cd684230a5dc82a291ec72f7fcb6efab2485941efa0a84d548a9551911bec1160e3d4031dc3e7ef7c5aa9ef00be0ca7bd70f87af0ee1cded7ebfed6ac9879da9bae3ec85cf9c94fa4841db55e5cbe9119d33275de43cc4d1320d4724d97f61943567a9453cec304640be2f02ddcb433051832bede1913c108ad043dbdc58a8bb0a8b6f5709645ebecc8222ed29e2798f9d388574061d01e01ae0bec0335a6fdafb270694c7884d5fb2b9b4f21d3342d3067a35958b4c8da02fe23305029c64fce395dcfb119d79987038088413d00192a6d19cea8fa9ee91d75284377a7c29b42bf4167fa94ef807fd4364cfa4e71f96478c4d3f976a574ecb3b22d5f8ab627e434e126b539682c5876889d3f3ac50c38d98c524d0d71cdc19e8d77a792610ff5cc68917e990aa92a4faf2677a83a81be37f2c10ea14ac747b111894d830035ee5ca74c484d75eda00e76bc66878852ff5c2e055fd2da97c96105af31cfff8fcf2d17c5e902ba6566fb78fa4a954e7134c69e00ac59597ef2b41510a7175c7f843382928d8e488bd2f841aba78daaf839fdcd25294c1d70a25","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
