<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"278cce471b1b3231fc674c421f95215870aa4b777020b440c7ccb9c5f2721ee50434baf4d77906e949f797e03abdf88c521ba1dedaa2f5617d12187526e05e3fec583a02b32d1348b7b08110672191a26d5faa99e99625fcbd2031d74fa935ee369bfaff83049bd1bb1f52e6f7e0f4f78ad4939439976c82ef0fca9ef16118f4d4bf73d53372b7b8a0473f48c7c3ced1423bb0dd2ec3444c6be364e9ac19a08241f2d81e6f7812eaa301f8d6961ec73905a1ece0a870a35b7138972ea10fcff715b8356b79bd575058dc6352f2e38ec2491f1cceb9334d49b5e7dedb26c02589f72063f80f360ee124eac616b2e345ecc2f11004df22d1430cd941906f2006663ce7976a6886092305eef1b6a304502948d39ea0e1e6b07bd5816d9730a03e696a061b1a03d0412ad9cf0b60fee4b6ec3661e4b0b9c600b4c94e6f9422bd22c1786a22bec1259f388eeae2ad23802eb4a91e9c7faa3a11362694cf0c29083a56b0a24f2826bf3942b3bf1dcd7980b9d8c884cd61ea60ea3375b7de28da2d03d7f3886c09caad234f6bc229eed09fd4e27b0ee58c26fd3aeb3312161b03db5a39c56309da3f8b9eee83a6fe439464c4eb9b8507ded491f45fa67355aea63fb12b2f475737a1b8bcb10ad8839098b35e9a85d084a4620df22999963fd6a0cfbec24561f81e616f4ee12dabbd598db91ca74d247ed31bcf676eee360eb0f9ccc6de6512d3a1fd4c9d9ef72e1b1c1ba9227a43f6b21cc241bce4b561aeba0e8deb4fa61608108de3df5b25c75148c226235cf6294ef4cbdf0fa7f10c29c4597a7d8aa07ab68b894f0b1a97ee842df7da24a0dada76691b13611a4dc760da6f67c679b8a23b091bd9a5d23f96e090c0f6fd6d83678dd8640d10caafdeecfcab0a4db5ef352aea9b8f7cc12dabbefd478654ab7f4a9b3c40877f45ff1156c22cc79f5df74a324b6b54c57b45fe8bc0d97d86cf0820f04b075c069b557f7b0cac28f46a3b32c686f4cf8ad63b0701e8287b04b543a917fccbc9bb510b8e0bd550a96d6fcc54fa882d0f4dd227c8985adba6c9b6566e53766c1924fbe787e53986e624cb2c7102eb6b8c2d940bd36c56600c60ed23f05274a879bfe0e48d30b6ef7e9e52a0e8df0409c5c57f8126b30145558ce342a4bec50030117092a7a7a89aad043c31af9dcea1b7d8aeb3fe46fa78915284341542e1f020c7ed07d4ef29e34d59275f791ffacbc59002100a71c21b51b6cab67c38bfb06051df70bf9a4b7a6cd44d5e0d17c8a067ad85ef4440eecac78f9c8039852b05c468bb6f067e3c6550e3fa0ff7a78e978dfaa35b9fe1790cdc231e5c76aaa92ca1bf90970356f4d8c0748da4756d2f0fdfdc39b64b55544bf9ab3e894e0d61c6893fc2c68ae8b914a29f8f9eb961a18706b4c2f679223fe905bac14f37fb74f0b6356647577cad6ec79e0499d0ad2903535111d999d4dfbf34ee245bcbea29b7e09cd1b2b189a87e9e78e6779fd72c4b815e3ede84c3200a46d9c86811b0208e58d8d1ad7f0080d61a4ce8315b61153a4e3ec52cc554e07aead67a4709052c732e6a970319c33f3755f245acbd8740d0c84b49f07a19d6fd1ed9bb5b3aa0ebb5d4916a34170e3a6d8bcaa5112764a017504d502963359fcb61dce1245da471f6a3e2baba348e58163c430c1f5be4ac6906e985bd2f499817842ba6937ddd3c9460b535a4b195332930f17c09279e92bd0d98be317ce9ab235a993bb0bc742ea962b4c62ad3e28679822d8f01e0c6812b055b5cbc8983f23bcc30da785dc43d9e1942060fdcd96f310a905743c28c8847bb87f50034c25ba518db186de8ec63c466b4514684e2ea79df605334f5cd80ae653bd9cd0de0b5e7332a7933c67f47632b99a9e9b28308ad9178666a1a743cbbcbbf19a8a772b1c9c76f458fa0628b9bfa5693fed01745272070b136d5353950b1624d000888baf2ddc8149cbff5d663f209858f58e0187740f8d5b65095d826086409fbc2772689aa0ae6a3c7f3d40192cf65ff4801b7062aaed02ff9b7302574a7eab69b6df57187ec5145ec8a3ee732c9bd04560b9801823faa6c2d5cc145dffc02950f5b128466dac2e0465547e0b5f414de84ee1f410580cb1514ae4be3bbe4e0c85161e8eff94357609edaa8d4ea7bf064ad0708029ad850a307c52dcfbd1cc0a243eb6cfa5e5bff23c83de8c3270122356b704abf712afc1ae5e685085b372adc85e0ebf233997b0fac0067920ef41362438175736e90fca7e58d71f28ad53fd38f49739a81c8216637bc311d13ca308e9e3985a7902a5f64501e3f4d2b1b9006215727ecb2479f826eede82ddf2ccb0a5909aded97bce6c5bb90dafe2f79a576fa18dca12a575f9517e716943fd9780d698e47fc536a274048bf84cdef20ed4017b1339e30a5ea2945fe097e73dc4956aeee498179c62fe4f5e712bb1cb32055ff1a1eac806c4593c56287a598cc2e2f20de58503773e2d6c130b09062cbafe13ee25b50e0f5be8b3afdb63f2a4129a8183adb9f558111ff9a062c822f0197c1d4138dc3d4b256d81367f19f93207e29eb34111dfa2545d7222650b8acabe0ba74af348bff9f1b7445c7f6a4a669439d3cd89f0b021d46120e3b2f01b25008c1d19529a8b0099e51e5dcd943dac55ac1c29dfc685163ea2f748609cf0624a708f511fbcb20ef3b65e3cfba3fdf8e87faeb3d935aa302dbcd1730c3d4f828f77e6e29cc991cd10484197bda5aef9e9b08724810e9f8729564a06d20203b3ec2fb3c4239fb9367adf3a82075df52ca10f895829d5934f9ad83ea18069c2de8cac8bea8ad4a7731310d4d0627af011885703137fd93914759f66e4a38d6298048536fcfad9dd4a166ffa3588191d1b9d6a84ba5ac48fdb3103ffb61fab33f0d8e24a7f68fc008d904082a2e74ae3396355a37f951f906af58ca86dbd963abd6f97d5353cb249f6817f548b52f5786dc294ed9584930ba9905a16534d41a9a42800909f1cdadfb4ac026b61eeee41b25e9f30c84167b5d924670308f974c3c17555e5511dd8206df8e01e370bed2b51eabe7daca47acc7d38c27f3e75db4b8a2b00bfa93b13d1bd609e541d391a1e1c157c4a1de32b325565d2d898e28e264958b848312ba678120e8dd96d3ca4377f31c3932883e9d8496ba69d6841ae57ac070d9b81d556fac37df450b5f74731a22719f113061933cc5bce62cc446206350c3ab3aeb9f092c1cce6011200b8164e6b761f7412db67e89819690f4b82f44f163260bdad14959e48dc39c5d0207dba08fbacc4bfe221c15a414011b8bf7488f40c123712b51668a0a51e2312a2e94b9c2266d538e5e2f70bc22b01e732018515284ebadfd21ef4c13068658081a7f6acc2b58963925eb974d9017fc005a47d3c2a2d5d598837a2632847156b09a3d3cc68b9e464d2a4a7d1fddfb7b88b6daf0b27fb4cc0e567e03b665ff6d0443dfa1109add42fee820b09dea8a7860bea6e343ea6eb5116d1cecb3f5fdab1794a6eddd951dbc01a3b1ad2c4c9620a3df60dce4e2c2b23f35323b9f8cbe2d8938aaa5516e254b6523f752e6298c5a6440f09a388509542301a3e3126be036d7e6b16fc979465d3d83f715fd466e47cda5bc17139cf3a40891de871375d9cb6526337680439252e0e134b02295cd09c448679e67a3e3f303c86221f14715b2f12775005b7c4301f9d0fb714a66afa44e982de0887b265105b035d9d750bf50b38fd117de3805d53e082f3e9c8cffa1477606c38c45ee2f81ebb7e9795bf1d72e45b22f4184d92a3dfe2bc0b938c73cdb06287affdf365630e2a263f8d6afe7a1ca8ba9c7893bc22ec586d79c586270826f99cb78c9e7bc91a281159bb64772caf9b22e1a8370a2d023bb27bc3e2256a9ea51ff9f1d40915cb7a1eb08b7e7dfe3f8250ca0a2079516377523be1ed8770dd034bcdd7e62dce8b4b8da8ab7b721018307554252395c4fb23559a9a7832e6fa80c0c5bb553f5cc8cbb256f2d6857bc762ecc404307c76f0909c7d8b97b51f976a6812274e5868189faf3cd39f867d734ebddf1036b2d64ce13d723c7f5e306c9555da34cb4f781c7cca394127e630f586c9e444242705a43093ac16566074908f6ae8482c1c9c0ce2ab1ae96530c6b6e2d61ce4784b5fd3dfe5fa492dc233f9ab66064d215ca8435cb22fcf1c829819bd06e1e18313e53d08da79beb70a735bb63a5bf9d25dac004c6dffc3473e256fe8e258e7b89197db01b45af4a0f51eb394e4666a789b8bf277c56489bbf7a30ce097bf2bc3200d2eaaa9005612357c745299f2b432eed92d266050de8a445b1e9519aa7b29a4516d153e50616728ca186b3427f905ab065b8004fa8741201313333c75b5ce89fe8ac858b8c959db5b1d03b8910537696353add09fa3f821a0d5c612ee99e61bc08b662a40b369bb1d4cd254936e70c06da82d1526d0054323bfc46304e2256f32aff758e4097e62b7521837e3e711433c8d535ef2c452e3531ec013af0a61df5f7dfa100ec7ab0fca2efdacfb7db3401ba59847cbbdf5379e12f9250d5827227709d4f6bd357748ef316c3f68f724d4fb12dd8fd8227b877551d5c83309f27c27bc77e42dcbd7d9e2d84eecf5f9a6081c961e2e5890787627a6028c4ff112b7739236c0f63a172ddc748db625c2cc0d0d6ad64646cf88cf861c78895c6aecf812e227b6be3d70bcf0fb8cd43b9c54380e58d3abbc65b59776aafb7f879bf313fc8fcaebd5774ed6820ee51f886d66622ddbd908909a2e7818c4c3fd46891be2c2c826eedf29725735c6fb6a8bd87ed0db422f1a23697b0f044c4661ba950a1c42038bf0bfeadcf8c9d1084af3f2a8fd69dfcd6254040b5daeb68cc51d578409fac80ab906aee7e624aa6f3a03967c69de1581e115364ce679b814c3f718b7787d321d3a9d8ea106a10b1e1e4231365d5e92b70a73e371d08b37b47bf98a3b340c272dc28502392c5b9273d3e418dd988ace5fd1f152960c91da6b71915aadadb0faaaa8c9bb8db5276ebd2aecead04374e6fd42a3d9ec1992c00d3d3f14b9cab9ee5c3487e08954200b599182376e5216557647ad57d8c5e9ff49fda28b0f3314d0e8ee7b84490298edbc6fbc7d9b597feb24ea2049f93739b84148ffaf6e6037901ae323b1b34992721dae00c61bb8d3c6dc2a6ed307392ae7e312356822a2f937660ea74eeaac9f75fea1aee354f5883c3faa55448eb1670003fe07fe36cc1f51289b7c2db4c1b9300536517709782311d93b525ae17b149c918ed2452043dd0908f8f881bc8e73d624901b7fa56f0b0122d3b7ce40548bdca4253101743d480e409dbb395073ef878d7ca6d18c03b105bc0f38529fb5127e09004fcf2cca0240800d0c7aa9e7e0b3676fb319785679bb3b64658284e977c065c7bfbe55edac73f1c440d9bdd3e963b02d424f6be955808c5b13285577af9f09b5ebc3a57cb89080b4bf62ec9c8a78ba3c2260717878077110a385923851ffb7386b40f65d7536c54d537d7ff23c8f1fd76d77fd777ba5f873774e491a3241ba49482e8ff40ad206d9c7b72d85e58737a0f0d2323bd1ef6a9fb54abd1d95f0315cbf5392667d0bfb9521c5a9d836d75c157770215b6b4a89e254a24ec0fe3bef79941c0a338dc380d9b12bab58f4dc81dfc223efaeeb9c08c99a90f07f8b1253727374651e9d1691989c3cf59645f1705cb9adb800ad03402e387e6b12567e833bf5ab607f9513ab9f3994f3dcd43f2627da64e3cb1e04aabae26488da626e751e47e4af1f0f5b7daad7d058073e87e758643b9073f0fd7ff1aa9031c07c8054c454c83a411e0865c3c11a520f7c2026007770f5198affacd6f5822668bf38f169f9f7000a5bbe995e08dcd4e3552c259ea84bf262b1b65a6e1e4bf668c13a0da4d571a86d86f52d8ae0ce5f933755fb92595a5d77753b0c48c3f4aa6681f86765d9fa03f238e4f0731b58f726c196b8e3ada645922e04313f778c3ba79481860d16f122330afba381a8b81ad639d40b7b0c378d386ca6952529c62de4f388573ab0387644be2230b0d0240f145b6bcd1ca614fddaa28817642191a7822965a9bcf8053a4f858fed01967e8614248ba4d3ac52935914721c789ef3470ae76f63ef132a0daebca0e699327a3ff001281354aa946fc297ce30bfd3f6592b6ab5ce956177b5ddc2b2b5986d18f669ce7783357988b24a4542b1282e7e8f88f81e6d0b393be34cc68754ac0dea9c4acaa5d2ae031aca7f2891e3c2417b34ddceea45efd51f70b5f9a995315764697a244960b8919ed57e12496c7355730f9fa669ac2e6a3139a88b0f0499da27795abf1e7960e97e4f9241ddbbba2363d1f42e828e55f73f36e4e8ebaf2301e30dc472e01aae79cf2f9e72f9b4a5764c88b93c07cc1ca8da27f148e33dce3133a36e1a44529a2eaa97b956e13bc59b4df1dc03ca80b1015773e7a48d012e3c3e08d7e5e29136ae787c1214837601b204d7c6bc051ab32c9d3e53c4d035521fe99ec930b9eceb823c92b2315577ae57e033512f38e84e67a040665203c062942db06e1f1ed77874e87152b4f4eeb24df5591197f5f132715a184191914d107659307770acb8f4ec5b307d2fa15d0290415ed9d4a99bba9845e2b260a088c64f4074f267a95acf531b8529533212e44109eb820139cec0b6e72a094b68acaa681f9d28a46045d11860cb9bc21eaecbf3c6e825a9e43c87ede8fa2b46c744006fbd3e4cf0fdc5af5cc9354fa92a7b9c22f306afb7a2f1e503a7bb915dce21610e9d80cccda3f76eccdda690cf96b819c5044e160a4485925cd0e6c1bbf0b3673e5c39c8ebfaa3e262ecde145f0c76f8414426c70353a6544e048cbe9312799546d421bb3bb9f37ec653aacdf1fca3d6275dd492a9e73514efbabbef72ebe2eac2966c646626a8002703be3d1953721a4434b03ba6c7e14918a9f63148e9c1e4c386229dc651ef84018b0536d1d76571146c1fa214c6092f14c8043e1e2bb0dbee68097b50c775b5b57be544547f31f581a5060338bcc199b830138960a2818f69056a0d08993cacb47a5d316f990d818a8fe3023f99304b196bb3fa818488fffeea4915a4961e25c11c0a51c6c445c3dde61ff86d2313bb0da65713b72cb32ec6f3dc624fd636ae7eaa2387719fcf1bc55d4325710cf4104941468068a5f44276b35fc36f3e412625617fe15aa611f6d92c1f46437623dead479185997ff3c6fcb5efce89155ff1657c421062c7363cfe3446ed9772288b3b5a9568b43ccb33dfd780f696449f911eb1f90dba30000e8799bc2547c13a948d7ac260962cb85887d05eb516f4fadea5336ccee38e076b3bcb20266efbb7fc24121d38306720f6572b1a933089ff4a79e4cb8fd600d10270b3577b54f7432b03082a7fbe414067eba7c517f8d6d24f748ad829ab2511671ee36b884cec46c148dccc4e6cfa714386e9e6bc77908f69ead748067335683c4154897c98926185c8a23511638cd8eaf845794cb4afbd9fd51f82cba43e9558d1ac3d2b3506d69305bf09ab5b10d4d45ff06cd1fbd43652277190d42f377a5a180f1d0b7b5fe6b26247185b82db8f890f9db267ba155f4a607805243cfd28ecc416d9d677615f88450521bb864cd57fd8dd025136d567c3bda51d2089e5773eb4b8349336f79852ff4e97111d8dbce38a9375a149ff3d8974397a588e5b63785ee6931994fe78d5299b78d53ed028c8755815cf339c5710f8e9e5171e0fb0c98b5855b88c5f72a83432a5202542cc5a8d2af62ecc8cd04cc1717fb045359b88f7dcc514ee548b6c9d311dfb058877c9f34aadae25a38518a5ca0e559e20ed5c10fc2bcf4d8e4d22359e2d9036d3b89b30670e95afe335862ff38618c0113bb57630b480d4a3745b4a5559a0afeb79f82c39e3d49961fc9962ae04d1b963628b2211ce294bf312f99acae39c667d1909d8f5dc9a56c18fc2ea434cf81539c360c41d9b338c2bff4f908f10bb622455f2c9dad6d806068a4a23c98fb8688c77367203dc55fa45565a18f1762cac27292d89bc62b71657da5c93c2e7b6323aea6071a03f487e07b8cb56af2362b4d4bfd796f90fb54b2af4c5b4e87322ec7e74cfd85f800745966ec8d5e7ff758bcca69833a71e3298f731e63e3a82ecedd406dac56e0052feea53c7592c7df0b58ef9cf189ec7b69ecc5a1cbedef09d2d2373fb96621a9382e729715d5a9b7dcbe89fc1dce8666e4fe9b1c6c9c5c6a83eacf338628f91b5730e9ab5c97ea48f42e8ca42617ecd50160c463c0992bebab85e53724de4abdbcbe8a6dd6b25ce6d01b8df243bdafbb18b56d739e0eb003e559b1bf0c586cd988c477a481f3413e489bddf8c9936bc8987a57c711cc4adf6f9b68cdd1760d361b8315b7a0e7dfe5e7458e94104c06264f5db916bba5787e4d8106d36f9e2a8353b9e6f2988032d1e11a1bc389c80bb2db740cb283f9a186cb7e5887779f954a735477ebde33200cfb71ba2cc73d165c1340227bd18526f4a80f96302eb5da5befe6e2f9d0f0e1d184ee7dac093e1b6b9a639962ffd222a9a40a1da9f0475bababcda2f4f1a5b00c5b5d7f0ea21097b4b210bebdcef1574ea6188b42c65587fd588494bb718862c80f4a6d95470e9c977d5d22d1263af87b818e4f9f570fc844a6fc5a2dda92117676bc21b2b1e6f8848c35bf19af7cfab42cad4a08c99c68cfe7fb67b42607913211bb9f05b00d04d019635b4a5023724b301210bb2a410ec1430a6c1142f483948beca3c01c67e1bba72411e8bc081b7cd17768a2404c91fb7d1a417ff6a14ec4109128f7b6f5f657f2dade4b7c5afd3e36c95b1d0a5bd0893588ec4d8ea36d54a4709a687f9c425c727ab9c10299806d6955b46863b5a6e5cec00e197d176d03c8724eed5c4417e688cc4bea8161840bf00176c1c09783d6dd483781b22dd44d2623cf01992ff726c6ac177206ec9ae647996e7ef04792dbd68b09af62b21f146bb353add51b3451548002b6ebbe11bb7c43838ff8ae5a3e458e877abba5cc04554daaa7fe898bc6c1ed6d8561bb9a45db6370bb0c735bab102ebd9c88145166ac756d6234a1b4a5c56eafa4f8dbeba0095a16176fbcc8cdd031a884e5b7bda7f3a3e207105cd65e66668a92cf7b8543fd3c764b91e4a738d4803834ea9195f2ff585258e1e76148813459747b3e0e46b6500998cd8d3eda3539c0add8aaf70fe7a399fb4e179531ddc010142380be661df7a84a4bc9dc61b994ec5b834a7831e7355b6f0f6c703c1d7eb0e7a0937f6ece58ac932db21418b6fdc01cec3e86a82e7b71266d3dd219db88505c6ce2d7538fcd0a96d49c99a71aef1c7131a75cd96436f53866ec7299e4dd5d9f8da58cc84f503eecfad11a61cdfd488547c2cada095e312ce591e74e48579edb1d78de6e8b0d7cb03bd558042d06187543f12ed51ed5ead3c7d87f8ca1e9ec878fb07aa13e56c2d16b7a5dc3d03e03802c92340ed1fcad0ff150c02cda5dcf53314f7ddd48c26c55ce9336342588ad6231c1aa286972215c94eec91d7352d8443bf14ed759e52132759a9c4598089170dc94a447d0c157a4f6c389b695494b10a564d0840e435bdddd2381c5e5473723df0689201833bb0e0b8bb0e6e5b186c2d2c80e52a5d8919846330484c8cbb130623dcad5388147f9dff304e101be1ce1f6fb271f48449e84149ed21aec994be1306247aacf91f83c0958b46186168c9aa4f156f62f34c1422cffbd2b2bc0e19f27313044c5439011506474185988ef6642c82a154d235da75c09bf9377db46c1c5effe9d69b813390ddeb4c5a51122fc469dc9ff5dfea2c007e2270314ce5e9d148cde20bbbc7a8c9159da7a8402800230daf2110ef7754fcb46f29bb6bc82e19e5347f4f01b3a1788abbf21c46a04020ee28e21be1d148d1938360ffe526d8cee24651300a1b9b4944ccba82deb46ba5477b1cb6e0eb2a9f3b727aa39d624fa5dbe116afdb2af2f8e5d740f745202607f2d82276362066489d6772b127bb5f6f5cb0165a208758c097614ce5b0fbee4a5ee8a3a3eff05859c4ed9d24b251f57c72d8b565a351f01eb4ba459fef443386f9e75840f51777fc36ec5567fb3a397c2b34e38ba2eb0723f9bb909b0fb3245bd506a15aa1b9dbc5d205860a873a326dbb7153fcad76ba0c43b0cd1ca458902591a867043d8615def8275543ceae3b8e92e7553eba96a8c1494fb79485cf81b7465a9439c71b33674c93d0fdf919ad48125c107b82ff761f0376c49e9861469303c1fdd3fb5323abeed194ea0fe91ea18fee6c2f5b182f910a9a8061dde09d36fcaf89e2cd0e844366a083d8d1696c07a8713c86e5852e3ac34b7395f469bc2877e1996fc13db6d8831bc4f00453ab04dbdaa43854c622640411a5211de5da7a34d1807f605f3ee9e4d5f9d080268bd4ecbccbb651e756498d45a06ba9fc297eaf03309b09dde0ceedceedac9d6f1342a92e82525085228e5160fa52dc8ebe81b1b1d2ed2d73daf8446db3bab0b8fdf05da6c4d611daa4422232c5057d141c5fd4b77474a2a33a63f0b573caea8c56f957bd304a0546281bce7e06009f3d43db33193362d09c2b669783710a6fa65345c641afd267ab535df1eec2c46a5de822fc32dfd2797e653d1750bdcec1977c0491f07e223a4943926eed7743ff83a61abca0282fe8fa77c8b157da6f2affe782c5406f968debaa8c6b017c2ed74c5d969322f1c84e8ae397a1f7a7617ba19ea09708ecd26f1ae2d7bc527c4e87dfc162c12cae67b8f3d9d021ad1b207740a29f2185f998c034c5608b77af1998a6baa9f874306109947c58823794598b67d0df163bf7932f07516a102c29f8517243ca6974090e1b18306ae0192691b657ebbf01e7c7234767049010d6d9e49448a21a4edb98fb317740b8d9447b31d66008b1ba943e8f248fe7f702aded883a914e6f7dd115ed8017bb37a10d1f1a08ecce010fa74a1c074eb17d71826d2ce94ef0439792371ae1276fc2a21a4398adbdf7130accfc025b4c4f49c91af398a75d4d298780d55f94fbcc4ef54323130dc6df8843f41beafc5efe4cfddbc38b7db3cc997b12ec73ec571a98b694e0a55d38ec47f07408bc654876d78620f22ea571f3b8a376b0a3880a2bdd3d35c7e6a5758b07aa42247bebf6c683ad6c6f4d9131e4a88c19b7d2f5fe16aa5aade613c22fb56920d5c48a25e07315a3eb993d11d95f193991905c490e47ca55b0f02ae9c4bf1590ed99e68e51e4ecc95c9cbed99acd4af434f2be253213686da9c9d61e579843268ddf2b716df67bf284d8ac66fc98a1a3e4c2441c54417f6e43c89c00070d2c06b511d32817700117426e5ec8083c1b74f50ff4a11ecfc7f84dc622c1953ab34c12bda64bb603c2b6180de930347d1142805f4b4d5193ed6b886006fd81140333766a70e46b75fbfe1b2ac78a0f89019ef985798ca2b06addd467e8b518b73c86e502094c52def139084594fdf1190be842b83b4b487c37fbca218ee11af575f3f9e34d1e2144e287b1ba3f844395c969d06c2770859dc870371c32883222e82d87e1aab4587d3d01dd1c98f77bf4af2a9a81280e8fb48bc0ba33cdaabfe758896a182e7b359b743db25a5c9d3f9609f00c865afdae340cf602a8cd5f08d93a159f4f9135c4d9c7e2a8f241ce106f8e38c24b9feb41d4d2b4e1a452919c0bc6eb93b812ab981e2886ad93b2baf3849f7c442379ea50d4ce222c1f0f231ab3ce1ca9bba730aac96472a3de281e611c106f81f4b7e1c7faa297fed933d2498b9b0f029ee012a6e85791f887db6fb5c77aa0c513aec5e28c0399c4b2cffc21b21ef44975cd53190966eaf34841f5c980d09884a7eba4bd117660714ef5e373663515b6a497ee5e780e9ac1b2913e721c99e80311cf2429121a450915e773b2a8c1a98f305ea94ed9d6f686b1f0383c59bc6c8f0cbc2fd115d83b51d561f04a9dddaea009ceb74ada342ced456cbe68aad4291dc630df796eb2ae33b997cd69a95f86ef9286d8e2e1fd5b213be851011f432a38bec157f61a7709d2a3096bbb85cd10eb317a0fce70bbb552c22a2bddc90d5a35557d1b7b349adab3541f61f3deb908c9b038c6db6ce3689941330dfb17fa9693dde387ff70cf20ac5a1dfb0e47431ed46d76d31f64b7b27656c76f76bba9a7fb31cf39e3d58dd78974654f0666c5cc177559039166b569b051a5275e7b32ddbb3d016783c656d2937db052d5a5517c8d7882dbc70cb567ef306fd3ee554e34bad85272e77550be36e0f8b750a2c2291e919fcf94b31dce54cd19ede542d5565699b82078f1fd930c273552d5dc687f29ba7ad0dbe573e44622bf41f3f87819c27e6d212352a32f6d654b0afffad1af74ed56375716af9edc214f9ee2db7f06e9acba3b8fddc5252afa3ca88401d9015ce533e3d7dcf4e8bfdc883db86533049ff18acacd6b4d64f64b1dbf45e76bda91cc2bf6659d57bcf79f0517fe27f20fd2f6bc2b97c7b2de19aa87d7183fca1641480eba93225130838e5ff8b3b774aa5965d706c3abcba8274d73b31d521156b7e003110b50cb0728b8499faaa37a6ad4ef59a236cdc4833343fd88b71cae59b56e4f26b026a85bfc36857ad458f029ca1378d50193abd4cb5444e5c352f12b95621fd11108be4ea6592051b2d8e43c027e8fbc302fcaec34d8a651184db0a0a17d6af731174c9f465cf9b1a586a3dcfe4c616cb695a899a51547c51355e9791faab46319134441989d66e2d4c7a2e70474cf9f5a7df5af7125bf0ce68f523461ee90b96ebd09b76627f80042c5f3438b206d70cee48b3b5ed751355817f35bb14e9b8c927d0344281e95f9236cbb8094f43ff82e142ba1dd7f6ece3391799e49341d64997358573e49f14b2237871995273b5d670845c570c63c14851de1068fa8720aafe92ef970bf5c458684fb65436f344543e55fae3ba323448fc62a62aee373f9b604778f13ea12c180b13a6cb7d1b1e0cd0667fd0251aa4849a8f0c4f5b9961fca4cc4a1d8679a0f3bcf6f952829af5863ee6980fa745f01a6dfd41db44ef4eedfe6f64da57835ba23a461bd7d6af46b837df1301c647c40ee449123c94a0fdc38c8447227e0d11342e9f316e044d445273f37ac1856fe161dcfe354fe9357afb90fa942ba957a0bf5545fed1c14ab5f0a2f5d331b273220d24d4fd9be466adef5e688f45c48f5f4b6b9d19d282f118a6849dfdfcccf8735d93431e7157fbacf0380477429c1a77c95fb96900f17dcc67f6d31246b6daaf751d5cd7d583146b17fab2acbb736bb88c22b8aaa1a224a3dde1906eea903f712ff1fe6fd332b696c51afd5458f8c84aecdfc77ad67d1d0db612ef1f5e12fc93dbd1d7741b3d4f71746971a9c89b83cd13d67d500a1ccef2dcbec1ce9513fb29fe5f0816f92142cf18e52d23fbde4f05565a64f9d48f27b2fc600ba9787574fc8ef1da49516ac6c90f1bbb1b3303936754a7d7500bfdee55f81dd51c53348da3953d017628b61e39a7ad88047338045b545a7193fdf5158be2b284a855016f746000afda647e41454975fc15b736f5d3d4f9c751922e8356dea264f41c7adc8de470fb7e76443a18cb649a1d57d77e5c2f72b5f3e57f573dde02d235eed8e435d4e5998c1f8b7f5c62a533539a348bdb99d2ab644c1b1a55e8411b7688e0dd6a2367d81618710d2411bd81293c5861010dddadf77d610ed14a2b0f4cecfc0216a9e0b1c12449a5de5ea34ed4f55b14f6d061852880b5e00f87314b01272e327a24acb09ad766c6a084d9d0c11708dbd6bb1500563f315324830adeb5062462662be6c8069bb37efb04c32d8c2a1923be4df230904ee53af7ab7ba3f3a9dd3f990842f64006a30131a46a50dc1e0eb850d30960925dbdb402f41673eca23f72caa58e020a8bc604bbe5bbad39fde18509188967bd21f8452835c275ba545ce6b2d9754731726838fbaf9d658a04c60139cbba2a87d764ed3f99b4d17f9862fce72858f87988f2f87f9c2d6b8315d8fe0dd4f0123dbc352af817cf2d311ccbeae62207ac8123dfa0a9e965d15d07cd67c1d5e0a06292e4d2318e920f43cea9e12b14a8c8f7cc1fb9139f19273c03d28de12d830c279917998603db71ff02f079bd07d9a35633e365b28da0fc7a74b4d22034c44a320fded065036b78bb057330781a24a28de407c27eb94c742f928fd158b2ec223214a739973ce4c731bb9daa87fb7509bb593bdc0917dd3e1abb42cf3441a98bd87acecc963222220f7900556fbfa0d03ad9ea0e3090eefa320e2ec6642f858755af1fcb5a12b707f2adbc03bf50b6abcbdc559cc17679cd4e3b7eed288f713f8026f87bcf5db6b7204d03d6456e509c7c251efee821789980c5fd0e6f9321976143c570356c8d43b48da9742d7fd3b76d119296c46302abfd25faf5da3e75ffb87306afac68afec0e07de25f81aeb21e939b6d696fdefe8809e2725f9acfdfe74a1d1abc3dc2ccbc02253cddd949a2eed6ef671bc985099d7365daf438c1c2ea8e851154252718d9c23c383f945c59a49aacc39101ab9369669451657fd3fd3d9ac519e5f7e32e353edbb9adc87f71dbd15054cc0e4d8b2bf72c278bd3c655d885be103820801a2b43b13f0d6cfe870d4007dfe4f1674ec5621c2522536f18666c0bea7503d1e82fd3b5f63b90fe9498f6c1517032cfa6fde44303f7ed001e9992f7551927ff672437a70493b23cf47563915a930551a573dc942122f695dcfa02d7cf5cc763b32fae95686384ae12a88f9635cd550fd03f640194fadad146b6ec19afacfa376988a27d5266e1b5a8d84654b8955b5a667ce2f280f338a405ae58e16448b3c0ec521cbd6d470481af325a5fd814e16d37049bfde61964d151aac5dfda761afd06a63508d6104181837696091d796df734a88556c797c88ddb3e86cb36014754969f40747a67774afd47e438bbf121ac71fb88a9b724f056a78926c4e642f77f10ee0c9dcdde259c2e20006b19f96728284f3253ace68eb0ebdc982be8b43343487b98b14f275f7484eabf69f73577d47e161f478b072a0ddfb4dcb0b0975ab81f76b81864d85dc8816a9174e8415307fccf12f9fab03d0b8f493c043f025f1544f2cd533b28476ac8a6596f474a9d9c40b33fb87b522c47fb70dbb901d0347339917cbc3f3a76585a5cbc565fa19244c350e6990ac2390e88d22d6625501695efabd5580a095b38657d51d466a6bc0c7b60938d6c5d078852e93b60d44bd538b4b02874e6201bdff21e2769f12c048aa2d3d999de3c445e4ef6ba24d28ad379c990fcc17a0921fa90553a883522ac4168d83f0be595fbb52adc710fc90c033e521ef13195aecc5e8f079091bb34c55fdda7daad8ad7d9a6323cdc6b4a86b853e403c9379a4138b03da7b8aa1bafb15316d95ca73abbe4e9ea5e9b8df152a25ae3beb868ab45a89c95fd4ff08c661d2bac5cb2b19eda6cf38c27871937d76a13ad47d7d26b15bace726eeb431e56d47bf9ef8c8863281ea6c8412f266dd3783d6be7d3cfb4f1a7144cf2d6a95a57a44c43474947cd527660050fabe46b6308464eb2c332e57af0002974d90b05dffcd7aeaeaffb55a9b0ed02a444df893fa4f86904ba3ed664a9274c82b1c3dc574313279629631ffe94fba3885d05d13beb37c6766af07a15f2c2941a33e0d17660d2e4b1efcc88daa324b3b12abdf4e596af8aee132489a66f96b01e01f017bc7fc42284d4e90a5206202208f3600edfe70acbf7137f14c1513884eacae1272c694c6ff6dd3b7debbb3a09e1575b7973a6ce195fe8d59f624b721cd20a7b489f16026231cbc6a1eb6e6b7484745e90300917194a8ec6d5995f28f8526474a80d3948d5df57a9be52de2ff4087b1ac128e2481d18440db67a1d52ceb73a8a5dcefcf95b5c8900181318ac31f7cc7c0d2dd3685a028a8b462aeb7faa857c1225e174c411e0a6e608c135e39d0124dda40f75bbff25fc32a16ffa2bf4c5885b73ca8f7a5174aea962593ab62528061a3ac7d5a6caa60d0be8eb6330adaa6476971832252f35b70883cc05c1a326fcd5086d9d9c312542691999836592fc0152dac1f056091d8ad58eb96169b473409b8a7708b893cab295934bee25371272852cd541f06159b8275598308b7fd8bff58baf250a7fb50db2bd93766addae9cb21c1fa3911950ad668dc9d9067c98f6010bcd25b792b6953c37972fe866fc349f11af1781302d39de6a252b6ebace305b3d64af25009ea3475049af1e02274de29f340db618e1451512b1cee4d5672d275809452116c996bca44f81a05650e8d68559617b7dfe94c665fd55d2c76537425bb46689b7e0026671e982e326365d97ad8e097089c9dbb3ffc493ad439aab9dc0b1c6bb4745db5a3c2ec5e51b51ff8857ae38db4c5b6af93fd8ec5a3a8f42918f9e37bd20a285d9579d2f5f8addf2d204f3d31c79d20b91c95fb81dea2ff759245c26edba9a7e805b7cd8636ed95da8650a0c86339d02eff90c3324233cf3ffd6c8fa43f9d97b88c7cc383664dc4781abb3417e022f9839823466ddc3a5f0571479b461c1ac3e59bac5cb24e9fc3953816feeb5d539dbe8a5a690c3bf1e07cc76a027a4ab76a65ff9d311be42f1fe0fb0ae4dc69018c13a3fd3294da345dc32ee2623c994928cccd96e9e3bc9739c0d6f6fe34f0670eb23c9a841512500db0dd4056b21d03928556aa82273a973b92120f9f28b04b85bb398b1d1573d50b7a4442c3c0e545eee86f4bb466412ec0110bdc4a17e8ef851dd7365e2570e074e6b8e48bf1651ddcbbeb19160c25dcaef69f9fc5dba0d63095331f21eaaad3ea7c00316e40da8aae67f84de7571a26780e00916be4753b1b88260ec389f5ea196d7e84d304873f9e29eb59bf04dc8ac15873c5edfd3c354d3b66ebc9cfd53f5e5720c870d66baf1b7b37138b3be22eee98fbd6986befb40db6c3abd3b192d8d250e896022889a9b1fd4256ab31c9cf546e24218177edd387a00af0d2cb4d8f71c9ea36c8851d870786daa5826107a0c6b1f0696740a532b0306c349ae40494f978bdd6e2dae29c18c1496b81a3372d8b4951cee55cd9462e35049b570141467923115ff353b2aad40b8cf7fb4448bbc8458a029dc15d889616f767a088e0a01dad2b4a89025d374e7879f089d4dfb60052d42159c6404a8642d3cb31e1f2c1c2356a115c157be82b5f1df2d89c522109718fa5e20be2a4e38985c6b6477ffc767e52e5d32ee1e6bc79285f1c55a74dd4ed350801a12dd02891004c2701d4b6b2a90870f43ef2efa0d3dfeea507eff051b4a1c0f86a98629f68cc990c006199e8242e955c2438793e33ca25cf1805118b6c969d8a304ed325cf4d540c2dbe593ac61c1adf2e8804ddbcc073a2ea16bb0ec37c13393b6163d863a69cab0e65872969dc4c080923fde8a28bfd684c97926827c62d535e2785047bae4ce4f350940d37de28cadb5d5f6c5045f5d82fddc94f3fba295c4449b3c7abba127918b59c24e0495b8f1938737f4f791bbc2820c292e23a8e4ab156e2a0c17ae076574a56559ffe6757e0b6cb59a9a8ed6e549856d8369f4f546e41f1ff4c7f68fa0e698fc1d87ae3b10611eeda35f985297c58ac0bee26d2b58f4d4b455d4be2f05852f950841406d05cf4d92e9dc0455d4ca95cc075efa071fa31e78478df7b5da710ce11b3de4adbde4e07402b26395d07299912816c2f27d6f499f50364011a11f94c7045230039fa6eb589bc27d6029327a75609f4f2861614115da410eac720a32b2b1401f8785d331743e8896045ad53ac26c929923da7cff0d68c8ef4f1a269f3078c5f4516ad0eb8bce8b11fdaf5217541ca72b10570ac4a0c09e6c19eedeee2a4ba40846abaa848027167fe6ee6d7f59bec302b1eefbd34c50e7d942e99591ab15d8e772c4f42daec80c612efa26d6766da8cdd0fa6d011b5b35fa20b88c1a5b22da54f50f3d72f51019f1a5ac37bb80b5673cf12f10e67ffb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
