<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc50b2d984a3f75792d550974fc1100e3abc5d1ae3d36f21c6a82ed8755fcb0efef8c70dd7bdd98faa820d1c3d132626bbb4b1d3a8464e4b15f9d72f6157ac8a2dc844d6ab8709e4a2ff7092dd1393c2eafd71362f871ba7dc93fdf6ad8dd25f639ff0a06820984013c65459744d3f15c9fbe9700c1a2736239fce452b7e18bf454fffcb6fc625cb9f48991f3eae9463537ccf876ccf439a049219ba9c2aeafc550aa6fdfe08b573859ead015cbb1e83c8f36984618cc7a729ad838905a7e0a0e6a7d7ece0b50102f4778f60d9a095dfdbc64eb89f3bf7104cc3ed35b562269c0575258486c0d11aa38862bc29e5d268ae97e77c5a29d4ad722c06d2d2bd7e5e605107057be7f062b0826f2389ef2112e164db7ac0d0a4301b86372fbf4231dc332444a207d4ad6f47a8d996982fd5e2c01731ec98e075f975e9d85f824aa2d728b040f326ee98e0ffb5a40f008443cb21520712610a8a88341642b30309da4c38df53bd211b5b6e648658c36c36455778c6223da24dc2e8398c54005b68aae4d9f0e96bc1b62d6ad251064589bc1ae501db8a74133f1edacc5ea7939acefce90c3490585391d99c024cf4c1da36e3765a2970221190e2ce571e1ed6251c221e8ff8bf41bbeefe7193c7d0462dabb0c2ce0273580e0f0918572e3d1eb726e47bd4d864f09e9e3a3685ed344e50d1ceb2e70446b07185832a69f278a519dedcc48c614ae468a5ed97b1701ac3b77546acb4fe3f7a05f0e82ec10034869e01710746d4088fc49a4baa1cd3d25d90576b82f36f629311311cb5764e2e20908ccf4725f003633e4bcda0b78f5f81f9957fadefcf023cf8b492af75b46786b84384e36f7998a49adbea792e033db5e83a9b77a219fb4bdbe89def6caaf635f102b367bfd2d01097c0dc1d56bbba9812db643d4b450d7337c7157ad02cd849cb34e3e9cc7cd22668b584dc9ea491cec62e4f2a18df9f69b891604c29348c81cab7603fda7cecb3b7690e9b6666d9a9f1f5c765580c59c9865780e904f6c6d64fb9d615d5b5b334b23b26f87cb80e4c24401f8105031cedf8a3b4fb39edb52f08125695048925fd82566b5c600130d5257bd5ff3f7584db2f4eacc188b4b64a8e2257b101cc874e9fb1447709d29201ebffb9a4376f1aa5d373fd471c3cec3a82d995b3965c4a93e19212e67c11eabc1e85e6042d0bc49dd52ac54db320b99841495ba0e2df11aa9c241ec85a1c02fcfed034338c9ab279df6cfa621ed16cc1a8202ce7d7cb31bca095187b9e9e7ad4cd2ea062027c19293ca856e2a6f8af0f34b7a3ee461fd03188bc7971cf6c56399e609a3c6a44495d9c22355ae0e8eca6220969be95d63f8b4386cc81a432bc9161de317ac1936ae97efc3784f9368e4af70456377a0a526cd20c0b41b96c980460a7430f12271fa66fdb2cd3331bc865f165cc041f1d5b39d6c2f1c5d7a189055e61df7c162b87e77e6132dedc535ddd1920a751a58db137921ff903029062429b3c26545af068efbe2c0f94d27fe599a541258c4d2ebd90391159aaec01adb3343bc2b152f80518b1f4f4e4175686ac897b08128bee0684ea1282a615a5d0869c1629a60df8e54ab9f7cd1e3f830504f7b4fc231379baa33d07b1b3c7c384905231297de8d406b98c9fd8abfa7bd6927f835eab5b0ff7a75e607114ed81059feb6467c8424e7cc5d32cd88edde061d877fddd0ddf64c1fb80cda802ffc85e1a7e7bbc5987a8fb8ecc069f8bb551526bd8d0c3937f42055ec67d9d0b446e7e798367e6e3f63d69b4dd72b798b5e90bcfe127d26f18778c977110ad614ceac35bb425f5529bffcc091aa166a6179e1614639430418b840c54b1639d280bcbc9a0120025ea7f89474a95375d169bfbe5c04e8c041356ed16181892637619cbf57d2e2799131e2bbfdf30df30dc7a204482e5a7b04a94d1dfa8fe2de5e299623010a7a6a8e6183d4a74bbf751c3ca0458f32c366cb2f924804c57247737f21bd09a6ea72fd21f926879c11232b31983626694fb3e9e6b9c97f05c90d18e2ea73f14d044e3129282138a7810af2b7dcee7f15ef4f3f6bb90765d2164ce5339134b319e1e5d613bdf01fe7c4fde2e819c60d01bd66f70901509c8d11cc0d7f8c0a77b87b12fb6246f44c5e36fcd93c0821d9cc8ba0daa6cb2449ccea222a99a7806ae560defe718eba16a30fb8b75355c6e3cbbf181dc21b7b7aa80c7ccf1cc5e9a78db2adadae4716b99ee43684ec3ec317836f2f57c12a2565c2a786791f48d6beb1d9ce5ec8b1e55d0e26a204b8fc241997e7d80bed4a3b00eefa96c4c2c4a25202795cf6642002cf247e0c21d8f58184a53168a6ccf461a7936f263928617c90aa106c968220fad79439218d2a438f5d0b8888c9834eb7927d58920ab2bda8e99853924d8f32361e1a4b059fd69f1edb3f8ed2dc16c9b421358dcc44524f849513afe57cf9b23326368fb0ad865c85a94ca1563d5829f643367feff10073c796cc3ae6ca21afb506384c62a3839d9c59a7a8332175bcac89622b9abe9b8d34124dd915f86120f3d0c046a57390a260ac4ef1fc0680156918bebbc1df13617319f722336c93a44db521ea02102cb0f6e316a44424169175967c82416f78a7c7573dfed06ba99da4f81407b565a07bed16a1811c73bda87e2f771117ac76988977226dfc3a4ac7f2af79e84dfcc028c291d8d5b04c4e4d6e9d8db73d3ea26d9b9b2015a1e7be76b9c85cae3eb7b317ba7c1d333fde88cadbfc08176baa17b1f82b9a4d28edae4037304ade33a95648f30498d59e1ab841f4ab78a14abfa84e771d2402cc893f9a638acc7e1647d50d377292f2c25bd25dfd57b5ae3ac68c5c7ac9355dfe4f1028e4cf57ad86e1714c415b96e8738c98890582c266ad7026bc2a71051e6e097972f99eca26b2b72e63725bcd4817a8e6906f59a03173b9f24286e5e4362077d25ba8873ec6fb18ae230af27f0dc2adaf4d59efc11b1db69376dea83e1a66f15f87f6381dbc548f4079445f80208b4128d5dff21b728b4fa1a237a3ea1bc2e0aa6cd7743646e8e284a720f8f2c971803ffe3a1dd7dd4bf02dea22ac1cc7afb9e39a0e8c587260a0023984fd9bbb4500957babfe0c8c766e22c270f1371c8be1ab53fc10aa66e9ff1356cfd041d97cf2e8611b25b4d1a8c6a44900bae47a793db9a3eb5411531508a40f524591b6fb806031febb6e8c873af57164953c8ef397746e0dc7359aa687a7fce21b47d3761353055e2ab94c278dc75f9bbf123307015fa7a1359d0974f236344f11854f5dbee2f73496db5286b540c4c2b30d039519222d891abc622aea5a571a3676b62269fba336ab5010abdfa53547da15522ee8d10e47e3117282b14fc52cffbeb15fc36ca3d7d91a8c96223d3ed2c432d27908da75d994a8f3e4fa80ca6f6aa1270c70d1c98e0f7d982e8c1eb0e0f127f349ef7b72b1671cd86ffa8d7d7a232cf75be8c1fea63b6a2022b2096355e3505c8f25aafc0aa07ba3830731510a9d126a7527515c753758e2b26dd9d79a776508ad82ac1197c811b13657054d843dacce924640df418e219d3578fff6cbd7ab8858199793360f421c8b87be791358e8ea2f4b537f9856e82cdbdeb170096e1b3547ef42de76698763fd4d848a43f615efc8b152252995bb2e4eacfa167faa1e8bdc9dbb8e3564e8da66ca98dace7aec4096da1546cd82224d778d23da9652988bb7bca6bb11ce5b0ef30268927a796f21da8ea527c04494070af3e9f5132f4e2de208a85e4ad4aa7b304732369fb54cc9c6a6ccfa744c070142b3a8caa97345fdf83c1e78b7f68cca9c3d96d2697fd3dd8a0bbfe44abef3a3d1d6100af62ceec42b69c1b6630f10cdfc8e86ff143e2242f5cf7c13aeb56ed7eb30cfadc936718be90885cac8f180f6f774798ffaac9350a45ca618a6e0426a0b23b8d640eb316648ae675fe73ad30df85a7e10bbfb2bf811a229a58cb290184c805fa1f90eb08c4e5eca607bfaf7de3dd84cc1ad96d5fd4c130ca10aed7cb110e1518f7e60722b5d87649d19494d251b61a6b3d406af8f26d2c035573fe9662ef3d77c4a4025c79f0c89ed6432dc18d390e0a174eb8889638a4ea67ae037d45825b3b26209262221633154cc306d589ccc9d52054909d56c7cd0019c296181e8bf209117cb7fd0a48e030b79b3b1fe8029eb18f31de3317c589e1ee32242a4ca156ce9973d2bb9390c1b01b6ae4e9ac61a7dfe05d97bd189ff422b04fac2d8137bcce5614df20dd16e52d6cac41d1865b38f7d8b325738f1e16fbc326d774978820ad072ed53e52e04d49ec0ada36936cbaba08a18acb5fe2a53c831e3fa993b670e46db02842a4c921214a53d02d23b644e01b4c36448ca2826772ce5965e211733d587caf5f7f302686d50c289080c457212382815907a5ec7c6b5090d51cb75a8d1fcef5e48617cccecc0288811139d69ee6faca988152f2420225c5ded88290b71f2bd55c8df65b648c7a7281e8b219fda47fe94c93b8bfb23cb4a162f417d8c880875a24fa0c615a18834c161e7381e70e4721bdb32ac6b9d02ff06d3ab30b326b56c6d6b7814531ad70cc783b86ad4f35f571f1593a9a690e9634f5b5437440b6233a5bbc0359aef284e17f4ee0a5f8718e4460a52c0131841e0373272cf5e4100551052162a1e7f10e2f7f8c7cfa241cfc434b15dee6fdcc1cbd40324583891fc18810e43719ff69a540cb19268d958159ecb95597497271873d4d2a9fa9757155066ff050171aaf3ae542a9b1e7b026ed5da38c5462bc7a27d16323e4c9e08c7c865050e201e42ce5552dbb4e247672883c532fd575c6ea9cac6c96e51bc777ea8bb36bb816f5b1db406aa86a875b50c71ed278dd6821a5e97860d9e1a3da75d609867a76baa3091792ebf5c6c3e592f7fc079664d857cf408d2ae8479e817b9f370c7930f0f9cf9e916537588ac3e2df41f5509c1647376cfa0282848c39c9544f9759975de05d0161ff1fdb9af280637a8b16b5ae62fff5290c730c1d06fa40246782fd23e65c71174f22b192d360e65449b5015a90a0f45c424e6daa1f3f62a0295f9ed8d3a568d17d99fb7fc87c1561c24c93ace237bc111662ac083720ad7fbe1f1d42be44989265727436c521572e58e4b92891e9b5c873986531abcd4c011be0e4d27cd90842e3524439b7e5b8f25ce90a75625c3ae4ca166665ea0e7fdb85eeb44c2b14d8f42ff4dc591d4ce88eb64b557e9138dbe94b28903408ec183982c2fb84bb1623b7952b370df69b2b3827e7d23629c5c49cf411c908597879cb39434e63277958061a814e71b1d19b6bfd29311cc939c6177ec62cfb1bcc0646d70362f4780842c62d9cd9a15a92c24786fa594b2a68bfce33836203c6b385956fd03f69dd8011d30557e8e4902139f5e2b418c854c400961474ff24279e169748e074d222f6015c824e2824a583454588953d64d54bfd4ffdea9109cd7cc49df4033c251f89a8806ee949b7381e19f6d1d1afab89b7cd2fd1a0d8dbea4af50ba4115f84405e87ee8ffece4264b58894339758f679f79968327fcb1c10c5ead8ebe5946145b395b3820ecd5e12c16bf583ff5db8edc081b48e68be35f50e0b4e2ef03db8474187a7c505bdc4fe039fb44630fcd3158bed1e8dbf000a64c99a5122f1e081f3cab0510f57abe492e1330f2b07e10a11bb7dd898bc94fb7fe07848a0d5ba777911eb06fbb8708d9a2c205b9bf6c4784ac68f1570d767cf283bad0031e5331224afbd9988c05de52975fc8a49427fa60f393e9a46728d246a9abf033706ac8a05d82fcf5703b44c67f0482745c21b57aa0583b86f9ba9f4be0dd5d788961926fab9c2be8c9ea5d07d0148b2b48f4772e1043e1adcbefecfaed9dd20906b292cd2e1706037c31a9e72392f482d31de45e4d01453b06582868d0410623204b1f50c66b209afa31c9d24d3602a0d76137c8ee31c8060d4d495a4c9716869d05fcf59b894e48b7a6a479f3962dec3b8a780c00688f4ebb934d4073197acbbd1f45e995f702f2c1a16778b1da6c8b495cd52997d8cdea825aaee8b555a1b0c54b4992bdd92c0dbb904ab5abb4a16f83a7997f25141fe8747129b542d3b5c0d52d93402b368284af45e1dc2c08938a4ffec6a0e6ce7e9c59421c4cd164e9fc2f4b956193a2fd55c05c66c02c0e61c86e811180d060aa4c85bda5601a5776d508181ba1bece70cfa57b0925bb7cba4078b1344473e4598f5370fc0ef99bc30e72c7a0640158eae55d28bc62a07d09cc63b47b373ad98e8febfa6c44f74eda5492ff26dc083d1e86001db468431a761cbd184b8aa1c9aeeb6325cf9f58f671a096c750d4017bfdfc864ac43b1ab603a5c8d73105cbaa98e9472e3bed4d4f7ae416f20d0a0a3f607bbfc8207d0d7dbcb1b3003cf8619e65c4657cccc5bd6974a7c8c35ef7cfac38cf2f132a3961e335c7655f443f375a3c30b8f4f52b6cc1599d7a1711d24a94397c4758cd5ce2ffb6e5fa024c95b94580c6c52619ef53133199fd85cdb0968ef24f1f41c96748c13690ae4c4437eb788d7cd986394bb6288e9833c76136e747a87b38ad6e27423d39a8d3cdbc29915eaf5424bf8eee923d9474941f41f960d685e2952ad1d0d0e4050d4ab9337bab793edffefd550cde1f97582cff39cee6bc87b1e6c27f11b91b9d2720ab80a1947157f2036f63a7fa477383bb80d253e04a548a19bd3f3209cdf0b76f53af4da33c373421fd73443e8f8b3acb107c8525fcffe9c45059905988d8df9235e7f80c67704c6759c967ae73ec98936504ade006770f31a945f24c7bad159c7989c4294c35cfe9fe7a3238bb44f8342d8c43c708d61fa8cedf0ae1ac1c6679b8b01c16a56bb50c7e3a36dbddc6c8e98733b494cdf3bf4333680b94a07accb8014ac96856258757fa35689255ddf9e5279302228dd2b994b6bfb0f82da4f7abcb91e7dc6c0a46764a9f5569a9cecd921d800949825bc74d4e5f9a92adb55c76ce881bfac717142e1ec58732a789bc90a8bb635cc2c42b8e44bcbe241efbdf42c4d19c1f0bfff701c8bc0918c306bf2381a30a080056517c79bce6d748757fed343645fa36a240609794e72c414df4dd83fd4931584d801084ea28f36736b4fbe39ff734bd3046f4f49abaa18b17de6ffdc4d5971f2873829967434453ff3bf5325a289710e3cdb3c8e6ef8cee1d873ff7274b5a61a882b98e6005b51e606b744ceceb49a01d2037004977f7dac20715ba90935cf0d20025a33310d2332025b59311e0a271a674a7488b56ed6546a9a06418d0d0391e596559de95659a474fe55cf94ef56be46b738a082eb8d33cc48562e8c4b8a7604945ca6c5b33c0c03b6151ea0ee3c9c1d3696b56cf26b8df5f7197ce4f5e766de726d8361cfefb36344ea38f09b2be1685fb1e3e91921f1468bcf6ae7d927799be905090682b1bdad3dcf34e549567eab0d7fb5f8aca0a09d7a8a6ed5e2797383ae537751fd7acb5052efe5524801e60587fd8a05a483a74350d68e725353eb25752117a9ca7a1cd6a345c42450ddbbe2d62e8fec017beac13f80b408e31e073970cfed25967677b6353596941b59482ddc63b509e2cdc21200da46568f369bc6ad1e738dead85bfa17b04bc4968b54b7039703a1c2c6d4e569660d87e4ba20e6cdaaa8a03d3f8518d03c47cb2c33569fb99a0941be0b6070a14da4bfee4ae17d1174492c700788eb5bfcd5b1f1c2fe789756b2798056fd23170626f02200a878ca69f31b313d1b3b937b93d5d49116794e5e213e1f3462e1f76f476ff72b87df8757fe877b17fa7f8a55c9a760d5db9d0e136127b08a8122d57b5e33147732cd2db71a569c8e64d7f1631f4060f7d95dd79062f5b0cc9adb5b98f8e1aa475e5a81ee46f59f0f26cb182788cca814256be65b85e0a78373172bb4dafaf097f59103af8878418ac277bb546e2390eb270cd8859662ba56ac98e69b5efa24d341d8f2f31079a50b900b79a931511f974dc31bb2b9a52b0eb180322b507382a673c9f02a002e2d114230b70514084c746cf4116754f2f56e8a461ee5795166aa2b59d65e503dba4251f977f697d2a503b27f973f2d30aaa12f0c7166bdf122654e54cf407afe4e5cd81c4724deb05fd044e3aef652fcbe457017d1ed0f21c48af577fada8504770aacded4043f77b246f6529628db34d2af5f19cf39da487bfaf3c6ab30818a3feed04fc62fc3fab5c44f23b2e62645065b9f1cbad58c186ba1528f991ea2a52da8abfaf6acf2b19d82b0327511056c9a948d781c651663cdd3077d7ab60591dd1a31406a14cccfef6afb952b8ba38f7dd476420351a668ca7ebd1c8ea36bfcf82ed3d8563c505f2feda87ae61bef165cc6186dee630a4be599e27a7498932eadd638b6153503d45bda3cc57faa29d2f9e5fd4a130b9488f0ab88ed2ee903be36da0cd80c1820d45f391fdb6ba8be513613a9329ab85c50188b44ddadce02204ac9850b5276f325c6dadb7ae4de765cff096b5acb8b24f6d6d70aec7699a090dc00e2c3ad54c3bd6488827c4bbf0e076c70a1f8c66849f2c0c3cd993d710049d1737636a758f32c077a5507b6b4a3ae68ae78062956bf51e57362407aff0c038fdabc6471a117793b2da1dce8ce3f24a45fc1a98ffb108d9c7ea377c5c881191cb770c0502bb92a5caad91bdff1551c809c3b9bdaead94710a158e40e5b809038f3c91fa1784dad907582e218c191c6521fa778286da608a1cc93da5f2fcaa610b48b057d3b6a1690add7406a15871ee3456b9d6cc2f9ed22a7cc77dbc4f7146e690b38f1f7bab71c5fa938bfd8724a0ec00c916c80cad6332777ec985a4341cc8b02a12c1f3e578e02586ccaf6b824d3fe5cd56d66c44f445093b677e2dbac152354ae74015d66608ecfe086b4adb483a094c483f092ec840507faef1ffdae69f43dfa7c93188c1776d97adaad302b9b2ace4fd1aeda264e0fabd14a0b4b7bc369701a549f98509281fb0d2bbad4a1fa54f33dc695dbe2019fea926eb456b92216efb9c91cbeaa337498bb44cb9b6955b62b5c7566d8eba75fdac2a8ac82eadfec96a0ad175bb4c67ef8209e41c01d67f59f58e0f4107f2b64650346c586cfdaf3f19e3b1f3b60548784bc95213178cc856036e935a61dc5f178d03811720e8b7ce33a5997e312bd488cfee2fce3fb4443bd06ea0b89a338c88bb7968d25246dd623ae554cc58eee02d70037b18d5805cbf75a617ac1c1974b7f24216c09e595decd76612c12730043f4911f8a25d2424d7413731e30769f0f75b47c89d8e48b8d9edd55507e4537ae4714d1145a32dc1697e48e1cfd647fe808e60262d04ccd6443c334eff2401958bd11290d74aa51d4a7bcb4c96bff651952c125bb7468c12bc524681fd76b1a44931dab1cbe1f602e1e1074ea106e780b4e259162eea5eaf2c7cad6df6d6fe0acc2f54c1004bce37fa1fbb0e8e06771a878a4cdf058179d571b51d099c59ab6ab56bae375973eeb37adfd93485d707a39ef9f90ba93c0e718815a0f5724b3249bbc5d6b854c5f23372ae57f00ce45518f15e8079c2f6748d9b9c3f9b8589c3f97f389c09c8b1c78efadf822b9f49872302303d7d119f2ec91852f37ad36ff6138d81ac8133e97fbc33cf07e08752ce079134b990e1e594b7429485ba72d92ae214305f9a53c7d393524746fb72176a99f16b9d5045207a4b3c3509b5c423254e9ab29215263d482eb212e7a98fae5726fb644952956c2b97d2394b6cbf997684fef47949d7a7a3216674f819b851d0fb0c9624d3126f32b6c8deed124eb959956d78942f945602f895c94c542194fa9af85d261bf6db538ff061642a9126972ba7f700d8bd46505474614425ebc6cd947428313bfa7bbbb2b104e3562a7f0ce78aedc97fe43ae64e513be5e2671b743c3089167593bb27e4d9b6c15c3cc7a750f75d9fac03342ac8be75e2ee60dd7986de7b475480290bfae94574a8545668fa6cc941e7f835392ce404291868e98d769b77b685e2293fc9a2480ae9da102aaca236fdab6f6bbbed88ef75e4ab3c27cd717f808c4369e8c7b0d9deacb5a36290116b1fc8457b7561787a5fe87d72e2db2e4553ec744ee81cb1443f8df57055c223d1aebe3cc769c6c5cd19c623100d781a64b40ce41b558ee7fe5ab57d2d8dcce31f50e04dd342665ed743358b877c3c3b7b9a1c34fb94e2662d2220abbc06fbefa0d087c73e96c9ae1430e31761c8105755badb151b561bc16a515f4b48dc51ca6c2ddb2d1a0623640ffcf0ca36f264d1013fcb67d89e3f843c0ab5fbe301d9bbefe7882eb2117b3068cbff903af3121546614d3bfe62e5bda5f33c55ff42e9bbaa873ee5be91d0d0baecd32570742c58e90ecf36dfd9903c774235197cc2227790f4e6ad8f2d7b45f6e1a293b3994d1736f24f98b7bc6398b5de29eda89596623a8d5efafa9b791b8f74f569417c37f058bea2fd6c8f89a6621563517e60fe5398eb63319126523b5db3c90bb8cab9b18e16ea16e7619018386f997cc9e3ee2bb9c688643412bd6a85576939fd9a643e63f984f980a7044923e6a1a1a78905efad641d88e4dbf6b01947cd4b8622a8958c69a8adc7da16f1cce907e07ed5339a6c8e70c2ce871b8dbfb37665d68b3918319dd590bfe992b92ee13fc17208c92f0a5a24f80ddde1214535317015a483aa1fe58ce2e4ceef84f1469bfea2bee58483185e327342438eaf33db8de2e4cccf862157011f77a327abfbac6371f02b206a88a93c03409b7e6418b74cc371cee08a8ecb00ac7c4f6f9a1e699577f46354f5960e8797c3e6503cc6c8764b45d91ebb81aaece6b04decc10804e1123d69072a7fbcaacd368cde5cfd17844a1958e7915944be270f3313e869916fe4e3b353888398d0f819c6625a413dadd3b64ea8f7aeeff29564a1d11fc64b52f86b66642ad73087358b5d31f3125b46abe573d65b3d496f677c3e3e88c07eca0cf033b49fe3f98e131613536e2232a0f34a86ca5c994fe7fdbc90debd9bf72f7bbb9fc3935e6e2bb1fe297446d7e13e8594efcc99bdee41cea4a6bf95b4aba215b5d8f8ab4cf1217ad6ddcd84a5033003ef8a025891472a6c3c85518d5a2e61fbfa8e82516b164855fa399b8ff14e25239e3eb2ac0583e27417920ffe882253d6c46facb0adef735997fb74f026e2017f8f2410217e12a6efaf6ceae544b092995953c3db7ce8d0db2d4d6093922c0d66e929afef949bbfc7d5f305e26150caec2439ed6504ec795e0d8716145a1b156352afbc0f59a801ba6e6fde806b4458068dd19506ebe6ee3374a41a165c900194d4b512425759cf7d8bbd8db6eb872cc29df0f7081fdc7de3341b7b5037b22e04151eb2ec240e332ffe1499634962144735f8c426586feebbeba824cebe94da417671fee58c8b7dfa227a84f622944c1db97fe857f0f7fea4c8513800fd25d6be05c4b04ed599974c7701dc43b2a556b6da2443819fa8f6627e64ca8780f7d46f3c8fe28f77352269647f93c1c85a5fe129cbbd525cdc2c98e869bbb3ed28de86f123ea1618907c54a0e37e7233615633071a8548a0345545e15d34fead006610b5f9581f9bc7c0f064e8d6aa606b66dd9a36b0732f62189f23561e14394aace5a6bcbef79a36416951758fb3bc9746506a91db8e71744c92b1ce3452a04e303f3784df2d15cbea4ffbc630619012a3d0d4180bf6b0eaf70d1ed60a3df198ee41f4b02934d9afd0b8d0572d044926a996b75cc372814ee71ff5e75e39809561d512deef7dd6cf9b1669c654f5c114f06de542da08c86b9976d0c63271cf47c35e237e40ffdc7d2ef98e3e35721a6944bf4b540140a273c156c4daee6ec34b5458487ad46607dd03fa3353db8b1c28cea5823cbcb60dd3c583af96074de141ac33cefb784dbee1e0118afc1a84fce89cff907e818ce7e8260e0da4d5d883a934f24a2fbd5d037f1d58ae8edf18f04b87e757200df5098900d21dda1a22df41988701009b6d591bed4d5ab9ddb15264d3b070458d382277795f75932e2ba247c702147f8e151a74011679609ed70f498f90229beb19af91c52d20ddb018c2df475900309646ef350369c7dc3119885bdb859643c054c563dbb845d349d120a8ba75609bff7d67c0ffa63953de38d7b261d4f25b360a81bbc50ed761e28ff046c66c6c23fe16519633cd1a7233bdb6c11ce3b338ecf976fab65d0d2fb7e31f0f5bec9074b0adfc1d6ee571f0f0ec6155f825eb18bbff7d52fad6f861a86700e1fb33c27ad9895a23eda3c9b19b89e98953c8a0b815bba5ff4de7458b976667614440e08719ef88deb854c01482865fbfd70d088858634a058089c4569640f75d2ab83edd6fccd1fa3e5517f5758f7e5b65e48f7ec1dd56a08144c5ae632fec6ee97be01101882445611ba98c2cab186c497bb0dc662178300f28e274163803ea2bbd6f7374f7514042813cd15796fcfdc338d446be3cbe8288cb0cdb4aed5c5b4f6d2475e7256df05df657c5f88cff8f30148c7f5210a97c842b53b2c5aebc869aebc4167a9340e4644aaa375ab5f6d13b6ac9931f31ba33264358380ad7cbcdae7e9f56ac19ed495fa6cf767981de90913433c5420d071c0a3a6d2b36a84fc1cfde4cc05a49fd63970c7217a8bef26beab8a584a65f44697f91f7d18c234c8e9c819b0ccbda356b9f6b6e47f16effa5d124bbdd238e237715bc6d40bd64528ca55ac0a72689909bb6499b8a0070d221d826995481b9beb39713e12788c98467284638cf77a707da06dbdf03d4868c9a89700275032f228c2a2974579372c94fa0249beb6c79766442e565006f34487d2a537dfdecb373db3016180edd44398f8652da70689a1e9c752bc498d5af021518d1d5357c2adb8f16c575acc476b217f6390d2af157b92db024f36793d8da2de642bd61f3463f1f282980b90766eb57809198de388f633ea7299b706b5bc54108aa8f7f4f414ec189c6b85c65f1db3309eae5d40d2010d2e9fc60c09df93fe65d28df52be0ad7cb54c09201dc29b445cde992108e9cf8249aab034012860951b28e9b8ccd54b5ddcef2f34cb72fdc8edbdb0a38f46985c853e9bba6e3b7bf3666604430b8fb5b57d32935773410643aa41b33ad5982c85dcd70f33cdcee478c7b884f555b28a564daf8cbde3029d26b033cafb1598b10da416eff9d17f507023eaaff44902007faa6cf494711197acfa3b90ced951612a1ed49cd448a976833c2320264066bf781be391c987d02132e5653b945bd992fa8e929110eae5959db35afcb8bc8e1786d9a70eb5b6773475dedd51954e14e0c6e36ce014a21caf2836ea691c566cb4f77bb810b83afc67e64b128252bf849f3240b6c8f90eb3b025cc0f47a267381406b35a5e8d645c9fdaf5bba5b868fa7401ca4a12d2a5a3800c67f65f2d95abeb259db1edf719fabd8b080a1ea1211a2b23bcd0862835ecb045a5488d6be0a85dd53b57cbb222014116f5478b75f08619f3fcc9e7ca223165c48f38e86d57372e6582c93f7094994aef7a7c00f931be64169c5b4440a6c542cabe2d8000669262a52554d424ab59450a962c04b39737bcb6061c6ab18e61562d0085512d63d1d9212e378c49efd4b72b8e2160c4a088da70d77024e0e8ff70c25406fc495f9e28880529d4b019514c514263acb44d3f0b06612eb8a1b97d39161a367461d8ba390faeb533f7a3bc17dc2038def3f2fc1fda3527d1dbb14c17b3d5f400637291ec0769e869c29edc248f36de96542f0b475c732e12478149b073df5756e919541f7b3abcffd24a2c0ca3b7c0393766099b9b3d47d4cafddbe50dbacb6400a2917e9b482d0ae6f716f4cf1ac7a8e33de6611ce918a70f756bb31d9c0a250036b03fb9e937b9170dfacd0918bfe395a3078400a30d8d726cce230658015b196ef3f710d3c1887f1c59421cf5673bff4c1b5379c7d1174b60d687ee49e1e8e726bf70f3c3c8c7838ac4265d50d304a8c235031093911f407c500afb18a6591b08344c3a6cf3d910c4f40a6693b22f4f36b887b7979d41d36dcda1b6bf4399b2e7f4df1fdc692d783d41e0e057c184029c2a54c9fc28cb031775aa5e654dff2cbe18679f9dc625a9548d90ee978c9b45c47a46b76483d7875f6e97408d1306b20883d76992e17ed6caca7480ad494d5073848a22ba897d9278698cc0819b5355da267afa19e10d4a8a6299b688e215957e45f5beeec1880764a676af668855fe0065baa4fc0a05fbfafe9afa598b5fc77647dd387f3679393a30997404cde8e6e0d0adf59cf8090f909c7712649250a35c49c910313622d43a2dc7c37d00fdba2bbf529c0633c5a1be854c113d14ce1df35a84152e48e32c25be67bac3d446c49cbd1e9d89437f820dda350283cbb1201eae13a887b1533878afd481ca7851fae483cfa8603bdba718794d9646937463031c0f0c967b6aafaa15fbd50edf71eb4fa3b05c08ceff427e87f697f993185788496d9ef57917234b5b0e35e506c5c5f9e1a6d66135b9889d395d055eeeaddb2c0ec40706c7b4768a507f606fba741665cfbfbefc2cd5e47131d73844d05fc31c225ff56aff7c6a03edf2702475708036e1c03ed082d40298a621f5595240c6f668c6cc939394b883314656220ff25f2cfe78f03ecae523082a49ba9f3c83d19280eeaa914be45ebd3b323cccc5b53509c209001666d795e2821d141a22e4bfbd56cfe384f43beef3786437df738ff1f7a042604a4416900ba5c0acade170bf231769b9ea65f250b3c0ba11d2bf055e753b128273b52c8fa24f09a23990dc17cf465b521d22a455f711569be49e1ed463e35ce3e7325164fa8a447182872500dcba6e14833a90aa55c17b829fa8788400389578afdd392851c06f185c635d15b0e9ec435edc5d73d420964e055646d71039d8af5da5152c476e41b5c125ad404bef51bcf92cfce7b2e685fc91b793311dc305da453bfd077bbb1a07a4cb6b5174c9e14897a039b4e55f52ab91c666efa07d24471abb0994f5e4cadefc6b5645678885b335f182497c78807156dfc0e0ed8e2e1bb9244f8fed97d6e270f3b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
