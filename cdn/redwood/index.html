<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5db2adec4acd2fda57082ed41b6a9ee9f0c4e1add6f47ce0227393ea47ba736a422f97e95f0c72db7910b626a1e7203dd71cd6fb48cc76eb101a6e1366c71fcc41aa211ad00eb9ea4149a35b2ffeaf6ba7cf3345faf318339cfa5207740bc9637e4e9665ed101a027b45f889d1a8a30cb87a19a2ba419f6c7195addfcec4c0475735abc1459864fa4e924eb03d3661e62861f8d3b08c61a161abc12d8f8ba6567eccfa59e0e9681f6f3c588714377836c091e61d6da34075d03b181e35cbd70a8f72bbdb27f5c4b1ff0a4a724911e77361d2008e30ba6a7c0f89855e038fb86bec10143b8ee876160ac8c90a71cc28c5c679f8a3f3f4c3f128cce16fec081672b577d303711ce70b87d9f942d75e804a01782e5a8b7f80e9b6ac95d4f13d3f172440fb73d3aee5b144c67d08f874989cb339d322d10b3b0f726688aeb09007e5562b9d36711c09fc18c8aa005d4479fd95109455be7c9e00aa55807f5a7749b2110860ba6ffe2795f561ef5e987dd8594f28fdfc33f533ac7701a9f4d999063e09048bcd140d2a83409bba1bd2d404a8cb838e2cb211da7850c46044ea00550bf7f49c555e8b310942291d975578f0990553901474bcf9ac8e419fc467dc7244cf29e80094bd5beeb2ec4d3959869368202e818c6bbfbc397b296a988e06b6ed927bf53bb99d9724f1077d4487e5b8222565506248e2e30d588e9eb942ebf8a179562936f0b96be89dec41084e70d2f0646649a24cce7ffe643513b371c862e38066f56bbc31ea7e40055124ce6deba674aac30b1ff2ed9b9303277508de74ad870c2babf4320862d8fb4ff27f105db6c9ab253f346f3898f2224e2f6dd315f3a760a9a6879edcce6f406438891dc3b06d0ff47459dee7da66e5974bb82b9a2ea6ae02b225c0986f77a72757082533ca581e0e3a8fa659eeb471a9dc72f494e318b97acc67b10d7b996fedd4654de370095e309ce8cc41c3c0afa3a7a4e8df8e1a87cc78f88f2d10cc4bc544fa48d67e1ff9c36b495bc236856461169858b8368c90ae48386faab2328a487ac403b68c5a8d18deab78a44540a3d5ffcd90e7e89a6e7b30836a3984a0974b55e09c59838e2e5cdf2cf7bd4c33feb7664ee4d0a9c13eea9bc42d26fba9c9655abeaf2dc0a597879b35b9c6a580c330be4955a71d89f2240d3bd588a34cd9df71f53ca4e88adff6c97cca91e3dd6e4d2e40aeda2c8ca8e5d28ef23669f2ff9cfb9a4900e0ef965f7f9d585e448b40da3f9f5ccfc7f52d36a442d951f40379ff5b43bab1273dcb960af19eebc6d71be4701631281a7ce6048debcad04dd2a3e4075fa385f3c028964f21454fdc0e9f0bb29dbdc1bb8e3271f67b473c5326d07e6f432ac33ef567cafeaab225d546230239f53275eb3bab0980b8e4870591013e2249f0aa9cf9a1fb03ab6df3f47de0ef6c8210e075f3a9a2182720da0a0a6e48b0e28bbae64caf444c74abc633501c25f5f1134e9ca367b3d3a3509d63b49a2152dcef2a6ceb6e72df9e5f9e32277d42e018439c28809a679ccf6f2a192eb8a5518d32d9e592c57b72d550e18ae8e70ad2eb7d339cf8c564985dd64479e40087ca117c4c6634aa23d4a5b8f87f109d42a9dea99d31915aca46cde4cefa4e1c272305c498c125a9a17279f656d100ec665a1d6785f1e0fdd2880579ee7e266b2c9147872291b55dd7529d1c75763ee7597b5b8502957044c5f9ad33ac20e3bbf23b069e2f75b3bb1129d0f80f9ae76977ac7a47e0f97a3edd2b8f94ad39bb818125ad541535e90f83e3b830e7b1af5ccb4cf012ed203cc6085182356668cebb908ac8d05f016f463b3f23ff02133b597386cea57f58cf27aa8f3e267decd0d2fa96d89fe6f274eb7664fc1bc0356a1d650ccd359112d1b165b813adb3ee2dc56bb61fe784d3315990d1dcea8a5ae4f21e779d8f69ac8b87cd25e46f132b935dfe84b68f07125b07ce8093540b6034b3a0cdff5983b131c3e30a865ddeb437b1660d065ba3a13e0020bcf7319950bb1920106ea4a3481d88b08fdcb0cac7f5d20b51d8d1c2aaa0de5d93c38da81db76f65046a0f1cb9aa6b2eb9cc461796d3cc2e56f44e0d5a47d5d73797fffbab0b8395fffcf9e7724094c2710f7af56d728457d9e05fe1dec9a69b12e73bf4cab9cc302cef106428e51dbcbd4f2504d6215c11c8adbb2dbfa7aaae04fd409a2148270cb5c76df4bee5a39628f7155efc1e23c10a6c748e97be4927bed51b64238118decb918791f8ee0ef2d395e4ae69104cd379d59fa0a785bc24e121224bd632511bdd782dcb39f4ce209debb67a109562fd1ca0f780d98b930ae634db20e97171efe47079fa1db284fe40429e12e335b2bbc683701898f4fe98b375f59b3d8deee6a602f67f5b16dffd6ed4f7c748c21f434462f66912306a8bed5394ead8d91a5de1137def618c2fefeb9dfbe622b0dd9fd48640ada3282150885a82852c450afea368579e45e00597dae0b6c4d3d9defe31115f33b704e0ebd700461adf9ea2e772f9c8a6d8977c8fac58868a7baf3a4c941f352068b833514807ff8abed71bbf047503610f953d256a7d39bcbc7ddb04874f5dc4147c509db90029f6c2a4dfb2cf3dcaf56310e5cc5d69b020872403ef628ff4d2df4082866a5b99e46c3d699e6ddde90dcbe2024bb9778537fc57e1611b88c68a5976a1e295000ea840b31adf457ba2017c54ca06334a1e94fdcc0d2b2683c954c84de7979f73a3bbb5ab6855f8d5ec3f2b1234efff886e4c9888c307d97bc39680cef917f71a4fd50d5634086459aad64f45d05ae275f4b583f7289579b3c355de56be0770952abff08040dbefee203ac9f21b07516347a606f566d7bd5d163e5c7e069cb9537265f5d089e9087d4d42d68d10824b168f7b27754a29040888b81fa237bfdbb5185e2bbe6603c4d68a31c882154279cccaa84f0a26517d032ef10cf5ae0a423b969b2cb680eb147c5aef43dd3328cf359713425d95503225078c11ab61b3aedc9b0c2a2c607f0cca14925b9a2638be5fd8d4ccffe8fa7707efe06885c43f89dbb37832fb7240dfe86e8ac64573435a61bacc10c1bc2621c40b7f0b5dffef8fbed20ba570be9f4c621f1165d39d74874594ec4db6f275d6014415143e7feed73f266a0526212c7366e3263ce1cb0265e27ca446bea51f32e7679e79a595ff1de4ba7302eecb27b813358ccf55a728a4b64a6cd19fbd58d39d600ed73c308612b0c2d85e43cc41890f68b0deb6561c60c155cbcdd17bffdc51a2671ea67e6352fc07fc07a74d0a093c657ef8ea038b11bb8a741083955a9172a20140accde5a96b3497d352c4a03de306fd42cb1d1a3380940898a75c5da2ef14c64bc535068198880dd83fbcbf2de1ac18c4b4790ec26fff930cad4f6545a1b2e9782e146621c8f17d538319620db4aa0096944ec0c9088c7338de94fa9d4539e7d32a0ce20ac2d893d08a61d6990f96e871f4a178f1c870b023b52366adadeac40b0d245338872243aa6c1d69d8eb5581f4e8fae35f82d4c8a743f137b613f38e2ed3dc02bbeadf5d522832de0eab9ab5c5187a3b067ee8f1ba25844c287de06eee88c39eef4e299c621f05712d673c1747d2e8eb9d586bd1f4a3bf2d59b41ad412eec246d7650ade91e75f79b74e09d0e14db215fccb624c9a86c7c3448811c9658fc5b0ef65076dd8c35e5f6dd044ab65cb0ccd2e694a4c5b4f834866a0db2b1c0df2232e1de396561561bc8e89445105fd50b4e309334aaa7af8399fa18f0aafa338dfff2906200ddb3595d31f65d77e2df57c9543efaf600092d8f84811c6a981c80adbbbe24e337ae95c314efe5dcf8ac8ceaec80c128c2a8e85f1b466ab1a0aa40d507b7a9a68b7a96a401f3caa08aa50180817b3848b4b6aac395c83d9e310073bc6ab7f3dbdfedc226d7f19a29b5957e41c53870dc0978db51a10b827508236e7e0b440698cb8c7912c6e48c518a7b06742b0df869bdc0c884ec9eb89dad654055c32c6dc6e3537cf5d6190e00e133ba8b25a162df8ed370db02640e212a5c9b163f386f211fbb5165831e4676f6f81d8fee905bc1151eaddffd0d6b63f764f814068d7e3925a77be444f1c4314c9d8caa18b04a46d3b98e8fbda4c512d95fdab3148bba9ef330ee4429badc585971873c28f1b3125861682f945581a94d2bd1752dae8e09f1bec38326d86d158677e6d1b3b7258ea1090c4b6a94cc6792ac405aaaa13b02bb4033a2af759f1fee54e4ee39a769050c75c42d2aea3d79b7fca6b5e19860b505c0b338ec665ac13e65030a1ae064c3fd83b32feb96395ab047fce5a7b030e9cdfc478db58a8e49c4c8cfa7419f26174a31cac9629088c0d91d6fb266d3fff29c4fb2f59aa03f7d5cb86e1a76b02949b399982eacc8d095b5f5b08411405bf8c4abd8192c6ad5d3a52f25b889d6f3a10733b81039071d4e829670a37b38937e72adb58d2b0e4f9d93f5faa35de776bae1e61217c26ccbb85fa978d63daa41da664122b1a038c50ceda67e26256e129ac26e4def17eb10d50ca95c4628f4ff19e521c0d2e0423576409e89d0d8178e203facbf32d126ecf2113e960950620356a7c9ea358edc1ecffd5d2cf92b19d60ca7c59ad6c53c73fa52411955e66785f54caac3667c1914604a88af2f8bfd0baf0b8a9c9115113917dfc3690012515652910ae0309d190dbb53b2c343fdfd1fea934de8ce5b2d2b34f80160eb3e3331f84a0f20aab13cfadda4305837df6edcfca2e2fce3ab1e04d8717a2e3957a890f9a58e40f19b6c610d56b41aa2132b97fc1dcbbc642821413fef5c9f0dcb984b6b7ac1d6a13f58ad3079784847cab4df3bd7132367e7d5947bfba7344e56c8bb443c3b01854d341ba09f93f863cc0361ede7a7df3a60cfd6c26bda8da8da72d4611e178607941e8fd15fbcf43573b3eab684af5ae7d339e6e34f510f3e6578a18b1549fbc51cea33e4e9b0d4b295aaedcf79a5276b2db43d564572e1f55c601d70a51ceb3712cb167531da366039a6f3046a760fb45ced351245bf1a6a3732c6390097a0641c16036f92e5b8c454e21e391da3f7c5f4762b16852eecdc01881d3585d76e7b0c9282194891c283ccdbf32d5d22ecb59f073ad4b747824c3b95a9a573007249746bce8735c588b42fc3e9fba475f89aa2a1756e4e373705f8962635b52a6890967d2e42e5aa52306e725fedfe8d8c0aecf8e49bdac5f59251bc30111170cbb12ac49eeaab203e50c53101c222a7ae5a98a44f244af0e59933b1bf259d4f8a42e32de75da27a6a5ca73a490710b86d10c7dd146b91aa5b4c248d8a065b8238a0c7ee5cf1d26d6d757fef7340643c65f65eaf94ba88958449e0cedf57191803db072e9d9e3e35a8bf5d198abda44f4c4ac914f8579efbbfd07e664c58e6784f73f7e381a3a59e656d851da059949862a595a912d5be8e63a6a34939261aef202a9b84bd963dee54f41af424a5fa327a0899acbeec682f1035d3fa9303d87182b4df73cb41ed5ce1ca434ddcc45e7d6c49f2bfd65fca0261916ac96d44e3b3ae13c2fcd33135fefa044f17506fa37d2085dab6b77ccd1d69feef0817390fb6ccc9e460e0e812626d4cf5d6435c8caeb3f9caa368bdce1a0c3316e137fbcfaa9c050be4dac8e857e8ecd569f2830e5fa2224055536ba2c0c378a087426f4db79c519bcd9b6743c39a71837c06dd10025229771850c52e9a4745b4b3feb22861add1dec5f6bc86fef37c895379c4f889722bf055516403b0011f7edeeb4d91d0f5dcc516d703cc6f76b6bae8ed7a16fbd49cd37a06ec3394c3c00fb17a425b3d3952bdae608bbb4d9fecd2b3e43b52286457db756e8474c38d07fbfe9fe2f356aee3c9eb04f6a254ff36444a0f16326c5467e6ea155fe8362e51843667e77c0590a75bfcd98e3ece9654e1748bf9585a56aaed4d06442d6272224662c43a462e403e419ad440c5bf9b3ceaacd553eac441456930b885ead1c955856f84a38d9ea6033f94bbee85e311f997ba0d4872efaf1031c3f8c531b85163185b6627e0f8ec496a30b9ffa5b8c42592ea0781cad2af0eeff57bcc68d50ba5ae360c6ff9f9be0cea48f9d83d5b980fa607cbbbdf6066770dd26a9d982fab22d66a4f799fe2a472dec1c5392af41baf3b427c7285024cfcdae4fe13ca614bb8b3a8d7d738cfcd299f7d76169db5c5e22d1e9dac4300ac2596efdc77954a786c38503e236f9a08900621af1e375daaecc7330990878acb2805c8c1db137195ddfcaee172d073800a77ef9407630e41cbef8b98ec6d15c337a4b69e2826307aeb5606ebc2a134003a9a8e6ea77d8824d6ee04b2de8902976020ba6b247a053b23ea23df906f00958b748e94dba6f1e21432d4efac2d4a71de8724952ac37a92d47cd46a079afaa4bc32dae76adddf0953e8b92206ebf7b8debbacbaf4fac95348bbd71020491adb3e737bc45c5b0360e6953bda129f486b314d013daabcbabd75f270d102a89b7c04e9731c5f395efdb61564d62cffa22b7deb76074ad85051584af2abbbf60e2249e77fc964a4940109cbad9d8a77800c1c1e0ba3593e81caff8dc7426a8ebe373f67e8e36a9ddbf1c136a1faccaef92bf1e842034a08ea2bca972e4bade703d691ad6af8221bdcab15cd966620f11399eff4f5407fd2a058d14fb265b3a021c3b46f934ebbbb1cb8dec40ee249ef6201e9e0505bdbd07b132f698e373d152ae34e6ef1495a4dd471e3578a893890db320ff6bc8643ff7a69d2d0be38f4ee0872c078244fb6f4540e2131e1ff7f803e13fbc3155b0c9991ebbe60c92d8ecb42813219d5a45b0925f64770665a393aa8ceb9883c3a5dead6cf5bc347482c0e253da08050a1f5341cc12556b30731d706f35b94063ce0b23270433df6d3456330b4ac253761c3fbbb28e05e2f0982ddac8f13a5aaa1d8e1e2c3b011eac7ac7258bf71afddafb1bab0b97028e5e2ef5555fa77efef91692e28782f919f97919ff0c120ba4e1b54a58e3854c14586150098545caa7aea02db8e45698fd834f809fc76348f6400d956a334b69ed3663e9a2a07e6ed8699fb1a2215975e4ca6e47a776d64362678c8259468e56a56b5084e21e3e85ca0c6685dbf066d95e1be05b6e61f679121abc8a55984acb239b467344861b7122140df2e70922d21816b14fc43b927f90f34b9f2f087deabb2949c009c00a14b66ccff2ece173d8b74303c4e954377ad42ec354477d297024cd4366af6efe359ff9255ba317086cf6b3c3399d56f8736ee82f0adeef24b3c392f79d8866915aebdf7bd3b5fbb4b379b07744089c597be5b7e8ad5c2a1edab6dc7af07d46f10ef67d983c7b82294763f49b3931c1b5ad9b0ff7163937ddc23b4d9e15f5dadf19c225b9b89b076ce764cdf791b24073d2e7bf84cde3a733da98afefdd81eba1bce5d4df1557103235d5affd42f0f201f14215239d53ce714b3ae2d9d8f74967daa12d78352a6e391472ef9c158725db475aab7527777752825c31964e2cb6133064fb652d89eabe501c730272e385455444e1166b93e88ea83bd3592ba689503ecb14b95639693e3f7cc92a81970c882f897d13c5ce739fc8a5832b5075db25436e91de1f9a42a5dd16278f83e8c3dfac383e131e92170fbc5ab9042e59d53b77170f02731cdb929f704c9a425f500458385eb2444ec383f7a09646e7e24f99f12ab79fe70a4e76aa8d6542e84b6e238a3981daf947d256cffae65504b4235bac320238a24115821a8566675ebd50c7a9f3fd4c5e94bec0edf0eaf126399b0746761be92e85bdf3de2f98cdc021a3ef835980194d0c764f286b79b959722b854a7496bb1504652f7a68ed8b08486c22e01b273b28ec8d71c3a346180e514ef7a356fd8bf0785776237fd06aa1723e6c366f3278d7d58060f0d44b35311ceabd3ddbb45ca6f06544b18d46a1ea1ed64c7ce9d8e5899eacbb0f633d3f9fa5e03d003e9bfc2df4c66553221bc0b9445ecd4ef0c4676f893dfb3174708b509a51200360cc26fbf8f107c95b6d35a092a32f16307c4caaa39eb741634056cbce7a85e02b362276bff6b12848bd1ae8b0c6adf82bf66603c57e87105a30d0eb6badbf7b340900deca6a96fc31725248a2133c749704ca7004ee4c480db15d5370447e457198d7f40216cc05af9935298641d55037c71e38596dfd21dffeda63112d387404c0de51afec3134492a775dca2d32ba90b4814ea0b0cf4df800c56bd51bd901057bcd16d1989e3afce29fd01b3b82d011913f117f3cd2551d59d734becb50f4eb4504428ea3493f74efe4158230ffa3ddf81cfd1332adcee35b2fc69edc8f44c6f46bed8307369ff65823af5c5bbaef58c95b7d1fc22b29785ab8c9a0c45a57601e1d50bf80418f0aee232e843d8a27f48e64e88435d7ac6970438fa7460a6cca5017eb50266cfece16bf155a8002251b7c868642418097ea37df907f464c6421e8f4f334d64ef5e3cfdfecd3b4fdc559265e45aeb419316b7f44ef4b3c20a97b82daf6cd997a335a98b3456d0e94ae99818e3c76bc3be1979c73d0ba94a376e4a100c9a970f1951445a0c4db204b4389c815b2329c642c35df30e70d907b340ed5cdc7de99ab86dabb53c1e7eda70b78e32876bafcebd7bffdabec5dee03839a75479e694f0a36e56039264b0939edf29da4b98fd1bfcc9e82864554c34e8d47a53e7960dec80720ffd4414ec4725f9fd2c729f6f6aa9a8efb6a1f6a35eb6d2145b5a12f1633d2509a34e7120ecb730b1c96f3666b707afa5e312efb6da789b3ce94e881072b58452da476c795002c5dad5346d556f8c5329a7297f1a821a626d2ee926352b4cea6316015aafd8e1e4f39be5c3145abd5f5062447966cb9909744abc152e34ec393ae535f6002452cc9996b1eeb5367f93d8c5472628e4a251e0a7ed3e1991c2dc7e82d5cde9ba79c514408713ff487b07514671574a009244ba9e9085b346788338f5b1fd5525255b9e4351a1b14b0810bee3e1b0d01bbf6d9442b7d6a95fdd7c01843084d424bd4af58f7e780a1b2eb6a054baca688a9f2883b159d44abb1bd5f4ad693fd79730b56eded9e248061e50c415ce656961801593a6b18f66d316c6b38d3b4bcf2f4e1b7e75a625b5c84915d167ae64bbc53f2960f71763ac56300e7e9fc8691419c32e4ec6cbbfcef51405834c6b3166e246f0637cedba6e1a27b5461af6f13280967de2b606acf77432c874ea368f28a8c98b3f32458d3b68230b7554cf8312d539c093719b59fda27ba0efa0e6ce69151cf3cde2a7b9352dbebb503e47bc8476e03a63d4864adfa7346f1f90b82ad5a56cacc64f7730d6c86e4cf599c8e3589058589bbadc239413a7187f1fbabe12098af2aff46fd45842b53f84c1a86849df4bbe89b72813aa2b66dea0e83ed1279fc1a4b5d8a13f5cce642ccf9b9f0006047a7266f923a5a64169727aca8523bc685399c388476b0759ea530e5bfea82498afedc56ce73594c4aa93d79867e8f261fb48d1b599d56e368f788098b709e2deecb32f682645390993a173073ae9171c3f77fe61932096e07744b2b00859440fca1a42eeffd36efbb40bdfe7c3687addb1af3dd485897eb95d769729d1df850d082f2b2002fe8e48b261670cb10884629b01a67cd787c235225e955f3db7cf2c61dcb7f37996bba4cf394fd7354495c8bdeedb0d127bf6ddd69dd53cf7f426166633c34e306fef7504a9fcf163e3c486ac9ae2433303991263190932a5c38b2a0ffe3dbbf32dfaf591f4b117b8f4deae39a6419c67049d53835c5e11898e82d87222d30bb3fa43135cbebcec6dc4ccebcbde847f2101eb9d1e89d7ae0dc5f11b341f1e42e7ff6e2fc90fa5901df0f4c925992560625e42042f534a03554cf639c2b09bf62d7279a5781aa7f96f16889ff45101ee1c837a3d9359c874293ec0ca19efc95799c816ebd25d30c68d763db9d52519e1d4c363d9ba317d8b530b3555bea42126bc8931d81d5d70c46de483050e96beef8193a342e15408d6ad214af633800482b5e6def4f28b75ca23c7546ac424fa48182083f266dd8c36fce4699f34512405150079d760bd9d1d2ed47e8d9aae6381271b177e0abb1a0f3fb505aa7874d8feb407854dae631e0724e1c5d2fe10e5d2dd183a40546c35dab5a0e2ac97702938710f585f870c9d0edb5a50ab87101eaede2000e424c798f50306a9c426e6b6a5574ac996a81bc16c29dd3127d6438968fc32831768fae3bdc3e7a3312afa2c1fe9243a5cef0dd1b982c28e09e669c828696e4a5c6b1e6a8eb82573d511816157b5e937c3365d6286bbe1e50c4d7b653c5ecd57b5ce668d68f416b4c539272f28ab467ed2d8cf7bd435dee50caff4ccca97ff64692f55cdf68bab7bd1aa4af9757a98b920bb3ab809e9fa66d19eb19c5497bbf916e76450c3454b9ce76c4782c06144f559fc7e536eb9afe2af6e25d31ad3cd67a2942f5bd06c0460d2ffaaf78ddc3fc4696f2283ac69194cc4f5cb9e7b9f734d0299a56f0cd393917ae8dce2e6168067b82c578960e33ed4278017c216a6e1d25194a6669651dbe5d800f82b40b6d87b8f0a8273b2ef57efadf3153bab0233df1ccd9fbf1569b4c6d50d27193f7df438bacb73c97a6b677b7b6050332876fe629493820f63cbceca300c14a6ab5be53261ecc5657e5cb2d8f763d767cf671585832db6637a39dda7838fe19e6b421aa4f01a3a5e73df1d736fc75a01187fc471c3c26c894157778efb72275851bc4a5fdca2f6f1bfeb90692c22c18a12cbd0f05065bd3b672d7748b0b22ac00bbdd10c413008e7bfa976278b7872316a65453fb6cba0f40db71cc8c593b7a76f32a4adf8690545174cdf55b712352c82dedc1e7c74afa7b058f9a8fa55e93599837b5b719752a95bae9db9b16f76248651f6d6c3f0fcb0047e136798a91d88893fe66cd47fb57a5e0d4d5c199fc65a95f7b6a372a914413a0cf5c1dd2f74c39fc9a894f0927d62880c788d71c807a8e02e0f6f61f95f1a197845e5d3ba0d28769e0811bc0384a2c7605cbc3db5c2e26d8de859f637ef532b6c7ccd97f1ce12b4be39ca6e410be7e59d956bbbac13cf1ef78716fdfad977ad65aa83a7608429bc9a4e99ff5a8be57ba41f216349ebd796d821d22bfda2ab282b0ccf0b7983f33df600683d99c11bd4197c88c81c24261cf1b36d3d8885e41371f1fd8bc415f602aa349eb6dbe10002fda621e3b09e4c70bb00cb3b0485bfa3e17e1c2b4b8155e48b276b87708975aaaba7a158e957a07f2b38c88e53ccfb1d7aec299d95c46631484a43d269720749d7bcf8a8ab02580e2100ce10d0cb1578793abd145ea493594290dc1cbbea0bad0a0a090ccbd6678fccbdfd038d00da0a4189548f2349b781f39f5892ffdd2c3244d0bcdc8b004cb098bfb890226f16d66c780bcf05db44eca7e71f27e1019aa21266f97e479d2088366921827e13e34f7acecc260b6e971d5b76733559033d41a103d8f9dd5c4b2aa9356ebea9b034bbf504fc1894ceda3714096ba937827cf035de57b0f536f9d7e739b70b039d187f64d3080509815392f7fdd24cede7544a8610691e0301189194cb81aedbf2d9e703bb80318623a67ce8f63a604520d49dccd05fbc604e42ee8bde01cf0489a80289beb9e9d5cf4d2e2bbb6e3f3e1a121f369bbb3986e711c3216be7d2fd086335cf5b0099e38f529633b6fc751816aad82c111fe5489f9423e122ceed7856606b38c90318b222ba1a0009d2c09e0f1867e0559cc85b7ade0b994f598a2100122d62ee124fffaec9b4f537239905473945378fdb154b99977b6c56e0aeb3b5ea7aebf63fe876f532a54f5a23a90804d9498fd8293ba5e7f70eb2838ba2ac608b6d8147eecf7a8545a48d8d39ed39b9db3d2d8e60438b5e9f7ae21862881aab4e39524cf134fdadac0d4e16ee805e25d93c4a42f54939c60807e830f898d8efe173cbcd3a8898a8c4146493ee575296380d152ff15915c0977f8be479363d5293e908df7c480c83a48409d1adcd1351d8d4e46ca328565f1e766900d7a42774cebdeec26ad45e2238109e48fcea894edd107f6ce56e71620ed8522da56b4992ad4c7734b2cc217cfbbd5818a6ca0a89d4562edc5bf44910f8b47a4c8d93f92dcdfd92048981943ecdef5f8ea05a73d59a333c97e15355a835fb89646f9b1a0b74ef1a4a40c2ebcf44938357bfe7d9b31c8a90520abb8a0c74d2818857f32b5cb2c6bd21d91ffa950641574e01625fb401b25e3e8218fea6b5645f7cadec400827e8c462eb205a170e6bc662141ad73717e11b8abd12ca333a0745082044f480b4db17c058fcd54c49ca2323eab6b73d9fb6287a6bbe8000839f0ac165547f535b225f6a5ea0d33ebb2c73e3d993f3fbf1ae967060088f64da43407436924856fb2b850ab07e437993eeeab625a8b35412b332c2eb91f1ce9aa233fb4207b2f474e4d7c69cf6872d27dc92ea30fcb9e062f6fcc04951c1e3f9424746234adb4042c0ef1220b8d93068db9719ffc8232bf5b251ee7ecc77dba93b1b8413c112c674b8899e4f3f64b55700a403d2a2da9bf42910ba668c97bcd1a93b22e258a05669041f6675f605348f92f9721a73347867911e264348a998947ad5a7564a4cf0443da7898deb570720426f670d00311e3e6fbef7d17fcd0f0c3c5b60d8c60d8e21b68835127d719161cbfede61f6e81c6bd2ce4e8e0c9eb1a90e8bd63d04ddf74daca69209655c2c7933637a3ffd59dc64268fc8d61998765cf531908f7a9cf41b4b8c0c3e5e5f93b38da03da33923f1e4e4c041d5c4e01ac2db5bc7d39943e9f41514a2eed22c30be3bb69fb19156c80f3c5b3d8c464e1831b92db0dedf34159e959a50b7cd6953de0e6d053cf5a6cf5db27d7256254609a31c9ea13e46ada00d76ce6314cf0053269847c2ab02cddd1ab794e54bc6bf716512635b869d7a074f05d7cdbb4e12b76ee5ee14abe3e114879f99e1bd7d5d952d98953de856459e9fc32a2137633494b6cf40bc3580c8ad93ea9093521ab2ad6a85c768f4c70c2d52f87ff3b62479573b174b538de6bfed5ccc61f920f8a2ffac3fe1ed77f500789b8777d25d14d0969899163108fc9a02d2d0bb2b362bcb3970f629e6605d3f4b8ff0d95a7dbf9f81e0f5b3d5e99846c1b5f7071ba474d11ea3707ddd7bc9af07f6d5658de0b8de16377abe39392a00f5751b24a797c5fa4b0f98d202ceb8d1f747e8db917df2ce5704cc2bd989c966da5338e17004c1c13bfd5d367d441cb6bfc6aaa67a3972172f1947ab5aad1a77d60bc7bca3489691313f7dd1c40425d27e1064348b600256d29f97ad893e39cb798c1f69f06b29e991e6f3f86a681a02ebddb3aba6d151461f8d9f0e3dec56b65cc5adfb130378156e72826e1d2c6bd9550797973a709bedff00392fd4bc8a7cab57334549158cc939af4cd585a5bd58ff3beca671e4a91b70653f2aa8cc22ee10776194212ee0eb544dd6c616e9821586fea2ebe8492a31c43426a86f2833950477974e2838e932a80548b094abfc5ce78a793e40bf5b341aff8e5ea2d325d4086fcb1f6c8cf98876d1e8a3cec8f6f1f8c9bc983f48f6a7c35ba1cecd81114950c683d2debbfc691c1058348e63252dedfff3eb54261ae3f015d6648832e7d0596e7936c24a06443d9e243d36c98e5bca5ebb47fd8ee2d083cb11477042726f5382cca9465115f700bec641a7c9bde5e74e6b8215c29e0901351db844cf07b0133655254cf3585431a48612c19de3cc6c0769976df04123f0328ca814ef5a323f6d17cfd6d908ba775e6434af4b3b5a5403c8f882ddf5cd0897f5bd886167ab231baf9baa9dc36f01c683032a5c96fce9c02f14aa3bc474d9df32d93114e3752826a6e6e948888d69712816d8d4f66f6cc6fc0812f29e1b90b1b1de6d9c1481a2140cdd1c74355691d2080aba1e6babdcc66f01c5ef72b9b6879ed6daf35bce67f7f75dcf3ee177d8827db90623dd2d537d0b14d5e4ab48e7f86b70760c1117448cb52d58bfb009d581b8ff67ed2be416ce263ece3dcc71e40b1073d07df18273d1979fb0c9fcce88d27ad38f473a94d56fbca57f2fb100494d301b492e31002a23056cae8dc14fa59301727102ac7d2e38eaef80b449651208b04c0c3e67ed543bb43ce23131ab7eb89c7c9e1fdcc4be3929473066e7256db024c146b9c23b56846e4a30b28147500523bf54679ea867d4b84aca34a4c0a84ae938e472939303b75963da0a32d7e10ab5891ce172c1611130fbab162e0f6352b00da521031b87f1869759d8b286e8de67e4188c89f76a47e708e0cbb2ac3034b88dd414d54024ad7e3a420d76aeebe0f26c099e3cb4d31634f4a4b0902f40e4df67163606edeea2c995a9077a1dc20209a24e3f1cdaab018ea753428b848d52bf41cba0d2d1e08f1c096e41c5fb406775ac09bfd52bf26ef76da27bbf655130492b21ccf8655fda064600830950b51b7c7543b40b10b054cab2217b2323f0125565f506cac1612e55ace46ae18038af15f9a70bf284694c70a92c13595c6b9b1c47d325fe9d82bd4f185462971364025fe7a48c901918705eab9394bd483852bc06208a5b699389eefb76ff3dccd0eb9a57c610df3a7249aaafacb9bb1f05547c4ea03ac6f8195eac93c099c0dca316f9d6fa2c1aed732e2aa274e60be371fd78e1138a98956df1a745c8ec5d33325ead1c9dfc8756c1dd19b9fc4b27b9fb959f4256738a803319641a6bc12029d9bd8e7173b63280bf121f67108e55511441cc46f92f2eb20fcc5cb6c1b7ed9e7dd4dfe8569ec591dd90e51c78f4450201bdf958b3ee06a35eab2d2622e7f4bc0a33ebd151c9f1016d2c2323945d0e6dc2383b6ec6373d66759d80d73a545d303e723fda0644bccd71d9e1baeb2a9eb5e9f10a7aecc969b2126500620d91fa89ad534b75b9ca6322318e4d4ace96c8c0df746b306387f671a92be16fcab0797641e72f7c8b61185835f57ccdb121449b41ce89c794815e573c3bca3276fa80316e219fd35c9ca15fd55a3793570abc7936b568358a2c1ba2607a0a26f7d5d1e5835b4faba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
