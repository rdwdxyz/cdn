<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5f430cab1834f5414f9b8b0643ed312150ce639140ccd491bb13eba8ea5679107d36212e122e4d7fcc0a18f1dedc50534cd8015ca3c7ddb2754f55a047c86d0d4efabecff2d34a0bfa96892c40ceb635316b93eb44b222abe4687cc414b889dcb4d24402c94fff1c76433d11df34ceeca9ef4a5626ddf469717604f14f92dd4c7ca82adccf8101aa3063bf3f0e90b8af698a1bc8d85b2ec2a95fc4abbfad901599fde225cc31ff12758e689901a149094ed7b65dc26b6d8736ed3a3f81d5c2db60cc9d919bee3d5d5f39093b2e2b21b66d660cb8ab8caac60329cc31cd3300141678d8393d30e023b0393d3600e70b792271ee69c1c3dc399f1fefe4e7a981e9fef8abad82c4d44ecd81af790f6d9f95de41535754d3e98697f64766494cdfc4e6544cfe15d558744bc0306edd51bd46fa1663e9e29d6c18ae35c75ba538efe547325f12f0f40b14b729d8511891f97e3e4f6ecf338eafd64d28162e05e12f12beaaf528588a0eb3bb202b5b78f4e3c354bb7ccdc07917d40e381c97a3c43563d3867de39d0925dfeae80b44dd22513d1aa57d1d43318c216516b4a53a5b2bd4a173586488edc58a8f12276f50db159af6c948b79c18f92310f1d02d3daeda54cf77513ac2d93d7f6d418252b139e832ddd8d6cb454ae380f037533ebf815b649505767df814219bdac651fe9fce18908a8cd0575f276441e050ba9bcd9e93768ec51b713843029254deef968c85d3b672e367bc7d4eeb836140476fb6440d2a9512b040b8fcca4d990584de1fd65280ada9e7dab27d4841dd8ceab0003fc792c1cad70e17b33bbd4a1e8c0b9f21a45b416ff2097fb687b3c3a6d21a9de311d3b8d525a2ba7ed0b82ac7e5c1b741a204ec491c417bd322ab49eeaa8d508d0633876622994e99fc9a6e5d1cbac3f30f9a62f17e25a74a4c8289824911a5c91303436666a4ac57c531c2ee35d3be7f7246595aae440b3af5161a7a7f43d95b9db017ddeb59913c3f664f416cf92a67b6bbbcc12336d4edc64d8bc3c64f6a9f700b128c31341746e8a2d3cce3bdd3318a947c5e6eacd70c4b56783a45a7190e1b7aa91c7e0be3f28758f7af66a5fa5a3deeafdeea049b1daa1bcb41a1f529a0ddc42f9256fbc3eb2b180f754b510f21dc317014065767f36b9f38b06c5c3eaeba13a78e62b591875cf89fadeae0b5be0c8dd6702c607cdcac715b3a0d4f1244ffcf692e405b82cae89bf46a6ce1d65d0093f5de9cb466c8c62bccd58f426dc269cbc77e26177e8bc88ac7e26c7bf494d3924d7e4596adb0fc370b4e77a894068b71dd2cebd23dc8b3a1b81c7882c29abbf0aefe0327c671c8b98f5fd79fbf293ccf906f51bbfde06bb21bf3c0c6170ab6dccb653e371912427894d8782462dd6dff5ba2be8f46400c740c6f08374c63b75136c5cfd099d743c6f8f8d136d1b4dc9b974e0ed9d5fca60596c7a2f9d1d7d13c7ba9354917e4de91bc3ecabc34ef6429a569785d3a8cbb937d55f9efae92c82b215c69768d6a9e7384d6a2b97eccf9a9dff3da013af4c638a70cf0c4339a34b446038d8891424fc02c5c7c277cee6d89757cb0e5dc06437a6956e77c629714f1141fd79e57c7b4b39d6f5299163dc6a5a6a99feac523e4caf31208e90ad20d802f4372689b4526445f54439c279a304c25aaccc76f2aadd4d10fd36dec6741b81bf89e218b747ed2b61c41543f63242745e56a46501e1f6d7df9e0edec6b91d5d5d746cdc77084b706ae5d071a11465b057d695948024f0367a7faf69abc4a14fb74d0ecf24621694c7bf723e2e261b85f34bd305584e3a7c144cc2961ea9fdb40324ea8adaff486fc4ad669756ce590045b03a3e01221b5f8fb80dc43ed7ba0ee54fc163f0ee17701069ef7f6e346c4cff7a46e51f52b3602e5b8a906972cbf123d0b27e6f09bc153c7078ab2b55bc2965218d7b106090a1be27c90f94422d56de6e932cce493f4ea5396c508883c0dec7527cdbc34a802ee50e26ec96322f69ed650f008232d9cf02bbf04ce1b923bdca9972408b85f78af8429857bcd92a50fb821d0d4423045d6a9b1f8ab966f2ddd1ba4eeeb87812f2fe1644dfd8989bd7c56825156a30d34969fa92709b4e6a007c72c9a74530dc432db49e219f65d1f84d966f25da2aa1d6bffd30024e5d4e43fc0183720c57bb9e4bbabd4d5e9189df5038f6e4f920f5576879c2be360c16812fafbbf459582a0cafb86a4c1f61c1863bd22c228c372fb55cd2c651f77f46245de7c793d29cf66d04aed40017f02e8181bee2b6cae08fd5057c89387900af169794ab3196b3e4d8d6d69e9fe930b81f957972d234f3596c7f3e15ac7e0afaecc6d382f9eae32a6b1f64cd050199675758775b19270d026f4f3c8b4907986fb9c66786dcac90fad9ba578956e06a16660a240433905771493e1058a509874de257f51a517a8fa58431fb04c69fdf08af1651732dbe907158e5aaad7cf7be63d104abc3588e20a2b27fe910b165c023e927904c61924e67855851ba06d176317c5f2f586021e8b146a921887acc8ca29b354b48e8108bd18a493d59255c9552443514a13d2cabfe7a89a43ff162173c980c612466851e7eec715d0bf6ab4a5cca5f27e60f4a496fb8209ba5f0fc55f3985607e4f065bb273e6f9dca24d73b4bb77d8e0c2b6104567f30b2d92c429d575e28902d751379b71935dd2e8a21d6ffeb124069d4514f88dd706254a3161d9af0dd86c29294e788dda848ad0c3ce0022bc6bbd362cddc1d8ba7d7d72683ec8bceaf2350dca4cbb3e5f7a5219a5128d12d0e393617c4c2357cc2623d1a926d2e8233e6e8a64e82880fdf07aafe5431fa05973db17844c8f73817f631d8893bc4b030be054a6580922d22d361854405a8cecabaa81338ed22bcf65a6b8b0a46c5f86471b376651cb218d6c458dc0b0b031cdc4e2be76a21073fee14a850578e45f5dbf5a998cfa7c4222da872f6c68c1f37e144100f5a89f30a6c36235f7c1d3d33520341225b328e78e0c9da2c7dda6ae00987907a250f8bcfcd7e5c2b4b1eb9e954af018e8894956d58038c72c3ca9eb13f1b9e92b77110e21e9bd8a64f0e8a8789144a9d8a9655a571c489cc3479a2cc719a6916dffa3a7acaa113bfbc91f199528c332d21df30d1bf1dd34c3d8a4d345ece0c6b195401ba65e26f55391e93ba5b6cd6d0e8804d0ffcbf3c4f22866f1d78a1df10b51846ee4a4a19f27a38ac854bc7eeebd43931df81a2d7d4e2ff918a983586c43caa0b042198ebcbf541cd92eebf7218faeb8b398126fce1c8a5b6ebec3a053b052b26a7d28a2f2dbb564dc59dd3e3093bcf42b6ce8bc08059c5ad38aad5c999826c022f8f85fae92882d24aa5b87107ed012518060be379806e12ff1efe7fee364c0770b9d7347127713a5840cbef144834657ee716ecd5b9b44b56563c69f5a867e06e9db6766c8040e7d5c97ce4dcae7a4b182ca73cb97c873603faa4356b99916d1c8152c0f79fdc7b015b8463a9c669ec8a770a819e24e08fa8e26a38ffa86975fd98c7e4ad183eb2ad39f94287fc50f8b0d8931ebf0438a18b32db91e2ac25175114b800151242712cf11c60cae86d99e2c08523f7c2ebd428dde37a30e37cf9c540a02c737da319cbaefa2d9607035ef7e4372e7136a8ab17fa0eb28606afc0aaa1b0d10fd7fdaf71c2a94f9ee7ae1cf78ae8f8a314f4049e5372ab5cc8532cdc4801583dd164155e5fc5ff6da3a29efd8766bb9ebb2020b9bd457d834cc32c5d73dbfeeddc5e8e186995171b8ff3a2e322afcc68ac6d455e572a21aa8b392e22ef1bcd7edacdcaa57cd2bf70ef9de37b68ab2e6377720fea00d85aa44ddd73d0ba8b91b7721ff405ccbda0dd36f84079d89e8e342b757e934b36ec722187ab5bbc7a1c6875e51c1a9d970569649624e994c59a8930b798e3b73f4b71d0733b42ccd33d17b0fc427a3cab07814341a242a378753a279907e6b37785492c68a1c6baf9f648de74132e298f44aa56513314ab1cbad799f4d95bec647f1283b32505f42c4b8b590adbed17e618ec289a8eba0ae13d5dfe365b2c1dd89d8a542abec5b1855e58a37a60bf1f71ff1b615e754a39fdf93b133a52f4c4d43447679d0f3751c49e910c63241293fa910daabfc870809e350cc4b1c3c4f4aa9ffe3c62330ecd2bc27a671d271e878e2009d1dc58658f9da439ffc8a2dd91dd8fd957047248aecd5eecb5a3410276c6c1307f238874675cae993607690ed75d82ae1d551ffde56fe4a1856e5f30808634267795393626cfa25b786117270313705d9b31efcf10f172c847ec6b5f2f1f8fed1fd04285640123139710c54e8946df42c2e0f1308ffbfb506e56f81abd7eb881533fe3788ede254e559d4676d2cd576a70b88f7fb219197651fbb5aa2d8317277858b2174c0b9992a2be60b02c227517db91c6ae637a26fbe809f940951c648e2da27a9f7becad54b7bcf5d978b3175ed5dd0bad0333c668924d8ab03c726e4c11acee4947aa094491a02c90d58b2c25797f96fd9830ac94b6e3b7d387c23bab1abb5184fae1d7db7f03a846004813707ff27b64eefc8349a6f5efba251194f2b66a0913343f6ed2a67a7181172bd2aafcdd76b9bc84ef8df4f408555dd5c191d36d6cc4eda3f6f489920092f6193f6efc01a940b0cb28922197371afe1e14629fcbf4400cf57fc822fe065a0b674f15e647d04346fb7665d3d4d6a7ef5931eed80e34644fb75a57cb1ff47b719372534aa702e15d409ee07de41e44f2b5f124bb6c336ddb856b3bf6256d1af41a00538a815d621325e243e9f17cb629abb0f5a21503211629d33408392cacb43261356410e3613d2f3cfddf7fb42007657cf1fd619a08bb3524c1230116d2e26de13c5223b668bb534c670768e919ccee6d8abadfa245fd9d3b274d98ff74ba5045dee60e20091d86763a149ddd77ffb6342c211d32dacdb5455a68425aec0420c86f88d454f5bcc0d3974508de70be3953bcb0d5441cd2cec6fc31c548537ee21006b81816d0d0777a56a43d23d72ca68fe35ce2a5f63072f512b5b76acdab35e162d079dc1a6a49dad2054a724c46ef822e5a55ba676949f16947180ed8e5d52471ddd2a8ee8bf3f606f2a371265843a3ca71c06c690c0d4bd353cea895597daf129353a17fe4d161837689eab2d98b1b493cd38a3b7cd866c23d2bd142df688521074ab4292851f8eb0137690aebc417e6b12776e75db91b57661e24a2ba986b2db99d00d6be857c73910a35f120889616fbf68be950b8f97a9d52e391a9bdb5a5b6f5afe5c5366f8d3f047404bf08a3beebe1461eeb0c97d3eba3b1c44232d63a79371b8070a8bb6c189c1e043c5cf26a7a8f0feda12923d42d7356f42d278a2182e4975bb008cd573d1d13bc0b270ec567874251e3863c8a9b450213a554a5b101197a861c5d6561e0df50b37b872e92c80d57e506407e01587000a03d4b03bf88e2f1ed7dd3036c7a1c5162f0fed5ee283ecb28d4ef984506829b0191237be30e6d17422a4fbbd5cc34a238d4369614bca9626e10236c37e5d45e4f22707ab3284d616b255428d264bf7b14d95b45c2742ba3cb280196d6513dbb846dfb2a7eaa8ff4610875a9e7af40299989efabf8eadc9a1539b214b622e6969b34d3d5ff6fc3fa76853fbc95e90fc891d7aa2792f79000cb80045dac3dea649cabb76871fe49fcd16a0b1a572177f4172575c5cc3368dcf0cf0774b28d6dcb7f9ed5cd34de8ad2b500cea550610ab6de60091ab6e5e2b40ac1c4ff79a2dc4e4dd91874abadc2f47734a2fb8d9dcf2f5bf08d6f47893db88a0e544c068e5a257c423a055d2ffdae4a139a0dfc38680f3e017fa54685cc595d4dfe2faaa72b111242bc2dd894c572248a1d486e8fa75ab05a522cc5adbfbc37289f8589d99d59d3d875a0911ee7031f91b2efccc39a8fcfe6fa9f57ef22011c4e28eea66db769a2773d30773ed1c03f2075cb4fe76eb526e298bd33dba0320cd2961cd50ab31786af741290cdf28d42eb5e60cb2a4748a82c3addbbcda909fb3078270ad1035d65c3429b35c0d915cc9e75361f601a92776e78a7056c0436c627d5b663cf9b0a8931f48c99cbeed35e8422603afd37369f00f2addf8a3718d341449918c1486ee6e5c18c0749b969d067c155d89e8cd544cfa8aa4c21bc02d6afdf3488ece2eb2909e1689b24afa7f0222411d0b404e2a27f272cb49e5c881a069f2f18dc931798bd96a917f1a288d8c4f3094dfbc07079712316542450d908f3c2e9b19225e758607ca91045588ecfd0a43f49317a2c0c94dbea86b106b258a373e1eb9650cd8c07869e619d4dc9ffeca930ed945579befbaafcfd77321a5746a137dba843a315532c07f020a75cf5ec235b7c079a7a5a5865964416ede19e38bfd1e6a0c3f659fb89aa2fdbd0694e7590b520cce944ca84ee5aa14729cefd2e0071794cfec598c6b58fb9fe099febad48430b49aabc8de79b72dee29a6db882974945bb9faa1b312787f54853c6298f9585be8542d3d3f21e9245a04c5e14a9ceab8ebdf34921ede381e51b5a678da3abe482607d65cc949b3d438108014d244559e83e672ebf70faf8faae5b237a5bfe72dfbd763dbc0d422b154e28728acfe4f4a300d059dfc6bd7fb8e9a2d6ace3c96692f007a3e598c289d6b3f3e7c60d60ff10834768ccadac78b7fee38936aaef6fe9f83e8f4faefff9b22813f4ee341eafaed427edffcf934ad67fe82750660afe0fa7212e960cc177c50d2c4b5e9a64bb03322d564647071a1df0fb9701e332ccf0c120c2ff0bab76f824f7debde9a67ff1a3c28e4627428b406f491f5a295e455765d22ce4c13a215dbc055ed00cb7ea845e4e96781c200e48c6054fea245158a664b98ccdb44c023039501cfb0e6516a5088910ec44c3b3b069f6dd0d5689f3bdc6a9eb4a4620f86fbcad5c524566474202294169709f261d5517f46480543cccf6e878e573ec09904783ccb1aed4d5b37bf0bc42c55b343c5e1e1ac02b1818e10a84be04c1ad95415d3cde6df8bdcf290968cc5e6558d63c4c29765dddac65cc9b0c4294bd5198efae6dce4e32160ee5e2ad529201eb981331a627e512388b22855a0b28623419572eeabb83c167293ad36f9e329b5edac9703982fbbf2c2e6b4215456441c7a1a3406b56b3d01e746fba32ecbd6e09a364a145ed2fbed59cfb1f2f5c631f38100e6a5170d53e6b2c2efe31bff008f2560c3758a20fde9812cd56a03cea4cd17271cce40e1c64d9dcd8bccde82d2eaaaf1714e8bb48b9f0b076aeb9244a45c17535981212093e44943089ebde949f3739e675c58582a6cdb449a05492d7ffb3f26d970de00f24c5356672883b9dc799ea1241a7f10f6f3a0865d51e0f1c5d571637af3d8b176dcfde1fa2739ca2a8bfde315004e7983372682a391269f8c90addaba5cfbf0bf458a1e04eb6bf81a1bca7420dc0cf7e611342962b4a8ba28112b084ae9dbf8458180986fe8329e2e94e138dcfca669ffa3a869f5b04b1c48c2a8dcc78ef37ae021a406358a40232cc5e283701b829ca9e28d1cd1073c1d0a0a65acdae2c1d1d0092fd37c2212735e93e7bdf4d5e21f272df84237d711d6627eb14dd98ded3d6942364525fa2a201b2e712032229fa70fc22c38133f238fcbe0032218def9a991eaebf80628d4442bf8970b4bb273be89a75323aace75bc45d944ee2e690ce68df33f2a01f40128309fe34d60d426b028ecd78cb897217253aab7ae29b3a5ea9d8fdfa8bee58d47fb377037aafe29070b4ba8ae4db85df074438f4366bfb8ab9e92605e53c98613caee91d061f04eed80d32a723dd81dc8b3eb3c42d06dbb0c7d61611d95efe48fcd0ac2be9642418cd136244643650d066fc79066bed3b1e1e340147cee0c925b837f7ca6bfcd7e1c7c0ad5d6d37ff432a0169c840f728228bc4861afd6a2aaa775e0bd050f8b3ea86d5fe623ebd10cf02e089ff401037061a534d72daaa03e4160bcfeb2c3cde312b000f97b3d90b85bea23b4a64eef17b3d6e691f0799fd6b37ecac483a449991356f464c91d157cd3bb47113c07b900a77504b6cdfb8ba0417fb0a1ea607ebd506af721697ae7602728e6a8146e1a542caec5243acf829e66ee2400a905cab4570badf76143e0f007775da5f28f41073ab5a6b439f2c0190164dc9aed971a656048237bc91de406532a5680967f61a0894d1ff9f493776748154616664353fc7933904000410d906a679a50752f063e14181812a1575c57b96415e29c66ff39aabc498a0b03341aee76652019d21d4a9db8dd8ebb862a3e38577b4bad24d619f0a941412ed588cf3e7d40b3705833e5c7b40cf39be2cd2ac9c7712acc2d017757e85c0d65a6d9d0f0f360420c3eddd1db3dca00f411f64d7f8f82f5443094abbbe73b4153ce48af55a39f7de0b43a738fb8be257da111809ebb37092107b8032173a069c9c12fed69a6bdd0af8d3fd4c47cef4990fd33c7792f448707cb64fbc824c2ea4eb1af00cb2685db1df15f20630f8bc4737ac0d81a11f83ddf25f2a7584d5de95b0a675690224c4296800494eb409e1f2a129fc5b3d1a38de3751185e6630d3e7b30e7d0f12f7012e02f89f933c1d1fedc375ff74428699be5dc21076479e837f75afbed2b3ba66cea734153186462213e6075fb57fbe8c39c0ad00f30cad3a00f1a39dd4ff9470c3291233d9466708c209513195092f140f8614d0d7a1699f2fefc2d4b17ed1435192231665f41d386c9da997fc1d081230bd8c7e1ce0b98363be92e03e307af9b67b52226f42417b39487bc812eedbfce784b1fa3bb9d4c6b71fea5c9396b79262cd259c339f1515f8cafa8da8c00aa2bd89531a1898da0d4492bc52319c617415a5cda9dacf8cb60a9a85a8dfac105d73d38b591fbe57306f43c35512cfd6343802ee7f7fa8d7d14359b288a2245da245353de5d16d763fa7c3951f928deb03f74caca5d0e693c53edda47615cbd1e03fcb5622c8d0711621332c1c9bc8c87319d52955816d2f9f55ef485177ae84bc8d9a3abc88a7b5c94bfed4ace2a0f07e1fa95f34e21fc5d844786f91f13b5bd46c7338d28143d9d2ee8709292a15341a8e6e315117b8b1038c553b2e6ffebc242db051e17126c2e7e85fd218db852915ef896b501f82524c0e104a1dba48225ff1d5b9fa2a2c0116d4f45031aacb0115c2473a5b352fe0d986b97b603902111cf558e9e0b3b029411a08ca8f4ed12860d9fe3cba91eddb3fe19aa110a47a7d6839959ba9826a07d66a4e5cc4467c45de6e56e64350ad34ae5d8a0ee87ea557183c7510a22ac5ef4d7b8f0596932b91403edc07792eaba63e04d7a201af86b5d3a01f7d6f294669e617ed5b91338389b4579131e535b264229c5a31aa730753f5b26272271a0ac96eebd6cfeb1568ba46166d3e2c5e6de61644fec2a5628f055dbe6d847e92f6dcc7c9f58200479db4bd4807a50eb6545259e9cd5d6b98af6f56019557c79ae97be857ddd7d3204fd87789275e3667e67447bcd88e7fb0227c86cda7b2a2c1caf8ebe8346caff593a34b61966f5cf3497528069871972f99e8cd6edd395e8d8ab1ae001f5453356228e7b4136f06d2ef745228b41fb0f1bc43842c7f81098612de08e04b80025cfa5b3f1a4525592a1a9331d9b0d61b9ea2a7aa7c7d48096abdc99218bb05897d0fe0af7217a0054e303fd2f867bc63d181f0751f027333296c7b75737dc48dcdc5b2938182bd27ce8d95c36d285c2f4db1f838d456d8dcc5d76aedb67b0abbb4049eca57d9ac2719a8cabf3b672b057e4f40d13608b3784b08fb6acda1892a5221cd86ef249b316959ddc315a44c3ef3825b7f9a9ba77fe63ac899739d25c44fda48ad3fa619cd063b992a4ac0490b19536bbfe7a390cdef2b792e28b020ba8ccd33328c1ce38940d0c6a94e7a63fbaa7d79b93889b2e3a5bee7f977d8bf8952f3fa4788be6df30966cdeeedfeb7d02b90b7d54cebbe1f74ded47c87864d59d3f8097e22e10b9d14c0e4ec70d36bd25be6febd7735fcdfdef48f64d88a2ea8032581e3eb4bb45845bc3375dc97945e6b662b20727a1b9ef58c1a9e805a2c5010a61990badace259aec9f87b2962d1b25d1dc42e63ab9dc7159eef4818ef3159b070ee3e905db7b6d1463a8200741475ea1a09a555278760220c1bed57c3b8b60994af1f9be67196127a69d101c5b561479d92849a9097880ca22922066a4efe5a19b97121434eb99f1a4c0afb39e5cf374cdfe937fc5d76801741aab921fb1ecfc55c72d6c9fbc9244e40b8808137181ffd2f056798f78c52ef843602eac38c6f942741fc72a5319bfc31e60090aa828eb1f8ef48d269eaee8a71a2b37c31d1b584ee68d746e3a27f9dd61c7ca07cca81409d2a03fa188987d25b1af941236ccd5b6ae8c3f1eeb34d54b5005515f58dbe8da2e75d4e52e6ff5cf105c7cdf9dd72d17175e0eef4b346a19c695bf69b33d4cfa77592ca9f5734e47ea5edd455b7167db054f4a4a02f920a33245a92a2f35dc591a2a7cb496d050851d36bffba42e6dc9145f2d46617434aaa1602115e6d3f5dad3eeda196d2b26ab6404e83be261ad9ddf325f5dde4061a4a2bd7f276720acb93770ba482f364c02ae17244747d407f6035d6024de87be6c85fe39d9dadf77ef8ab03015466ae89dcf6f27a94eeeeb59192a922a7b0b8cc4b7fed80716ba192750bbcee14e686fd27a7d5c60f8aa4afb113a7929ec0072ba064f088a7297081f0819450f081e739b4ab4ca9dc7540052d10e8f8c5a5d41e15389725e6af333ac9f4c5c4c12c97b56f5782835b802c08452329a95755c343302124750e519aae8d5e83b4e482d4e2a2a1fd39c6fc7b08f22d803ee8a21a15d2b0ff2954ec0dec24193ba55e1357c0b25458b3f38203f043507e195e3009d319d30c4500b464c67f9bf3ef55adb78c92bde756f925b0fc3ae1e759a9510c32bb914409388c0818b3027afe315eb7fa2a38dae585dbe6ade6c8264475e3ae1cb10f0298db76956a2a952f43acded1dc21545c9c9faa9576cf5e37d7c1557a5c9870677eec3bdb569d88c64039b151bdd97a2ecfdd132e239b90873cb280369734c1d155b266ce430ef08548b794ca0c04a89bfa054c2ada531aec3e81b4a47b3faa24ee304315b4d63a20dfe07e1366ae588ac682ffc30149f9e45b4b1513d1c2fddeb20ab2db7d8506f97b6a2275d78c2682cebe541d84bcfc4dd16a5c14637382e9b66033d17664c9f8d5e1f2ec393fa4449621b906e1b07738c42ff1f852366cc5f158dafd5a5d7178dd6732c582a7dee1da699a68a4616113cacea6e0a7d12017d589c6acc321366cfa9350990542e9a62fdb2592a6f3fc99a80b87d32a0e3d158661db49cafd1cba6ea24270a191825f10e0e9f31e5ba6779dbae4061b6ebc6a0f5d82d058c90a63053cf3c3acb9c4941a70fdac809cdab418425b5fb90b5a7a0df3424ae379974a265fe4521244291d8a2a59951357d765763f0c60b1df666a6a63b7c38118bdbbfbebb93ead027b0b04afa3efebf0ce75692c7c435eb1687befcee452eb62fd9cf65ddbe6e80599b68126c83f02f4b79c47281012781dba6311a76387912a7fd1a9aaebf2dd625b60cd332f09b455670b25e292f00410dd07665040edd53ffa11795307dc47ff0f50ed0d0a4660f9c8f108854f800167d30460ff3332582e0f7831b112e5537e6ebeaf3287e9942e0101eb02408d242bd2542a0234c25893ff636d9a0cb17a9ef49f906a273bd01e88894be0a9eccc2e934c068d8b24a3f1e8a40f2fb3e418556d89d50462290cf58aa10c7e6579f473d883683190df58ae7d2a478a4655dd61020b129ec3074909f7a709af8423314735c6a7765f6281a2ab16555bc0414e6b6f68eee841ad039789810983a33234a5d825c0c9ab95face8cea73205db3ba93e10c1c00cf1de8dd90480d3398ed3746f00bb6da4153008dfaa75cf9dc28d2d9149c763384e9b3bcf7edecad7c2db6e94742d0ea42bb4188669190d016bff68beab71ad103347d8ee0fe0683c59b91ccb5f93ca6c901197ff24a86bdd25c472d5e0e406b08479c27100f4dae649f226d2f39b4a63813d228c6ece1541bf0af3f6df9f926f146f315a636c452e1f4183ad131a8d618d72fcd116393d657a88d39117c88b6723e94827d4ab086c4acf2a0bb9a83ba979ebf8ecb03d92c742f60c1601693124a3760e786e94be4a2690cbad7e105b2f0a0fa505d8f676aea51ca548c075979f00fa906a46247731f0739206ab649f2e9ac3243747f661ec266abaf3c60f0ea3cf0f8ad63ec07fccb19289cb9bcb703b196d13b69014499e24c493f5a2bcbd33343ba36881b7c0f00e95b26d93a1b598ec35d5689fa980d1ed4df4d75f4ac03bcdfdc22dd0b42982a4bcd6a9fe9fcaa9e8329ccdf6c0e32f7feb70ffba3e48d28d4c48cb189cde78fa2420590746c7ff19f81eedf27251f70af6434f98f2aa1f4874a5dcc90087ccf2c622683956d85e826ff920ffa622c1c854d7d37eafae8ab260d5c2d41e48d480dcbd98f4b8a551d2df8f263bc68907f3b4f78a162c10f17b3a12fa3a69c71a569be791419b591234c8e37fa5600e90d77ca7bacf5f602433b3780c5847ff1e398f7162dae116ab330ebc20011ec02b4553c23431970353b6796ea66b358e36c4d490d0915933c09a441daad7e3fc6e9f20e909927b4aff295e751a458b96446eeae7e26024e26bcd81805f4465603954fe44696eb84a2b3efa95dd3f76f7c6f07830e082fca38929e22a2dfe6818882ef19e070e8f7a19a977a0c9621eb88239e8a8ad0b7c53cdaa2a7bd176f656690e6cab162dbb62e8e76d1027f7942ff442bb7b4029f1f488b92ddcd4f38cee14be1f4064eb7c4e82d8e3f259df21f1f49db8241f971bcf4c19b19108574c44c9abe4fdbd811eb40e0a327bea97d76059c742809f14597bf685afec1aa49020b8f0496d2004fa866ddb19f48b94a28021bc6c1aae2d0a209e2a0273fe4141772fb592bd4514317c6e65b92b64d222ff7258ba288a0c7ec26029d5d67fd11fdf4e167ffa250291b9f4ea3400bf44fb227286daa0a203a6b7be2e5f8de9c08e545abc074e0aef041b8db04c060a6e30358aa57d6bcdedab1efc9a352f430262bc6c2ac52203df0a257d8bff4fe6fd881c659e29c1cdbe7f43c90b6a3f838dd1e15778c4a78214317c08d3ec54e3a7e8677e9d02fbf54e7f17c33f5388436da605a5546b040f81754d6ad67776929da503679eb4fd48d93077f8782436af8c5cc68bfe15d9d21b44bbeda1dbf3916bbcbcf0eea83027663984a2ab8b65133cfd63c3935332fd0986e248d066a2c0796cc8831552eed43b8c06dbc3cb7155181178bea8458de6c6e6dd789d84130c28025e5b041fad96ef8bc450edaf8af11388888d4a6edcb13a078d8b02d205d0433a9dfa39653d7228ea6bb94a52b22776951dc76176ad790fd332b47ec78254c7cd177563fa4a0578a4dc1c3789d201ed5d9e585116e8e1b70b5354ec892bf254e3585651f0b5cdbd8dff45044e9f8ba458bc2885146fa18deaabb69c50008492094c62a46b1b572f440c02402d89c64113ed69dcb24c890802de9ec29a7761b6ccebb1a5645897f086a3b8e6008404dd6dfab4ee6c8c6d6c483623943b1b60a0aa2b1f28fc39ca6ea435f0f85778ec8366947499e0cab1b66ea08ea301d87d040d8aef1fb83e040608ad1e1da6227128911ea3d773d40ae23931f46108d8d119784dd73fb9bfc288f0f4f0c593b8507a639aacdcba7c9e69c5dde0185196f91c60d02ed2fbffc8152ea61171c20733721e8a84d9910d36678874a1f952a97e810fcdf325aacbc3933825d82b9bb677371f87dce00c0a537bd1b725bbdac56c89963d9a925bb6017109a3472ae8e476474a44bccab13485a3db7a92913b47476f10486e40da0435f43d48cf26e5e4d0ccbb2fa600e51b9b2fbd22ace7e8fd9701ea984e5e4cda5976a16ddf5d5515d191b0f1b5e1e37a2b0b2c73da2f6cdb0bc33e1537ebc655626acfa14c32b97b4b9ef43827195b157e4394079e7bbb6a0f398f2da012cb585eada442ca5406cc298fb80658cb50fbc9de0fe0c561abc010be28e09f270ba8766deabd5f79ba62101a72bbe27db7ed346524d8a486c095dee1d6121af3946d4d6d0a3c79f744a874251e611f56f5126b392788cbb1dcfd7354ee06cdf050542a75c066689e8904fc896426b1a42f0f8af56a798587ecd37169e7c57a5229e4f7e6267aa4802f9976d65b23a745e7820341fa5c4ff6c3d96d674522bb99180a7cc100a87d47333b89db442e9af59beea2f46f9fcebdc581f9dc01190e8800336e07038fbcff4dd424d52f3c3f174a6e02d6c5b09e8eedbb404a18133708dc35eed77243631b76872d406d0eb54ff8726079080d65596934a428ab295e658ee6250959f8db57376aef8ae3be98cb15df6f275d9f51c26037262a3b783ab5ef6f99969f67828a48161a64f2f6052a7bead1f2f4ceab1709a7044720a507d374a58fa7124d345a0b749d93e49e5125db7bcee9f103ef39f555424704af685336661ebb03038cd003bedcfaebde627c2f321c9a8e3309e23e72fee38c2bbb2feb94cef97b63071ca0c44408f0f1b050c4219c210c4e8980f95a08da8f700b4188ef941443d3ca6db14e5f547f8be20a13ee308d005620e983093891414cbf7328a1ea0a413e7326f07880135bb4e34bb8898bdd781eae9f2ccc869b276a9447c1148ec6053fded61f09628d9c30b8b255236f88e36e657dd45022117ab48608d235dd33144897589737cde196c1afc0ff375381abf49b91850a46a4f6575e3a19b96d1e90f20d10aec41090b4b083fdf8d3263e183f46103fd90307c1f2b5c55766dc52a47d44271d922c3133110a4593bbeeea042f8b3857d35ac8c947c331936ca0201f4071b5b6f922104d60021728890f10edd872ce342b33b1757aae541d5c0001a318806a449fd6099cb0bc7e8bb9dc1b3392da05e3a4263cd1e86ac118fb58727509ef84db41cc1e34c47c3d02ec4f96240e9f1571b8f36c840e3e4c8a516a83f7dadad40af59f52e9f3e56bb5cc4756f53f04d1cb63864a43d3a83e02a8bb641be995937736201ebea11b0c77e6db0a84c36971508e3937320fc49a46b9bea5d3dff362a5f97b7073b0c17d2f5210edc6d329aa9ed18c3778e3ac60472f71dc1cff65e2070d155259703dda17af4752031c52418ac292269a94f38c1f2ba72aaf716f5867e0542df0ce3cfa4ea0d2a6a36bcd0d46cc83aaae93744166fb9c69a4728ff1bd4ebbee6aeef705f681b970ff7551f6760a1e581c51cee4d4ad0e3574bbc9209a705fa7fa715db00dbf75075237ec8f597a59809fff3ddc225757c5a10165a7b6025f909500e098be0d7fa6d0105b77beb1b22d5cc34cf60f46edaa99b54ab862570cdef2e182dfbe84f986dc61813472af2f59f5bce264b4ab8d4854bb2c40c58634b0a9c3352eea4c71139c25979bed064b545647383b35f2c7135f4449ac6eb52e948ceb73e171463bab84e2a63b310f3fe1c0e0c6199ccf0e083731f228b0f120d73db68d05ae1cbaf8144c1886c51510656f65c2d3d2cd84cf8e3ef465315b04a00fc9b0d0df9b7add065fc7dc337d82a67a5e6f15951ff15f8b1de5a183a8685484d193493c31dfc2a58d5eeb2a3b989aaa62a0375ddc1112dea717407f404114d078e2228a2602b6faa5215c9e85b4bd8b7a3b1ffbf69c10ed5fa09f1ab8c5b4ca2f37d34345788635334d8fe30022e9e922f047e9bc7dd55f595fc9be13ca6183224da0b7cde3b669de761f951a677eee84fc46ed84400f6649318d595ea2a6d240d502a0a9658ede022f64803ff352e5560b6a60b0b666cd34a0dd71dbba5e7537fcc9a137cfd5c12f4049d400385fc5a47c8e811f80963de878e93e88e050b03a5b9e2b2db10e4ada17731fec7eddcc9cefa399f50e95e9f1cf290bb4ad62477f0f5323ab797782a59b83fb661a2ebb553a2c2a3b42b3110af8fa1113af6e574695647cad921b5404efdadce1acfa0f08645e43e4f58a03926a2aaefe6d34bb7fc4d3b1570a925870a4c5ffcfb553f8ef848613c591e8edd303ea9058d20a8577a0741682b5d8217304b081d18078c6de9506a0ac7a72136ffe6f375c0d31c25116e0f32cff54ba38f6a6fbb72e2592297e0ecc785d15e3b914fedb8a28632a06b321f587cce481fd50727d4ff620f67f0625c7ca70b69a5024561088a306b93d408da6fe035a0bbf044b2546d19aac8ffed9eaf16bc44122f2d399526212e16e090811f060989ec71341fedb352542772c5fa1148f6fcdf21826cfe291da4f8eb2f6a4f4c6e18fbe173089c9a00cfd1bcfb6f138146e9aa506beb63ec967099d5ee8fc1af3ecd11ce9459716dfdecf5516e4aa26c1c3e470f38d1639d6dff24d082b9be79c76a54eb530a90f4d508d5f4cee87501ab0f6f1efeb7425bf4e035bdf4bec832f8649c4ec6d3c2024f455007a71a53ab916c6ffe99206fd9f4b0003175cad7468088c66b8049dc587fb7d4acaf093a977e89e4a788c97cbc192bf12484a9891f1dd0882163275ed473e2c482b84e244b1f6f9513416f5039afc7ed524105ba65ef4a5ee48ae5f28c0443ace57a6040ab0c65d9f3f0aea050da204f1c8b58da6f785350529f7fec6df442d379f1ebfc7308134aa597f22437ce803ca7e8acf4b18eeb232c7c5ec0a1b73abc77da71833095a2d8098837e3ba17e64f0ad02a991053b4243a5dbc51e85258eeba20bf46a204782666d1bcd01d615bb0d4b6574d3d55e16c71263bef87e96fbc4e351a5533458ca967b2053b2f505caba28fee81900ab241be360e39a65a88c0ab6f82d3ecd80587d07dc2716257c4de566d3d2038d867f04ee7f5df25b15cef5ac93d76e4230b66eaea2650b08a6e6fa034eb66ee8f90b8bd317b1c86eac1efcfb0a353e95b55c5c9574eca8c87c0fcf895b0af82ca4ca7fad7863fee200bce402c5ad31f4c7718740224189807e9e3600e565a8b1fd9134a9989edf5e0f2141059a27d7cce68b5b5f86efa7f6157865f0873b7008bb943dc84bcb8264400c30eea92ea3f09ff6322f960901d16e9eb1206cce10f4733e849f09eb53ddbcb5c45e851373d04a99484806f90aec3590dad2c53ce0b6f20f509c935641b93b3ac3e5a5ee05cfc47b267e640b26963699b43c7bbab5fd1dc91da1ec604ac2d2aadda0976a7458ba746b012b46b523d735138aa029c98cf1a95294ffa244e7ff54afa5898796f11242a3dcc8582750b2314d3fce1a4c798f21e3bbebf8b1caa03e0e5f6537310c6d879efaf3a068c18925588a554f8e8c61426f1f2ebe28a3e084763dba42d29fdb96141dcd3c10a37d30bf5009e4adb0a9e69cf89886dca28ab85c0deea40699998fd364347b664446a0df376ba92d42a24cd4fcf8f2838c1e2c40df364b952d1a5dcc33087b90b47a0bc6915b2ea4343bcb9241552e60eea92515b6d8aa22ef45894cf5463dfde1da83b1558a39c7afc3318e608a74511be36774a360fde98357c86b630408dc183ddb2d9585c55010e77d2f01566df35d523c4a717456649309ebb783fbe69d98aacca99a5dc2cefb597e6dd99ba1480a988ce08f5828d1270f127ed2d454feaebb9c44b26f2b50579f9d5cb3ef5aa7bcaed661d0ae91bc2743275e258db984d5ea707dcd8d89e1526a30bf4c40bd663fb34d00808b5875801bb062454b905fb7c6b917e5301f797312d020b5bb05754c5fbf148558f45f3e16c2c29a3498310031aa56d2afc8b717f4573349102b55fe12bee90e9899cdf6b23d2f9fe4c709cd879df3f3f4511a57057989cf6719d42fc3a6fb2d0e2924226b84c459153b45d29f5d7ea88d384c9aa396dfd6306694cd7759072ebd27b1fcca361b39c62d6479376888b2cc8c1b9ba8fa320d90f4d7f0bc2196a2dabbc54cb895c00651","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
