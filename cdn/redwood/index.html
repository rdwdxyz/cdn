<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"046a6e505885558520afe29726f404a8ac1e663c5dc0ca2c0e89bc9d96d4d41001eb04995420350169eb7b472c36af4a6f03f44883b35be8a51fb4d23a243af9657768be0a793e6ff05d3ee26fb98e346a4a09cc2f3e215f5eaae6f2c6626112489da8b98fd8413ec27b3213452f3e8a3b6f0e5b319118836e7e52a8bd272daa31f2f4412c3e7ae1e91455f1c1ccbf20eade22f54a9f81ceddb896b6b983f7457c25092631ced5d3ae0ba3da2b0629f2fb3943f04e0803b3fc6e15195eac50f93dbb630c8735c80baf0aa9bf520402a2622a1f61156cce6fdac8cffc936ce408b828d295152528f16372d84397b75fa4fad8dbf86982ec6ace8c16791f90b446f9ff49b6942d6f78d09f9597adb62936a673eec819982fb05538002ff64a3f7fae82763c9377a3a77b773f510a8180cfe309aee716dc66673b9bbbc523dbf6130d85c108f113f1c35450a899d72b424841d4b91df538fd196069a2b8d9e8eaccaf50c56582cabb203c55d42e74ff8c637433be49155719c9cbef6fe1d4158521ec7a532656751b4f55f5ab8d433ff8623b31f5263f16cd048654fc4eba1236d6307c86b7a0e54d8add8db7ab9fa96561cc33d437fbdb7d59b29ff164fbfae3b225e3357a092475f31b14299632ffabf31adeece1a2493517749363e20a5cd5d1346255a06eb202fa6a54016730c413d0d715d96d8478ec041c0084a9839afac71ba5c1efb467c69ba5cced74e24040d38547873a0ab449c916be76dc98c352be93f1682f609537474ac8f9459ad59422884992a9062317e7011909056b9640e0190c8490e7529959c7c24c557bbe1d41f9c48ae0af5846847b006f0fcdef839bd62699bc879d45b340336eaf5e72d55845b80a9a052b168b6a753f8a9918037ced4a97ecacb3600f68c0acda4d8d20c89238595cd50fe4039539589fb61decca380f6b0071b45aa35669a2aaa699d6fe71c339747079c60d5170265bdf61e1aa32aca6add98a9b00e2524fb64b6fb9076538425493918d4fef70ec7d346b5fed5107ba17c77b6249c53adcb9918a979fabb9d8fa7aa2dedeeb9c8ce15fe52ce513e4d409f8670a17320c3f62e3e41f225961984331deb51adf59c95b97d4795c2b3942aac75639aebbef3f172cd3e077c1c5619df351e17a19bfcc93151913df297910a949cc4ca40d28cbe9b0590ee7252963a065b4d030ad0caaec03d1edd973edadc6979b8f98f2583a89d0984232eb60e59167bcfcae5658efee94efa29fa6708dba92e65c17d6bd1a0d4074d963ce78f48780611ce717c1e1c17ba7fbc342710fe1ff2e0b1655e67dbb76fe5420e9518205494c17c137363937d14e8c5352f2207be1e07845332fc73b2dbd912dba991f62dcb129e8dd2bf8fd94c2dce0223a53b23fa6cf23cd9b527ab00348ac6e7d0c87d081a29b7418cfa19fd9d9802a3985912579323d75c86e27bc77f2c2c08f89d9050453a4916f69bd4bf8eb34d2b6bffb8509149f1a2b8929d6d5d7bb989faf8fe3c2b39201d6a3325a43d664a53db01c100faad834c221cdfa921088b772a3a212dca6afdde64aa5a49e29dc2906dad67c75c62de933dde7ed7f2f7c3af5967a70b86e3d3c5bfa969b53a38bc2c932ceca773b69b82af69afa0eba8dab024197c347a24556c13fd60aad36bc70132fcb0efbe9a02192f76b8dea8a7e1741190faf024aa35afcda355541059a854a12ee6e5e7abe863b43bd076e9c15460db7781e1cb37d11d39cae0b16545f332105c4dd442d648880d5d6cc5b8e67ec790b18d161c5957e10ff477238ebfe165c507dd6334e0273d46adc98b321e8bf846224969c85d24ff1b51ebddfc07f7a7b6d3ac225d8dd4a22c50246983764ae21a4b6f2982149c9a1c18c5495e2c8fa24d1a223c286252d5194a91ab3ee7083f80e81ff23af00fceb2a2d2f8e5becfeaef23da38d91388335f1f5592e479e59dabf9f18ee98dc4247dbba7d600fe3f227483896b17242c1b8e7ce75527bdd23b1c97c0c4475e6ae9aa3d53cf2c94d52108d90c5e18cbf0836333849b9bfee8f082dfbccd52e92e546a67fb2a60af79e60fd920bdb0884fd697c54f5dd61b8e3fd20697cba21ccbc23a5adfcb08ebb38caa1d9f0ed678124f64a446c87b2347fb14f9594eb0ca2f6781f82019df9a6086f2483f1f48535a80ad0bd8f7312ad372dc2f70b60effaa3b1b8f5cbb8941dcf11f1753ff1c6304d2bc52a33937ec4cd3198d45bf54fca5e09a2594c48f58a6f7d64706f9c2cd537786f983350f91b27b234b790756df0de23c2f0e3ae8b4b824060b53cb3d8d305ddfbb2232939be41b4f018b8d9b0781e1051da7d8320964a5c696b279ce2e39a3a45e685974eb3af47f2a78b03f41a1ccff1e023184c64053f1fc81ff173a0f08377dbdbf0a954cd6a9d3524653fdcfef5520da0adadb798e1914097683ae4e1d0eb68470728708057e74664c059b6ed4a4269ce980af08f23391ac1974f04afc774b17b8f065d67cc78d7e2f4cc1a2aa69fdbd08384185b40c7aaf0fa1c5aea3904562e785dd90a38ae14061bb7bb2cd3645f9f36ff1c91ea5106570869e3a6cd663125f37b870dfec623cddafdf81fcb14baa8983c23f3306d0ce2e91fbf1769b245f20151c26f5964c2f189e928f124b122073aeaac89694d591d7dd1f0f18d91e512bdfdb183e338aea8c02dbf494294a8cd7cc671437d91e4aa8bcbd9bdb0253341185e932f11152b8b21a96cc937364adb39b60da7f227d3c413d59e4d2da6831056dcc5060a3a2c869cc8cff7c5c87e27217f2d79f8f850f89724b80f97e9c206d1e2070814ea932186651e257d47fffb7cd1e5d81ee50c0c8ddd342c34a2105a7e6bd09801061ccd2b4d89c4e3ed5ca4ac17d8a9de908aed90f780e525402dc2c592ec018fede121e1180d088bb76836c8210c9f71db60aa6ec6eb90cc051447850675ee7a491b0adf8eddcc7ffb52a65ddf96d1c3f760b7fc91e4f7d6ee79d9896ef4a740f0542c14cf39939362b54fe22ca01a8930a6ffaf66c840827a2688c390bc104708370f414919cb81f82759c31dfeaeff4d09a34de6357d36134f4b99d12d1379d687d98f1706ed80cb6c148a9bf488f7e2fe2c61b8715227fd589428fc5a36f05ff0488978b155bb3250f84f57600e0c336994073e407e3026ed90cdbfd46580a09232fdeedad86f6c0257880be2ad185b956486a9b1f5534117f5d30b4820dc31a8e25d2de5c0322814248283faab4ae520215e38c242734259a93117892a8cd5054211e8cc2aa719d2cd61d49ef3e8b5927030f1248439eef5b9025030e9a376e732c8bf4c32ae123cb898ba03868c92106188296da17e2490c62f0a11a9e85989404fd01afdc32e2450ccc6630d80b5a60db4e5267ee3ad3fe39452b6f345189ecdc0ab439d64e56b81bdc88a6159a92dfc87beea7c1d10bf07b21aff5c57536e44c5f3911067b265eb38e9e3f4bc089d3cd0a78949b17fe2907e71754e1fb8f724878be4fff68bd151877121780096679f64f26f6f3453676cb2f8f710534e31707633f4f9d4a9fb37a0b962656382f5248c84ca4a1adb12a8a2dcbeea5e4f18c9ff42d523f5119447202ad69ea136b21e7768d47f5a7eb1f403c7125da008b3461fff893ac64536dd17a41b121b390493584855592aea3adad53215c268b6d150107f3fcb66393687a7a0659696293768ed339575a57ec5cdac17171b22e062f95dc7f26990832d1e5811ed444019b16e1d2f22e5456400ccc8054cb9724f53eeea7e812c739b10368c92fe364044afea5a05a02b879663d997d5d8b46e24aa75db3138132876a8406d3220a147a830fab0475ce869a796371c50493619e2d919eb9c51b86777526317d8a7398645c33f0b0896ce578a66d043c50e5e39980719a16b08d7f5c2ab65c45b4b559914fa002f052c6b667c377cc84a58d36d3d9f986056a0af929cce0fa98a2aae6762eae26902743a1bc4bbe5d93caedaa6c9eb5e1d4a0079ddd75194d62ba0f347dc04d144d2f4471343439821721f5234a3c35c0d602264115992b6f9617aa51dda256c1a8f08e596501750ece9983963edea23443da81f71eef9cef200aaa5de324bb41e8d3456e687ce85c56b31ee3b91b1a6959d92d92a7d66e7fa1d695baf3882b0e25d34cb3fd3409b6f08d3375ab1c66a78a94a2baf4a2e83871d6d603fcb83adb6ba9f64a5d4363d1fdd3e58d6dbe6fc8d529d01dd2b25bcdb40367c9b4321bb32415acc3efb10850a8f291baea880345ac476698714ca1cd4f26ee8af3182854a897d11d301ffe7197f90033296b4d24476abc6f377c626b209c65ffd4689a57b767b5a0359a844efca52acafa4758b2d8a7858a3890fc04be94e3935d7d48edfb1a4fb4c987429d9a70aa9712cd617f93ae47f6b98f13c0382c1323354f94a342279d2742d5f66b8f9db2f8568577f6d72635f2497fb6472277dbe9f17faeea717b9aaeef1a64a7629cfc58e81a9a7b2944b711ebf88e29f0a9fbb2722d8af11e7c2128845fa0c28a79ddbb896a1ff2cbbbe208853159808f09c237a1e9b64cfbbd1a30dbc692ac5b84d3cf0078d9a0a638097d87431794a6c7fd9a0d551d0b9f09317c4011967d47c9fdb68c4c7a4447a9ff960d725d58a64a0a31601918c72f0982669470a3fcc3035779472980eb2b748e210d32acacf2c2060ad37cd315b4ccb48a27edcd60ab3937f9f6e6a2d2474450d54baf70978bd709fe32a2da444f0fd58841959008051126849026db7f120edac7d80344159e1b996112689db2f748933880e410674e70d53b761918d13a1193fa887447bb83cf87221f6b1ad06480166bd96cd63b92854f1e463833c9382dcac9328981abaeff1a3264c05e2034e853e331cd10b95dd14d4dfa212d49c6b0da7015eed3d0bdbbe499dd54f749a0397ef6ef02f532fa250572af0168ec3f2e4dd9f6d1f5be3aa538b22c6c9bdd613abc684efc976876cdb41f2ca6131aa276056ee1bfb398f56830e77b6c3488a6d8496b4f9b23b515564ffde9f96da1dc564f09281f17036352677c625ff6dab0840a0da5b445a12bea808766643a30dafc44fa79fa97a6fbc3241e5b1fa80522e9efbdcadcc1e5e8ee245aa7f61c2b15f3f8282d2f5e574a1cd38639cbdae3a21b21861ba86936c0de78efd79461f793967d7d9190a9bb80f1399b1638a71c84368a584803f58010fc2521156b1fcb93352c8de4de7c76f6877075976461388ccdc1e1e4421d748de366924267acd4b910be114e8068dc9fb50da4ba71b26f30a27fb762ca02b8fb18bc08cee10b47ccbb1d83fcb2952e0f37991e01b70c5213e78949c0f6e6f53e27ecd130bde85d88834b5159ff9e4b84bdd7ab2b721f86771a41059f2d73e5377fe915fb8602e5027dfd63956fb903acb7ce4de95d4fa3e60f2fc2446d59a1cc84c0d7d8e478455aa0dfaec6fa2b2c7b4eb03a48a51d957633c02c0eb019e455a424c4c44b23166a23607d2cbcc020f2f198fba2d37e86220c55f89d352b3b7503cec42cffc7c598d0699b15a0f89f339a7460ecd1d4066dbacb632c31eb39968fc502c4630614219a622b26240253e115046034404241a95ca3e50a9b3e183ea14034aa6c1a88699dc153e9c969e99703ebacfb7a6c2f0ffc8a2bb04f28cc72366cec69de12b5276ad9d70111da37e716bfe64338a0f165cd680fcc50a9deaa08720fce8c10d185b4cfab003353edf7fcea307e2622f487162865c196a5dc53715dff86d4681bd5bc82a784002d34987b18288bb749e3f8154f069338cd7607e7ef06ae759c17a67315ed0473dc7d58003e6b3ae2e40863dcbb3c9e5dfc74625a6dfc158806b9a75383c73cfe0a76e991f9c684aa28ed5965e125db6fca398daeacd639158c5d9c0d61c95356ae8c5d4fb94e6c7567ee1c80987a346ac5c40f51e828bbec3977a45798bb6b33f4187fd7e590fb5d42f61237796a47344ff56747a6e1ce3e33668078c640cdd3bf237eecae119099672ad10b842c07e7104aca861a2ffd686c0e9e6020dd931ca30e8bf71f4f9ca484c292943d02a248cad03a79a56f27b5052f18a3c7b484d1537bdcc27160c50f1cb265297b9d7b5f361e66cb8e07221b48037365e38bd9af5fe2a5eec5ba08ecb40d69b5a1d23789fdec108765655ccb5e9c4eda5e752e9cc348d6322413e640b0199cfa3031f7d0426015270b4b4ae235bbe8a038580ea38ea8e109f56ed389ee3d5eaa5d8d0cc620140470627d50ccbc4688b9a93443993b71394bfd00fd4079f493377f07ab9f79104a0bd33bced159301ad09dba3262866e9e8701200f4dd869c4619122c4359cf491cb90c6bb6b7ced2fcb918084ddf5a0e463938524db9b90543d8128ba3cd7b21415be16e12abcc361da1dd6b3423ec9bba610a6e87ca8d324d82730a87c1ff9bf5756e22fc184fc117ee776f190636c7434be84cb89ee5ff16de05bab8ee2e4d68f00675e0edb8ee61f1c4f45250955d4dfc2acec94bb2a42765630bcf4804c6f074649e74d318e374a05704a71319506ba1d2204ee11e24276d924baae4c9003f9910d66960b0977d319b6e0dc062643b887c8120be134819a2b1b14d7d51526d5ecc7448dfbca3e86562897c414c61a729b85ac1395f1d7e7881d3c1c9fcbea6fe838640d597e2ea93fda46082b2fd3b7775ad2f7d5579bbc2b52ed6056d83610e584456c58dd6699684f65ee29607c2fd12f9f7629ad38386da3eeb306dba8152d131ac9c3a56d53bd0bc8b63f7360a4582156dd1ac22c11bb7d37673f846bc75f59e3c88fd329ac1fac39c179e324e55e3e45647e11b9bb6b68bf086a854c55d46c776753b213db1bad6c8fbd78a990edd0712461f052ffb0e5edc2249eb39203b8c6865cd0f5abace3f25655f5143062f65eedb4d38cd92a4e8cb0400e768d1112f11585f867b444fc7b0a90168a1e727c4f5cbda7db1414d55230a2c243ad5e95aa48ab6fa2746eeb4d331e4c0a01611081df472b42303f78cb42102ee918b9c0901187dd76dc5e6f1895965c89646f1045c0bf7641494c5098e9d9af8c5609b56fa2188befb820c722a0bd1bc3d37fd2d63c2b7a93f75650e8568e6ce733c9ea789ea440ee6f424b9ab8dc9e0f4b81f91607851159fe46e4bb8694ded2966c167e121a4935f85cbe18d84a832fed5ecd992ff37dfc71bc5fbc490cdd9794d4ff2a1e401e00f32523a1f8cd99e586a2a83ad2f595020ddfe29267198f43ec9db9d6b7777faf21870887511aecc1c8a4a77079254e344be619e5977b7c33942386359d6bbb1ca5cfe6bd518a457fd4db589040d7ff06b8155cf7dbfde0edc627c25afb22e16ecbc1c421db2c5bd3fe1e6544e93dc8747c131812d83deed50103cc1dd4f68626cd68d764729d21ed1627203535d094372c22b370c85e78c31657a68b559b4a62da097b9b098a7ce689ae6dea6c413e016df6da7f3ee864856a15a2fcb5c231212fa5b9eef7a9f7d2c9398bdb2201f3b9d6417bfec196c8c9218ddee9c773b29582daeab34f25b9bf54093d93861ef142bf01008e0449928898af09c54c4b447184caab30226ea8f861e170915ebf489d6929cc3a9ce4c9dc6d7a2bdd4609c51f7397024303d27459a593d6c62b8b667b9927ebb788c2bc7042d26c739ccae80d0ebf4505de7f383c675f3726c2de04e6c036ee788fc8ac5689c0c4717738324b9dd8441b3c3446c2bfa566062e021f39e4479efa47eb35b679775f917469c955a8254135a2d10410882034117b4c18f7acb610db5bc07f4d394cdcca6fe586621e920bc90648a61937d2d651ee7233e501facd83782b652222b34ab60952dcdc71142357ac6ee8d6e9b9f3471ef329130875c9b00f551feb6f5ab7609c82a6b6f595d3811afe05bbb4fb15b7877406dc832e83228ec9325246bbd76f6cacad70d928057c60c159650856d5b542d235fe96885d8b0bf7cbf59675ff0f20187ebbf960f3f5a645a261ee33f9b655d99d9e396f01ce551966f9fef07cdcd5e6ac66b899bee73c00fa79619c096aadf3379b4d760b5aca0cd88cff857da73b1761e0ab9c54e00e327f46ba8dabc366e31e53bfadd7ad16e21f54d02966a3f447ddf176404eed919e9e0f3827196325ada9f768da57578cf893e58228b811f61bb84bd826ebeaabc93f2424a9e18ad0927dec0b86b599238b371edd700357b1f899d729998602691054d5a593d5d30a263a4fc53484b231ca8ac1bbe8c79d3fe55466dff8496643502f9b03d6b4fca0937f2474482390c7310c811076d80734ea0b6d63443542903372cffd5fd39bb3df83a62d488390b6bf57ba3875627c18d711c6a67750d900b2c72bfe836dde8a4485d3ca8ccac0d4083748dcd99ee87441a25769a8564c088b1ac3e184a3cc59b9125dcb6cacd5b438fd329a1377d0afb40ccd618f8808dd3782400eb12651bea31390d58ba4813c3c97b3bfaa55a3a0575d8cdb23864c825b6abe56af5cb6a2bc1b41f55b1439f7e41f28c1e04f77cb6cb3776af093a4c424610fb1ee61ab3457cafec27ebbb67fbc7eba10d83f0cf275ec8b221c652c17a7167db1d553df9923ef5f4b5baa762ef2a01991b380621f0d7226896730600e2bb94627a41b50a747d2500f6ff77e95471fd280151f5cb6f0ce47daf67756bb7bfdb3f2236b909c187fdad381ce823483366232c7d12462f5d6ae724299e7c35d3b0d4b4692064e3b185137cf078943ca29d5f85768d455e16417b567076692491972aa51593ad2bcf3357bd52502bf671100e32c608f794cde0ec99d850bac9098ddb5e0606a0fcaf102ba28bf402a18d8f2aceec28fa8092ffabc52c9407d8c801e6b23135fcdf59d9cbbb6c688bb07acd34931d28618eb725c2712bbfc573b350d867e660ccb15fbbdeb284ba0f8615b95aea66467c4e09274a3cbb24eb99a8c44521e8e92fb37013f2e80aeddb9bed7ec958b0615e490519421442193c775eb53f7e98f64c9c7d50c2fa7a8f74ea96850e14eef65aada31569066f5cbf315d5ca2897cc6d0d0eb8d734182e20d31763a94ca7ff00e489ff68cfec8ccdc3a12f2b92a73f893606b868dc4690a804eb3d6496e6332578709b3f38086dd463f31b7493d719117f172adedb705fcf563e5701dd18b9b25e31a53f17aea3f6702929cdaa068d82c6651e1e950a3ca757047daa90388347bd1b84178ecd444f0c03ca669ea99ce68213b7589126fbb96e97b79d51d26a657dedacb58908e7750c6fe572102ec609cf29394387802906b549837dc84bd935918b410669ee5e329c06009c2506fd0248843e46d64e08fad7e2c3af2c1e58f1e8930c7261808ab3c2d109244a7cde00c0e3fcacb70df9b0988a3c3ff4e8d7f37e044ecc45394a0f6f1074c8c1f8ebb48739103c1af2b00945518c9a8616a60113cfbafadff103f0fe0917dd6591a2dcea63c03816cff3fb452280e7480145b8d3813cfdd263882cb949e53ec290aa3f3a534bcbeed65ee320b51c90443192b3fb6c3abb7193d0b29035bd96f366f0912ff591ea18acce5d84fb1589b03f924bbf7a42a27e288a878229a3ccb7b0b67f4850f09e267fa0ad5997c104b192b72f423543ef512912ec9a66ae1c6d8a8b8adaf8920f1e1eae309e6abdaed731ad0a6abe9d189d717c7a713da2acdf7e9a6cf3e367674df3614cf8e522688289cea35116dd71689bea61fb87845152e6fea3d5375e03cdfb5d9d519b9046ce5d00586f82769362b3f71f9aa50cbe29f81b90958a989fbde109c4972708513c55f1f44be426def477a9ed8694de2f07dbae32a076cdccd4365f286db8a00b465f5915e70113a2d171f578688dd7e0368127856e0d85402b44ec52bf480386c80c61baa56645ac56870315db4b4f2c9e425c2e71befe3e327284ea5af5d9f66344f83a382bac589ddd9d9f3c0154bab39108b922f8603ef8075c65a35f9559b043b47e8933cd9b4b9cd8327ee708912426074f3738d9c72eb8af7c9f6c88e758ebdaa4d09d0994c0216746904ebb6176eb335b2888df10e7c0664fac780dece2baf2c322e2ce1beff76f64070372f6310704b3d3ead4231f6061515ac26e406522ca597efdbab16baf33171df0706c08ec22d6baa2107c2532e7a4b7d61782d9cb15b2efd2cb0c257d4ede18b7cc5dbc73a6d193ff8899abd4feb29d2f5d48a6873a7251ba72ff23d84b30b7b8928db9e9b820c2aab72fb4b55125297e90ec03a4a4fb0a3a121a390123df06df1f59cd570b66d5491ae09273e2484f7c39cadc408ba69319b0d4b4d307291a5d4b6edca282b2e32e11275c334bb4c09696e00fae73df54b4b25a1283998fed178eae226d9cbce6e16307c9d9bc3af1eae731b23d3b0135bba5a1f23ab81499a9401db41085f8251e97297a4c9651195a35779e618ceac708d2b8f89696a83e87681378f33e385b01d3e917a8630e9485b65ec9696c940ec42dde0b563b8e6b830381b00fb3166ac35aa19b67c13429b0bdaded6ccebff4a51b640bbd24ca462c07d4afe1d9687fcea068aa86536a564c94cf55ae7a0b34edf06441c9a439fc6297d6ce9e8f59fdd75f49411433ace96ca0a884e0790d069adce3b574e7913c8635817dc664c21aba697b438d99b780e43ca51bf3a7c0ce6be240c07c4701e6d079e5cb99c8c05a6df3b5f2532a74824cbd9f2f6ef91148ce7eae57b865a7e68fbc05ba42e27f2d6cd198e212d37259e9b52b14ad2b7219f91c9373ab103de127f80c1d5034a1a7a73e1c75fc20b9a514dc3bbaa13815fe693f9b2a8e9f99b11b9d9ea64f401673e35eb0ee6916d76ebf274cad749a71e4cf7532ba835fc048a8084ef0cb7b6de27c1b2c317559aeffeaab2bf7c8ee8f1225019acf63001fab3b9d1ec3f608bfa4c2a521713450ee755f6e3221e454c12e43c2d70509ceb9fc7c01dc865859824d30c4e665cdfa73b5dde00f2bce394d69a233cfe681cb0d6258741fb20975add33a298ec86280f6e17dcc6127c0e6e4ef7ee8f797a26c14e4f20477be76603ca867381a02302d9b85436e1ce185f7da025d6309d11eaf7fa7e46ce1a973dfdb3053f5041ff23d26619d9b9fa6530c30f9dcdbf5a1fbfcbc7bb44897df53be5f0a931bf874f79ca687c844cb8f71c39f140a57a9d07f3a130a47f069eca9adbdea359401d83ce3eb8f4491013144a15bd2fcec4894a34d907c264d35a972fd364ea46eaf5ebe4bd7967b524a3c4d3ae545709296d86ee4484e6742b8d7f10da7145bd70e86a1706340366b34409e25df11d68ec3e1e232729e8ee797656e094d17717f62b92fcb64ad00038b5fced35ac22ad3ff54ab79a542b7e20b42c56894d3289896aa7c6ca87d35fbad49bc21f41be868049ff120992e7b6af0db079d842f8063ed3687096995da4a2ae90741d0ed03d59f0bc73001788f51e328ade40b919a2198751b8c83ddf4ab1d0aa62ef53e6210b8f02ccb02ba2d9ff385beff2034d727c934b118cfc7086ae6677ecf529b382a919e61b24914263fc734d26a54686a2141b12bc5c79d38b56844b0080300551e2afb135bace42b0ec2209e0919d35a551f8ba32344e1c7e9d04fd57ec2c970d22cc9c071a5360400b0c8203405634df6fba7f4c599a0f63103422fdd63bbecc1c47f1b22479573050ed20945d15d14a6e3fdac89aed0239724f4021df720a59d0359960703dd6d1faff373235e1fd7d2bf65f2835b6fc83472c161c78d260bdfc46dff9d58807749827e1b49fc13161012552acb633c0a0b6b12b001b66965b07b8acce5fbdd2402f051ff73b525c487fbd3a90d943618fa6ce4717fe5bbd3b9ce4f9d1a7dc2b1c9bbbd94b65c8f2fe31720f742a4b8e7c9f95f0a2461c2258e37cfb57beaf5612564b288f1ad2e04586ad526fdd0c787c25444a154b6aef9bfef0cd6bc7645b4b5bfa306387398202540288d86ea4ff8c9b0f1278f95d2524f7c11241800ab2bb77ef7919bf165e2b7a136329ed2369fcc22d7319c0495bede3981b218816d027301e3a986122082e5b4a76d05d29f76fc599f171e8aebca0d44ebce82cd3c2b70e8eef8b5de99635dac26489c5a5d15caf64818e68bdf6e8a92a6e3eb0c6710f5c953641223e7e16382132922be74b78b3b0615713a0a0b997f8bafea2e50a639fb6b07839718c260b26309d9ac358cf6fa9a3a90055846f20e152d4565fc4f93a06332cdb4dfc29ea8c191f2ca032bfc1154d9875234cddf8a9b1c9e6916a819681c655d1207dfda39c38db131930dc6d787f8bcf02d3a3217bc67f833a38a0cc5b0592ab9558d510f04a19951e820de7841b445c34ddd3e375498591969deb108e52f0a0e7ea86711cdc42824605c864cb2713af1f84a3f920a9bea0691f0cdfb3ed10b5c3e4f1e0ddc695249609b2124bbae38692ecf21da2992c57a102cc8964736a0d2ef3917d740b04aeccf2a2606abc03f665afe8f2619087ccf8564990a5b8eb88f139a14609eb176c043fdf5577f93f2a30995cc51eb67dba36a4f0b7b5995f3a9abadf0dc831532e8b50cec3b9fbe94e34ef061402f232ba621a7083b7a1d8fcdf353652a959487174fa482099f2fd024b09700ebc28eb07e97c33576d327216ffa29fa1e3d426e873b50e4912b784a7475efeaee99a41f5a887951680a1e0865b13d1af271ed258122d505539fce6a6deadb48fc52ddf5e269c16eee6a6f90bd96865141c50bd3e720eea4f6ed3fa48b0d0ce79ffdb4f964f55c3e867163e325bfd38f8178ee7221170ecc884b67b370be08682246cddfd24e168d5c8a903ae25937a29319cef92d790181e4d35431ab0ffd9e39ea41ec603fa433eee2a6e2af2c1bc25d9e7169083c1386635b330db20b08c4d8dab5d6de1bc42725dce50ad6a59c0ce8796a049bfbb87b8a47fee300cd82d6ac51f2f227b22ef93dced6dde0262148c516745d2e9a003b2d2a420d0fbc8868dac53d71b526d61139b975978d3c66f5998f0aab64e50c14f4571dde7933486a531853ccf9b207ac7e68ef23a0c7a61380c66dc968a79e764ff0801cb9b2576ef613161378d97a6955a927193ed85a222523616e169014bee0d2797641e59db01ca31108ce9dddff609810f0894d52f9f463287781f6ffed464eecc5c1d2c54fee16064301d4308da4d238b13d5a14e438bbe76f9805ac1d3196f4652fa3e9a7d083c532e8673d5d0e5d152bfa0191104c936ff195fdafcda394ad04027b1aa09fd30d2a318a4a2dec0f038d4f8c442b0bee94196577c49442b3ac0fa914be7580639bb37ce6ecef52f115e6dae0fd0754a71235cfb0064ebc177ea16ad205f314c8665ae7753970954eb14d196ba6a0c71bf38c4b13ef5dd74f00de86e80cadd37028f5ea72fb20c26c7ba547b6dd4ef7bcfffef231ec0b774238ccffc33665024322a1aab0235c2a38e80a784ec555066faaa6722a5fd87ab142c6db1e191c8524d669c21cecd5ff4422a488fddd95f9f02ae0e098ca49ad043153adc1110efd2adfae3dbcb6bf2ce1a4c3bed7e7349609e1aaef122b0706873046181331aadf58b079af683796a7ca0af590c914ec750d121f21059a7b7066b5b9663d2ea90fc16c341e98404aa0e64e6f46388c3aa0eac7bf5494a81539081584a9dd7576102a4cd2dc4b5befd1bfdc0cf9e2aac841e47afb5af91848150020fd35f8b9ce239c15335ae78be0adf88e96b9a426b934a55148f050932957d7d4b452d793bdd5aea132482e7ef1aebac7b4a6c4ca8a96014a5279dfb85ec18b103b1d65e86fb135d17a10550ff44842ed72bd9f1608596d8132f814dd309255c008497bcda52897f5616d156ec3d80f99ceb8a1e41ae27a829a5da965af7860deab6bb267eeb16048bda9711e2ea3f190b8476c1babc3e75dbb40e6f9621c56c65db354d0a2a36bd07acb0122ee433b87f52fe6c059309e8faa1204266bf136d1d38f898375ad788777904a163fc9c01b332423b06096ac18d1232d3d1bb8f2f392b92ddcb6f59bb6d14ddc47a7a8493fc4a22ebd87ac08b84cd7a76903b75024b7e3b9bb5a5cfd964cad3afbc5a2b3aed56f231ac4df3cf95d5c5254f55bbe78a58755f10b8879d8ab67b2d3751e642435c306d6d7fa58d2ab6e4e3c42f83bc1bf1744320da6ce8914f9eb54562040813badd38ee0100f2f365e1a9ff4afa141c770fc11929f7deaa2133268437d874c8ec8cc1a2fb8536bc26338f88526da8522fb7424d2829ffc458d6b1511beb905d6d9891632e2fd6863372dc26543b314295141352dae040813b823c3b7667fbf690e8f5933e95278833f66ce97d9d48e0d254094bf2634e1a5b48435726d9e8ff448083ad50b99caf3dcf931b54330012bbfc9a4875d7fc74d42f5e4c6b9de39b980ae2d021c295d36df8bc44a90144e867dfcaa2a9d147001b01f4a09af6ea2c144aa5923b1568ee33d974a480a6c369fe5032528bcb1100f14be8f05c34f2d68e705d5f9174719c0d88320598c9487c63101a77ecb4359909e9473bc99a7183da26723399afb3d8cad8aeb8db3f8a0414077cc29921d1f1f2e93d74a99896327ca4e0b7edf7fc6afa5235155c7dfb742f1439e22982cc8f3602446c52ed8b493429557dcd09e5b0bf91cece3c71193242a52a476f7d03a59788bf3de22a9790e77e3651977dbf19254093117ea187bfd9c9b9b498b13c794ad2a748daa4e29b4d6095e1c486fd874dabf0c9f67ec1863b455e3b17973acb3a9440e890c26e515c4734db062c61553ea868dfb376e46f56313108124c7b4137da32aa59f8a7530c836e80d39f13a28421d47d9e96eac810bf83d5bee72396dc96673475654d5ca71f2dfb3183ffb90d41aa1c462b8514b1e030f094cf16b018238e056ebb6dd472f74c916fa54dcfe1a9ec471e7969eb8a9303ee71a5d39ba8db0fced1252779883bc79f6d3ef04c07d51a9001582f99c37f29642df6380e7b290a9e00356e5f33d899cbde0fce59bf95cdc43fe46fd01c991d811ca53e8a4582c4e62b8265a685eebce50d96ffc6c97958f01e5ff736ca994cb60d2a58e9586bd4e65ef85675e61f99dada90ee8c58be522b07bc2e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
