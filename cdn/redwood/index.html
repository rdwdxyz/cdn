<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5af3548a37925ad9220ee29327a8cf959b2aec5a2ec65a13019709281e884503c285cc6cb289522b08e03642d6706d0ce8453ffba5d5a58907788653b6bf2d13731ed2655fc1fa36060c56144302805122df96f8689c7d9fd1f9f786a75bb038bb7476ed99821fac339858349cc123fbf7b457647f8dab912b081b5a55d30f43a1a8baf82a1819585be7ea463799c69936888188a381c983a2446d7863fd2a4e0aa372679880a64f0cf7df6020b12ca047eefd19ea9f0a349064e41d46888b5d364b4122b0d0fceb719c3a5879b59aea8972ffc4abc913dec2bd7f308c31caa559ae65e82c16246388561671ae33643dcb967fd8a7f90f86ed5dfa9753d6f2b3e9f078a6df8c5e95efbbbd2237c05099b774b3d6a038a41018ae58226f8c4124fedeacfc5a70f42b7b47f9a031be0d09c8a58f352e85c3a4f23b9bd31e4d33763c9f3d0c7fd7073d4f26bf616ad1a48e38ad49bd6162486f828ac27be528ffc9128f5987808d584e5e1144f89c6b891814c2a15f0c1ca38fc365fb484b82d9d3ed86782e51abc8b24df37d023feeb8fd819375f4be776df7ff0abdafe0c327f6f312241a13c6795c1d556bbaca177089eec7c5b03aee54465312a48781a96b2a920aa9f4f27f41b283cfdd0d9041803e40fe32e817ecf3c4a9350da257e90bb40cea9c0d015ac189c3abf3c1f5c68884bb37a7db83e64793d4dd3d155a911b0ecfe139b3c034eeddc271eef32fa55c5db379c2971db36bcf99b19198a5ae8766fe59df52dc27ea0a714517fb2318718088821510d4b6e1cc5136a71a1dd0338c3b1a658adb63e027e61b5c99c4a61863b2d07e234462c7f1f009932cf3e9c621e06c65337850008b81567f42cb45d8391cbab68b11dbc167164bdc28d262c1be256ee77c7c0c759caba4e7f95bb9db09541606f0b7897e2c0f3f866cd7220f124b166319fd691250daa7b6cdfca97b214d4f3974991866ed7aa8a4bb15fe3ddebe139ef0233e0d9203cf901f0fdb30aa0a79e98322d394eaf693d77cbfe3abe0bc45b483bf35ce70e376d95b182e1195bb7884b0aed62cf7190222e3e8feae6b1e05f6841afc2382baf59f7b10cffd5eb0f0d9e3ab48baacea5b7032b5fb019f7c92d0dd5488bfa888f4c121c0b180180a0c279d8b94a1a27b96fda1aa7ae732a5cab337b23047a86d68843c3ac79a2d8fca899a60b7c12ce4c0c9e141bd839ce51eab018d37217dbbc7111772c055115a0a3e1481e9aeff7058eab92c724c04dd421fbc080362fbba7078b457c53ffffee6ce5aa4929e2f99ba8a37a9b2bf158c81967c61b7dd4e75a73a7a7822fc1c143eccb5386e453bfd105646edf74c464eefa3233667aafab4453d46171372b80b9a4bf08e013ee41ddb8466448a114fd81ffaff3ae384040844fec8589e597de8e041f798ee61fe1e3c45c10d583167ecd98034748582372d173217465ab820ff9b9bb57ae60c671e20826914f937e7ad22dccd0faf07aac67a7f9de4114c7e708b504ebe600cd5da2282148fcb051cc5eb1227ff3da4df8ffe6ee6117a7a245ce20bca57c6aec9f224805da422e5c2ab94008bfc899f1411684585ee2c260657bec6f42557c6108d7747b4d979659b63138965863a4490a6303fe4d81aa08680221666e16329ff8a478f1716acc49c4e902f39d9be8f3ca54835e67a2f2272da84e0b27bb581671fd9ff2f66ede23e118393de3967155c6b1c08ca7191d7de203239c243ce497017ae6b6caa544ad9136e363e62192de8bddac465798c8ee10b7fc8ce681230a5b0bd7c2368ef5152bf94084db700ddeb7be0ed0387c8d71b1266313477280366fd752d00e7362ae76485feba5603b9abd5ca6663f07214eb88cdfd36f98c1e8482f7fa70c4d9771ced799ab469e5e3538c7b8f0505ad51a77ebb1d170577a29eb9cfd5bab9b8cc6c24bcc675e1f0d527bc74e3785f6fc0c4992596b9a6692e3d6fd8cbd6eb7835d763fa958123f38458b14427bb65fbb8a41bf98ddb48089020e46ff1c98c3bd4f9f142bceaf5c14deec4eb62303353bf273ff555e353247301b9aa60bb44325e79b352e559c5904ea4143b26924313629c0b81ef21db92546e19d65de2f1af9ee94159d622b0392a09dee5eec450e49c6620870f052d2dfe9b7ab9b1d93ebdc27070e6ac5711996c63e4d0125fa61bc40d581640181ce735561669d25c7e2576e9c16957975c2ada891cea8d9aa63d8af6464fabd0bffa756a9d9c7ccc69c806465340d42018ec6df99161da688a5a4deedac27214eeb43966f978a5fcab8ab760fdcee0e4ce558ea2abdd521c85274d7c42dd181a66fc2e047577b65899db7b295787bfbd37ff91d97134422dee02cd6743a963330eb39d04e859b58b406541ef662f433dadbf0512468d21f214690bf6eafccb2d1b0201266d758241b3ef0d702fcc5851b1093498eaf6c9db32a22249aa477df1b2edcb830628e12116b376d005aa9699b7737fc85712d6f677ff18450885e6789974d09a3bc072d22a71bd4b4cb18d1bb189f470c0e888d402922a54f98dc607555c1a6737f5cb44b6f19644b2628bacca14347eee55d30a8f5db9b405259c88fc4589a588482e7ceab6153d6f8dfd3d164e707d95348ff2d81dd4bed3d3e3f2ebac5cb3319f9b318a4bc4c509d1815521e636908b32121fa433466cc3142a98b73d5432bb4005ccb25b4d332aa19a8d6bb136bb424b2b95d5e592af057b64aac3da1d2d592b094ee22ee16659fb0294652267013eec4728b30d3fdf08c2a7790f71a5880a76f69d5d09bcde5685239172f51cfb570d14fdf600b50a5fec585d6229b966d6843a425b065c4ed0100b4ee29e4e473843ccff8cc0acec4e1f3c9998eae4d7f0f5abd62c44773dc315b3fb36fc8270dbd652f30a5d2fa7e8b10890890389fa336cb0a18fc1f1cb5794ed306e7ec772a8c39d8fafc95c950507626bf5442f3621186d12762891d7b6d94dff4c1b9d54a7a022fd67552ff625081e5c980e455cca04fd17b536d0e84c5e2663f9a2dc0ef5f2794d8024ef40e0a19ea7370ef0fa7486ba07e1c42f59febd63601cfb2ab15b626acb2c6a93b374086b3a03720d9da9594d6b16c5e876abcfbb200570041e43ce96b61e82b29f22ccfa16430ec759d062d8e41e0dd0aa3fbdf8dcc441e8204e0735209faaafebc6c9b6afdc87d18097ff8e14b86f047e747a43765682ab091e926c48022e2ebe24c0cad812991f5acc92902abe609fc760c58a699ef6543aac7bb4e7ebdefa813a5b6b17a55ee459b825d540a1674a9b9aa75426c33f0961dc626cfd151195ba85360ff4e1375fe432a55e7b3bf78268f1d0c471fa604c51072399de4ed1421cd370218f5fdb44be8e93cd5c482eec0e58064e68d840b848e9358cc0db542606ff7c27b1a00eee9eeffb92dbbe1f3159dbbe621a9fd186826dfd158ba09062959f2721289c1afc70c9dbbfd0a110984a3d634ecbec34587fa458982bccc0e74bff7b95667b8df0c2090dc3001a72d8dd9f72ea11f63ed1d8776990a3b2b51c12c335753da1f88cad4c34fb547e0ce5d9281b94a965eb8f13667e38ed381e703ca1cb4bb726adce70d94a16a7205eb1921c0839208d0058fa6743b99528bac76a61fdf3bd7144c2afc19b1e79540af320c5448acd0904e18cc1e43fc00403f6a68344c28d9d8de293d2d7267de53a196ede7ecad7ff68a6574cf12236ccdb98adfa2a01c667b4f908272ff56319d04479431ae275d3d422087dcebcac524775ff610e73ed9b6ee6cf76075bfc540a07316333d760bbc81dbbca66b6714691f6b19df84526f7d9715df6d904c60dbce1e79f7abf64e3afa46ba4b51ee4d95468ce021cf8c301cbf7c3486f882e25478e5afd55763eebe7cafdcbd3bffdd06a22a51e91b21c4b4f299d05fb64d89d7c65d55d9596ae093376bc00c3aedcdb430e0f37fa01719833d47e2d8ca0a71da60620109954a0e5e20ca0e1cbd77722ead02693f7d408bdf9c704eb894bd4cdd97f43b6ffda68a235b9e8a493995c8bf638aa65061d05540bdaae12a50f118efd67b0299743c84f63dd9e50da3841cdf66dd4abedab153a2ec35fa2069461541bf3d8a893fd5e76523296df02bb41667fcdb1acdea82cd15c51dc6cbbea6207eaf6697f80b48cb4e87558a8c897794b6df5345364a641b15e6ff522fcfe8080a7c77a8ae4abc77bed48f65e61f4cf56b745fa5c572cbad1bfcff21bef64429c63d3767c51db3dbcc23d2872c1ce3e27f00e103860ae68bad57a0ff37fb5454196ecdd349e04ed424f527ccf842abb24b8fc6ba3a7c75a0947909e72c6044d0a75afee83a5b5f6f244234bfb8dd0ca23ed50d0909d003e64245123e327f422e8b06ea565b22e483edf14bc68f57d7097616eeff62387bf280ffad4a12a6b6e5072f76b0561818c8481368ef0a449f69e90484de2c65171bf1e81da53fd8768a2358822c61cc7eee1536b337ecda621f6c80ff96e16cadfc66af1476a250e1879cedcdbc7dc3d52d10e12586859705208d7d2bf3daef8e63634c8c11f0f4740603baa2c5b4c76347783b3cfcbf38323baadee41153ac077ca0c09e2b6174712a584f916da1440b26b459d7cfa00219e5de715193bad13e206511904282ec208886a76d0ba0f33988d4fa0815fd9cb7a1521ac4daf9e542a8811bf35fab36b87584f847ad02e0b229cfdb9c5b87c85cf9fe48c7a1b2ad0ef1fd31e6c98101f5406cb22dd0831aafee34b94660881c5a54d8f2ef719eccf31d1ccd20b69f821ff8f583f043543ac6b44e2fb687114304f0a4c9e8961be85e04904cc738af53046c00bb1bf5b75313794dcc0c88d70a714cf396453b4b455b53cb2ecccfb65d26fd5b3523d94decdf6957c51cc0cc14c1f75cee3cb506bdfab89b950964dbeaee9a402af5e3474c5005eabb0e9de535e401b5e2bb0f322febfdd9a764fa698d0c4529857f72292681af50df02c1a3a47ed21335633bbed279b5f0bc45b82f32565640069a420d95b40be878ffd70b2203162d543502d20f57d26d96497154f3f3f0bdf07506e31e7f444eea185ce2620364e70eec76c1ef0c0ab8d8b76545832baed7732807a11f0e0da5502f9e92423f1e07d17d5d90bb76453ea375921c5fe0f5d9afcd7da006540e6e8b0e29b7c196c5bb9d8eb46a381187b12f497faf78be740e68e69411d54a1613a5c41e1b8097fce157d51d82c3c9b65bbf40d55bbe9c2a9648ef559fb7933138edb27a07803efedc121048e98fdc40ccc8ed4dfe8255d1168289fc7f675b221d3f6c757da835ad106636bc95a152dc2628ccee3aa1a43189bc08bef7705f0c8fb60b901e37c65ceb32986de3dd1499f3ab38f6411f3aa7f8690919a57c34c0aed483f2139d8ad63c61164bcb003ea3a6b01c5f44f43fdbde447687961c83383cab284c366b0dc591599f55998f945a3eed861917c5c644cb113a0ad5ee32809e0a9a2d18534e75122e354b3582cac4f09621980112a36137d975419faeaf71cb65096d3965b0f7f1bd0fc01a0d1ab6a9a9830d58734e70cfc0274d0aba267ae4e9e2979634264c105b996f9eb3702a16a02ceeb7ac4fe76f16492963fa29677bce2c60b9ec980282b810c57e6629237572c757f87aedd6e4018d944556fc5eaec0f94cd56ce793c8bc4f7fd77708c9985e546d725abf9d2a3a856589e34e73ee8b57d3c4e8b1023c4448a9df00bed5818f6d20068a07b70b00a2fd5c71fb997c80d9abb98f690b26eff8e4f5415369cf1dd409e3622ca1e7384c6be7e43e911a495aa9b0247318ace467fdaf38494ddbcae35e2ed31790462393eb061c36d3573b049d9872c4f761ca693ced10094b8d2f565523ae9f4c838782520d19d6ff239d8aa06a1247f8a6b19f1b8bdc4b9a78cc347d19ca66dbcd8f5efccfb925fd1f6faa8073da9f756d6c14819651c1e277bec28a9925f4e053626026a96ee527c7a920917b971583ac3c5c098887c4268f9244d48074a872dc80628601899bbe4386426248828b77957920ac924af65244884b90276b92a7ea93b46f6c2f8681207385254723f2a0510cf2bf932fe1d0ef5fd98839ff6d4018362eb09b10f90a7d775350507f03490764cfdcd529b73234208c02918bd306a201234e08ce3bc20c204182721b762c1d9ef4a6a6ff02f8a4dbb4f4f1decead658fb8d9598e995d513016a43f5bc3a7157107bedd707bd5939efa0540ab0b8a18bc5d8ae47285e067eec573f72ececb1ccadd8e96ddf402f2e34b117e28bd21dc95c647c0ff500da97cfcedd1b54139e24f6566d62bdc50b5593f1f6bf9b276a88940bb47139e8bb392175df6125380f5ff2a9749bac847b4c656bb059c04bf66a9e24adc25eb9164122c292a8300db5770d0b76e275e83e0a9afd053753920e44dce497b56ffa1951673f881efc25d660f2625029c8b9fd9573f60a9285ceae388f794aa7c6413ee88f51fdd40452f50212c25dc48e9a148756efd018f4310ded8df9fdd35965816c06adba0174bc0a1fc9902dc9be6c3e29b853e5fbc3311e05c82df42b9ee1fc2b59c52f3805e0b05d4a3b588ab8c9ae3674ec74de201f70cf564ba92d4daab5a9995bec8e63e0afdc917e24549e44076835b3dd2cf9fd3b32bbb31c0c149d6b900b63b93654f081d4ed882e35aa6c11cddd5726ad655c77535f192c2d3a19db245e8739ce1a8db44b4ac564693d8e84304d6031e5bff555198d2912f50d8182df2650f0de72cf9af001802adea96a04d45c07648e48a66daea2bc101c81b0db2a61323b74cddca7d0fee29e14776d573660f1c2db0a9fec048fe8738187c6fd5b1775f1b4cf929ea0bd29fd7e2942299a676a4d66d0a96b0762ee1d954c8f683581083bb61c3ec45a36b171cc2afbc5e1d4112d8a9ffbddf64cf125a140ddf50a331497b11abea9e56e642e03725881fcb2018172374b89e35c1adff4a47f5b8c56f7ed3292387dab2c46792c68cf6417863791fcbb04866b31779b0df6153a9d08fd22cddb08197eca853b64e425b586a058d5ddf6a561c3f6322da636a3d97c46c5ebdba0cd0392e3b495b874ccab7d562d4a7f19110c4552731018e63f969b88bb39439a75295158282d938203015e1f545b4e8efe8688624e4c30d9ef5f30fda84dcd28687a9e8c895ac7cf559dd92e668b190267601e6373c63a95899502a6ae2a7e4d1306eeb5e607102fa29151cba7ab926cb8547e7e0a6c1dec763f56b518bb3621fc1fd28dc3c05bc83d2901a19e07c5566807c1a5179e7518830e858eeb5df483b8eb870ba80b0e3aa0e6a1e188687f7a428ebb85980bfba538e6880b48d232e0e43b62f0a0f6cc0c98321c613e451b24233e79f5df408530813ced88fe5e82f3c18510f2f75b14be69cf3d20eebe36370dc1a585ada193b14b8401db91237b9cb4b2676d9e7dae0a44c257d4cbc654d2b07522be2633e9a3079f459811d792565c99722c1095764854daf9d07209d7f3a4195f99a9273e7873c1e679db21a4d83f4743ce412c6cd0e73e0810cb5339e9b2a9f7d0268982b41808f407ed9376c9becf60eed5d0456b99389279aeb4b8f5821b21cfb72788bb8958bb5ec74602b3a4fdb6d4b40dda2ef9f622a667dce65134b25823f940aed937617bc0a1a6feaa76888c627f6c2a2d53b6b54bebe7198b91d85768dcd610bb96b6d9845713c2d14399a713d5f57f07df9a031e0d45b2065314b56cf7fc9696e66ce3caa5de50a39a80b7f2127402e3ae09bce1b43d79724e07b0ce84334ce7f4706eb932641b2534bf5a3ce61a4c93caee75425c222fe33de500f0c3f1c99e4b7c733191ca97a45f35151f3e48d137c974bc45f046ee1953672318b304b2f448bcb3176293a0da4ec2d154d8c99ccbf3bbfb68b8d59b8705edc630ca5fecbaee6696bf51af1e5da48a1d8e4b84da0472360c27f16441c37adc7bb77936d9d0a0aaf05dbc828d4c102794a94293e8e47aa4fb0e097a8779b26a8ecfaa1d9e2df5eb27f05c58ae7516ef9e5b79975d22eaffb56a513eab1970e9bc8d999ca3fb2475b833fff164b7aeb2b5b7fd27b1e7c2dd9916161d0b9c39801296ad2d821462a33da7f370ee186e73f433f66bbeeab5acf6b66462a52e725b5b5eb96bc2f37912dea1de2b21c9a6449a920dd0c82618fa594e1973ec5aabce3df198e83b2fe3da606afcf6afcc6efe6893646ec5356a77f8d324e6e9d46296d3ba627ce5a55ca00674205e6ba5b07acbe910688e1cf8addbfb6e8e75c4ef8a8683a4ded5a15b640874b0771d69b84f966d2342651667b618a26d12c251063c16a2e7de4aa796e7ad341a1082b879ddc977741056633a93cf2f6f9652b9ff0d7f6e7f7cfef789625b341176095175e00e0d769828c7900d6d5c22e2b87286aff3593b1e7a51c044a5e55c1b900ca6e820d4e3418a4c47f7fa63ef88534ce04b01192241eab41e6861814ea275ebc058ca4016199407b938d53eaf8bf17a2ea44877f658cdf5b7c6f6d970a184301e4bc53a8034197578b8e2f31c2e45244bcadd0326d5b79675096f301fe96f32edb18d85889da5a0e4eb39c28366ef5e64be1332ea936d77fc311fd4eebecb8f37d885eb374827e9c26aed01fad017c7feb789e8c67cfb828549e08b5ff6f2d4bc3983a01540314ee630a543eecf454369b11f90b2d8b7e0eed18e18e039c49dd95315fec3ed424ce5a93d0b9793e550868fc9d1e896e0b7118871ba45438faf1e3817da6520bb968e23772ba4f59a30cece6dbc53ab79c737ffda2ffaea91dc9f53d070d5bcf8f535a463f7241c75a81a779fa37d36cf894c8fd7710d9f9f8b39054e2de5161b21784dee1cfd504b30ce9370dc6a467a30507ea9c1926a9d99b22c0216accd2285bcee14b8000bce784bb93c020f5487b5ac516a0365aa7214fff2da460e92106b387c3d892dde7562b37882988af1b12b06c1bbefe40cfeb3461dba7a76e0067ea80f3d2f664bbfdb2490b2f0ba042d70b021f55a605795eced13e9d4b9215b9aff8d1af29660d379ac40ac0fe171a74cd1896f1418fe5f868b6071be4d770ebac60a2cbaa540ff766021694b0f590f4eacf7647079f2156ef0b4325b1e18b49d1be8f39746e8b38ed3ff28436ba20d91461e42b817de947b108426d2c45d4245b688cddf5e97d932856f2ba2b7602417e2c871c199e955449622611072162e61c5cd1fa6784e18f701ea3ac177cc9ef42c4d34f526b2b559f03fd62b9bfafd6bf3bbc86293b6a87dcad2ee4863a02b2a90958071f518c2486700eb9ef305a5fc8926b0695a17620d0f10295d756aed4dcf74f623f906dc5bc1d848eecc43c0c791e121ec935d03c7b207cdbcc77f7b6aebf6309fa81cc5d3e89a9302448acaa1796f81153f372b1bde8e2b6775c6cfd479032e6ad5adc7be5939d1f3869dcc3c6a79a3a1432dbc9e9d2031c70ff831fc4fdfdafdabb0feb43f6877bcbfb56d6fd772b310cb3ea82a06ba013fdc4efe82c19529179493f03e58e61b4cd4112adc2f3be87f6632654353e1c310a294c15858c30ac39eeb4b29108dd2347060d72e39fed42dbd656fc913aaf4855e74ad57979723ad0c35a5445ca739fdfd6244b08509776550cce26c98acb8b4fc6605e418bd2f9b49e2c8f1c536d182319d08bf2823f1ac18169384b7289f1dc6cbd43818a99b126b1762778ece61d1088d6ec07af2273fb881e3bee7d5e53554bd49714c4316a8cf95adc1f636b6e259972957f00e8a3b8e582ed09738868adb4d47d4f2389bed0b44e7dbadcb420328796670a210d0f0f3fac356e1357dfbaf6d6269cdc1d28161716921e130494aca3e060c22a1f2f6b1523ff634ea6d6d4a5606502f5a36c6cc440b0cbbb7ddee0d4f48abf033a9ea43c152122e909228542489610bb900f4ac9c15912e8f4391ed0b3bdf55ed8a9adbe800ba83d92b007d45b67740945e3a16f2b5604179c6dc34e0c37abc4c9824d7002391800538cac36ba9ddde2e210869b697c3f201e70e30080c2aff9b5d25cfbb7485ecc8a2b1decab916c0a55f008ed910bea3ecf4486369ee74472303d2cfefd7eca4eaaa404fd5360e78fe091b582300bbc25e3079967e1a13a1c828dd6e39d0471d3e9cdd7473b4c57575c853906a35a044b8c0404c9c71f94a25459d5fa84773788eef07bb87d247d700894d9f4b1ce3a026f4a98dc83d1a623f35b5ed275b300607a9c3f199a0eb7695d447af496f47b7058662206b0c772306f7c46f52b6fe55de46ff64bb79b597c18f1d1f1a67be355c55239ad53d2620f025bf17c9db17ab4206b23fdb18c59f16caa00bba339b08457ad367485127fdad09243c71690234ebf52c96d838d58088afb7aaed8a506e086869d79f242743d62a41181206f37f6a3a3d38d133cb22c63000bb8d85833db8151c6055f307b4fd93d84ed6191af7a36e8622895e51b6fe11478bf75f9218aeda7ad39efc70d3187381e9a767f7a01dd372e3a203296d411bfd46c3d716334b68333e771831822474660d303108dc4b2393cdf3c13f755ce9ab5f138a909df2946d92bbe0b8e34f0afb0f6d5d3ad615064388d10f7a1e6c9c6a96c947370edaa6ec5f2dd9d2e55ef55ed702ddc3e43d279af7513cbbd1b6f2f6711db7a0d6af34b47f5ea7c8a6fc103b87d25381083b2c5296bb59408bbe93ed9882dacce356b05a99456c0ee184ede05ac95c96689cdd197d9eb9edfe613ec7c54677b86eebc730f44aa51ec6fc522b2788795e23baa2758502982dd8ac10c6d40a43b8f7d1eeb21a39f021c25e31eba16607b45679325853d429338199b3ddfe7765438106b2f251cada2f8da35f13086b21ea5c3b16d3fff07724054593acdadca1943d9a37d296dc7721c25c905dc954090d039dae2b83c09271e31bee52eb14718eb7c3afdbf136ffefed5be2b2b835e633afd2cadc8124700ded40390e7b1b3b64af8e242d900a46f690bf9cfab2e62e31abfb345841cf10c38a6cbb086994163e444f018cb7adfc967c00b4413a140d95149c8acfa2f4ca1b02b05b61ea4535d82779d68a43b9f60dc090aca3f5eef9e879b9ac37adb076c280faef1b7679d70cbffc05a58497f5b5d12ebbac10035e9c9331d73c4ca12c78c9fba1d124ca2b4e0e7092a0f6c0cf41dda3a457caffd2586b290a81bdfa05ee808648dc8217919d35c351330233bb3262d6b0d103be26882b8324a55ab75600af36bebd4ac37170e003e7df072ea8964380a36b7f6ef497bcc2a3d9946e2753474d269c19c0e9e5d599c5c33d1f1bba74a0d4a0d392d9e220f2ba5dd5eaadb7a42cdcbe66bcc84e3a21359b1c993e66f0aee45c752cd183eed10600e6e224ab39fc30609a692bc71fd8750bc993c61f52d8b9d2fb24dc3e29cf50620c18426539363429364962a9e651c275e6c7ba56e16f159f74cdaaafcc39516aa7fd30decb43540792f3485180a39a36cf1c73984107674ea7db61074419360344bdf6ed888af1cbe2900e82804df2253048aef7676a415c2196f9ffe84646c2ac8b475b10f4cc565960ffa9d7b5620a1e44c78dd340f26b0b10330e1801513f66fbd1cea5129d001d7a7f004bdb8d533159a18a10036d15552df97a4cb53b589f64814569a204a41352d7d5cc8b6624e6484a219a98de09681ba4c550719078b5354de46f786e7236af7524949ba7a05dae6a7533f2c3bf6a83fb0730b7eefdea0e69c22bc37eb4809d9bbc73cb8694eb54e349d2803cee3c9869a19db74992628b519fc4add9153459eb8c2bd70f2656ea64c30fad47ed5212c5928d34cc7706b3a0f733c852e43e4d0b4afca72228e7a6b71f493ea84668fea040531cf3c5f4b0b0d20374f9695a282301beb1324d490b69a03b5b5cfb554bb4adc8b265b59482968e30b9cd3ab9cf8f633097721aea8717305024ab4f4b1dd885b9ba61c9384ab282463b3f733bbde3546ae8ad551a90645e707e882de684324121643d48e9e0d12a135aaddd609298ae359a323758f394466a6c5026e687d5b4d585adf1ae36aedeb9a261960071e98eeb0df11e6bcea1d59dd87bcab51928a495b5af0cb89d80ef603ca742205895f5fc4b01f95c22e4084a78086adf23b41eda625e3fb12a5cc77b5f104dcc2ba754c1a787a619d23fe8220ba1ab09b7c5cf219bdc67c518a94ac74bd1c1bad4d973589a6da073a38b4252e15f3367c604b1603402b67880a0e6a11ed83e852d54c6b2b69ced00cbd8dc059164d3967daad77667e0ed250c47f911aa01dfc8a26dfd151c3a5eda3254816a1f0cfa16b29d81350e2e9a4928f6cb7921287487fc27169135f72234837dbed019e5784fdf071857f8c7a41ca327551dbdbeb14bf7fa9a91aca43f716542ffe693912f47710a74019b32845938e7a68dc4d09528a182855c04b0edd47cffe715990816393e93329a577a82159b6b1dd53861fc4e222f7f478fca370ea5afe1e819e285c3f5ce31c2293a22489a3b47ae87e2f81a178c59a11638e3c72b8e1396afd930d0d0b57afe6cc0da3c97671c2018753819dfff7a1eab9b09d9600174a2d1ccb521dce8d5ba8c125f887542f24e36289a99fd3a200af62e779f5c0028872234103dd5fbb372c6b3dba2bbbb9430da31e166b4e0e0b07a998560f7df7d6ec5dbea7fdb2b9ec082144d4c46542eb582980f87a83d504c6101014b837cf5101c7598dbab1d7785169730589c3f705ef6825b4edf901181f7d38e330264a3806695376cfc814ec78add1bf321ba940dbe65889c1621e03c0c70cbe61fdf5ba0ddc11cc3a31dae509c300531ac3824f642b6a2aeaefd79ec6b922dea8125746331ac95361c6ef94f3ef1b6d6dd30d4bbd0253b574c0ea6533b45f0d90b1e94b818fda174b97ac8d602a3677ce6e81bc2171cf7a5eef5299758a32566652476e4b1e6dc32d94f8d3db656a314fafc8c72d59c643a1814c93f5f63c54305470238e550767c1319ce0d454d225ad4b7edf966ffb367a178646eb240b89b20110765c498a79e3767bb42a5169f055d5a7b821d27e42d64b5169f80e46bc863479c4d2fec7694b80b394abe5f6d854ae7900b7d5b6c301c67f4dfe120f47b042ad789c546c3bd028644f68cb14d657bd567d6bc319627371da3986e432c67442dc2da733192e4b56229387f50cbca6457522282be75bc486eafa108a5bbcb7bfb80236a17ac142adf4695cc58b8993d5c2c634e941ca7984be0c4458e7632582ee901914b4771aa48e8758f13ab30c26a7a738e8ce549f501cad6996049a9b9e8f582b27b484aad9f9826a4cb1aecf08241dcd465977b0e31eda6790640f35fe8076fbd3fdb1d7801682473619821a1ab162a4e60f5112fda016fbef16b5846c0651846efff6ac035728a5518e611784e0333d9713ffd2a7d5f51ea266df9c3764b6f0a1ef691de48437984c0ad5244826806a457a496e531132c918f7b47e387375545764b453b88d71cf4de8fce94330dc2c7f3e1a597403f9cfa2e4899a60a7d43c522592fecf9e2d7764d7d5fc0bad81e48b67c1752b3556a7f6e9898e1101c46a55e7bccba92efc47cb5cdf49f42e98e2c8170311f6e9c00e82bef066c35af7e8c9f44441378bd2c24fb3fec1184ce3cd264ee2bfc068a8509e58b4eb64daf5cc2586f848ab29778e8b6cfd64f461cbb4f7934418bede9f1fe2786dd14918ffa9eb45501563c72c25564b00f56cc4e67aa67abc5f8d567bca466dcd9f913fcf92155fa8fb30cf62b4dd792c5ebd7cf2259248055ad5deb45ff412523322abd6d427b4c7e9a4a41c51f9fcdc474d268466a09e7bfe4486b1062335beb9434105e8163318574a6fa6b632954061bf262f72b6a943b10d4462ffbf72ede9c35d4d47c817d3e2b559a5ab106df9ec0dd7681db9a3605b629153e8c6c66e7d70ff567be6e2f61e12f77459bf6fa31b43f8403298feca537a4be551e399dadf6c4a2155eb8ef8a68365d4f1a84a3fe7267eddb63e9e2f9f26c6b7ff687968c247acdf2e6dca864c594a33b98303d2665a340516352f77cf54045faa9e48096415410b043166faf92917deac3587e3f89438ec1768cd5c59b0c1d3cf97dd0f1a616c406c42f2ebb79f5ad04b381fdddc3f68e43bcec508db7ecb67d9b6719ac455f0475fe641beafb307a30d29494687cb191ea7e5137607d64ba01d87aa744c0de7fb594a278d22b4aa54b936744801788fd6b805b8e72ba5296ff32e81be75ab1d68e5d0ddd8a6794423608afb5c7bd00526932b051f5923590588078fdc395e1935377eccbfbe6c1a943c0eff726fc671234c469297f1af6cdb970183daebe8a3e53f9999b0eaf4eeccf2ed020868ad16883b5f1b61067e1b2943a4ab847881fed404ae760b1d9aabec080ab0ffef67e9e838845a0f8c204018ea9bcb738b2e402f5f09ee822ff0106e50f70e014cdfa206e8cd7a513a3a7904e0ba2404c050ac6a0c9bee9f2dd17d8123d4bb5596363d58606cee9751313d906567b4ce6ce74e04ae46302d027b8e5222705dc6c429a9c9f45e40c81d6d681420f409912dd50df2eca0327327d8ee6d3d3c6192c38e35c67bd3699dc3ad6aea60aaf70c677fe2993596bbc700829a4d4b76590385c78a186020a6fa9cce5322c534beaf326740e13dcf2e05e5e55fa33b03515f26711c81f8ae4cbca5669ecc17826a03eabcec99f83a419bed82bd760a96cffb8284c0c03fcc8446449e1167386fd08b83ac8bb31a58abc96dce3fe4d8d8675766036848cd04efa1008279a85d6bbed7282a7adcc3a1900e749d957b125d5b34bde2d952f9113695412b2cda32febe34300c03eb7a9d1c3cdd4313258b4015579ca0c65f1bd7ba8ed71664bc1cf385845502565414eb83e2bcb5e4169e64cb197dcd9135dfffc5bed8b0cc0338d8d1170802bcfd7c63e787c4b5b250ffb27b251c6507ae65938a1de10a343d63973e82562099a802a84145df7e6a46a99d5de6a44d6a9aed68656a70bd0aed3df62c132c760b77c1d177da53c4bac46c2a338b37f3f079b1c1f66cd5b5fa5d7e16107ff034c5c48150fd0a1923d7e640d9cf5d9c31125bab562e93d3b6f3acba17eb3f51e026276f22feaefce23d49cfbe64212c6bb378171326a36ade4a1a59bb1f744e4380cc61fd37ac0f2004f77ccf907e907c5c8a1050ece08954d7fef4b39a19dba19a48d29c794499ac737d6de6e7117a660dd5c6177eb261cbe7a0351aecfa36da0856834f06ba98c91549fa78f76f121dde12021f17571763e8849e4df6fc9a41223100492a9c5dcebba995e713e43daf9b7ca8def8b3cb57703a20ba54d87ebf2a159ceeff5d7993d824a8df07f94b35e4141ca9d2e05c4139058b1d8e6a0400e5921eecb54a9740c3dea32dd3dc80e131259754f53011d84387b24b16ea8bc3c8a12592d1d42ff35a19b07b50c9c337ff9c9c166222027bc5c9fae27c15314a2cb0a32973ff26681bf8a553a507e094f89b063c31d9a757a1092ff73de42d27686c50271ddd8a07751356d86c6bb548233450e922816a469bf1d6882d7efe9a68b74fce55f8744e286edc15ed21a998113c0da0c92b93e583ed1fb81343bd184ce0b3f52fc088d87f443c527ba154ca3b2846ed0fd064be14e6f809a2058d3d77dec3a40d4f69dc0e26629711ad46287e984470e2aa262fe26ea5804c490a7c7f44f273d74cd1664fdf90bb0819f4b9f26d5d1024cde82c4c614795d49dfe27ee310ed34b4e6ec551a99b1bc7dd0cc3ecb8cfc6a249efa5c26586fa40b6d20a3194dc4919ca3efe8fd8073a3182ecf1a0d28f860810e3fe165740251a7f52edd0026e4630c06dad7a173bbb93dea3d77926b3cd3dea1618930a25a5897015b690a58b45baa473a837651803fc56b8b8a22d1a64e72acf8117ed707f22b6ae03baeac647ed034441252d024ff1b5a137519da9f9fea7524b39e0dd591187e4210cdbd59ef300d0d7c76b23561e41bc92036978a2f4f472ea46501a93579a71a3dd3a7c8e8f03fe8faecf4cb277e1996c1785ca42608777a3673634d2770912d1de645091c3ced1cef3378df775940d69732b4f3e2fd7c1f1e229d174647d04ce0020f1efd19a84c99476896dd9807ea78267fd9d1c5e1b51d4175b9bf1c8d07ddd622e47353f50520c219a28adeef8e3e27f00b5226a98f892e9f10e396438e966b68c8c4def9d471ceab099c439d4fc8dbb7b6eae45bb11bfcd170c9a5f3a8d986fa494f532d64ff74b3fd314cce50b46207b72438e2f75a2b260cd1b9346ae9c336fb3357a1e4b7e9ac1ae475d7f0873bb1d2fe99c40a6fc48843fbd593701d832c22ad741fd5480ddb1d2ffca99f991be334c10b63f55d213465106035239fbbc73a63ea93e9832a1771054ca393e26184f55047447f99bf6a5d6e16d6f20cc2b690d379c58c1e22e91ccc7c13f6a6cd9853acbb401096136c7a92286a50f42bcbaf24dfad74064c86bdc7484849f261d41364bf97ff8314431a1c1bb2518a3f411b2a1e34328e1657b9be9590a3b9142145d4739f6a580af53832e4d6a88f92449208f32abc84f58c22f17141b325ba17ec6cea1dd008639e84cb28dbfd676ce69add440c4cc8fd3716ddc304c123754bbc47d456f7619ca501f044766b2bd3f150ecd48212489b66db4cfd7a77e31dd3c94d37c1aa12a06ac7277a31b6b0a1d1bbe8a2a135720e74fb493c3a9b900cbfc6d3e5d8d1dfd17404a93c4ccf349c1ecdf1c59d9ea5249f481cd257a772ce38ca2a6398c026107bcc961fd3c1538782985bb8c769734e3c30f6e76a0d754da62a69439e7acafe0e753a935d550887a78359e77b1e05293700850462206606fc2639c4ac95389d294d8ae9ece41a95175d56195b72674e76cab18932c2d9a43d1b38c9c79004c2141398a302426f18018c01b47fe3c2c44a08f2e5db0e3aa285e5b91522f0a07045e78087232e20da3d90eb64fd1d90172f26ac3bca679740a4f5f773552cb9c180650254a85b211e4e23a23106cf15be3e6c82c46d581051a1f67b5c3a57bd337802fa51ed3c2389cf7529732de76c08197558cba0e9218464425d22b134c869bb0294eb11c580b1826449263bc5dd1fa3aa02ca19a60387304ad31390309595bfd1a7d2c0eb6bae4651e221c319ffbb786ccbe59d46fa6250519bdc283dc7029d95ad1c93a3c758c21524acf505f772bf87027a606ea4b961abfbdf3938b917235c76b6d3f8672643623c91222b82902dd0704f232042842c9697693200a1e4520280ab40a5e171adf6e2fb4fde672b7ad4884c33bcd5d03760f7365ac2c24e041fc7dcde9bc2d387fe308834f3033f7e71831c7dd8fb73b03467ae6c3501bd9bf6bb4959d00c2c9c64bcf730ef2f294de62577f3b496de96f71bbae809c9bb8f370141253b0046ea303a0f819353227425903f0850df75016f6d39c1a29f0fad8a9f07cc82a8446e0c2a43252240e85a742661327a7f2d7700fe094cf1c086df852a5b07e0dff33599e24fd6810ea030b3f59c6c2dc2d4385dfd2ea943cdbd64f40464306fe32e20f5bf33fd8104c1615714eeb8a31420a1155b5b578c5f8b53525c2826c1d8899521587ca892c5a2a9399b13c1d0e4341836875e71e1e8ce76d32173cf0e3adf43f75e899422c08de66ab692c9e67783d20ffc5cbeedd41f1c3c6f19b55e661fbbf0252dd20ff6ecb24fb5c4ef78d6b5f57b9619f02b487ada506bf2494d3a6789f27c881ae008bdff1acfa35eff6c75493e3fc092d3d962162447b006d2f8c7c00d69a3a4afd841985d7efa6017f0f4db1aa30d1ec4d4f8e674939c4bff44a0c1986066bd255727c53f622dd5ef9974876f4905fb4e2148490bbd725d8b254c2d7b4a0f6fa138d1b289ce07164cd7b8b80a607964c2fc948939e5c0bc7cdae5cb09e9239a2ac28fc44b6dab597646e28705c128eb8159759ed967d338a8a9798bf76c099b07ea1ce14622f1cbe9b884f7955c9419b664299e1432ca85c1293587222499053570d99c4dcfea17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
