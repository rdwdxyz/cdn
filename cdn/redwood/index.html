<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73376246f3bf381e6e2bebc7839aa753c4100798d70cc5b3739a416dfb73ec9331b361a53f07bcca04f8479d1701074a4f0a51feb5f5019f2c30f36b61192898c19568a0f8361139506d73e1e40558a43251ca41778e2fb6065d7c86d7ed56986e103af4980f9d8cde27f9be37ec82088c7c58cb094dad3d44e7ae9302dcc10eaf6eaa17f713450bc8d40eec65e97bc77e6cd3e0e3267167a6c9b6c965546d4fa6bd3a961aa675ea4ae422a1f5de7538738992ba3ac623eea6604612c35616472bfff0bff5b56f8a4a86d80888154ac5d080d31063da829ba116e05957084bf574680033fc4b6cd3c1dc0f619aaca6acfd641c774a5b2e8dd733841bf905408e042c98572bf44f7e2919a271d901119cc04bacbdba540aca1795324a3f53fbad72d0ada25b4ac57eaabd54c065c77c0a90be74463e5460cc5489b68e434e2961212689d0c0c6d99d45a20cc85275dd64e39f4cf3cbcd02afdf2315fe5db6cf2a035a0cac7c7821803c6bc953aa736811249f8aef65ea276df9d451005e95e4e7db7f711ef5304b2c2213b8225478764394a403d7ca5eb2cafbeb80719121bb9dce2ff11f73d29c460dc2522ad3d841a456a14a7b44c4850b31fa9a09d7dfd9e2c4e7906e34d7596dbfa2a9f219ec1cd40f435439628cfb7bdfd712637161e865ff952015100ef0b78c3d1e3912a2de346eb78f4905bf14caa8bd008f9b1e68d91e2805aa1019f023b4743e13ab64441caf81f874c488105466e1d1b7abd63c2c8a9cab98de5803c4b5082d039284996b500306c0b9e915e03659a2e0470cf993e6e5027ed121e299085fdf96000418b2a396fd84219b510f3b23767d512b0a6b864c991a243404967245ae99f15c21ee36dc1a218662acc115cd2ab3734900ac8502ecfb0b6e6d4d7cd418d9628403d3be4fe8e8159047804fc8013a4c32c98346e5ce4097630d3ce1e87969e50f172dd1e9901f0f0db891ecd59c5c0bb51a5fee3349348659469f8a2835825f893724dd623b6dfab67d97cc5c213f6d662ab55802bfe34d05c25e9fd8cbbd1a5d526a614677d6be8cc8de7e629f9418793f56e7924d7ff118508c7c75917737c0a7ee06f29122d932914878d59718e547e9ff15e815df6cdc379f858e8a71359da7915576ae7f41f23f5c7a7dda25798e4238db329e59fbee9ff89994793df44f5f746bb6c01b401b1b91a8401eb37a69967d85f9e69797b88d77eba7c1050401c5a9c8334e5ab79e72b98a2c6bb7badc70515a67afe81596878e4821c4a1908fb72feffe2c502844207468f12a87b6a9a34b79cde02aca38292a9e8444e19b0d0f566848de9f60cfe9f5c5c3ad044e4268285595a094faaff2cf279c988cddcf6865ce091c9e68780bde0e6e0e90bbab894403f43c3b5394a606f13b1befea6b1f43f17d6eade27cafeecc2bfa4801f39557011a6d53305a68a1a5ac9145954630241badf122fb4b0219bfa9fc0b04305b621341049e3425086e033e5a00b17f29f187cca74aa843633fe70bef026a67bb71213aa9ecf7ac609367e6c4c386b4523afc0eed5647c8df50081998467604928e5ef817c7b233a169f5c321b9079e72b00b25050cc3fd596aa8b6e17076d18f51b539da4e797ce68e28c3ae1c90889be5c60e1c16b381a94717c88a483a0ccf17a7959abe76891bd07c77307615ab383f9915797992918e5c2ccb332c298f1be494607e94c9cfb5e3b15dd71e37891a4d91bddb8c6d86ac0fa63dac9ef2867df656dc73b13eb9491815329bf4eec1ba98e3b8c142867a2b934520b4eef06b77dc17958a66f79c3e4973a632c3573cb61b6ac1e3e5f20cd8f1af883d669d1f24bdd1f228e61d51a5f4bb3075c5cb3f1954f000c1550a430980b59a5df0c592c7d519af4196e6ab76503e1fa0c487f69ecc919a3021e5968b3077410c4af5ea138d5453a5ca38747edd7aab457a01b6dc082186a144eec6f05e73e2a50e2fc1a5e36ee8db599bbd57fc1785e6b32f13fece35166f9f5f985c7ba0b5371a1154bbedddc7aca7f211fdb0182569ed7c0c9a939d878d1c7233b33166fb8bd1a61c8b3018934387a3d7f34ee33d6bc7452fbafb000f0dc5b473c84a8f8898ed1ee97c409f1fabd2e424347b74d5cb152d36a75fe9c94a66e3ef54b9ad640280b781715680d62da22e0e70b52323b9cdd6fc8435898dce35a9ff50a47d22230fbcdea3750af4d6cc1981d1d6fc6021e6c3becdfb7a32a84602a57b442cc427c43b7c9ba99fead5819d5a197727ca2e81a39a6727acc911208df68a44ca1601354d2dd39e5ee0b6ed425ee446ab8d72588bab369b5cad33672959e68a38d85cc454231e26cad4cc60b4c2494ce46da5295307f4d40d50fbb728bf1ce81b1fcc102a9a828ea66d00c0efc2de515a4d6384efcc1f50191661fa859523ff64eafd94e01344d1c5a3586c15ece7f497cc77d68eae82902633fb761b7c246eed38829ee6d9a491944dbcab4e76832e0558f5213c113e182a7ff58041f1db13699970234951563bd18e3552b0ee9cb0d33b92ff4e924f762f9d8fc663885635f7111ce768406ac1be7d3d4f683fd94f82c2dff34a9ca46b14b68751271feda82c529b109d916b2b3d12ecb11fcfe3bf8ee0a465fdfb1c0422859ce2a68518a2a79b2eb44f91e81784c11685fdb62f35da1643cb89d12cd9684ec9fa751749d13a88452b0893d364207f2365d2d5c4d527a91df1977584530055f8e3933dde9ad6d37eff8b6ed453eb9a862a51c457682036521193b6bd1284a5573dbd23ffe951e208e786196beedb3572d899f9d1281cd8b0d57c37a48503c63088611ab2ee61e57423fde87426d785dd37f9b295500f5411ee7e4565e8ac2bdaddcdbe7b712f019ccd72cfdbe973ebaf0835909eadcdd3358ae5da304371c5578ca44763ff0848302d17ab753af5c77fb776a24b7667b37b284576c0c59ca75b969a27b121d0219b880ba6ce2cad83b8eabe169e639355514ff579667cb655277afa69c4205c3bd2c0956d2b26ae11400c1287231a6bef8f497c1bb82da98a2b73f75ef897110165e337b6e51c2025936a215679e9a54adbfbb727d9ecd65150d3a7d8ed70f8d63bd24b144226bebdf5fb05856979a97f2982533f8a9ec9bdcb264f14c25cc567c8d08f13525f4e0ccb1598e6a090a8af5ce79e26d723039005d6390dcda7b62a2b585d1553e6c7301c1fe36ae275fa1a7e34bc652df20d3775c0be13d88443e89f5a1467350358f6096b175693850bdbc7ba6244c5fef352e74bf7cdb02aea2c5881efcc9065d21d3a82ccfeef3af80511e4b030bf76f0f7818ce9b782c11f657ead3ff583e3fc68954d87cd9fe7b4ba873be763faf56d4f15d6393b4f52a744d9af0d099a746490f02c19c7068e9c60d744308d7f32e6c8c1633a41fab311fc3ad9c75e8cea9ccfe8976199b8271f6bc82a31200d3718f5e3c3dced9b49c43bdb786723788d69505820dc6fdc049f406c3f33be00a3eb5c4b12695e645d520f06ab03233c797e7b4e791d8721284e8391ebcbaefc58bf1b874c6fb228a3202d3c66b550b12c35af94e3dab9edbfa22dd3ecde1ada848713c11f70fadf44867d877872fd38a5219a112d9662f9bd9d856ce9f42c4ae931ab8ea3f0e1a243551517405b00a553671eefe886a829609f56c47d0a1e9b1ea466b72366f6d2c557036bdb595bfe417efdf2ba8971450b95e6ab743e3865290ed9812e843c33368efb4c54b336585923359097623412764b54bb1ce8ae7268d0357a069c15585f9def788334853050618a2e087e73d1a91d3290b15061be233ba14877c9cbaa5b741d8fc1a4a46fb1ef0c15eb1ca2261a0e593c0359cf4e8d708e0cdf963ecd449a17227a1b38f26a708a09702d61b4984a54d8ec03803aa01e28160f98b7f857ab76881a2e384005790a6f6246fb18a4e92f3267fef92a2923aa952c5129e91474e1d2583ab0eab30c11181cef6fb5bde48c3d34c5ca4b75a89fba58e6b953399f43dc619be38d1fd156611a5eb3d633432d5e10a7b6ca01da73787f247a5db5a2c98195c54f25d3e938271a07593ebfd82d970349a5c3e8906346f4280db31e1cc9629834538267df345d7ae5d312ad8c3dd82c9c0f85930e15059e234de3058f1f151fdc604d1b9b19195c4562c98e2f9dabd68b5af8d7bd34b46163210e417701f38e5a60a8e40b274ce552ff79666fa33e66502da1c8462cb95a318dd1822098533ac5b5160bfb5351258b2e14816812f909f4ce8df581f3d5445632169bec2ab91805ffd58c33419f3e617a0f033947bafa5a521a05c90c33eb266061dc87408eb1afdda2d5de24a9451a066a3edd6179b2d8c76760d1116e405ec97ecb97905472c5a11dd671b936f48e88e3583790c763c5e16dab1b684d6a03baa3f7bedce8fcf84f0ea66d5c1fb67d5bd50484a0dff6ac34d358105e118f34a662a9799e2bc9f57fa52e95e41b9b47dfd04471a8afda4b246fe3a2bf5362214ea7a0a53786802dc58559fa1acca87c0a08cb1ba7fe70cfcae1117b8b76b2c4b1a4c6f4c69cd7b55693d234d18ca50a9ca12a64667c79815eff2c9c8dcbf9f78c5d6ea564df86eb1b5e4917fe1c458ec6fd0f9c38136cb1084564ece368485f3b324bafb5ca4c858969331ca28c73a62afaffdfc8ab20cdfef0398e88ba13dd8db514f93c935107134701f882b543cde7637de730d1e4153fef100ab50614cbac4ab24aa021fa4a4c49466b9b40b1947c6de0fa7bd54e0e3e145b132eb6946c7d3537ca56a0e3e0caf8cdce9c16f8e9c7515fd40e26b6147cc5ddd5e53c4da920656aafc696618d4dd8b73f905dad10fdd6311defaec335277d8f5c09fd95d4d5935c2188a6d151d3ed583aa784fec9e45ecbcf7bd2a239011e4c613f7abff7ea7eda61bcd08785092278475186c6af6b78a9b75833936e808f1c8b838b0cd8de1fed0cf00744847fa550bb49e7354d311e3e90e247f668bf21c7a18acf8ebf2d833213192543b284efee3e889c7a1f326e31702fb2f5b43769ac3b7e59f71b71e2a48adf0228a68908c3e95129f9da6e3b604bdbe6567edd157f7bd5b5916d92621d5bf76d8b8c1c5618ed5f5eca09f94b334b15704fdbd6475abf469cdfa88d593b270e07fba9937078eee82d19dee2b3c55bd42d30d02deb45e06d605b5b5a825af58a5e14c3d18456145e4cd208a8d0094521acb997030fa8fef86bb6ec9ccf2dda83fc053c09a8f548c1b39c5d5228fe103bd676d425554ba33555cf8fedd727a30f64d820c980110e4ac7ad4a519a0d88e1c32b5d29cfb685bbb7fa9706839e09779d986fd09b260666953a8db5a63ff4bba599cd655cb66b14380fd3f8267eb66595a124463b3d5751b5cc71aa5162f92fabe31b1480858ab0e328671a8401d54b05b3cde261129450e436a2075e66c0c481ee3292032ec986fcf57f84c47e80fda22973cfc32d639896913b8e1cea6866d10d20dccf8072e5354e0f799a586749adc468f13b6ed7217799d4d078624a85e3f0633b6faa63c053d136167a8debf6e22a052a5282f21ac6cbd689bcb788caac1b6c77ad21d6d74fd211421cdfb9de34056092067cca0c1ff2bc290e111c78f3739021205ff5416ed9c3433d51a55948225676a47930f260c7502e3e94c5f8e1b6b062385aea4b46c4955bb17c82d7b5ba207cb4667113d7d1145cdc58699d9128c2ea543a4d924b265e8b5012b676ca7d8306f7124bbe05c756ca570c5db83bfa1ab5306b44b902ef29dc91b03c1496438f46219b327ce52f5bf1e04e52b0cd729ff2ea27758a86bfadd3d805ec75b6f818eb94ced450b460757c74150d856d2f2764082f04706dc071a1897e9f51bde7870098194995cbd535caf04db61a15ba9f722a24c6ebf0386a59c90038fbe5a0449554b96ec2b6dba801907e8e5fcd63ce42f4d6801bb6f1a078fa1b978d6c2eff5688d16ec62816cb87f38fc130ce3a75347364691f563ae7e0e354a0eabbdc80e65869cefcea2db6a4e333c6257521eda0a7df909701be3631bd6c85c3d50fa5e818312a4f0eb0b409e74b8994170bf0fadf82fa18d3942956ebdb359dd6cbd4dd8a21b8014e3cc7e44a9d4e8597babbd241b87b58b3f1e482a6ade6591ce6574597961819cf3d8898ed864019308b92c72dc35b4c17ad8755bb8dd294aaf77a417ce1f9a87cc5123a333d54400c1affe24fdfabd73eb13767d3cdda0e559a89c099f3cc91629851972caeee2f256e21268f315eda0cdf1c7322677152860dc99b436eac2dd08c516f6b35b1f80ed30292e42e3541cb717a000b753c8a2560cec03e9ae7da25ed373b8fc84623bb04ad64fbd97c0313cb8cb8e0a00b6505eaf2f87bab04c71a29fa086d41ab4361bfb8199743f8d66803ff98514df03fc1b8eca98fd8db3c945cb4d0e70580a57e33e129713e6dd2d8a0db13a724f19b503791bcfd0928e85b22e11b17b34e32a8293b9ea7b67f544ea6ef657e8d9a65b54b672d440975c808a29ab2fa244786a56ad40f368abf3e04a7ce56cd94d1de0ba9020012228ba827f2dc86755b3507c6e98698728ce101a72b7589470cd087baa9f390ccceb36133b6d21fb37d8b202774a9025d86e753b3ed3b45eea4cf18a8578f453220c568530073f56396e15d2f2dd674217b2bb53c839aba7c076b068c6162900e59b46b2e89cc05189a764f470183e44ff1f23bdf37057329c9f5eb1ee11fe497e2cdf1be1e070025c0c10fbea89e4b036acbdb5cce88d73a4f9b5bd19f173a1e03c42ff31f4fd300ef78d8066437dc6da4f2cae420ad99e5436219c10fedf6239c7b369378e4e48bb22e6e6e26b838b9e23d7f3f5387b895be2149f942dbe47988160ade1c1dede9c55817fb81a06eb8f7846b7e79bd0f2601e0f68681a4d2679868348d15b1f756fc09ab7bd2452b54a89ae3327ac1a2d57e6201e36873b9fc0bb7a1862ce60eaab82fbca83424868a908730b45ac1105cede769912fbc50cf735cae13fc8819911d006063cfb84de90393908519119d2dd93aedbcefd1c29d05cd2dfd10ef11050d501b54a5c806759eebc3132a966fec52b7826d6469f039cef7d392117c81fe06c36b569d7d59bb666962a3cbac1a814df78efc2104f84936121679548d9500dc2f5004f3168130946936640dc88906710bcaf6152f57cfeb5069e1df63631396196b709c100b5bdda79f9a035ebafae01cadc44dc6551b7bdbff2a40918f156aaa894e39e9b6472511041131d40210e4940b72fa06d5e36612daf08cb2478ab71d8fa5e5bd170bbcd573a58ea941c9b148d6fd121a0b1105c7816bd9f8ab59361bd2c353778fd5b007e0b46d0b14fbfde8f0f5a4722e54ac1a3b438bd9e9ea32eebca3d91acc771940e198d97323a06ce500bde976d76df15b115f4f7b5dc5024b859d6f6f0ad14819d0bc45347cf05747a4758d20fb3609850f49af4d2d110a6ab504aa96b3b0d9c529a023d073cacc1a7ac2fd7a4fa2800bd45a15217c2a6e031d90085f2fc3dd843e49e13191a9b838fba6972c74e5eb879eb32e3df36cba9fe1439abf282f0b6e046e7ecb22c973c06b2db21a568b2888118155ad93bceb9796f5a28ddeed79da22572292318ba6a13d50278e20e2978b6081d8a8632063d44e3fa747fb217c10efc0bbaa92108660d55ec57822c1faa7c435a0e431731b04dee4cdd8dcb216e024fa1f63b840d74d11dbed8890de45bbf06e412d661cc1a0feebfd070d66bc81668a928cec31f6b5b6f6ce1a8011e3e50ddc4013d56083837f94186d923c4b8eeaa00a34f39771b3e387befa8408bab25a8693125efd2309b1faca745ba6285e4a6c29d47054c52c0b59ce2d9cf6fb244e16286dd26cb8dfbab99f624993cb9507235e52340d505b8fbb80b6c3bef98c160e7e6ad84481c49142d1a92ca277d00d9087d5bb66a04da7c108989d25793ef7c07758a6e897d83b1d28de0ec7223162034da89e9e85d49e7a00e762d7b26c87bea7a4fd0f54fae57d0fe565a8ec926f0a49dc5ee1463c45c4fbf44bceae3c9bb16da1291eed7b5cba43a7b82afeae46c7dc1f0df7b259943feb1e1a16081858c93a3ec392cf7866549f3df38e18c5b831679bdee76a4ea834f22e57347e9a60b0de780ea2e165ef5930736fd78e3dc4ccfb1ba79ee540e161802a54e18792806be618900f4fe2b9bb80b57f4cd6968bf31dca51d1e00ea87c65d0216817e8087723b02f9af17e0ab79455f38597c53a6a2bd60a7b394e99becb23e9c4ce8e68e1e23bfe2ff875e0430a1a075c32fd0e972e9beeb689019719fd1ea1afe7ae389dbdc33f7afab8031f8637cb75af2bf46d5a1c86c9053b24c9e3cc2874fe54f74352fbef69c767454345ae8cdeb7ba1f83d82cb5b184672121c0c0f862e8dab25496f36daa889dbd7ab0251e135fd24eb0f4e84f8a8292b8b75c8dd95fffeea4e37f0b935a9b45fd231b88def23e7ea5c4212adae0f5af8ce6280bdae838bdcbf13f1b3011f02d05c908007a2b6ef0602a111b77faeadd0bff9a02a77762b9ed7af9ff2f03659be1b8790112d8284d87ccb5e10cf06180e04cc6dd33011218bc85d8c731398b3f28d8a1573438cc114e52e87c1484dc041c23352bc721ccbe49d924420ed0a137ebc291bad5315155c926058c016589c3d627f04fb2a5b68f24f4f3952488281a73dabf4cc3f456aba3d5f0134eb11f22e922a653b52000d9767cac47ec4a049a170c2a4d7020ad58b57ef84570c186f8f914fe4e6eb11fd4efe5cc0f8ffe516e37a33fa2cec06e5902321d30e0feb5f0fe0f0940bf3275c7997ec45fad12f166bd40d843b1e56391894aeb930631eba92c9fe4512a7492bd803831d66eb5c215df8fa08300b918203486a6c2c99227f91555ccbd7261470621bbaad497a51bc981dc6f0905c754417b9e03a05151cc4d694ea1efa4096b755d59b17ef8c6f6e1d29ffcddb55df92e93992611eb557c0120465e324338b18ae96f07ed808be9c96dcb6de2272437d15a0d48e2ea646fc14d71c784e599d597a3751cf83a220768fb69d35f018e267cd9cda2fc25deda55f34911f11ce7f1418eee07991af094369033ccdf0320996766b79463c0dbfa8c05b73af90f607b274af0f345cbcc440b159b4858d041f7f3f5dc51cae8afbad76d98b6e56527fae1edf4cf98cd354decf47ed1bd9fc5e23091b51ec20a9e7f66f423ec8406e79d30add05e69a905213d8cb93d410f0f85add9fa1dd396f6dce24bc6db59b19e5e406eb9e804ce63c947c8c072375364c194bcc5a2862de996d6f787522522359a2a0b46b691ff27d07898bb992895c15283e24e4137a5cb3740f62b6806941379d61f66b425d281c894126693134b4db9b9f7e5cfc4f19649626ade8bad33b8c00043a97b5391c18f9c1f53d293283b03a2e93c9fe8d02c66fe81f8a5b4150864a34a170362f3fc7f8ddd20be0fd5e289bab3cc0c6242595253d1d75a92196e71939d6fe4ca9e82deb2e9b65e2b9fe4c238a644c58392bafbebb4638cefe8611ab52447152e534ead34441ef6c2e3277c225aee58408b65d2166f185b071411863f4f59c306169aea01ceb4f91b3d1f83ad8cc7920b57b0c2bb5e7288cfd5ae4913a44bda8706add6d6234f04c47acce34144ef173e3d9f6b5826ad6e8fcd6972747608387b779d435483f0c905e7aa785264ad34da50e8893e8552653cff8cd13db917562759ce291346fa699acf781c17cf68de7b8a0896b28a3282b85db0300890b980c23b763a4bc9e4866e473d028bd1bde94c1ed5a05a2bc9a39ab97cf79707b0f248b484b61a1bb2724940bd41652d5b330f6cd8682a53cf35cbecd5dcd17b0dd0d7faefc5513711b7f7fd058b3de6e21a438327a163f2c3681ceb0d39133d5445db2fa77a2c8a58793fe2bb292740cab3a0752dfa2dbb5db910579546e3423d446b56e8300e0895455310c55341c5481ecbc74b5503b249d53e95d94a68d4d7e438deace64022b055ca4e4628d16af695e08b092f748fb49801ecc3fdc763c9a9bb59882cba9efceb7dcb32e7b2c0a95947217cace6e68d5bc2804fdfdcf3a8c383f1805949c1643a3c31f4aecbe77f361fbdc1adacfc2cd1f3cab4343cf0e8e1dcb7cc3a82f307e48154266f9ca37c491abe0ec3fe46f2f506f0f5dba70c7c21f1488aa42f333e89aa35fb680d3af8d51b7b8bbfda3ce59ea110a11696634061b42c6eeb023c6b378643476e92c66be3b44b2e9899f8d753123824566ec83b8e4a0970dc4d673e79c14617263d069d4440b0ad28163d3fca570827005cf409f19d84270c5e449815a60cea03d5a6efc8e6d446ffddcb41c4a31db180c1dfa07c9ac63ad223f38313baff9a4ef4b2f324134490899f08b3ffd9e28d01c8ff352fb8aeaa60bfc8b338ed3c0a3d72fad11723b18b69015b1ab959613c2106e8114289d76bf13338645b2c4b6c51bded3a11748f5d180fd2f206e2a03731106b757c4dbe56fa52dd66b27993bf42acf71bb6bb7668745402f8de0a76c2ee6dec3d282a05a99fa893ed4b2a592612a2c1bfd5d0eb63133ba5c95691d95ee98b0495b625d36e6474fd607e5fa538f127f79d066ba06309e01baa46aad0027df0cd85d8c1a64149c966dbf535711fe2131029a94117e80e36e118e218ff7afe70d63b712874f2519374975759c71165905d8536f96b750c7819aff6bf9c65b57c11b7ff8bd505c113e3ed942435974c232187e1987ef4e30dd6dc4280c88dd1aeadce7aef9a7e19363175126ed4211f2a1bc2481343f075a155909ad4165b11381966bd43f1b9fd345eb57cfe436de8c994031791010d96e94e6a931fce185ffe2a1e6786e8648bd2159bc40ee2cf065815aeba29e00fa84cbd2400ad40f4454126f81826c4bbfe29e197c1c7f0f2d0076c9f1c926c7a7f6143cc9d968c4379b106e8301fdc61d6b01d8c9ca3ee30d3ef2ced3737be9fcf50f6952759c338248ff950ebcef6bd4dc38a0634a967f83955b2f71b8de76a110b4769e3c299f749f5428319163ea640e4b39d24206ce90dd8d68993d83504a8143da904ffb95c798e85a556ea1d04273bee54cf1405590647f12a58b1008318de7ef5299d90d559096eee4f107dfa1b0e6403c1938414ab12b12cc26d38b00b8f9aa3bda0231d586f894111dfb51d8e2eed26f815f8ad6d109f669099f80d441b8d1a360f9cb6d8af61552c4bbd9d72561462b6f462950a652fb8a19da34a28097d6bb4bd9c4c0793c63a33520c7de3f082ee3137735f273218ebf38f2503c47dd0d3cc2a595337027745392b30211ffbcb79c383b47c7bcaa9a866604920a02c144e2c74f17aa499cc8444dd4bb37921bdb88f47dfd5213e2f12be19114eac90c24bde4062e7cdaa5bf48f87ab87e8c9203ae7a649eb657b699d6c91e07885e7e6c33339609831ae8064eafc0ade9df7b95995f2f850ff31e9e210f0485b677b4b914b9de7b75cd77feb43a78129e809459085f90cd7561e5ca2bd4e4e697a8d08b1d4acbbc1b688052a05635a4d4f30fceaff336980164623bc6cd032cae326608d0d0f5fa063ae9d85e7846c482cced01705fceb290fb3e32977f09bf09ef74cce6150ea9e030ccf45852a02d6e0598e8fdc77d9002fe02d92d2513ab7d90ddc21fea4402247e96af5854cb52b8309a7e7ed59d46d524fb7ede29942c824c1320c95da4766df2334ba351b6c0f4955a48d081d0b64680ea018a4c54ee5e3aba5583add72151add70e854042cee091166a1bca1026b8ee19d31c381ad6347b0a0f9d2cb49ce664f8fbbe76f3f6351e045fc0ed461e2533aebbcd78974108f8df0e55442cbc9f0668d05b5dabf33e2785660a4c2858b80f9600ea9476ea0cd6a5ed888330df0c7ac61c65a526bfc41472bae3c224cb45bd49742c54432951c1c69754cd09a418c2de9b67fb7129e17ca57baf72c7b658c0f0ab28606bff883654474f14985ab179eae8d5aa74c082465000968dc21753fa4536cdcdf604f27ac4b92d5c9f2df976393cb1256a14c190a36a501056caf9af608137492bb43355cdc21d0ebc8fabb784621d7075182b6ac6349bb633ee755e232556ff3808c2a842fc8f7ee32877c0b819f8d84d3e841aaa80c8fd53af41438e6d61988c151c1460e1c5fe9e43c3ac5996e880665b68e4e1585bf022ab1fa93c743ff92dc4d61f760b46026ffa867a7463ae716a8502449ea01dbdbdefd943c8a2af62d9f623ac937e569a7dce96acdb03f1c0bfe182dc86e20d475a8a47f16936f30ee6797ce67c5700d4cfd0ebd6e87c1ce87603c8a081768bdbb9ea87e72f88aecaef486b0b50bb714fcd03a1ab0f0bac7e86c9bb9125085f63c22d406a8393142306b984118c7364b339c7e001b4603f47b3256e8aac9737a5407ae4b84be660fff9d6cb737cc5cd905dd8e67ddc2aa7b8da6f9d231b2fabbcb938bfde35597db4ca4c6c685233a78e33cf92bec745d84229077a2d9a9d88bca8d318c64f0d91a70f1b45385d8be3e252ef6f75d1755e3ed9496966dcf056a92bef5720a055d1c13b3e97b04d37cff95b0fe387eee2f148aaaccc8be108549ad05e87b6758f9da1c77988a69130da8e974d56f7183e5a86261edc1aeaa6da5ee0eacb95d8de1bde19574405856fdaa79f6ba2cb118a45f04fcec013358869823db535dc6799e17daf7727354eb40853b22f583476ebd2df3925316e336e0818bda78614066ecd8e1c11e368e1a7f6790bfa38726c4270500c7072b07792cae5965ecc40b69e7074f5f518ccf99aba822bf15172fade171c50f0f4474350bc8c2f2849cbc0acee4ccf625832bafebe22efb47ac6a08660c74f9b73ce582ecbdf79553cea2333387871537949cd7f4e7b7b4eebcb660e56df0b55ed987b1ff6df1fed53d36dd57d9e39ba1766f7f06b56996905c927cffe8b9373464289736a9c19d4b3a025fd9ef7ac0c135418f49f48e420bf362c9be274f601ff4918207102dff290ce031172aad4c5d929800fec8f93c17bc31aec39ec4ebe9d63732b6a1347b2ad4573c517560bf3ca750dce4012f7e8dae91f1228ed3c63402fd364647e9d5c238fc9a5edec6951b6d19562cbf4961add2189a24f1aa5e95060689127ba80d8b6fdd81efadc5bec750f117be93dcbbae58ea8b6be11d055d5d7dcf7438c075a838e469c2e00dd909ec300932bbd3398bbbafc5de1069c474027701ca6193f2844dc2e38f74380c97da20b6ac9494771df7b5ca1fc889cbcd5aeb721a9d1d5ff4f8b048a08e5b55561363eb56eeb54108a466117dced431f94e3bf11ca79afb32bf45d50a04fff0fd332c521743e546c0f13c5bad93d43e46920619a706ebf579498179acbe506f3ea21e8482a1eecd9a9573634c5ad845e900f7ec52c9f767b55f7f4f34d0814d4be9d3069f59c9e88e461c10dd6491ad4df102425bc0ee1c652ba65348e6bd814d476c50d9050d5e2ada4475686ab421657fe42fc47cab0dc76f214e615492fc623421a7638fc2ebac17d67c75609a72fae59f28dcf950a050f28ce0e8d3af28450eba66ba5daf6b3e2100e768e227ec8598714f0a67c24c1d0ab3726bc4e2500edcb9b0eeacbe9c8febb4f35caaa57caa5d97bbd73b07442e48644926c49bdb21a8c15afc3b56338ba6dd77a58f4fd9e333f22f32eb41f63bf0354a4f07a88c85a490ceb2460180652160d573ac502525918a60aecab1a7ddf1031025abc871aad5b132c7d76d6cfc8523854c7ebf65baff5d7e73f3105aac2d8013482a6acdb09d6689ee87a9131dea8c82c97ee9cb7f9483b1da8b006cf800c847fc2818d7f6f11ce0d42f55293e5640d526871499f3f09661aa4ba7e7d6ad72e47fdead3708422c17bcf426b5b48fa483dd4214ffd40f068b6aa98afd476b681c226857c2f53e4a42833d54003ed605a22a047270bef00c21539fac7fd42970df2cd3da3d032f5fb2d9f6e33137b2c11ed771aa49d064e317e87093071426adce9ca5681407eebcf124e94b0a6a4230fd9c386c6d2f1768ecd2055d1bbbf5d8c76d359f1298a75e94f190cebc1b9f02401d9e50f977959d813be7a33dcab3266ae72052759bf8ad79e0c5f331f7d70a18f4822b10706ddee9e912322497842e5d94973971a5f325b55e954ad397323df424afa8daec02c20f992aacfc51828ab022bb9b3045ef2e19bf4739713732526d7919eecbbbca26dd8065a8828fdb41bfb2921f398ac7568e1dc9449c01ac8a86b5dce13bbb23591c3a6b7954e5768383493912dcc9b7fc845af7f0c29f495652c623ee0d8f423613dcd5b88f748e980861daf47d351e4645b6adf89d7e0537026bb414512c3580bea537e559c005b218024c3a0d73fcd28cecdacaec53f72bb29b0bc3544dbf3f2e6fcd3f7e69da2363e049708cb2b2fa6c925e3f9ca734a4372b6fe6e06abf1b097a4e8f6d3b1613492f7fb5429c47c47bab86f0a5e90d8d0369e87de2b06b91bd385fcc3d9024ab2a50c82954b2a7e2cbd09de28919da39332b4ac940984ee304bfdcac954887685b29d0a62b176b70106a2ab5ab29ab7cde6e3e7202726defb1d407c433dce4013a54090a5cc4b15407396dd47e5b807b8809563dd8cab8d05a48aed88b380e6ef45e6de301659e660946f38052fb8f76d322cf1b2e16d44302d37cd0045484702a28d2d3ee1cbdcc51819d2f3b5d516ea8f6e5bc2853acf60e033c30011fb64dfcbbf4636261364533c0fb0bd20fa834c5a62418e6fa8cab3e2b46a55c9cf602baf85bd505260fda1a5c7982cefd7e96320686bebcb3cbf168a8225cc2bfb6d3955da035f6afa0a1f0b272cf95aeea65b06ec679b680ade1170ef7862401eb536f619629ef3731c3c631f5482349f4d3c2ef6775b85c12e1e47d629f0cec9e095311f04a46df9faadd5aad9eabc254554b1892e2f7acbde38ea761008bcac2caa44394044c019ef4793f796d0f527756bcaf854d80e149babe956ba900740e23cdd88691859f1f84fe57de47f377fdb8311901233df9d3ebcf469f1421dc620d4b03209944e136afd49af601b4363244a9d25409a1d25ddacc00c5b1feb90deaada4eb3a2325f4ad53ec09c343f740fb14aa5b23549d1bdb9b6665b47887c17f66da30fead23a3935c335a9494d14bf2a829c0ecf87625b30e9555fedb52e01401bdec2c266eb794e78f0b04b688130ba2a47a98faadd6ea6f79f7b8f214f30b2afa20276619bc84437f5e8166076a6a09afed15d6fa7e639a045f9df3b631b016087779bf704a38fa803fe31a8c643a879524a7ad51543d45522921a0dd74a4c5aee3d2dbd0ee0210be909c70cbcc55b625471fab56bc7374cbfd532bd126b25ad5d29b5b3bdd09b93df147c2f2ced0f7b6bd6cb378eec518b5c18a577a6b4502291645088179fe5249937bc18cda86e066c46a8e18f52f7170a70950592cbd147259e118450b024076e12d9ff673c4631592e5f7cf24d0c8b8058d36e6b6e08315f03c8d73c068de4db7d02d3421b75828c859373413f346275074647bc14da08c83148bd70330c749c0beac94ff2c42764678e3d6ffebd28d09c99c84acfc02ce12d8a32f6e75692a358e351e70d233d28896bd72c803594a3edff7151864dafbda64d2be64ec2754d2b3eadb88e7c850618e998e97a0a0b27fabc8678c42a0a35d150867f13663a302902ddc3e427af43013cf384e2414f002f1f2095d169b4edd7717e04ac2803353770e8d3168a7505eacc02034b1f54542f0f60830123350de40bc35b69edfcff2e8665774d574ba6ab201ad6b275450489366b51e2898f1c5ef32ddf1271af0a93823da0a4a39daf26176f8764cf21a8d9ceaff29405ebf497b7b3afbbfe62afd8ca1d59d9452aa7dc92a175da8a714ba4401b701c3ab8a443de75f9411620ae31089e6233bacac0bf99cff301e9e5c52d1fd25b0a26076ed98f695cb7584ce9534c84eec08d0bdf75c0b65f69940cd945c5411b0acd9b1c623c7cd6e8ac0b1142b0ef08f381fcd8270b185ac8f3703b7b6c1cc8dab01398a53cf2de3cf9b1a5bd324891b8ae8ead0965d06f625e7c9eee0b8d3bc3ba0e040f4e971831d8b986675812ba18d40a589c6c8fb494299710d1bb8a9c24207c27d75331ea60caeb55b7b8b45098ada04f781882373f28ef1ec580a3e8d07e97b04609d5d7f4e087d0529492dc3ca7b4d95b6858d96bf104752c38d1fe0698c1ccdf03ee348601a2aacb6d9fb8d1ec4488356f52771cbeb9e395bf59fe7fa6a4aa5a6e58a51c72c7f5c341357a9db0728e3648aea8aff9eab23a274b1f6e69911e7aa97d652a78bbe810b08b5983d479c7345676f38516499dd6d92fa6af53a1c6402b50fdb5fd881d4031dfb39ac74868517842da75e669421bb360e39776118f28b828341f44269c1377d2c665500d56ebe124d59e738cf0f11b8e330c5696b1e2f755fb7133cabf773b723084f5266145137aed0c07583ac88a94b7ecf45048cf7f0cc6400d6500f8d1c80098e5128f50166a2bc36ff3ab1df241dbba3375906eccbc246d85d33619f559dc09eb2c07355c3b52a5ac3d42a75b6c20146c065c4f36b78ec3f17879de889db1f93924338b1fe134d07ae9abf215b39ec5349e451e1dbf8401c32ec1bb59b3b3702d2f1ebd71ce525664d5086b876f08ed9d488350f9e991c0ee0c008eeec93206ae6ae3930b802e3d0660e46c3d3e0576941543d0f8c2c97b2ff77e5b26cad24bc86b3affade7155d3a87783ab1d6469e94fd76d209336630888d78975e0a1b8302a17ccfe9fac1c9d09d4328cbff8694c7083cf6ae15f71c434181f83007b8e5df19f7e3006d3d510b1540d43c688791925194f290629c5ecbffded0f7cbfe029e317ec355d1c0b40a87e5354616f67ebf49b61689c70c55aaa769ef2e4e7c5786df3492e6b94243e97cd2e37eb1d5ce75aa8dadba96fcf78ed1b4e546cc17f45f26e5292f03a9a4b96fecb40fcf55e7e4beef3214325e2b26ae05d86fe116bcd04b66d1e59a5fc587148db513f44b3b7a5389c9c49729041731c6a862ca5fb1d1a417b1438fd382494144e7d21dfb5efc08825a1faaee148479928c2eef92458e6a295068fa08a54043d12deff94ee3e12a63305675a42f8cc77c57f3f2012fac3a8fd7077c77acfe347498e6d27e847195a2c0955673a1b3bdf8c83cd66a02957c4c60404f22720a40eda6538e70b1801f60a1be1e8b1da84068708da083dc539cab320dea4f606ae364ee1687710f2e05fc7842a2d98fef39375010394bf8ebb34dc0af6931a6038c977150193b0081c3352f724f96565b4b6551f44125320a8c0af96d72ab2be3aff131b43f37f9c888d33a02b66e116635dee46f69d8f8639308e93dae01f037b3a0b56a654651fed2c870babd95ce2bf2025668954a3326d6d5362b19b4db831af798955fde2b4adb75bb9b1736445d6263351680f6d9a96031b0687f2a882921bd25f599b04d21a2504e0e4184b377f4f4a544bb8c11d7e1468616f799b940f39b560881df94a613dfc75ef08d32a4a3ef2447381a942165ab02a50a1c9ab1a8fb01257439bb513105ad18207bbdb9288455ed922c6249de191838717018ce11b3e9c9a4605f23b0b41148c8c64ffe333dc004919ecf2c8d7a8d60a09d5f34de95c5ebbc35af313863c4dd0c048537a5a697e6508edc4c325110c7e99f411ac7b45d6d253911dc284463d12c172caca14778b07b4c7685608e18095aab436f0898a26cc8b7e42bc18e6e9e1eb2f63729e75e18fbfe491094691cb0fcc714c4fb5cfd79a794996428ebf7e0e7a323455355a3324fe83789ac4c00f570600d52a421d3c503fa4bdde02f5c3f1b4d12fe2e4fd4033a12cdfece0cd7c192bd37094cc7caa135783c6e594b8995498c32ba31f82930867e86e171ce914e2b40190166b6da2e4d2d07420325a0dcedc3d3fa4b601df9a8578d9afe077ab7999e0b5c4563dc806795c684d7a1e108eb48146bac3f7ea9cad7f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
