<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e814405f9ec5d89087db6a0b39c4be7986d035eab1de87402c5d3297fc69ab7085dd89fd115b143704533512793999c349f081ad8680db3b35b407330416cac8ac13db0ce5c5a1d7188fec1f432d50b524b426e5e9ae2c69b4b53e06a6b513dde45e9eed437db47dd989904a62d78da9fcd4d9f6932b1ab2589f7b19d3f6fb2b7ccf5b688fab014115c4b2d1f8a71a3462ff6ff14d2b510568f403f960ffc3269b2078a10079ecbbfb9d6397b1f544c7477d21f332808eb9854f248df82e29c8a2a64df56942d40c4da918f1d0f72728d1de8f85cec8c916e77445f5b011c400fb0885601bbca5b7dd236d54e066456678e95de3cac0406505e61ddf5d15aa29c0639cf877009ee0ac08c8f00e33c499d9b1ceb74ed9769985858292f9a198f4fbce59e91659c6c09a9554beb9f973904fb3d7b860d3b0074f364384121fc48bd6438d1b32ce948a65c17636de6fa5111ae024100226e622b94e260701235c90e52e7db7fa4663c9fcf0c55195b9971930363276baf57c6c54ccd411a2d3fb1f2a1763b27b25d9e84463823fc436b0f5d593016c89412f333821a897beef1e5ea713446e1e0e440217e7ef68bf4851b89be50fcff787e8cedb22df2bc6eb26ee8d57ad89f05a68272152fd487e15ff3c4d0c8faa67ee610dc8fc4904da72f5664d8e238c8c247f723ba05f6aaded3d0482e553edccd4d916001bc8bc7e81157053ca36e81de867fc617f65a4e1108d53a0e2812beb92e7ba13e6f3ef847bf65d9605b5ead88c41aff7b32cb7e59bec597d5c216e788735756bfde7b51327441d6eb523ff0ffd92233fc8dd0ca26c730545f59c533183bd4d49c66cf279240cf866665840c98fc23cad27b6698ee6cc748ecea9650de1ba9c73cd8b4e6d8768e007174027d76569561cebeba32c25abeb97d961b2200de9f08dc4cd01931eebcbdfb0bbdaace3a06be08abea6b5c7f1e03b3054d4607020bae4f361aa3ab309aee2e3cd1b042a3a78c12926a8a9a52722c45d5d0e67bc44443ca1bf9f177f9130c706cbbea5d05f0f71bbee6f3570f30bc5bf6fbb03be4b1c5ac0e181997897faae3305bb0fe157a0c8e83e0c8711272380da0d38a8a051787f7be1ba695010619ae7b4738a9e5275a3f32114f3c2d2b3c43d69871302801f0cf75279b65c3aaa0f6116bc73a09eef09ca3cd15d4aed673beec128861078ee71161b8c3051d3a908c88d12c3258af61b378d4b0117fa1680ae60d06e048bfa343fdddaa8ecd5d18e2170b73eb3c0627cbe69f91ad0fcf6d264091158860ef2cd4714d6bf7eea5e78fb18ec021a2186a8146fde3ac7646ca301170b29ca921e1a4d347a537d7947e36c31b220004d919d144b08b95b1f57ebb99544809a3b93722e73114bcaf7eb7f494ac36ec1b951d4430ed220ecd50286404e29ccab000a5d0becd5e943f82ed06726d248a41dac1863e1a463b00ba9730f20a37a3163adbc2978bbf1295c98aa6ffd53726cc46954b13627dcce5d5367515a94739fc6f4f670e28b6d50cd57ff91a652b9abcbd42f22909be4f13f6c5653710d5a73e8b33e775b815b91b62c9235ca53098dc83f651bb878bd61dcef427a1774c5b26b5db8b9720429576434bf4c249d05b39c70f54909391410259548c96b0226733433821cad5d34500f39121f2c8a49b43d2ddb6b7b1df15d43272027382ff4ecb772b977ae39db6e78c4c90c90f4a7e0f60641bec84cb48d2237ad4b451cd0d56ca5f535bd4aa7de0af01e215274426239cf09ba985080a1581158a0d827db0e006d8eecb463ac8f2ee468a20171e61e42941bb525bc6326b4bcfec6a767621bd5d40880f144a2ac2a45be5c597bec8d0ed63fd6a58206fed3e6d663bc3eb4c70b5e9539f49a66b10a86b6384066ca40c01c95d04f813fbae7d9d7b7078ef50d8cf1570501f03fe82161e421cfa173245a735b9c07025ab746cf7865da9fbcbe4240fcb03ca83507b62c9191522676c152e99305107a56985009d4da8b5972d3632071a631997e5f8029d04a60603f0d712dae13688b03f1adb30eae56162c3036469efcf89eff09cf856679859515de878758653c86b837193732d4194cc49a87c22b3a3f54f7039a1228618336a59ebf0d226ff5a3a8164a4e35281e412bdeec7300a31b4bfd97bb595765eec60556023f26401a89c9b40b3c5d07a93ed5bcbbbe1d7e37ba1ec43175ba30d81e074b9f8d6b32d6615b551edcfeef308f5d99f857c7b761b2b228828dd2553cf68862f183061e88d6c7dd0bbf7c9ef5cb9b0810874b77ea5cc867d3ccbe8c9ea00f374d2dcdf0d281d3e0c3a013d9d7c62d91b87e054eb2723cc1665be196c3400c6c7a76bf294d37fb7b219126b62e48549e9417a72f1b780d2066a0faabbb7331a8af986085c02a6578b17ed7236d58c245e122c240e7579cdc2b0b50d0f859cf2d4c7d18964a3a89f9624ee31b51ad8bd60f0d54bcfb10eeab3fb59256ccc6f79bb653c10602fc52b08b3cb5661ffe053501310f0ed6bc7ef613c148793963b7d81b9a02a7ed648f70d8302cbfbdac4456912f181e5296141138704b0c5308507ff8f6c7d5d5f0886001464425bb3ca4c11019b3d7110fa6cbd4b15b28d8b27f9b07d6ca33fead9260ff4cb8d8ebea9c19f2b192690aba86ac8c72d3000f3d8e32e6be33007a33cb5210cf0b76bdb2edefe2b4b629c0bc41e2ed7afc3ce93720e6adb24deb3a5b3d7b564cfb24aaa4bca85832e83be73372cd3ad8ba4cd8c1f931b1591b3b909fa000894af2f68210914bff6acbae9b53f2ef2ef6fc3796aa9fe52c45e2ad50c4c39bb48de3e72fe48ab67dca99ebeafa522a1f4248f7a874c3ab86ecacfdfcd89a9285e36988decb46c4c26814b2996d1cf5e4623a693802795616fc85dacd33d53eb2512adad3eef35c128909d895714151f3caa7ea6d30db7e26246baa275eda8df978b89ffb4485dc7a8ed9694d3b8962893fa9743b9a26e01ca750d18acb195a040360f96994f2337c82313ee837a7c5721cb560bc93382e8be3192414a2613602a787db7c1da62511ffd32bfd350da219218b493a0c5631a47e61845a18ca16ba4ad6ecc3a48a2cd93677caa54e7c9c3fab178f6caae31df08a6749b51c1ab3a9d8872f52c8687060bf1130a23a87876f732650784033b70ac277349ec793288af6f0f5479657321f4d77d89620a5d115d350d392e11b1045e29e36c99d04527da41609f1ec4ce012f9c64afc33fc8be1ca31112d2ab84073a8fe83020419d1ae2fbf9115bdde64805dd10f213eac531d54491f555ca9d925784587ef4101103dd9081698db6c840e1eb8585f7567351923d7e2e74869d9af3e0d57f59e36ef5937ad8556310d5453afe75bddd6efc3316f9dc3511816abab5983480f2c1d03645d54c5ddfbb9032d1ab6920ca721a758ba35f0b7bf4bbaccf51cd00cc95dd84b7fe0350c6fcacd386d233a662c6673eb59b646c24faa422e78f949e19c49bfd3ab3813ca0c7a74490baa539775e27ff5c4bae12aaac42df39dd8f228e86c369e7dd7e58b87916ff928a90bfc3362e26d2210a20bd3bfcb25ddfd66f79cb942619b6af67ed7e8903baebe5c0813cf62ec0d108b75022fa3222d5f002a43ac7aff22b5836e9802c4ecda9657d1fff785b4fb3d689fc21dec3da41ab6696fb7ece8a8834ca7ae54b8a92f4375f68f2c3c0db57a076c0236d99b9fddd17d22f2a0b12d1171b77177b2cd87e3c2f0fddf1812571d0001f048a6bc6e0a778aeea03ebaf2b54587757b176c66bfde6273ac58c7bc5cf5b0205612f23a9cfbe6449ab24fcc61a44b6aefa65aa5dfbe661440fb90c15de1902cb61421a9fe0d26d18323d4860d0f62d30555adfb65255d47cef8ef414b2519bfd1f98069659448a3d2e703db39ae7038216f34c690302092ca6cb2922fc2d90689fc0ea7511d8e1b89b8f0ef2bdd7c317aeb56cf2117799868b43908597eb340bf826bb794df8bf1347e90f94db7aeb5997d9ad48d2218052d53422c919703458579c15342d6b5a6dcbd5223108878e65c52afdeccd8391b1352b42d702bc6ecf73827982412517ea5dd99ae6314ceda2b3417d3173a9d6638bfcba3e549c89474948e9b973e567d0485d8ba3a66db60cad8a2bd693c59fd95014983495c54cc368c4eb7b421851c4b8ac4609183a67ff46262d3dd74499fdb3b8b3dfc1497dc63289a2b0738c472f7024c78da6b052790155632b1eab173f2f04bd125862901092e87f8984f08d3b721324933868a35ac451574febda87496cb6ab05743072a1c6659b33550ba4e40dc503bf00fa0e3749d245b1e31126b49563fa7c0f5ed928487d20bf4bba61e7d7b50a8219ef323a2e1a16c814cdb4808adad5683842dede70abb26c3001b9f2c9af36a17e668ed2e0bdaccf3b1dd57895fbf787a007552f289ed3e06cc3c03852e35a0c3b63854f1fe778d011f611c5d48fe90ad882ae0bf1e5192a0dcec992ead48c2a5796b04c0e2c1ced5704c0880c57cce871b1e05c4e04e5d83386644a4461ef9c0fa1025ffc4602c7c70d81770b6fa48f87a767f1a75d823a07143096b507596ef7ce84b1bc3814153cc07675d7a8ab2892908027f6906c9562af89abedfc0961dce2b77bf594361d78cc3b792a82adfcdf1c39ff3217c421ae1e95080bccabf98b3fa5acfe6f87179e806cc7e69369110b182d67cff52a704e28fdaa03db937d722ce7ae68a4f0a263c620c84819d4528603180cc141b12d54a6241705ce951a26a9f0b32dfe217780974a691490505d3cd9cc2657a45f8972b5ff3923b6deb077a232a39dc6002362b68f699d0a752dcc726aaa12cbdd509289b4203c72b14d59e1797e55b0876fdab65a21d10845bb4997b3c274994ab697bc4f507a8b98ea601fae3c5d050660455f8de268d1a7b58a6d9387b3f2a97d65613dce49c618e5d4d1ce60d6830fc84095f9e8769264a47892b276c7707be23e990c77650113863090f5c9f51f2765b9854521e187877e6fc6bbc564585a9054ef302cd2d0968984bff8dfe4949316c7c39c8b6df616b33cc513eef5ff3f6911e3eac8feba71bf3145e7c1e336cb614bb74df4544c3dcf05af12267ddaab46f99d9acf9b56f0702493bd70bdf270303c72adf46c460feb98386adb346f104dad06daac173cdb32ebfd03f9407ff2805d5bfaaeea2dc88dd6afcd417ea1cc275f3740485163e16a232b03b1e398fdb5c9883a4bb551c4006210d04d98d3626e5ef2dc951e2701362ee92fa611713889001a82811e4b7135f664911369e5f72fe3c01d2ed55d7cdedcc368d42bb504eb5d895e90668cee719cb2b9949164374f1cc175576c8409766083d0e9841dec21b8f041b6b512385494a18f490347072ace2a25a5b9804593003c3e7bfa5e4acaf9c5e1ab3dc56f38667d09ae717c9976ddbfcbc63b6651003631d5ad1a20298cc46250d63350a84803dce2ee98900139c17ddb484228b02bd6315d6c32cf778cc40e59ef5651d61fd5c2653cb7d7d395d45f5f762f4fd3880dd05d6db9f9883e34ea094027b8e92b0ef08a0d5eb3e079ead46a3462b036acbd003f6c1bfe90b736feccb9524c1a1f4d2f19a3d96c5bf61edb7872eef3247904996a9e10f1023b155877c008d9157472b7969367a0d8cc9beb203848fc3a908ce906ed42c53d2f166de435c1b76d44979642614bc926c8a4212b523ad498cc2c5aba4465985db67d3928911e465337a78a3c9a0c259a625010391c6f8b0a091b45143317ab53bde4db68da835167a9e983ee6e897368c17eb723a0617f334b69f871c6220031e16a1cdf7d9f4c9793d1147418a41a226166e9ffe98876c9bef6842f532feaf70d6655c0f3d5181f9ed59f1245a9559d76de3fa8f4feef4facfa16268e9d1aa4aa298ec37fcc776330a9b4c42d60828d40fefccce38d05d6338b42f79707f2cd4770657f5be603507cbf9f0771826aa04ecffd29f4cd1429ba2a7bd14aa24ec4347c95f08c3ccfc9fe7c7d94fbc59d0b8c13406594a7a4bfd9ad4edf2eb225adbe2cd6a6dd204723e0a645e69e902b11a8f36a1df38810e1def6209606b1e6c7f2049227bebf66112af3c663b4dd7e45e203d8aae242bab99a0ddbcdf54bc202c51beedfec08b4fcbd49927652fb38fc103ad3309fd00b2b634dac97a78deed589992c54dceb7bd6e85e47695b65e0a5cb82e7e177a0fb54f716cd80445739a145f0e4b7f1c688ce93bfbcdd7b07316e30ce2817843ad6dc392eab89caa26ec3d3d54e985ce4f063b4fec9a80e4320f700060c2de05427429964913c32cf13aea0c3083611d1f40c1931d4dfe8f57972d721350187b0d1415c77fe3e06de147c8bb215871094c838590b30eb606b922bbba3454074320c02d4554e4c81b3c7a7a98dcc3a55ad1759265f7743e970ec1663ef35a71963af50a2ead8329c730ada9e346be339a01830e59b5a3662e0bde5108127e8c2bd64b163438b62c515255924bf60fb3ad67f02aa033960d1782a507af69f233fbf258989ea819adbd7dcd450d4665e81e42e086ea329ff8be6881d49614ec8d8c3e621e538bd6358196e255589d0cc8b00420861cff11792e7124550c7897aa1719918415b8c47eed23b2bbd97c873e671f90e38530472d76e7d39ee8ed1fbcd4432fa4d6a0cb96add79b30f8b37797b89f0abb78d5e9c4110db66653cee345daa2828c8b114ebfbee1a4f07df260d49b4dab70e5f4613358da1db89d7aaafb2b2c28c8729bbd7fec4486879b88046a815e0c1200034e23a9bb0feb53fb8790fd66565eb35c2af23dc1694c1880ae178641cfc46f17aa557c1cb9f4bc17c6b35f0f677ca384d7afa56bbc13043a18aef59798d0da9967493c15c7e3fcb316c6728b04197f6b313b76fc1349641c8cd261bac7da5efa177997c8ee165cf4e4cb9d95fea57963e090b2c365179d96e61b7eb94314385afad01a7f2ff51ca6be26d1fc456e4620e8a29fede1f3001280613f30b105945cdcf56bbbd419389612a79e2224593b0a69c4ebea5f8750ef7438de0711074fb2a9180e1ce2831bd8cf2aa1cc9f7a8012d29db0411db663ad1bf935fcb44a27423ecaffc2d25090273e61c1e6684dac2e8ba19a9fe78d48d8845944a548c6d0ada21d743acaa61222f781824dfc4921134d973525ea91b50f7ecee9abe92db254041058b46fb827e2215cba47d613f2163f36115142fe106fbbdb9e406f372ba2f1873db0b7bab23cf668ad10439aca43f0f6a2cc7b6b20fe08fd7cc4420dbddef0e4869538da226ad5848176c9c86a65c7bc414f3eff2d09487c82797702ab2ca1981d7aa604d5bfe8c835661356f2830d91c0cd3a0dfab91b6b82358ed93406defc72383df5cd2d3d417b67b372e09203693dd1ff4231d21c9a2600ffc200ddcd5456caaa0b3224b5fec615840f42c04e123e329bdc07687e2988317f838060afe134ada2107bfe4bc88380537ff6fe7b437c5ee5c1eec56f2069b94f17ba4c0230bf7eebd00360018f58dc8e97f7a3f3153ef3cbba4ac2cc0f6c00dcacb671bda11d20d9a5e1f4c4775c3e74eabfc72d1180ceddffab14819429888a0685534db45dd85cb8dd010067e371e4f5774baea34552af5fd3bfa5b8165c94e982bd2b719349f4e02418240e2149cd29a4633783535a5f4d96dd78ce0eee31d40b1c54b226b67c76d91b96060e9a1a614b0a62385fcd0787e57ab741666eaa187e047a653ecb45e89a1f63749b29962f39a97c8029d0a245ecfa74c6e3fafe38c848f2231a08be0f8f4fde0c291b19ce83eaebd15f54c7167050a829f1b36b83e8ea6e93ad2377f7fb17d1aa68977ec40eae6a8d050084ccb84a5e12399fd53a4d9df6f4052c85f77bb6c9bea5694e9f6af8820c0dbdd0eb27439d6eba2d0a0a4ae3583bf6ded54e72c95fbf543eb4caa68c5da2d74a9620fffabef5516b78c211a0aac3487ed511d5d6cd654d4fc40e407196a486f90e19a554cee93b412fc0f47d802026226921bf16a2da9a1ab95f7c988951b3b63e3f50566972a719152f622681a5f372e32ec95d87cf5793cb896f8879cfb07e7496fa112910cc437be2b2f25bff4caba10a342575d3829d442c7fa3c4640a250223d64039643d950801c595ca5e1097d06309b2278f04c2ab3e112f1ea6537d2b01b07c66cad189e0227549ea0870a1fb216c98be651a80b53bf346d26fe28dc590c98f390a1868c4db6763708bbce7e2c1870afb18562cc735db1079dd212383416391d390563821e50cd607d6710d4442beeeeb007338b964eafb9ebfc0a94b46fa6023594cc9b83e3f5f242ed3af37aa423dafd2194f8e0142262c41c9dc6c1e498c7e7b82eab6b273f2545f76aa349668020473fd781ff4c92052c346028eef53fcbda3a30a5e87f26ff8f4f1b80cca6e22fc0ec0d797894ff26014e3117cfc8dae74747b0feb0aac9315252c9bf7f4ecd21bf0cccbda9d1a8997347734e77cfa86cd17725d15be578d79a671f88a2a2039b9528ddc858db15ebe2d5146cd4de9af4e77f20505ceaa39dcf53224cee5ecfbbc4a31df6397ceab64dad8eae474ed7e8aaf8b544e981a5c57fdd953814949445fc9e8f306fb8374293ecbb424dc0973aa0134da69d6f03c27db280d73df3bf8d88440444f69f64fc6beec5514aeb4e159ceda6882639bd8726690cb6aa167e75ead5048d9ed8f6c047482e927ef664f86b55a5a7e2d9227fdd858746c8e7ea3a51e5c1746a5f44cb95b89b9d5a1d91fbc0b6b5d783a364d02b574172b22c91915f6997a954bd7b77d3b67dbb1605403c55d4c3d54fb8c74dd81276e7e3f69cb5e188e58938a183bfb7fa896df81a976762c4fe52354ebe59413825f5ef4f434648b6d513a86b83675b84ece1a8bd35cea89479488b477cdd8c7393fc86493379d7a80cafc7671a8f765158bed45ac594d81dc093c5cd7ade8e4fd5da1d1d9ab339ac96dcfd995e1ce9e83bd14c0a3be47296eadd8cf9207e67231ed9322373f09a1b6a471fcab9038a5bcc7b96a3f01fb135a5931af4591e163212299c752ea66514b87572ea0bb48077e9505929adc2681eca39af8ab10982619672e44508ec01c5f0c2dc246eb3d72084386917dd225c64bde66e6269fb9df55a2e7164f8087c7d615904d89b92786b12202db9a7198c4df6d9120f793ccdbad09e5c0d85a785933cd55dd24bf9a3e9b7208b5c2ed2eb2353b1f26eb7309204258678d6440c871408006bdfead4aa5ad3ca6f14782429e14ef4f15dfdecd86996fe819581372232168baf7194ae3a393956a984d543b872077f460849f9a93ce195d568b63037cc523bea686bf3749673ea44a49ed603e0b17857bd59f1b45ba611cce8a8a6189bace1f477f7dc8977f847428aeb22627d6a4a009444666576d34bba364a6845812ed1c50e2bfd56838be9694b822fa5c99555d147a2639ed368c725e41eacbe5def385234407bdfa83b508a1ce9b1798c164a00cbc806e2e7dbab7a0a1d9e76ff7f2cea7380aecd8a7731b3b3d75a576b219518da46383c4ed7db4a0c863f2376e541c8e771a0f394c243e0c61f573a457794ccf1abef6ce0d6f453942bf280267b9d161628991d410e3eb5b2f559bb65190fb1df0e6dfb630ab19b02f29f26d93729b19e0c9ce46668b90eec0cc3f76a646711aba894ca51f1c998272839d4b2a5c7551d74194418d9de98e5dab51bcfe32331427b295f93ac217f8c6fe24ca635b6341147a16cd7791c57e8fdeb6a9952607d44815175148908a6ffdd76e0635e2600e63927771010072a933e16473bd49ca6a66cb738a6328be1ede16b4e558de1b99f9fc563be04af95d7abb5f35e193a5e2020393e2e3e214634c7025025a7e3d850ad8b2df639f03cc66618b1fc0608f56d48a2e39ec978da4fbdd38965263b6ab2e6a7e12dce43dc0387ce5d1a48ed06a06b3e2470a48cad8ae710ff77e45f8e1a935afde577e771f3ae99dff0b9a4208a17211d47b8031072629740e902fcd1a73aad845a163084b98f2cc87e30e6bbf26507a5dc9aff72bfcb4631d10252a74401733ec4917563f5073ac57f9df06f56b73f51932bb9c1ea45a14fefb9a91ec9d41a08a6cc08a22e235ffca3a11544af52ef23516f56b2c892f49182460eabfc26c714026c1203cc753d419df46d3de466ebf833d13a43c9265cdb7452ee0696bc98b0b7c7b14f52ed5b250f0cd1e97554c1655b885f87abfe3823b12c360c055c7986dcb9012dd9d29aa2ad254b5496b7b8698f26bdff7d13afe4bd9afc8b68449ba17507b885da90c26e53bce4a208e4cde3d3462f1dcdf061e215991b139d3cfc5f959881a320a9b2763860eb7809fd4a4dc63da0b9cba9d9bc1f9329f29d0251bcfd13bef7920340e5cff00c1b789d67dededa1dced8e8f7331401651571baf93efb1101e2d2fd593ef9f0ab0515e4131108e062eebd316c4c072d9c1cb032afe5129e36b43f679ec14c0b15b00cbefd8cd62f6dde7d7e4d71aedda2b409ca00f5a1bb58e969c2a8fd2eb016c483ff280ac5ef8ea613f66eda963ba4794d6b6826eb7963d499416c75b0abcaa2315cd884cafccac40c4bc1bd032a42c9b5edf2c10e1af95319f6099af90e93645c61bb24be243a32d87e9aca1452433e68fd45c2b55d6a289aed3c0bee52bebe8fa461b13dcb6c665f594ba9487bc1d29a87740dadd8dfe18c04bd0b50dd00118879b6d01f2106a3513c63504ba2ef129a921c1b0084cb4ba545b5558f2914d53413b6c9b13380e980233ed487f332cc9130fe990fb08b22950c7ce2c4e3e91329c97230f6366ee629c8991baa3011353cab84ff30e2bd5a02886153573f7e55f1164060e9ce5ffa73b4fdd28caae30d2d3cbc90b322d99b3890502f3228757f9cfd4ac7cf0635095d94df90d19043a7d9566fa593b156fbb2f99739ea03f93a883c9aecb24bf9de73734c515f41b236ac1047be35a57baee81ebd708fb0eda0e478ef143a341a3381042236db8df200288ab9bc70a475a9115df5ea0d65d58b41a0ed9c08f5f186a9cdf0d9e190fa7b9aeb9f330d6f7f7d0e82921b61ebe2351d7d70423662581451f3cf1d26b1b31839dd06bc3d0946c1d20b95e5fc33cf9cd81a03ae1cfa3f317ebefc904acfcc181decfe6811f4a36bbd4e39052339fd30e37e5f4c0ab713127b66c13e4a8d0c5fab19aea885983c8c37342f9c89916be504bd0e12af0d127417f49ef4befada0ddf72ebb5b56364fe37579967cec14dcb7c8cd0c245b875db253c557cbabee3c072e8448b81bb2735ebf50dd286428a89ae5c4fe58d0d921c0ed5bfa0037f569574ff09bcc9682853c91c2835f1f193de5097fe730894b5497e0855d2f90698df53ca3f8cef221d33fa67aed6d6f1b8ca391945e3ab19d6e6849b629000854a5469a70e07d65aee8ee8f9d671bdfcf0400ed139181bc82437144faee7e693d2b995aef39072623ae6000c31eb5c80f1bddf6ec24826b27513d1ffe51e23c902b23f6df7aa06a3d4532efeaf1f8efc03eecdc97e29396d66d5b23dceb6858bfda42ee0420973525645038e5a712c2c3870fc2c1ea49ea8375147b498e6194dbf7e97d2a669ccc18654fc35703155083fe1c248801815c4b83c546328488bd35fa7c786f80754cb2fdea3be3f2063826dbe93b03f793e19d1f3634f10e5bd891bf3afe552df65b7545e5adc70b20780c4ce627f5c88ff7b6b55afc16567f0dea7ccc382945ea81a28630333285a05fc98273082f27e6219d9e5866344afac489e6970c102eceefb05762564933e24f7563d25009e364a0aaf346651477459ebb7204dbda13b82fbad7bc0704f64862d4360c1945e30848c05553c1e945093c03ece5094719ef0275047c50c5fabf5cafeaea834a117c9c2a2e32b4f9ee245ecb53a1450af9e83427fcd8ca522d2884f96774b8959cd06d1ded693a0f62aee646063f338d4d9c1694b097a65fc1aeba0524f49ff2fc964c886ae299578ff554da7717ef5ef419b66bce3f75b2cfb902ba665e7ecbdcf0ca89c7f64ae3a3728e7a6c04a35efc00528d8af5ec30e0c8020974719889302fbe1686fc8ede5032aa40f56aa297bedb4db79dc182bf91d213069bf0c15b3d9358cb10f0f05b9b88bb31a3e46ebd2c4e8401c487585ebc766e1d56b50cee584a61d8a9c35fd7dfd2c107b407db5e8162ab1439dffe32271d266f1848de560a73f38611db38f986f8e337b5a1e8aec922e0bcc594e0f75826df1377d559b7c833fc5e3e9ba286cd4a183b5352a289ac9e18c89198fefe55d5245068ea343c7fd50a364b4a2837e99aadd92ca7a44ffb7d9315ae403b5b4347414986027d12da0a6948198a16f8e9773ecd8066b61a7d40319a6391b801f19523097c1e0214f98fcaaa736b8ef82823be18d8f8cc2216b2fc4f0f94a6c18140fdd4149049e225040807cfa13d52308c794b11b59e3b48a1d39bb60f6e9e39f4629a8d65ade2d810d6006ac1c2a88b28812733053d5109c8f5cd3120c4370d4a273053c34a7ca4365d8d15deb78746df7cd90b6371cf2284c554ef4d5e20e880c9c2d4853fc416313c5f22c7aa11808c64daf05191127243754251281bfb03308da10a9d72b8d1272d1b737ce38256a6eba6d74d3bd02b307e6f947a055cf5c1a27a952bd8853f4fe6fdb1e5a6aa8524d081647bc6e52be19d30b6a4bcdd058da70b6c7f8359dfe2c944e0e4e4b0fa303811c05c3243816b51b9cadb951df1a5d8b0124137ad7c7f0f17bc33e10ba28add8cd0c6a81456a5b84d329705acae9fe7ced74fc55f2a0b8293a40ca817b7d01ca7bbfeea5bb6e8e4f27732d15ede23d631bc4cf655fa5d9bba29516a97d9eb75185f29690f77c3fdec0b103c2d825ccef728740899e7ff472411058daf4b81ee3d5e1357671ae79e4fd9b6bfd2a80c2b46c8edf479dd65fec34cae6c54ce4f7672a4df35b220ca18d3e2e1d111e9145cfaaf07c164c270653c257f84d7a8cbb0685ecd34a39f38830096473859e8a9469df87e68a7c5168cccc0a9630e0d9c2a8bf2d724d5b572049cccf9aef438a71d98aedb95a49845a25b111ed976e5b79d104be566c9dc277e670660547fbfeded83f2c7f8f2bd53741089ce552bf2719d43f690e4cb32fe47265d7dbdfc905efd144c3024c36335446018efb473bf25600806cd5894b92efa672789a2443dc8f47ebf5f231831c47851e04812c237fff3e93cfce7c623650e23ed76dd16d4e046e564407af48f92595889dd5a67e15e2e24083cda65762be430f15f9bc5e78b140b57ba334f4ccccf14aa4b796bc978964fa6b84fedd26292284dedf60ceadd8b15ddf7ea11986ad348ebdb840046f45742220672a08fa9023b2a9dbbdb9ff46315ed2fa892b1cc19989ad483d9ea96a32f85af02b72fed8a52de8a4069557e07fa4f65370739c092e51d180bf2df0a3369982dc64ffaa81138d583d028dfcecbc0049f63dbf1581a1a50fd7a8f437809674fb1c54170ea6e99a750ca3abf6ca16adfe135e4839035a9c9495123c8ade4c7a6b3a5736a89eced44262bfe33f760269369170bcfe0ac697a396fba22b6fabe0121b059502d176f639b8b2c742311a2568a03c1c41df32952a7f4e2bea8e427a008c3ad38023699fb180dcb142b07a2c8a684a142559a381e4527a5f1321c8216b255792fb6b6edaeff2bb9519d8b909ad545ebac660a71ebcdb16003506607db015fcfd95a73be37fdf8a1e0a01df23a781dd8a4988e10b097571f2749dd8f012f7b45d4c2d55df61b24f8dff732f06f22a4499d5bfa98328c95b176257e82949d5ab3b73e5e535c770794cc421c580bee872124e39ceccc5fcba8f6e25828d44b960caa849704fbeabf9c3a27509108ffc6891b43e7f7474042f8f3bfb9beb88cfcfc530901bd53439d5972a36c39de955fbceba1a1517df5cd41e53327422dd03684985c54aadcbc0b6781bb13b8f0d46b08a5bff4c0e869553f7015ac55a098f371ab49892074d42332aaa7f6618ba1b6172c44be95f991fd98f365916db7f28a9f84800a4ea54c31f52568be9a7f98599bdb6b98aaca66ee6544798044506ff2586b2963dffacd5b9848aa1839c998238264eb5bcc7cc157c4ce4d565080727da5095d43bbb04397f06c84b1f1ee47f3fbca2e84e121f70cc847b2d9b81677897cd673480c91ff5676b665d6970dd525af931d7da692d8a1ff3a73301df4857854702964536c6dc37be036ccdbb08cc41da1482d579e0e374db2ba719c25dce77e528bbb9de399b8f1233a80589d9ef131d2025e79ae77b69edc7b9f160824f3c72b3217457905c0f1dec1a32c22c428777856d3d7d03c534bc407704405feeb9e7f89d0b970402c597a1b93abe228d449a9be0135cb297e02b1fdaa90804e21188ac6782298f907aa09a7152b38dd9a03dc1eb898f3bc63e27dc5d414c7d3768c362e368d361e111e92acc7f9649756f37d2a64b711243245941120cee4dbb6aab4949452440131b3c805e6f3730692e5e605a425065735852fef6de35456087dbf5dd7fb70e016adaa5b9fa4057029ad65ee7791470ab336bfca591e5d8cfa16ccbeeb771ef6a61d6d43b4b83b5c39603f1f5ae1d0f73dda127881fa947a8106856453542b2433935d1906f811bd00149c0ee1da146ae6725b94ff84ac073b8bff99ae2df6fb2118e1276e184d5c5bfc8ae72c9bece98652d0f345133683448af234adccb17aad8473b175e81ab183bb53a45141b36a4d6c66ce747c089d42564e576317a15e65050c2a10d70ae351e3a6f8decb4f321beefaa58e6ed8980e89ebc7256724a4d28b3aa1ba7d0787def1ee082d0c8f9088c52f83c7a4af57f7a47c4ead941a2018814d7aca736991a09acb4ade1c1a81ebe3e86b26ea7a57402225188d77a4a79ffef9d115936813beba99a8c19316de8b24f6f73699db5abbb2a568697eab19ee08711b98681327cd60654d73571e71241db4d29538c764b55e3dce43640e015810c43e7045e6f6f638ba75334dcc9a25f6262898984355154361a61aebe6f0ce333f26ff3bccf7d482137838e8bf684bc7392913fdc26e317c1d5826fe8a342bfc02c58738138cc5d844b7de9b34a2158c89a2b3c4cfac20b5c5db8d963ee83b754e245de260a35b66c292bc1f4bfbc26b81ea0b51fcd3abb1a103b0a04154d659d0380f761d8d330f12c5ccfaa6f124bb6e3742eaa3a5de300c349d62e7b9e55641005e8e308cc4b9a4dfacd5b927dc4e0734200fe76bc743088ef07349d02188a6995419af9d35d1466e127463e30861cf7d64a42b7c0af42d67224e11092f897a303e220abd7e1a92f6580151f8c08ff9d2e9631a563c15c3699a3e573357ab43b282b238cb66e25511307ad5c441237a7d52412765914da49cacbdd4422f46213a52a62744e9173ac844d7f9c4f62d53f703db7d8eacc053f254a3dfd78bc5fc1a1e252f03242ad3ac6c6ead221a8088a5c426b8fc0eb6b05eb48d6a34dc28a64e8a401d3da46728ce5bb7ac9d87d2f1bc2f9d7b272ba58f21368561150e75c8f557b56c7dfb0e9ee9802a0b498814cb94ac011556d83021a589b19d79fb5a602ba809123d2d6af8fcf8207d73b1e62fc8cebd916595641a954b1ad0d89d735c27e4006fa04ae30355e75895025ef1c3cabbbafa154f01755e465bcbfdc2abc798c578e0b175a37b432bd6f063b7c96e375bc55c27103624256b04eb423c569a182b081fc35956c41fab59d6d8c344006eebfb92b02615a68563b380f0e82827ae8be6965e3ec3bed702a70068bc81c7554b045ab6542c4f94016dd09a856fa4f118cdf4c6e927a897aea37048b847a80f0ea754b0a777ae3a939b026c1fdb379633ebcbb5c1650c532050b824bceea069389579e70d845b0c5de196ef692c6af8192429db9aabadf7f300fdcc3811eaf3592225e4976312cd4aa664fc72cbad4a6efea4f040d31d2682d80c890e4e6b4ccd79e2812027394b0a434a74060980b329de24dc608de26779657ebfeea2fbb6a48ad760ab4b2884b8e0a93a96e43d06e7bd35cf03f818879aa1c613917093ff064c4552e0dcc5ef14f79b291efa67c9ca49fb530f44e7844be2a9c7865e688314298958424d2e16929f8fd04f3eca27394da0bcc3a1f00d12931a1505577ea5836945c13f842febf82c9437979eaff520db869da48db3eedbca22b2e02af938433564a11211f9f9afc9a3278e409b2327ac042823012f711a8efc0f4b2a30ec429515233e6f25b945feab3f5f4436f5104ff2b1858b27f9eb0a142a1a4f2b82cd1e3dbe662c8661da9b1f16b0520d54c6b396c0cd0808620d376546c817a0489a950b7271b9a42d3e886044bae8663c273583c4e87dddb023eec8e199330629c22e4619804ddc7e4a688fbd44c3af9fddf32f66af5062b956d904a9be55914ad7c46183b34073b20faded4cff7767cde0b86a972e1a5f8184644c164c3b0be601f6853a86ffcf5a2d8b4933dea753c96044b59a3a881151e12629d6d78acc43c486b5274475acaf43a5bee28d237880a6ed993d51e1e69025961de73406c52620c3b57921b9d360cd3ea0e350791300ec52c6860f0641807843c98e58d639afa41e62eb16dd5d7b75cc83afbf1c9eee87b40ef0b14aa77de75dd5f65a08fae78e0422781f9e9653632ee055fb81245a33c157cf306bd0e1f983a73e351334840b6160ad38952dced2b657db9d582e8223bc2e9e5040b797771b29f9f03316b451354fa1e7f2f03192a9de53cb4139e9cdd9e3bbe4a6e240b440b30d0ad4a6fac66f385ee510319dc76b2c46458efc7ec6df6bb058c7283536574ebbb51b10263b0b36c8c81f8bfd435139c37dadbe4a9db9065418431a2f11796d958666835bca440defef599a4787ea89db0051611f82ec0b740408fb0f1c55d64708b8807fe0271b040d9898137f56b377c3ad1e6f85d8d5e131ee020ea9726a973b288525628fae2d04216dbd33556d2c2f061a0677843eeb31c14ef7eeedf45ce10141c9515d6de11160f7af2ebbd6d89114f64e438b7b171359e55348c6f578ae0ebdb45666ae272d6c91f117626017b5af6fb759c279e66e4153f61e2f19b7c9ecf7a30f6c0404f450fad241c959583a54c5342fd7fcec60a17e0000e7711efb074ebfd265599f44a8317272aa66af23c70122668ace65d037d8cfd69a0b5b4274b7e2bb3017c268817562ce81a2a7bb5647348e7517b08a966d132340d5fd9fc8eda034af96714144b69c546d0a664d66196e50fc4ed3d7cf448443b163c41846a80897c876abeb4c73ac5fef9bfad2435c15330587dcaa9a2d82be7dcd34b3034a1b392711643841408588f6f74ff57be5ad3f446a2d2059e6ceb991188fb346946eae0aa7b309d1d87ebf73ee118e59d31b009a5aa798ba3a7830e1153d503016843e5e701912aa668286f3211202734f94a229cde0e20082a01a5f366d6480dbd374321253acbbb0515edb9b00d4f00942b2b2ccc124ef4444a43d1d75d5dfd065dfe8f0ee688a9ae05f0daff3a779c19562a73b72ce1c7d4a73ddedee6e8dd4f7aeb99dc1ff3fde16a6f30a7c587404070bcc6eb281ea11b7ae6910bc575718f50f2405ca89ebac5314619656ce78a9123a5f5b438658829602f6a5c11cc42702c15542da18f3c45e92597c9a2e92c225071ba7dcc3f4a915a11ce199b5b763a3166b0311805a5462576ddc28ec9ddc43a065772ec4d507c4da6f9ef76e29a3a188c22372ec04da27ad688d52d3ffef50305d6bf508db1df2bde64f55d76c1318dbdc3e623e0cf0adad8423e18a884a99690b163a048ddf3e18cba08e1e275eeaddd48f1e0969bcf6c173ad37b28fa1dc3c763dc3b4dfd89afcecc60190d85df445b390d696587db35dcf5284e7ac6f7acc221e34b20d4d5192758c7dc6cad005e7b55c44920e77f32d7e38f776c531b1dd95153bd7c297ea7272b6514a2b5ba7ecfddbccb29e004dd73f48983dbbbd1ce2298e72","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
