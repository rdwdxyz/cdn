<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a60c47c99704475d030404cdb25644c4fbf6a21e6ad710b9126e46811e6e98ac177c7ad2d2a9a25fc7453842e2b8d8f4b3234268d0f4c45c0e7e0a7350d78a9ed95138699d6ef34b8e3b9980ea64b78f1e5119ba8fdfc9c6397a3bc5fb6909c85643be007322fe2a95acc61272385ad5d601a2a543c6621838e8886811bbbe9bd212c4a81ba8395639be52d16c8299d51e72f2b4377aaf06a4fe874169f5d2d7671740b9f9fcb450c7389a8f7c5d935a0c4ce643fd1c86c4725bb26aa3f4750d659db5c7f534d07a2c5a275591d35f0c940ec855426bbb4aa5f9f472e5f58a72e3ed3763c31abb2d12781e962c13ae30c918ad8b98237754a72375c45fac0804d0bc0a9ab22ae4b783c7093c4a2b2fc61b5015af24cad2d6d5010cd05b1b546a754cbf369da2ea1c7f465faa3b9d0cb6c46070024f7e10c207428216ad5c37fd4c2dfc8b85dff04dea986a6955baa5740351c0e6cad96fa060a0ed79abfb4d4cb70e7cf9d7b464deb7f88a070808524753fcd2e9d25f67a2cdeba890587af06b744a56cb21011b27e6eb4aaa398a93a18c4809de4d4bde0ef08d073f808f1063dc5c572dab5920366e60d381e282a0b8235f81e9398b1af663e3d35647f39af47259f306dbf08141ee920ebb9f0605c9d631a3cf76fc05f56ecad753895e6e00c5eb43f81e73a336f3621c38ea181aca96c548d4d6fbb064f709d9de349ec3a9cf3ac7cc95287c6dec1386a6414a17463569ed8bbe4873b55bc11a7886ad35719157f6f5c35f93b8735bfaf02079019935b6eb15643db07790c5e6a42937388b3af6d24995a46efd6620a71a7879bb4c6b3da6c4bbf6d3cdfb00511f386ca89c2f0c229e7507676c7d0c4519511929a1f2099df03cf7d4e528ce0ff5565cbff2f64bf9db8df04a95a440429f0001395dd9663c25d524949a4004a51ffa85574f8efcbf2a8b72fe6d5d935f8dc9afa84dd7b251acdc0fbe8a719d1f9510c91fc2c61ed359802d151a16154b73d424b261cce8a800cd6392b68610830c3aa7393a1f2bdfd4ac3b39ecdd409c6cc3439240430acf94ffe5a256cd2d02a56ef69b5f8059d01a55d729b43ef30094db4078c933e6c736bcdb00a1057aa8f830c10a3a7566f225da930f778cf4a5409ffb418e2b9999b7a2165c9effe9b9f89da0f30ae7d56e32c9fea03796e4bb8cbeda61dc4c31da5e69a4779d539bfcc0aab70504ee2039d9d3292f65aacefb4449ab75c29f270e0185287e3148e3852647973892157c27c63c3401f9f3a927a13f5fd96415ee247c635eca41b20a6f760c3acad216160d8e7937990a5f68860a63662da201eda1775c20dee1f144df314212d5f69f970722524c5cd5852b3b50876d8888e80592d9ce9d055612f046e4ce6ddf7849a1767e0f9106eaf52dfce8f9c50382c9f0fba9a9343e83d58e6c9e916a589d5c14a2f3b10da13bff85736394d3ca3670f005e9f88276ae232f3ac66903cb447f795db683f0f12095d94248c38c3ce928b89e57c4c01216db888cd6a6d9f015ce0a320f98b692b77f7fdd13ba2b9dc9eb177460961df15330e1ce7bef530da731937030d0a6712abe7d6d2f1ab7757bbb764f0fc44247bdeb8da4f93db2029648f9fdacb505ec473226dec8636b935067a6ab04a70830278deeef5a9ced8f3bdb7f8f78472ada7f7ae309df988dc803a5d8df3afc21a7595e02f6756c6656e27881d0c4005736936e9c8c1146bd457622b3fb5658fc275ea9dd1ed17811ec36fb801c3a464aa4d8c7fcb7f096a07ed3495d0ba7cd67d9e18197756bb07bdef307e736666eb63efcbca6e1c89e1a2e38b25999258800c9f5f35adf7a8a390ffb3209837628fe1f2f7d14721eb296c3fd9ea3a5e6b568ce83a96aab1ea9fa80d35f5048970eb103439350ffe5297ab53912c3e11954a2ee6ff86e10ee37f03a0e8506f6e40d8716c0aee71916c573738d13d783f2057a1abb813760b9e7556550fb7d3a76f4bd4d9cd39a12fe4e7dbec277f5197b42359eb6b327ffffc2fa5bf6a8ee1acabca7a201ac6e40ddd17016d03ad38ecce5610bc5e85af7d07f583e3f9c5ec93cd482fb4bc37e4b8875636722fd97f7df0c3f7397e24c147b9a5503f475e1879a0d48a619370362809588d3bd41b950ca0f8982412451af0d13d5ace0197760e530f12589b85fa504db5fe939a745232bb00505eb3f3f8c0c56a848146d4295d1e798c53d607faa8a25475d48f22459c98f7bdf0d3fe620f54b93fef9bd5e71027981e48e01449b4cb7bd1cd58b1f39acad1375f75c163b084908871ba266ce97c2744618931bbe32e21a11594a89645ed34edfe43d7efa4444fb1e8cdd4c59fbb04ad6d48e439032e60afa92db7d8e4cada177c6de50c61a99c08c2cae204b631460de809f79f3409057f82c8771e6a066d9637404cf907cd96bf750318303e85690d393c1f022029e0dbb9f0ce9d62d743dba129823e0b606320b2fc8374f176e85122991f8b539a7c5fbf74cb78f8676301a33fb55368f1ea9b7e1e6890e05f1d022d0059f5c47d49d005bad4ab91492042a22ba344571a131a6a84fe25f4ae8174d72bf8259ab2ed558ca9c3d3872a0d6ee879859f690b0a19f4721c01c1d0bb71fc5505db7a7a8a341f5044fab3db260ed1e299d002c28965f93b0676e3835e8bc3706e4c6bb1158dbf8b820c49ee6031ce281349b11f772bee3e43a59f79d9cde80bbbaa4f641ee699a6d1d2dfd3c0ceede0ff51298992c9d8cd8cc72b909ffd17ecb5bf1c4a428dd80a0b4e301d4c9751b4d38aa3c751587ffd6c740d5db20f684ed25f84377bb573ca421ddc6167bf1872775d0fcddec72928354af4ed54aab523c06eb89cf7fc1b1dca1f194a2883d989fd131721e1c9a7e61dccfda8425c3703cddd136a7b01d0421585f91c88c5c2b9a04a88faf47956b5a94e9d60bf4502373bc44f172a0f8af805463422e35740e41c14ba8836ed6ff794add548b88b9ba63ab1bdd49270f215ad63607b43624260011fba968d7e023539a5f0b38e44a11a735b9234d8929728c1ac9a7bd39fe1e4cb48412f08ff736d5df08105459624b8fc023c120c0f0cf4aee8109ee10e2092c4ae18f4b5685042c442b570bf7daaa12a5a171b4117bce5b79476f7cb08fceefd8fc266b7e81002a71af3a5248097c8a1767a63d69d61bfd25004e23c19cf014f1d5f46cfe2b8864c60a594cc4a73e9ed0f6745ffd2640e159d942486abe28b67cae75314967a5ae9233d736f2c7fe2252e45d51b7a58d3c66688051891fec60cf84af89b1ca04d77d9921ca28102e2fec439fa25fbd8bdb7d681b6ae0417d558163faa33c0ac061f95e33d1cf8bf667009b39e829675d3c0e4c5402e354f4b9ab423d4bc583076c6c49fb2f0515c43dbed8ccf4000453515c9374eaebd274dbae596f0f9dcfee010341719c9d1992aaa882f07ad607acdff01dc87ede1715d5b134d08308f3971a08c66538aab10e95ab1af9b0249b13304545e8d76673e973f9e92b897ffd8508e21d0e6eca26efad536e47630af43f6979445b89817f9ed5c267ca856359c06619ad746f9e0781e0edea446fbc626419e9ada56cc651b17964658d0b836eb8148d87473da581e14e9e3510adce82b920a3fd3cb312af54e0e90b81ee4ca1bb07db6fd5ce26435022425e30f9a35d403055c0311b6e28b7eaad58a952fb8ff4f8e240bdabeaef368acf080380a33f8ae77288902ecf1b6a938cbe0220e98d4bd6f661304dcf2711b528b0c18d56cacf14246d63b54a9f5575df6d96121708f552de3eb13493bcf43d5364b152860bb607f587d2cb66ce65325e95452a0592c2e869c6c69bc2291671f7344bfbc0df7363380063da55e630a99423d9241a2ecf6b5eebf056a2dc6def92e374fec459aaadb5a65d4a44fd5ef565eacc7d4749863da0b2ba602d0b5827b37d30eedb8f1370698ee1a5ca777f37d43145ee3fa92fed85f9636325162449823972937706c22af4ab3cfe2cf1d66f0b4ec8d62aa6b33b25f9a8e2e6fc965f75459d41c4688f5fc8df458ec9ca0a91ae63f57c7a9054a029861ea701605b630de9ec170de67bd7abbecebe67ee68c26e40a5828e202b63f3b2cc365fcfab7eeee825b24a0f83f61686c58d2b4a9050d6f46d37fa6b625f766fb75bd8c2d6c3abb58aa2ec8574886825b51384cf9a7f99c3722d98f76569c92c9ae7e0a2512f6d6951424a3eab2ff31f2f371e78790355a286456e5335f8565cb8dda4a11117d3568cef8acc26700940f8e6a356c350a503cf4e117598341734d9ea7c9cf9cf86f429ec7a91371ae4d5badd3f42a9b2c82087bded759d82f8947d07ec84228084878653fd745d051109d36c9125171ad1f30fd8cc052af949806d8aa2a7510ab97a98efd66d3dd6f0a2a8059c0a7449b46037f7a5380c67978d3eb2d0870da831f0e954a5ef4a443d0517ac0ac61b7134c8a7acedf1468e57fe8fb83653fbd4916a4f942926225fe2960e19204b298ec3a2f1e6e2929090be26738301f0f7c26ca41d2640a41bdd1d9db29b4e5f55733444256da828fa5c52de3d573b7ca0749cb15c97845057a199b908586ffba66c616db0e21bbb0b509c60571bb5258d0970e987196a2851622b69237825e422b7ecfac35513fd4919dff5e1cd1287a20a3de6cdb63a0b8e065570031e7a1da1ecb8fa20e2a4e3e599f534ee6354be6ee6e0c039c52b2741eadf48e9315349aa060f9853382a264650b6999cd9034b1733bfec87e0ac64dde018cb72d66c69d544150102a1fe7742e587e85ef709a392fd3284b6094d0190e39143669ae2ac62c2c257bf5e49adae4b744a44e93713046f2235696fc56a4466c3a7589da00116728bc290c98fa7ab892d22563f566ff6bef35b43d3b7471502ebe574945a08f8a9bde491ff7e1d6184e2be6160ae0d3a06659c03d701be3f07007bd19420e8ff22042a31a3de828f8ff2568c62bb36b0196e4885e162163e3a42fd6b6287b7ece3767bc811e857080fc38265b197173cb24d6cec1e567c4b2418311672013ea4cb542f7b73054feae8796f8c38dbe4e14897185d1eec261e2a5449de9820c72fd01ba1e0fffede0b29a28bc5409d814f82cb2d4164dbb1944296284b2afd1f422814c306d465477076c074c9ba34938a7f28ea9629204ce056094dc927eb7f50ba8d128df2666dc3c6a85f901bb7d4b39ff407ba263474b9e6be2b350caea9def69b87865eeb321cbc1eeb86d9c6e3f1202fab98ef399a1a80c70ab6ddfd5ec19285dae2ac9747b01dca5d172381b5c0ac63deb1ca8794f7b94a9d8f7a82cfc5b6c82ba35d5b7b4fcf5b2d047e0fe8692322c9d31174a7a201e7a0719b09e3fb280326cf4735503f7e76bc3c7ca58d056eedbac41d721453b0a727f665831a343a7de17c738cc2aa9869473e4d12b2ff8736c95771cd21c6cd1d1cc3e7d1b2f4117b2bd984dbc5e6266a2f746f589678239957c67e21e816867c351e3c4d58f83c2df367d6e815f3f857293175b7a23c1efa8f2a7d86273b8c28b7085831c841f9b9f0d3208b3209ec70c141df0c32710d3aa0095c2bc915c082943c12dce695549135850aaaf77e60256d0632c40e7e3e3d43d4293607c537cf3ae8f07e55e9d0339a913b0b60060d8779d1b29449499f1b96ecc52abb6d741055799f3e4aa7898359e8d25a5f1ed3d14722cf8b29e7e3699f4d6c4275300060a0a6a29f5b8554b78d7b0876f110901c5e70520447473f4c593e84befe3263ad35063bfe936f37b06902985a0414da9a72163e7dd6c4f7ddd89ba91ecd5a9c73270eaa256b0ad069a502b7143dcd7de3cb3135b3854d5119d61229c111193b43706734cd7ed736237383f3858c8c6b04843325608b8d02a058ddf3fb078347c0e5d4ba3315090cc0ceb41ff36966b2e385e43eb2bf66150ea3838a0d8ab75c63784fda68c9fa33c809e6ada61e91ee045f31a9ce5493a0356da59f35057bc5f7946883a7d5dbdf5b827cbfe3d057600246e4813e8d4c85559ca62457eaa50ea5e231d02165a24744497a9fc46008bbea3024992ddaabfda0a40eea5fb3f39b5c927040ce58b5e71705252dbb55054bceeb6204b80f7f0c678f741a19136f5145f430eb25986259fa133a95c5eaf48a4485bdc0648490b5c8920523e936c6f95867f3d6cb4bfb19540492f19fe069800972e678dd525d7e0b93daaa21172bcc58877be1ce0d823763ce73753e13952c7388c9ee9810052a620cc5b6707fca793080dbc16e7ae4a6c8fdfdcf4c61f1d8f372e558fea0c8a73cd9e0793004b4ef67a6b3b67cb87a99c24cf4c1d76bd99e0d9670caf18fe76b059244eaa11c99b947d42c0b62395aa80c99d9938e9109f51796419e6e7d1ccc016a46968368d385b36a2bc8028c01a32d7c78b4c2d3471322865007c5ccfcbc443d349469e47e7a4b7db1455f506e96a58e4f4989e111b3f041852748f0b096d33cab15db4b6a1cd1def474f8b94bc2ab075002547a9adf0139c549c1948e223e6405023680232757e00fb0d350a8f47a1476c28e4cfc1dbc2122f1fc2e55786807bc727b816fd87dd7f72f46461e732f28d54d3252bdce09c30d6b63b3f06ca1a2e8dbb8efd1d120daacf691823b04de1f1238bc39d618d110627849454119fd0e966b3bf4d5d28d88d7e425fa12f8a2e5b6944b57a00c25a11bfd31d448101fed30ca06b4a2fb7cf8ab0cd97fafab4e60f4f02fc5e345c9d92014f97b47b33eddd70f0a83e559a99186054c3acc086dc18def20dbbaee1d7f48cd2de8958b8410d0607c3f3bd4a32d2a591fe5bcec017f8475d48b2788b492982b0f888b0d4f8ee11cdbfb9688e5dbc3c02a37b53a44efa56fa06dfde216de043aeeaa9a61203bcfdbc551f6149aa961687f17b3043a3523149d70351c5272f6971cd3a0ba3a7240d1423b71382d45e9ba5a9e0ebdae6c2973c38c0cce885af4201e50d76ee4e4805992f15c1f85512bb39572f3aee8d2df27701ae14fb05e0a428d7aaca5107b1017555437fcbccbab2427002fcdf0c25a4812e80a4dd74c7093a3a47e574bbe1fdfd338a8d1c8b5bb470cb7925540d7d5107bb892443e6c906cc8a60105a987bf87b7c8c2b68adc28d344b08f8fb96834d2716b6501e34486f9de8f2e51f7475a5da80490b7caf8a525d80375d74cb3ffd77d8196b22b39ce2bc19fb7e1459438d8e0d9c6474605e398bbfd3b6dc98bacea4b4eedf9c6023169bf7c507abf3aba67b45ee61d33e65b2b09cd11ef128ae46741a8317170de485754b3fc7f6f3e98047836bf97a7d671b2a3a37082637b149595c7efd3ea9f8f21d3dd1a7efdfb70f06b23912e436c6f9924ffc5f9db1f856a09be3072d293f7741f45268b69cfe82eca02df149ab406d70bf6272dab8d90af7c79b69d7f57e8661a6f597c5d9d654fb744baf7f7665ec04f4938526cc0d0ca69555bba3081235b7780de2e99eeba340d40489c73c5f54c2008b387b3c4c43e7a9e03f724c7195a123a12534a8fb521f816645e53664a287bb004d3ab773da64c7df3e9ab329f657a4096dfcb67d99a3695a470d64fc92d0c6893668814c7ee34f8d3a539919af0dbb96d5256c85d6e3ed1fdbd68d5384ac5fad64f8fcfc855a14794eff31250eb3c712a5b80283cd794a7f1101e0bed10a06ad760bc4b7626d7134f8aacbfec94f26a05f3cd38fe11fb1f428c2ca74064a35db283f7c752d1c39b90dfeb4b42a1248a58431c3e3b28500b8e25700f3cbb0325bebc4d8b00ec8eb7a82d52bf59fecab122296812c0453537e3f86b8c0b25e659930663706a50c042c29fd9a215748acafa196992865d900ad91ede9198491c70233265780a5063eb8da3f250035d2f426928af293047e6fbc5ff5d7a9c84faa8afcf0a8251a90110e14c32c1181a48e5284726616ef82a3d15c1adf45a9dc93f8fbdc705646b162b9eec5332caff94829293a1dbe5bb44fcb4a06cd4e06a9272ed78e4d917c5752cb9c81fdba77d310be5212170bb139fb4b97fdff1580a5f971a75cad9ff1785e7e50d1e2cdc7b5d830d7ea6d9ade6536f8c53212a0d20211150db05ececf70417f99c70fdc20fce8a74c855a4e656b7d7d669f0febf1537516399fe217ba5ed1ed53a8caefd184084ecfdf76b15e696522fbd27abb54d443de2193a2c461dba7335feae308aa6fe5f6e8f0a623871ca4094fe8ee9af39abe29a0261c08f151a15a2728da3604aadf85d6015113de1b7850947ffa02434745ea1e1e2f1654448f7f5eec12ab48d9e9c4c0bc9169a1b0bf91d421bc5e3339c02151f09955d0f70d5fc59f78c0d4d12879e7fbaec3f94e5b9618e201e33deac6306a2e215ca45448f7a0f2ddf7543f5fb978f6915a6abd43ad8c4cf898885ff78dacb7e6cbc2eac9010f92709a75ddb68a20d644150fc6b6afbf34184c01357a97e81abec3f591547366f01071d7687c8787f7157638c9723cfbfa69ab132956572142b7855abbe394c8c0d92793e64f0f7cd45944bc0ae6f199e66836c338308c57d595423e514d618f3d24508b1c9ef526b6b1a12dec5747f64b21b7507b70acf52a6566a007e5c6b5478f15c4bd1114d5fedb33967541ae8b53787b1d02e483842aa22e5c02e7472c93dc0ccfcf70c62b5c6f96f65e7161d95954e592498f9171d8ff04e0c76ec85fb48ce1abf198b4fea91734f34f43ab5382adb777f0c1ee03c8032b45ef62dc25d143bf2796a589695f354a7c6c211f067ed706ef2876ccb581f2104ceef5d5946ab6d7a65e3d8e982c4936c311c80d1845c4e043c1706fc90125c7337157b083a7c730f2a772f75c841b3851334fe23b52acee12254e3d3fd34e04c17be19ee09a1188692baaa53bbcf580a0bc667de865ef9f0a324c54ce424591bbfe3a88f5e7af1cc32da605aef4499e08c3070e8d245e3127196000d9a55ee59f3574640c1787dbd2e1167d3c7ce1266a0d78c92c5c23b64387b675a358d1a7dcd8d95c79dacfe674ac6105b9caee7968a64de81be9042e30727d7da44b420a924b75d898790fde5a6084451f49922b4ce76835f205b57ed8c68857bd55a1b660d2e19f1eda58eb6263f7210bdae0eb39d560540dc70d9b1577f85744da46adba113d268fe3cc76ea977dd51a9dda292849c27425afeb7a2616a9bcd289b9c655ac1bddcbc4e70f2ad3a44e314242085e2b26c698cb3f27a7addef69e2bdc905209e49b501ad67c9ee37e6e4d606b18e3a08fc9e612f3b220ff7b715947d9ea3b32ddc0c4316e59eefcf4917d1142f216e3850f16e49013aae47a77ee4c6afb6a0c93bd8df1a03bdba832e189cb452bcac400dc72fc5f2c12a9c4e6e77c2a29bd901b4535d1d4ee5142b7566e26f1d28f87ee34aab8bcdb3ff6cd36393254153763c2048c1986364390092064755d63e7f3e2146a50709d1f0b77ad6004af06e8674c5296dfeb3c724cd905c0d321929ed610da3ba63723044647cd80278078e6e24e2d5f07baa7481b0c738e4bd224914756cc9800536a137f1ce8eb6bb96be39070f1397691028090daddda9b12f95aa84ee25bde00880deaa4bfb2880b281a76c56fd878c1bea7ad4a8f804039b7723a971acda149ec7df1544456e183a7758951195cd4e28d9cad94c44e1a39b7ff8d79b9edd4593f2694f6234cb82a3bc003a8627358a36f9f5983c771380305d6dbfaef12cf8f6d16efca24baef7390e75430d79302cdc0c8bdf1514e887e89dffa3d535ec5ddf720e804734d05f965cb41f13120225b5a2d37252cfff34cda3c68f3c216f5288235f08ff347d789f89612391c23214f5b6d038d2f4280f2087f4b64eb3b57132aea56836fc42fddbaa1e5d9ca4491d4a26d543e8f59ca14f1541472ff66441dd4e33e781132f86679935a58d9ccac3495f02167ee4ee735a7001a2445008c9366d367b2c957d5636c28ba23cec16ba548b3a0f335e4b2e11aaf9034f8f3a6d6684a6f7118aa784ffb0e70876e8967033f605a419cab31f5f1289cdbee73db3d25347c4a598e469b267c4c5e2efa74080cbe8846cf66512203308fb9c94d24df169f460a373b0373b50cd9b23c6102ce3a92ccdedcfa7f7c95d1c10eeaaa23ec42b041afcf2447ffb1532e19d916022e70289d10772f907782287dd195273ee3a5bf9f71543727c6970dc004b2e919cbcd899878b999b315b5a38058a4355337f205c88b34678f8d4d3571938988f74568f183f0569e65fafd067537c6db338e7b302470b0adf596cf8f6eb850b9a5deeeeb248cdd60a402045544ade31d5af117efbffce3685dd7467f9c2a87c89a8b22ab100f5bb73fb371e60faf61956bb9fbdf7c0fece481da89634a4a53a9da0a405a8f544ab5ce2fd743ec93baf21c95484304bd0e4783106ad090ebc9fcb8cb1e6fda124a7838926145325f199464c4824e2772b614d69f740c641b236f25e83b4a8ddb47404d7d10254440363cdc9d7d9fa4b18d2c72707d850c27fcdefd78ec5f556f972177d92d579adf2feaaedb37c1f299e1e3da1e2db4171e2782c84d1b93af6cdb8ef7700e27fc63087b199cff9b04cd7c1782f45d04554ed413862f829b3bad8003eec337ce9e0c18a4084d864f2f922e2fa3b51c0c757227b45ff31b8408ff733d686a8648a9e9012798f47190c536ef45d6edddf8f8bd8c3c9ee78a4b79f026b214463f46b6ddff105634fa672951f12c0e3c0c94478c53ab82ad0d96a906735bb0998b581fb9fa3381ad2bc82e4f7437f4d909828efa79c49e84cc90dc4b630344270ce5cceb5b372679204f6b2db6b414e19dfce80210c498707ddc9929e597ddead3a3e9558fe7946e281f3ed082f2d0ea4027d9961a3b7fb87cb5cf20a4c2027720261a2348de83da9938e1129d1c075a8699da4535ef064b3b7d795b28c2d2392ef2e002f90e70a3ca3ed3787e4cd8a191cec04b2461f1fe175cfd5e104d6b772093767d3636c697d6f37bcb490ea0c451ca0e39922bcb22646dca9d615d3e4b676d157c40a278f6966d51f4a7c176f873ed284f3e3f9ea7595abe02324705a64ee28f8b936c2bc792914ca2aac9c583b7a4640cff85b109c5cf047ba86ff47d34ee417b4a24b0724c771ca8fcdee208481d634ea2391a042d036555eda6e96834e61e975b86f9121af1362f7350284f5691af68a4790a2f5fae8395920af51e7c8ecf61c4921d3c50fdba923c7a956b603a87671bb1467954657a2f698fb3b3c1b642d2c77f44421280e480fac9b32dec10c35d713f213fb096403dfc97bd94cafa4b47a0590c5072853820ca046b37fc351b3a54a50f388cb1f4f0965cccd55810a38c831b394a5268206711bd35d7ba31f994b5490a0a5b7100beb26c77675379005c4eb3ed7adeeabc2d8736961f94244106a93bc53d5a001f96dab10f7ffaa7227853d046ff3a6a4bbabb4b88125302789bbdfdcaffb5631474447afd5e51d783a0c3e3e19692f7b3fc369b5547b490b6e281413ab548ab58f428a3a2afc22963c4223149fdde606f27d0b53511f2bdefc7ce0a13ccf422cd0e2bfbdaa546248574054c7911527a443f731f39d8e027d8c37c7d9b642f11a8833fe5afae2728ad70e6e3c7168ccdc9a130d29edb0001218e23cc72426516c6d1e39dc8572434fd8007efd464c8f9ca46614669ec828599f6a1ac4ebe2c0c9ec9a691bf1637cba34214b8b3641bad1266ca53461b53ec80e7a71305c30fbd06e53418dd1fe9886c1f6adaf5b0df2ded30d90cb29f72d4018be5df613b8cbbda2c50e9118f274df3fd5e1ecfe24407354781385f48b0686f4898edd6b8807673e887019537a096e8f92523a1abf8e14e4662ec67634bf4eb77f5cc47f848cf27a7583341094e8c3ba334143eacfe7d93cd0350c757d89d3952de638bc28317448c8684a3d20a742a0be34e31226b94e082591608ab940affec4beb807bce05b08943844b2d2e42c0719db442a892e740390de62d8201018ef46e8caed28cde7c0a030fd68ff4a428d33ff1eaa3ebe8906d9585e9de1f95d662c83317224349e242ee10c1475decc1fc1ea37cfab7698dd1ca3f35175680d88af182bff2cd539f9dba31b9cd61527d634a0c7384209b05ff2ce314a6160e493099f4f806f4d9bb155d104c2a6cf14f3ad16f79b43c6df40c87a2311e8de81b34422b86d0ab3030b7b868ac22c7dd5541a66a7e5e633c0090c3c26c6e9fdcd20d1b1f44f53085b2f2409f553233e405ccbec2922854e07438794ccdfa8c59e5ad125bd7c2e964aa82a0ebde2907505b838e119d2deeef875f5c4a821ab417671905598dec92d598056e16234268382cab534b0c53289ba683395d912cf04237145216c6c1d85012a4797f98b5f8fdc8f2f41745c78bfea9a23648576ccb4497c9bd7b4cc258aa93cb6c7029497eb61ff0e895be389bf577bc9b45197c4e728e1fc198256a3739348d219d179064fb8904fb162ce36a9a5a442e8f2c660ad0311b05d70e056ea8581c37430e4f08009b6e199f9cae1e4c78b963c124cca905dd377df48dc48e9da9a1019fe30b1685420b3510c491a8ebd668498a907c0ce992e547b3dc4d7e70132ee680525104be38562cf2899488391a6ca2e9a88a6e340769427d586054df3f9e03bedcbeb0932a3db06c0a0890a9b6ec325d152af58a36335af8ab6a18d078be21c962aa45e4e385f02df7bbd66366779ebf7ee72c60a314a43316c789dedcdefc604cb637b3b26b90d030f34b0b87c65759fc9189d749de131b86dde94fefdaf4e12b37f3bd6a073f10cce48a742897a4da031d57edbd64c496ce59ffbcdac96907b13e4a958aab4a0e559d9ecbfa731cc227bed8a5b6a5257a85bef1e10ccc859bfa59d331761576b7f07d26dd0313c53d4b0a5153d2f8f2d4e71c405bec25d80f4f17602a5f020e722488e482e057cdee0d4a115b563e364cb2d3124ca6bfa564f609d41b0fea533c750a923e9cc4885fcb26ec1426b469123c8f15c038372aad2abc3f80a351d2751a2820713072604cbd49f93f7a35d069cee9e83bfdaf1f255ca324186c76ba28e693a101f02f6cfb166e18133e3beaefe0cc3d5b881abfbd207f72ff918801a772ff62706025e612fce54d428181638caa2369cd9a595b19e74b41ce011c3f594292e0d82aa4b48ee981b8d07b783923d2254731ee5e99475c9a3da540eb989b6a74ee1a8a9a2f734d6e7422377967d4f66567304b9985680b53d07964345c9b0d22211d7d244ae72862cb06320373ad0122c2197241fa8820b2290bd1ffe17f5f0186fddde19b090e8fcef69edaf30e68b060135edb8e01c50f688c68ea5252bea137efa84243084bfad8f7772974578e9e1b15c5ecbafcb4db8eb21a57d0dd749fc041d2e9a42a1161abca55bae7498c81f25ae46df552ef52128b5ec51b2d98c3768053e59b16bfcca05a667d3b4d13df7b5d9b855f90829345687ddf63f22ecb7476765779dc623e996870979797dd983ae2cafb6c56911b24ee02b930bb49932c4c530abd2a9af0149eca0c1da1e84ee9923d407a17adc88ed15ed94d6127ee8b88909a68b63b3deb44c5c64eb2b560ceef9ffbd77c698d079d1867aed2d30b1093d1411320dca940de4cfc20739ff094fd66575166d08ff3251ef3903521d2f6965ca2b5368add0f31cf620e3ff42dc5870817b1c542fcb5149550c0c4cdd4ff2622cde63340f9f2e1b7d02428e795c4cd9a55dd90bc28bf169cb9e0699f927a4b8a47bbd77b80e99fe6955c7a035cbeed91e3e2ed74aa6d74d4fe0b8cce757186cd95347f62a002f67c53b1f96abf7015b5043722bdf6adfa3dc8c2d9ab94c66313b4db116385589b1cbc85408942ed0b7e53a750679be51e18b3df4b5b6fd1628892b51ac5898b662393822976eea402601ec69d54ecfcdbde63acdf6a31421643579f5a554fd02eea1f5dee73c0de6a5b59b9afadf54bb780bf6bb959fc1f1e3a3156275d08f15d8937b3a272f462a3b5f82799939e61efad015bb1c0229cc3b6c68d637d67e27f0c1b1ab6380e56c98cde765fea2fcd17119367b7d86bfaf033c7ece779bdd08bff17466be2ad13a0da332df4cfe9ffcf7b3d12a4ad3b8f4f4b854b4881efb6c8d0da55c6db5b29b5b6e8a16defd3f66e7506c72ab87d6718b8e95be93e4554a95274c6f530ba293ea803fe2ef0469decc5342a988da89548f2a795e2388fb05f5bb0cc95ded4e6f2116e48822381fd348d8d217e33c00b37a888cc208fdbf1f102884aa6354466770300b3040b9d87d07d822dc245660b693c5b91294bc131f3b94916e9f6c21d5ad964f76211bf11c30b60f08c143a6177391af321197199d10559af8da52790a89f81817244be6b95fe82a24e8893477198f11658c2b1ff3eb1db93fc56fa3db9594fb46d5dd6bec52ce49d8fd8d49832cc7f24692ed6711773fb91db56a23a72089c8fc4bc674ef5ccf746cb3e0dca217f1da5e59d9ac5c16ae24f83798896f136fce5504c5e81b13137414479bd3c5a53d87e2031e3a8c2313233ce801e320fd78085f5b9ecc1026acf23ef3de7a7c19499f8ee35879bdc287bab55cc5db82b8a879d53491c8b07399ce5b4f9727e0631fea5b3a45a1163f2652b541d093476fa016328cdef67a120392c5afb5166ca468d6fae552a84a8937014ff14a820ed507dcd3913c87b41d8e0bc67480e1352f6e9a9212bc87d4fba4c847f6f6e4d738227d4ecf15901d1ba58582243bd4d1c54dba100c9bbb05d2d78dd8ee7460d48901ec6f8a72028cca205bcaaacead3f7d6d7270629da81d6dfbc6b50828e3356144e6488a6bacdbcc242a0c8540ccfaa15cbf0eb1a418077325bbb664a924734d4aded19e92ea397b24b49716162a6cf74f330cf48504d17ea453bb5e0cc168c42a8f76c87af28622a220ab46ae2c0885d4a591b24f486fca1a077a18836e5916715e3fd83500536af7761085b93981d64a9e01ed867c30ea0bc06f03b4078b60e7319544975b078dc177a6868d1d296edcc35fbe70273edb06e135901faacda91b5e30cc913b646a8f4e857c5637a42e68d191201ac5f5ef007f7b443472b84fbd5f79ada4c68b43a4a0f4b78320f683538e303bdb7cce14310ad0d05a28ff9305bb0257c9fa73881b3e110fcb46c3bf9250a8c001d315ba238034a23952b0e80ab468ef1f54f46b30be1e5dcd5bd3b50a86303f1ab0dae56491334573d7ee8c459d56a968aef9dc3416be9503c1e79f55479959cc8b7c58eb6e4e54021457ef652951d29feacd845bb2dd97f7281011e08703e64ace92fe9ad6f005214cb423a8d770571d6fa0a130bc775e77c226da5e38dcef6ecf588cc954166e3c4217432be3191d657a971325d50e013815fb8b4ef38ff96ec862179239982eec2f8e0f6ec21d226f45bb636624a3e02083c157820ee0fba7332ab6d54b0cb89151aae1c614b0acc5359128559b9b8531f0857d8286cbedbe4b32dc2681888abc6bd6d04abd744b6d6489c115281fc1e08c96333ce00dc999ad6314482256d8b5c29072364ad1feceef5fb6f962fd6a44918440e9b27e562e25e5e0dd95e493f08fedbc19e1f39d1c6264e6a8aa8d35361f04bca38bae6ec148ccd15cf6070c354610ef7a96519614f0b03e6fffde52c4445a64150bb245707125513a7e6cbcdfca9125846df56e624f298336e057da5fa89c54e593df9d9b1c84688454bc17764f830c097c8986d42659b8d9d69658fa3db0ee19eeaba183b412b84e756a1c3b10b42fce42eb27ccdb7d06853aecaa89628df302e6636745976794a8ddf21321618bc7b4613c05eac08554adafa7dab15d3d7596d13b29104d8b17ed17a5509a9d58e6f2b5d7bd3aeb51960b193d366e0bb90b59b13095f2dc7a4850cb4b75b6b85c712811f062b7e0e42c32cf0340236d67a3516865cbba34b1b304e3090baf0c160a961ae504873b2317d66702e4b226d98cf6bdc283972f650f361a2a1a39aae0be3c9c21d9948863e521935cec8b2e82b8c37c2fbd50a30b948d2e723c4b989d16fd323042aaf84201e1a110b254c3e51a6d7b02fe3d352fe442262efde2b3c63eb5c99f0f9a164b737cc7dc635768d2b9d798b92529fa46d0980b1c5c380f16d3af04acad00cbcb74718aa53e67153bb3ffe56c84c2efeedf751e484d79a63e314dc24d9b0f025d19a1e1791fb1ae8a132106c66a657b931d6c55736d56ba6bb7de1be38ea889781d62bb7f01a1030bde51fdfbd4811a994eb222de81208e78ba1aa6347586a0a67dfcfcd61660fbbfb70f5f3144efcc25fce1c9af4cb22f5796ce1b694078e303111b84f2f82550f4147613125ca07c2d58bfb199fb4a8a8660a80a16654a50010b7e35a51af50c37fe1d63d00fe56f0e58421cf36db8c6ef4db9eff2d33a5e21c21e4652f60fe998d1312558833c4cdeeef22205f7832ef7f6c14ab6fe616fbff34992c9eff0c0a08aa0bb5c52be461fd058e86e5ded299b4ad003107a4b4b794d84923858f0c740e1563a4aa91619906bd0e4ebf9318cb79308926df9ec82df6e74c9ca470b3a71bd490bd90accbb059233dad572f912d36fccd9b27c3bafe44d979ede5071cb79458e22423e7e172986e59f34b9697fafc58dca844632638943c5fd5966f254b17419377de0f1837e35de5952d28ea752284c69825fce5e643b9014d674919feb8d979ec671d954051fea7a2ae3820f41d715d57c1a735b77b08302e03c77debaffb47991c58c0b8e6c4746e23432ea45febdb21259d8db6ad8410bdc32516f8def094369bf762beac11696c2e0d111bca8c3918408e76d070305ebefb5b0eddf97b586702b73328ce72917fe1e66e7191cc8915f75bf5343c01bef4b279d431915b3359d262e277a0773b8eff516b34f4463b7682516ae36aef455cc9489788f63b78b9fe5ecaf75e4ddb01d15247fad4a1ad0da84b89628f12db15467c1daab2ed1016d4046014f84cf1476b02e7bb0295b90d1b0ad5ffb20682d6430b72ad79c2d40e8235dc78aeb8b634ac93627732f3e952cc35b304f26a2194d61c49d9e2e05a19930183b2e675ed6fc1cb514f26483aa755499504b0d1b599aa4c51556ad58c456391f3c0bd8bd55960a773f15fe6c76b8db91f3f341c6e4f01c1dfc2086f752ec6f0e9969f2d221bfc60959d6cffff8bd97f016bb4244c629eac1b09360d43f6d3418fd584487f4e0ea7549403ae9948050c1c1c92685122527ebb20a7c4e28aae74c03f247b8c718b005a30ebe5e7ad82102ccceaa91cfa9751f6de4aca72965a1c7d27e1e273d263ae466048675b9a778066c77de0aa86ce56b600552ea04e038518521412a66a742c27866c206d610f72a188a799206e0f6d98f5381aa6e54d2075861f3ca3e1570e81be9f655ad16cf0b868b31c6bfaa4372415ddcf9674da918dd9638eb837c314b7c304246ca1f0706496bc642168643f572150dcae8d0094de3508f60492b582d53fd2f6b0e26a9bd1f6c326f4eebe95e2c385b3b08289d04f3f85b7eab5a79ddcef6504378e11030cfafc34fdf788ca0ebff37128c8cb04450a7fcd09993b098be9df7645febc40c4744439670f87766316284ab8ca2841991a99d9baf07132eb8034718ba5be747008cccdb19c15440de0b27d3893477bb0060b378e37fe2c26cab265a89983f801e2707ac88c8e061185286f2c55eb799b28d0b834ea42384e98de2e1d904031c2a2c91eb58ff74a3cef26f32c64f59441a2f2fa344910d140a668c21b2bb25550240eff9c8e2b58687f635a27c86482b55daa58bd99bad576ae3f2d3f00989fa1dcf80f07908bfd21158f63d06dedc12bc86bfd036f287bc1b8101b130fa7fa58a9078f13b3a71d0b3993e444e2f4dfb74fa11f18b94a01f3e0a7792c7bc4b6e5a5fdf6a35df05b8c1cd26bf298cf7b5cc690bd8e090018198d0149bbcb9c4619ac1073a3a83bb61800d258c6675ecff59762b68d89fe077a4be3fbca900790ae80c61c7eadd9a6f30e344f5400f6bdda9521898ba0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
