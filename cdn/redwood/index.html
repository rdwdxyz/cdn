<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20cf2c010041f746ea52c6b2e51d7a5547524eb2b1e4a728d47dff0912a413af28a75cf32db6bdbab239030f5388625922ff5ba6c85cf2e1ea05a43ef60cc1eb4e7200ede2275ddccc4e6285716dfc3f081ad54bcf0013f192970c4ee0e70ff74ac608894c711a9a36ba265880009d586d9a9cdc55a92aa90caad6aefe18ca325b65e161fd85de89656e093ccc0c45be2189174d89c07e54bc891ce34c28b508f81e6e566a33b3f4808b41a2795da155e7ccd6769238c95b24ff1a23fbba1aaf8381e3b206ea74dd33e8c8b462ee79825471ad4014ba5a6b79319f593d896f5ea376ac9e8f6865e32c240462a3a274c8f7337583e88212801209a39edcd27c32294ae2266795b8ee086bfafc46c116f30efae44d77c6e87050a41d842a182d0ca7976d7731ab3050f1fb0b5a30fe261eb4dc34d4583c6f3bcb610ef2ab9a031ecceeacae756dd3579f848ac07f57127f7764ba2e0586d660d023bbdcbf304ea37c316d17f5de2890493f53102d4a14931e3d00bfea28fb6a8288a7bb20e20e41c72f71c11dd30213cfd3cda0955bda4c596c62e8d730c722b8bc190a14742a9c0d2a8a1d2e34154722ac6e61325881c98f8e8299b838056ba50dfa32ba1ee7d3c1885173a4ad46614724480b1dd5d74bf0f206f6f5bc692d60983ec7e67f701c922b4e4e81b7f56b5d22a0a61694ab3d900b722ff8daf8810f50be5a6fb7bbfddc5d83c31c1cce0dcca397aa4ed03b11bd69e01b7cf82440e9fb413d335d19fe9db60d1a9a2a9c098fdad7d555563a038ecc012347199e7974c28e69eca56a9d23605376f13f274bdc4415cd6cb74157c897a1f1eb24c5a2d3b258523751068507c41054e181c8fbeb7b5636ae27bed79a6e660b329a385dd46fe2b503fe5ef438ebf0c985d500a8e9a8b85f355928cdd5459c0f783b637aa0054696e58f791b4784381edd7e985542d617e020a28cdd70c30c057a5b9db94d6e51dc68917896ec5ddf1b59c8481fb1797835334aef5e6348ddadceccc269d6df551ab49a79fe6841fa805e29d55bc18687258a3981559e5b8d410750fef31f9d2b33ab4ddcdbdf9d9b2ab65437e8c5e20ff212a19b01ecd5187dee5550d459dc6e2ecd5fe2bb478ed3e28d9d7bdff3461396aadedd801e08f3f52a8697c69b7c2aaec276ee212390b0f67e16798e55ecc1a0fb4257aaa7777b916a6cd3452a8284410137478a459e4e19f4b648590da0e1aa3ac85eed36b790125f6a342bcbc97bd760205f7c028ef281c046407cd0b12a155080089bf0cd63ee08564b6905729982c0c9e8a349dbc8c490a31a295d0eef18cb9257c46d5de01c4980aea90a818535e56c4265e4b95937d8c02cf40458ea34437bbbe67b7518379df9c5bf984034cf1c8debe39f5d34b530af1ea11743d86ac171b91d65f965e0d24828b7f4dbb3e11a756852e6affb5b1f02d1976c85704d92ada90fbf583198635131a381e6cdf211f6fbfcc6c03debba959653edf5d5340d23e9a68345070e4469470b9275e66fe52e997f033a49111f3818080f71d092204fb98be08339a9d49ca4da79c09c2c6505f5d0e4b1e4d826a8bd3d1ba4f05c729dbdc50196a7b101ce034f2f1e79b9f891f2d0d003de62f50a48e1904acdcf28390ac429ca399f324c73aea83dd8a78a3fdd32c1f960b62b0dfd17875a7aaf6584d0e909fbe7d6cc42109165b891be9b0d619c65de8d5e1c18b41aa6346855667b3911ac259b8adde103f3d5d11afc5aef678ccaabfc517756e217b0fe68caff6c50af9c6acbd37ce931f2a465f61b1197388782ebcee06fb482dda3d1981034e15271a2d92b3bd187df8eb91e11a255ef8ba9abb1298c01fccd75229ccc711c13ef41e67726fd365ee96c59a2b67783201987de2e85e1cda00010142b38e0bf94a0e865a5e9ed8500865c1d2f3563c561ca12db474e4376d3b22a7aaa83097055500eca6baf72aae8d4d245d73b4a8962df0378cda2dd7ff16614f7ce33cd6c91a117128e501264275caf7b07130038a8d068c6f1582c2c2f4ebf773715ae65f10f99e7df29d6b92a6f9508d6bcc4b9e55c4a473842b162f6c5df20318d91190a8a27e8eac4c8722ab7e7a077124f09d4e0ec64efe0451cef0775ce53bd9ff86e66da8278f6cccef6664df12ddfc5b4386183665b9804561bd4552581da552c6f40299a493eddc4ce62e51c1e95e4adf1325ea4778dec57e3779f9e0fe2d5d0f2f4a0b4a02d08fbcc4674db889876ecd3ae2ab84e21a36a8e6c7581b467a483bdd245fcb8f662045e07840a73f47d04dc20993c8e63495ea63d0600b9a97460416a9a5390a5f9a5684a92e897f8d4e726cc5ced675aad7389074ce32ff80afc5329ed4bd52fbf27fe71718777a7f2cb4c0cd371203e0ab57f83fd24b79ce916e2f7386919821cc9801cae565377e980d43f67ef0f1d121149074eccaa060e1134fd2a29b4765cddae9eed6af44da24b0ef7c4611e2582118b2415a72c2ab25378d03a2b9098ecd158310b3f827105376a13266b807b0776aa022a93aee49ee5804ca67ec0459e15379e2d92b48be141a0a8174fa82e0550017edde5cf3fffcf50c71a88c4a4ba8e49d534d9cda36e62d839960294bc37d385467cc9876c60e9876e446575a7c1fb66428c9a4f6ab89a50bbba6edcac0516f65c93b6efb68cb9add2aee902036fe56a6dabded4966f5755128b7df5516b8525bdf8b114ff03c140f2e23bfcacca57f141ce639f2e51f666f05776ba4056b683f0066276b05487bde5023c7221474694d49a1840c2c57ae64d5759fe3df7308f95ff615695a7f7ab2c0a299838dc6cac30f4e36b8eddcee8a1f74869f1a58bd1db41af512941b9ffdb3e10308676d8487908f0a236a905cfa55d8181a72a9fde43d3bdb0e9e1b1ca0c05022b2adc25e5229d0d996aebf9dbfe22ef4e84bb15a03743a630f4075dce167492b6e3eb05e618d4ba7633c98ac7675f00243ffeaf068e05fc9cadaca8f29a432be18073cb919a82118808956a0ed3344c946a7aa02f6a7c0692644c135d0330db7eb09427dcda8540375df9fcfda30e3d868404f2b3a79d0207180ef4f18394c190c0f40ae5445320fd2540573115c7494a1397d706dc76b9a93ec1f0584a52b691f6550cc0a60201815a00f03acefbc92b3fedd8d359c3a3c95998b5435749af3773fa4c4418577eaafcd1a7e80071ba36f74d05987fe7ba2e143015cd469ff652ea77a1c9d5c2ba161a3fac99b11172ee3570e3770f8d0f08019a179ad6124c905dd8a44c4c8cc3081abd122102fa8161124c8a375e139547da78d64b983218231f864ed52211e938dabba2ac60c46d74deff44b68f89ac034aa1b0826917572bc749e4c2b887723066b429c5aa72a7c8f00aaf295209efd2ed9e2309562682ef4c920985f1c4d4574ea6ffd5bd2343d37969e3e98594c95ba2e6780e1561c4ab4b375b794c103371926f1df37ddf5f5316410cb20ef8a05c2b0b8698bc3f2c08d2e68576bc0c54c663f21e2a3ebbccb937821e26d1fe38b5fdfbfb4a64f5b60699d4c9de5df3651f04685daa35e3da78082ade0cd520be62a7055e4e4e7197c400ab7653d77ad6e330848c81757c0fefb03782b76a4ee46a423a4e65a38b618f79b44ab6ddfbf7cf6f1c1cafb36db0fd852b3221cc21610fa96f9afba1b97fa2d2f97961cf9a068e5733a7f1d3782f2e6cf4c7f0f15f733454198057807a24712ba130466ce951671761ca39470f4ed2d61267dd565d7bd7fa606b5849efc7948bd51554aef3904df3146df61026d4fee99a3ba09aea1e28775d2053a8108ac61ecc87b8ebeb2aef1561e8c9ce5a735e06707a6441fe779881736e81676a0fceb0b56df62b6da649a8bc1efe88c7274e7db2c87d24a629d0e7fe221af560855c3724d84fcaf10f40591aea9ec75062293f65955d13538afb929fba1929c2cef40a978710f17a6be59fdd4a8e315566e2afaade191a4c140cecf952eceec6a595e059dc359372ee6557305c739aa2f627ae730b544926520c821839cbdbacd562f8c5a17cae4cda8400a4205172274d159ce632d4348bc4ba1453554a3efe6a6519266ef3ee253b8e4c7a1e1a4191378ce16188f39634244a42db1d8751647cffe1b2e3dfdeb25f69e28ed6bcfa91709b527472dcb9d3960eae0e72844c5aeb8576331d5337c6ca3dd8f477a62e7947f7f165dbc11f9ff4654086ea991effb08a435a01b818ee68fc94fdc935e3d1906c01fae70d6be22f5e67e7575227ec2861dbe86ad2f5c975816e7abcb1d980b19d3569225bad48eb6124f803814dff89a576b71f2ed706b530f25db779cb74026f5f761e0fda184e8285a9c69cc484be23d119089a4674834179141142f709e39f8291583ed08ce015fd6c82bc414440cb54601f2a745af9185ea268fc11cdaa5ddc8961e825131d0e521677c8e56d767e41b1329e7949268db0e324acbfeb274fa7f26ac00a82333b790744297382dccac9515c2b865a994de45ef9d2ba9c3ccd15ea007110b9fca3e1909e773a86acde3aca7a1f106fd570aaf8ff9382f1655bc015fecb109168265c3c8e955d802188a319de651349ba7d2bd6ffd27ef0edd8bb263be287c18f96af87a23e4f9d44efffe0c6a9e9b7ba65fa1274f3c6a589c6c9d9d20a2539bb4808931f743b58746e7e5f78f01afa16e85659acb59836932876cd6cdca4d764fa840ec044bee27811a0d647554263d839687d6b0d43d5284cf910c14d492e653276239293fe8db3326b729795fe5042be8defb4ecd646390bf74c5c175a5b4eea8fa030348524bcd9f85578fa1d9af65311c489702ee8eafa49855f3737fc44f2ab6ccdc108fec39468f8da654c5eef03e82985fc05319b6769a43d83a57b3c25f8e0504a8576ede44801589116d26bed611ef285a62ad21ea08bc337e35f0020539ffc530c1434db3e05ceb29c5cfad3dbbbea1dd322b2a483aa875bda0840e458742aea2cbc5abf91412212377e45f52456bdb7dd27e10d6f88a680e5cbab9d549e3525b59becfbccb692d908cd075bc1ec7d341c82bf5ce237d2f4feef8b00e58f8167a94e5a7c6ac265a731c741b028936bcf9d3ad0aaf35f93b6368eafc79d3962dff6ba156e1a6e2c6d4e41cdcc98c609ee038993fbba160adf62b1c6a307042c62d212b95add8edf954286071feab300142474a8d32e4eafcf5b37052556af740a63995af660ddcae418f695e63da409ba962ae058d2c5d779582fca0538eb56d9b0fdb75819790cab0f5cfcd3e5c666e45063171cf6c041e69b7e10b0682d2e7bb5a84bc4f90802a5a95221f72bda32b170ee89a54755ff52480f2aae743b4f418fc345aef88952d5dec2595f51deb2f7e2924b4fbfe6e5dfbcb2571f4efe18d4a610e350523ac36a8447a8505e947c8d2292659cf740fdcfc3b1ed9e06e5a4e41aff1961808c4c0a42def9258750c34f7f5cd868ecad70583d9d835683cbe3d02eb7ec99a25afae9fa7f38c9d307a21e560b0d31b90292b00b34349cd33982f4c46e445ab08aafce5510ccdb0b05dc0121cb0fadaadeb16963ca457b09112e2b235d826ec281d253e45c3ae22f46a020c9a78e019292bab56b8730d76addabcf5e303b6101855ef8f77a494ed5df39cb895b8ca25f8b2c8afa7d19055b1eb2094faf062f7b84ac727868a201340f076fc6ea9e38560b16df9fe5de95f262b80de360da044e55e3bc9f8a274a1b0b2d7c735cff4da6e823bfc248c73ed12f4e6511e235b631131396d9e112fbba78b76e7dfc4e2986da14423139ae4799d0c978fa6d8c265a8e7cab447fad72c289d75cb18b81b8a7d0f126cb43b817d8d4979d7e46fd90c9ca5902a14909813b57ff53ee16e73745414662836e4e0f7e0f928113399df9d61f26bf6a1d6cea960f85a35d6e9cb86b7667500b6c28a2f55bf98591802de814b6c588563ac25d14094caff6714d371e3aa6621f343c8cccc978c61685ac73bd0c62c19a28ef5b5b4896bdbcc277091c9dca970b3715a0b9f6dc022ca6d9af24f1b93ad7fce23cbf0f060967f9f6204f5603400b99af30dbbb65f88c9d9b407923f4431bdfa8cbee09f8d10fe609ed886c9961a7b417cb9c91aff9779bb5a3f7358b5ba6eae3b624f4c6bc309dd2de821b8abfea9d0445778fd767eb9fdcf5f2998dbafb7c1c421cb111aadfac0c5da9dd30a2516ff9b52456b6e3faf33586e8a1006d46c24325d7ae85c6d101db1ec91c0be064937ef72f948bec2a9185fc740c15458afb0b08a9954aefe878d14897003703b859b27e4e09df4f270925bca8304dfe25e8bcfc937ea0d7038bc9b425fe476dbf81ee9220fa7f24c53d7adbad2eb57a32875e61c91f27d95815346c12820f8be3342f161e1e2f51eb23377bd6505f1ad5e936ae57f256f1c73ef1687ea7642846a8e5d975d98881a9edf00b067a37bac1028e9c36e4d5d7aae1fdee0e0103d649e5014393cb1f68e8948d305515aa5d84222c846d5afa891daa8d9a49595b4b072a9bf2eced79e222b12988526c7b99844fc6dd81defe853c8d14ace5236570a4cfb36da7c83204d105ae8341275974b98df224ad71dc2d342f014bbee6631d4fb3c91f0cffaf3abeb67a56a50d9ff222d71c71ffebb1267f4db11b8d8b9e166521bb27aa82ef5466d045c323cdb8c97256955f531185a45e6e20fd90a363e2fa412285106fc10fc280947a2f4022d93d3ab9eba733566727bb89027b090c6011e22b4fe571337e024719c4604a4c45bd475777577cbd31d5a63e1eb6ecc8668cbecec3fe9264e4935bb8dc48292219d5b27ae5376571f3f4e758098f7cb7ca5d2f0ed6398c7e66cf5cb1ebc7bcbf0c6eee7259afe842264d2a88e5660d7f91140fe0515efab6a739080880a45a17b4f377b0baac6ac59295fa8355b9d3eeda3e1b6c48b1253ebcd32884a8a02bd2b3da00c98eac3c4fec3436270c36d1ff8a6df80a4fb0f5ca7632b01b52dd7813af28f582b14f7fcf1c653f776380d0507a26598dc5b19dc651e3a9e20a5b8e40ee68f586076545e4af3eff2ff55d376c74addf4978251666614e251a2f7e44c32cc1bfbb2ed2624caf7dbf8f71b7b6341ab3a3eff7a634d8308bb9359accc20faac1ec2da038b466b72c8f976ec2d0d358c069e5b30df974dd16925e2343a495a60407a022d653a2b8ac150d7a86747f7d499e26d4ec724f6651eec6eb8a688075172eb19128779482ce5b2d8c0effcc7e1b4bfeac1c9f18b5e8c21af8960c4749ec48d0485ad570a1ac8257dd74ae929274adcd0a6a99ec34bee3660e7d135659ada3e4e6bed359c6f308b9987748aee43c3e11a23945ac2df36fcea41de998cc686fd6ec90106918d19116206be555e58cd521b68d4390fb579db8c3502736d3e685ed800d04fa0919afee9e1384a7164a11d891564cb91fa469cc686b86d0e36fc45eb9a2a0722fd62a134e41880f780540f81c5dafa7eed5ab66eae6c82517a29746a5d66b9180692924e5f231b8238e63efbd01489b26ae5466d914bde527a7bf0c59ba72f8d74618507568764b4c2f160d8b9f92005a3b4ae28002c4dfce5dc93ba437a23d410d7361bff7cd64ba422cfffa71f03d54d18bda07ccf51208606464559ba7019c8c7f018ddc280b01d8118ecbdf45b6c6e04e791f1ec735cd374d6e1db5dbea214775b4d2257c72b47b5aee853a8df7849eae7aee01d93ee8ede2ba77f00d6ef68ab5ac7bf22ed82305133c068d34c40ddf7b69d10e1e29fe462a9f643b3070966ea01310600da91872a52013f169a2dd403a5d6d68c51613c7d966d8d2e5313b1d8b2e46e0d5b29f7e13d5e0a21c41c169d9806dad75d99940a9a505c75fd83fbc82a111a818fdeb095a7f82198d9a0e1b45b446fa8dcf56d79c702036b58ed47d28ead4a7601ac4d536f1a4c0ff2cc4faa8aa746562ea5b8cd454df79ddb1862d6b43a7a87ef739f2e4f3c48546119a2f59525d578a5cd134071109598a24e8314600524e2707f9d856c47ae333e20def8ed97aca43a90bda1c41e5920f8c5d0294d9be34d75bcca447e929d908f9c6beb421f2e8bdd04386c1d56190466b1575522e54ccff30638d8c20cacad1461d3e86b288e66c90c91ce8a4174abef78583f06b686315dcc3f21ac35e6ea46ea8c8cae1db00958ffc4397bc598249135315dc5c1237f0ff2aae098742f8359e87ffe9ea1a9dd18a82371d85698338be0b4534526d269945b8f8b865d267681ebd58bf95f7c647df312ca1149464aa8701c59cd09b914b80ae886000dada5ba61353344ef99d0a23f08f5d460ff341cdf40d71feab28b65cc70fdfae6a8c1f77ad6fab31b9beef1bf2fea1d3be48ba175b584df0c8a08a2e3744882ae3f21125fc26825dd40d5783f356912f074d42b0c73a4282d507641925785d3301e7cf627a120b5492135db7b508207e95d0a23113d8fc13de74673e032dba2021f7a7f1dd30f765637108942ba683a6f13fd013b291a07029a1f2f38b2aa5b0ad2182bce78e8d3240db79a4dd3aa8673f60692a719b80973ae85840f7bd8156251e20db711a12ed149e74882556bed6cc343ed153f74c2dd0f50d7fa7ec507afb5251c3e719d2113fcd780235a1b368a29034d690c6a10607d852074349e58aa9246ba11c5e5aa730072e33062b7739d127d9b67f77fd551c8547f72a6c135fe358359f844a287e8d696e258fbd1008b588b6050a374c18e0c0ab6f2958a628db0ae897d6f2292c4b26247f1ec2e6fede0ea9a70658e30108a8c98905bc2db0cc879e23ca58c6e9c5e32babbc3ae6709c61ba1fe375c6b7bad135d13c3a0ec58d743a12dcc0f0fdf0610bac6c83a33a1a0170b10c62f2584de11200f4d7a1dde33180a921a8ebf2c259289ee3427c8e72d437ff32320be202959db2c07a2ce8028053b04c9554dd6c66f40d2e979388f7be18d105c94714888cbdb3bcb7940b966a88964013144ea09df8554e9d829afa5a12afbb17a67ef5b020cecb32b26e2c977f16502a9d583641833bd9d155f044142ab71e2a23e66b77fb643301bb7a1fe38ada116018f32e673c24614874359272e43721a2b383860f2f545c69dc2f908151e2b62538fc2b29c8f73df56c0ceb2b4ea1c7412af935827dd5a59eb3221067b3db27b8f3d10a7ef76565f84869ac2964ba8035489c00d9126862f814028a75d16d0e0894fa0609e6a07c77261c69cc07b2418044137abf4d289483d76d088afb5aaeda642622276bb8992a7c875b355fe7177a0b74b8bbe49fe7d207c3d6e5554d955b82fb0bb653bb888170d1fc336c2cbdb9e6e96f379b73bdf784eae4352a9119bb6494246d5941a85cd999cba296a0e1d69f29f1dae8c4218fd0932df3a782cb43951db682458fd3d3f2c251e0350a77c6c67170e3ee1a4ddca9c1a6073e173948a97bd079bffc01bd29e484b29f0227230fb1514efe3571aaefa9f3296138428298cb838a74e8bbe999119188bfd9904903e6457db1f9b8ab874d1d3f1c062c9f0a7398295d53cb46fec6372faa31b7013d4870603f420ac9ab4018ab453f86de48bc0d1515fc21d950c5f3eb824100aaa91877baeec9e238eab68be871e2865aaa5504e4ed8ea0192f6d8360f9d444162ca5070557469f20f0d017b807b19a522de745f7bcca36063174832a8584714752afa950f622f1de64830b8a7214456659f3c22e74852e49b4ca07fea853a036813806998d22c4b60fadadf65a4b251179499f75e6ece0ebf719bfff1f61ad7f4040ed055d25718fdedd1dfafa8cd44eab170cb0e5351888e1b9195d6acace164fac5d6267660a077dc971a1f1b0e61baca65f41a704e7b88e60ae0e188637e5fca83f8af2bf591543672ce31ab889e1f7bbc747c93efad94acf4e72e051b5ff21fcb80fa73a7fc798200620262d2b3376cb23aa005d39266bbb6d75c270ef8d263684c5e1d130abfb25b74031c7df6c0c99d47433610c5edd82a0789b0e4cb3194825dc87effe9aca214b6a2fc3dcc9e81e9a81ce69144e11ece2866c5feff15e316998afd4c63b7a27bf939a85dd80220c9f799475c9b296200c3c40b374b718fd1acdce6173f5f06b2492b27e79c724b3532f8e9d4f5465a06591bf8a2d2af84d535f088f378f9660566a2dcbf9c72ff7306b20143a639f282aec9b4528695a1a03f32e54f0f17dd9f2acd210c9c61d770bcbd775ee2cb7fc61bbd48b087ee0c34dde57429ea77b1e9b96d152938b8446f55160f8639dc651cf1092c20da9f4f0aa9e944293347af2eaa23f81bfeab3a5676d8f0edd60217eab1be74ba412672b1b59782496adb38db7b2c8b6b635894485ae7768d9300c8886711abc0ac01ad50853143df076d659bb3feae0c8195c098942de0d828df761e80329bba48ceded3f12d60a09371529ea8f6936314cc6e51239bd1ad62fa6f45b3a7d28bb9bb345405c1aff5dace0edab60f9c4ecd8ad0861fe9b1dc35b4b92e027892ab2349be89de079e9416a7ff36b43d1c837bb4e7ea56fa14669bb4319833ff21afd35f8b834bec6d818b1e3aa4e341b91e3ce4cf03fc5e9d0ed7ce349ad5779c3cef065a9a7db6840471bf2b00a140893fd171c2cc02e21f562f4d17760bdec20f6e7d8ab8875e0f93d28b1a1c109a69a99eb1eb543b084b2c333dd3c528489d79b89b9c113e387d816ac242b500e177077b82c2adb7de5b4648f4c7c4fd8f6c2f4f6e32a7a064cf3b2e4d3aeafd99fcaf7d64f6cffdbc219cdf9ff7c8b6f87b7ba709e625e8c47dd69a3c14160a0ceeaf303ab589980290eb09c38e43613c323315b3e9007b36748e5f3f42c5c15772884390c359bf309ac5f04d0bcfac0a54a0e92ae2cd430f1361e8ecf7968935fab86d734bae21d00741388a3dd5031f4170208f2d7af8a2c26f11936631bdb7d6c856bdbfe1c40a8066e5b83947cdc9300542ccff6d306d76e19ca893338a7344a3f91410e73a0d0546938a8ece924aa087509a548a07b4be6a87ea2a6ed573ddd8accf4d6f138a79184d6f9297719741191608a8e7c38fa00a4da2faf9734fc9105db310473740fa45b09f8fb8d01c62efbc13746ecb4c39461ad02da4ecae26541f7e20bebffe35e1bc202fd5f89ef1f9eb71f2e9b891ce86b3801c76f400358e4f06d9931b60315ba8c56927c4bf4f45615d6eb8f70c5bba8d3c5c7f703b92ca69781e703be12fdf5badd78442f73fb49bafef23b4b8037cc67877b5d1b370328bf511b76a96056cd76469929411c9c820e704c6228021ca2dcfa24f94a6fac583636ef1443349ff852709331675e34b0b51fbf95426d2a86f1843820b4d5edb0f698d22e256fbd8edc2cec4d45dda1a60a69e63c640b3f31eef26f711dcc66439c4275d2d5ce81dfefb4d836e8fdef56aafc12cfb856959a58486be2361018041e6301ff4f2d7149fb00fa0a4a3a6e958025efb492c8121513bf50098c40d5908b4cb2efdf0135f4dd57d39fd1ca178f92b50595ab168e18933b975262c4f5d80171505d8408f4be665824b29e33d241961943bf28b80fb11a274611516746c6a633b6cfd35a0017b71ad3e8420bfa901b8a62c824d2ffb4a2ffbd18d1121c4201b120481c39c0af91e4f97299cf18e47ff11c17a4fb2246fda9a86aa1df78a1d8cef8d93874bf5291c4f926f7906c9a8ce42acf853ebb8a1c5081b3f13eb9bbde49835c55a6d6da85374ad90e170e967fa8293c35e5cdf12d5649854e453157d07a2cf3a1d9cb02c70e8ec634ed2f036d0d57b56e163db6871b82a0202b5ba9b457e18442e442c5e89add5f553a25f1c8595a3cae034e0b17bdcc22bdeb5bb85351014ff2d87735c5b85d67e741997e53cbf4acc018165957ebb5ac8962ee22211b0a9ad1f284b921ed73c01efaccc22a2a50d63a69913e76b035fa23b78032d1a1fb40a1083e931be7a9e17590a428b1dc6d7d126c0bdaf26e9586a8aabd9b1af97a7ae4a528fff7c32485d529265ca2250002491c8aef52b39b14ef8431aa66f418ed78f9c88c9fb868f03ebc1f93964a47f1af4d58c469ba688e446f05cc875c4d39c3fe1d0d2462610dd8492b22df66f123edd19a06d6e403ac58e97f269d74e5156ab08aae38963aa597c10ab91ae9801f9d71e3cfb9d625ba2f88e946e3bdf903b4694ba240b47a39537fcc924754ee6a6274451f8291616cdb7f2ed9600df88b41bd63a2d4bc8be3177cb49be63f8721027d2478532a2be38c758afbe2453cdaf720c5ee31f0dabec4dca3fd8236e39cab9318aa4f2b6429ed2d7cc44f31513ea518a2ae22c2c5e540de0e8fc6f658ab5a41a851f3582626bedae2ba789508b17c38d937e1e79e7183aa18f7bcab314bf9827cd6aae6a9cff5cba9fc2827c87f44a8851b3930e3e715856528b31e60df55a11a9eb5ad221788f2c1d35dfc644bcc78f13249618c69936feb7fc216b247a6248bf1c85327418e1377fe89750d82780b449a62adb0d243ebd2ca151bb406e334a7482fbc6259150c37d960807c5b3f138dadf0f044014e28f01259bc8bc5bf13b0740e70ce40af5a6a5d2397bf1dc182556cefcf06b6af222be44e1c599e359df89f1444bc36cbcff88f53c3517f9795bd7d606884fe2664d18551a5012caa354e785db2b8f60b891aab4bd565b6c99f30a0079f7157c9973ce844917cabb572f89758a4894f46bc86a9f981a32f4e954c15d4b7ad19590122febdbf51349f463f14fedd77761dfd8dc36268add3f6f710be8ce379b4e0b52d42c18369eb4f6767bf9a0943539e99ab1a0a599470a0bd22690e8d86b54ebd9a9b0471beca09f7e2a3584bc32f755483e16ce75b114ae8d945cad45095f197df833b958fc983f706846f90741b60c0b222e2b2968a72eadeb78aa9474c907e48fe568d3f443f7935530ad1415b8c0c7207fdf10eb0b912357ac47726baa8fbc4d463a7aa34314d62885611d9e25c5f95178882a9facaeb6f524fe6217cd5761b45be2c807859271eb9932615a118d8030a5197b78b180d4315d81bc15ec95dd98ece783f73588d9e0064400ff18283ca37820be14c7abefa6973c51371a4f41ffc3675c1aaa1b90ab38418132e5dcae6279ffb70a91255c62b4512b84d0fa4a0e90e6903aca9fa24460f41242d53398d8d13ed5d7e254634ae1e231a76ee446549ad0ed82fe8979a5789de93ebb3f4d045b77f1e24521abc1f637e572a5e4bdc05fb54f59625e4835caf48f5b929a0e87952f8dc42959c0b1495fec3651db63e02452342bb5498a6243cda304a8099a8494e9008014655069fb0250acfc5bc99a7c30e37e8c7437adc13740c6c71d43e0d82cb7c02a8d6f1f03531b2f395a24d4967d0d28aecaff0a23db886e3cdb0a81224bcc2563c678219666c07f3825334e8624c0c9c0a5a18cb2ceff0fef3a2a2a6ec06a81e76887dc064009db0707b5f020b87d3cd3789a2a410d3f8864e54c92363b31a5d1d2fcba3324d3a288310a4da7d1285ab649b7ac2eeb87d9fcb5701c6ba74c643615a091c2c1646405e0e10a74ccc80fde6a3f31569e601296c6758c04af378bc9dafa325dabb2ab35c600e778fe0d97219cf0b9e679c2d7b31097f6b8bbe49a077480de42e447e70915353a68b4335da4296c7ecf517b4c882a8697bc37a7beb81350c7955058aaeafdbac9051541f140ad21de004196f0a7488a7135f2240a8cf29017d29013b78a0bbb700e16bf89097e7b45037d061b07a69951527b3706a6cecc37e1f4f2a101b03925d3e5daaceb2732adf573a4cdf0b8d841e5dbb6d7d8cd7252f05595f02c8b0dbd9de7bcab3a7bdf5be297cd13304698e03c598e2ee28c23f23d634fae0cc285f8ea3a819360c3a6767d3ec4debf28dbdb6f39215db8697f0aec841b85d7de4a08ec9c8793324f467386a37be80f7713e8801988a87136bdcd34d0942bea68dc6039d24f19817e6dd62ad88b72774aef10bd1cad57766c6dd5b33397fa1536ebc7189a848d3482c65e3914a03bec95b96b36f6a7a13b92c041b7f0b52e4b017481d69180a8ec37d9bd46668f660463e229cd2f7fd1f9776894bad77653f784cabde67e1c359972c252fde6abaa52c9518ddd793fa2d04aa2cbd6008280067f66205d3dd2b629decd983b4fc155c7f1601462b2c83e2d1a0f6a1906ec31aff66a93b8eda5ec655e51ebb1a9c1b1e366a658a21383789c48aab2483e5c1904132ea78792b6fe0730e6fa6842ff8ea08f903b2410694ff9daf3b889483628d9f2878cbe848bb6989935a015002a634430e29b8f35250590b9e3940b91d546f8129032607b88f984ca22d35d7fd11834fc6426025e95713d1c667906f31c0af57c91eeba9629d27e9a55cb5defcbe9d3bfe9fd0a4daf47671a28e7743ab8dd9a86b3503585b3cd16d09bbe337f54215cb4b980dd94cf8240c96951586e6007e77de2fa23d80756599afd9a9bccd5e124bc105ffb118edb1a4a0876112bd914ed7c65e444bd780c4f8f06f405685c253a034c728f65d04597a4048950192a70c183197a817d603ba829a7f6ae30b64d191bb730542bd8749061e4f4232af088176d15c8667edfcb4aeb1290b8c7a1fb84a912b06355014fc1ad1e9d8b024f621521d319b8ac3f90802c7d991685494b50973a13555a7b482f0bb29e4cec9c24be0d0dcc0737150f61a47e403b5ab7351e2a15935995d0e699475b06321865d962512e084569cd290303d64fca9fe977dc4cacf69a7cb0bcea9e912be767f52b7019df4de6b26fbd7f215d448d682963b52bd7ac12b99033059e7475e6556f630dccb4fb86b802ff749850855efffac4da6e75eeb680a3f0348788c7dc82e7864e96de3462d54b190a94e7598078b9867c9f6fbd564c700500670a0c4a8b4392bf959b5e45343c8cf3cb0e3656322ef5b2c22b5816a8f1889e338dbd9725f2d81edabaeefb38434192d92dfd77ab2d4403800a49a2d19969fc992c94f579af7a71a06d0dd323ae8ca7a182f1b765d072d8505ea8aa7e4348936a040ff702ff99aa6a9b44bbead88bedffb8c5b7378b4266fcaaf02b05c29aa290b4683ffee2989727741d2d5d66b77a3915b14401db09ac36f2a6e24d8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
