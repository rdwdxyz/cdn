<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e554d3180d6453dce52d50aa33c66ba8015db7fe26b3f4314b8fdebddac28c022d38bd66fa919c83549b04bbb375459f96b7e5049cf1d87372a978ccfff89829a1120cfecab8eb237e352aae351cf5f2b130361687d33df30e745db65941e1ce8971faff342819b03fe4fa6de2aee49ccd5dfe71cdf3fc9688157233bdb9151f118d102552a86e36fcadb3b3cf46c3dfcabf0c1c52b0cf5aea11125f576b9edb0414f442f472f5610d7598aaaac3aeea942970c4021eaa2987c3bdff1feb85940da4445ed917a53eaca7fe4696af344f776cec6c76d7905afa3d7535a88f20f578be53c40e8c7bfa21987e4a831abebfed5cad675d8d66878812d841364b00d07338fcc9f59d2f29a40fae60fc146d13d309863d23e4e95618db7b25a7f7a437a07bd0bfd549347573dfaf75a7c5e9a8abec99fe337c62ba9f6e1f140c9d329e32cac1cbd4891b89d1f6ce6d33c7f2921206135f0c9b534cd52030aac3eaae919b6c658e22e8780dec6081f9c7a53338c60b6d483a50f9055860ee656bb85e9918d1a81a1b6342a230e3b58f22bfbf49f8c003a58fa762a8dfb229953d458b9e62a875c501cad50c699904a0fdd6f8a11c1149da393bb1850c6c3e88c11f04fabb37c8f2eb257e0014259e336ea4c51212c3b22492a09d385ba8bd9f4a584ebe739c05f0626e8246d2ca46efe09c38c0ddbf2a555b844ef6bbebc42aaf5f930412aaa843c13631f404d79791b85e2de97bcc1e67315650a6024e6a6a6cdba109533a1326e4b2f0205d9f1dd29a854493491aee0b471c5c8afa1d794f53a8d6cffcb2a3665f6ffdff9086ae17992d252af32e13d17cdeff723e16dfba0fec5835eb91c3f3af8b43c0988b4a0ea7fe2e90753ce572135625e45686f17a71b91cd0367a4182b1b39955166864ef1bea4bc9c1155aa01a3bafa1486c24c62081893f167a70bf0112b48bebe7f6c1986f2ff910455ad90442a7878080f507fa2d3e11d409eb20203400989b31dffcc3c3b9c7bcb05cc6e9b28d1751c5fc804dbbe88a52a5a38cbca5adf1468f6101f46febbc561bc4358a8bfd1910d9e9105208dc549aff90b371fbc2b8e90368e2b5e67196fbe0d84fda596e75561bac7b7533c77a3713c00197def1087ccd30b401635aee9b182e047c73c8b094ac76a7c3d0eb1dfaec9877af60ac81c84e707c7ade77ed64f9b4b013242ee671ad4f2aa068f9b6979a3090d41b15e142905c434c2a848410fb1258aeff16882e7b5726f408664d55574a07e69383539fe7c545f25c575767875ca0eec662ff9e03135679c38de7e3cee31db80557adf370070c3f6c4cb0f49f352bb4cf3623522021a24f22b14d0e05370b48e2aca0ebbf70d99fd2e5b81460b5cd83c3a5d3b47ef8c051401e56ec5663f56655d826291965d5e7418eff9a4c4755d69dce3344f0613e8a8c60e015fb78c00acc6cfd91ffc9e7c535e2aad95bb58e5f9448d6e71f5ac323e1fa8c4dca537b298a18dfc22c5df82dad9c5d4088b6724c347ff98dd8c8f0bcdf5e3bf6a5c52c04494c43077a707a6c63b9d2c7240afa3d9f6cb07f06c3ec85eb735c78861320998172e369fc8af1838a3207fb1ee19a3d41f3224737b1e006d570f992c2a1dff71cb4f1c14033dc9904f9199a8ac4a3788750c58ec81294534291d494d0e8dcfc46e17ae6c8a00c836d36b0916a3cbd651ba3e04467e59aa1278b8a5355e7304eb517b70effcc7e8879e26a11a3f79bd4f0f6f33f0810fafbf2af3a7230e7d6a3b4164236e1d79910242c11dcb962a23b38a0344d18affabb969b60e274605743bb9e2d479b3ca1bd96ec80f12952c8ec07c58ac835c7c659001fa61b634a8b5a52679031740d1d99dc191625b85bbaa04eb06a10b1ee9954e3ed5404fbb21e49b206b59435b87c2e66965e9db4eb531fa9dd3d6d9c821620b2ad716e272cb997dcf906aa1b4a70f8a9210f5a7ccde623947f2ec0d24858ade3317185daf3552c5fca0ee1998621fa73b7227b6b6fa9ff46e88794799f18679dc11ef4dc38e2c9bf30a507942ec676020be4d683b5bcd22ae3e3955720559ca59760686f5f17f754ba2eb0f2666bd4c0f66212740728176abab7f271c9be32ea94fe2cd273a9d39658faeeafaf35a374a40408d32826f445b660588e062c9c906d08621e2ec11d7655f84b8e10be379fd00775cb54fab1461f0709d9812837ca443299f36aa54d420a797e810cbcf1c2cfdf124a71ef133224fef3325042fb75b2fe146edb0dc09c14950ce8827ef65af6f548b0df866b1a755fdd582ede27d7ca07ad89abd2e363311719adbd7cd1b42fd76a22e29c50ed0cb45a17e3e543a2411e66645800d16a700561f4e6e9686fb667513f4c9734bdcfad2a70dd2f15512b97941d2ee3e44ee17d5e3324257d1ff95593ba9a32320da2b1b3dba59352440ea8c620d653fd8a6e1966a51cc887df6ed888651bdd13d0b73a25f961e13b4a397b1e5266d14c3332d847f21c6a2d5cbb930b434b4702be3969ecd4cadfbfdd390e00331ac7980b5614cca0087bb84959f4b3756e65d67fd354546089ad86a1df4a775edb6929cdf80a1a611849ed0d1fa72f98ae5d2376a29959b565a2c87c44ec8ea23fe0bd2f941d021d6d35aca750495f734b6c370551f5a90545fa52b963820d35ebdfcac4d7168f0a287317d12e5d8a06dd8a0c008e325a6d95dbb77ecb85c82f77f6a4115e5acd3b5f24d8d808a1291f1442ab7cc43f8fb8905ee580fb94db08dbb98ca8ad580ae81a70787dc52a1ca8e78e2da2d5f8da403acf6bf151e6e3152a89ae09fd28945bfc83279d1e28b4a75db78b324bd841a9d31b9981e153cfed4a0ac4315f6cdb5ca3abfc9ba3c693bd3881c97ff1f4b6c3ff6ff673397dd5e2b3481b547b056b9f738e864a596c830cd77cdcda9f1471cbb253cda2fdb1c158a237336c6f63cc6765da8a5e41cfdd340936edac8aa2b72901912b9484c61bf4410c02568d5502c5760bb89370a61a99aea2111e723afd3c916c7971eb07113b9ce1df81e6fd888dfaa2fb7d3a978947f4623fc0921d7576c6b6f708c2b57546d5fc5cc64bb752341710a499cd6dc6ce47a5e264c9b554417bd2a0829b038c24c792d11e8ea1b8980f086543ab8a6176ab07fd98ea642755aedf14cfd6a16edb0452479a2692d6e6903bdb1b22b57c49b2149e8e450051b170e2b1dde253a69dea097408ea94dda8d464c0feab4e9841dc32b15abf2f4d555229f22315d12c916666ea7d9bec34ca859db020fa75a150953d14389c0b4517d670097e9cf5a59036f536ce18e9442f51d0bd8e9dc7d1b0ae9fb072a31e8ffcbb83c07a2769c86f40597b4d5dcb4481fbc425644bed33b7bbb6795176379d04f4142fc53744abbae84da79e2ed89f9abd1bb1fed99080cd0a30666dcfd08addc63fecb8b2b02a54f0776c075a2384d304fe73248e1bcd1e1ba18c9da4b86270348d8d1aa70ccbb798db491366ee28ba1ed87805e206b3319265cbe61b7f8de13bbd75359e4ea353a3502660335f18576069e9986158654f7c302c5bd435b0985ca0e9f20a5bc57eda22805e002ac92628a6aa08813865b7dc8f318e3f09b74f1a290029434a5c7c67916303bca1956573a73e6cdd25be01f0d25db21b72d47a9397e4425a7d6a53296480cec864134cb480ac65dee9a4067ca5f1ae3284bec9a054d3b6b3ea2b781bbbc8231ca46f909919725ce438b627ff01d95c0994414399cb2a0ac6658b9b130dc3de8a7b97ef3f5001cb09316c1c5739125868b3cd22b3b670f407800d03c3fc6ec382a8bc12509a93c6d9a1552bf295d257886b6d9542c2e55afb6d0d137b4c330a254a4a5bb2c9bdee744085696c372a691932d61861fd819cec50c2d1fea89bf3b3c5770bff7ebd90d8748da9c5d1d1bb7e8398edad16af97a640b90f4cc66ea20d4e0017e21cdf51f22cbb97d3e7e6907785a026e95d5e133eb5c25e9e2714f74596b8810d0f250d13924d68e20e84b883e7d330565ab0d131b1a7c0a1baa6de9d3c8d41d2d65ba90befa0fd5e4964f08dd978433bf222520a64b068d11ff20d67f1832605273d3dbbb4889b08cec089a92e87d02773ca2576a41571b98939450fde65f13b0c91b6b7d03ab5519835d41ed65b948fcc03c8ff0b6effc2d481c674c8a8a5a70cce8477f80e0a4cc68fd59b3faafdbc8c9fa56a4ff9f84d6d3b2595f8dd85940a53a7744d661e63f1c51e62073236a172d38f0c8f90255bfd6fceabdb727cb296c3fd29dd53608cb71415a42fd34a98738c8247434ad1a4d86764ffdce522e434890283d7be86790d991af4a1c4bc88b9638bf64257934bd82a595964f1f8d861b08a960788c4183e5cd43c71293f79bd3622705562cb16397d2238754e2eb2f0d5fb20db8cc3559f6f5ec6e5f59c3faaa624b008815ef4ca1f50cc852b870c870024d45b28258ae32bdc0d234971aa439e683620fc0591a2a302fcd5a4c3508af32a9a35e04283f1abd77a74cbfb79f542a5e73b3b7727e979c035d0f23dd55e447d6b608725933e1b88e22cb8c71b1ed365817cee17520c0871fc75894e6cc4b618ffe64794b4019f09cdecdae1aab52e1875bf2524049305d39ff92f0686aae95ed0a403d48815b45fd019f457a8b4c2cef06ba395093990d3d63d77aff5702637654c457f10f49fb166c2d7e97a7beb3ab32a3c2de9798c5b69fea4e560574af26ca80d158af32f1f02dde2a3a1959aa884a6f9a7acea2579955f343c9ceebcffe38dbaa6365fed9c84973ac7819b590bc143cc521234c5959974966d856adf3913a1731fe525c6738db05f8f2c227c38fd05afd1e5a0b366969f5c471ef20681c53d020f7b8836a2b3441a7740ada8655d5440ba906c44f12492285f16f6884e2cc94ff708b72cd5d79ee6cc988846c1c767be988566d79eaac89b75cbf20e23a5db5be29e9cd00c7ae57bfcba100a8817e7e8d94962228e19d2bfb382055cb83eea68b9f964321df3fcd1c1ea4f38fc0f416ed5a6c09d966ad7db1050fc5f427f47bd72983e52b239ecf85386bd08375545a23ed2910d545b8a53127c4a8e7ca9ad9b91da806a2fd02e043dbf6b54a29001aa4520b835ab2db8c460d841e978e0048f48b3721f3a9cfee02dc28b5b71b0c7cef77e2183369c099ef860b71b49699198b2c3e625e047934b4cbb1edff68b40471d4bfb62216792ddbd4728ea0508ed96136d9e96035d5a7f7d6a65629cb479d8b91c69d151db4e5037f3a242c66d016bf5e71ae17e17646c40d8bb2e0815ae5f8d3659e7efc5af3805d14b68f427fc0853d8bb3fbdb72f91953d511623761ae771840396f2d6ed253bd46df4183768745ed3b580828a921b78624297c8f99b2b0fa6774d3a355397505763d5eeffc12d045fdcd34082b3eb8a9e7d65c7f511b24984f98f3323311718da863ac7a1aa5a7f9b12832aa24850d8199854210a6ed2c483c97f1b39a45f2afed0c6805cff43ad8e8ad20b52d903c5f8b2c56a1c44123518bca67f7306c25dceb99adc8c837a6780a61cbbe3816f30ed0885109667e5eddeb6390c1a906eb5fe315af4bee5c11dd0541f5020ad066858ae0661aa0e8d3b6cb24b13bfd6e60d5c1a0545fd557f05ea4055d57f788f35d824c7a25cbe630d85a0743d0a013b864f1506c46d044c9f5362736b012d106016d5cab1e6e99b59affcd011efe50b2490384a771fbb0dfba09fa85b08990129aafd5d87a44f0b4f473ddf6d9836c32eccd01ae8c11f4530753da9e1868510eda4324d4beded7ecf9755092b569f31d449c2aac034c5b334fa0690d78f6990ff3e363a1030be1b8ee84d06be7763b859f6289291b50996b9c34cf3daa522b48e257db645bd01d584a85115dac411e6381f5d00aa73b36957cc2e0b5f54aeb7f40de2b91840017dcd50ed8f896f186de54484459ae606ca14bf340418d6b12c00584e25fcf7f5387809491fd95acf509ac2bb2e41d02ed8bd824e164b3861320a80a65e8bac9b19a478225f6bf9df9f302cc60ad2e697f3c4d6ce6c6c118ca2f28e2df030323b2c91d0236a1cd930efc2884726dc35c743bd691f147e885ea438dc51489a6012bfb392701e542f3a0d07ec85e46642d0dbaf1fef0e2f7d603c488757b4fdfa9bed6bfa7dc43d13ff147cf03884fcbfb0f1254a6e87087fcd52104982b343efa8ffbf4d7c2c6587210c74fdffd91869f314d6f72272821aa7e90b8e6f77429152379c9c9dfc96540049df248d96a0af7f047d9d4d7b9ebdf8524b5cecf95a09bf950ec8d4519b4f1c87ecaf5e7b15079e895a75d385d282063cadaeee514d83b0e06cdfd1d3bbdced3e2a9d7efef946d3c1e5ece9b8ecea783f30fbad29204d5cb47f68377fd906ba97db0defb98740399a898c7e0ef2b03b7341ad169a2c7d99f9e521b3b228fd0ed3b6fd5d92eb0126860f80a963ed4f31a25e625b7d6a2b28b74388b36cabdb3f358991019731f52e8a0ffb7d1f8f86a02229490be6c66d6bc65b11c8c9bd91ccd6708430d40414a2a97dd0b96322c89eb0f7b8b60f463a82a54ee56ec04056bc929e34dcb295dd025ea28f31e3b129baf5a0b5b96d8fd754d59bbd8cba137b1d536bba2db3610cd418f2dbd23de4c05f7d05c6efd7e84a46d28050878b9f8c912e7b341443f889fcc59a78bfc747e0fca00c92ddeb0eb26308ffd3b69500d643e976d73fa8d7588ac121078cedc08353ddf5c469911bff86c3159212538d84d600e3a59dadc29f0d236286ed42f55f3f0b337ebbfa914a798ab9fab35c782d53990c63ca663be0f2c6a87ddd8e275bbf21715156c6e9d17f977557f49086dc28c985c8c8de71d12e9fb91ff7c8af158a7e4605cc97dd095544ac90f44ee16ce42e0c850b8d67b76bd9373d764a6d8e4c48f65c64c6fc081a8789fbfc1c79fc5c5dd667de9ea0dc312818aeabd17ab6b4e2b11a2d6c196fc51e0f08ba94545e9c5e2eac9589881370cb871d33f9e3f9d13ca77ec02c2773e1f821225d367426b0ac98356b8c210bfc2134c6ece79da7ad5110eba2d547592f45b233c3a964e8c9aa98a05b4986ad49f4eb6719210a8791903deb537006aa2cf8f2508b713530cd8dc9ed692ac2e5453f3e1f5062089a7b4b9ecbc35524a083f9ad617a04f59a6e899493218373d73835b8785d544af6af34d3274629c5adc1d16086d130991b7e4099f779a15b957b06389cd5024d952f50ce11d2bd89376ad68629cf465b35990ef3a819ecc5072ad771241b6f286ec426fbbeca2e53d6613b99c0c86adce055e049e0a7959d24491be08aad176c526a6789f0fb87627dad6fcabd8592fd28d57bf3e10c36edea49fa399b7c9a073e55a31a5d43c3d5f43afe0368e177f5e805a3facfd1077e7fa6f7edc42ebdafb080d14c76111d16c9ab54b9e69a36abe0b24f424c07c8516d9a42f9c0154194a43e7c043880a74564464d53ec70fa6a7295c660085d6d975882e4f2b3b41e92ce0d1fd17c1762ea73fef0bdaf0106fa2551be796f29f116c7834c1d22327baa0e305635f6e7cab93fe52cff23cd3b574cc42053532e12949d2916188359d2aa74ef51fb25e2f4d9e5512897863fedbb1e20e53fb74ccd3029abda265fb9a3cc7ec04d4da3c2bca645f480b3d4b159091eb2dc6a37617c60561a5e58cafd71c5f461b90cebb4ac0ffb52405afbe193e39d9a7750bf76ccba6975b80d28d47547501df04be8a3f43796da9b728dbc8d1bc46fa0b91e5b46feb85bcbf6c1bf78952187967409022f666b2e4e54f313be03c1253a1ba6012717e34e5f100a8c146dadc4d2a049be866e8ebf8840f46b8cd37fe338c3665261aca476ce4f63d44a004a4485f7c419872488467ac84209c5c9a6616ebb855b78a5010c47a520a14323f014088083718b8afc59d4269c001fe8892337a1046fe2017ad860a9aab5cf1ea6678a929997be660dec026fb3928ecb57a3630e0c98ab0aeaf5a19d52e839935897a9494efe3da25a0c8768e970e841f50a98550ee0dc1f48536df71d33349244a080ab9cd22a45e5c13773e599d50cdb13d64b541b9d2324e1405dab9a6b1fdf4b6282216fccd1333e4ec4e58547a8ae29e8a442ea80703c6b709dbc24f047d01b6ccbd255999adff73b0e3309f3f643f52f4c7fc6bf04e772a3af9aa738e00255e830bf53cac7fac6954f83ab8b58f02b61e5a33a33ae1ac6f7e566b6f7d42e914a687249ec5de348dc975585612c01605da0377ea24962c251d4ef98532004154ac439e9c24829377f2d21ed2d2aba2d36a397bd8261aa6ece076453e218ce3eab7e62cd04e6852c6e20a55c71eb5ac87dc17633677f6c2a979522f1fb34db1061cc6c0cac9682e96d9b5a79b5003d8ae3fcbc95c391709921efff88564e1ed92db692e6748efd0201245d31882de574e4430e8f8d3ae57c968c7cf49bc2b9327c7bf24f1928253c00968879f1aad9fdce028c6850c2d63688953b848cd57c0dd3e23eb73903100aca83b29f9cbfed86463c5b91b5915479f95056b459e8e63d9849930b60ef2b7f083985eb80cc2ff55ae561f3afa79797f72be42685328d7a49dd254fe929f92d5678b656616609aeeede1e218658f1977fbf4bd39fe4aa24dd833fec93768ffc2e865ca3e64705628390404a9319cb182db0974e025d507cad731cabcce9e3bc1bfda4681d21c992241065347dc97f87f76ddf142c79658a9246385afa53e110848d39f2c347283b00c43ae84e8dce38f3b087c9b91d3956d5050df657a69eaf789f331d8d1187e492d2c36a875529854f017e8fa4d45e2e32bb1b5375a1ecb417c7f4a123e0040d34cee2d24e3de5389ec7d6f1f1abec4d11065cfddd04ca1b076a336b5932813345651203d66572566a0e3ce84092a5aaccb8851ac2be241e619302c1c22ba0d646d5a3b6e17f310ee4484b4c49663c1aca91f70d9d517c1badedfc7e0e1a262b4581797a7abda61cfa73e9122c093a9260b2fbc803fa70f716f95dca555240c8b99ad47cd8a60b534f695c185fe3aa66d63d4ae9d4cf530fa7d6f2fad38c73b1953477deceafeaf0a4f2b5d46540edec4b7bc3135e1088a90910cbf8f3de7ebbc742c914bf9bfc133822080f0a576a7711c7e7662c6ebbef7b422eecb568e5a60753c4ea15dab42ef0fdb240197b27328f73619dafa41da119a08237a997a5830e0a819d2931586e1aad498f2fb3c44c097cec368e13c1d1378cffd86b867e9ff73f9a7de21b556ebfc9e79d1229d8fcae43382db3a608b086094585fac3026eae0b3b0cb83c68ad04d273648ca590fb6f0a5b7e8483b376cfb4780df7d7a4e2ceb6e1fb541101f57e6c453541ee3a1cc78de62aec089d180a954faf0fa48bfa0808332cce831adc1f2cc0769a7b1e7e5f394e6152e66fa2f8894e3c2df9d7dd883d43f265fd06f47cbe2cc524716810c74c6068ee46a633604b8af028c08511c3cdb36031558d70863b8b214a0701bb360bc8bae27864a0efc859b5f1699132f95b954e6f113495fc6ca22db0b3a4a81d5c0b1f4cc8cb224dbd386d7ec11fe3c868f7a24431ed499a7d6df482216a10e7608c21d04e707abf94b6f52b2963f85fcecf6cd6739651d834376410eeb41780a72c492586a14e66a670a024531d797c210deb9c4cd684b34dd5f9b7d0a6b5ac9687db684ab9c22f5f638587b72d01993e1a3f1b40908f121ac6ab0593c5489d9180c31cf9e9a066d8e5aa9839d638aa1452691735fbf91cf40ef8aa1c9debac3ca7f41e36a9a9cd6d93aaabda8373b3c1d5948850ac26941e02ab19c0efca43f6c217f623b3cb3e185c2e3d4a113c2ac91be2d16f1ab0ebd3744f787fb6c9409b8038fd1c569a7bdf321782804acc337bd6593325f6ea4bd5b3fe473cb2c78591659a50a8484ad265b68ee556d23f366af56ed94abbe9f4fb62f80e991bece82d43db00da7d31ba9e7123ca3b51a5b70615f169fd2d23c27a0e7f2797c272b97fb20a97c2205e2df242277ed02101057534d44e5cacbe68b3fc5ef82616658b4a818ad9a65999e52abcaf25420970c1e030f371ac98846b9f0c8956cd9906595417631529b142f7422c61a0ec1b6a886c2005cb820388532571bfe240e1252e9e4c1ce6d2aca1067b2c0b7b07dd3a1fce9333b5213600dd06d7e0ec9fe1bf700d58f34afecc65a68a147c67adc530bf1b27772a52bf2cf0f6f3de0c18bed9f7248df575a232500207acdc2e1d2f13421430d02800003dcbe05715443493a54f33aa43af7bef52522494ba96d3e0da2519b438c50bebc197dc002ddc413f39924abce79c28fe248e6bf8bc6839cefa94ae5287237d95355c02b49db158c04e9226aea674187514d8d71412045e8e76b95eb4677268e6a970c42a3edb130b27f70339d87063b9ae7aec3a140f3ee1c3846506c45130de2e831338e636c6a3b319fb495395b9c0617da6a8d1c2d08668f4e0321642e94ec07ea504e1da1f620081e63f44df9013fb7f882555780aed745ac614d0616c216305c93e843baa4b962f2e7f14fd6cc0e3de09dab78137313b59678c90f4356c76e3f18cb2924c7b9b153051b6f18fa8e4eaec9e889343358ea15a90c24450637af2bd51f67b178093b8e7d934d786a0f95f6dda13c9af995b3e8e928267e0167cff6296132daecb82f27fab7c4ec7eb8843d4d5fb0ba998ac286c4466b42c2896e6e7921071688e591bfb61c6dca190e54142017ffd691e6107ef9e8e0b906afe0ef9c5a420264f7bc58ec3e786997cc5d8761aa6b84e46b399ca066dbadc25b8701aa22665eba69d75b5d133f703c53e8f73febb1a72e43812383d374791a82f614f19e59614c04dc71c407d004e3ef9cecb0059028335be546094264fcb67771de7f0ee5b133488b5b249c21aed0ec3ae3a645fa81abcd678618e95e8729da5f00b740f642838bcd5a7c08f01d94a4896e677d1c42761b6cc394fd1bf7aa22223333b2aaa7bdaceb569ea934c558a0d644063769e2007b37a7ce567eff91b9dcb14c662b31b7a640be9d006d37f344ea537d9732d515ccda8c38eda2ade2c5d1937badf66bca73ba18961e78b841cc59f1538367f5ad2cbb158d7215b507fdc11305f44f7ad3b9e551db8ada49504dbde34be1b850184e2c643eefa19848719891ec326be77e9921c8c18fb98b490f5468883397623058ca7dd96fccc70f24a92ca693a0cc8892bf65a8d73b5b50f074c274b467c874796e226f4bbbc85b2b5e1826fd62443d8cb46fa4c6bd10976f5ac5ba0ff409702132c61c0c0fb4afb43be98075d37527af92b871a339fcbf7da993c2afedbe6843cda46eb2daf22fbb4734ba750e43a5c52e6700617e762a6d78a4bb7bd1474dfcc5a5c2a0060046378fd261ed510f25d7a1a21caa802ceda4a8180c34b010e530df131af20db701cc384731ace95b4cbbeff922765be0e702c1a21ccbb4d180bd04cb7626e722c60c19cc440df5a8c9f71ca54c9942239c75a419242564fa2ef8d9f92a9025fe724bfe160d0f714eb36d3e84b1d75ea62f5a0c2b124d735a586b1c2fc834641d722f7c21088345b997a156802fad16617c6e37ba3a8cc1d400adf4ebba59b1834df76c51615b9d99374b07933210a12e27c5345e79d251f638bb7fec57357a73b4b78d5c2aed76fb02fe23d96cb29b230d1710467ada12b23d61f390da10af32e5f55a3a4f233f083ea2745c274443a9f31fb1098993aef26f4227c219a438c525df13dcc199ed745bc759834ec5cf8528345822439a822e3f33c8cb40c213c1df17537e1168eab553d3d3baea2ffc019b70e50ccd02da839584b24cb7db5e77b39a18fa4fe4eb1926d34a6961172100d768468176d92aa71a278412f00113e5c1c34fecca3ecc7111b66d46da39b55f57556dd5d70cd6a0918598a77b06395c7ad0cd6d3e96cc3ca6c99d3f125b2448ce6256af3db2317e77ede32ee2e434b782cfd61ad1491632eb6b119328166f20024df3e822d94ac7edf2237999bf50c06cd475c54e9022e9873494242965b941f88154f442e9c65efe13762f62a1f6f1d0ec3708c8a5a6bb107645304472379e0ea42dd7a60c1ac4bd480324be83dc66a2ec961ea73fed1a677ed9695804afd94a3ec4dbbd98f75238e81d49bd82460ffe7fd981ca054dfb1ed2c5cad7efd9313b1579e7eb20ecaac61d38f6c6c09309a84bfa7a457646d4d41972dd7fd6de0362f193c674ed161f72058c7fd965868121e2dcb55e032ee93f96b6d205192926ec79457ec4ae58c023b0bd4a198b1b1c98063614412673a937cd1464b5f5c663f48911210d9f4699929bfed0c1f115c74ece62885d46f25868349f904a825f294c4034354100f9fc94503fd5c72bd823991008decf5b6b318ac424def53e747ce800ed0eacf6799cd3b0b5399b7c629a6648833ed640ba5658fe89e684ffc58e2881af5f8395cf79e8f8222ce25817eca06d59f42fcc02096f1cbf3b40ec623ba7faa99b2a154be41d1eb6a2bce998c5f0cc06e82782b7e73c036db98ebb29340336fe8d2158100560bafd64e6977670f6dc8ffd9cd878133be4c296ce2a70b60404852fcb2e9598faa9281551df215123d6ec855dd144ce76c7cee93018b21b0ce849c5123dfc8995eef15b32f1643ee819869910e461cbc7ee535157b8d63ca43010be05dcc532241bba0307ac681489fe03375f9043034544cd2c2ad62941fb21f25313607a75afdc66b8efbab0534958dc409b1347536c284d8a6f89b9e58a2b422d314782bb5c3c4366597cd50fe5ae96758205883e23b070fef69a206af0f717a47299c02273f195ffe0d4335667654cbb46a2f169b8cf09dce3a030d2b07efcfb7770ce2b5b37b08d0faae2fc6abac2f04b7a7cab3eda882bd8d250e0793063a2940f43a127f340c7667fb4cea11a7bba94db834a1e431dc0570880329b6029b4c5a539625f9d82ebc7f7dd388213c1b32c1a5e135f1bff628775917f306b198e9b64c79bdc38d3347adff9bc55f0c55b2afdfd73b659bf55a236354ddc70749ab783885ce7a5ce6f7006a23c37fa2b5dfcf296896a3c689679ea1b0913cc2049e2d069292441a7580b72fafce993cc6a996362f7a6c3d25cd97f9790d579dac107cc16fa95f9a15de7b77bf301ef57b528126ddf18ef76cac30ab69348d6bb1b243d4958de1df09629e759604a0535469d961cfafdf5f0f97dba7abe6ecee95d084b5fb7ac27b76032ed3c11e543a79c0c5efbb628923dcfb0100e976772ba72c486d3191f8ff0ff7dcf6c6350d9c96bef488e9f0646be28805cf06c22e2415bc623704b1c50223bdba06ca58992d7b38389a494f5a86e5b02dc4e9d2afb2dece0acfd0e9c5abf4d8e2d14a104440bc5af59bb98730cd598799a115689fb16887b0aa633e5819cd3f5ca2d74d1ae5aec93966af79591e25c2e00b054b95bf16f4aa51e3b043a7ec3c5c1fd9b1dd0930c64eb2fa56289b0e2e73ac0058ba41e9973f7be85ca3c6e49b5291d76b0ba741e9dcc539195cff3fa8a5440a9b81cfaf037ccbb1bf92d892dbaec768f8cba80abfa46b3525358cb9a602c06c78510a1d9358da35313115abd57adcd384d634c8381622c90b48fa1c19aa41c0d18c5d304b6fe2eb9fdac4286730c34286338bf84e3184e3d9daabea3945ee734912e2dcaa84cb7c8ae7e8bb6b3d156b5fde6aff23f51600264acc8ce5c533a03d1c945b1fb71acb271aadfb5cb9cd89a9ab0ccbdb9d357840a3ca62f99d3c569d04f610bf5eb22bec5a4187c0146c76476afc15862b0c148a1a7d3ef40ea3877f94286daeb094c9247c18340470a48f35675cf48b34803a81f108605d0097be667518885820d004b7aabbef5286c5b80e016d8cac1e369c5e83799a29be00e391eeac4106d219627108e2a3bbc0111fcbdec69620aaa79de0dd4a6025c18f481e079fc40087012d4502c7d8c92bed1759b1289d8d5c4e8db33e3636b4d4ee9b3456f9baa5bc76d86d1f9116dcb87af30f8abff2967a057b1b4eef022e4010726ae80c6cb09f40ee6f43c0fecdf5fa45625467db98efc6cd7dccf5a7bad71a355f42fc5cde17659012c066d9ee28a277b2c27127e4f4b2d992f35f324036400ea8c395d43f75d729f9f7f44fc48b0199da3bf19753dda581e855b7cb0fbce0a2e6fed1d9987d8b50a54b20580e64ac7a73ffd4baed9e5d08ac4504fcefaf864881186bfd720ec974dbb7f37ceb551df741d018d6b326afc67301be1cb4ad3fe39a659b79215aa4aa18b2490533294ff91032766d399bdd36a6ce76e5c64462be2f48497bd4d12853bbff755862c4c52821627773f4d483fe403d40b7f531832955103a25286cf11432c5a21356d51ddbc0d629136d1ac1f372c1ae98b8ab40f69707d3e776b08be9f7a2377da0353b4a9f48f7e38a11686ec2cd18afd5007598416a3cfd5012bfad72672414817daff20527e8647a227b38ffaabc46199c22f24fb2107b23d8651f3d05d248665739e785e78925d007fe9de8d719bdffa70739b10feb0bf0e13b782d20dab1870a222b382ecb0491494e321498b67a5d49dbf75f827d099c07bf57a75a8197cbf8036c140c29dc312c16416af6db89417b0b8e3552ff5b92276c624c8b88a37621e031bac847b02f995fb1b912fa457054904f567e2078b2e96e341b0f34f8619c36b2ca732ca46f2d02011f5b057eb7eaf6f8f450b6fc7b2e3b0deda18a04734976466f1e2b91bdd489a7e653ed84d005d0d1b6f6dfcdae197a8549704a75b81d132b3ae9ba15d7dc927f1feba97e88255f6653d7552af8baad1026e42530251c16e0709f708a769e31ae0708a043301599f365a75222fa8d312a28d024e9199f637c676cd3ab37564f86e2e843bfb1f68aefc9f907f42007007cc6e0780e237e8cb131e960ba5c1f1e9942207523ae7085ffb89623830fe49998a95f731905fbceab58f5817caebe6cb3c564ae348a910ed6aa5d071dc64a55e6f3c38a9992f7d066b85270f4b0ad5f24bbb6562f23c344c1f2cca3dabaa7b0fb61f03df96e2045aa62626c8f3d24efb06c5d14c8bf5c2ae8ea71209a58c4884175467a8498fa21fcfb960e2367600143aa5fc79447906579d9e263677942c074694792d35233eaaaf780fe48e194302bec8d997ea8dcf71727c5df714e98b2910c8071864144cc09afa10eed77913d5421ec07d3682bdfa4377d20dc7cfcba936fd5d9409069c8e0db46c50aa12cc2fb72fbebf9f22e9fba2a9d051e5adabe690280c33e3f5c7501f0325bc5dc928731653a734e7b57b50f79ede568fee082b4566219f722d39db765dd726814ef9b64ae1a95582d170761c8610adfd8d25078e4ce2346dc65a59dc27d5c66199e7590314e4a450aa4b09fbc64b8e19416db132bb70ce057951713a74fe132f3bf3e4f06ffa46fd49da2d61c506aa1fbc737cae3496125246c7332c4d0a441db7f5d4296589178fc686ae372a191139deabb920267d06e358cbe4285b6f95b4e80fa84cc1075db00870243f4c2085ebbeae558f66b4c84dbf366dfb6805c889b2bad0e8564629269698a1e4adea9b187815e7557127a26c079dfbacfb0185700708d136c83dc8154f3f5052e49b3264019ebf1b13245772b21a3c3f2486650e872a76899f392b9affb98b10934fae9dcae7b995c5125b3f252c604b64d1b07a704e7b1bfa8875197ef9a8876ebde3a356dc7008433b1d0a45b7ecc3cdec6b15bad8032128e479552114a9f0a826f7f7f70bea35d316357204b603dbd0e3b82deb6d80fe5c0005f0a3cdd7e44238740eea92d5b312d28a031a657e4fed1d4a1f3c96b36a2e1de8ee639548d85e052fb4d1d897ce373ef0326d5c9e01cc7896a6e83a4b683357e303cd5cc331d787962171e9d6fab67b7c5083aeb836971210e2f7a1ab79fb5851d35f065e3213709988fc61e383a503951e4563957968adb55a018c3b09ce4af4605b8e37a382d1f1745805d91f0e05d1f5e461af4976abafc81d730e635b98cc2e2346b5258868853954de2ffde74f525a68009b36549993493a8913dbf4d37dc7a47a0c975a935f144f6d82f7882bb5bee215c1bab9d974296d8524ddb51123b223ff8fb53d41f9577da334af4057e88ac9a106058de6b1c8683c12fd89636503073421fe19487f7719d87e825b09e888706f1845161b464b26cfd4ba550e0daa01d864c07f907a46f6f31a240aa46576d791a41114526afa964d41fc6aea4b693d29e2a3c252b4596dc72b97ab836a5933ec1efa6395dcd497e3157e8e225edc9985494e75f2f81e87d4f80cfdc2310318caf656c46107bba8eed46b553846086a00c7b2f84c90527b7ba3ff91602459b54f60e8ccbaee5402f576f6403d2013e4ec3139bc57bba8d3cc321ce9718b57a3169938f0101332e6a5cfe896b99d49dd5f8f5d9931d2d71f31e40f37a97238261cba7e081641aa3fcff27c91ec1fd8a88584fbd753d14305dd32a29370ef3620813ba0a04e879cbcfb696cd0837a8ff08c45d5af660e7c09170f46591a97c43bd545d91ec557184736a1337eaae2856ecf9e88d96ff68c971737d816f8ec24fa728652e20834f8da1aa0beab82a8f911aa32f3125464c5ccd18948779bf58eb5d32549032698fd0e097d80b178bfc5570442c79ef34a1be027a9c46b64c900a41e17d87f452e9e9da90386d8605ef0acbab7c8351d584961f8d6c68fc9ab6898d46281a735d6cd7c2b71b7b37a01bc121c57e39bbc9aafae7f2315d4d8f7c1eae06bfc28602e0d46125c83c9236f08ac129549f1e3e6d866d64700ec98bc22f3ce2aaeab8d671e905dc5f4074b64423bab6dfb35a50873fc5f2b4d8b00985430fa52baac11db3837e6fa389fad57eb405f7581078a283f8fb57e43bfa022c3fbc98afb472a68e2f7b5996049f5adc0792d31b06e00440f03512a0cca886243758a31e2290ea37b8d101cc2f41b847d08cca5bdee58fab5906e00fa031cf1e80ec0293f6bc5bfe02772036d5700b7c3458994d746e11f237f2eee3e705a2f5dca6899186bbfe1069f4380e18566f9a8997e45dda6776bde059cd2197588e7fe4fd3b43163b4b904fae2cff73353120b74130e5d1e5fcb01875b395210b2e2142a17e75de36095e4fc14a230756c38a17d73c787d793079331335fc0e15d937c21a3945e82acd8b11619646db01741984059a085242cd550a379c7665656e86277c729464012c14c6a2c31accb9dfcef52d300255d5f20ac3abd3a7688a1cdabf08e068ef205b23efbb954759c5b8f2f453ad2d66fad28d68af2c505ba6ee0ce84c07aef77bdcfdd7d9a1d27425733a140b67966539322c0660e730db73620e213fe23917016907c87dd8db6507e1960c0b70635e3cf6f47991cc0da06425b9d803bdc0ae571de4bc7f5cb7809df1d4604daccdf9ba2fda43c7581a717e92f5e48e5b6fa6e055a1dbbaa4ba6617c240f04a939608ba0d9bfab4e32e95126f227d52680424cb5d3b77fd8eb10ada3087f27470bff1b834d8e9bf0394695d88305bfa3b1edf99a1aed202ee9cd3e23c5fa07b7230316883db49c581f1e2214a379d87a64551dfe7d0e9e6cc4d22f920343538e79b384a63708914129e21e00a7d2ef501465afb9b1a67d1c00fb2e112ba2ae87dfadc8632449dcf9b879c927911042b9005bf17cebe8c3adf0539f35d6809a95b983063a6d9d532aacc674556f87b97e6aab5cf1e8230502c3e016e18afececb9137bb5bada3ce60b5dbe786d6d0073be1ae692a01f1ae6f64d83d2e8f2042df83d33fe833f3b6e65c1112730eaf0f84410b8b2d186e6e529c393f8ef78d351e0dd191c9aefd3ffc178e3f26719152993cdf214f1652b43ccb1b27723e8e3adf9ddca3e6f37f119dc2a48189c50a830ce9c8bde46a69475571cb8f58ef1abc8c2ed06a5d8955aa25b1f7e01a60a84273959b441503210f32a9b1c4b5fd766e0df0803d468c26274b4d226fde43cfb530209b94acbdcaf1cdc9b95e70e889167e133340447","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
