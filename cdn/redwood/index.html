<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4f7e8eb99cdf467bebd84a4a896813f1d860dd0ae1244d7c56788101de04012add4d843b8b7ff7e366895e2cac3c6b86f7403460a3a4269793ccb4d7769f6a22dfcf8f891f2f26de6588e2ef9ba9369d51adf3f2d47d127357c4249ca9d4f5de7cd587f2dbcea993c0d61416904411dd354d0d64194d8f1bfcfc9fe96161ed4e5c1d9c4af27cb7cf01495dcb9e96a96ab6809cff5c88eaf625d67c5152b848fb185f3db21e76dc39b78c3de8e39c14cc06bb6bcf453da6810f32cc78e010edc134e522920f8ef9f89cffc511c0cd59096f4b04fe7647809b9cfb814b414821edd2bb7ba0a882a2fe675701c9ae52d6579be650093111e8ff244e55f618da681139d6a1034aa3cabde6d976c6605016e1205ddf4f4cef993f4db115c1473d4a8793257ce42247e9fb506dae4b3c8d6fd80ae7cf849a7ff8e88c8e0b02abe1917096dba865a504860aa6c834ea00a2a61c3e391643569e7f5eedf17db68a12b516df096707c81d7f80d38b085ce525fae32cd77a1ba576d0d910f3cda1db29436d6bbe05151ce84e77f607b415febf0481ab3bcc5517484f7d7cddaef5b022e1925aa65bd548c491b8880fd626789ac2cf1ace89419be7175651ff7a5d47aa7d24313c8a937587e177bcb71c4759917dca72c9837977dd4f0f6aa91840c5c58d08d85463c3fec6856dd15f6df5a3dc8e5f66490a5e7c089074aba8674bcf90a05d6eac33a1a177b404e624185231c816fcef3c0ba2bc280ac47937854805f7a0bd079170f2b7685a61b70d9e4db3039a81e0d87625bf3d1b461864ad894527964fb32ad6d85e1782c32074819cbe3da99c565c7ed0f13f2d4409279f3c093af30530fb5941cc6761973b4c432f706e98d82933ed8611b5f2ff038f95a353b62aafad33c49f20aeadc516f6672f26f3af27397d0c0bd5c6096738ec1752a9fa724d7d51dceebd34961f28c4a6a3cf2902a74d3c623cad6e44816fa3b2ece73d872b9463f070532d1e372c1e7de1886384e4d01a5f219508c1e8d5289f5e37a49d53a2dccd30bc7ec1b711029856c6b4f328aa6994a8e6efe603616e8d43221006c40fbd4b8d7161a0e94b770a2e0d901e9b840515afb60bcedb8c952217abf64da5c5ee7e106176a8f98390d5017991616c2d708607067a9bb358b320c77ab9a27f9e4c9ad3a817928d24581f491b273937842f8ffdd60624518dfda416c6128fb86146eed3e7c61b37ff2822de282cc1f2209f0ac60b649edf71a42cbd4ac06d04bd7ba4b77d17c33947bb9e9677eceb3b3efd2c403a295f71b5118d487b2ab2b0906fe088c43c53767b21261a740a62e92c3832bbee4147cf8d66f2810939968822c82a3db41421e0be3ccc4c6aeb5a7230c4ebcaa4d918a5041ee9f67cb0dd51a21ad46936f6b30e73c4c2f8916576b8084e0da354ed12a087e030f2882371728fbe1629d5e832f7af6c5fe3a350ada0ec038df89e45d733f5c2ba1965594bf42775dcddee383636ac0f4f1ccb3ccd90c32b09c7b4ea790f7ce5721354d8f27f73f269f8464f801a5810dd5cfc349780263cbad5bc678d31d0ac542a10fc0b003ad3d9d34067c3d2af5668b3be644f24289381c1e5c679d7bcce1b47a3fc4617c2ea9f8e41f1f6725783307843254a0a6cca30015b7c5920c96b11d581a7db0fa6f46baa06fe4abf8fe37017ab2c584a5ea5b3f7bce6efd745ed1104643c3559908259790e075c12c2375a6f7525514888fd5baf877ed824f976fb36ac6f9e1e7b11af337f06de2c1a3a6be8cd7927ac7c5c5f30f66da75fa7125c0fda60a60e3a8a18896233b5dff05aba3952dd85a15dce87276e399afdd527bbbeefcd61fa4f6a2ca974b61d4d6e0ee1a0a0b3e009c663b4eed287fabb6b1de176dbd985b50d232205116da45d30dfeec2fb19174309c4ced257e97ad4d10f58da8b6c0c9121463861ca9d471d15dcc69656cc209474bda4ec28597cfdb7997771eb0e41b5f90b0ccab652011ddf762aee45031c2c0ab47093c6dbbe0f2fb201ba68cfe3505e88c5f14ac6709484bff152dd4f0e77491ced48a2e16d926f90bef9785a5ccac8c4a0256788c4f81d9cebdf7489024926ece531592df7dcc307b769b5d192bf11189abdc2f2aae784df64f2d1ab8b45e609f1cd1c4c727d720eb099c4b22d7f79112e3cec28fa31d9c13490df7041ccf5415f78c9636236dad89ffdc7e18dd687e06f39483d5f0a2f297accc9fbcdad7c728e4c926e6c23c4d11d3e7d3bea600a634993973a84c2d266758cc8a7202a58a34a2b30ea869287fbfacb68618bd6ea0394005944a207a4f1a175088b919379841d3976a0e615490e450603b81e04bea528d4ed803aca2e4e992b04446d698ddf312f3cb7ba387ca0a062aac594254894d219a93bf4b4a46eccbd58216ec547ddc4b73df9333d5b3c3f5d846e848110f06bfc74bad9d2bc46cc8cdbf7a12da559132211bdc4657066735c1579bae4db624be747d9262dc2e0bd3dfc0d8c647b128d4ea6ddae967b2c846fd2ab9984e0d6886afe3de0ac24d7bdf3580b0e5d58a3aac6bae09d2a5dc360159bf9fb3b6e73f50b6c382819a446d9e5fbab5f45a35f23903f57b72ea0707b0c4cfdcbcf83d6f3f27d6f0bb6506974f55f296ec36eecb7a7a427f06183ca0075cec22388db1711fd72c6aafecce65aadc0bb14a049ff5d2649757f18a56f22c1fe2cd0527324e801cb7cfa85bd79951bff158cf4b628bd020a3e9c7e532ee9fae70c53905fd5b47df5e46c1ae1cedc923fc51483710e9533c4190a47f9636b1957a4a37ee0025082ee7acfa79287b54ba1376464aba1342523ff0ff6c01765f70ae17951c4ebef0920103db09453c6cb4c9932c08dc0cee5cd3af8c14c901c401fd5b915b395df27ddecb2fbe6f6acc1227106e3f8e4de9c84e27549fed572d0e2965a5095aea1e4eb2de407493036cfe836d7f8de49e04e0d10905eb2b4d0b3cf76143408d5bd6e6a76ba5f01e215ece279f3ba062f36b0e911df9423d3a34098459d7758153cb1cd647c7f085f0cd165cca6cde0f00f8e728727e28e8f348be594ed624b2bb4b3754bee915f671337fe5bca33866bda82ff276081ad2c43bf57f2d6a53551c5ff2a4846fcf76500609d1017762d87c86330578026a451121428ba87a18d7fdd9e93df2972fa52dcc26de7694f9551ccfb7872fcd626b0367ab71694293c356a69d8e1062334de2aa4af13ad30020cd6b8f6387095550dfd6894f02370bbe971630ab3f276ef7fd57d21f666f9ef02c5fbf19b9025238ad4c26bfa1859cba0f7df665b92063a067e6faa0e1c5a6a7a8f767930d0fae1c06f6b1c3fb0fa48ee9d8f8de90d2be26674d1f337bd187077c45ed3c0acc53389ce1778f7a5f86c2821550650a5cea001742061c5ab542b98265134267ee7ecbe0962244d471f06acdd5da37d5d5b9c5cdd936a61e07a1170f30805d4baad8bbc6f1633e7f380983eed199216e1925666e108eddd2c8e192ab5e6b56911b0bcb2ac93cd7d557344947419052fa5d2da547497879dbd6cf57900e18ad345709945207b1982bc905e27c969a5f80e47a1ba8261b3616b6cb9b4f79e60cf552c4ee4b46d81b2dee23d4c30c12917157ce6481d0a78875ebb79cfc2aeaec15cb727a0ece9c8f70b31cb888e8748b16b16d24cc7fb1b2eee8313541cb853c311a5e37d0e6d5097cda4e6f4187d73e2032fa85fcfd0718855e38b0c81173a118eb9d26aaea7b54406ea35da8f39ee1ad2245230afeec3bcd3700021aa98fafd9aefcf52491a276f5dd240f8b1460f97763f4472ced2702940777a96e865d3032909fc858240b7ab55b4789402ff95a451b95a77d4e1760fb0c67188b747a398f4c9f8545edb323d8870bf089b578413256e652c991ea10887b5ac1a463285d91936f1da3695ab1ec92c19959d6c884d190da63fc1dc3562c4cfaf477eedae70854c7c8fddbaa97f5f32f6d017228105a52ab091f4e490a45f7f6bc1be54a7909f55eea96d499d4ed13d15af3cd395e08aa7ef40c249c1406a4b4dcb2f6d001b8239acaa5a1b158f2f05aa4bcf941e06f37bf0843d4288271846bc1d8e3cfc504ba638ec42ca51df13c900e07397f470e1e1cc5806792cdef7cec85e03bb060bbc68a23b385bf21f71059c4ee446d243dec5dbc41b535d6bbb32e1092899f0074909ca51dec15dc667784828658072afe7fe79a95b7f7c03a2d275c2eb322efa4c79e22d2d39e7d7e80bd9449a7208700d83a19c93187969fa687d0e1c7f5065d5122562916f3d5df829e13d3303062ab5f6bb2dcec8ec6cfff7124582f792418c2a86ff0a7b87ff66299dd000b846f85b2688bf60dd9db6cecf98810ff1672c9f30a6ae7cf35d4b06f9fe97340d4cca28f949904a771ce02d575a1e136aef0ede33b579e534a8f3ba55bc937fe9a6919abb625309c2f2e3d89cad486e25e49edd4bf70c4958e8dd6f9479d7481a21ea41d49abf68b3c9cb41815f6b0808eca1402e8b287e0cdac3048fdc4380d4cda9617379aaf1ab751f6998f74b518a866d7cdf0903c93fa251faf08b4d821ab7627646bdbabfa92ea1e499a2d2230a9c5725cb2642f2936d541d0a1db6cd307b3ce075bafb93aa3b6e465fbca0313f48c18abad24c877107165d3fe8f79b74118de2f0eee93a4eea4837233d2ea3847e416755227666f36b8d2cf0eadd653c23373415c35a2593a3f2e39b1626924c62ed27c8cdf896d9f1087ae970bf8ffd1db76fcdccf34aa5a445c27f4dc654ece4346db41f5a32155b556f5015c297a57700d36412fd50f69db0f229536d1e6807e4750ebd509a9657cf77260dc5bb650a898447c8124933fdf71a8f07ab8fdf3cac4632037f7c4ccd5085d0205f7165dc4df8907caece4d7181c3ef684fedba36eac470b7765fcf37ed7d67f1bb1dafab59dc082bc4c1e118ab5892640b8c9b49207e36ab1ad2da501e58a97359eba987f818eb8479d2019d605557a418014e1cd263dd611b92a23955a2cebdb5bb61069d9c2c2e724cbe959b3371cfcff305c8b090db0449d2215857fbbc1b1ab543522d4dfc46511e32bca325c746c88ef2c969a45fb911d9ae68a010a033a09ca726f794bba68d7b0c7d0a45e793204a72c486d2a0e25c550f88d508720f62278554cdfb02cd585fb49897073d41d0665618635a5e3d7fc9fa7d0a99529d8956dd62516068045392742f317ce9e61fb63cac8be6f9bf38b2f0ac5c7b8dc57a679f6592c8cf327752f02891b32885513c9df30c3e9b110db6bc242b5f809cee94f487385cccfdfa249aa5ca677977c9a8e313651aa122bf587107a029b32301eae2d302dc4962163fc7649822d0a687e6dec2cdc5110d7dd6428113bee562c101f4e80cea6f00b536b1e73679b2d396c8e75791bfd29206bc8cb273663f6e546019243b1185eb5a332f2df54c477151ed4884a14a9ea9a948611123d79231d7fb7206c9b935afc8ab3cc9cfccbfb959172b71bb252009cb0ef5b7c9f9347e97aec05ea53b2af85235d8b1dfab47183b51beeaed85e2a4d15fc01ea3739ea9e220f878029b0a657f9e60e880f217957b9ac3d7badc2e8047db9f64fe6575d8d20ae1c63861e74d2ef7329467b24de16b037a069e9462c0b5752937bb0770c0cbca1644e06ba011cca640c570a64c977676a59c34dbaae6244b615f709c507c7a3e690c1fc356a711548014d21350c4514ae567275a9aee9e4560fcf172639fe12998f3dd1b7fe5269fd7c8f0a1f41f7bf4197dee9f3bde10f102fd27552592f65f7a9484011dd8625d13dcfe3d75e0e3c0095baeac6c85006f0bcc66e3215f2f7382c9baad4b1712bac5a6d7775e7f327335477e691368844717469f06fff5ef1198827fa8a4111878eac34b2b5c3c809e355e8f1b6fd6960acffa3513e061b629a4792b27ae48bc1df2c92a8ca1c6a0f52f4bf87acc2b33f183fc89e3848e3010157c53d892026705252942bcd5858a482d57185ef5263db5e4cf8613dccb7f901f1f6b89adc2189682c4ff0ca37ef54b88a8ddb10e44ceab49828726e9d1eefd98f5bc495b723dcc57ec5d44bb373049807eeee6cbba57ec78fb8fdeaa7d21b6b5326f3fb45edc85fd8272e8c9988fa88f8ff73a53f8bff44698998010a8e67021d9bd23bcefcd6cde0f6ccd676d96d18c6df9070a071cb152586d1efeb1ae365fee5ec2575797dff3d966b18ad5da682e88f6194bc7c21f6901ed3e9e43016e3b838ca88f5481777889d9b20db69f8cdebb3ce08d82505bef7189dc0d9cd7f035597eede5f952a0e255f9c32ad0d37281ffa9a677acb907f522bfa303d94c93c58fbfe0f77b78eaad0ba2ffc6082ad5d0c0ca8eda4d9f316b987951fcf85366e5836cd405f9448d6ebddd94a48efe53831a432fd43a0e9b32a95e3ecb15a9b5ad07cb6b29cb902d0d43cc8beb74229f7ebae02f02e36686ff8dba496ca09742ead51d3b3337edaefc8952e350b49586f9b4016469289195826ddf446233d466533a9f4c7112d5a86a3ef506cf7bae5cef2e38a50b5a0dce80f6b74fc42cc286288127c63bfa9b8188b66c984cf688419f61142810385e31c7c9e57399e3faa81f99c2df0d925f4064172a0e38e574ded7affb023b8282d2c4813d80020d3cca32eff0608eed802f6543a7a39943d29013fb31e8d528e414b5fc3f6b8c6af048c52dad2e3566539a22cc73221c0a1624275c83b6b9844c4788c7381da90b303da1f3a173599df13932d9ec9d5ced9f4e4f5a7ccbedaa348630c9b585cd78e58dded496c39112e9235fa74853aef6d5cf812ec45fd4780633fef4eaf353f89bb2a4be767fa02781c5cfefb1027cc93ca6a2e296ccb74c1b6292b59d505fcc75c0fedb736b8876989c96af1e37cdcb5ae28fbe332ec649404e4eb0514f67221e549f26b56dff474ef1e2230a454264d9bfa97f174dbc667f35d767839ffa27a2e4a96ab645a4165b71daa2a955a1b6c8bdc6beef5854cf39423cf3a660e2c32cb9f3e60fe940d82f8a0aa35339ee26f768a781bbe8f01cdb00dfd4442f2c12c33d359ef64628629acf44f5a2d36923ef1e8aa65232a7a901eaa96d45b9b83a1a1689c7272bc04fc5fb9092d2769f58e346a24c38cc89d6484869be7315ff59f8dcf13da73d3e4ab7c24ef8266db9d2107910ebe6032c685e2cfceb8eca6b278f28a13a8dd027d2884b3e70b622e126c8e3698b1f1c9c4b3258f95bc8f3388b4b9339f73b68885a14a5c7881289d568423b8f1719bcaa046bbeb4734b06cfc86e4adb5b82938fad23d2d6b490dfa2a884b54d8c27aba55e24e7ee9edbbae595373cfcf833573e4dde5a349b6da67307542e2199e4e17f25ff641d6b620dbf416ccba80b5d3dbf65301e5896447d64fde15317f5966efe20845e2dfc8d29aa51cb0192d8b2244a53fc4190a3802af24397ae2f87a5cfc58dc153455bda6b058927a51a816223a638b63590c5338d5da00f4117a805468b55225a51d3a67659d503608c5ab2d945de9a7204ccbf783003f7c2a48e32a4e93224845c516e2db4559ca98a18b3754b3a7cd8e0ce930a3b30f2eed017201c5458852388f2b41d85028ca4ca80de5f92d047eb12a105dc2a5da9f23c772fc5f105efd6114e448d2ea77eccf305cfc538c19de2d258fdc04aa9aa36bd9b7552f734e19c36bc57a64a5f12f91bab44743cb4407d0d6960fb75f75a92d666451eebc5ef65b56171579043e16acb1e87ca7cf59464fa39b20ad19d7c57afc5ea27fcbdc574a9a54dd8ae700c7e0a0a5f7c7bd60da51143021f0b16663e0d9f09753893d452c8fc3727382bf533f8d4107e407115f2cf7fc7260e3860635b905fb05686435e0e612f8e8658c1a9f607d0d248ba74849ae7a2d7b006ba08dd032cddeaf46dfef39002b2a40fb97c957ed015a59c3712a39faf42e5815159b19dc30c2841e21cce0815161619e234f6eb05974e118d5d65a5d012bdf848535b25ecf724f800a14115e9ddb5153d8cb69f54e58ee4848d81555b1bbbb1137c839c5359c5ff86d2faf69ed01e9931b88658a124f6ef95fd74f82089467a8eabb66c37ede8f5ff300eb853a4416f7de161751e3519c476075f2e92f37347f03de94ccbc960f63cc4eec2a5c90332eb8812d90a371e8b06c80aee749b65783ee35d076c3438d46b37d7be773f77f7f6aaaab68c213c1bc25c4700b94ef0150cf2ca6e0765c1c0bd3d8fc4fdea5802128f042d01554738303a112b2831529a96b74806cb5347c6b20c795f491bcc51e1c36432e46a169d5889bc3315cf3d68eec9597c5baa134735f0cab14256ce8129ec77cf9c3486573c968668e7d356c8dcafa0970f10d964ad411730fa38c25b6b96529b06c51e98256701ea5e21a6838ee1a287f4caa850af8ab4463aec26ababc6eb7fb70330b24bae568b3bd0907a35bf080c58fd7ffc1218300c7415b75d87d763e35e6d4023666e160417181621189ecda131b597eb075d5e6f5d1908fff65febee17ed3936b9e271eafe954fecf7690ae69a0ec5013366ebb44e064fda5ff06c26117f8afa996e23b2615e40d962b924b92d7148380ded8b90fe0d1148837283b1c212bec3307f10e73f1aff1087cca6d4b668b5083fb080c1519c0e631c8c26bef158cf351a7a9f67a6ec32ed6938c5474207827bf24a310b49959d21afe9dfc653f5d59235a2f3be7e0acc490ce9d068910d61d9dcfaf29f9d7c4bb2da58494b6ea493f6b3de7faa9ddce7d6b9fa98c35b6863d7b80b1d84ea67168218b34649471ebca9c79a0e5a948457a6eda613cf8f1d996afbc14684fbcbfc882777644d2f1646ef2aeed0b62d0770fe06286ee29e708d88e584fa5773be4c4d6639b595d1f96839474e60f3b1f0fd1428e8c8184d5e5f877fdab8a3417e8c430fbc0f7933e6c4909413b1846be3bfca70d0bfe9ffb1a2da37ad2db94ebcf8e75a277ec685b1f63291ef25fc311c6320d6ef6da9f09fd60c48b218759d02f78c68f7ab7c4f88ab941f2be18b31e4fbeb8ff2c719134fab6c2d61a877988dd4941fabd783a97e55e506206d92d7b665d5dc46836099191c7f4a005414c7f1c021fd3da09124d89551b97c63a2b3bcc2a8c43f41aeaa473d4b0886a4607a43d0450595dae39f4d0e3a0bfe5f9d83016bb64cebac811dcdb6b16b330f4493391f83b4aa118e49cfc5d627cf21cf75ed6a55d42d6a0bdd2a529d41708b5606e52f92a135146b7a003a428c62842bef52c79354217d83da433d221c93e06c61840920d34823ebf0a950772a8bdc17f1c102abb819b7454ce3be4f2eab0c744dbf2bd706a9ceb981520e18caac247095407f3baa83dc7671658cd4d79ee044b5a1f97390a890f097324edc40fe3bddbcbb599272abe6b4f1efda02dd77e9bd25cd226ab27b44d85f6309e0aea5a3982db17e33e6555d87eea6c05cb3232afca109aa4800b86b8b323c7102655f33be5cc4786e71beef7617ec1078bad2de2c61ef916112fb52af503c6db6241b783ba7d89e392e3e041b7e0f50ffa569209025a80417d45bdd523e28894dac33783a679683a7a6a399526a5827b048319d10ff73f7d7cbab8ad894aad55fb38d35806616c1c6ff4a39c7ca6135a295ab2d99cc59cd2a8d2e424e6570317b42e0f31d0815ed053c22ebf1475df6d54490b0ccd452438394cf4d8465a7d6a8c78a7fc22c60b854b4ed23f8618efb1fb381e341243cc12dc90e08410e596a33c995e0c420cf5801de4b318968404c199d003c22db6e4a0f8628b66912682cadede2e7c91a7d688cb90eaea99d6a8e4c0e1b933a0b75abea0690c99f3a482f225c5bff87dee5260ee2c4a4c483c1c4f578adf92c1e667e8ee80332ba18a74cbe42523a8cd6d1bed257a2984e648c32b2b05833d302ef94222ca6126cc0005885f6e25655cf543b68d35e68a104fdf0066ed2d36d594b10972cfaaf01a3710dbeabe03c354848e4882125d4e7efde484def3f5fc5d7b13edd6d5fa9d5bc5aab934945a3991b621a8f9c7787ba7c2139deaa960e9fdbc9901069e1f9e95c5094e25ca8e27a5e93068ace09877cb2b3e796931d33575a9ddd81368a027c7b000de910ffbdbe792beb7f5746a2c8cafd864df610854ede7567c9c24b1d4ae490279197a0c265765fe77502fafa938dbf1f5618043ae7616e914635eb7a9465a45895a3e45f9ea64af689c825cdc318de7dd9e2ca93387147cae58c899396ecf0610664ed54b6bd60b43991c017e164d2a994e80a1c9de1d01f0ba1854c6e5344983ba0e76cef57a7ba17265ccec49b1186ea998538ba43f0b50e02f79a0d4da961b39ce6e438aba0db732ebc870ca24aee104db7b4f71813ea8a82004d58c0b76db6ef1ee2e18309de2f7174dff6aae318f1a6dad8a8661ec9d4cde8ba84b50b88758c66e090e8a695a401984bc97eb2a217c3b1a770da54cb61c89bc7211521eb1e0177cf156b28381c4c4378ca429ef970aef71ea6ba01a35299dcf6f3b242cfe101102d197d3cf9ac2452022691df29ed04f8f8ab7b8b4c4acc3e290b4a205ce7a2205553f3ec9f328850291dd7f67db49d12141a6bc125e11837f1585cc948dcdc29701273d95606f61f4e60b860ce4d6ae174985495cf19f2473431437e4fd0c40f1366e4321b143ac9dc44197a47c5c3750f3e8771b4188f2ee78955d325a2feab28ad42676c9cf306e77b7f0a65fd81aa282dbc226d13fa7ffd97a6026fb6a24f791c2d85aa0cf95944711cf6157f599ce7b1b52b86b9d1f13ceb2dd8484512c8a354dd5d21fd37ecb0a970acdeede93f88426e061c57e555b28893985ddecc21c209f47cec0f6a2f95e8aef9b3441593670ae304f6f00feb1ebb2a890b9ef650531fd070dbabc4b8802d97875a31b4a1c470f3a1c978ff105e9818553fc0d75a06b4145aa38adeb9ec6761c6ebd34ef314027e42e5e5445aa3e009f1efe436b8fcb5a87f81c749ee0e87ba9f151440551c00c0e16679f57894435574eb0f4b03b07819d99e14def583d7f88aa7844b4c2998f7936c5ba56618c87f3b1b6894a4306e3907e78e5546b32494e3878b6d86c26be72045e1608f40727ed5c6e755972104d38cfd8300e5fce6d97bf7bd79ba1295f587160d99bb8ead1ecc5d28996bd1c5b39ada8efd14709d664e54cb6c405a8cdb5744eacd470f5dc1ba70601e758f1ef692a1577c740ea135a8634660819dfa1cb83ac857087844850d728d751d8cde13957fd108570fe268cb05e9d0d61a092fd7ca73ca83e1d5671704557f719f693fb52763b51cdb011e7a83fb75b91b5aff0da647fbcda1f89b084e28d8da988ccb82fbdd82a6a64a1fa7bd96ec726561a11f7ce818450e71f1a9725426cd5b8ad7d4424cd15ba2a556fd846a8abe2d6ef62c3ec2bf9280fe0127a76fdcc60edc1156b4b9cd21afdec6b430cc27f79c55f3ca96f017c19777248c9f8f6f3859588807fc0122eaa8937ebec9db5ec8c4eee4a6f23cbcc32742f85ed5ecb6de71398fc7483b2f74559e55ebc71b7bfb02d53ef6545eb8b45b975f3ded0355f8f1c4da15ba33b7930db4c446224b954e44dfea3671341112133cc8695e676b2141527a3b6ecd96b548b98e68ad91052b65b6a19f0671af25c75f1189ce0463973412f049a1888f94b475b67c336401dd646b094745319b1801f9276a6442d658ac3116a2a244eef3551eeaae7416a1978ed97b2e54b5679e77d4485a5a2839f4c43d3280be4e4f2d733d55de475d5dd955df455e159882b4b724313edf636640339b6f1145cc8c41c1bda3e14799b7630524a44da6fc463e83fc83796e89e801e2c916c99c44ed3db2d61704cae87077a5db9bf533a810db429675ddc0493dfc51b6b03e80778795b98da92e7c12151b6e9b96d73d41b1ba41a1502352d9f78dc9508a274dfe4985964117661d4e1ea220adb7b28c026b06c95e0bd20a6d0fd4d1a33944901934fc81aecea50d5b2c5f0ff2e998d8d9a8e54d34603203eefc124b7da3771e08ce42631f07eb5118bb0bdf26cc069dccc78763388cfdcd68bd4435a054dfd6b250bf8cc00af04b87100664f356f14e5e202f2ce670e1017807b504c481c9d2262d1fbe32013bbfd28e8167f59bdb1fdbf41940b258d5c874fcb3d9c5a6506f470befa810e1d54716566686555cc8b4c51b5f25776c79c6f8aeabab4780f917e0d9cda644248a7ed03bd2405e6649bcbd292a70a15657ae085c82aeb847c049538d95461f110613a610dc3fee78531075a22087814436445eef2b0bfeb1cea0ba50e8450382ff017a99c5b7daae7ea7d383b14b689010b7270c6f35b22bf5c5c4afbf5889ae73b49eba67e1031c84f3f0b3a1c79ca5b39aa3d26fc861ca96dac6f051fa5c6ad61ea50e179803b0025425a05a341c0e8387ba16220f048eb887154c2bdc68375c334690e34183f8b0c93d65532d27b9b4f4d80ed49a78dce0366cd377a8aa941c85f19183b9205ea4e73e4efab8b76abb836de32d6d4b4e7720467090409149617abf228da0c364cc0027bf8573ba374cfa4c9e0d99a1335b7580d786a22a732a0c2644d05e747855e769ebdc1befb61b58e53fb64724e7d2ebadfc3187795d3082fd003778fda8694802fd107b077a681391b4c9e6426de90aaa21da9243f70eb33b703a7d6f5b965a43e87ed01397cc47cd1fda4ab739ded746300035b7cf5abc95431f51623571e73bb6bd1dd62e434602f341ca948b088e730c3965bad70eff2ba9fc2cf1a7b560bcf336be6bb55c62e8a6702a224999bc889425061aae4a4f87478a33aae273488a1de5f716fe786782fe16feaa2775bb672b29023d30f676139aed7205bf91b4892aaba9d3f13d857acc8dea877736334f911295e90cf34390321564eeb54ed1509a2070cffeb20a2fe9a7a85b17670b514f888a7c39f9ba6f3b44e3484b74fc0bbf959378e56471d9703252584ebe6c4910446af4128c0ba38c1332f7e808bbd7c3b55b76f514f6070675525498cbbc458b704b91c7c22ac73d16ce7640d08bf68db2fcc62d8010b115bae8edcf057d2913f1656ad7462c35c8539f925a059123e5b9af926e2d1fb32b7cb4ae19b220d8477587b6032fd8c3c5e4514895b48b668afd3dde12671716829b2327adea02f432d7a9795ba432da70e2395492513bcb9c1d242ebd4685945062245aa6732b3d0a17b9e0256424642bc6967d95df8195c71d46c3ad9c050a5a7333c78af0c87afb541d2bf47ab5a8962ebb9e0893b6691ea1f63fee6425727453cbb5cea567718a93975117f1889dc9702c5877142b85ed2cbcc4f7694415b5fc5abfac5ce8b8c0a3a6b306b76ec1a8316a360f4c2c1dfa0df994b61c7de07cea4b0f60a3570d9ca5abeb66b7ba7fecae2c9ea86c30b5a716faee060ba165002045d90df0c51c0963f752b5e03042a62243856f374ec95a6b7cbade50c2e241c7b150e5b5c5cb734117072a44bad140b42f49eb610fdeb38639a843c5343f63089caa478d2ef2327189ce6f12e3fd7051def5023189c6472ff384e2dafcf00fc5eae3332feec2f40097e2284de843c7e59c9bae21129fe79d86afcc3f7525315e278d8ff1b0dcac60c522be3b2d734ef23e7afd8566bd19af75229101700c45e6db546949afb5f2e2ff36e9d9a111915f705052f878ec08714e2b972be1cc1534e5e3ec88b5cdefe7da3ac00119e356c5f3fafd2ba189b549b66f886f6b70c678ce19258d74541b46a92524f0ff8dbaa2a57fb72350a1b059d1c619e66d67a86e06bb43a84be0829f86d8f967708ba1703261ec3efb6720388fc67b9a0677de02fa4e77cfd58146d8f3c313f206bd638392d4350a6e50cee9454499adc1d8629c90ee3f407996758538faf464da286a2aef9839b11758df0a1fcc3ef9106c42ee29cff44c0b2458eb11563002ef6ca582c0c374f9de8104910c76291a74afc3440ece06942dd1a812b28678e14db890347561aee2d64b67b785eb15cd0f7f1180e9e5a5cf7459f0085a22cc9e14ce5b6d430e3f7dac7fbc79e112caffa6efa809dc49a5400b24d778961c536df022b5b5de8db35de4dc5f4fb26511e33814a210e95a72a90037c01b474b378802cfb532fb7c4102f5afb9cac9e1e89633b4375c0537a4f0307327ca4d1407a61af6c1c5f4b5c18206cf77a341066636b685b39fc8b6a2c9f109b2738dc611344fdfa03d1aaede7469785271482b663c14f46140bbc44c4f687346ac8ec978bf6baea4c6d4decb8674874c7cccd9e06e7361569cb724fec4558ea5a2d2e360933d29df0043b8937d88fda9008073fcca8714ba16b64087a667b966dc6d47dcc0a5783fdfdf4707fe4e5c39d46849b6f9fa44a911f80dd8c5b757c17f89060ef1bb2e3c9e21d19aa47aaf88e0aff254bd532bd4f18971215108c8cfd40e1681534c67aeed4a6bf78241dc1207884f0e45a3e5f0f2dd398d740840f37b53741bf079c333ea993126615adf4671988740967d769e59db97dfa2140c752b97586307856f69b1481dfa8140a8e2649dd8033c08376cb48fd9c69b1c7be7eddeeeeb39c3fa2dcbaa1e989262caeb0bb1b1cf9725eeca64596cd424985a69f80108c79cced28b4c3f5c7bd617b5f0cd06c07f9ac6532379d86591c642e8fdcd32b87582d7f25ddae1e21a300ff2e0e3209d05829226318cfbb964d77dd72b258e7a9c07e4d7107ff2f4fc9edbcef8eec5c5ba6e4a47495a82f17ef0b5006906a6699a731b2669c41d6595cb33d91739d55e0c96a5ede2c5a8590bdcf64bb627812191be0a7dbfa453eb11f3ad16b55c4777df020f82ccd383525eaadd77034c4d138033dcbe8136d5a937847905312b8be30f64b1c911a697c1e24eb4e8bec1dfc1958f1dbd64834481bb2a8333d28fb3167b8cdffca3eea4aad81e1d8023fb0afbec7e496bba5365bb6b99a1d444171811ac2a62d9c3ab5aae2c4bc72b2504f3be11f6bc788ddae4592a1226af57205d72146b4807010a15cd3290abb4b00b7c8612fd4ec61f0d5e418a1cabc99a604561d698ecf98a10d2044eb6e62ce8a9b13a0938698a9fe4326192a195ea186016adac397c8ab0f0a20410b819dee3c448213005a8f622ee04c027b98e2336e545f1e557f78dc0e6441e7599d610b62acd93fb34c8392773cff34c4e146c04a56fa129ed927bb24b03e6a9da579bdaa9ee3a39a9dd8040ac43c7a7f26d3e3791f43d9977d939558bc6079954a5b4d38288b2b98951b3569b41e6366fcf9887946be14a81435ebb71f8a3ee4cfa7cbb61673e823bba6ba3d6b942e5ebdb01f34117472bc69fd141d9a70fe7f0d5b36fcdc8a8855b422d950fa0d0af7cb03f52b722b8918b39dbb8bca99a661ffcec1577e816b365a66d44a319c1df0f11a3c319f667715f17c4713f009fcc5cfdf4bfadba05cdb311f11dd40012420c4c5b723a70ed1e7b91f6d05f586c9e08cdb795386a397f89ecf60f70832697227cb6d05d296bc8d124267a62f1f1935b6bffa207c1842e0a728facdba2b7cc738612aa9858090779cffc68f593151d6a4e98cf1cc6caceab9e87b1fa411f563eced93fa3b0be850ba4bfd53f663c320f4614282a48a600ad960c02e46cef95d2654c6092285799b4792993d061c8b2e65cb0744c63ee539ba5bf11053a3371581e3fb6e7ad64ee8ad34e2e9a71ce6f7195692f7f83d2529f116ec14051729d56cb7e2b8c3446f5a34ef88f19d5847216080703a810fa568e9961a18c40613c1aa311c01457c45cf0b2c28d6d00e017bf2fdf0ec9698d161ad4c32cf5ef78b14b5bfd047bd64bb9bbc36ad42ecb4feb499d3610b4f58d03ae5c309b936daf2fb63b3cdea38448b18e45a52287ad47648c7baac93504e0032c8aa17f0431f9d9526296416f427e3709dcf0be406c8010ed008d65306e014c692296ff90620b6e16f81b2741858393e635b7d06ce935ebd15a371bf4bebcfef0968af9d6181f56967096c3fa57cc0e29bbfe61190926153d178fc2d5f15ae4471ff888450d146892bbba786eef5fa5471faa67115c906c97444cfe206a03c7b6dc7694b4df21d791d20b27a87d1975736b8a4fb96cf6b6682c1a9557e54031976c1b0669cf0efbad9d4f594ce43f894bd02ed49e48470bd8f46f0ead285bbfa232ab606f0a025070206bc9ed6b21184560b20ae8ed6ecc50ed7edd1749ad2c635a675bfc819432967255b10ee057b4f16954d1c0b2de387e15ff98bf8d91947e43df5dd6a5ebe93f5f5887c2fe97021ac5dd1d8e75a037386720d87c27362de466e7d6941e711b2a4f57bd1940506e5eed32844d29fedd75b8b84bb6d3f2ab8612898e8508d8de28ec36b3b0b230a70093002c1df91abb71bdfa33b7970132440eb55158f0fb3452b096e189193101817e3f81fac474475784b54b49fb7c5563263fddf3c3a19aada41a7ecb52fe73dd43e8136e5830cd7cb45f84a2910c8b6da3a84b3ecd7101fef4f8a3d085db324176c765012755909c6bb0dd1573d0c128a6e8cfb869d4ca327fdce7795031f0deffa525292cf85fe1893857192b144c78742fbf76d6058e98f41ea73995d521b46baa705427e0618872fe5e302623368687b95e584fcbc62af7b21fc677228aa6786c30a5218ff1f9a45d79e6a53ccebaa48dee108132e14de1fb69d947968e044e7c3b18b08f525162532c2ace8bba56165b6b30a6e2a1aa67f0b92e8f629e26b34dbec5622b08938a9b1c35139f7a4df3b235989fae4658e93a8b09214a12bccfee7b83ce36fbe9556381b648c1208b473096fd3de498845fa9c9a4a79c7431aefc8067fddc45f504aa2adf2cc0f7d53f64410ae83b13051f8f59a7ca9183893ee608d874fa56bdd767954d1ce7edc54bb32e4b4b257dafabb15e0075e558360a0121549a4c74df94a582d76b2369b4294bb6292e4ebddd3591f2c14497afe3de1bd0824d138c73f6e432f507eb4461092f7109ebd956bd06b0a2ff6927589a3ffc1778e73202930a6fdb8fcf61cd569b24177746e4d80c26008b4281d878709485c89227143cbe1c304ec8e81ccfd2ffe6d4644855d25dff7583ac3f145b50351f38dfa6afbe2468c92f10a577dd433602b7b36aca971199eae43d30eda6d52e30254dbea1e381c9074a0b55f2627eefdf63874cc1c267993c1f4c3a7da412fdf096a286e7c718272a3347d6ed224a8532177151ca97e899daec1c1e87cd8903e044a14d1c29e393c221cf1d31bff819e34456e9fd307fb9ad9f1ba83905a741c7e5a5d2bcec4fee460a0870ad689b1b5e4326241254fee9309213986af594c3132fa91aebcf2df6477ec39dfa90eda4cde82582aa3ba1edb76e91a4b5847d5e6f0c37d399e01059e20f869681858e45c06108a2f3bb2d073b687af0de5a7d55b51b186cfcfebe13cf0bd30773d9603495be8cf882886fbc2d87f8caf8a7b6501b42b221ad3ab7df0783638a9f03f82cd451abd1380f2e3c5004897e0b2d0472ae47b8a5fc6e70d1b97b65aea66a7becb7c583476e937da018219a40879f2708b99b2d5557cc85ab2525584222cb0072dcc13d23d1916c0dda2fd3f4f7af2e81b40b7d531a35b5fc5c9c918d6c9bc0cd9e00503c14d39de4b9de64256729b48eada15fac3a1ffe046160018b335b15d9e2456cd3ef30a4051d3d74cd81bbc8b76c9c3799eeb1e0f57950fa38b3208fee93cd3a47d7e2c9f164d0e1cb85c7320fa37a5de10c3939de100a39ef4e38ff8f985839f20a2994d0ada13a30df2ac5091427e09eff1cca9b3d4a896759a664c1bce4e6287a65f0d8a86d48d2c6f7e5590effd3723cb95ee24eafb8e00e37e7fd519b3f3de0b2e65bdfa11248c6117550887de2ac3a2a24d30304c452e72d7425b848d14b6a15666827bf926be4cc248739fdbe21f2dc192236674d03c28c0e1c7af178dfa8b7c570fccb4e494e1d584f490e47767dfa7026d924fb6eed58b7bedca54a71df9c3d4a4fcbed00e595fcec3d89fb5536fd3bc5c34e7f708bb7a07e8d6e459f7cf3cc0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
