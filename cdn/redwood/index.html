<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6684ae52b6d9473cefa6ecb8b13e0358866a74a285bf963ea021dc2ad4598d07eebeec71215b091d93eea227634b8178f723738a11d28adae9041bb0e9e857a980f1362b6d69c84b9d5b986b13a7741e0fa251c1f4601027aeafefa3d7e62cb31daa98b08a01b46324dc554b5ae24d2c65d662e1690139910bf21d11649326d8e96befe92ee9bc001606efc5a7a5385ca5faa97273f30c10c471c06ec293d7e6b81f3ef0f626fe911a780329efba117ce4de126778046d6f3a40819fe98e3e66b0ba761a9f74e8c49244ed860414398e5612f6dcdd97806e9d2c8ecf2ce6f4842e37c452d0c29d5f5851e596d2794210891326526fbb0c18670f5d3c51bca4df314617b2d5968e00dee67aa4cdd078a9281a79db93f03bf19f10c2611a7a21c1c3c7ed22dae5e90792789bb4881de5c89f85d3fa705cbbc0c21eb16182ec83f5c3148db34f1a73c830ea0b5fd6828f1e68bba64178f5009e66029c596030d981541a4da09fed7c1d12f255a6ecc3e188c31278f8bd8e3f90cd6c878bc2fba79099fd6c77102158abb11b5f7f9f663603de8d26525bb717541f531e203849cc11bb952526f243952d60a8c09ef5591e119b2e372c3e855d50d947eeea18f00a96dcd2e6d314c08fd64b860ce3bdf1dca98b94b34d7c51dc230b3120f1d6381a40bef766cc344d60cb78857eb06128c7d38ad898971249d6045fda0a9c12ef51885711ce60b149729b2587f243c163ec2a836d18ac930bc13ab8a936e81fa94e96a9b1b0acd5536c58eb049f2c4aa50cc2a45305f7ac3d1c5648ba7850096ab00123cfc6284ed4899b0f3d17ed6a1599b8b8bee5b51ab131265603a788cf5b973f98b1085d00d3cd5d9f4991cd22e9d494c7ef7138192cd6dc9ed7f981e92b2e29cd8fad10cb41f916b284dca7bfd35c5c633ca8a4c91aca17231ee3f713ccea506b303a75c977e25329a49632ff99759a14bc0c6a61d84aab94a642f8dd2dde1778a3792dc8efc478c6771c33cdc7db28a3ae894bd4b6b1de3e8ded7f414e35b61a9900756c36d7686d3cdeb412ae6136de18d24dcc5079e7b8c375e03214eb614ca1efe4aa2337944c7222f50e00ca78826c42026d9e8239a3c1aa8c81ee721c3f4cce5ad8fb1c2220f960e35be3d96d2db7a4698bf6f6839eaf18a25b2b377969156e790b3892fbf40659ecadb3e68396938cdcd61156c0c44b5f32b4179d04c65228de593c02ad5ccf706c9b5954d2c5fb13420382ce6852ca66c9534c2e3da8133f5650325f93429dda3c281c9c6748ef43e32bfc88d4b2f383f518a25ac7f6fee2b307afbf85c962615a6a9df1705fdf2f119c60e8285540248daa416db5814e28ac7021a5666ecfae058b6e2631d15eec5065b512236215e2d8cec38d9cc04ea096a82a6f96c0fbf69e914e13294817bea733417d15481498ce216d43481e07ba59d98e96c91e209221a9ab7301a6dd8185991ccdd4c464eb63b496fb8515e5634fd4514e9111c28c32b109a4bb2abfc6b2181c471b44364ad9d2ed54278190694d5657a2259e7a1395a2da11b5f9df66fad30b4cdc2339395e3f747615aab72df1c1ff07284b50c13e935cfa5b3f56c1498ce57207e7bce9ba3db89155bf7041df0100270fb9b23b49240b5b705129c353fead6d896ed9b1038fe60f8f613fa7312bc66c9562554896b5ae64051f28ab23575eaf20b78dece41599a7f46e5d3820ae24dbd7edd23a506098df15d325a9ce86396c145cafcfcd75d13af4a253d5292388e2f3f3c8a1b7b72189d71052961358b29415dc70b3027614106b65b113aba21c19e5fb324ae574213890a9a67c798b4cd8d2f7df4ad347dd9fcc5d20741eccd69a7162ea6badd770ddc05c96589f617a8293e12b48c9aa960637e505cf3615b6a609b6336026cf4e4a7f3a9e85bec09017de7e82d53047eb44e0cea55273a6e57dbe49c8d8eabbb13b841e3f7d8354299e4e8c1fc2740252df65a79ede0d7c9afa9baf7b40e08f47845a10b0dcf254d311604b03065f88a009d11894b1c2d5493fddc58109c7de2bab1d2f61ab5214e3ddd411ccfeaa191b1c92d63ec3da8a89e6684e1dac7fe2d6b957648c6b3148d69c8b78c84f07696662bbd54b3650a2c22ef950b14d969813e03d3ec578c9c56cd611b63a5925e06c0c286ce051d487e7a9aa38508cd7e2b2b08d36de99d663037dc878196a663011fe9038672e5e3ec432dde4c9e737533df0ba2c4ecdb6191807641419c913f5e1dd6effb8a1cbce4acc0e832b5174838fcdfb99f1bc529704b93afb2a9051a1fb8b0b56e29352f531edd404741787f956602ede4a11176ea7f2801c24967c024b3604886a36e917d5f3c025e16cd710b8e544d2da2bada7aa64569a0f2b06ac06cee773a3c38ade8e9308b0c9b6b511df756e7d296ae6ff6f2edecfaf39b20d69d9c5afa7dec8fca54c9c8dac675b9514e4adec604ba1807d6cb3be54a0c256a6ac5e5152a5ed876796354756dcab384797f355932dc1d590af131c48dd1de30fdb9bb4ebb0e36a95b5641aa9ae4b5af31bb7979ad8f7df7efbdde172888c20bbc6a570063603c95acf477252e043c04224359fd029f8288026fa8ea3869b0426b8e6a7e9cd1940dcea69e43613c0d46c5c3d343d0da5de1a40c4aa57967660d9c01b242fcb65ebbd5ffab22e4bc2882b010a8f6fbb2d410761c291b1c483c4e63f30ea19016a70e8e86adddf270e521e5a58c649c67c5348fa84f8687ed8473ae1ed4348ddae9b1bef2131b90caf64f38724ada561c2e1e586959926265e4ab831b61c5aaedf7faece96f4f7a94907005cf861e79b5689804e525e0500e38774b2ab9a23564ea654265ed45326c5652c35cd079dd810fbe772c3eb35447c5b180e3eebee353b70eac60396d4a8f4e19659f0577b54ff0cfdfff2e306d47a8ae6418b6b8ac39dba642a921d2423bf38ec3d61f3fccb915dd34551f11d9c4c2e4c12a55eed477b1b5e8343af172df9a2ee7614fe9a2f4ea0506ffaace4218b828f897d51f30661263969daf06d82c8b4e20695daee95c6238a8649a3c84c73ffd44b90e89b5d597c9c61489b25e4860d6e93b90bd2d12a1903f6d7357021ee2fa8d11ca16eff0ebb585ed391cb64305f9608ba73560dfa21bc3668e189a9acc8cd7d312e76a8ca461a575fe79282bb1c3100c6083c640871847d5a1389bb0b5e598789300421a1ffd72b296343e19dc98446867c55bc388b763c7bdb8826dac0aac003a9fd5a0f3ffa83f68d287f3f66df2cc88da33d672f929b2484bc9d59761ba7a92444fa390d46de15c25f961e00ad2104db4ca1da4f964b27a2d1dd76758df5fdc7db0bcecc7f3d6cf8bc47a3ee520332e466500bc75ec56198e6e906256d535e9d84b9b4ef382100012a6527bdb666ec0de30897d77b765f7f338d5697b9f981616a2f9e8c2a1433559e0926301997bed6e931e0054517a60398f08bc48db7c47c406448922fc2c334d9ea4fd72037120a00f611aa06443231c2fd334d31b97c62d61c69dfe9b887c464b0e2f9086cdacb117f8f75c0c8a262279ee4917d2a6f446ad6f13f1b28fdb9cf39ca31a5b0960f420810056e6ed478397f0f079974db6503edbf2dc8f0633a4632256db580b90820f4342fbfb93476f86facc8a1c01349e092e0eaab9a2fb920305c4624d55e85288660fa1cc19dba2da3cf05551c7820021fa1bc77e912d181586ab99c2685c869af6f9fc5fea4d1d56674744edc3da7a100bf53b8e5dd07c93a26b82730a740450b7ffa666fd1eba4697a89c3e79baed8a7d744764c025d67d4a4571727926617c2366430690098681184a394d04c06d6d8462e3689da0fa63c8685187849f10cc87b4d4aa2ae38df3a2e100d21e2eb12906290060b3e3ca71d7ff67152df0b1d32d79c525192f7d865cdd8a2271849bd86409f501ca6038ececbdd6cf56ba08e8e67d819a88c316540773e103766b07ced066d57b0b47791a076e2624e09b1c2fa8ed7546901e4fb634e55a1dce2f68bdeee06eec54328f4a022c5188d4b8d1509409698250efd38314812b33837087f80ac42d9235f5d10a2e3bfe0b756b5defa04f4883e1dd0f0e4ff35be52f97687067c39dc53e83122bc33cf1ead7f2081062e7182f21b0fe0d261a56eb1c5236435a729dd36645337054ea929c006a745b3e9fb2474fcfb44144c8948d67cdd10c99be25019a179c789067dece02a31cba18f40c19e6c340ef07768ce1742322db507f91cc3901981ec3cdd5567fffd85c0c1e4da0a18c4a029b193a7bcde84c77cb315d50949f0b60c94c57aacdc2f0af7a1c28c66c04fca6af7c2642c4d8e9ce1475e8595839dfcd5a3acedcb4998dbb4b3feef9c5b75c28003f2e6e4749ed5f3388332d28e23159b38810bb0b3d661d6afd3d7d50d74b3f8687fa959023323a9d15847ffa778a53bf797fc253c6ac8adc6512d170674ac049815c8861fbdfda7e3a9a8562c891fdcc7f0f96cd02a3e852eeaf3495951b89c17a533155fbcd9003d6e7a46a9d4d4664379e2ba1f571d44d10b1b45d00f7f6868b6bfa025d23252ef8926867a06926cf6b16bea2bbebbc3e98d3c8cde57c256f31adde573bf5131dc79d997474fd0a03caa490f7b13e491bf839294ca56d3b29de5d5017194fdc8c6d6ab1d10e58cc8b8bd52c242103f619be123db90641198647153c57d5a530ba67877a7b4c6ea8c50fe3235e19bbc78d3e2686605549e08878f413403da2a19ab0548df0c41d716cc051890eca7f42937d0de733d48242c5e391037f7e5f5370961340df6a6aa652cd3f62b2180cd964bf9480801841b0adf5105124b556994d656e3573ee28e099b72b5e259c4b49b70a222aa26b2ab637501adf5a515cbc059ecade35e3cb8d003e033ea817c4bf6b4dfc090c180bf79d4b7ca218fe37592679e9bea24215661f8074ebb72e0218fcee42a6a409f6458f5907bfc187d66efca2743988247ce6dba5f782f7173d989518ce7ae90eda349979468282b37078ead6d356e643ebc7e6136a49b515947550a7942b0b88b27752c802a293ca01c8a072ac57e6ac58edd3b3288aa6d7eb9b6de5aa4ada2aa7c1818f374184bf5e62267782386ad97b809583fb9bde9d3d339a9d62b21f93d5731cc85a801445e7fffccc62a40a877c618bd7dc82d2b438ccdb03d0b491315c47bead3e95c42a425d0e6033d40c5c7305d8628270fd7960cc889b0909f238ddcd166aa35b7ef42a7d483752b30669816a3acc0932c1f449fc63ef34fe61fa7a05fb453773c1e1781c2343630b34b3445798fd76ec5ad5e63f4b27fcf54f41401fb6786a377c6ac5f89a41f96e55d7f850cbb697117b53d6ea5fdc0f455df9310402d3b39f11453df26dcbb2fcf8620a1e1a37489f7ec21ad7671cd6ca84de01ed50af01028bf3b13175810fa86b90f292f40a1fee6adb31000b9eb09b8482e56ca83c4d80b574ea1846c50468b71e4c1242fb35b6322b2d3693ab47a6da29eea5f10b72b8af561016459477b002baa028822eb9eee2deb4f126c20123d8227fea4157104df8b7b6c6c2f3515544222bfbde6abcbfe18b8a0ff003626b7f06519f88bd92c55b97df06ceeba60ef55a7891dedabe024fa93ce1d7ba2e6ef4a9d2f76eb6d1c8c45896781700c477e2f2f1828e1a2e83bba057b86048e92e9e6f59653a28eaa07df38c44507369ae4a6bc648a176eee18386c550febe30837ab6905bb070c6ac88ab5bd2258e1ea887f554729b0dfa56758d3e5e8a5b64f47a951bb4c0e0a24f6616dda32e4e66077cfe0cc90b5334ea5ce642337efeec80fefa4e4cf0e2d9b99dd57b42898ffe406387725284c6dda28b34e325cc400bd288f2d7f58292c6906cfa93f1b6e48557148f79dbc3e162e7979609499249dc9112285ac56839f56d6e35ad46f84de3dd96bf3f62f1216b6889db952ef89ebd22b30add40496edf15a5e11557a53d9dbba8e2fdf4dbe22824baafa59b7a8808f072efa39ace43d54d39d38fb4222a1b07cb7a2f24abde37c0a4a2ccb68ec6e8e42f350bc9d4dfee3af118ff0c99a631a26d1984d59ea48af393eda156d8b0be2f0122de42aa574c5054e5dd98cfb5582a1093fd8bd426e50aa02f73d87e2289eeb1e5dba26d9b480ac5343c045548dd56aac25054ce996e2995dd634811d6d8e2dff18cf893f9a335c09460dd2f8f60465e3b078abc98c271b6d28a1b3cff2d1aa3e96c4810e8b38cd06cd0dbfb3ef4e5e36ce5cb5020bda77c41945eed3150c045495bb64ac4e4a0ac98d626eedf189bde5a747dcc85faf69cc4a48fcab9c33493c5645a5d5f549e7b70a2c24c6b2607a809903bb19ff2835bc3271168bba7119d0c47ea77e6b58a7dbc521ebb7e7a5efd3bfa8447a2a0e5c5b9b1351aee7e5d23e3d4d79d10da92f98936592110f2351d0c1ce1ab8bcb8fbf333ce40259e4d71868e9b19f8c20f1137704795874e5fafa3e5c8c7052c5ea676363b7e3520cdd77e7fb4506fd9856cda64590a7d0e21f93e1ce06f0e4148e23235be550ae2c60a53dc2de8b247f0dd9e43d205a61ccae6b475a955b6d4335424070d35723270c5d7b0db94a5601d3a4067885aa4e69aaad946b9d2b5fbc1db667c2ce32917d1dccb6b5038b4fd3c1d4125b34a596c679c988c8fa0173887be1a07dac282129039fb64ba9332a54bd33a5b10f9ec7c7ad08c226a2a894cec9dbb2a8b897a576e5f60ecdeeff61091c18d9b6d572c3c53a7325f2671a113ebf845c734b57a192b803eb68a5f0a6fa205639792b9e7fab57e2bb856c9fc30440fd38b69a698030ef2c21212a2c90934ff3997178d4ce0bcd60171b6c86c451e7f44bf1f67fdf9e5891439e6f9b8f0ab58165c5993b14e10ffbce50837bcdb14ed2dff675fd3edd73313d3adc79c79c04bb463ee6eb2ec4ba5401f3a009e6d644987c74ba3dfbaeedccfed1a6d9acda8f4ec259d1dd87746a40807c02021ea0444b44d5eabe9c82833c89d4959f6c9289a49927a7f792ead0f4236697943a3cdd22f56056e31bd88d93ab34e9e3b6115d571ee8e254ddce5d9ef22c85e19630a0844092d8a96dc21cfca0a5669d05be688f9f864680a0a81969595db22a2385f988ea59e5d7e13a552ab09a37ca4000e2da77ee141bfd7c5bb489d98cc7da6032043159a0856be76ec62786f05561dc417fe4bc23a11477a742dd4eba3292f9bf38c6a4392d744f697e1bc582c87672a85db3334a74e60cb028981a9a37cdd48595b597b3ae0716c518f5c7fabbca37f002f1b05f02b3b4f02a61d2deaa945ce7646e9ae8720c1b8d9cc6113538fb2529dc2896092c268fc62cb6a1a0c51a2e0fd1bbf5a510c4de6ad3cb543ec1290138f290882fe4dffebe3d49ffb4837444cf5521e16dcf362cb55c1658bd2d928cc5f80f86819eb197e1d334fa36a98a48a1194a5b788865ad045f92eb1c4b48c9ee6ff8753d39b66caa9ff172f24421f417425ddf2a8de395ec12607d58bb5b4c80cbd560fa0eb88dbe03596697c92ef7a7c162e9be159b2d70706e6bbea892a52e6f2e582f9d8464171225422380c8e0b44befaec6ba53e140e188baf2a086096d6cbec4d7afea49df23fbfd0b89a688ce580eb2c6c9e7ee611fcd707bfaafe0f237edbc422a9c9b51a2f090c4719d227b9ef23830095b49835e7bb1aafa2fdc2f8f33c08ea3574d9e1b8af1b40e25db99d620d9087441a7d7ba357ea70afea575bf63c8c4d94ca38669f97229794e7b64caa33402d4b0060d06e4141cb994cdaae49447c6d89b10a70c38d1120e947a69de56a3264895542fdf44063a8b88069205503ff93fdaf3c606197f7256d1f7733358b810510360c45ccff373378bbaff7845024995201c7ae2f30b5ac663c200b86c2bca8950497d3441e2ae040bb70dad2d9ed2fcdf2266ac6c7a4a5a84c4de151733ddbd26d1fa28429620f88f40cee8d5cce82754252a1b5fd17fde3b5ad3ed6ee37bdef0b89047f476b4889ac66501afa43c669881358a71703db588659edbc9ece31bd8eb335707f67d6327cdb90ad059b1ae28d9faee18e48e853ee86122c2c7a12fd689707525fb426fa267c5584f987e2c1f78845bca86e7f94ba3a97d0b1024de7b7fc3b619ba007446f28e908acf1b66cb92d5b40dbfc88e769413ccdb02d05b2e472fdc7c9997fdca0fc98cfc6a157cec6a2348225d60d42abb8a2a62f7e1c67c74b056be282e87b48f5be2bab8131a1d1742a5b639838d36b3308f274c89163ea239c4d60f6d0b09f4c53245c64878e7a1f15a644c9f79ee3455306eca8730a2190dcf1987b4339ef273e5510ecbe321614163208b361dd9050a7e8eeb2ae05d3f02896df37f1458445e9819ecc1e7b62aba87bdaed04c222e06e9a36c52f47fe2fdd7e46524cdb8cb57e79777b65c9bfffa2abe8edcde8b7c6490e0265ba4701e2e06055c2f5db457c78a3e4a6f1448ac61bcc29513ef5af4485388aedf4c3a260b0d467bc9ded2bc6be704906c44ec62fd2bdfe443c9a4670ee2b64896610a05223f3e0a5d99b42e822a6cc5fd2b68b898e30636b8f2ffc82acd9ad8e22e16fa5d81df350ce6b20d8043e5eb092220e1da237624e009b56da896d5f6b4f5dbf78d0d92451b7b32df063ca88aca88bfd1c093925ec2cc01196fad2bf613ba0b05fff569b1814cb3e9c5b7c0370d3920fe9fcf734f7ae4ad5ad1a531a871c91cc9ebada75e03a0a5a67932ecd939bddd9d37cc0f90fe16caefe42c2b50f70102cf49688c6e06e574bdf8986706098f35c38c96c004acf1f7210a92d4c863ff363409a4cface3fde5bbb78d9e2657f0ca2bd1636806ea8044927560448e9a4aa9dd5fc13564772d19d79bd4a654a92d50a4df5e9eaff8406484d134c48c94e23440f9420e3cf1f5f9cd883d185981fb2cc5143e1130f941b1c62afaa4176f062209c73eab5f64b1b8cc7f860f1a08c91b6eb3369548dee9b18abc212807bde7b5f8c0de37487d07c0acbf63754d8e83d1f0af86793c37fe00756697a114f6480b92e840a93ebb9910f328c03b78bd60e382e78f4a5b2dc80b26be5d961f26bc1207b1bbcd9d9d8cb9d7fcd1264e895a7bc4dfe236d3e4e51c953ca05e555012ab8c165d544d890b47bf1ad0034805d4bd2b7e93b8e4954ed87788b5f7141409f147525a01aa842daecd26732957e0c58100cf10d71ab51ee8e92ade7b97c410786e6cf808751b9bd1afaf0d93a75de1486a2d5f043ef6105569a9357c53ee79e2ba324d0d0de7f40766c43da5786e604177ba9ef4cf1f7bfc5e149f25a3c7183de9c7645dd08069eda385b78553ff0bef43c1a7a7990f3c07a5272a16180509c27ba1d182ae4f29ca2d2eb1cfe2e939b51eb34c0bc9e2fafb778c1bddcbdb231be797f73ec93ce2a5665e024ff0648afd39ef75e0c377b5e600bdc4cbfb3330ecc39e1550e83c0d4facb04b6c84f72be63ae40e0132ce35faab706ee7e64c97a674a84a98836a08ca99e885c0b11e20d899b4f8773db230ece1facf7198a87ca03785569e8171bd50c5c5e5e31be5e90553a7bc057ca4fdd54a055717409445005b19483839185981cf3844450b6b6d52bee01a0fcfe14cc1e2b41b4bf27ef359efa9924ffb9e6d14d8ce072287de9c30a62fe22b8f0d876a44bcbd5abefac4a14faac36f2b51a958487402b8754bfab77e0f1c163652df1838dd5edf26c984bb39442dde709c0b387dd5148306a6c8bd4d3bd44495eebc8cefbd570b1cb466c075eb5f0bd52c7549b7429e14ba3f954307b0a26ded8eafdca5b60e3ffa0c1222bdbf9e97ea4b67b34f287f94620c970f1eafcc4d7eda3abedc3b38c8717e25c2d4bdbe93034ab8a576f10539403b9ea8de2ea58f26b82a8ade6905847d7631d0b65e9284a4ce6a62bbfcbf1287db1f26a3731c187bce425eb85247572e0ba930f519ebed2f84bbbe7123899a29632b7c48c2e8fd78e0d5a2dbe285452bff6b07ddd93abc1e0a74da42ca926c005ec190493f7c96ff73321b71db37fa5cd0694a0b94446458448bc0caf00648ab9120ec2a042cf9c372493efc46ac2a4d917ca7e1847af558d1976c1d4a2d7d5eceec182d25ce242982609478402458905fc2652679a0f52830dbf79cf5f3f1a90b3ce55e630e258d457ed06efc231312d5cbba821a0b8df4316100614827458a0969295b4508df9cfb249c9103e1e627e706d382290775df18bec68c2d4fed43cdca457a4498a819bcd4e374e23d641c227372e40cf49744b723e50a501bcbd2b8025b82817237739120b00404f82fe4b2bef64bb490163feb293ce03e7e5f23c2bb2a235e2e22b91f1b5ce1980a357d037c0024e6082b9ecba35f02fdec8123ae19b8d5109c5e2f64b86c012fae7036423a9607a70fb6ec2d83f34a5c906ea62adc518b4ba9f058155324770beb179f2f7627799ba47708d9865696b1b692efd6495e6100457d718336ee2136e5fa8cd1dfda9531c3d6793e2471c14e20bee8de7feda2e83f60025656ed9ec22b0311c8c0bbd7693e49cdcc33cfefdd2437c357a607ede67af46a03974e88e14f26c2268182aaedda5252a28225cd235394c2c8b8cd6b9ae64de6dd35dd3bfd733665843c80c8ab680272aa9a179dd5325c7cc4cb7560303eda6f35da2193bf11f2330ba65063288d6ec8c14c19c4f51c299afc1a94868d50db6a985ced18be9cda411c8dbc3cc62d2a0447cdf55b66b31900a2eb27d21024a1e6d3b2c29c3a4186017198eee612c97903f4d25070aa10535345ad52791521eac6890ad84eb31f93077bea93508801b71d31db14e78e47d9d4c9a22150b7f47db5b04e61012323d24f362ad6d28fb6ddaf42242935678397fb2f590f8862fd8fbdb25ec472d1b35aa30746bf3c4f5852fff3a7c6e57f74973fdedf0522fd0813237b7ee9bb7c9895edfab074edb6fceb6c50253f94eeee139fe08744264464b1d3418fe2d4ce0045786dac865a53fe7dc118f1a6d93cf115f6f6e604dd5fbcce8290dd37ea4c76beb007abb8d002e944683cf93588d460fa48392f8382379525d856f8b3a9b43811ad977a51ec09250e32b17f37113d542d42e42bf8c76c03a370a2a1550b39a716fcffd39d80e2c1735c43e7e2c31a21b9a7638798b4571812aefaa87d1b246fb588a22803cf4790fecbebd454da0db9f127f292d12187427761022a7a7d75210ac90eadae96460da0624412c3624e580575cc331eb09e1bebd3a081f7b5833453fa18fcf0ea5c20401ba19c82987f77187c6ed7ef33ca27b46b114934c92241cd279e1940fc20cfd94fba6d229ca991dae2c376d784cba7179250df76383b4edd12f6ea7fdf16d2b60a8be23397f541dba286e4af759f6bca36b44c456b2f1bc6a5284dd4333fac75ef0bb3dd217c0145f87634b15b8b90f2c47ebc0c5512850915389cbeee2373918df266e00fc563c24a90f4f2d1eb25d763eec0b19ebed5f408681bd8fca288be1f8eba1b98b0748811acbaa936ff1b2600a489ed19b6c9184511bd009d737fd2bc7d52c7b320afff6dbcd26225cc968e5928ed812cda8163e02bcebc92e70c8f4d86a7d100dda6bb3e20fb015fe8e8477d34e69fa828588fc6abb420d926125ab699012077b5ce7860e7d7cf16fcac8300709b555cfa3411cb9078309d659a1017880bdea8287fd4e80105b7fd23ad402c6f9cd3e2a2f7e25ba4c70230c0dedac35f33995b590c59e8302a5d7e127b73b790797aad5eecd4c918e6764f26666a62da1cd94f324420b4df0152f0962210c81bcf860116fb8eea1544a3c1d048b818ac21d581c5db8fbe2d71f108560da45df0a7642b38d80958ea5caa6bd47b602f1b6ce9ea92b679d80fe47d1766dc26554e10cf5d562722e2ea5e263b5d194078809f0aa51923aa1da2389d63be8e146e44b80b6a34f41e0234e52b9d163ee93b508d77d90b86f868f1745d9d450656abea290b2c4a5eb2a58560919ad25b28f7702d5c2c60e37d7064f9743d1c82c1b354b624475df539125c8d252d6154d636e777cb79eaf6fec66f911a4150450a5b241429fcaa1b68adce3a6899d1474c34dad3149a983f1e6d686b38ea4d667f13b6a3c3e4018ec5c611506f2a922b791487f1c7594e3968489b751327e1eadb1e6152890bfb9c73b40bbb5f328dbbb0354bbe1eaaeeb0e7ecb2afc712852675abd4654c76f96c9590259368f4b171eed29813593e05e9b3fbcfa6b83b4d0ade18a57b976d22ca409620a95960db99d851c1cd0de687853c4898da9d382a492ea3087b5a07b4b163420d86b1b03c6c9bb3b0d7c8f778b97525ac6bb1ee12e65952901a6582d091c4aa65d8a17368f05b73998d50df3ca1df5e82ddb94e4187cc6d738fc99456f1f8ea3895d22f4f8cc5c3c79836551b2d58a062f759b21453f0795bf5726160fbcb2697fbee9a0ff5c26e06dfea7ed26738d90d6592b0ed7c36ffd393a4e2bad30816051fd3667cc19fec1b5b36a78ef6776a36b08aeeadfc2f7f174e7acfa069c068e51bb5ab11fcd5eef508ba59812696d69c5a5c21a5da5fd93fc8c2f73850228fc29afc38faf5635fb4e5b5e723f0aa3626e5c4decf056bca10c19287ca003a5018f234a25e92d6ff9f1d4158fdcafe2c9872e7e0dec00bcaba6e7589bd16eebdfbeb56e367c8f1c918f30cb883dcae602b290f0be4de649827eb312266d43fa10a8f527ace319f67020652423c5c81ea9a8115f643ca0379a14bf027c609600c7053f8be75a0022ecae60e15f5f250c1b2cf3540e5ff20ebd5e07b8b33f226c6fc44990c9a322d6f7e88615f2f19039c58e7a82a25cfab980ea8d86d627c6b48b87546889e5c3b72d84c394824c8c597c9a3ce4cea914c03e40d92e0529290a01a8488bdb2b0447bd1bd0fa5879fd79bddaaf02a2a4233d336b088e1756d53e627556c064d88336eff5989a0dea96e9e154ee4e902eb65a9c00f77d6c75fd83e9bef61c18a651b6d6453dfec6bf1620539360e02de3e154a5e837f30891e518d5a26feb39bbc6b8511f7ec39b1840baa20da1e13064d37392984dbb8b5c0cae445d6070ecd505ee075bad88a54376600a8a7c96d54ab6a9452762a1e5e75242941cbd08453ccf14be7e6c31b72c97f30a4429ac9b33a1184c2a63fb332cb554306d95363b43c6c3cc3697c51042c0f2f4da758cc266d0a3133e50e3d6126707e9b4f0ae4c7b9475896a4154a0f3c11f92caddf6803ec07f9e8d5a1cfa06106238118adfd43ee1145ae88759bd2057a9ce144012e7e28cf339a27f04234f7017e412121e84d589f056f7e213f58183ca1efb485f7cc44df6b041f81d27e9c665dc5ed5d0fc14b1c4040948e549b60ec1bddd3e1219bd0d98b330dbaacea24cab979dfba36a3be47fcdfc57be0835add537227bd5685ef93935b6ebf77c0abf05cb8fc2f634097f2780be8a8eed66f5776b13cb6ea54fa2d78d700c9c2205f7752264a26c0708b6ef4c4c203fd5ee2f563033864e3858326cfe67dc40338f18896cbc8bf4ee2499fe8274d343fe292740de8188a09a861572751d9141eaeed48c43614d30e3331362bbc359eaa729ecc9aa684b62cb522724eb158b6989911a50275424803798e0818204b5bb787a1d694ba6dab615176e8d2485928c1cdada4cb2be5bb390a57ab70410bb644eba38ebbd63eca987a1efe7218f92ff111763241d62be7922f5e962543245f606c1ed51560c0cbc94f7e7d6fb2518dc1140905198d482c7011aa20dc4569b6a4858af7410c91f8d213fbbe733a88036aa3c75dfe5d0a6efbd9a75c7fb25361ac35f1b5ade6d7d0de34ef8bec2160e886608a6c823c8ff38980627cb710f8ef73d85fb9dd0243402053f879b83892b9dd28172b1d6b00e719404f5e6162ae169ae60d12625c07afa951c8f933879fd3f30fdf628c260de096c271a10a64916b7af4281be4ed3caa6e41bbf1f07257516cdd16bf4bd7eade390afc267ae113f3bae874db9a15d4204686e95afcd94fa5f62a4716323a61ccf2b8eddcfdd46831b150fb5d17bcf2234571f147c8108c63302e2b0889238402c571de9cdf62fd26bed354642c3594a88c86e4f5a107bd9377fbbca68a48ff2338d1399a538507e1b55312ea92ca64027c9ff546b6cf47718eb09666d6087ff88b9bcba37ff14d92718f77ab4eba030d7806e13d0872fdaf29f4f31f67ae4116b6c5bdd3f46afb588f48778487919ff2efd70a9f87d624b500fbd44c2b28aeae4a8de6b8d4583d411abf07f3a47ad920aed8042ad361108ad18160379c69ccab99c852f75b9b9e7cc3d8fcc22c082b47630184b8c3f716be25003ec37c35eb818fd7a9c013f7d2b07fa4ff7eb17c9c4398289043b7b3bbc49505c36793f2b46c41b281c8dd6394c8278c538a14810bd39c5a6798e398e480940206227bbe32c927b3abecb3c12305346f4ff9d3a937c3dc5b7634e41b50dccb8a9916c1e3b10dbe9aab4da94f7a8e6df8d25bc74bf93a0296f1f25da2b1bd18296562946971cc6b1163224ecc20d7f64b9bf357fc83f0d0d4a127532ff0bff470828ef29702b0b5f4ef163aecb7b66026c72441bd2a6a4a600589c8b52bd90a0035b6c669f72003acae320c715e3619b8de4d82ba89ec86917ee1a2459beec314affb331338e6355e8f50a84cb50414c46473602cae1751b3ff797df34e5c78bdbd0046f9dc05a60c953b4452d99ca47dd35ebf0ef7449f65fe784ec9de642a6d49814b3a47d2903895cb6c64a1c5a59549fd46cc051740160eeaa16a71df5cdd87116621ac692673eb5818b1f61d71bcc83b9b890a7dcbb71c036a6f553ca21a32e76ba1c7c64114e983645e396f1a08e9dbe46ec474da13bf6d2c302731a9d3b14467133807af4a8bd28bd72ad307d85b7f3732384f62e5dd0f1c3e922ff36a540b151024cb0400dee6d5d7e71dcd40272ace401761fd6a19076f4b987da667222f941dc685927222441481686ffcac8768bad16955a83e48388bbec4bc0526b7242ff7ed059a949a603a566a9b808f11fe164356913a68940a6a3dbc4252b06c92a769e423ee5a7c4197d14cf00e537229923ac965a5b1967536bb3419dc4a984e9b89e5a99f6154e867d8ebb1bb67227dccac45ed2d15fc6aa75a68665facce4d44f28453be09e85d2f4600cfe2bfc09a617d613040331c505a5052e3a1f8970a37c74a9058fe1cf6111a4236fbe9907445813e11ea5150d676708b47b4443f4c25209839eab182a9088e46aa5e4b5a67e218e6bf886e6ab95f21c0d6e5e9b16d3a27e2e68cb10c45078c2e8c4106b58655775366b044fcc06d246d5d665db9a702035300f130df65b2cd4dcd98c69f647b656e03dcb1e9a6081f63d6948d2d1a79622d84151a0825b41d4da3596a2b3c7dad1f13ca9a8e2a30e0a61cc71147fd33f4ad2f630a73602cc85349cfa2997ee74a7b83e9ca0fdc07b4d3c5ce8c1451c80a7ac9eaac86e6f5a1aa0e554694cb6be71891a29f56736202a4a0506c4d5fce47a8eba88f40af5378a2a986520032ad1f9af17436b3cda35b8d4f70d20b4e0ed92fdc0cc9c45ecfdc7c0085590e4b1dc79e24ac10df887267841cde99082c691a683419422e1fec8a4eace684c051219bb46c67165dead4fc72429f2b7b940c175fbdec5da16a1bc452dc974355403c4b04c6bc241073db20498671afbdb97a71915eeb2560f86b3710041a87c81aa43825d721ee778248d1162dbd10d66c086f9235bbd94dc253e47e8dc3da2a1278eb381b77099da7446f20932db6d8cf5501c2231fa29fc8d4fb50afc2077db6b84a0f97f57d6263e09ffeffa6a462adf73f0d5715401c75f07dca175e9aac4fda8f7f942b21ba439e409987e41566d6a387db03ec02c50f9ec3421d98a0667017e0c23642838c6f8afdac1f7097c2f233f0a9fc5928b2eedbe151a5f443cf55e6c37185b05c80ade3d191cf8a521b8bdf2b625b97a417a65d0b26b52ac653b3faca40e00c21c2504689e332eb889e65f7d97e29238ee425522c3eb7ff2ba36100df47c5b76eb8261cad4bbb4da4b326dc03f18915e6eb707dbbc95a4e46fa98d26811b6316a18b9d426b1e335ad6e546d6dced90eef358f4af71ea3b92ada152921409ffa183169640e005cef7703df9a5d9cbd58645b977edc58c6870397f8d141ba1b709540de6c8eb05967e941e5b2d12e311ec0c12ef32f8c53c31b65be069b8f570322d7830bc41e5d372ba939a8ab4894b526d2c9d9bd9f3e400148b022e9a384fc8243bef17e9c1e6aa5ee3f100abd8e08b67f2fe3d91095e755443e259096a02c3a281d1b1def0211c15c76cbe63ec104edbb94f7b7da1202e93ea6550283368eef13e4c7bde0a41f14331347d4edf952d0c61eb82e2bc3e1bb0f60dc3da1ab8a581479fabdef392ae9301e64daea1e15301c8bf8309ddfdbdf5a1728fe52e4a1a53bb335be456f8e546b6bbd5beb76ddaaff87980e48b44bf7022d89b587ba8676e4cb0218edf77b745ebd2bbec98dcde8850da0d763264c09f4c0dd7cf7113a9e54e3e740bc8096ffb2ca6d2048b23097270f5818d59193891432a93286d76bb11f4df996636b04a1a33dc14e839dc788ede6d2a273225bf9d76551da6e8bc7220b2464e4b678f6709370f4ecd05999a9d53e2b9328638b9abe9b56fcbd24e4340e06c7f2477219a1d7acbe6fa9eb1e4bc7fcc716940e705f75306a86ea3bfad1349758a4bc757d8fb04a6daca4f32ad979460a7bf9a2c0afd7d9ff065656337b9e911702be5ee64855dce3bb8ae660efbfcb77bafbefdf2a9435faed915d53be38c3f2c75391a88f78a0653b51acb0496c182ac788312bf6c7352cd49e2745589a82a2af3eaf0d928915485d3bf2d9874413225047bbbb4d143ac346e0cb558e7e6eb3f16ea36d24f09b114819e8fe8342a359e31a44dea5e32d44ae29052b1e8c25dc5c6847588e94181ca6f50fe7bade8f838375a7c4aefe6865e118e30f016c6e1b759541d58473632e9a32ccb362e8951c0772f81c523429730c1ad47c733b1ce390dd08617032f1db0bf4de14e6193db88bbbea14c3242a37023f2b83932e11b6f27afd828a90b9e2647a904cda693cbfc82edd565f7ee7a22b17f49e5830eaa96ca2e6dea01e03fb897d3d3c9ec264345d6b79df21f64b5437b973070d7299e2c917d82ae1a0bfe10802a8e7ac5e6014c4872286c450ca37382a1d8958ae9aa86ae60256e3395201c56912898f46c7b9052d9934cdcc17294ae2938cd136863571b7ea74b85a9a10b00ea5bfc8f1b1aa57104477f7d74ddc518a5cabbb76ed24906998c17a746e9bad92a5305fb02a0a906016b5239c24d3f26fc75c818fe77a95c2461f9cf1ce8a73e8c1d26f0de67d98842228772d495ff2dfbf2f67a4fb60467b67e556c7106bfbbb75d04c7f1c34539245d0655ff6ecbf92548fda16bceb1161d3c704451512f7de11e8b43e1607863f6ea453418e2929cb252ab0d1ce0d3effb8b3421f811107e96d0a664cbdbd532d1341b91a8669a76f317df20992ffab48f0820248c15b93d4db559f360824a9cdea8384201dae175fd09c28f6459e5e377d30c144226b7d73db7b78d38b922936edf285b08644664eb05f40588d9afa318d77dc7cd5d243a9c57ea3a1dc352518ea2dede94cd149c97443692ba560ecb80975289ee135fee21a44df1ccc6f40732a42fa425b853aa702357b538354b19ec37095e967babee15f4375db556fafc558e8c98480142eabe0988da1acdf771a961e304a85c27fb9ce4693f8993d1d40cd1d32e2ce142f6f60e4e2f02bf5006cc35c1dbc19a7c9009d6aa85a7719cc1f624bd1a89d9ed8543fd630730707ad86f0bfbcaf18ecc0f24e0e786e1e9b5b6ca1485ea641dfe665743aece83c5eacfbcbc9a6fc9d54f5821e3f40a6adebf3cb7007ba8c092681ccdc6075f17e490f67aff37f202ddf79309a4ab497a4f41fafd705bddfd12fe56856d8370e7021e861a1f6873796052fd06e951956ee76945f667efdae3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
