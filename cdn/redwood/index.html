<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5b4fd465434f393cd10b7de03e50bd3eeb1513053d90d5f124503705575feb54ac676fb537497d82a44446e0d4461f5065a4bbbdff5e8e00d043a24798d85ce8faba0c4cc0eeda99f77b01ec35364849189bf6716c06ea9bab8ac07867ef0958d348e3b1bb802d9aeefc25aa08f3cedcafd1cfce89b5d66146fd21d2ed340bd27a220b0bcf2962ff80a10394e5b32c4550de62957186af9c50d55c7ea10287ca3524f9a426326f0126a0e02c267458aedaed3193b0bc64f00e3040e923034b03a67aa05e4de81d1e48a8ce86538194c96500b6279245e3f56f10ba49cce472d7daa032c394809427025da77adf79554dc0c611aea9f5c843e14b1ab89d96603e7b8c5c85321f0071a2c49bacea7776a945a23ea1b4bdd6c1b81b9b3c6af4129502121b96574077fd29213535c41210b4598e36b4191c456c0ee75784b3f87f9c02cd8a9e4c40c69052a461aa7ce891c64c5336a809e9e6efebe5166f4eb270c8ee1647bb99fa75a574c6107509b59b3311177ae2b8bf38101e576f87e2d2a48f74ffcff1499b5e70545f13be5479e9cbc77eace6332c60d7eb718e17c88cd620332bf7a9637a3cfcffc45cfe375951c338f3e635b1737618c0a99c67e24022ff6d48f3a64acc1674e555c3893ed825a1ad54171122b8d7c07aefd6ce556e6aa0b66c36182ecf5172678f0148a5e54f3ba4d76cf9160f6ba126ccc95cdb4c1a51d96fd594243362e30e0594254dccbbde131b8ba035f12bbf3f9de1432d287d847e9a7d928f66d670706fbdaa4df93d3ddf78a4764ba4299e0a28a50e5e5e3f975f74ba8ed9aab79c96967fc58bc547a027d73f5876065475f1ff82e29422db1a3ec44cae8f9b087a4d830d450ec8908f54c1263c8fcdeef478a8735026e11201b1122149986be90f2db7f57d14fac376876f7252d1fd8348898e7e26800b87c2aaed2f8eb604d0bbad9593751b6c966800506d35f0507b0191ae3459f31e6f1b34bd6b8ee135103e03d8c8d242b9b191e7f028ec9049498ec3a32b5a02a0ee86ce6acbedf411ba3d26369a1c274e18b8a29eb5981b38158f09aa1db3a08bd3354e5a203d9aef617ad146258596f3229092e0f8aaa4963108a16656fe68497dbbbe92009c99ba703aad15afc05384d6e67cc6c8911c58c0fdbcb0010a08414d7c892d874a3436ef0295a24aaa84a4b11b8cac3491d157da1c5a705c8b70a97ea2a468869afd6f146aa1aa534f349db5810b62296b9badb674132b7e85323c19ad0d281aa95e1a548a6f4ff4135f3c327ff8a7e7a76a590f2d848e632e109b01223eb79c1859044905ff67660bd8349537a3663fc0502d7ea32cc57809b4f70e466b63a85f1c04d6e52ff7a03545ffe503f64538b05bca89da0cbb00eb6bcbfd0303461fc8cae7c1a39a0974d8b5167f5caf166c066366a8c160fc14f7a482ef00a915623e9ce46f9f81203138ed7265a355bce26479133e992a3f45bd17f280739dcd661e04338375e2ea1d7970e9ddbff870c030dcbe46b50ea110d84998106c67e868f578ca7441f3c348f62ebdc0b1f1aeea19a4a2a1fe8c5d1761dd376d00709e255b6079494450ccb14f8d9240261799cf857414241a188b252252e34790f5dac22880eb0d3fe777096af6c76b194c362493aa0ed1ab18ff189b018e952a8bda74acd9d2d2eeb5e7f8d1fef3ca59ed94f441d50698c459102ea356c8c807dfe29fb1e05af8fd52aef33eb68a886b747ce56b0a57ff098e15160055569d2f5571597d1520af975c238a0a54fd5952a0893045e1f8e642d6332b3ffa3b6843dd4727e0d05b790a6db560f8d81a4d61cc49bec7fe340c49295836c2e3a3232151bbd84c9994ebf97d1de88c5d716bea0b9245393989ec3d9acbb9b6e646fc6e0179924feba1998e9565dcea63f2058f5ba425ea25588ddbd154a18b6f605f0186735cda254e368d9a172df1b77412cd35dca955fc1f146409c750a94e5617e729725f6e73c88ac0bdbb8ce57e134ff7d1d33bdc2f2ad5a3d8abedd06de9513a216be04d7df0c8d32b2c9e7824f4ccf93b1c2c136fb104bc0e87285a66e032567946bf920c554d2a1504a42cee18156cf41d9e6006b8cfb0b1975503b2bc480bf8fa0765f9f39befb5e05e017de703e2ba89062f46cbf9bc657f49a58f763860616c7041a4fd799e4a8ee72c7b8f8adea1aa4d1a7a6ced5ad4852739a821d325ab4e889ea3fe334fe9f949fd737bfd197039d940e4a2b31e98bc7a330b7a98b2df2ad08294543af93341adace755a40a1a15fb42a84036c1cf2cf4527c4ced2f87cd3f65fffac9b9352ee5cb25c05c15efb09229f875a830376bcd185d5fb6bc5c1acdd3eeb7954795dd62a02ea61a162898ca5e7c1893c6d4f35523e70fa1ebc8daf05de9876eeb05bd53b2c36caefeeacc6126c8d353057904e3f2d5d9a103fcf1954df880aeb02f5bb438a078d737bec57db3c4e48a6cdcce90dda9e95e1582cae403920c5cf891efff7d7db3d7ff5480c76883d13e0b36e4a66cc5ae8b404ad15da8d5b5c1f3f21b663ecbe95743e2ad4e816ed0fb32acc808c726155ff04d116c8213e65081fed67d6155c5c210b986bda5d758f4bd10ec1f91377a0205ad65ec981ec2970400a1075b7c7e61f5cf0a21b57783d7c30f5087078a71da9072820a3d51fb759f6024538332cee517241b381c37e6c302020f2be16208c6ccb51e979c6d2ba620ab4422160f69eb08fa308cf0a352d7f96f3d16f74ef299bb2144c7c4732ced3dd436911306e48a0f2ac7756b2662c3813e1c802ea920d70b21fddbe906631646822f1a233ed3225dfa45156625ac50d1f856379ffe1099d805232c66330f1fd82e53e79443d85307bb2ef261a18c13e99d298635280cad8b0f199ef0a79ef0b4ce1f7870b82c781da6c24b53c54c857262e67f14b03d64d42fc4853591ece6a337935617f60a2a7d022eb62460f58aa50e1cc444ef16ba4064e0509b7934583d2b7dcad8bee1aa8612e7081d9d9d356e14c8163e3e54b30ea9904f23b470e3d5d3efcce048749f8a0169edb48a75362eac94655b8e516093d799a4972968eec074a275ef6dcf916057eccfe527679a6634aca07894954d4cb1e37f2db4961541abb871c4c1d8298f0a4b675bd421077609cb5609957e0e41f4ade13d570d5a8ceb0300a6cfb9b4de96c2217cf854707166b676733ecc2c9b25bd9220b841b8b3316d0a7929e1e045d006de3916e760f39dacd7e144bba2347d3cca6584704404880b192d82d818a86a90b1b6fcb5212549be8415b5ff1c341c0f83385c16e98cbc6069ee972c2447ba22528b4985f596e881c682afa6d04fd4c1332fb27616fd8f57c7ba64a25fee6d5fe7e2f0a7dd4e9880553f80d7d3c5f2fedee790418f17b451327d731ea26689c5810f4b346a623101002cac920a20bfdc2904aca598360de05c4512bb31e3461413c4a67ddf1e6e41a34222b77ab6283d3c5ef299d7cd04d1782c650320f1584386dfa914a588ecd7cb83fe15c9bb60aa3aa03ea7b5600136521cc067bc7b0fef844ccb0e5a5a5aa7129f62cd7544bb86d713dd1c614bd211347c5a39d997c86d975e4684cc91e313ad61a85788b4131b097d3aafc6d8699f24c15f75f9fc2345473771c7fc1388347143df03cc49ebf7a497d683c0ea84c5891a80f1c3582e5f99f11e67501d712aa5b20777dfd0c0f1776e20ab458c4cb1080249ce1a7ebed07f7e2dbfbc86adbec58133464a922adbb08ad38e519f60089cb78999b988300f5996e4208d129f40f5e6dac014ae83b2161ff4e57297980d672bfdceebe29cd367d04d803b140effb400ef73d85d2a240bd59068d1ac56868749a0462ea41a908b7b721a5db5e36a2eb7111bd76305e2a297801bcabd0db68683f61d2a0890a5e0ba4ae1ade9a3a75890b6f9a250505e0664a75e9e4e129bb01cc63c571bc60fd890a77ab03dd5da26d5febcc9d06768d9a98b519e01d302fdb59650cf07d2dcf30df7ca42bd3e1f6ee9e7541c8a7ea8cf38f8345ed63bacdea6f48250e655d7c13b8c5a5d5f38e8463056bbbdc6020424f6092984065a260a877a0f3daf48f30b2cabacde20584b044384dad41bf01caaca002a976fe66ffe29d8dde3617ba41707414cd4ca5734dfcd09334d4a3122467c5a636a8e305aa4b53e6303399a4e9fb8de759fe39416f84abcc0bf860c75fdf6f1bf8a1194f066c374c8b28d0791720a99ba295135e9b3b45964967889a391e32ebea46b03730431efa9e70862c9977d2cf2254d372a9a9adc0bd2375bfd004ad22cc22970840c195f4c1d7887cc9f28f1b2189733899a24e09188cad5737f5ec01a6fb8d18877aebf7e330701c40ac83ed106cf6e62d9297bb77294dd9170cdbc5a398d15e3cba06e220fd1eee676926e99e5bec74b7585653c969c56d123ca0b300eed9e586f9783006d77a095476ac0905e1174e2742b5f7f92837bfdd358634f5a2662a019df8d0d52e2e90fe1fd4e41e7255174a7ca1b566dcf122cfb0e9dba342fab49ec480f8e555316b9bb3aae9400c662740da4d594519246fb76ce7f9ba84e4623e39180884a72cd8b86cbab38dbe1e29112911d7a2db906313798190ac529a22515b872456b3a5180c999452b0c92bc751eb6d092b4036591305fb961a724b2cf667f07448601f26332110b8572ec62a0e4fc1e8d445274d928ed9cb8669f078fcb622d209136b61a31c719c5b2091bffb75294d06e78a70d755fcbe912183e58e9d11ebffa69e1b00343af912683e2a5f9b563c5cd99663df7e3f09d0fcd4f104886352c86f039cae6e180ff320160a62f451c6f64307614dca3a494ac832c20da9444f14b5d52f190daed345ad2f1b80f2e5fc650a359624fb5ad6b4076af75699f384fa87f0172802651c8679aefb08e449e7fc06fa87ea97cb8c4f0b5ea8ef174d85573cd8cef99dd1cbc278544d1b82d0dc641b831625948259989651ce57c6d027735d222cfb9c7e5eaca267662998eae3a2c81ece8235dc57c704963538388850dd3165cb0a11751402f4ed58864c6388d50982a5a54f78981c7ac325ec566b29bb94573661c947faa3d61dcaf886eab61fbd6a760b4ec26bd4373bd93646ec0c619ae1ce80f51cea5720cc790a9f35f9236a7c79b6b6acd059551d3d8bd23cba124eaa1ae0b14ffbf3143bebee2885f24ff60166cb9902c3b231f5ced65a788ab82c5951d34a32136ae5c12b23acbb20d406938f62408bf24453ba7131a4a34e580efc5b5d7725fc9506d6d77e37d01d78d8d8e6b1bb51d29bb07e13b7fbb1f46a16fc551449afaebb4e189f77ceccb0f584a084091c3c9783a59490a02739b86fe815516f398099c206b45018d39d34f0e3178160bd51340eb955324197b285be3cb07e89daedf9517a0dffc67bee5f5b92f89cb1e52fbc290b73eb99e2b479602af744881213d5310f0b2be3a94a7c990799b90df30af31b96fd43c1061de99b676db57abf7d13e231e734a726be08e5b84f935c917aa34553577721989029717b2f51a6eb26ce14c8f99c4425591efd055f1d4b9b8c187ffdf42a17203328133eb1c4ad8d947492851bec423185943c147f0b49713eef1c758a225575c4ea1ab04a65b0610ee503950753fb67d9de38a96a28dcc305da52231d88683b52460c15305ecdc7cf3ad8953592e3dc97e332a56d7c9ebfcd2169903d090b561fae39f52ba41d1f64f6575564af378fb61c4ddc6851da020ed2d1fc594e243dd9b02897dca57ce7a6b94bca99e2d3303435f2cf2b7d80f7d3f296832f985d0d672dfc1f1b8c14038df4d6aaa57675f9633233764d8d40fd8893914a594eb2d2387bc9c028d1c819d4c282cfbdcd897454202d02b29839c29b5b5559b73adba991f195c5851b8701266780daf144a85b27a3c64936b3a48022a36078c4d5bd13c33fefe13a42c5dbf10f7aecbbdb9ee8792f5a77c93dcf8dfaae4ca004714e30b4c0edf41fc0dfc730c2539fbd152a096bca1a0c6ab211673349317b9993b0e530cb67eef7775176f83762c7e29f61f7a1b3b90f1a10a765e042b7c229a0e62b1980cdf8f4bd2e18953b0695631f0bc45aa3799c9f8cf6db7165be5021001215a2b710d095fa0660c99bacb526b15b695a98eaa7cd303e46fa1f51f6ec7705a380fb492bb89e42edea4614e7b3be295d172625f9d331673226923a6ca4004fe77c71470ed916a5677e839b05cf578bf1407882f5ab98328c1e4bc5cf98384805630b995404bfa4da99cbaf8d1ffdbe0db02f14ed4ea09bd68c1ca912ba2b4f4334ec6171932ad4782b83c73c4ecb234c7ebc29474eded7d69677f9a099e4ff734561c18e501f5f6d782af771374c321f21cc1cec30263511ccf299ea0efc74d33b15abdcb068ed3587ce12c9ea10c35be909f0120644cd386fdf31688d13a0aa8a78e044e8775c2fc6f2114785ab41ceeedcc7b1341443f2e6c10d498540fef7f1f38a5d9a8ccf4b6b57a9b421d27ca923936580e7aed16a8cc36c0aea84e2e4dc36162cf5e4037ea9320a39bf7c0a6260b4406b9e243049347350b290022120c1be255db98ee7726bfc714d4919d9bfecb2e716a720cfd6f737c732ceed5cb7d6fc0ffa05d7621ed1fbabb3cebc064eabaa0c620daddda904f41d12c3f7351826ed2f1c2d826c87d2521d46bc349d8263758821111fb83afe42221039f57711e1e9bde7917eb64777b8a3cf92bcb228a3459b52f0f09846c7580c8c50f689a334f81de61aea90a2a32aa1c2bcd38c6757ed0973a6acbcae9d628e468161f83fc63ba6a985f09c07db77e2106dd0b9c23c577f7a3f60385af1fbc058bf40969d0cc3795c96e3b1c64c4c4b4f7d3f333e91b1ada0fffd2b2e4bb584a8ce7ccb8f8d647c61311426aa509478a0b696cc1dd2f8ee1781fe01e14a5810c96355e4331ea6e53cd8ccd6779b7d005bc5d2c87c95dcf89f508022672f4958addb2a447e12b810ee801f7392e5fb2ebd0c3ec7b1f4b1e2fefc5a7e7e33ca8eda1224862eea8f22994e99164fbb37088cbd4cecfe6093f87a45e6d5ef1e75585547c0002794ea34488303ebeec900dce74b7ed745c1d0f72990ce46a043e90bd6f8d589970b3df729e6f6db8c65d75cc50a94b922891bbe4fbb949ecd911df68632056c7020325336543fde311cad99043a45a362007ba166cbc476eda7958150c756cee352a7464b02fb0d1ca13e49a50d071144df9cc55e06b12668d83601234b565d8162a4c05fe4dab72e9fa8adf32db82b60451b0142bd80526358de462ec08b632c8313b00389455c0188f630ae9f5284318ecc57cd4ddae500542325fefb4f73550d17e7999b68bc42d4fb7e831835ad4a99089f278645166bf1337fd96d01c4d5d4ac49cfee4985ad5be3595da3a8604c5561670f5201c8c60018c6c5f4d4a53e93d6215b47b95d4ff461df1ee8b776041386a365a41e836064ac92ef456946c1afb5c7a93e6df4f8524b859c502bb50029ebf111a8042a57358ea0fbb28d2c74e9597aefb2b98dc5d2d554ef4c2353696a7705eb5c9e8099bf5e9d1910f9a04aab18dd9b1ec0075af0e2f2c714f44fc59dc582350ddc0fd0b163474dce91ebb82ec5211a0b24e5fd6489d471cd3a40462b53412911e8f62d727e93adcc84476f4d0a273f731fbcf7af5716330febd53acaa3a0880dee7b504a42bf873337cabf7f1462a715c9cc05762b5ec943dd41bdcf4323635da412e43802fd6de90aacdc88d879e3abba2eb6e0cb2bfb352ebf11fff4e8561b5551f51d663cca00cf3031d8dcda9860401e3a20e364df0d7f6936f74cedc8b2c7e68be36195b4367ab128e0ec2c478359ae8564c3aa57b529f50270ccd9cc88f5e5ee7f77c7bd4d5fd536e286a4125c3e61f15287178490d7b70a470b63a04d3614cad5b56128b377cdca60c25d0f0da2adf06d6bfa9793a763d1045823063a737fdb07609a77064d94aa7880a4d5addcb5f890d8d4caf9aee4c5d143bdeb2ac49cc6487498c1ebc1cb83766622c5bb6fae83c5adcc05e605d06374f176c74085c88e1470fab3bdbf59af27ed67064aaa32c6d21eff991845a3eebb2ddfc3536ede6c4642ab1b7dea9a0592bfc4226f508168ee8b8ffcc929aee0db3c1c9ba9d544e12c79a7a62a83da838036ac54c8e46658188183ce51a779e44a3fa35f6e48edbec84568b02e9bbe0b20b59dd6a25a86e15eeaf3ec1d7cb62abef82bd20f789b4e090b4fb34b4f06cb7a8f8fea2eae0bcc6d0a526e89cb08c4417d8bfd79bf7c74503f61d116d8d10a2d2c997835b3324acefbb9ed2f15f0806f05a080c706cac169ac2e71beca0ade95f643c71085aebb99359da9672203c898bf132fa824f509884ae3d3573cdada3cc62734058197924264105db703002b0d7a419b14108837953a078ebc3ab3468ee8b213e4740ca792b5bb7151aa076f4f2686ee8388dca552e5f3bfee3942e615517517c2eae4c804af1d5ff7ca7b05a3f37a9e618d0e9f6b58d74aaae6775a9fa057e7a70f4cf13d41b932568ec733fa39856fe84aafd27ce653ed716e50252577313eacbd9957d4ddb523f80e877443967011fac17e25f1a2af32e08a3cf596f4b739733b5cd6abc852ac2b7f01ecce6fc12e40ee0b3b7167b3fd498c287ec9e9e5ee3453f24771d9a1fcce084deb8cad3d3c690c73cdf98c6414b059fec385ec94df92ec0e96ff0b6fce8bf1d46a66c7abcf3dbe96b896854fb4eb9c157fbd78ed848a65857fa790d717afdc353d40524b851aaaeb97da0e44d560b6b71fc4a042e99c56844253c65b69d86037cf87a4a92d63b7c0f70a939e13b30122747a00fd2258a5c1262c1ecb28df7e1ecd907d6e48d80a0c4db30574842ed232613839d642353e1288b444eb80e3ab6dbeeb25aeb5ec662f8926d2175d8fefd04248e1ac20a9be366d2251d3f87aa306b1cf5b7350df890b42297bf69a20438baa2c699f3519e1f1c98bddc65a4b80c56be95275ef2609f385623a23b5f9d1e816b3aa78deab64aebe640803a2b267b0c6daea92bcc112cb822f0d2971c1409631990be2f4383182685e51bbb059a6eba288a2d5ef66b5127752a1c7be78ed29f248198df25013249e95d5f463c3dd9c824f5e9b89d10908847b3f45aba33faac65a43abb47d7604332b4847d33dec8ea9d761d5ee722bd5d92d1bedac0306f72b9be9e97af1b244edecdc840d6be624f87d29761a1570c76a5b550a68fa7232d77a661b016abb4a0813d63b9aa4a630027681cda15ed3d74b6973942cd875367bd205614faf39f16370827c0156023885259b1f1bf8169e26706bb1c8826b430276e9106fad7128b6ffc03d45d1bb9579770b4acce2bab0e445fdcc59498b71fa236c308fa701be698955420f51dd9dcabe3d9c4769e30330ca0861c2355014fa6356456c83a788d9ac2283cf7e42bd21ba1443d197fed3ce6804e1b16b8657e10dec01ff1c24d469ee7cc8a03d2377d091a3b219a09f6ec7e881a2b372e4b3cf39c80d7b0142720f43bab174ce1a2ef494db19fb76e23a3872ff42616b78309c91c2095c3221d866a440bac1ac670fe98d64cffdcd7dbabba353d425457eb43229b31cd80fa6485f4c18715fa0d45c90133e1c76f2a752debcf281334c22332fb78e4faaf69ba26b2a72c36926e221482284cb009cf520f4b9309683f06927849c01a068a5e48da37aff277c3ac0eab0bffbc149d1d4db95a9e8ff43ca959e3d2b03a7684edf09ee570c56f16271ac5515218b2ab0640a774677ed3293f13cb12adcb63942533cdb21502269f94425dc981494765691efcfd044565f7380b88d3e21a2b7c7965ad3dc2add5dc523b84da8839d93050b52239eb28c0a159b8704aa39e1d8760b3e18adc3ef6ead51db103529ce45af2889d6ccf06accfa1219a23a9a666d200a4020e6eba18a2bc7b5803071cd0a82e512c93be19b89387d612413bfb1a69c1b12c4571dd235a2dced056931c8ed6ae07191ddda19b9cc636cf970e9b739678c3b431efed3902c28e2f797e3ccd2d926b0e213ba9243e6d3a69734849a7c835dba7b4b2798d8df70ab0b15a2ecdef0814a94d03783f5ef7c56035ceac5b61298329e6132e132b6878991343cb0d04b4666ab86fba750dba0c4a70d0d1eb85994a945a99d65ccfd37a3fb4d94eb0416b6486811dc30123ab84687b74c0ebe6b560a858e0e67ae701878dfe32c1a3c528a08e5d8df62086211ebd10e5e7e3e2ac1ab4a75b0275d4918d6da7271f31dfe48f6caec016888c8d24ee05c5a383c05f3ed96379afa7fb6d68d43a27bf269cec51d09a3505e52d86954a533fa8497e079c0eed2b306677d4a7f795d9f511be59580042446ea4354036c15bdc8d07b66b12dfeebc26bf663a9e7d3dd97ab6456b9aa16094b5d721c15184dfff255a1d0fa44dbc244f8d0699fc7d1277d34ea7e566e3390a53151aeed617c8bc34bb71de2f3cf94225efae314ee9aa9b97134e99751d292ac220e7082e8c96ac9f5c4cca9583fb9a8b44ac124c1310cc303c6aa87f0679817a0d3b8fb529d5055badb63cb176d00324e2bd946e8bda633c84fc68f4c9805afe23ae07161058c555df10e556bf46d39776830fc562ea8cb4d62e2f6f172bf650f5f4c5cdb7b19d7e7c35c87a11c1b94435aefed38f968b89d8b22c937b094f6c6bb57fa7bb9643d101cf0b362657b4705f845e17a7505bcc34a1add9cb35f560743efaafe125e359d7d2be8391aa94aa6a7da76221a4b8e9e1f9d4410a42625a2eb02998427cb3888ebd38475ccf5ac0e3b3b606c5a2c531ebb260755b9b58c121b30ce8830b9354fc5fedbf56f7e851e867fb77999013fb23852e70739ebef812b9ac3f88d23eae853550d73b3823ce0d79c12485850036fd8b150691af3f1badd790fa95c3ff14e378d84d6f344d10f71a28c58fc865803679dfad890c57ceeec73c2b6135010f89db5e3e7b5b4a7d7998df0d2ece17c28093cbe781fd41e2d990ca8cf327337efeed7c50011d3318abcd93373e472af840e2f54fc0374d42b0a39be84da0401cbae06c5915db9debc09c08832c1e8934f9c41116f89af8a76d9e2d16c08bf16167aab10c7a0e8eaf86efa2489aa2dccda6b9e9055c1b9dd657df667e5ca92d4fea064f744217e6995606296898824a870b6e56b0da97285c2f59cfca339a0d2c3163867461f0bf9dce60134ab6c4a27d8d67b0b5c6ccc912bc4d3ead69c5333dd3bff3223a4f7430ae02f639a20c451cc58fdd4a9b8e41151d9468b5eba9536e9cb93a5c7357bfda2d1170dfc2f36224db013aed2146895923d34c27ec0ac34753d85f5d7fe455ab200b012c990ce2f36dca2556b2d876dd3eb9bd4a8cb663b54f7a6d8c3e44d59e7e7bf279c3b68f789c574c989a6a4ca50f9aae21d63f83016e63a849ea465f0813309571b2f85e69247bb7c739022220517db8a2567015b44957f79abc54b2476a93945ca2c9139a4e536f71d2d3aaeee394502b94e09b6bc2fd59a04e24ec71f2cc18836efa6198c927234708a47610ef1ead469e50a74d1df5f618fac1480c49fd4412015c571fb4636edfb9374356cce8a6b3bc71eba1bbc210de437d53e274981ae86bdcf8f9d70186d0dc34702896a7dad88fbdf00066d78369e589c6466d916421c8b8a7518e90c637ace81f57b58d9369e64dfc373c1134330dafd6b0f345cc3b564a35cd5f5c8c46f522adebc3483f8ebfec9c5e55ec4d2d71920d5e819d7f36c8102dabb964195f5a8c7d978e2c0722e6a2d88a1721f531a170105e48c472766859093c83d983f331f31f9530ef0ba357239b635dff9e671f8c8b4c353a270d30f1b83ccda18aaff1285845a75970bdee9cbc8cdfce0f1413ab50a1eb55b3e6fc536112d7f48acdb02242a83145987d0e957a5108db601db43eb30248f4905a94c51d520af40931090ad31a1247b82416fa20af9beef380a666be848df4ad38213a51d913ba875a9ee509995fcccf4fdc9d3d99c99235902d04cc83be07bb4cd98d3a545ee611a9819ea60b57b06f0cf5800e838cf3e0624436197d41a89b9caa245c96649946327f4f75bc240fb575b8a2cc49db18c908380e75dfcea36265e39748fa760e2e1b8c5cdea9e2b9390350daa3274d5113fba706daf650742a1840984617e7d123cb249990cf6c3f794ad3240c4d3a948c276196fae7b80a7f25271c9b5abd721c9a22c4f85ddf0cbf22c4d26379dcf3563d08e26271f9be35326057bbb4d13e1545270fea605c2e9aa1a86d04d49a6cb4f6f1962ab6cb8a6a6af64a1d850888217fda73f2ef33261c64dc95b36c2d481d6c137748964ccd0b8b0d7e5faea5e15053a677e4c713766d574648d519cec16beed9294ed2a9781b268f36095e6c74a4ba887871d2789881447f29ad51c63d146b19a3a3719223c5f7a1cd5d3c1ce2729796634b93a60e6c9eb2e56c08986a04552aca0f6f8285f6a81aaea1f279ded9183a3a521cee2e12c0562c7b081faf1543d187a2d24e7116e5d072d30ed6f1a0932d661ee08945b2fafc26388e705695de0be5f66d5ff8d0992dc7ac7d46cab2705012569df615f56e6114dd28968ec8e5f4c7ad3f8932f5fd47b892f52134710f08b2eec6483963ccaa2920b22b0209ff396440aa036fef7e7da9e395561f425ea3caf59193ee70c484bc7d7579427b271ade4621d14c7c58d6544b4dd7d37fb53e3f946dc0cb0e5b2fab88ceea38090a25d4a0bbe0619625dffa9876def17bc51aa66e18418d0456856e90043c3daec4e0dc98107bd185dbb9d017f8b5c395e8a5897f048bf9486472fee0b5a974277753a43fe75c41653d7273687de24847218ec4a13bdb702ba91a6117c1664008fec6fffe67eafa064650eec481af4d9dc75005054675fe0b8fc62628444f389d8b441e313b09603bcd0f72eb26164ec47b16884ee07c93d7c7ac94db8f6b1d1e21fa760137c2114a60291df499bca1189e06edfcecb9cf45181493dd9672f0103d58e856afc18dc5a3f9a7a60e65bcdd1c7357a6a12c86c48202f0fb6d333dcdc6800f059ec40ea110a3d930251b8c16c4b5ca8b468f7982141611b964a175bea8ad60490287486befd9fd161aa45ec2b6ff31c868f2e4e5443de329e4b458b62751d93f73f329816f7ce143a4994440b7b258bce1cad89ae503b7cccaf1afbe1dd3235c858e099db8fcfe39c96529bae881eee35ce2d373d03dbdbce12da8bc435ac95ac69c912631e988b096fe530e06a0b1363c66d24df534d93d4053f5658ad5eda8371ffd1d4c30a01d9fd8621fb064b96893d662c7eae1467ed0eb0afc86184a196ef7442cc6ef494cca62971aeab795d85d804753385b922af0bac2da5115f95c0305dc93fcc8006ee40ff915ecc255ade8e7b198bff75eb337f568b43e66f0bef83b5fd1eb0d5d4e77585bc02df387fa025d2037a6dc1721cb8a35ec27bacbd68e7b9279acc18052bc3e4545781902034ababe4b05c6149fb5abf4a58d24b7e105daf8e284c3a5530938ffef8471c066738b7866028fc5e778f82cd858bbd272d33a5ebbb7b5c17ee4a43291c850594b76457a341a7db406a90abd6600df15278007e2808d4b20f58ac888fa2f3292681ecdab428725cd695f2bcefa6d549cba9074a849f94361ed72f7a89291e286eb1242937d9b7f821a22b31130888a3e1e07f507d90fd2d93e3e4b6b4e69348fccc4d7963dab7add50b61c79bf452a5a39865a8f15d2a35a00a4d3c63a37c78d6cec89e7602097e9da3251fb0c7d7f4980f56c08b39c8057bf79fb08718e3b3bd2f90572d2833d27a51c0cdbfe808738a3b97370f61894a9fd49e7ed0c17e362dbd50f97756a8e52b9712bd59947ccd58aefb433a6beb376913acd58d433ad8936af0c31d5361eaf2809ef4b14de6af75f31784293e525ef540e9fb305ef398489184eec9ccae821e9c9c6c90559a2e36ad036f83fce87aa8eeacdb8825f653e8e9e97a32402a4f469f2b0b4c49b5fb7b64e46ee2a2077c347ae0938bd0bb556d55c2d46bd7e91748c1e0cfe76ed6f4b7b1eddc36555cbd9cfadff99d00a42b5f572fde70e5723f2ea280bddca9251f7b9a40a9f0d7e031062728748ea2b373c58c51b0b4820855070e20bfd56f593e9d6bf859e1fdb5e328ecfdccf5f899f07fc3ce605e505eeb39e699694271e15f1258fd2ae4f9a859a3ee02b80351a7c678f6bcc8e77dab86b486259ce78c33c7a772f4d5aa0482df18ec57c402e78f6c1a5c079fa3844b7c3f1867e8c7322d3c35da147d0bfe50c8c0e81c6873419dc29daf2faac9764606f034cde57aab19f72208a86c3fb1bf1f4e5d8c3c74817395e2274c680bf4343c9f344bc1e89f4feb8fc1825565c8a03d51136448b0ecee48edeb42fcd942e0092743880b17d6229d39046fcc9fecefeb8325ed406060151ce0e415d63a39478b1b8a971c6214d31ef72ba4e4c83e2aeb905e62a2fb38ff0820e5e4e5215d440b8559f49578ab6a98db617ce14ff3ef3657c0b574f3db4b3766a07d14790b406772cabfeca3bdf5bcc85ecdcf5d0e4799f7a5109d18604083d83fbe6fac01ca8de9ebc80cde9bdeaaac88473233d1ddf70876392f2a8389d0e94acb195381404a21336cfcf67ec6fa74487b31594b8569b6a5b939e424e34f5116757cbef1a4c513ec1b6cde7607d5be6359e9ee6079fc48ced2b9965b611333c02176cc8d34dabbbdec340f326a088d64934e70a18b3aea0114a23d35dfc3afbc1b4ee996205e8dbfcc4bddf76a83f7449c19b20c29e52b499c34a0d77f7c40974f0cf5db90ef30eb0f1b65996c4a2171e082b45921bed5866dfdb4e2a363d7b815174a3bbd26fbb7f6f85f90142da320a97861ad0403d8ac7058d7614cc8fc874640088002b8013356ff86b6c921b8d5340dedf42e5af80da982f827dba00f1512aa2586bc687838699246a7eeac767b0a16b1fdf6b749acffa7280634c85e15f6513f541aeceeb3746bb26973971b095aad95ded445f6ec1b15cb086c09fe60f348186fad6fb286b55b57d3e5620e80aafdf33fd6c5074ee1812cdbb3eb0d3957e10f339695be4a162bed842a626d0d0f8b7ff1df5811eece2c2e0dd1396a1eba976aead7ecc2c58badc43667dd67e26dd854765d5d7fb054be76c0a33d28d51fe5c3534da9140d97e259e05e0529e67612f39553107a09f9ab4c6c9b39d6a99bad31dbf5ee01f900016f37be97fac8114c3a5f65ca3101983f0675aba956078a55acbe146ffed5c74e2f6e243691b8519e849b1920197ea8fd2b2625ecb1b62d8152c127eaf9a1e2d28caf8235b2ab3a490f1a6e0f0c31fb93f7c6455631e91bc44b0c743756d38bff96ada13ed1dc483c618c03f7b978028b6d7a758d0cb30fe509fcbcf10af9afd1950a68ab1788a59510325703f1ae71e8171c6f8e61744141773700c888e5f02ed617612a561fab4cda5f77045d9d985f011e9f6ec1d81dd692871cf6e3cd43984070c6a702782e0fb6afedbe5f6f32950cdca82965688bfd8acaa12c87517d3436cedcf0d133660d14102600441340cc48a496d02ae4936b0536e6c392223abe673506a6b9acd2e38012c382ab6ead9da37a5c41f6e85314110798397e6edd5fd9888444c7e20ad9485842d89810ea92623ec2410d29403bc6f65bad41b2373e0e9032573832e2fbb308a75ebb5c1f8dafc5b6d13c018bc7cacc9d75ec761094361856fe71e359f14b5558bca5525664c4ac881aa2a66bf10cd2347702e87fef0c956379d390753b61e522ce3929cb93831428b48c44e1d5184d93853a81a92132b8bd56cb772bca3baa8e67162203fb105f310f306a1647c03d7f68e2835b610b3f4738a02326ce22624e721fcbe9e6b84019c4898c18383054571a3cc0f5c657c11e3dc558f0379b0c0053fd6f2a4c3ea5c58c3fa8af3d22539c440a59917f42e61c4b7fdcf32931d9e5b13e03e5a2f6450f8d8efaf57ca4990266a07f2db390fd42dcb9217bff72b85062ba976602b71a27783900c059c88678b4c89581425c8f1c124e57d92488873a93f8c34994b0466216a2d67bdee81ca762cd9f93409a6269b978470ddee611f75972df79d698979458212c631424ad3d224bab7c3a9879abec1c3a9343abbabab071cf8429107a03f337d81ed83bb52b0e45a3df36809011800c6ecc15d70b5dfe14ce978e1512cc1ee14de24e792b1a7f4af9f5b99be8c64bcd36e7625d8777114717d3d318ce359b427de7e9d37ad11e78b09fc927f64c0483c6a46ba531c2f9321b7ab4be33a48a52238356d8cd59549b9afd22c4ae7ff379738cb8a3d8026337bf16373b4ba27721f864acef80970514dee553b18af5e693ecc9c1c9677ffd1178ac36a958cec2462355416c707238484b0e37906c08fd6a50de3236d6a4b772c3440b38378858cc678db98f528b25c037efbe4e79184ab01c128076d9b813abde41a07906530d3e0ac56212c9640548b5e3b79776d6c5822fa1d501a8f2d2c0f2dde863e37ff175d2c973521f489065cbf18750fd67f2c24ec41cffd186684ae0422d12eb8587d8069c39ec9219b71c5437a7cb4a6794fa38244082abb868312dbe16f56fbdc74e695c0fa381f508d7cd2c1957d50f65111148f9179dfd9a1e3696db67d41a5a1514547397e61ceab521253fc847b7386160ffa42f10868403b04b0d1baa95f546b1166bb63c425527e22c9692231c9a95bb7b83765d86329bbfcccbcbeeb59daf7da3686bba79e759f48d454fb9066a291f8684fb31c576b888a356a89389e8159e12b159c5bf3a72951ab7ede6b0dc1480f48c28dbf3a413cb4ab18fc3579ede74853d4c5748b81916d666827564e1cd3cf56fdc305c639796750f08203b40db7d1178b15135e46b6cdd3ce79f7a3807c075ff86615360dd98e15ef65c1dc2c1f83da31298e09af388d5ff23ca64a13031b31ab38b5cf17d108222974f1ddf367fa7208841f3739c79e53ef9bdd2a711e8114911a0f2a928e9bd25ebc65bbf0a9758e28cc4ba1783f3424d1fa7e2d770a2d66119d21e4d2293565793f1697ae4a7bd315e956cd38b2766049d12a756681863a6073892b675863a9215b60b5feec34888aacd02dfb8286f504235ee3426abb7b3168b1ae091bdf333aa5a257a8352db986744ade0768d603ac59d252a35b475401c5354e44ab60c2d0ad16d01268913eb25b444ff75d21cf8a0d970d1d8a979719fc0e3fbaad91c30b5c50ad9ea55be1fb6c73626356dabb8c6cbd4792e3c660c8a2ee8c86c09bb309ca0f914bba010e6a3992da52af7f3ac171ca3dd34817ff71957d3243e88747fcd306a03e0ceade5495d4a0381aaea01011004847d95853267e2f83dcf2c9dad00a89d4a8659921919949831996080b365cb5ccc0f800395907443025fa627543258311a1d5c5f29338a55ea197a79e0141a05022bf0579fcfa5919d0f48d16e41184cb9a624cc518a848039c7548dd0c9044e0af633e591c58608a1a0e7ffe7de44dbbee241660487d3b89baf0f87ef6c6c93cfb01f1ed5ad22c87305226971a56cfd97ea9351914558e6ded1f5770fb027193a40d71e224e6b39d950b471f877c7b578a26a4fd01d1234fe9b58890be6ebb6adba70e3766f85ac3d4edaee102b9a3ca4d4d8ff1b23d65adefccc1952a3c69c9619d25c65fa30ef7784e92e3b0efb35593b5a0ee6e2752c00fb5628738d9ca0237dbdb0904734bb2c8d43e925897eefc5c3874f23fcd652c5546c4a026a7358846a880167d29479ec0fb0493d08bf0abe308936d414dbbc9fd22bac45025a7a8f188b1f0a3b8afd3a653ea3c59f2ea8d912f42050ac96e4f7c61b6a573cf092d4f828df1c842ed6ab068bade59ba329c37f77abd3db43e5d21499451cffe66a2d0eb0821b29adac8a41b8095a9f044008c789bca3373d9628a9a842bbcaaab1c3991b2adb5641658835de587a673df0935832a88b74dd32e98dc5ee09927c5d66f7cffca44e77c0a2662f920b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
