<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca72b709e9ce314b92110465b16fd0dad06b2b7ec437640545067fd406b4114f05cb2e30d8a62070034ee06154806a54410fd794d228304fe46f967abbba7492116a43f29a40c86ba1ba25f4b68ba0f1b0ab3a6485c969e93939cbc799ee04ecec89683f146284d436e12b6107bac90a989b1d924c8fda1adccefb7137c9e84bc967563617a62c3dc39069dceba82500fb44cab5cef625ece24f782a8b99f6924d31839b1dd12898a3b4f43e02ab1d332e75bb9247c5ddfe5e421291e04fd53d0b4b832c082313657f5570fe8bb6515226f1d20b0fc794b1baf058b3657cc0ee040befe27f8a2f36d1350732b3094174d6327884e15f8e45759098ffeef28a9e10127c22eef8011a3e385c7b7010ac60a2141c9fa67399ac4653812cf6ea75204fb9a04118f3aaa29eee33dcdd575763bc0e0b9d854d9aab99fa5130e27b6f0b3e72fa059bf33c4237e036da3c8bf1e90711235a9822b532742697251f9dd9c2b0d3ba99c53373896d2bdd5d77814a2fa6e5f83494718629e4b2941f97aa39dab869b65a2adc724b6ec39e207372c9c2ce47435d3a06a310ea13612f9cf74e1c54e99b0a129b16f9bdc16a81794841951ea5611d21f11456e258d8146282fa8da8eb57ebbf5e1144eb9737fd7e3ac700f459e68ecb20359afc44751edd561b5a09299dc8c614b574a8423ea09c068e2a34ed2e08f17569eccaa220f807822e0163d66cbdd74fbb0c4cfe7e9d12f0d8fa0889cd04bd4e994f5eafc8d044d5b3866b357c83918e2d5bb660a96168ce2027b96c4dadcd71ea0a1ba662c104915fbb3ad78b523b9e165ad306f18d0de56930e6337f04ebd1fabc182d16af5b995f2118e0555730e55f479fbb4e40ef96cc98b626693b5fa6e88d4cdb24786d17bde9eda9fd480aa3df7bd3ac725b2d4756d161e2d4c6ebe5d2a42310a9d42eaf8ff26982d61fdb42841efcaba994f08149daedb1520e07941404bce985fe096519fac100e29fb586e412bb0d9dbc3665bc5a179ac54b5cd58ca7a545b736c080372dcd2bc5ff360d3ea0f364cb9a970ec2a1ed705b9bd788de90a0bdff595561e2a8f7e618b97c6a018a9f077341d7ed380f10e94d0c2418479b8c6ecb925b7cdeb352793f0ca528edbeb92943c16276429f6f2f275ff0153f73a1a2a62c286d0b090bdc2fe0aed90c74012ab8fa70875b4cad7b66bff0eca99a6e55f762a0f97f8eb630959a489b0a94d7610c77134cb578bd5386d1e381e16acf5b251f2886dfc0cd9aed2e1a60536e4ec36a2983af0d4f57a259e1c51aa7d32f9471ec8d03a8b66c6b8b9a19739bc3f8d770afecc5b7f326a9f598d4e4ef0b7a44ef7b4d2789986213394d2347b38715cd7ad780d7f475c0dcfe45f29d70bab187ea062c03259c50bec5ff0bdac6dc6838bc09ce085fd20141f41d57322e2f48c760260422c6aca2586040e141b76aaf203e260006f84d4a4ef0a2f4975f1acbc75480f300794325c3a5370a7dc16b2765f66ce0938746b0223d80570f9a4d6c4d6b0b8c7ed2c335b318905413e94820f9b8a2a32fcd2bba34db9abe68e241f607485c7e7f0a23d11ac1d2533f096d2dd58eba6d183e97b94acb7f9066419a8eaef6526aca786a91c0b653e89884d1b5dd2ced58344ed9827e84088881d5a01ceba994d94bd89f90cdf215f648ff8fb9f59daf2cf162d3942fc63b38ac4669568e7999b7afa6b9c030a26402ea006c704ddcf56ea5bb71b4ef5b9d2668797454d1ad2860f7250f8d1600b05826490e8302fbda81f1a8214dd55f12d92a32e1ea7995b11fa9ddcf06b991e9434faaf4c8c3125ec1f5851a68ce69305445d1d885e3f1e26d6a95d7b7fdad962d9553c37bf71ea8f231d17f5c9daceae3f78d281a84b50412bef90e5e74db0b6b401a363cfc022c684154f6711054ff993b0b1ff1a71f978b19c125c7056bb3baed6fbc2078de244fcb152eb461e731c77cfc2bd5b918682d2c111bd13796344bd457687b3d1556e367f42b30c3921bbe9fa8224aad1f40deb651780486540f43fb6ad0cc05f7cca47a502d4cab6c5c8170e4e6435bc605dcf75cadacb4aedc8947abe8a3d1c02d2fcbc5c93e2c42e9b55a13bc447fa882687f7905a050805d55bac7aace9987877176ceb5ca9f469272234dcb11e60af64f4948573307b83ec2ab63c7f12646cd292dcf0e78d0d6525b87900b3820ccfff225fafbbdd1f481c9d118dae6e243c6a9d629629d78e659468e70dff56b63ef240228bc5963c581269bd07a6014feee7fe9fe9d94f3dfb3c735e7fcbc3aeee25bb5be5b0375878654f8bfed4df4453493d2cb4ea44e277f6ed7340e2850cca399d160ba0b600238d8e326fe3badca3b066525cd3c713d6c5da2162742263df9c9ccec0b463d473e2420df4055900eeb1902fce000d37ad27e3d9ed1b875ff9fe190480934f94064900a80adce018f0120ada8b017e0e21c8d15efb7c6e53d522df44e33e500613341c134214b45bb5101b335d7dbfbf3571528f32cecbeeba0d0de9e283be789abb0fb214af71267833d16990ecf4cac1251f5b02e6ffc9b74530e26c166301d54eefda764873e729c9d3ce6eff0d99cfe1994aa4c0a889128cd89ac6fb0e173920ca231bc12d4ac21955751d3b32b7d1df55b2a8d2efdb36798b0cbab11a9566c71bff1e95f194490e099d0b5b2b62370422b36409d769fc3bb8adeefe54f73d0a8a1401942fac8b47af665e041fed2a8bcbe919edd621a0a4cb0204de44a3f2d7e2a112e10152ae8cd2901507f482b720260c713e7a65922988dea103d6dea8ece2a9337f7e16cddfe577cb13666ac9ff1e5e52c9daf5567fa47522ace9dd89c58a637f7d08788111cc9236e79cad81d761aa48b838bb2757a628c9f49136902d3ba58c350c192d582b19580087b4056c3cd1ba10aa62b5585f5083daeb7f6092319912a225d41c5ec627452538b9d463a33f9537c002b9686ac1c88e431fac64f17663fd3bd9eaf6823551e715c79f2922d326856ba39504073ee468fe2624d7afe8d52290c49cb69242d44f014530574d7b27efa11ab33889ca6f92bbafa1bfdcb53e2b5ac3b04df71e13b7b66891e00bef1ac0ada08bb6493d13c3600b951744e7d46cf17ebccc41a6bfd56de99eaacecdd9625ed4749034530726d85979b82f2c21c65af0465e4671503f6042abeb62b9b88222097ffa0648bad0bd4d3c6f614bbf9aa36eb77c1925cd409cfd90c7aa5e95aef160a293821e255a5a04b50f54c8ce3cffb0890b9c2d4df637b83c22be5b722749d53eca3bf7c537052f63000d34e75fbebdf3457f972ae12e063b2366503a37b20212d3d8ea3f285795b4335cab95e0f3ab2a310f890a9711dad1a4ea79fee7c4418230ca0e874ad308f5be4a1a1bb4ca5db8076f12a3798d25da915f480715ec94ea5745e3ab682f35f0dae22f2a85b9952b41bf4a64fb39955e2ee88922f5735adfceaa25b9552cc3e5cacbf3320389629a3923bdbb1d6a4bcc09128a0e0b242629550bfdff6ef20bbf5a1446293213bc3a895a09008802921410f5e8a5d8b796a2d63f3e85b54cf70de244872582d26aff3ffaa5c78ec730aa74052fe1037ba70f2e81fd1b6462fb4267c7f9dc51d5995828f197fd46e0c4b7030eddf23e5cb1eeb0e269dfd494dc6a80e353541bb211d8764427089d9dcfc71c077c93d5b8b55e4413cc85da9e02eef6f865ea86fda8221e618d89e56191f7b4b40fc0dda7b1ae5dcdb0972af7332c56b5e3d182c73d5543d12f45b1fb3c6a3c6deb4b1d5f7bd27a2c847192959d3df02ffcb9c7666d9ca39f1e481e2acaed6a524886ee19ec919436dd5baa73d2f0e323f3e91f6c8cc5f7389a60c1dc9e8875afd45bf4d8f171301fc5cb8c26c1c317dcd89f2a17ed9590011dd935f69ccfbf8e308cf01015c57cc5c7c8b8db210ce80e7e361acd0ce87384c79a426a17c531fe3a45e00f0402d56ab55785bd736906d0cbabf4570c725e6ee3d27b6778fbba69bc4dafd253a5a12f18abf38c0ad7dd19dfd327c434aafef767d15e1b6d62f3d8efd3274a45c6214fc025545704727a7bcc45dda736f7cf2c1d60a2ae86a407dce7c95e437fc1d71382128a41f8ad85ec73b4294416658af97590e17bd42ad1634a0855a932bc006157c038808c8eba6585e54c69f6d28707657a49ed205cec6592933b2de4ba9da426a68daf8ad1d71ba90a2532004cdf4f11f0ed54cf34eb9757eceaf2a2ff0b049aa84ae2935cc50f99268154aef9613313ff2bc786f467f1f84c2518bb70430a7e9d19378c14ad23c80662812122bf034e5e4eaf4bfad6a59b4770f10fe32e19cf39168021ddaff3056ebebe8ea82f84d07c267f78254cc4c0443671e627e753504454d3b7715eea967c84841d79923837d029e1fee83210512a42801a2c0352ebe8fda4950170828ce4a9a2d88c93987c6db004b315d1e4fb9c2b3d6e685ace0ff955f3cec309bc982b7e82228745fdebd369f801d1a44452a0e69312e8fefd9e5013f88b6a9fb1006ec8abcdd64a7d187a5b9eb3b6593e422d70ad11df443cca4d4f8900f5dca13d06b126e8a00415d535b5119c37ebe7678f0be04506dd275002f758f14c143480e1db32583a600f8fa3a2582e1f050c21e3b705751c40b8f4595eea0ac8941e252da9015dd20a389f05c616955a7edd1d25e02dd3b8ff1eb8c1992a0d1c68ae21cfc80ba4bacdb1cfda236835cd201f5a8b2df7337ee34157661f093f26dab9b945d39b5be8080cc54c847cb6c4497d2793fadc64d5cd3bdc79943830224c6f133d9ca169a1ac2acd37c0689ff5b631cadaea2c1615067a32e1b83912b22ff76f8a5a544ff93c5cbb95d7e86513ac411041c1deb11c6d45957d7e64693093bcdc745f0ecc7313c2b064906ab13ba463dea0cfdbaa6d25c0daf94ac27f739a4fb987da3dad4420d125657722cec50ed975a58a0c4c0c0d387ad975eaff9ccacd8e469d486cc296cfa6ee881c6ae06b4bdf7963d1faa2713f7fd708f18161abd7bb168f25b73c465af6003d1e4be75bdadbb1d162ef85800f52ce69d2ed2467c55db9be8c1bdde3cb3156d14e98b20fd2b778de930df87adc2d4140e1c4929315df87ac4737a1455d7a19c26340b4ed5ee2993fbb6cf588d0cd51f8524e4199c8263c7e6e40782413cf5f42782b6915472319750108899a5456b10071b9702f1572e65b38bd0236f414b3065523d876fca7d89ad9df3cecf5a2e69640e4bcbdc7488736ac4ad9711576a3c256824751df5063b4f0e2e5ced94c049c75beada14ef39ea5cde9ade5818fe4866e0a80476c2a95d0953acb5edf80a446ddf07a1d7b1cb4e7f436033c60d4535220604b8f9ac7826f61e38c777f4f75df9b0d7fc2d04b417477d61fa24bea05a04a7bb2e1530eeeea6d6ed7da70d6a26d4a78585def45026148014e0616d24b7ec3f2c6e4df8c6b33b73a2c39073417c897122f72d9e37443a08543c9a56b141d22dc56b32293e6205d7a3e5ecbe5ff817624f81a525c8aa6268d08222486b5317ba1052071ec29c231719c36e82547a22ca0cd988d03a4a16ce01b4158adced9a9e449a95fd227e65c822694a20635b4772e9594756a9a9f6d9565ab18089b2805df9290d3a0de2d67e4b4438a3c4ab2568715c61912222317b1397cfe4029f630bc0504b84c8b2359ba74599c527b4f64b019c93710b6b6860a75c233152576c536c94a4cfefd9bd4f6c24c932c39ac9fb8c72614b438244b6feed63185cf3f6b3f7984185f882292e7b826c34039af0388a949c5c1ab9b0cd78ef320f09934593e4a9d735910f85d5fd44bede5204da03686913847f259a8cd687a356d106c5a5899858a1f67ff3fea1a8a33e89f0cac373b2b8bdc126d7e9be91227aa06af45b4870b6279a9b383570625450afed1fc21c28a96b08f1e17770dcc55c20f083844a7122e98ffd731d3ab2f060fea1ff2236a28a13a7b62547534504fafc0f100a56cbb61d14835d74e4666f913cc0fbb294b9600c49b70a5bfcefdce6da40e4e67fd5273828625c6341846185027cb48c57f2e29a3002a2e646bef94cde09b18acdd6f265a0229e02e1b7f0f1bc23601282b56e7893e18da492de825d85830f7ee460cd70e47fcaeec7a0c8da0678b51148b55e2d1421092d983fdc7b1565e6c71d26c38a6d9441d174434f9115d5ce751b47c859d9404edd27566531cdf4f48aaa4acffa45363c4637220572adf26d2b0509f2a8a92fdf038911008b44dbdc7978d8d257e07ef89579c30a9e61ff83e8cc19b1c3863cba116c5c699283b80e4e4afb36a09a05ce71afd3ef654deb082958cca5b2c748f4a7d144cda0aeece445ccb9e963798bc03ebdd036ae17311ba1f31d2b6113ffb7c8ae790dec54d14e125cb62473ee4586dacf5466dab6f2f2227c6b2f62704d2e49937cf8d60ef8fd222a9bcab6103dc9e2c2bd1d1549eb9c95731b72aec9fdeaea483425b4a890b460ca9c24a7f5ef8b20f0333b80d9ca64e567055b9368c29ec2c982f1d27366e08aeb31379bc4aaf3f52527efa1abd7d6c1568b243cfdaacbc90b093719bc0cb829862aa2b422b6c17e190d0672ab17511b2e45a273082ed0c6de5d5f867d967989a3e6468ebd1c46e8284d5015094f5757062e1c7fbbdf26eb1462a76d3da2260fe221f2b9987248ede812d773c6c3649e876027d39a29efb6546c908d3d66ae499bea11a7e5ccd674a41e8898f139673cd7faf08f8fde74016a02b338252fed3880a72b854d11b77432767bd7c54d9aa48bc683bc4516b804850a0c8e8b71050a39b26c266dc221ffbb12967881d06dffd5ab6358b8906206374e9bc7f1ed42e4155e20e88e4ace80050c6a34b986c5f4d33a76979a87c9b50406a1adf50f3b3b0588e5214bebca79c6dcd18b447315d5d4beaaf87d4e5e904bb3e6837e2aab4d8713ddf35feb3204dc0f953c4001c49a0ecde13aed71849f738c098865fcc5607c29c942c5a05f07f84feb4cd00931f5d7b12df296f44fb13801a2ec18dce4e4d703a3fffe9c5d2f7e889e7e4b8308d5dedb9de045c82517f9d8b6539ff50541b535377fb76d84bab29faf76bca4b2dea17b095457a3de531568a88512079062fae8ac81c7eacfd52b07c40716e7b4f598bce35048adaef0cffb1053b76ae948054eff012db9ff88c095da5cbea23f288e95e323cc14d5376df90887c88b0236e3642c9029f3f6a7d454ac680b67e9db46547a6230314cf03df1befdc157a19bb00f48dc95bb363cb9c1e90927cda09af5633ff13cbe1f58307b60bf7b1cb1fc4a6926a3aac0bfc05d5da0adfba1004b5ad057767793ecc3952fea16676e3d1e5c9ce0c0723e0534f9a6770b096808a7d0e90a8d906ca20fe4b3c03b7eb8df85264a0a80b7cf326d044b8f1ef68037307f2f9404e5278108c124dd96adb2afca491dfec989d871966fea4df93bc5c0f0e13f6e0eb57f6b3e03fad5d8a8a8055e0d88c8bb4d576161432bbfa435ae77a877eadd81f81c01db6cd17aa7f371e4d4d324285ff5490f3edf8468140c1055cbf682ef69f38ad2b90601749f517127099664bbc7b4e0a3aba38d9ff336f3906a011f5acac97db98c1fb7023a055dbeb0aee3695556534809066089810444dae470ff9e15e8e566be08278e54e419fa7add9f8e4bb652d0f0abeba22a76fc5a62075b5fae8680e1a1aea7a68b2cfc8dea4746601318d39966b34239331e09eb46800484f97b1e3ec45a7af5f48760dabeddf4e833d02c797ec04959edeaeb88d7ba5c4c52b91149e0b0813e776c6c036ec863118b8478f2a7e8ea2806ae7271a2947f75d90380999b994d2d04e6753ef9c8a6518479aab24b188181ebf521a5cc5d60480a39792cd64c198e197113157fec08eada19b83c73519b5416be635a62d40a3911dbdaa05e4e9e8a3ab57c57796629d01578a6f7438420ec1e777dc4010cbd967f2c17e4af576ce2c8f6c5dea81f2654090b429343f9f9903b28d109ba6595b8aa5548c0f94fe0ef3635732d306948e3d4619da2646b058e9d57223b5f737bd9a089e546118b546a7a7ef5763b432e2e246a4d6d37a16d780cae6da8ad6e3150d354ca2941e745ee751ffe1d9dbe476bf8bda8db5a9ce263afe8a90f32de1187ee667c9a0ecae3ea9b9c89cbd71bcd2f2bc716527b3b284fd78866e94ce0d3ce98a24473b8e43b2c12c261df0ff78fdd216baeb53da6e3587d03ffa2c7afd60709105fd25e92928f88af7dd3e8c58abb6137c5f6d8c95966e0d31f17d90dbe23874c6e2794c23a32ed5b37893cf5a26e45f323a7c13c530d3c0d6c993597db912f11a9a665316638efca0f31c9fbfa42e0ac80f604aed35cd8d8c3dd78ab7a54244b90cdc773edb7562cfa198bf28cdc8a204d5b1c2e43bb0c4a549617861189a0064e57b314cfbe10cba85558e8b8dccae287e13b7ef6fffa035861673b2c3a684d90e42d10d2691ce7d7fd4a2001e4d391aaee65a8af3a5af215353179c2254d48a798c2cc6a131e017b36e0e8129470b47071a17778611329807a2b3343a09355976cd0a7ac993bb41524f43797031b5355801c1dc9d8ef733cf2b5958183d8700562aa7ae7b92adbee2b487f51ac999b7fd8fe11c01612e5928140e46b830a3fd7ae3d3514958ef0e22bf05b0c01954fbaee0e6e192d2e1ff3c0b2f0633848d1c64967642397d0f14f21ab588024e019cc452f3ca9bfd22010b9f55ad7897089b231131f24466afb7a119154860791e056201318555444046a2956c653847d68aa1943893f2103b87b3fd50550c9a8803b7d62655b9f310871c65df3733f74a23440432670028c23c6ad7cdc9a1726a58be56dabeed29953d16eec138f38a1ab4dae96a4076b1854e1b9237b2436b3996baaba455c192049c745820b96213345edf9bba51eb139cd0fa5e0b3c3c5aa9b7a7091177cca4740d43b0d7fc091ef2051a11cb1acdb923a15bd27c10f90a4e9c24a6ab1d5c44e984f4ad32be51ed91f21c230dc807be926db656bb0baed7628e71f934f90681345584e42711de4c7cdcea580c0498dc6b96def92ec6dd3f4f631e32c5ce21d8031e109a43aa69d27c9b34477cb16651247e77c921839bf449196bd74744932b84468b1220f3329f7c00983e19b13e2429a6697f270eee0e9c00ad893bcd51900672ed3dfe0ebd28b81e155060d477a88cf21519a7562640e5f4f8c677e6112a013aa64cb3e83bb1b23bfb18057c75ecf29173b509e873092f74e263c764f8a09b487c461c6d1da6142974328a4808dd94993b6cf4d9fdb6230733090b16d2ca4d1697077078a196c417a214f9ca68d1a7a6765267be2cac25ccf9515141cf3bcb65c75ed726886a769f00515e20e179e60e62bfafe405edcea06932b68caa18f9374c67c34630c9321881ef6fa7270440898ee4e91b14cd9126fda87085f03ed324af507779d4b4cc882f79ef4342eaa3764ae380fabbb7fc6011448abb9cb492e5c8b81ad68ef92d5b8a9c75b102dbaf83bdb220005a5c0ac0e2d4240385c025620f7d5624cba3a15c4eec2e101fb7e8b72e6b0a6b0c12de1b5d337fee7b14d00bf21d7be09f8de9d97383260c19be19ca08ee924ce03dbe290d8ab9de09c1889bd952131e47a9cae8a57e0040a5a154eb9430506ccdccc91f5dce8d322b8c4c786fa806d96f00d0af888535cc09b8e3f711542a2e72ed8afb6f8b9d9b5711057d83011d0639f0351eb9f55c5a8109b5bdcd9e26f56196f58326702e310c81766de3849a9ef20f40fbea423a11109ac9837d8a42649f989e56debb761c55e2ea085804eb816290c8ae4e18fed9814939baf6a9b91109e6a4fceeabcd459c01b2acb63705e62d4d3d1d6ecc25df196d7f7ef7acc4695b3cdf824fedd4c170ee9084efbc10ef05d00b9a176e76e56a92af2f79f86a4e3318a2775f2e2f49efcb799c81d875ea1466040babb4e64090d70f575c9071d5b6343e044513f87c95dc55478b08fc23771eb0c56ce52282edc3191fc7e5af3771fbb52f98c172a3269e8e1f3e08256b8f12559e82874843ead00c9ae0470eda007c9ec8f25458556daf3a4fd2e8a5494386ab005ad904b3123f45ba31a12d18719b8ac9a09405c5466497acfdab87d8358290296044daac1f1115030403d8aa5706111de84a2a2de4ba81a7e5d96e73c4e12f512c28f921281213a21e0bca780cf34e41a1b0fbf297173bf9d3596a254717788f24cf427bdfa6223cb03bcb4a2f0b123322d99068c91ab5b96c39bb99cf298b8fe80f9004d4b366e408c1c04af5cad6387a4f8ca921a9420c4cdec33546ef8188e39c5a0e1a8ffd916ff46dd9b91f3eccee97577871eb1b96c84335d1a60eedf2978df414137046f68bb7aa8d22d00837574a061a1a9597dfbb736d549cbad57f27c15c64000ff89d6a77882587fc43698f42f819239571380b7545baabc9cc510648562bade84c31c82f8c6438d76605c4287039de9d86fe9938104f2c774646344d425a996d44db1cb7ecc57c4c42be477d02e92b7d5e76a8492cd4422c17ac398b5b880363e0143e35d4ccb1f80fb327b70229ae142aa99ff926205efe257814db8fb4db51df8c277ed6c9b4bb2cb2deeabf6b1304e1db535acf11f869bb3b359b23bc89be71337a7419d3a9cdf6bd432b07eda0ee54bd478b9554e08a6c4010c0f47071d264d72b2304d28521978fada08c9227695c244eca37b9cb901031a69c52d1d37b82f759d01b54477536fc909245b0bfbdd67a2d841ed357c08e99798c0ec0aa05a6c85571cee99d7310804410b300ec28be7048eb8afd729d51a09dad5aa735299a58766ec6d0085fda2a16703c8b9f45c18b576f8de7312d36aded2b7b101a56345da0b57f5b76e397f99c8346c20c96690ce43e851ac9e3eb57867585d4ecc5f072f72617d069f0ffedac0d9579532978ec24165e726123898dfe058b42ce09f42dbd68e1e3612c9dfcfa0ade559ca07b6f1bd2404b6feda1429ff2e36341b98b76304ab6b6d37856a45303c3a8a3c15f8dd74d1f8fbee2b71ff146cd3c8e79ae78be1f389613c74f325b6bf197d4e66ebe09c655caf46df0982ecfed5cbb26155fab23ee18fc1ce77b2fec814f21988cac787297f20227804da84c62fc1660e060967c6a64865a61ddf9fdaf7b2b56b96865d6a86108c0a3f48d81044bf43bddb57265504b97df395637800daae0521515e4198abbb52604a2fc46d131d444f47e1b4fccdfb198aaf6c0dbf32c701fcbda3ccaecd8e13fd712b2aa724d6e042eca15eb6979d89d5247ad6a6bf94cbff49e40ed01a8e83638fecf9219118d93f7b2680514af748afd2e74e84493b445eed2459ce78b37abaa31ec5607e29c602e981a7ac9969e230c4c77bf22ff70f85a30ecc765beb45e6aeb59579aa2cb01a19ea5de86224703d69b667c7272d0948b4c2bbe3af85a74800c6b1cc6bb443045c5c91b5b242be1c9db8afdb8c175de377919fe0479c74d1e2c6ca6d4ca89dc28f002553297e76b46f5651c847ba4c0fa336802c6ab7cb2f96fccff548209a87e8784cf64b04661a07faf80f66295299d1d4fa17056b6de766b73071ac9a44d8e65b3f7ba5c39507c0881e48cce2b96fc748c775a66ccba5f6cde2bc44e04930a5f3ba8e6ff90949b6203b6492fd4a2e925740540eedb0501e9b728b763177ddcd89105468028bd9cff40798bd33dc911adc6f76c27566521a708586e7946fe20dff6b29390f0bc2dcb408bf79bea3929c9d5132c2796c455dc8d41daceefc283738cddcc5a1de339a09ee6d4700c6eb5f0b535672fffa0bb726f61b4cfcfdefbb2743275bd19bcf0fdeb56470574d529a23bf743d75c6986d08366ab79243bd7e8ac5cd16d3f8e4a011fb9dd9dcb7c42e51537b73bd4c9dc5334ea4c70d2e4161177d37052cab79be268dae636ec6dc8f78f2c9cdeb6d7f5f18aa9d3fea0eda3520aca0757f4956066cae3eaf380ccbef361ec24940b033f8a5e808d5de38d0f62f5c8e18bdf32060de276256b089377bf25c5f32b7ea35e947528379191bd2bb2255a0a2134c597873f6c9fce7103b16578a9b83b2d440f13171467d473c3cb6c191135069a9dfe1babaa7b6cfcf150d5922bb5fea46a7ccb0ed368d26a1d61fac96e63de54220f5ecc4571dea9fe9eaaec7deb3864c48adc5646644051f8134c7661c97f4d15cc312aee7ae463a4e701654b54b1187b9ce80416f721f5e3564c1e330a91d34d9d828d8432b83e2c16e422c4fb15855d2de7d27709a1e0199c4ce49e6f78b0e08cb67621219bb479c721f102b05df90eab48ff46754c9c4a24ebfe1bcafa8034e212d177d5659f92465d90b4c0ce6caaef6f3a4f38da2b5232ab0fdb82d85bb4038aabe04391a092f545eddb1b392897294d458ad6dda25bdde058345fa5f3fb0ec92c094c5cf865c88bb0654c9356101f135bbb04bdaa4e23205e645ee70ed1b6fe125f115da1926616f2d40d62117984aa10aa2ed2fdf0f34904e0fcaab3fb3ec427ff8b27eb86845d9de4cbd0507a3ed2257901a27d9c7279e41b73bd094fe86a05f7cc1268833f91d04e6eb52b41d931472a903e9e38a43d91043100566044cf90ef7ce3e8220027118570ae4feb4d42f06949c14fbce641d1f97ead02aaa1ee9af7a6110645aaf2bba866860aa6b564e1cd2bf98ed8abf6f39a76adecc3091c7d35f8e1b410b42d8e646661e6904e0c893a16292a21a9208f4a214187ef50d59fcd8323f5839ce26ce75aafca49f6ec5865cc389a0127c5ce6fa8ca8fd6732bfce27fa5d886b91ed540e1d9c939204b751a43ecb6309cff52b3b5a2d629ce07befa9ef2ef8313f0d02b2476849212dcc20c30d9d5dd9e27bd3c3e884d7e57d653ef412c33335ece422900cd6f8d73aa04b2beb9103c78792a9230dc22bfef13e746852fbd985a9ea0a594915843bd3f58e0913dc01c30a615278986942815c058ed4810f37be5b89afe8e9b8cb68ec799db890572b1a60bd59fab9047c22bbf62fc67990cf0bb9713c5f97b2e950db924f2bdd1c97eedddbe9b9b1d0438cd6d07c5adecb9fdb8283e3ff0bb983c9bad083164dbce21101993af378a87ecd2295a7ab5e5814ca3d725e7d7f6640d95b0c8e2622d8cdc3350635c36541293aad817318d27354bb42b36ec60dfa5b336d951561042291947121dbf578768207e98fb78c34c6d2c51f200e7281b9802222dfe31ad731943ac0aaa0b762b6391fd1c6f461f50809583c041f0c380b4c3efe87e1fe302db6a29a3b0f41c0d829d617a91405edbf41b1b1ea618b0d2870e840ba91752db37bd0ac5cee72ac8e97869528899cb7fd5c23c123393d5ed89a666c240e6d9e54ee7822a9f7b00527b43ec311f3ab425d47af429dc9c8e5d59a1e393f896fd259957cf89e0566350af110d5accbf531de9466add83b8003f947382c5d8d22b88c07fc6f66f78c13ac077cf15cffe126b3a61572a3d0a9d0c9f70f306b1df7e4f4bc48c6551d09abb3d1dee9edd23cf1d42c4552192e7ab53317f79fa0dbf2e4a758fe9efafcf50b68fb204e011aaaa561be49df3b6ba960c1e4f075668e53510bde5fa06ce18708a14755e9df21b3bfdf9586bf61b68849193e0073ced644080312ecf81e24a7e37da2fc7b5c922ff5603bcbd9e6ceaddf3182f163fb2e327ad8e976824484777b94ed1d960329dad54076b2703e48cabab77874eec8532c8af89b991e95d085d0da9d6d10aa6fe4e9a31a46e8d31396427a286e30ff77fcd3344871e98b89e729e0a905d81c6e13d68aeae3fba56d23098f1877c0343e25d7612fca5edc8984a94be544f0c9ad636c560d3e04b28f78e9dd50e5067dba018843f2736531dda79874a1dcfcff0117e2cb93e6999c86e809a98b6e73007b2e05f72e87ef8041e8f96f8977e3b4f9726d9261e27855160833a0ca0ca1c5a725e813d9d22abaea221b8e53f2ba62dfc008a6dd1ff512647d9c1ce6e5399f2ea9590da8e67c258f52e507f49440e12c577a05f8d43bb6040eb3c180a5aaa644e1a2b2044f5cbd8afcc86896e547eafd51043ef03f55337dbe946fa26e55b98a160e265ff6bbefa93a3a5f6b64953af0f69dbd6c79c92961f9c22cc127fa2a7390e1894af3e93b3977e075d52d3b15458df5d54f5baa31df1537df6cd61107ebb64ff8957b98ba8b7d19980e2c9a16823e14de4528deac0549791a9e2bbae6e0d5627eeff47df05b3ee4cb627adea912636cdf8bf5a10cd1d54b85e2c3952eded92515e2702abac283b67bc3ae1432fdacb08ce2ebae8167463f0cff68b3c422a6f509166149252e7f662a886c8bd8a99f3de8e56480c65c75baa9f1c160156a752b4d28c6e270aaea26f302a9426e3da957d35ab9c4c0dd6c5b6acdef6b3bfa86048ce4b8a83fe0a58672b20224edd0adbec8a289cdfda063e0af6d385af99eb7ba7a54a954eb90cd08b2e858c32bca5f18d59625851a3d4aecdcda2815362c83750fda3e84f42574da2e7861ba063aa806c73bc56b4c59b62d6ac8c9e2bb51bb4365862ca71de8d967b4e3601836908e4cf16e2dcef3dc70f93091767900ff1fd05f23af95496179493497af059677707258bea6e6071e8614aa05b377206aaa5433bf79e44c94e13732bf38b16c77f94924f0b3491b0c3a57b00c26b1f0d2037f863e23eee642c46c9bd088357e759a2fedb586d7571c9b793798c8374713dca47a7d534eede7734bd65e82b52087a5a060c711b982dbc093412f942d93b4cf624addaa619ab5a267dc8df5a6b63f1c41dba3f0eff2728162ba46adfb4972b771f891d5aaca04d5645bd35109dba56fd92d85a3108b78c352a007561c90dd124505e60ef9d7df1477afe833941018dd57e57071abf425197f82d858083c6dabf580702c3ec23b624988335f316b8351338116657b8d653a37c07838dd1a094e95dd0e8509ecaf06bc9f7924d5fcfca57d6a1dee8f1bd52aa11ef997929f999e80cf6f0988ba07b517367d4e7331aba942540ca8eec0d6fbebd301a3aaf4d890de6d0be4d00c0eedb7f5ab1eb4cfb413adc575e15573c2db8d37b529f9dec4cc8ee04f8038f9781d40d8597def74d057e08a53695fc6d3679f0fa0ff52f7639a6ea7f8d15ddeab0e649147fc110a5f13a222200532043a838118a7e005e5b98d4628ca33bf5b34e803c5f9a32addd24041c301a15dcab094058b80a156a74bc0be9ecbee6ba0cc4a1837560b2c35d5eebe73d20d339e79de1b7f251aa2ee3d37e02fdf6f5e52a0056d7db2947e6b48c77a072c7e03489fa9b08a368a199ffb754e81be92d02b3c7cab7e906e2376f1987b7c2891b8dfca7af42b6d03a67b8a094aafa5f21f8de2f5f1d839dc87fb3b1aca4d499cca502c0598bcea2f3507a8234ea480bc929f5be9f5c3483dda2bc90b2592dd55307d5eaf4a0da45c07ee5e5a0261cc57ec5598ca209fce027d1704b85b25994dde65c342e561af5926b549e6ad4cc4e1a3ced04034721c77193455bf3f3013e9442f6df8d80d002d8feb12e3fc76d0b94e09745687d0647dfa8402d91cf3b8c0a9cd9714b13cab1e06a6ebeb78a989ae566c3a9e838b5dba2e0cdb8082d1464d21be4c68ed546c7e68b322ac4b48e5a348e3c79f40f329dc24ae1f7552199574767f9a235a88cb5f73f7e68ca6d2934514cef01ef86f3651e6643c43f116484c9c3d6915dd00d7899910ef68b6ae8038f58333e47ad5b6f77111a31c076bae0a5f190a3b45e42b751f3d96ebbc3918382552e8d22eef913e75d8023ff9935ee3615cf71b2c647ebf47f22947ca63662ed110d573a1e49ecf7db8f37bf2b36c8f0d26ca54976c5a78c37ce81ac1415b0bd9ecadc2dd517b6cc0619e2da9d3ae038cf1228270cc9fd2fdcaa6b29c4e2ec3aa3caf78390bc279680ff58f64ac86d1158da6798498a3d53008f9e85f3e938e5c1f6813d496395ac5b1bfcce43e49c0c0204d2a4c3e289c310a46dcd2cee25be43aa0ae4531e8bd4dfd84089043bb6ce52b30e3524a8316f3180f8c9ac7ad3b8118ebb7476f2e78ba1721085c72d9e92834a793b5f48b0b995e05e7d2ac12b2745c8c52062a4be6410877d0d6be9b83ad9e94c013bb7bc65f1833b9c596dffaa440d87bd42a2def0a532c3e7d65a1ba9b8cb0be3c87dd97e14f89cecfd09d51ed00c3877050e906c270524139beef66dbda2f0d72382eaf882e2c0023baeedbb7f8e2793289a0a925d955be1d88e09b7fc07c7ffc146b43ee71a8d87fcb413036b8b64d68e6881a953619450ff0852b9123ff9f491ef803614164ed38eced331c492f7e03a3878bec7b3351852271bc590cc606ac080253c180740474b54ad816eb4907355ef4c59b7de2894f652f1e961678d90409e3e7ebb113978f0108beaa23695366511485fe1218c930d897357f46bcfc955ef62edbc289a221bd0020e69b5b980543a1f3f6d78240350920b0fddab3dead30489737160a49012d919cf4dec63bdad5e138dc95ea05d9a3d9e947bf4c3aecc2f960c171aa52940056facfb40c82cf2e0397c84887bcaa9397af923eebb7e9b7e31684cb4f169d4aaf6e78f7c8a96457a9f27fafc90ae2696558177062fb6849c47e22dc61fdb0cc4350a2220a261dd78e1eedc5117f9e87dc4994d2e52a941754eaa07f34b004f5d8e82383946e1d7b4ae588691f8dfa5f5af67f3bc501941f01b8862d2659e40bd42acbf1702f4e22af717f0606d6596eb60485363c8c856678c91df22b8586f79070885c0efa9fb01b19e63ef9f4dd779139392ecd334eb65d84eb11951bce615c5b2e24f388af7c188170303cca253e700e707919e94cb0153f149f9fb351bb064b33308c6510c7328a1b9ced4a19f3366bf28265773e36a927cfc3dcb12604b06e66341756815e614df1afc4c333360b354386bd70d9271fb942925d8e071d825772a4adfe3fc3633687672a77853b7803eb9e1a0c3a7de8fbc7cf368f80a1a1d3d80eb9eddf81a568a81ac2f91c818bb6495e4c667a3935f55c6e8532c2e4194b09af9e0500ad27e368e9920077e9d4340959224e1c9508015cf096ed6d4b285dcf1056865b2a6e6ac68e23c0a353caa68e65836f2e8d5fe1cefb2e5f816f5212604f70bf1b06b1a415935f11605a366406d4b5bcd20886f7e8a8d5234f9c5a29a17435b09c3329f317a61f15992bf4d82cb1fb8a9b09c8b00afe3b59e3be8de394186d1122fc45f8be0c16300571f075aed79b476aee37583fe392495a6e9fc69cd410707e4d007506492600f83decfa05e22c11c18ed685c49a537a74e05a88da40a96a1f61dbd845b57d80354386868bf093a887076184ce580ae8dc8dedc2f7d0e9859cf131e5556d20948304bb545993e4b023c2bb27358ccb49bee97500dff8c2ac488acb755cf537412037c3c2f3af33e648cf848dd1fffd56ef82a2655c5fa99d382491235e3478cfef6c7ca65b188671cb83a80a5174d5df835f60e049de962c8cab40fb126b9b06c1d953121e2d74be18918774c6561a21d213c33ecf260a1929ccfbf383b70c9d660412727d5a293005715405ddee5da529265ac873ad9ef6d144a171484e9b385b507b1886817a5972c396aa04d3529543705215280112d185fa4cce7a35c04890d74a717219496354b850e1ed8a35c1b45f088a5057f0c0f8438486edf2827c0795fc0f4e8cc3ee7fcb3889ec9d2b4014f2175361724be50cebbb63d924aa03c6d22b544169f72c9c8bb0f3f99abebd4943ff22b7a391792a0a79336306433957d23d490d746230ddecef040b6b3911f8c7c11fc5069ace298af044c46b24d8262652405b88a60fcc72a469a1e42f879aefed85c353c87070f04d4829aa02d97417dd75b105540287f2b40dbe8459e291bb2803c0fecaa9e80e68e52a264dab7211d2db3879eb3737467bb4e4247abe9e568480a780eee31365d41e789affc0ea88103c47b34015b2ae11763bf17f7c722b57350c8f81356bd314d8efbafb92a4f9fc420b79","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
