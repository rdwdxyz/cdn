<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66758490d417aa0c629149b6f6cb4bdd4f3a76506e5bfbceb3ada850c1a0e0b486cdf517f9d567895f49b9c69b5a505c8200b9c2405c99d2b28ff0aae0019bd03a57a2bed04f75ebdc0b531c13273839a61ae219678b764e8dae8e51802f5229d124d8ccbc1946007f06adf3b57c02c6f543ba7e652a7bbdb985d2e67a56689472cf75940ca1840b492ebb839c44c392296ce59e7a64c3438a015da5e149f105caec785ee36d29a8433a427205f14e7a2f661bdcef23a857adaf1858356c9b9660d819cbb290a21858d861da5544671e4ace829e401449dd702cb6f86b47570ac8b504f98782850ddb7b5913fce8c725680b8ad332e3956efbfc3846e2c0cf37d8ea1a657e940083319285b812a6ac45dec948585e726832e011f716ea2ae27d03a35f2b04bf4bbb43a89d5ba55e5df7051c9c08112b580e5fb5f139c0668d47fd2c3a7c0b7833b81c6bad6eb51cca5a6086c971de9e4f040e339093d6a50cd5e6c4f1a6ec5165d115c7a34fe1efb10e8ffda3bf7c80e39d182dd6051b9ba5f6bd48e7094d58873637e85c6313aee56c2d5341baca7424b2f231b426bd49e8aa890583e65e0714a50cfbc3388bfe18136170be2f5fa627e4f8a2ff9cc19e82bfec9b0dc0d11cc80b5a206342ff8332f2e4a4b8fcb010d4224f8484a1e54e01b2c9e8d04d5f0b41c04f73578b1b81786eb0d04e2a9746eca26ee6bf9af2edbd21eea3e1ae3ef335279a3027733c81b03b0689ac37b2fe2d5678fcdc3123bae64b2550db8581724b84f03aab64197e472f06ac5e6c9705abde24053038d0da34ab4bd2944b010000d852b76d48abd4b29b09392b618b605ff32538b12e0889a86e0f7eba0967a1cc71caf51dbfb4f824716d1d0e08ae3b182d7a0ddd07f6c080ee6d0f354a3389c9fb12923963143d1d26972d7fbfebabef1c50016e7a55ab9ddfbbff3fbbfa9dbef3245236ff24c55080c2bd5e3ef4eacffb2c3f068eea1604c1295316aac85e1ea5411e66b8a97cbfdce71b132cce7b90a5a53c1796624d672ad181cc64b1bef1bf3d179137fb96a260f2ff275b9ebcdb93e178651d4c8d63cdd990e529c6362ef7e4cfeb995d499743ec4f6431621b181c5a03820794780bbfc06f8955c7b1b50fd570571e86007da60f039929d8b216420b7bf6b2f58fe01c13da8dc5940dc5a40a21d4f911e9111455d424338f3229691fedd145c805d55db977d4628b9c984a6c0ad062f2ea270ffdb1fb6ea1c7373708acc393f783583996aac99fee3b0a456b17dc00cc4afe0e395de5f887f045916094503510f691355512d12bcc1101013d9ab1bd5c5870228bed03681259d3471142caba8098092f87ff563614f011f4de53c559f79a9575a2b9d2bbb1560ef7c6775ddf2c4f7285d70411c9e0ea0fb5dadb7df32fa350021decac4c8ce28011bca3e9df0054116e82840a7bf5e3c46433133e48e20e29e3afc08fd6dfd953c182f5ffecfe4fd7dc3b20d8c9fab373f90407d94aab9b97fed0331d53f33f83bc404122daa68c508d94df4e142588fe7b7fe7c22c3e1e755f8d0a51d1a60320c9c3a94a7525c3ea95158cf1df416be9f987bd291949dea58aca203e84c3cb02fd44636455363d13cdc61e92537d3a2fa16b97b1a8fb439e639767ce4a566d47d662d771a8e56bfefb4f2d85d0c92c59107082eae50ebebb2861a06feb4e0c50aeba00b17a954987ab4e3d67fcf8e5342d28ab6f96a0b5943633cb63b6d68112a2aa9521b1f05d246096df97c6f73a28fd81ca29ec7f5a18b86dad718793706e80f223c6cbc7211b261bd6e9b72c92150ae9646d289bebe69d7bf0da53e66c8fc32058af0b145243f6305869578749328d59b82360a942b0f00cdcc85e11e7f3aa60045a8dab0e5ca0abbea1c1cb795bf3d31ea68ced4ec1f454ffd659e292f2f086ad03a7aad1f6a6a314732703b7c837b33f08bfec1d540bc49b85b2b72a0899249666a5aecc877976a80e224f13bf867a3624a230dfc595351e31a4caa8b6771716dad9e05de9017e290ee4bbb7f02e27ef2e5f4dd1fa3ccbae69318b671e1c92e33c5eb3fa1728fe19525bbe85a072564c77c12807f449f7b94d3cdc9dee5b958c94195b51d698a07b7937ba714510f5b1cfa6bad00abe231e4be3e02252a2803c01748e8b45b5a521a224ad08a5e65f5a291d53d8dc771b5b0a45c3227f4e2f4ec50876be012cf48f1c8e90b5fe19772b5a7c1c2c8b7f2ad735711d99439b5799325352c85daae415cb400381e256f8ccebd6e04f8f5b2705cc56afcdb2feed7b6c20f64288b7b6d8c33552d6b513c7b943f366b06458ec9befc8ecb46de80caa4215674d1321585fe3fef69ad4ca63e967f9c52464702287b16ce9168d1afdcd28fb69d3b4d2857e50064332b2a80d19c198362816388de7e93c57502d3e46a719d8c76ee2f1cc4674e1f7c7e0f83e31af97888adf6248c6970e4c7de22fb20be8d782f275852549d777a77e9fcbfcd0957b7f98f7ba7833d5e54d19a8dcf638551df75f4b559be940d8760ccdf065b652a526c7071a87bf6709e62e405880b33eaf7efc6beb66817ec8c4036ea776b5937288daea9bd57eff1b5575dac633ef43c7eff5a78d40c2029e70df7fd95a2c1d4d48e5bafc262c9a3925e2f47b30a405dfa69a9e61f8a31f576f01b9a92cc4fbc89a0d877927ce0f9a676bb57915bbc3831cd5750a1587baec3164b4b0f1055799ef06afb8a57b19467ce34a442c21ae2eca3a55a4b00c0fb64b0c1000da5be4db94ef48c4dba94bd6eceebc59565ca37681479d493637235d9f3f8f452e148a1eecddd8112f3672ec0aa8c82f6a89ec7a5e44f8ec53a6af578873cbee24b8715173d543f12e077b1ad5211285b15354f50bc59ba2343edaf696c590ce5002d8fff1893c0da337ddb1cb480bf10c4ba18e747e98c73b99bab528a1043662375c362fc73c1aff688415e87f48a2efff637c86e67f84c3d386151aa8bcfee5e6e0d180f78be02041a8f78360308f9ef05ce44b8abaa0ad055ca50e5f6310ca7fe4c83a7b635d1015306f7dd466caf7de7a9807f320ebe8f52454c2d642843751aea5181142643895638b6813bbe55a299fadf7cbce93f42830f386f9173531c0e204657d3366ed1210fe333162f362a0abda287b19f4d443b92129c73017770403a009f1580a0ef802df4a3d974771385c1845aac08665d10b4ba857892c3e6addf83059292fef14c1dc0a38bca4aa3f26dad5531b5c60fa9c6870f03c025e0449dabef0792814d7835c37451e7bead13da5d60530bd9ee27256d65dc0f57c6f43cd1c8d3bb9a0c4351997b48d972dc50b4fbc263305eee53644bd430828acbc98257df5af8222d84aa228867a817896b5be9c0cf97290f28c651b9fa9a45c9097f0486f2ee737dad7436836425dafb4834f31e6d6cfb94127530ff2f513175e478a952e693535ebd9c8ec15d1b88e7cbcecc91be57fc760e9433aaed99d0170fff424e166369d5f9c09c62d7fd3e31495122bfe9b435f27aa736108cb4957422849894e4ad7811ba1097f501bfab522040c0caa62c3c82d56d0df90212af8013a41fabe246061755fa01ac22c672ec2d111cdeabf764d4bbb83eeec71e6d22f5fc978232f6f38d5281495f931862d96c3978dc01e7dc6db3a50d44be1db378d152905fd8383d98a94379b6514c8c9a0e409d23b91cdc1258de649874e86b30625abfad0b330e88a64c1adf22724e14cb9a9da64484ab3d543db6446bb2fd516446de1ede3bd4b857d36f3e84624ab4cc72c12a933fa43b7a5244760540dd0bab835880dec83f003513a33374d29ed0a0d465812a43bb4b88c2974258573795b98691e8965e0ed02c1d8913b709dbe88982d06518a53218aba80b11386850a82af3a3d444bf455d18a3be430d7c2e6b8fc8307b77b67ab7a0499df96cc5a345029a556277af04cb475450b471bbca6b6eb29c60d2ea60efdae0c8dc3d7bc9a504ba7ab79e55b998b759070dc0ed5cafffdb9c9bee60bcac4bba93b95ccfff7f7f48274c7a7026d9904a61a28ae595c58c385c25fe1f04d29b1300a9a3e31d6dc653f5eed8950734e67b0900ee783a544c113aedcd3ff9c554b87467594d17e467fbffff9a8371b46827c7f3aec648ec8b92527bdb0d0be5c9cc9a578fe4516491b01d003284d2be6c7c5ab6ce79370a6ee9df44df83f3e4f63ea12138602312947c951d009962b3afd37ead1a1a870a421c754413a5b4fff7e1fb0a44145d316d121186ea25168cf99692b1f332f0e0c3f4b7d3a3e190712421ae3cba895d00d9ef2d22bacbc3562758be3c9b1ee1a1ec30db1437f1e2257315133d128af76e50083926220d05faf43231fe85cbf0b793564f8338fc3c3be0bf906b9577069eb1e5dc3f241fc070a75385383941515b8e3a5465accb3f3187e23b8a58bb1c35ed689846ae5bd9127b1ec7588906a92ad9d60de966df49dc74a6e11148d15f7dfdd46bdb1e0f92e7b03df3db9072df0470f2432b5766ab8bb98c063d2266de6f02dd0b13602ff24faf463386a5266125c3c38e42ef98e97c172581a65b4261587c5c2f2f97b0712fa93dba637b8c9805c33cb5947302947ce1bda449affe728ddb63fc999ab3ed6012e4658a02f39bdc1acaeaeca706b102a768b831dbe4791f9071688eb6dbb49a9b22ad007b48cd7f9ee3add617e39c93e2d4f0799eb594a85997be8fd6a351d7a2736a005b6c3ec6cab454e0c9253d6f72c7fb64736bf94054f79bf2b778954d6ad1746e625c9851d6d4f565e075c47b416cd67ead3c053378d3209087e139e20fed0f293bb4a9c9f6a2007ae8cb0310f70faaa65b6fbb247b4c0aea5ed21b48c5a0f5e2e6251090eef797e05f6533eb5191629ffb4fe4a1b710c5f8f658c52b277a1b8c039d320a8b15962a8a0d8903e5e421d86e061b4410352013f851226d7e20e100f63d1c4c102327499215f22e9ca4b8df590634bd9131af3f98ffcdccaff3a7d330e4b7099dc376d19eee0e1f3e8ad02e70752020f391a5557b3e4b9bd63cdcea3d50bd7eff1d9370a7e5b714057bf2d0c1ce480d3b5ef8b6d104c2602aaa055f9f97e54b26898f5d0da6901cecd53e916953b7ea3783c5e7cd35c2554326dd93b812c6581af4676f3e00bd96b81f052b560c8cba056e285cde957aea2729648e438d789a8438c2362000a95da4730a514974acf7ea2133efff6f4b81b534189c98d7753765f3c38c971939f0ac4245dddb6c63d7f0062d5132f6243f9e61532fbee1230bae21b0ece31f7c9f15ea65de90756cf3fd94c03bd86ae502323cea5b82e1022a2c8b6657652f05323da8965982a67ea5a89432afd1f0d55ab004e37c5b6408cdf9c9d1a7613fb262cfb3482a6350f0420add485fd69a3b06e2756c2074377b4f462ae52f4936a44ab3ff7abadde936c8a1151a592f28de47d75f33d38fddf64a891977b82415ce12297fa0f1e62f4a4a670c34da2d57b7a6b5aed82e72048937f77dfbb643f77707563cbf69aeb8ea54e6b315699c2fb64875951608138745705c9af2e8cb7880b07f9fb9eefec702f8f63089c268488e22422a54eb85618501c8c9ab99d8fff2dfb366c69a874591749c68193650f653c60379e3790dd6a5d0fe1d622d7298bda6766ec662b05f9da871b0799c68fc4e9d413c952f2ccb3d993bb8b43e07f3cfa049a350daa77b251585d971ce9f4a264f8a1b4aea8848c3acde1f49eba0f6fafc98b382daca88f4229d90d63d2506dbfcd88e26c967b856dfead7723325892f2ad7409731709c74890e810c788650535a1223bef9c60a969273ebc5ed1cb4600ae59d043b47cd5a593d471157a1831460f1c3038eb35b809679a5e954108adf9d264fe06ce26de0dee7f4813cbb7c7379544ef7120a70d3f1f9671c3a828a679203435a131e5f2bafed648026980043737d2865553e42ec2238607771317efd8d0c3e4d31ceac1a2492a33a2a2b1da41c898c4724462bdb92c34a2568b0b333ee088aefc1d86adeb1cdf9871cb9ef5a8b79ab7216e60bb5a6f018d56f90e9788e29d1d2d326fae0ab86e39abb6cc8ac0d9d716e66aa78be64845272a5b39d8cff4a9eb466e694ad6a74d67ca5ce23f38008d1837ee23498b032382b862c64bf75270dbe089a3605f5269813ef2433f7d23a4470dda0e206b53e1eabd16006de58dad0cbd17e1eb8856a11458ded22a3a8fc4e3cdc8cab42410c4017c1eda0e8675cc0af06657ebb01876b9fb47037200ece3e31600404e692c453e6f3c860cc544cf19893ef45e17e6fd1fb22f6af269e39d7781ae60bdf0b7484a9ca5abd783eae4e888fa6eb9281241925f778476ad8297578cbcd378aa16185df6a43d0448b89227e3d770bf2326df8d2dfd11e1314323b196e7017d9c3a24a06bcd3d9fa38bf58f22ac0e3aaff77caf086e95f372804f490d757f8b2109776d559300bb9259b81f5f3feaf9b39b8cbba29ccaa8d49c6e2fc4437a29705536ed4cb141c1d58659441b1be4820413ab4e75e3ef4b200a38f9e253ac6d9ce44e07e7414329e19efabd702d1f2172f639812afe8fb1ccf443719377b8d90bbc184127b8349de2ca32b24056d188282b306f0664ca2da9bf69dd5138d838714462164e37ccf55a3f4c60448001d8c036eb7be2cfd0b6d871cc40370a9a4c646b7e33721220bf87565e0b19fd980cc20c387dfb96837e88b265db94fec1d851b84e679da11b706802009912b54961f0ad6f8bc8f6fa0f9b47f05d031482e005fcb11b2f8d6b8be5d5444ef14496722987e0a327aab1af1bd61846aafc21106b5e2e005bec9546fa1b2a3ef2302e2981d23b65ac0282adf0bb4354a127a1b37ce5d65d8a554b06a4eba9c4823aa4b2963481493361a12d04df4a493a0be26ea126231e8d68b4d362e3e25b2be91305ae8af2316b5e9dbf9edf4eb028041739456b929dbd40f95013d5b377ae795f1c344c87ddc5ecd3c65ddc577690d35781f48e8e81206d1851c38ff85e80f9ddb6b0734cafdf8ef6a48aff4e56abe6e3e76314ac706ed9261bf7228dbd414c4ad5d2bc00b1547435444d8629ab658955493b6ea5c74f01ce1d5e3a84b557b0ee8295aa0dd6b53f3ac6dfb298f4712c1729598320f4f11abab38c8a5e806d4289431b82fbed919ae5956f61e60a85cf7b98b7f1c3b2af767f9b6ebcc77a423b23ed2d6024bad9c26941930d1d20e296b93c5b5fe76f2dedeb13c83493fa60c4720365a72f93a792c700c2a33050c4e3e49817b33fdaaaac843d8892d36c44614725adfa1569f697e2f2758c077355e0e6d451f1c0538e88521e08140d73d0a2f3b21e25bd4e4c1eb97b4278d186220c1baa86f63d22f0fd5a16b800076665bfe2d5224931356ed3ff16c4ab5d971bc5fd3fe2246113750b2e1b676667495229fda22e19c8c879cff558c215eeb7c6fcec5beeb5357d8330667c95846c4c6121ee494cf362a902a3368165abdc70ead0c58b2e0d24062a272fc740b9023218fa9bf19b027990cde4bd1b2da7cb5e653a1af6d3e22c802034f115a67a343a5e73fe5e94cd30008de149730879c0c4f04732464c1a2ad3b5f0328790d8908c3c58efa25a8967c3734fe0cc9db83ea40144f8d7a07ce47211a40a4354b3769d8adcce73cb1df4cdfd17cc830ae8e00e30de04f3d342ed4bbc57006a04168e8d604a14f8e0ea1d2e3820775f818d409b554eac4df86b79743b20f83695ae8166d02437bb1283ea669b76a89095750e0a04eda7d23048267ddf582a2918d99a7cc024da655de8a428201952cbd959c2fe5c677f0c57d7a4332ed9b34ce77ec3ca16ff3ff39dd1bd8b783509178c01e4a30b09d53933b41c1d88f1aea623ddd63f428770378b6127d76fd3f6416102f10b9d10cd72697b87a7f6f89bf128a4ac3a40bd29e215a4445caa7b0a17746914103d258bca7dbce504174a809bd409e5f229fd79b84a7dd5388e2ffecb8755c6aec1162c1e79df3c9240d0f69cd91b7ba5ff9bbf318f75fd90ea24053b2afd748251511c290a0c0fa2ec610e14995bc7e1d4d834d166fa8426d937c513cd24d7a09e43e106afeb8134f15fc05adc6e626e8abf349dbcb993efd2efe8ad54b90e8996bca1a9e1318a896510732d190894191cf6a531a93450ee6ceed5ce6fedb83111697cf63b8e808d414f8ccbe434170df9a4f0f1165346c0b3af760f7a58ae00faed6459fa48121accc00011c7baaae3d05997503d86bd949884d3d1f0c0f488e905395d68f8dd0fa64f2170fbec85aa0787bb9748225a9b90d8be11d0219470c18d6fefe066a6b3bb6c5b4e551abd89a1278faa0a4cb7e34c0f86862db25750b18880c7e99e1e6fdab4a19135921597748a60be38be730f79f61925b498bc875e40cb11aa83d959077de9b206757fb016c98f00142deb22905443fa4f2fb5af559f0d2f51507da4407bcbb594a5ca6bc910de4fd0b50435f9fe440b9f20e2d524b9925f793317db61542355ba145d64333dae33cd038be8086fe134260545c74709cff01e8391dfa5839b6ba8754c04a4805c0fa6fdcfea42b62c9dea12a758213a4e389d455f1ec446f6224452694c2fe66c9c119456b299128b79490c90c97a12a3960459c1085a160dc04276722c1f8feb95d07428c1e63f0c76d41ecfe4890cb149175a42b22202520536bb72b14ae51e38bf8b4fc1512d7a681dea6f98b85a98e47e116ed7b4c23cefc4d572d6401ec935e5f452a3c842e13c28021001533393d189de59ab91c3f1b5364bba9bd9184824af1a28d17bc2d82b65bda624539dc5186c23812e2130eb3c56a7127dcfb59b7296bf1bab7a66afdc5b862342df8d4f1ee5755adb2610ff3c6874a7450ef957569dd98cf4ae28a53faaf22a000640723f0b487d9bc648440c7def6fb89edf8e06aeba19ec280ed3ec2014d6cb8a535c7c5b366260a8e7b23905dabe7b933f0645fe7f7c82f7896470d247477592170eaaf05e17858bf2a0640468df5035e8f92a29d179d8aa59fd9745668f02b27cef140e7c202f4d70b03cd39a9f64beadc3de1af7d46482140324e556a69ae5000facbc541b27fa96112f7f6ca72cbbae1f1a718bfe05b4c20c36178cd7061f633a13416a7e4a13f1bcfbce9af2b2963aea2aaf1b2c208217b16b50a8ae539e5fc63ddb2098b457a1033cc14cb0d1111b8e7a3886b55b2633e2245d0888a6911b6803efb9a9772e93556aefbc7889deda350e15c62ea7491f2cd5c9d8b023391d0631095336fea69f633d2c358bd1832b26ea7af64afd963f3f8b3b7d4845f6439c3711b3764f352a6bfa3798dc2061197790b2a589c3b93a517b4ae79651c75af2ec3b58d9a72e6c17bbf28dfe3786f9ba18594c1ba2c7360e2659392340a4d08bf0f097a99825548539663a2701049b22004be4de71f81b7383a4752b72759d42e5d9b6b02a6b1c9964d6b6bf79693aa2ceca003a389225bfc1263967238b6105f8602fa786ea5d53108cf028ccb7ab9521612c90a03d899e692e777ee1daae551de92d8b77d019eef34587349e57a1d2cdf3076551ec286d032eb7692d6657f76dd3d883c19667068ebd04c6b8742ac582688a8f8f6b80fb9948047ea6f34b8575de8bd666fecb94d36eb5413425eda250aa59ddea7a9015635fb64a2db3df7140724d41ea563c069cd46305d6fd8aad89f5fb5c3a6c21c514a2da4070b8fedb4271ffaccda20812efb1c89a60352772ed3fc7d0aaca0386f75a2e9452aefe47fb6721d291cae865309121fc27aaab3580dd69c25b1302a6351ba9804b10d84e535f85bff1947bb8423eeea172b4cae3cc7bba0aa83bee8e78f036a3cbc653b0a836b551241d6ebcdf71a99992502c45ab1339b4591e089353c7da9a3ec8e1bd9492deb402223be71b27c71dc7878f066500bddb619a827db13a925c04842dd6e07c8c898097255a4040ed091f8315131a3fb54ecc50b1ddd743a738aefd63f4ca64acaf4b656add83a3fb6a9ce84e3ccdc2007da8735443f98ff00f54af0d6a27d167c31b242a8930d631659c1486674ae3bd2c0ef0e5541641420ba2668c01dfe2c6cd7366ed95c1cde9cb1157c6aa248a514b06d537847ebffb56e15203636f52e3a63970acce8b903da6b81346d7c82eca9511b1de44ac7571a1c165a750e56a7427e9e49c3b35d76ee139da86c6af01bf639655ca8296baf3c4e308621b5b999884f3aaec762c0cb2e5665f0fd30f0a43c9560878c3aa585d90ac14bd404bc934a3531ee3eb9a0b0539aa9854e13f8603bb9af0ee7f16258ef2913fe3926e8c6cf39d554b51daf6a2d0a3e9e6a886257234c20caa97c05b7a6eac2c1d1d5d8173971a11eb708a9ec1b360bb18cb8904ede7fa31c0aa20988834351fbaae49ab599a3f4fdec457a80ba43347af6b212dd96222fe86ce3a0390cb8340cc06604e995e3ed49a95616a91726dc2057d1bbea79c1c04a6af43d804652fcffb88fb6565b470ab308204d3100e3a5b673f277955d8c80ed07a1512ef16a71c9357aaf62fb970a3a4ec5d1ffe3984758e38abb2db22d6a271041c39ddc64b9f7293ae89f4607140568facc17a540c4ad41fd444c98ce1ba4ddd0aa303f6e7c309428679d17b4f5d6594614c9ee26b622aa56c1a5501148d61bd8b0b5aab452e05c4f6907005e5444b5009db0d9a00eff7beff862710a8895b673cd1b24df48f44be3d55db47d157633130ea584ffb59cc2b6c429a8442e01f11efb10f941dfbda40746c4dd896c14f404d52c1a8e7e66d0285522bd77e1e7aa2a4302d9edf5ce4bf198a3d3c0422aacb7c0a2003673b830508e65b04f5fcb2632fc34181c1eadb3dc917ff0d79ca32af1872fc09a877f80f3c6b9fca74c85ca1f4bc169fad5368ae3cb76c3b30552dc9d9c0c4bc69e5bfd599dfb7c1217110c82fce07e1ffd7fd9e5b7fbcda6bc46d7aa3b9af6a5a910668fefaf7dad4bf4997cb6d3cafcc6f0491ed1521d82975516c90b401621783fbc9cbe9a25a73da65297146eb60b3f47335b6fc43a6b49beb6770f13d9a853e861c89ad8ccee29bce01a62d34377ba69c05e478cf547731a11d42236b149618b26c44b17553ed8f93fd7a428e0f26cbe610046f99c83b2d7cc256a1ace513e30ca3d896a29f598c41088c15d434e10fd6a205e53d863f997061d778707eb4b7dbd3bebf332f6748e22bb79e34c8c210895416bd5300a630ece78c070bb8f1ef3895e3b37a6b3309208a183788b97c70c5a4ebbca03d5c4780d9b71d56efca2172eb58134440b06855c0614a34d4289ad72db710a33a01805c7af906b2f4f814aa32b9d1ef47c40ca41f0eaddd5ce264f9f9360027e4e4ed62e14dcc97012241b805690ed1bb8447585cb89dc80d8845b1bb14433c9e6190a7c4cec862bccdf101b674c4bd99e722b88d0d5470aed81b9605c72534b081d2e7ec9f20de4d6afbdf276fe954582cecafad795e7a0a342d9680305cb460742ba12dbfd1301cac25df7b1a9cbeb7104d94bac84a94fd6564c1167dd7617bddf9109b7bacb5caee08cc0ec0cc35607f3c966087e89225fc41cb543948ff1e3dc4c67309cedbcef14c8ca337aa26d970fc80f8a57a7d20269dfd3bd9ad8884892d609df608a6d29ae38e5fe2897b3df4f73b73d72d0c9380c55552d43cd9110f5e1e64fc1f2917b6d9a512213b86648320b6c0ac75909b1a21452d22fef7c11d56b3cf06405eb0b40f6c7d8bd7e62ed29ff57868188d6cf945db9c8b06e65793bf58ade6aff478bafd4de4399287b21c081606ed867f9be6790d3cc6d97570bfb15878ab681327848366eb8d7c9ce3e3fcfcab83d5ebf2bf86731f6d73c6de15871349476d585a48dfde5f765a039e397d740739c45d9dcaf323174332c7003cf6711066909082e3a3c95d84c9a2276c0b86606b981a1d2a40796599ff4baaf97f8ef62490fb74bf2ab0a8007bed64bed720c965a5482f9777790eeda35d433580b8b06ee98e2b30ccf8d7637e377dbec8934deab47db0aeb224a4c12d9f3ac2c974866f52f7576011dda3cea7919044ac83214e8a52bc5d2d54d34b9a9b1f3dd3d6976ed2f3bab63f23cbb698f4785f8c64b2025047bce193a9c9a05d51eb13c040756af9d71abae41cc9757cf79347b644ea994db6cf0785ba12b5ee21e5c3c17def44e634e421a08d1c5c61338f6961be0685e2eabe3334a645671332796f5318ebb9bf3383695f39c36ef32e9707ea03959f52e8aafb38e6f6480e835b06343bfd9f1b8e6d65218192f845766c17050b179b070bae05ed95f158f6d192adbd8fea9d605982eb70bdd2815b55162defa9db0b550f252cc886c074c130402b51581bf4c49c8bf908f8165277e2681ad0896450c08c05c93090822cf3a53656a7f2ad833194eb609c8eb4f4c5c0012e72a795d19ad7f84692fda88d51ea13cf6a7dda661a711118f867dfb21233cfbabf387a902d0ba6ad9477b191202ff0561aac0849cb824725b4b80e2779730cf7356cf0a3c814ae5f07be1bb7135dddf1887d0229dd3adc0d0de6634f04dc29dd30d5beae4edb490b496cd071a17560a3ad0d0bff6abd66391430e5ba0ebc3c7c73984d373f06c03b6be615233bd808d32b303258141b67af09442e809cb3bf31782e3536f34c02b7eefb8d285d0f37bc259746b615fe08cad125a8e41894f8db4b341f95ecebf69eb792d84f6f3242f6c7bd5bc62439b6e4ef8904ed325418eabd4fe6e00bab07610052edd9921079c7413db056d161755b6f342698240a771f88d34385b9c136c0887578b3c94df128e41d5fd705bc48c13a9e35563c4ce03301f695a7bc83867b6152547d369b58b4e11a30f2de1c305e04ef1f32aeafb3fa56bd1981ecaa495978738e079291525a1fcff97f829fd825fa1b7bc43a723e8901f80660214ea0c1287159677970f7aaccf17e753931e4fbdd5421c44fc40abbe727e5986fd77fc895394786dbf722fe284848291f1049e43e8e56fc58fde1d2723051c547fbb341b342d5c14ee2bac60a176ce097c8a53c957d87ad71b31e0ca28c98c6f3f956850e448059e7f02601fd3d373fa2c99c8ca4e93186fb7604c487494cd59e5a41dec6b8594716a6d10bb273b7e3a6d866b2f12aabf8d1d401e75415b2c93eda99ca692848d0ec63e440fef8d81ea4da33928ecc0167e6802ab08df29a0437b647700024c75776782d30786770a881a45f4883323e7ee82310e374578afad325a64c9123354a5d3b6a79b2e8ca583c396e681be27a570d3840018c79eff3841236bbe407ff4a1b69dbd6143761cc3a7c9c4acb2db5167668532f883fd71c05b1b0ebee9913f13886af26f86444d84082aa4ae414aa12c7bf179366a2d33d5daa98055d673c23bb253d39020c7e1c80cbc5d72e065125b36447f9c5857191178dda67801ec96061b2c8eb8d338cb76bbc6be67c17a48333ed9c089f819e171a29192e277b2ced3b791ddeaa480081f206216019ad51b46701548e824dd2c2cd5e15ef90b1fa1b7aa8974a373ae32260d9d51504490f31112936611d0513a77328a8025c160779fff80087bc47df871e71d0409cf81b9090305dc92bc756bb9eaff9329285ac8434f7d67c5f4d66e22b11f8f21ac5a4fc43df7d77294a3d60c60954ba3d4854a747f84b59b382d1d475b12c23d807b0d27fd21a011730f65b6e15c02b2be1993aaa66ec13dd9350d8728e16c5bd7885ba4c77c75ebbb5d00553388275cdd1ba16cbcf062a2a2346e33a5e89661daea5b47ccec889a3ccb92e5cc320388976c1c9c8abdfcf5468ab9eaa4b4a037b24b867e463a966bf1a0a0e903d4cfdd22445bc2c6e025a542a541264a28f6c4bf907a3f116148bfeb1a8c56e1669865d985eb9a2319e04858c3c4a2c19a131d27f210a83dcb3f6490bbd7272286211f541df400236e95505e3acddc9865023f0b3febdd3a604ece1295846c340eede17f80de1e10bd3082ae8acbaac4d3eee78c32f28a459de970cc10f18d3416d8adb72bb6f223e2a41828d45f80e572303d82254803212ab62cfe6b970b367b245db863c82eba6aa1d26dea2388d58dda1e3f6e976d00066ed34c686b7568087ad2acfc062211afee57304dc252bbfa118608df80e07d5cac9a2bba14b73106c9ed1c946e4a174a15f704fb985b0503d75c0a6356be0199ceb45436334043eef49b3a888631f8981441741d5532408655f168630e6fc329c3e65643b7a91e64116eed3290247e56bf77c417e1436a42d284dd77922ec5081a8957dbf4fc93413cc2f8181d1df53b82efec83e772057652cff937c0ac76f6eacba649259a8399125305344fe2ac41352ac859b30a17faa95788617610d948c3ce291865e95a1069301494597286c88554e586443febcb339c5edaedbf6cd3818b1fa4904e90e7b7e3fb130d92f854dda25d55bf7b198ee51479a4e4d1b22be0e9f638d627e35e3011fb5d0b0ffc872c6cc61436ef0845f6c2a5d5d6d14b429b2b346273580e2225cb18604ddea114c69e56970351a6fa40cc6b7e44a7ba627c792953c3ea01f2c386aa3a10d7eb8ca27f4eedc480ad241f98c4a9e0f73ddf9632308dd1d4252e5b35ff5d80d8a29a534b675bb63f6757177b8bc0aacc70bf5c2b24ef5b149ef4b1604b6f031e5478864917ac596bcf765f2af80172aa12715238dbb868b09d1db4139843d8363caff4b2245487346c7264bc8e2841be2ff7bb04a4bee81cf49bcabeebab18657857418f6fdbbc273d4abb3a0ce330a25e2bf5ba0834bfaaac9322ddf390b9eacfd334d84c2966187f4caa0210ff2ecacd4234c5e1ac5cc0c9329a7c1d151bf665af25096789ae4cd8db1911bb19efda1d22b9a8d120530f9adf1eaa5c48606e166bff2f2dbf591edcd71bcfd649dd76cc44b008830af1e6277ed6f92e45bfa5c71eeac3b24401334a4a63097e6b8367ce18e911b949ae8027bded6d267ac6389641287a72b627a74c471b8355430c612145089ecd626bd5fd349b7b87d8de17c4cfcd24d015c83e35c28a46d09124cb35099c535a7420a21f37665eb2bc2da660e9b9c4b2bb398e06281865e39a82dccb142ad39ebb358b6802369493272baeb70ba751aff75f24827745f0c3d8fe7a9c738b1469502c3805c4db26570786e48789c2f2afbb3666cc234130641dc0ea8795e7c4f38b6c0cc520cd775bb9112dbdcbff5bb4a6c41c4104c1518123557ebe8721f0d8c70d9cca042f8e5df8a876385b859774bcf8b07187dff79d6e56426f029ab769f9894ece40c35e9b1fbf50792f897be73302f103a6dc9b8a1504ff9d1b7cf1e97f98ef013647b6a6e65faff3843b4a12ee709e2b1c5df3f84deba61db7dec04d85c52b056c31ec935baf50a05506ad9bed0296fb2cd1f20aa3b220cae2a2aafa9c1f7c1e748c31ca2be676c9b4fffd851d9044d1a1f331a3e5cfc921103b7f0283ef54f4ad682ca01167d13071fde636359e4df593f740621b0e4558ffccf2339f058d2b73dc16d8d9eacb14204c74bd47b02c3c25e51cc2e4d7919e92c562db706d40ea5f202c7b89379beca0af3aee4b626f15ed8417dd98692a6a998b4102cf835920b8da63cee7e5f4fa22f467941a8d6ea6e57e8410824d77ae04df58efad8cfaa0d1eaa47fe4a00b2f9f52754c89343190719a7d55d2088da6a2823cb82523182d20ffe7270f81bd711358bcf9d976a5a46ad573006b445481786095b463e2db50bfc9bb0d4e71eb35a52935f250cf9491314818ad7126276d03cb980b6ee3712ca0672dd2d52ba3b4b91c253338e7776cc0d506d87ce6dc2b3ef44b2ac70d7d1b7a87fd0c0b949ac876bdf3e4ebbfa40fbe932f75886a6bbdda7d40d59f9e2dd98f96b88df71b1c41c1e76318f0b2817c4d545d876eb10763026de5c1d1ff3f0b997d98c72f364acdcfce34489dd36974414310a77aae7cbd000a66013963e7720f54193081bdb3039c9fd0b12c681590612ee1136104c7eab9d1579e9fabbd0cd95c37536a5a530e1d2f6342a9eaaa6e8b638aae2d643c89fcc7e75c9a9a81a692791aa22fc2b11ccd64682ae6828abb7094922297427babb8443a052def6d2c92c71371f523dffedc5e91b692ffc904f8449e5e844fa4f1614bbf794f0b863f977c9f15f78cbcd8575f871a35ed3245cc89591598213edcd87d00e666fecabfe30f3b2b31a978820e6b1ce3fbdcf1f95d744a88ff9e3fab6bd4c6c9454c5e5b5d67eaae6fa11af4e8d14c694b49502941ef2bc0ca5579919928a2d622f63dabd8d3e1232e68ef67a9363ec9d5e34f62c306517d50e7b777bcd5b1216e29dc46b2b73604997b80e9a7df0e66d2d71a43933096e5ad591147129a4bbcb4344e230f2097887602609a1ec2e3037a79c7c82a53b294c0f085f06683f0c09bc819bbb09472717593638819620285c3e3f2242b57a0f863c38c2e9cbcf917130042745723949b4b2f18cce484fbff3b5f21ede45bb2870cff822f730499a8441382e340a5d536abb09f9bf694462b00885ed61e14f46c0370af577a3994cf5d25ca77a0937e3bcc8f137fd8b358ed5f7cc5cd939d5ebdd47516b207657b5579fda01fb2884d5854f5890d2c7a51906ab8c68be3e53ab22503ebd6105c7fd50004688741039c9d10caa7dc73de96a95ceac3b0823fbd8a47713225a3f70125a8622b9c24fdb792a96df1fa4d79f76748bf9a7a6e97466b8e105c7903d8da31068abef3ef7ee0d004816f700bb0a6f15b41e7e5ddb0800ab244b949c2081955853ebdeff2d7665c89aa1c47fbe8d503911bf38c622d3ff22476d1931330d2b4912fc14c8ad5ce74924b0290043bb6e174539c64e083d1d3b828537118e1ef5d5a0ea63616eed5e1528e32247d5c68dbff9ac746659d9a6aead63a2eb9d433b3f6f1ac7e980a9f4e3ee73edeec81f4604d77b4ea0aa6259f6eef99e108d2160a24bc406957cfcd5a3d46a6f56ac4508c772ca9aaddb09bdf09ac96344a14beedb6a243fefdb8d5255b1989b6e3d25e2632924edeb67dd4eab482d9d0ef60d836556c8366b1335e80c87ca2d6a8500c829e99122847b20dfb8fd0df7dc156b4fd44045011b59a1b2b7beb1df6c0d9712f4109c2d03ac2d46274d4e541d98117ddf732120b5177745e207e24567fa138dd10c12d20aabb7572caa63ad0a257809a658e7db20bd5575be0a787a50dbe584decd388344c0edcdc745fcf4b7ed46a927990bee10a76fdf9ca6dd17b9879d89cd4d84ad2ab1b71dd58470b28b5d84d3b387e1750505bfc5782b45fb9ce9fda32b91ac2dda868e0b042b4b901e81902977eb2ce3f08ed788c4745dcd2f27f46786412ad13464c7b9b6929e6dcb7e351d52684c0c997f3cf7485f7da6a0f921e1c14524fcb36d505b8bc45e6ccafbde74a8912524dcfda27ab55e54d08c0d003bcf72bfac118ab3734f205dfeada67760157c1083b4eb3d5773af81f3496709aee60dac500c3549a3c2ceb2b1f71ccb995eb3546aaf90ba5f6bb8e7cc7b3c92aa0b488578e67e2d2afe68f73dd65077aa1e62b06df57c5055e44f38aa3b8cf46482e29ca5cdca67aa252cbf3f698a5587eb6066974040dae06ddd1d7198e2e641b76a7c14034df4b9f42353b81a4125be7cc2583792db1b9af1eb7406af735aa6a0a4e573e669236e5df60255b40126e75bb5307ed215f1c01907472dea4b239e047fed8f49e69b25aa86e78001b915d977099d15484b3a5078ac25185cc02c0d8d6df56564a92c6c1be5e56d091e49f405bbe5d9466463d8eab062f2e1e929bfac81663a4bb7fbb83631cea3aaf9e193797b3835f0db899d460bdb9ecc4988adb858cb86f3fe325d0664ad1e56feece778adc46eaca32a8c09a7adc45cca1a4347b3ad648d8d239bf8990fb10e4a7d8396e87155cccb5a0640cc93e6a0c98bba8fff235e4b139b9441674525b35a70b3d4e7fdbb581e61772197e0c9a7e1eb71b5e98921daeb7a5ceb850b138743a70eff5a5e8729903d57de256f7266758ce8e23c7b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
