<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"100a4924f77d9ac62283c921aac164268a510d4f5c13c6fd38390311dc8481ec8d97fc37ffc0f27145150df6a469c592e1374ff4ebbbcf0e1a339bf3b98fcbcfcaf91dcb6eaaa3840cf556b0147b939c824c244eadbbd0dd92b76f7ac80413e6e626ad741e7ea23434341d595b344e5fec03256e83b8eaa97e6fa3ce8892229c0aef3eed39cccd2509d486986bb41370207b0a82c404b07ac36ca36385ec9c8e2c5e0a7ce0db0d8c752391bfe2d8feaf6c5ae24dd8ff584672a0ca7fb39aad077fad4fb2cbe15c0497ea7d95b2cb6dadf249cb31baa5feae8ae61850f7d2936a042f5038a527806babebadba78ca05f25b2dd0df516a6bdd46da1504f95c5e8bca59b10968b0e44e5b0e11c0c9bedee1dc68611470c49d8a66804ef31ec0168a2123d984e6d77753dbdb1a1c4583e8a196596993a5c4a90c2f4b15bb5ec82a59183f6fd756396ad7ac83c8fccd0210fbd2b9580537b0bf2a677a2431e41731a4c6d29ff8e3f966b4d836ded63dbc633f53374bcc0b1f3931d7329ecc2b4dbbc139617cc305538ea54ba347e1ba63d9b1ff0f30f82398cf5526023515b4c658727cb780229b7d6de031c35b4a893a8b030323930b30d3af46de02286a0a343ce388123f1c6f572c10bd63c3467e86b80eb19daa6e86d14e0051f3f9fb99c663d821669da1fc4da9bee3318605f5fb41b2748372dada20f2f59950bcd5a6933dcd0e97f304e6e7adbd5266b0d405f9a8d72e4d3a1e72e0fb4c22c873fbb0176a840809dd496ed43b85c145a1803d1aa64f7eff96229b731eced528554f3485c0e28b86777c74447263f5da6f9456d4a41f83f925cb3a30bbd36ef4baf5c4c1a83851b6d9d82e3a66e13693521365fbb928f0f8ce62e4930ec34a43b5da5fb1aff5cb48d76fd92d89d88ee1e14367db6ee5d867eed576e5c97b56c8c85193c2ea1b5d4cbf36f12846abfbfd7151e47a61f8b5ec7f1741e701f9e41f0992a80621819f1eb210d2609139807c3fb2e2d223305921a25a8f96625e09fecdf7f0ca2c535817266597eda1f96d6a79dc3be42ab083a043a0151db41bb92e6a832de8047af9e4a6046c3962da96a9099635a87cff9c8b1230092dd6bb46465bc59746f6a57f614cde78060e5aefd4cd02012130904a6bd00cdc416e99b4c9ce788ef728a8a6c9585bebf9685b9ed68319cd94382737508fb3c38c5aee1768d5b9bf6274f5950f946eccbd9313550936f3e2f4f9607e3f5721f7702e37a74b7cfc17048bddc8ecbcd2e1ff687048b25b139d5d8ef4f6298afb1770b8fc8629ecbe7c5993c1abc8a3dfe9a43ac4d4e6deab8d76f5146b17b4030f1dac6736caa4c107df49c5c76b10a33ba97d4b6787c93b17f6426a1584edfc6f4f60cff5d31b2a36fea22a4374ae3407dab210f348de57d09b63f83bcd942007514168479021523fae233c75894950bf82d3e0182c6383dff2b94dc574c0edb3506a67cfdae25ef25c06eff9259e0d3f7ddebe6ab369049f04430422db39b8f02f12b3d80ba64848ae5e4d70da87a0f3c6d24bfa95ec7931ff9c6d309d1199bf8c8f03f375e686c48537e044f9e0f87d3c0f86e3a2228d0a83028c0bc8ca23b94fed691501bb5d6a91f7a92dc0632698cc2f9e6ad182e9b39c2f76390f7ccc3bcad3fc724fbb0e62844faf84285ce80dac7c5e21e0cac43768d26b922f4d51d0a6e7cf597b99c4167bec298d08c338c3307e796118e7aa4b0b932628a3b0d6a8f72aeeeae0b55812ca2fbda1f145be567de1737662a2b2747fc42cbe8442e826d8d7038b164cec6ae66fab95b45545c7c52571dd4f58a4ad36b11c850abed58616360c3571c481ce0fce62b0ee61eb27853b447b253e25a4e739596cb0f546b87f4b8f171af244a9c1b8ca3c88e428d40410ee0e2600099d507576cda1a811fb1af0fa4c1d733577b98a945ca298f759a13c90b50f4d95b4ecd03510e512f1d77741925801b36794e244e0560f0208bb7d97a3a8b139dc658b3d4570b877a093125c8b7d1a529658bae4267cfb9c1f828a5327e45f216899f4a92571c2ee36f0a22903b4a14b1b08bebc32c36546e1ab9f635edfdc224969717cb311656384309ae7bf8e7bcd04c6999d4bbfeb544fe369eb7e68986b668a691113e80a071479e4255aa4e1baf7dd53e08ba21a4d7f4ba103490c8b46a882c3b9279e6c4a513d60ec8f5e0eb233cc469dd97350e77458b8e11bc6457cee476cee938b6dd44b56347c3d0cf57c8d5c6e5452380187c8006b26f318efd3ff9c0c3c1c96a9b0b777696e2185087853968f8610bf6a0a5729f7f745b7779fc7bac1a50fa0840341036297276f54482066df199621eb8961aecbe1d978d92eb863801cf1801622af4ec4bc701b02779cee87944538eb3223f9d73ec05f18c28122ed5825ad9030d29209ee7a593fa420346aa96476f59da6d294526c20295b45d0c6fe27e240deda580850450d01ace3093c6adb20cd854bb87793968563451954deb522a405dfc59ff8e529db125731045d6ce4250ba2101c841d6c5fc13f2d0cd0ecbaf85552e4bef2cc046bef83b85fef356ec4451ee0e1783a302fb3a71b5c23bd1ce8397663f3467ae590dd36193b35a5b0ef177294eaf75ad8c78d71f86d2080959e14182580cb5599c34398f9fca155d6e8564bcfd4b893177f1d1b8ff3be8e52a0cd5029c70a002853a7ea16e6571a5f37da355ca6bba7d41c1e123b3ce42d34989e657046f75226b76f24c4fcdc9563a07a6e02e5a7359ee183003a8fdd7cf0af7462e8c29aec431393d8a512a384bb1de24bedf44b7c6e2bf8298199b98bdfe6ee443b17fdf9e694ece991b1302bb581a48bc28490b2013185e269d61f41ef3565997eef938dee975bb0b7d3e4660cf11fb102ac0906fc2693233b212666edc7d24bcff7ccee001f52070907f5ab4cffa77d5fc9efdc2ec2ae71ba83da0e49228019572f0ee3cf9d162b2ceadb33706226dd57ac5df7e0c2b1fcbbbe360952e2723862d1fa5f8501cbfb08dde206e191dda5371b66856bf69c5190a04da25f32b7e733491c77e235519906fbae8f2c204c89b5fe4acfea98f62a518f10d9ba9aae674a57898c1f71023c47ab9f323665b73b7df398015b8b1c5cb38627ee6188c04afb52327f3715f5dd9199e61723606ca45be957c121f15d121875b0317e889e1af99e0117f8511599ff4444682c9adbb1cbec1d62b6ba7fc16d8b98a8e34a2d8f2e88e4c92f30a81c4f6d0627b23de6cb123b827c39f5b8bc0d378fc43b0f31a88c98e9f4fb2fa3bbb8c9ba72aa58397feaa94a27a13cec9785e51e88d0d0f6b76f978f376511259712b54dde06f8246e2ac1130e9c8ead24909fb62a787c196667a2f337bae8affa065f9917bef02f48cc9ce6ac690f4f2ba6d45351305d29950ca93ed72b4a8735d0cdf79582dd43846bb26c27e1d3fa4ced7c9882202695f27d365124d9949b4e29bb195c7f9a1061ba4d0d71d999e6f791f0698ca8a010ae169cbc81605bccc252c3e2430a421d511046616aa6da7ba0eda3776d1d0c67a137c589d437ab176da6cedfe5109ae9cc1fc30099bb99e22046e6aca3834bb1fc474de049f43d1e0a51d261ba61c497a503b1878408dc76d844f66ede41665829c4dc314c41b98fb493eb4172a5cb892535068bbcc1689f5f599f1957e32c2697f5449476c2329df5abb27323da8732ce594e568f2ac2e0db1672842f48eecf17c7973009549e6065aea6c0c86e4f2ce4ce214601671555ec202da778bc888d826243f690f7c2c12126a42eaca1d728ee4ecf1d373e5bff996f84f39baea35f77c6c321ffabd7bdba05db48783501e5d35343a680e290b086f4944bc6a01d879a11d4999234ad1d1af60afb72053379bd5867afc71c84e802a7f7f7380effa7d105db1673dcaa922f60df226616d5d16ff4bd09b66aabf210dd09179eb960319c43bede10126042ff2cc0ac1306f51b811c87cea5b982209dc949e21a69571eb72aded956009d593d50af204a9e3fe1844a5d5a67ce948f803f200f5410922fec4a6f7dd9dc3012a66b0cda82225435e2dbb19e1896641e4e4ed354008e25d1a32d2e9d1b6c0461b2111403b7e3252777b8bd3b8d66a3ca211d1b274809fe2f6cf28f38611bcad3e7eafe92c534b5d00312612d71abccc98c4612345a4cb75241d56dfd91c34d0b6b09baa34cdd20151360b2daece9744a5264547679ed574afbf70daee276a2386299f6a3dc7202cb1bde67e488aa59294df3df5988eeb63aa426e5efb17894e2808490422c3906e60f1bedc96dc576998071a6ed4c5092e86a9c3036aec2aee82b13fb89a953dcb29c896b389ddf2215e85e836a255fd3ce0f052538f3933eec1ecdb8f80bf94ded194ad221cf5d47561681710a3757f22c8ff0ebe751fc25083ad1f221e69d96ec45afdc122a57dfba3cddaad2367a95711276792f71e7356772f9d492a218a1e49fcd88256af951376d5e31afc4710e6c01e613a3b22d3f4689e950d32b82f4cc9d1da49b4b09776a7a0c7367791cc258a9de75cb6eafc5159cf5fbe33bb0ade398287251ddbc18d74087d0c0f1792949060683f7ffad29b0aebfad69b0e899e0cfdf915435ff5ed95476773786c8d66652aa7fd9c1e1e7edb184f05ed7cf9e399c66b346d06d3f74ea9ec3a9c1113b8be17ae361215dfcab6cab10cab9f952fd6b59e284956a36b58bfdeeac4a8311da28ac7331c77c99296e2a1bd9b9fdd5f5fd60508740e859492379ddc557812471ba74d6a59b58d66feb4a168e4261fc1b7f75858974e2bdc00d5b9dab6492fa94d5a92b16bf1135ff289530d97fc89a63e03f4adac7306c5d3429064ff10dc05c631e2a6fa0cc04b1a53d7c62625f5a773341b078eafc2d3b1860f8136bb4812fb58872f9f434744397790e4872fb323cb36169bbc70c22d8132f9732e9c2e98b7ad0fb1211eca99dc990c404987829f8d7336c183ad379d404b7747e572f93762e3b535b55005295433e7cb80e1b173896f3632c7edf3be6f58b333a0052b4c74e6b458783014bd7a3d60ed527ebd38378ac53ee82576523de26b364cd36be5d639726550e9e8c9d830d1f68d9269465e3a837ff15f1b65434e95f6e85a54c38ef9ee356b363174d33428c8d041cc5eb1e929f59a261c61aaa9e07f590649a98658878be11dbe1861e30887af1fc2a63bb1963b4147f7ff90f8dc054ccf19d02901943a952bb712d3c059042d630690b8c91d272de1294f2090c58c168a11b588c316757bc882419a04fd73c0a776a1af417183ba53f63cd7259a3d2566104449e9cc99266213bfec3df7a0b1463e4f069b7770e6ba40ed77287588ed6b97bd1e8852b64e78cef22375a88541a0291f2f4f512d5120108d37e75b0c70c6488433afe9eb2c44b14a0550c8840bfdabf2b04c7201bfb1e7eaf5559f7a9d3f7c48631cd75276de43208e5256944ce926f91c692a555b82a65736b1867255adfd39018786b7587c714da6f0c82df553a9e8948f2ae7d2cf5460c01aa85b207f6253a3a9b06814b51e89b4b4cf9175dbd1d6e4a50a1d9cf30f2e46ebc0d43a8e94f493772338bd6dc7ec4493cb6e25af70d17f3dbdaeeafe0385aa314143146a5a2a6b37a11855be132bd6eca0bf1fc17232ebbdc1dc7a2def673c9091e3aae8f343aa1682be11e205dc9ad6e752d5e799425b52c4983c2854c9eb7c38e81b0dd509f7c0bdc22f7f6ec59001e4756329426e2c9ddd6733108cb6dfa64d7b598db67d46580e6c169606c27db287cdea39447863cf9ffbdb2d0b4ffb7fcbc68cbf5c2eb4518725bedea9c6ec94b29b7753a0fde071e0067f400194353362053b75cd7c80d7593a3223190bef44357faaa4b7a9d0ea50320e5723a9723623564b2c737a36768f53f91597dfab5980d4093b19f978ae01c691e5a8d21dac7cc6131011c97606533a12fd98ecbd6dcc51aa55fbb81f9733216ed5e761ed0841acc8e71172c0dca4cef4c3ce1b3e65f3ed38b8de21ed73bced7f888f0d5d56d77c4582397367e491c33cc0dccfb9e6d1c258c62accb46a583807b0bd5f7f2a16388993f21a24fa2dde89cc9cc4e95db2b55969c3bd8c741c041497e7690f8547b1409c16847cf05dd2d67a8d10d06c7c6a68d6ba16a726e4911eeb44a4bb87a62fd23599821adc4827e245af01452cdc445f8247e2827b1a6deb29fcaf26d2713f325fb4c7550c22585c113b18d0ce1e69221237084ca21009435e033d69045afca223f380dea54bd9f3aa768257b9bc04fa44cb3502a8b5e79652ed9055775d92924d567c0aeebdc77d8a1f3bcda2ad88a019b42c3b99293b699fd4bd2d9ab33348aa594dbf09ca2ff804fb1d39e7fbf960d7137b5c81eb1f3328d112e73a1a2863e44b4ecc739dd94dc941f538e17c1d481144c5f3305ee3a3dd972cd077aec191712df5dcfa5848611f7f6be802846cb8de417b42ec237ee8d409fd9a41615c98c8b78b8b3e273f4a46b9b5bb025dad98cf7d8a1fe7abc80447037ba8c65336d5df078bca97ace6c2944c414805954e2bb38f5b9c20738c7ba2b85013c8edcf720a732d654a74169797c240c0911eb3192503033912a1cd5ba578f632187d1f14bc17363fa5ccdeebad0ab2ebcdf049b5817502d12313948d5033036002bc3223b2e6885ff7c78fd3cf957ad819b184a7beae3d43d6eb6665d3ca15ac4a79d458210a6e10a0b30ed6b956cffc59cbf75a6fd61ede855b7988c9b8f350a17dbaf39b48ddd1883f196e00353c7dcb941fd7ad142283c9d50f54ee9e94741155fd537307b4b48029acc4fd9d29590dd935a812d0a82ea8adfbaa90e46cf71be3af02e9f62daef78c356318435f3180ddb725c6761fec328bb16938c0541c08e634efb6ce3eb00298e4920387f5f3e2f3cee35e935071810cd38d52f715d65684c4293fd661e31916beeff21b5c666d0d86dcde4c072efd998839574eded542f4653c8d2abbe5576dddf18e85e4c0cda7e64817eef4cba707a59bb2612039ac50a5661d3a0ad9640c6bb4c06ba326e8da94b62c74e82661a623a24b4c927acedfdacece9379edf2ab28a4115a99cd867df6382be3505b172ef2059bab5eb21a898434e0d8b32b03fe4119ec0666233ed7040fb7e8703782bce4b56b9fdd4c894b684a9bcc7b357863d8b4060a2307d07644d7a031012088751825b5af07228c920ab6f9284671f8b4e736dae6efd9c5665c50ece9eb70e9e55a255acb4407194446581f91cca8c615edf6cad1257e432b6e4b687ea6547dbe2be21194125d97ebe04c858a870bc49582104aff041b8f8663bfb43d0bf15980ba9a48509d2b1ca61e347c4372e30b8df686464adcb75d0e42c405b2d18d07b288e1d5d2d7202db9a22bb605b73c47e7094b2eda52e1982b3539b2b4d1bddde8339d7a02f387eddab016f17f634f3246e61652ca734e694bdff0109a8259176d474927738f94bb3e3ab426411491302813636d5ca1e4d130c9a10770af743c57487a06e326c30a90abeec240813566987df7b99003c6913da7226ad0fde5969713201bcc6acdf59f75eb791ebb91530dc0bb7697e86208751b8ea2563f720f4f44277ede5e233ed5590d2acf55a977466603eec249223ba786766282c0627c9e5df99541b481ec2a933e4b4e2731522c9d80f2d5e8019661a5d736e299e1f8e2c8a4868efd88b3291792f77e4124f33fd4d0c6fcf20beba0168330fa3af9b8485755d124464808f986d6c8cd99e957f0dd2a4fa28a55131f3d3df9e0c8620e97192bf70a32f3f023cf8c8ff09c61d9d98417c0a2e894015140150c31722bb34024f51a84fe7de14a1367067e580386ec2e3bab5e19d30b4ce685443c8de4594930cb17aae25413ed98a54d845a263eed4ddd38895abf3fe811f6a93c55338ff0a164d67dc40c1e1b06b6a14928290e5dbfad65fe08a0aa896a9458fdddadece20d45be7f29b35600f93943f616e2df3f55263dcbb3dc7eac21297963ab53393abaf6edf463672f375bab0af65a525741cc203e4a05b3d8a293fd09cf30f6ef616335fda79ed5c859c85b13dea17a286d6adeeb5f1e6b9f69c006a8b75f63600a132e183f84adb52e46f8f0ac62a219f203926d0fea138a525e317c9fe6ea1c857c1c8a1a6f44f408534956ec4c370719678eec2411347faa16fdb5a7df4637c7141297f5a0550a64e6cee2a3851a68ced61ef91aca2d38d23013734a88c1828e4f0f3342b54ab2740e04db06eef5215dcd971127f21aaf4091c2741d2eef33c825c124fe1fb0a277b1634ebc63d150b6bee184ccd00ce99984800f396b50590e1bfac2ea53ccaf68890e7e0eb3bf6dce44c5372cf1999c8ded2ff3746f33aeacd412e8bffe9ab378f01352257daa3df859dd2e86504f3d37a3d8860784cb3e18d62e3a148cc769906c791e5bf6ecc232ea2fc5337ef51e2029d148ffb88bc7510cc37295d2087549f4bc5b0d01da7827790e0534003faf14280f1bef72f3c7f9e65ef2cb0ae5f0a63d09e509a00a83683a4094e3d5b57b93b4aef069edd5c634484688a84dc3632303cb227b08c428b1d782bf408a2f10186ad5b15876ca1b4c776c70b756ffd4e7cfd4ea3054763a4af27082554114b6d0154a31693e4949d9643de4ea61390b99813e2467e12dd8cdbf13967e4c56be663003ba8ede2fb503d312996aac84836a467613e19f8678e3e13e7bba120bcb1b93e01076a23fb00e7151b4fedae1e32b074ed61ffb0057c7507867d3c2e0613f784103f63cf46d747e377fe627c1f51374c10729448d6874983c833497b04b6b11da4cd4ba25ce26c628fb5e26be05518bdf2986599d260f5a6188ef6e9ea5db3d17d5d3a2a0bc57cb356326d5bf61c0d0a3d190a1ca2899f58d7f6a74e85f690d0ee9be5d63f16d416f263401cd1cb0162a4dd4b0c0fcaa4704e42a48e27ff2a6293a16e05e3c2a1c49b55a618278d586816519ac0d11f9c317c0865bcfec23d938f8b4be870c7bebf2e3f21c66c9f0cae8af475c5ec3bf61652f39116ff29260d992d5c67968fd80aba67664fd3363b4838822f7e7644e387e7dfd42dd6ff45a09b2a86f35d13af8f241c8e7de323caa016557082807a7f664323420d7bc6cedfc225e2538bbf9757049063bdbba7aa1c51af20bc9e3558b42232ae024c27f0aff1ef460221f7c814c3cd534fd1ee7665048d4603fecae527ff0a4235bd7d67bbb00ba275648b51acc875c5e0407a760a0ca6a12026e94a040d8189396fd614cd395f993f30e80307c4ba014b2d66aabd1cd3fb7c387e525251c6b77f4155a3352b96802c663d87c069bf3e407180ba829b31c2953519c69ce0512c75639b75ade119011aabfd82cf403fa038ba22c0511dd2507296c6149ad9889bafeedb04f7735f0ff471e4fb85bb2476df0f143da82ad4add587013b525d4b68101ffa581b318cfe369f77400933984602fdd132bacc1f04689f51fdf4f4474703438c96f22c93d1d6e062c217d085d73a312f75b519df9eca04db1a91ecac9c0ffde874290d33684f75def2e41dbb08b23cec65fc19c38a149f734bfa79bfa3d19d75b8909fd8adf3aeacb1e7ad3ca89a289167e22105c10d13cca4d76e198317ed256af9b0cc81cdefe8d22152d90e53795a217e5295461a627553ebec7371db83f7f298935d18ae00c958426b1d2601b7ead9b797465fe40b6d364098bd24ad28d6b4b78629e49f6c904157fcee34506dc956b4e1bd82978ff3d7ae63a5b54234498f7a61a699f6386c9a0df075d58c6ada37bc500f470d397262064b27c6ff201b20229a52c6fc8d731bf185b9fede22e0a37d5f105cdd8eca19394c228e8a5a5621fbf963050bc8b10e7d7d76d8d4a31857963d70bdd5ad8653d92140230f1747c8234e1fcd1a7a9cd9843a851a043302299ed5a215bde5829cbc33da049aedbda0262843c28de65a09cc2fcd0bc1e678a26919ee341fa12833cb5071f8a4b8a4525b949d6707872eb31a2a57427ce084be95cce317c9eaf65d4e871bc9b6730e2628064d0069f75bd54250c30f0372d8e2c29e5be21e20b00a5c8ef2c04291f13f28072a7dae9e17982a147d94d596128b79fa625aafe0135d5b8f00827fe29e55f9f10ef7fd1c2745948883dabc05385feede41393d14e1bbd9542265aad66729b08301b53e49029f447096bf52334406f8a6dfb62a32633791625f8e27beb9471f982ebe3ae46411db5a4cd641aabae5b84faeda41cacf80ae08485400113e836bd1e38b13827ca687353122f76cd0ba039884ffa7f7e3b5ca6b3b28a30ba675a6242909cded535e52ba272af77892c9a79e2ff47a894025357482437c88a13b8f6421df9bb98d46eb0248512eb57a3c9dd3aa3dc1b680eaeea0d21d68e3d7dab4459240a0eb56c0798e543d9ee04416f46264d128dafdd7cfb74271b5a32dcf9e86f1b18b63705c69b46c38549250b6695b6a36b15c75f79ac6e4c1fe96601b1f68183dbcf7d1ecbe85d2991efdb474f124bf678b844defa65ea7c210c38d4f8675b434764c3a610845a58186de4a5ee0775a2564e224768a10e4557b7d0a0a34ee307e1633d28a3061c719a2c69a8b39d0884277d350123326cbaf44e2e81fc641038f11746a50a3863a13eea047cccadb30119a73ebdde910f844180a1a7e3ad80efc5d679fd6850e63a14dfb50b948bb90af5de17fed5a9726a22b27c45609a4be555438bbda88e8d4ca54607e41e6c8f39ecb2dd5e2de277e32a221421bcd67785043ce15c595dcdeea8ddb89a6ccc3be5520162454e5952e62c7626a5537f6ae97b5b72b6c8a6e6e871b342a499563c40768fc48184159c5bcf449a1813daf88193a7e403783f13eb523dc8b63710a2fa96f61755c88f20af16522263354a10c9b82e8e9c4fff2895b7500d35087e615181be80edd17d910bf184f164c18f0448767d801d5e173df071958dd980b2e6d5f29397e718b0e072875ff4e1e87954e351f7eb594437034e3dfa5be54611519578a96ea357f9dca7f669c90b6173deff99df5954fe330252f527ea9cadac6a974da01b60b7dbab7fd6235fc01142e33ea40c9fbc2c28dcdd012f40f8d35e587015a2daa1a08f404cca9b4ad9e413d8919475532c728520b73777e3195ae9a760a458b1c644c61f9e07bc4d510131abc8c6879353f009c30b439601606cfb0f67e84a12fdcfc9738b5af6acb94d717fde7daf00a8e436f18203379a8d7d32b09a7992ac5174f6eb813d1f32b50081b1396d084825aa54b7d681d1fbee8ac69835ebd680cd505a805e0da803a1291357aad9f3c0df7e4675d43f818ebd68155133ba901b5018903d0591f4bccd967fcbcbc2e2b91dcfadb62a5bdee81d2e57e532c3a3d451978d4fa322c2a5e9f614cf3ad6e3aee417582a774367cc8983578401c08b57a8a65c6f161aedcb782ac24f0af750d09665525d059fff6a37b92cb0865050a1b46ca7bed44d46600ed13af15d54ce70b4f19ff595e2ef8de09be21353097f3948cef61fbd29d5377dcbaf1d473e091e7dd891e5c61f8b7bc8732ca14ad017d834338b178b97659365976472725696293801ea21d2596e6ba386a1213a82cf39cdaeefd8fe287722e664fd89424cf246979c7533822b93a7219b220f930149fc14383ef9889e228cb259d26db612c59cdd23576fbf41ff8772f763de533f033e0f9f71fb9601166ca3433fb782691800d83b6094342942e74db415383c95b2cf90da9f125d1369d34dd8a92220d56e30953504b3f447db55fe6fb08d6e64fe8ca43fe28376c176a669de46d4766fc59bacdfea23600e948f505f8656f8a0ebdab413588c8b9af5980568b9b1d447d58d1fbbe1a333ab6eecb251ccdc8cd37146e44467a95bf01875948b84b1e5607ae318e4e640a6f708399a5fe4cb30a25f53b6869337258b72a68381eaec6609e29ecc99d6611a4609824c02060fa782ab455aadd0872e7e9092668ad6602cffb3490146a3de06c3c5053eb21243bdde81fe9f3700760739be2542bc6c31f76c6fff3f327a0d3430fb3ce0c265b151c1aed0eb597a5d2d61899c840cf5439c38ef382af4bd62477310500ce77674b53a30d023cd91c8ec02f0dc876645533749ca9a7e9d73d9a08ff19ca3e3b3c378a4d0aa07a46d21aec6b83c4049f102debf98ca8900a6f2c58feb21604ce0d9593b34639a5096a56c7d1d4b801695f1836b45ea6ea3f05f159536efc6931a51cb52788edf335ea44676c41ec41114a77cd4f46ea559ef5f5104ccc8522f5697c8dadbfc42393b0cf549c26d51906dc873fc57d87e2a088c5235908e928ba18a85b506a0277aab1a5540f94117717432276e35e73ba05ab06d9819eb05d21500b48922ad89e6eccff2e5082dbdffcaf29ef4068760d776bce20a4603ba6a70d0f3e465e03b71c35e6df786c5ea6d86e4948cac3f0e89872acfe16503b83fe6387555d93eaa08294c5834327b83858fde0b298ab3582ae236ad8aa7c4449b012bfbc267868be1794ae684a7d9f7786d01a1c32e9949e52c45104c567b3a2895f0e25267157e3730c3d0e23a8676b01b4c9fdb5083a9ebe261ebcc037cfc5674b4328108a560f3102fd373e7045fb5c180436c14f5a8a2b6299a1b5e4fc3ecb31f32484d62f722ad4f6b3f324a258b1747765890673589c03744a07701d14c9e7fcd2cf12ef0b8bf72189a0d206f4d976d49439e21e2466d74eed36495d9d477994058847fe3ef82ddb9da9a342dca8fb4a142eab25d09ec8cf68781545bc86e8866fc3708796f2ef2b14ac40cafe44cad9aa12f0df8ef0e1d84ee49efda2d1e1ec8dc75c0971afca4593d59a6f4e83e9e6b7f5da5895dd847bf037eeec9cbfd90f220e658ec6efa59a21c6b6ae98b038bb1076337e6c682c1ceaf2c878c809c69c0dfaa92cb7e38817764160df24218e9f70441f5ba2e2dc87303d2c657866bcd7e6ee76b982c9f5ff640d8f531a358ab98a904b6af9b813c6688520f0baddc15924ecbaeea1962323ec37b9f6bd144688e59f059a5bdd7bd6e2ca0efe86807f4cc7a38aae538d60206c87ec80dd50842a37e86ae3ff4ef306c1b2bebce4bab78f787bb626d0971908de4834055bbaa963fe91d39b6cf392b49d822ed9ee67196aa34628804cdc5ec128dc8d3a117099525b5099e31ee6f292a4bd0f208511d0c774c129a304b78991b35972344a556cf1ae05a804009359a20315c52174503eacdc0856265b4b72766e01994ff521556232bd7fd82a6efbe2c4294f31cae5f6621a3d9427abf9a3bca57aac5343944cbcb9464ca491c55925c354962b0c7f3ad798091da6e58550c215154959948bbd10ab18e92cd8f7193f4ec4b6bc448fe1c3c2a2652255ad6290934486b0564bb207cac69e1fd0ec847f92bc90c3c6747b38a5b82069f8ae9c0ce31a9fdc34eda59043641887f97b4d57caf66505537f862edee38aa61a5bb16174b29a7b89e0dacc0240ee7674b0114f1f0f0d43adff67d3e7a3078f226a0a1e2a23565425652b5efd36088c0f896992c7157a64fa78d26b6f81235110b3a0898bbb52b60b214a14a1c449cdb1687c7f2f2c4bd8de34e8b4742381b52612fbd8a30210ad1115ad21b2e93ec6df85aec78dc3baf804e226fe6dd36416d18cf0d97191cb37d40c35f3f65aab39fd3e3c0fe1a64d8d115b2d60884d51c420d23773c56975ddebaa01284ccd7b5ccba233406276a93132ee0a0c22ba410ea25d1672e1549b2ee9d6efa871e7e6df11a5d742726ea1f7caf3f2da4a7216e9b16626c013080e079c02d3b7185b9497dfff202e03bbec30197daccda0257ebbfea14b906285df12f93b6d966645f5aeb48bb239f59cc0f241ca9b6a734025a72be94bb87185e914ef6deca85d4cb677770dc806603e325996db601a0f48ddb2218547ea71097dbd85c6dd67ae0dd98d175a59b807d6afc738881d50f9ffda5c9ab000bf79134190a96d2b328bb30c533d3fc372d13b59a19fca94f6a476e26f8bf16627748320243d3de37c7ace19e79cd3edd647f8c62f86c8f819728e5b8319e6e2c381a788ae814de98c84df6904b425f320b7081a5d10d6e5fb2f5c1e8498659cf582beb669caa3d360b2b82b9d64b05e8f9885b0fd943a8c199f7250f0c0aefee2721964b9a9ef407e322235f23177002e0cb97376b2f4b087abb40a6df5cb76d644fc885bd1cb03e04a8fda57aa98e44d234b9d167b465ece7a679fb1cc5e1bf6b57c7f27774e781abe540417b1e31666946f5e48c209e7cff69d7d47e1338723ad81e046736b537c67d7eeb8121f6514795a5ef8fd3805fa27fa3d7b3cae2ccde8218cee9538c0275f130fa2871d23bf1e8fa3112adb6bafc72fd4a9db2474569998eb2f45bf01e3f2422b5696f52884a024023c00d5593456c6604abb7a0d4e6d326e8c6bf8d5adcff77376a411de86f1303300061f0df20ac8f0a85c6a8234dcd435e5428173880538813bbcf189059d08e82a8b732c97282b25be800917b4f0502e8168aa80191b5b5c1a8c6a84d62a260f224f7ecd3787e866a92d37f86e3d2bac10359a19b0fc6634f95037a3791a7eaff7df8f022cd99fee5effb0f834741836cf456fed008909f6bbff6347095532c8db09aeceb952c8b880df7e3b3d9006b18ed68438296c8ac764634ca3a3e87256fb11e56f8b4d5bda6e2ac208ff3f4ed363bd06a513d97cdcfc335d87cfcea4064cd7138ecbb1da31a3a1ac4ec58f2a542a6ede198f4e18a1c1a84632587c2ada93c5d4e9588fe57a7c0d00378e70e8e34f3a2cdb1af24a5465d1c4d9ae7ed5116d3a44fe10a2576947911baf78da5f458a1fc481411cc88f1cac77a2df3023a4029838b1fc548fdab9e9d49c78092dad30edbf7f7a3a68e0b09b4369596eb38e91583fdbabdb906631e2210f8ab14ef9d3a0a32844ed93300885c10655688916b084fb503ee25c925727f3d6c6f5033c7358c8136c54558d44ea40c74bb86742284424be76e226f31fea0bc539c5cf78487e6cdcd1ab5fc061c4d07feec0b8ca7962a69246088fb8cff75e8cdf154ff989237496a22c769e8f8af8776529b821321d114f2da6177f81e2183a06d68841da2421fe7fd71f7fa306556f5a4c37c4fb51fab733cc3bd3b0f618cd7ba57f37780e7a09f3a66325e68135a8aa5ac7933c437dcb0a324eeb8b0f6f692e4c79d85ec4979dd386f77745a59b8f351ea18a12b95cfa6fe97343567e0d0677a4570f5a00607f10c2350aa6dda0103cb3b895d51d1f493fc3a9abe37972ad87e1534fb4de0ad5682f9d0b5dd62eba37ec0b04e626ac3508d1d7cb6c53b1fd6be1a5c019fc40be8d609b37bc3282f2b9fe5c800ee3e88e93b774c149fe6224c74c182c12e84999bccb719cf0be9eafd250c11e6eeb34a28016fd5fb01df0f57726701c8ec1b77bcaab61708c6af756b0a0859d73b8085b7cedc7b27e072034d393fa43957aa9f2817a4899029a69de611084f3b434f09e22ce3aaa0453ec1059d966ef7f8c0d2d22ac05291500f2ecf179c488e6f0797a94d413e0f52deada04338446b0b6539e53a29b63dc200ae4ad45e969c8c8f22e2896c987bc85d0bd1adf6163cb5bc4486b60b925bb4940915ebe4d44b73a7ca2104efc913f6846259778aac4323f44ac8ddab2a98667ab7b6d0e22ac596e25b489c62369477ffded944c697b0e339454d73565bb39d1013810507985f7bdd7d1485e1e2078491231027d0dc7d20c2c9f027de823d030a51ba9af33f4fb45695cab08857848eb09e29f7b5f6b6e39726c9464938c9f72e8023d5a5497bc6ecff32be110ac75abbd52d9547fc13ae7f95bfecfe0c9441b563fedd4c4a855216590c7b53f51fe89c334ad657bf2d3243229e69a7c769d634a7a616b5d29623d1026ac0fac2e810e8ae54f68f1808a44b28efe96450e7ff6b7f78d46166e1602e6d28acfc72824feee280bdde212c77cbeca45ae7803f0d05f034d4cc814e5d57f05429643b65a2ed235241020847bbe156f91a2d7eea16ae5c7f4b5d858764f737b1f5c35f63967a61d6ce2fa90a6b8d8459c84d52ae8019cd89a86ce40e7a886674d47d64b999809e7a3f2b535637df2923f4f815fd69fca37121723622754c953f74dab0730567afab86d8896076572eac7ed95548f25adcbdfc241dad98264a2638cfbd1755576df41a69b15496af571070b26a48db969ae182a0da1e416902974a91479f9db1ba7563fc4537224baa5b77619313a54a249a26d5c8e6d88833d10fd879bb6d2ba6d44a26094db29605781d7e9152f11af0f3081e6aea8f60a329f2e6c2d9f9403841de755bab60cb54fb6e4f93cdfd33dd06e03a5133e8f67dc7e1a284d1052e2e87e4ebf92fe364c25959afbfdbd603acf2f8ca88ef34c445d6f99f58488c0506e5fac0d06b3b8e939cbf8d5959a9ae6b048fa12f8fe3f23132ee380df94cbfea7f207a3350eead1562b1a26403310252b0581dc671d2e0d0d949551f08789f842d7de0f1421d201976aa1bfe89d299e784bdb08178703bfaa8518699fc1dfb24ca7988ddb593e3ea46e3d4b927602d0675992282e77b99fc35106915cb77c8246f2e47cf58bcfaa9d4f4a5e989ed5553840f2a9b1dc4453194eded39a54cdda18b01b27e49e12b9a0664b84ce2b069fd8c564bb6d6850e334e72ea317f151154a502a9c960353375db14ee7ad94c8ea8c56753de6e84d20bdb33b21654c5a92d1a34d4b1c2ede30899a407838a46cb49d7160cea1727b42267d1439ded55f0e3ab45040e7787e41238a3b9518bbc3249a1bd2b9f72affd229f47611aa5265d8925479dfb2b4939b7836e2d4ff35d2b4d9b009bbc6d9eb1f87328fb6ff4c6203e45d8a8f93ffaf69300d7445fc887d8f82cce6d35a0a6e8836e1a5012b804f62ba3f4bc24ca63506cc7d820ebbf0b4e1bc5f7e3ce0393131c697f6b7ee504d1ddcca3e89759722fe2b1d4b267b32d560ad732e59785c2b3dfca6bccae90d1d7140350e4211d396aa02ace2675741fb6e0e487127e25f111afbf61fa1af1b8ffc8b6f829c5c7345d8c500e799eafd0ef2f6ab0f1277b57a1e36a804ed1380407cd1d92ddc417dda14edfefe15355f84535aefcecfdf1610cf001413e82aeb574b156a956c368a7ddacd9ea23fbaa950eefc0ee5773ec8781fb46442e1ad9caf521b54a8d35589ac898684bd4974ee8665c832213649568f2bc804e4e0bcf033d876578c470e75eec1890da65e37c12e05e64460725079f4cb52d9450dc2ee10a2440acb3bdb407e31ad66469f6560a735cd4da645177b20a0cacdcdece68db38b9e71b0e1d18521fedfb3aa8294ff60aa16c4a817b991e54adc8439a726bbddac65718d1b96e454ae0c64dcf18d8cf23153e390637607313653a80e426fc8d569e8e34d9147e5738c7604b0638d0805ff52ff2904921bfb8635d548b219362e83b955080a16826de447920c361cca70a8cbb507f798c14fce3f3f60d306039f355d58b5c44cbb5582b055de038d15b357f338294ff081ced74de508da55a5526407ba021477740a4289aabee180d47493ed6d9a092665f17d2069d581f0506ba685f8371d8e815171abe3bf31495508d3852364b4f5deade1b66a75f41976050c077e8f8c73c9dc9cf5d09ac54855f3e3dfb7f09e88cb5f55524ead520d5f7f695c29d79617fe5c2ccdfc0eeef0f273e645dc47fca2bcaa502232a3a51b7f43f9fe16908c5a79e45bba46eecef9281255c97d9488b86beabc3c99957132cc3dc2fb2c47ce4fffed474f05c121148fb219a631389fb7183cd42caee147c6ddb8ef10b2cb5d5d7e7cf869d2c6fae716dff9a5d920223e636042d16d0a7b12e00af513fd0ef79e3485b7671eae56cd1c8391444a9f8e1067186b66e052180d624568c2a57a0596de4f9deeedae9f90f35fc5fd596ff8e7f0381b324aff9122cc8b5064217ebad99becd1007710847f193cf7807e29325dbe157617554c5c76f358cc479e5aa01d45811f4495","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
