<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2efa78939d2b37488819d6c0da223058b29f6dd38049d48857b705f054f0a2c25e2e1c234e24e06d0d9598c24194a4f40d3836349af94e1a4d7ca5105ffdaf19da8634699d5602a153c028d82cc560aeb99b446aeda926d8ad5d45c7082f76f392a830ba2407b427cddbd14dd5d755ce9d97ea8f6dbc349907492ba82357aff3298144244f03ac34a334a5a3f884df86ee91f2e93790c06c388d4587d00da3bfd5dd5035b8e104792c0d562f8156c1959a9359a8087e9a93cb51d265007a16b7b78a8d88edd47729391aca52eb7024e69e1eddaa326dab04aac88f6bfa045ca5a3055c325ed8a363cc16f15dd8da90cd5c90b842af6d6a27d082557bbf64557cc4db70ce3b43ddf8a2fd3b468f1af0707db1caf3ce33d416f1bfce7b8764be132717d2b74cc63a5235300db4b789f3ca7c6865234bd76229657be2ac7c5e398c2ba26cc5e3ce2e8b52b80b4f04899289a8f8b6af7cf98109ecaa8ac0a157c1640862dc61fc6456b971dcceb487efb039aaa7379023830aa23ed6a0590ec92f5c00fb5ab06e1d1c07942a2f8a26cde52ad11a9459422e2ba2ca765c2a748571dc70a6c960977eeac46360d1392925443d8b9813c12735de17fd19cfd9984d660590f8d34e654f790fb22c25dc3aa917e96d9984667d264945bf139bb39f3f8eed7edd4e93ae7d5d420d7fca5a528750caeaab0de86179b46c68bf37372a5903edcd078d6d28df6f5de29c31d8d063cab0dca90621216ac8fd7a1f6c12c59d7531a6637d034e75aed940a1c757a56aa467eac4f56f734862ff91ddae2c5383d806f780169496534fe77e09663164fed2a78b4fb2d27b55111d4310fb268856d84eb5e90a5148488bffd6db64a7a3116755926918a2ee769a869d957e53f93a3199d76c89461f370693e250900bfe3097e682562864bc32ab064d94d5d543f601983ff11804474479c1a26850b416cdccc6b8ddd5d6827d90c3d7b808772352e09ffb95e2033545ffa1b2a0ad950a2799cf14305701d523022ee87992dfea3154b66558f27fa845fdbdcb25e5fb01250bbc7dc6d918d52fd9dedea7fa73c8bc79700d3e67e5655a416fba29c044e8f615f9124da5e21122d480f7b3e4ac64e6a105ec7e1faf09fa291ae6e615b23202177c520c3732e5d3e6a2c78605cf26130d389214a148c182e363c09d62452a41c7c682b2eff9e7c66a974c21ca99cf36fc5aaa615ae7df895a2c940ef7da81e28f1ed426f5ceec68328860bb917306edbd5f74b18462836c32b3742eda23c0d401d5c9bac8b929ecde93598cb8b71beddb50b7bd9218b9d288d9d2ad395d489b2d5378ae7d26b6862dbe36f96e3a2d817b4b70ee7c7dae7654c7d00eabba7484bb35ab606a7a9714887a3c25c37b7c2168f8ea6cc6d9278be40a1ef85a1b291d48b789f72f008ccab2f2b234c8fc7006e3b3037e1444f173af893bfa34893b9de1c0f1932810945ba430513363769e7e1c76ffd8bfaa4227c827bcd38fa300592fc1dcf05b5f544ed2de1df202baa3359291ef5bf210c42df10db9b3331cab04b071f8605bd10757e1349663d1f370f857f5fd305023d8629f5b47db1991b591e30a7b700215bcc017b25781d10164503b4be2d94362d4cc54329c4ea09c15ca0eba1ec08cc8ba5fc668c1b10fdc9a071e905f6fb62b0b437359b82447ac8648e9c22ca00d3081ca8527635da4859affd0b15bd919ed2c56eae017aaf5ee2d97502c2248bc7c65dde2dc5129fecd7a0ea6a8358c06caa51b71e522035a78cea4ae0a4cec19530fc98ab7a513aa1916bb9d921133637659e4974012012f7236703fe92de630971f10ad10ff8db82e3562f640c3ced4120fb4ca6665ad67242612c7306399a118bed6454fb443a5585e6bbbb94ff59676613437df467d4a534fb77113ed39d9b5c00705ae03aae061feab806e15d00716e9867ce7d40049d10a9136701d69bdb1637e43388b6e411e8d5593f340d890545916d43c0edff09f17d1f147f9ef8932848404a2558da2deed1f674450f35af80fa7ae8ed1a41a86ea624acfd688e4292ee69e2069fd2208ab9593dcc286de99e4037ed85788f44b406a02104024c724c9ad30fa8f52c4145adb787e0811faa9ee64eca17eecb54959cda0c406cfb103a0d5bbdbf47a523b1a6c320631c449706cd05663899d8ef220fce269f7b2518ff84a4e1f28084d082a14ac9608cbb935a09e2b04712f1d5adf8ef95e3de48b2c8f049db9583db1f8608816190a4b907884332f5b3fe643f93db8c54cff43f6b503b06db98f0ad1cc009dc76048c9e7c6ab3f64490a44129c8bfb70d96c6a605f3799ab3d092d46d8fc170b210ec52b8e0c72dd47b5af29cbc244c9dd634bf122060bbf2600ef9c89b0de3dd18491331534ae5220955c50cc0acc4645b25feeee995f234afe6ddb8c96c93cfcd7fc909b4fbffb0e68663cc68ec95e60638880afe47939ce8f06e90c276d67a2917ef46028f88e3494f0a34dc1794903cbd23d0ba0b7d6f021fd5a40fc9d040ecc1f3be18b7da43814f508cec87de029e6dde05fb11f34ed54c9ff649aea571ace6ae851c00ebce819efabb2ad011ea7fb9cf35595a16aa4a704f70cf6a0f2d50c57c9a5cc2d304d92185243df05348114feeda1ef5481f121e544658e361c9a4b5d6fc707bed81da856495d6c8cb7af851fee496f5359bb789513d92a6de0e7f6c55300bc280849e3f1be0e8b62cba1bcb57c9e9c54163f2f8de47a8144dfba63e890bcd88a103b84aec0adda5b5a4bbe93ecfbec6bb5ecfd678e9b29829d7acf31f68b7be03b9bb059fc2f00c56f5d655c44f31097be22a6eaee31b23a0a67ce3bf021f5f1f873cbf4cf0d1c83e36887758398d0fc06fb0ed30a0f26ca2f284f6db891b03e383ad49ade05eaae65b3edc17bae7dcbf7892d45ae768cd39ce5064b9258719df1d1d47b9df0189972e15ee9378e09bcc86f1dc40d6ef1adc21e2244c5fed84560fc533cea07cd17548af8ca8ee3b6ed0e14fe0835444790532de01c351164cb29466897c5d2dbe89cfe81fafab68771a2a10317d972e983120b22df951e0e9526624c504a2ab5cab29beddc6d8f900077fb8589730bfb6e530c364e5a7d01170c628ac8120dd1294c6d4486fcb4f9f173f3b97865bcdfd6ef5ac477ac6c56717383a254d498902a0e57d9441d961d012aa82659ca91c2f06a69bc0a5ed67e3653625d3936c6c402776e54dcdaa0fe60940eda7f0c9da56152191f8cf2d6eaeb7526c28532f407c5ecaf1a5e9d92ae05baf769309497b03bb6c3397f3121245a73270babc111c779cd02eb23b6a2463f294f623d5ba0b9f1a2e54ad0807c5452e45cc0c8690673817799e6f479aafc98f4f235d22976b9df1107ea85429afb984d11cbf13857796fdcf8b12869f6e81c419e5ac3f05014b59589ca0497718519885b65519174cf1b40f01afdbaa45bdd1b4e8522195b7926bac5fe879c229c31a204be3a560f3ca11a73d5bd4c5644d884b289d3d986288866fbb61ce35ee1b2bbf332702324f4bc1b3bf7e3db8f776bfe3c81f6f1fa8b38ca657213727d81332a1a4567893b28d507b2d3fdb890327b22ee3e1766b0f78cb7ad0576e29cf415a0ce3aa753132c58b516100697bc00b657827fb0bf6b97a3176b1b05f65d6e0978c074b75554a68dcef998ea67802468acba1ad11276af124d14b93114de03e029148f12b446bb4d089e35726abe2e60526196bab8155e7385db4d5b0852b25842f0648dfd125159a8856b4e6b8feef9acc4b781aaefe7b99cb8803bf121e6f8828cefaf9cf0d92490f5e5b3b1caac103ba89f937d8fd11cd43bb7d3fb543086e261e42ff3c4892604427b0d51f2b73fd626d3632b3c62d418a619eb863477be73fed8bf7d0a2c49caa90548fa2197ec3f4e06ec8af71d1060ddfa4ae163ad56345cf066f9528c2d191db5eaa60c30f265fd9ce75839308805f60a52834880940e4d0aec4f221abddd7d422fadf3bc58f6ea6ab427f2f8cbecfcc3fafc040ec53c411a7f3a4a9963aed5bbbb8e3686e68f577b80ee1395380537843aea4b0c7e50927de5f9a33865cbd1e27aca15d161181f860dee7d854d6b3898a971a30aae53d4dd93c24d59f4bd00edf5b3cce8eab252cfd09222932075ac6109ecb0ff519b64ae7db2a91f5b2ea153208e4b52204e641dc80902cabe584b9c7ff495196cf0cbef52935940c2069556e09a3baf12fddee3ffbce5b10e89aceb04f2ad2caa3457012eb1dfddfba03fe5e35d053628d5319f6c5fdb14d37b287579885d514eba3287a73c428fc4336808218aa7c172706e5261c96be98aad7db963a8736ce3be0b202dd095c7c3c3552302458112db42eff496434f3cbba802aa616bc930859bb1862783e9dedaf7affa2ab68e8f2274e98b174276ad80094b29c1a0c97996f510fdbd07ea04c707a51297d8ed705b22725f9fd5df1a30c69a776107f15cb227e795cee545d6b7a842be1c62c872cc43fa71b044e7306a6c1d665fc49d6c04cb37d0abb759d48053ad629042c9db3591c5c3e10c7819eb17dffd7ffd2f2ae3b1670ae4553e42bd69f8b423c06073b64d28b7c6051eb0fd9f2ada7f11546841608ac73589001f6bfa1c6d950e487c0045bc3bf6adbfae0d1ea316b9d77f654675c7b95a7dccdd8e6b15eb5275adfd1cf74bd7b2a4d738d32d76b59593a4a5b119ac6c37b9d6f4acc4d9ddcc9a24ef3840d701ad1ed34e521510effb341c66d1d7e584c94ac3821c1835c9a696a9725a3a79927c6ebfd2e38171ab8ae467323173029588634e0ff31d9e2cad454b8209a1220568891ca11e1f6e0a637c8f966cbcaa40e1a7bc4ce4165a40bba9ee62b88412df2e13a7c25767de68a87ec06b8820578abd8c622e4cdc23d5a6fb65982993403b31e6807a462a723b259f636a981c9cfef278f2533c21119cadd88e1f5f0664b611bebc9d0fc16cd0f82c7c83c9ad7f3abb2c6fe8c799f0cdd6070f4cf29e08ee92ec3fa6d713eacef34f4b6f559e55040333bed9f7166d5b05b89aa09c5a5de65e84b998a9242b228bca510aaf12feb58beb1d55a8229dd07c517470ec92a7f306b05fed9a7f31023b70bc9cefdf5cd91eef932b7377baeba175628e70673374bc685edcda7fec89e34dc668b7a3519ee2a4631edaa9544c2e603c64667391150a50cb19434c55c650ade94dfebf55bcfc1e981c972f35ff85c2976e3cc40c40b96d5da7f4ae9e475823bcf78791b97b6f742683894ed14c7ba7dd4c3ae184e53142f5bbfb44bd2f10e6905821e745a68748bc7583bd39f324c0a070418d33d64c7d6277302179c739a741f2c38a6749788482a33442a563c0cce2219d7016c9d37f18a1b3915661087b87d06babce32fd4816a825313caa26403ec171a84307344494ae40ac7ec50b4c22d343f759fde24b2b193d44c20cebae9cb2be19333906a6b626f6b06dbe5f136faef20abd749d0ae4c076e13d8de0eeed99e232e2cfeaa7be339d6d98998130fa4c360c90e369c426a55177af15d23eee9ac440b7d31abb7704e0eff040a5092527a4bf764331acbd668ca6cd97ae83a30adeee56fddf0e7bf30dc41f4496b91e68a6091706277bd1ac06d75c9f0978ced3d6d93a8367f01b140ec738cf6d603bc8c158bdd296c3aee6ddd87588e498f3271bdf8d77111cd1c4f0c292225dd6fa5c2f8107fa93ad0ea9a17fc5f7d38d992084985b65b80832fa1ecc703610b8c6d8b89b1f113b1b0c6e0add7d623cf4028947640cfcdeffe91a7b48afbe47ea79eaaab704b8a0ca80d682300635cc8a7c23c25fc986290ebf7363e1ad2ffcad2530a26fbde7038c2c53b4f2c4b68d261e973ddb3e83d3eb21773c83e4e57997ea7fb349e48a4a855003e0234d0b3b644bdfdfc90996bc510c47769e6f565c4da48c9f6eaf848662738458c05d1f78e63cb2e28f33c1be6256e14b02db7f375d73007aeb985c2935c2e85282bac96dd1bd1ed13686fec77107efceec57f3e416c108295ee06b4bb81457fc9d7b510ba7174c5efa461645b23c0047594079925491629c36315af7d6df5c4d3c95de4e307ea1e86016fe09cef3cba57fc9a9fa3e1be962c9d338c61db0efd9b98a229b3ee49cd68741727138900a95b7db39185dea4f484d73682c801025bd627fd837de604af534ac3dbd62dc6152325709969fad989d876e4b183953a7bef63f15343802095ca8d2c1ff60e78b72e619041dec875eb6b895558c281aa4a0163638495afa24b666ab144362d4f8f54c8d99156f5c84fd387735653a942a6a7b9c0656a8fece7ada74a571d3fe155c5df0919aca274254cc6540adc12e54bcf7910b1114e7c623bd98acd04619a35fb2576283cd3d3390268533516d740ff55a6c9b04b32396e8c653cb5c91c61fbe56aef58c84ecc91ac14070466968f112e306908636e107948885c87fcdab60f8d0aa46fcd8d34f39f1c1d9c17886d6b360584ed385e3b571348fab05c87f606f9f94ba5fcfb101795f56905809531736c9d9bc2af1fd445eb87de1e8417c52be515ae7080ce4c66d8bf99a5c7f5eff8e7d38b560b8cfb197870745fd0add3f290a3e72426efd641076bdfbe8f233bbf938f36d6c71b7955df8340b8e131ea2883a735fef037b074c791c6ad3f043c75229d9f35306937bd9c486cb407dc7bac67e07dad708d431f0e5e83930d789c4bb58375f390056a60d1875fdaf93cd6516d60c3830a228372be3250c063c2b8dc6d1500993c4559e3f07c471d0efd53452923efdd02e9c1d50080933ddc8a44115ae853f182628dec8d4e7518335f501d78e7fdbfb590b4ef772ffe48d7119c6a23a276b657e591d6deb6e6a2d73441b111d7e9e902261cb7e44e35dc7cf925bc0c32b47a39b46545ea59f57dd7ae1275d226287e23be1a6f8613421ae7dd6eee79ba56d5ec6bb4dc81fe003cd688d3f0b57639c172a29f1e39ee6f782213cce88e9fe91e2e390ddfeb3bbd87372e9249334776faeac85928156162dca0cd009311dc69c50cb9b0e373bf24e8c47c4bc7a41856b45a100a22166697339a3685aa622e2601c5e07b161eb765282335090075548d566e1e87110404eb677111e737e3ca22b21ec4fadcf65fc612401db913ae561b168ea741d82c1e7a96438ae2d8b92afdfd7f767f8b55332e96a02dbd1cb018e631443e3be7c82a6d6bf6311ec395d011b2b6e92c6173195ae218339eae724db2a497d47498680c0cb571202a0fa1d31e2004d77f61a707cc219b2fbdd6822edc5e91d8b0e851db10ce09510bec70b4edd63bfcd3ecdecbc70d8218a39a04d978e9000d44baf42e60b952ea50ebc50e8c9ce7be523808262f473b2b1468978ecd2f11bc067d2be0bbeb60a062f2dce78eb322d79edcd1791a62581240d63b66fe04a3d703d8934839ed0cca575deb2717e2940f5e82997d13d1bf3fbc44111acce572cb37dbd21e3b8458bc334a8f9818b4b2a12738a39e0fc2b8f938fd5b38b03fec6cf01b091dd834b6aa167d4535b51eb9aadc8dc134d7e16988b7dfe9a1ef28480d353124333b394ac792a64bb6075805c1b76f71393812580d8ce708defb14e939bf48e41decf2407e9749bb9cac91552673c1a75452af8ebb67d6808d7327bd96c57e59aa33c3574a5244f5d9a8a43427af23e9c6b0e20610dbbb213181a9261f34997e57adbfa9443fdd43a8f1a7f31fa326ff320e63523049f4876c10140c013d4d5d4a7ebc3bd7f2f4c9a15a11bbdd8e5e04be468df0f163d32a9eb7c5e05eed83ab70cdff8bd2851aa10e83d83383f22e90d504576a82a6d4d6f87fe20634b1bca7fd9064a4412600345616598a1a5b53f8de108a28193c1345fe71812041cd3dfa2d43d69f1d1d62614d88c5276eca327bbaed8b88d9e434b816f506e02615aa4a2a176f9fae3f937491e0bf585f8634bf9192de3640440601b941e7fa2ff97ee194d89a1d266dd37cb95caa19ca2e5f818c31ffbf83844b1418ed073df2d1028382861c20eafb230b16f9dd4af287e3fdddca701097656c14ca5f8044ca7215cfa2c6022f4bd583bdfe2de622890ea39c6a12560dc8f7f13a8a3ba36a1393bac3342c8de823e767d78b2d84ea995af99d25cf5a492ea7f81a1f9b25d79a97cf70c662c96c7d52fc9d6d021feb29745078d5ec2cf87602b512c4b17ba6ad96b4b13b8610df494a986c461a436cde1b1a1e4c7d7cc9e0bbf5080efc27005fbe2d5e11ed3ae64f45e97cf45a7b6cc26dd84c98b661f18bb6b4ca561c8973e4ea5c2a6efe1d6c9548df6e6c3160b183395dddcf2a53aa9cd7488e0a108463f1c768219dde9f1a6bec8282a0ddb4c7b87d9b48256f729077d2b64e9123362a8dbb9d12c676238b3d0778b954c0ec105fbfaf3714131d3de72eccd45b526c7ef45b694314420017c8cd0e2ca19527ebac3873b0b3782cd8b05b6c529d70655d778552c40a29c86b133350cbf69afd1937b78380e262fd28a5b1add66656109cf235681d79f3166b30abae64a6c941dd88f05dd32250ecce4c1eb8314453c1b74f3cc8819a266ff14bdde70891d592ac915b52069daf12a288c3d0567584b2c0ce70d542c028576e921dc6d14e2cd5efdc749c1431788d87c2c2a1291e87dba2a782575999f9316b907820723e258ed179077c93c1a52f3f86ca3d49d149cd2bc308850865ca015d92eea1714d4c0fc8adb8835c947fc374a9162669ac4b225537bc7c8ab5113d5ee405fe3d1d30edae2de3ec52b9b0b718314c2649a0837fdb1f1e3e1ce0a5a22f092a26656f57dee46d73667fc25a6e154e94aeb061f26a6002c310e55595211e35289a3e5e00aa47e92f47b2b02f34a2a4738d47b1c0b68d105887c78345c9000a16aca1ff46595c4a2f7ddf31dab0c1f7c9a2f6d682c175e07e468baaf88bdd1081d51e26142bb0afeea479a57731d0b4193ab592cd10fe320648297f120e2b6cf979ae44a4acf5cf3a55223ab4ca826be2265a6645b363baeed9d818864e484aaaaed96e9e5f742a9028beaba59e55707f4a94ade1dfc0003f7eea8fdf2efa59e44591c651870e66783db5abb8e81fa8a54bc0b333130b937d3249d4263368004082c09175230cb2c5ffa97aabbf0d92b4f3a9bb844123ee97ba52eb420d0979e12d8d56043d687ebc01354fd50b9b10e687b13158a7b6bf0200777c065b9bb1ca1bc76f72f3e6e3eaa162d4b8b0d47f851e82102e0aaf9223eefb14a6888cb1c0bd1513a2f6a3cfb1e7107ccdb7d4f98d80ec773f15db603b34513ac6ec53c2778677c5f99c4ea4d027a044aac632e0658a1be5ee4e78ec4b6d11e5a02a210da9de182f32ee9aa8e236bb98130f50e8b301610c2bfeb97a4825d1e0618275a3477850038a707b21dd96fca237f20a285849598d3f9ab047b8a0024ee1fd49e54e725e6eebf24ffda30844735bab46d5758b0c538d8ff58137aa9b3512679a23041f616d6ac1c82d6551dd36928343e6085479e8acbe936d2a8472d9669b50223c47d34df335cd683fd3d60f1596c59252bd24aa28d82d1c6433d2d6dc825fa2ab05f19e6cfb21a3a11cd19e9556d06fde2e59729d43e64186c7564643b1bce7955d21e657f63b1f0d719db5f802292ae4b5643833b21462a2a102eab892c800008b5fbf543df858ff6a447fe75464ce85295ecbc911cc59d77797346e6c50a3b686940a2e8ba31498e836f4705a6fe520f87a18af927e18250e6178306b7cc8617a0e312c1f23cf1a7e5519c88fcd4b409071ec3c7d3b5764b31007063428857c1ec4c6796c4aa76f5aecd4ab550efcb43480e28a06b32a9dfbf09869052a26c6273a39b65c354886438b03e931d8ad2cfb6a5bad5e544c264241a03eb70245789aef704c728a798b9a55316a228415b2b39fe242349e2e60b52a4db4702d40eb9074361000dbcfe9efc1e75b2371faecf17ed1085376b07bc8a77dcd67012b7e7c249d7eefa345e3d3e18c195648b964a28a97d84118e5b0a00a2975535d529f34cb5c8ea67329d0b9397e19ea0a0081cd051c1d8b5ad118bb9e2d01e3ffe52116fcf409a1f8d0f5e511d08c283b07ecf152bafb7f0a3f6fa39316a2bee4933e2edb377af7acf0560af4d96262bdfea24a71acfbeb70fe54537cfd3ca76d17b20bfe508fcbfc046e1fcffa7a3aea45819f464e0afb0d944538401efa330f5cb88dde8e601a74c0f3c14fe6ad36ab49212f86ab5f40650186e829fa31f3dd509f58afbc17c66969af5cb3a7f40de2cb9a15ab8fd8bfb5bb65d7a811f7f700ba6c3e5750936a0f95877a29a3d607b2d2828576e3efd7d5e4cbc2d28bea1b3c7e0ffbf44bd077a95f01b8b71cc658d755d91a7f1df06197d1d1e825a78324fd5bcb98ae9fafc4e79e5b08b3e1e5afa1469ef707e5c7d37844578c5039f9a4ff108120cd8b11f6275e91b56fbe18322227c04b7de005a63eccfb5794244ccb11e3b7ee1753a36408a8e5adf98ee92aef6a2477b5498a272b62f5e1fce75cdaad019c513eaf35f16d71a38db0215447fa7bae3446c6f3ac7b26d216dd3a19b57acab9b4510813a95f5f0a115f986c03db49a853a1794c3fa63de516aebb172543d916e2bddf599eaf9858e02996d954c84aa430aa755817c97bce0ab152e39f6183b1021957e17581cc4afed2211d1c53c40bf8a794dbab0ff257066ae36f4001c58bb13627024dda17e53180e910d2f4c6f19b205b590dbde37cd93d09f5e3a9f234c271914269ce4b157b2e3303383873773eac396f6049e98560583f841444b636de754fd87744b26bf3546e85f588e77b3002aa8083a082b1eb829e1331aa1a7680fae23d348cefcd4420cb600c751a25e4041dc929c10accec9a2135519e446c843fb27d4ea2fed0b62c3d25ef47333ebb2a8a3559a48ada2a31203847adf50114638667a08152037cb2d3c3ab3c0f6bc6635e1aef0f8c0cfb17a35f4bf9aa30822366bda99d5e2fd9d85598eb272b09c56480f4483c55a0e8472b23d9b394bc5559fd7eb5d90ce7264b06080af55eec5c210b10ffcf7825de1d8510dc067af76a307904225b22f597702639db1a7132f483b96dd8c3911c260a340f7cae1ab5a70aacf874a8b7b785c5e8f90ae0bfb37adc4598fcb00b59e7ca8e44bae21eab3ddcc9bd30f66569c0f3374beb040ca5e18c6d01b927861c81fb09e5cd4e143faf9c9657bed44150dd5990f7da41173a0c601ad84a55ddffb73840967a7a511057cb6ac726b7cd782883ab3b390bf3fd6e95311570b7fc2df61391614334f2bb9485c894d90a46f6d69686ccabe476dc69d783073b2e4be4a9e71ef299f338fdccbe30501dd21293804daf45591ac5cdf09562d2f04d72e3c90c470f0f33294d8af22f802f04991ade407009ed7b226b4816290b695c42dc07929c8e65934cdc1e7237c101af040cbc3709c952013e3eade52aec83ee39f5aa1cb68d657b994507136f96d9d2a98fb62e3de83b23cfb0e2909e6795df445e8b31d550e1231e42a984e11ef8f292abb73ed3f27509d769a10ff60fa2d2e13c16e2cdadf399a79f0bba0108a0f31d20df69f0194df64bae9c1ca99f84b1374722d790cd3479a2b92dfbe85a92763b8bf0a0a26ada95f657e4fae2e899a372d8d38a3589a649915d16e7fd1c51b840a0e38d350b178eaa5ce1068b557b43c966632b57da398ce1e2867c2e9cb951b7c0cddf1674c6cda74fb798ff71ddc94ed876b5a9853e4d29eb189fa672ac53dc00554f35f2c5ef4f7a8bcdc35c168a7c45a7aa8318610c51cf1aa4999c96be39f270b380363e89959082925304cacbdfd6a5a19ef8250dabc37439e846fce1552afc687372d2253664c51265cbfd1d3782df7f9f7fcd31188d8746e7dc65ef55461f797af1c8b76df5be0dcdd47de7a764a958e1986de9dcf65c536c7347414a0b6b31f8dec40ad74caf442d89bf5f4b15738cd9936ab8d1ea00f4a39e630f676841a6dec2665bf953d6b8ba119179d9538b57aea807bdff9d7e1d29e8c3da6cf047790e7de804df6914ae352819f9723e312bc7174925f9e7c64dc208cfe3618d3104849298f54546c3fd0ed1e998b461ad3f3d397d5cbe1ba3f96a4a28eb715db7f4271116f112bba5cf71b8180037b7ad47038cd89f7d9e8aa7cc03afa242ca0588d6933db241b8b93d02d1cac05e18a793f63af95e93adced287e6abf93f03a247de93650ecafdf4717956840684b6d61d084a7a0279f4c05d2e77afb061bbee2bd1e93757eba2877a5daca422d757513f1d1a320bbf458a504a2763c85e6ed54c261c5d2596a0b2a043aaf8e5b59d125492a03fd73374bf83db8305f9af187cca019834e5e8904942704c13715d32a843d8a9bfd002ccb6dd21836fa367b78ef08978a3d118b008bdfb4ca62f66894193d5ae611558e2f204e6c637b897627bd78be5cad851d2520ddbbba8fb131b7c1178e091b775a82679de38ed2e597ee3c0db6e6833111183375279c33e79039433927b1aeb111884b58b84980b152859cd7f26a3f0214c20ecbe8e39b38d2c6e60f0204febd377670f53953bcd1e424afd03cbf9724f11dc97bed82009af1352eece90fb3da8e1265478f95fa7af3ca146bffd08f2e1109e7a251907c788062414554a098a356d06f26cc8f6c19cfe7e712b25ff9b8b2ba857201e789dc6dd64c33cf85a8479ff2e20e472c9bb324ceb56ab7f11e86b221f19e7e1aa37091627dfa9c9435a078e01cf594557e378d4cd5f2a47ec19f8824f7d0eab5b99a2cf6813e584c4f792cde665045bcbd5b895bd6bda1191c559fe0a0fcaef2e9e2d92594dd591a65742edd61f83efb6e09c1f58c0e3aff2cb7dfc7a2cd11e70ea01a4089ad8816139e5a421c5133c14234e4f95190c77c6c8ac48f33f27908d48720e2dcf2c5ff5ea6991cbad5a7bece9e140ad15837193c5476f4ca104e94c4c20df8d0b023b5aa93cd7da2d8d54330189d02583e2419625815ee0b5f7416420aa5c8c222595638a0597513c401e380dd1142658491749285eb87e3552a6a14add2f4deec49ed5964e06a2516780073f42604021acdfa8134dc35cda5128955dcc5365681ce9d4ee3ecc200a0d9cc479877bd5d4565408735a05ed7c7fb1429cc5747f867fcfcf520f53a329efa88272ddf77e21f19c50f22535d53bda7349f112273b7b3b979118fbd1760269997293f5b29d671e84a220598d4761b4f93c45719f87321f3571beb797d47300517900cac943090571f43a2d573e4fd698c3b8fc9e70dfb142a462f47d12eb4772bcefe0f50cf1aa8d68b350d55472e009f952385b36d60b74f7ac86c72957d9823d0c6b4a4d4a0cb4898d80e6530895030918b700fc2dafb4e6c34d3dddc588dfc77e7d1222740c398bf28340618f89994ea477b1843f4d490472e9be8e09674cfff438c95fe15841892f35a14f70471dbf18cbf2e34993ddf86910303966eb6daf1c1fbe7e4d587a34e64c5d9144a1345480c6d8a562167b86df1d871ca81cdfb4f5cc3067ebf5a4e7c69053b394d3fc8d8a965693783a51c1f203119bd35df526401d1322f96ef2d0d732a281727581a6ff315c789a64ddffe4d0419c29e7e2c563169759f8920c397142b2c1dbf3c468590a1c7377310afce78c1d4523d632b0c16bd91a1337919dc97d2892066d61c21db7c4b712ab9502b6b8d078fec62ca6edb9f3c5b429e02513cb332e50d6452722f5bdf18ef4bcdad00c1ec949d509c969652926d0422e430db47e8e38601b8c785926a1645a10ac9df595ba02b18085665994f272210c727c32c48404d9d490153e1d77739cc486e82f0759238cc259e3ad483082791cdb8a6496b3f5c89165ee7787bb7317e3e1fc20492f59824fbb91fc7ba2f3ad53aa09b5a6a6fba852cd3cddbf26eda27e1272b389ee59e9cc6455cefd0e701cc70933dcf8be9b740b45ab4aa4d16d353730b775718830e00a04a8132bd9bec58dbbf5ae17849fb1b9141a280080912e4e8520e81f5fa9639f6dda8681121b9b158b11f0d3e4ce56d298fc531703934bab7ebbba4a5ff103fb974dad6b64cc1ae26fafa481eaacc365ad8994faf0e60bf7b1abe238b757b663e5f5e086c27df961b7b580afd2395c1ee5c7a11727b6ad16eaa4682a948f2d1a58ee41fcae70f0404883be1376ea72fe5b24c80cbc24f290c2c9041806fd79fb0486a26efb65b35dfbe6cb010d73700b7d176ded30c4f74dc18f8da1006e29b6d6dc607c78e07ecc80aa0da063469fc8db0522f70be578ee3625c9008a4815d85ceb5a0c12a9619c336f0cbdf68a0080ed0977f9fd12a50debee0913878bd6d26d9ef15f4809eaef1c9bdf78db666b697ff27aa8acd06a3e6c2a006cda1bcd3c5e61506cfed4bf4cc8a0680816c7e1fe3721d6936d1411bfc9ce3ecdccc248b0358db1aa97ded1b31d4469ab5909f91e40760949a160e5d1d270bf4df278759bed2a3c1b6d47c3c62c64ea273e99b9f3a782df8b7a2dd6eafb253a84678beeef60bd28debb46cc939bb6de07a3dde73d873d070615458bbf73f9e7435a7fcb05ed9718b3eb685cdd8500a1625dac8d5fcd2400caace7203c547e733a0f7c2f251b4e3214778d76d4b0bc4d264d3c2cbbfc34b5a9d11310235add0b5370f46bac0ed6ab339e72e233a5963cf829f17f90ca629c6ebef7b80f83d33f4164a529831c18d5c4b3ded4a98f55e382fe8e5cc998b9aa7be123755f61be13c7e2ab2c49ce1f638948ac2e02b45a2e0dcb639ee17fdff883c9fe100de60ac17eddea4b429ec246f3f04df65c5c05773ddcbc8f395ea893859ad20929c81dd3b11efcbd30fb912c7c9e355fff250d67e2cb1af58f65828914b921c3f444f13da8bfe404fd566bbdc68001b03c8a6d9d3c93595eff50bc4be002a19d99a1ba7737ba312286e2b84ce92d398e7e447f68d24ecf27c185834bcee8083c3a95c607057b6d1528bf8bc3166be7691e5b186a43405a791ae851bf8bc04c277b30e8bab6cf988110317794f0ac77d85bf6ffee5ed1616d9b3cafdfdd2dce5224fa6cf79ebf636f178da6b306ea29327145099988261f44d8014a3b0a6916501f79328bd871b9074","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
