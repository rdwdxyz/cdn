<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d512aa6b209486a595ccba82cc9696d6884a3fa775bcdaedf83559a7831206ece2c114fe6d3fa6e16d395cc79765d6bfc30ecf8658e83985ea982799d08557c1ef1491077b92e38dcf20b031d3a2eac577fb0c2ec28fe17d4c61d4425b4fd877f12038458eebf0db624ec4fc0579644833e16b5ea4355d31ce4fd176198f3e8daa9481a7008534d4cd15009988141f8cb39e4dd56b133705f5ee832400ba3a25e26d05419048ffd79a5611197a4d06be121a1cbf761275e8440ad2c104cb744ed7713c08b83555499053b7b90b1f359694861142903a6c03f9d4598c3575eec9ce630ff5052a349db49ac3a872e7826c1710edb02e075126264666fa429eb26b982608f83f05115bb512d6bb386f3213ba866531134e9ca5fe8f8f863437349bfb4a457843c89800deeb00b49d16a1862defa5785d9fd4271e860f86fc353c62dcba9c2d343f06f549825ce22babda6859627c098ead26c20e1d78036d84f68ca4ebd87614dcd7e6f2731b78e5a27c623fc7fa1ea8fe7829d8f0c0da2317aec16ac793376a9bbb9a778cc64acb9670075fee26d0bcc2d9ff97da3e683f6697c98497cf5aa1384061fbdf14cb4967dc923cacc9403d64f4f3fcd6d6f918aa22951af39811db24b297234b91efd5f2c211dac945fe4fc7c4aa249d6949801554081e9d5df179d49ae5ea8c62e2f1b352d31c8cf701eef9a95bbc38529b215981b2306e62e01d00dba93493bb1da8ab7364d1606796b1837c9d4130ac6250e19547268e7491758953d57874d9deb9765388d446a5d8c510b5ccf1611f898e1d01f92d67a560bd9faaf86cc1ea0ccbbcd59a4433e3a83cb6ebceae15fc63e91946b13d71169fc6206dae8818663b658e2f2eed60557cb30b66a323e5b77fc87cbb7d89201a7e771895e94ff1e840f87d2fdb427ed8918ed5816882bfa073418601ba8ead0e8c4eb4fe3e5217251b0a35d541cb0b34b6794b6fe463fc2783e40dfc41461d2d30a84052f1f5760db908fd97efa706dad01585fc567919a399e601987ebcec3cb418b721712f4ef4fa02f9eabee488da083c43bb5d7331664f6201a50875900e7618c5846fb8c1862a96a06e52f0c00a9d4234b10ce74bd00e3781832c4ff8ece1941076fc46fc15758b1a7c8544c4907c9d4e7248fb7072ee6088907dc761fba0c7af4370e03b68d6ebb0156b7f5ce100657740612fa999fc189298613c6b94e09144f918988b149ac823a0f68d84b5c6e82a5dfd65a61b7484fd5aefcd07502afd774ff0e5d4d1e5e5c0d6fec21460013603581cfba1c44f043750f3e1c67cff44d4b0ea03d3eee2f747f6fceae06d751a670ec3c2cf4b319b30719b22bbb6a56431654e0c4237ddf8853ef5f6621c151dc7788165126df4403dc0c6b51a90cf65cd2333669a6c1e052acb09da34d414afdade2b268f92cfd1754a553a8f4125266870dbe51a9e18781c2a46aa93ea79b1fc038c423cac561728338c28a7b1a41ba7f63af7ba057b6865d185acd3452ded70bf9dd920778a3c191a56f4c87b96756cc5c0f2b4f516ae14795a487cbc59866e7bc4db039a369ffb072c53a02402e48d7f2a39ec32b30ac276ed29ac814bf58024db065a1dba8ff400104c99706295ce7e8be9e3544af92485fe852cf85f9418244ecb7e873aad9c5e3ebba749319e897527c414568d0a8f015142c8790622613dcba5c3df154391da8a731c68590e5b2ae6fc37d84f1e905f6de3d69101f9c77188e28e4de6f08513c24001c4b30343680801998b328fe9bac5a5e1a3c9330bafd2b96054b09807ab59c7f9f167634803761ec2b165d3dff944a6f11d615e10eb80c0d2d14ff2ec1fbde4e433ddfeaedaad0ba4427a8736c1f499e5f66c9e2d2ad7749818371d0d17eb6629ea5794e3bcf5676e7a6ec3764a752d923d562dfa7bd797f6f3b5858d5615dc6c182ea5f8d028632d0f4d5193102e088a40ddea2df210658321303bc6124b94a2ac4b77f27acdf9fbab05dfc9cde2677420c78b3d19fa1b0a86139ed7175453459ab81fedd0c028cccec7790373333c2e104a7eeb2c16dd49901d9cd20ed610881092dfbcc0f396b7489f9cd7700a94a39704c04eba2730f24cc1e28723d3280bbb7a253d4eb8adc7b86220e06581fa01950cc57a72e701fc651de2901dfe4c6de2f7707588d67b3169246be6b6b577c93f601c29d047d59bbf4a1ba70976e33164836b4961ab9ad90db8c76d727f29587d8a6d199e17a2d5a47b5f60bd1bb41333ef9a7d1dd4c47e292c177a76d0173a0adb4e1b9e2e911c39138063933ccc2d429092fb28477d2a695e61f2d2b321e1f9569718a50cd3f95a7640da43c51622ec5fa6f94a9a35cf0658f51e80b58e1d2611796177bac75449457e70a68289ae9c35d9153e2c3527acddea36c943efd8496e3931d3143376333aeda566021b999024708cb2755b85282623777d2438ab22c02efef43916a401556a5e8696b7fc105442f7503c588e222aa43fd15de0ab36d7e294987cec0863509b086164b48f3eccd89e831c8d06f18c5175b3d89e42d5d2d4e415448b1714c455110bafbf9b30a305413db61dd8d2c2bdcd46f49bd7c718d18312c0e3befd6988e6e7abb10fea283ffe9eeb7ae7f90255fad4642658b47578a34722ed0fbbc1892bf0c948aeb8aecbfd0937677c0369eb795feca90d0020e109b09d8d256ed3a32f96d7626a49d697d8a9ab47c6c2be63af8f87fd9565bffd0481da32c711aef7f41bf09c5cbc9b7cc6ac309b56a3315f17a3afd6b73031b7b001a3cc48f7852084c8b9d935d7e602f9728244180c6b725a75f03d6793312c89e0dd8bddf5853367ffa2d0a8fd022734d059d19a3bba485238af7ce15c21eb83f427bcf997ebfc88dc2a1a35ad84c567362d155f3ec5c38d9222194ac7198860ce9cd537352dcfcb6af7d66ddbd87d927aa0cde9f928a9975c7f8d82d888bfdaf7c9979a1706bfa2120cab6f0cd1b5f5d9917af895c6d8ce3fe94aaedb6fa412f3c6c83920c8db9e819d2f4394e2b8a4a68f84eb92e4f1f1310a3393e9eda9325565b491edc13590f7167410764885d8d0150be30a1daa9345de3d3835113ba58057607d488658bee2ffeebab5c0d4592ac60d1bc85c8cd5d10b45dc1f5a4c4afaed600024e59c2bb28dc6c72f8a9835cbb1984d6e49b5155497c3ba6131a173755dea25fb249d66009121a1f8bde6363732d4c972f805836c17e493b23d834772dd4cbdab2cb75e3f2a3730cb3e356bacddb2b298795abab8644494749f01a4a86e5117f565bbf59eb1f865278513cd1bdf86f079fdfee35c447f681f09ef0ce1ee4469f2021b5d59747c25f4f247ac86f7594f398f85e07a5064cce3c6d5d1a689b96de339091c6661d04be59d7220d26ac6cb0c0908ee8cf5d1c66cbae3b49332fe62da78d4c0a01c8c19d07a1cff9bb65ed89fe4b5bb9017ee0e6d4297bab974ae481efc14068c9db5d63e601176afc38436d243145e7a2db133e819ab4b6dac7f04afd30b705a94b4d8b42c7e0d9f7535694df9c35875e73129b30f5fc3cb1821173923175feed990aace3fa4489ebc6d81fe57e1b52c007efb0c2aeec149a4b40419efbb7f987ffce7f204c1e10e1af00fe9851a833646258fefe87dbd8712ed16d0a1af919095e06a06b39c80b2384dd8bd16e0dcf21463941c8999c9d56429258ef5024959c8a4cc30d060397bc7496efc54227217fbc172412f38f898858a3484cea3ec19a29b3b7cde38b8752f38ef52ee91213c338a0569b5962a8b74a9dc02d4c6e339914b1f46defdb8bb10d30a9cfc8732437b24eb14d8150e57d13bc6e4be29336cb1e671a4b526d27eeee1a1d634cfb42fcb1676b64bb8b60e76d35155226b4c628f56f6236176a0f122b34c0b9a53cc8ad02ee094e896e5dcfff95042eaa6339fdd981425f1dad8e35604b85ef303ce7b4fc853611987828a9379e7d556a1819abbc682476caf51a2c85e34ac6f57a52ac5cb3688a96d7867d92606bdeb5b5006249404fe41ca8a1a30af24fabaaa9cb7b40c2f75fdc083d388912388eac73c7f31f23d00dfa77d0a2a86e56bd7d1b3f074449fd55d20c03eca2236578fcfdc3ca5bfcfb8fb30a876e78f634f664047c04ebb742cb3eb26b2ebee5cf63242a29e62b6ff3b3f934682c8c4b48abfcd111b1b17a7fd2bbf068bc54290cc1dd7001e24493323dd54c5dcd36d6f136f6ffdcb962b37944b341bcdf0760706a9a342210c87532ec36f0e0b6e39a7b3419f15cd0a0381057eafeea11905e724784322c0dd21e8f4c91a774db8349e69cb98036d8490eaa2919612ff9a1f74c382b9ce2379fba0a3549aef42171ed39543f949e6d57b16819485c3975c731b33e92a0d9684163d4205c58b2775df34a937d4cf974c2e86e3fb00a26fac59c8878092e03b73326bbd846accd81d4ea4bb6cedf7fa1e4ac2a5c14e2cc164dc7677b226b536408d9dfe14b99ea146c52167b73987c1b6263ec0b9f5709796b55f01063c74d0bc264e36c9771540355f299605fe62a63b4134aadea7283793a774e2decdc45a34b1e37baaed78786632fab2453d8c8f0fa12c6d1c233a9057e9279e8f678bdcf7c7c9d141e06b4605774704fbb2fe55997a8b8ac35c8765c65af158260b44be7d10bd916c9b3d4e9685e9a6a9c10422ae8fdac67b15b3c51202f57f6e736483d13a9ea174e44862f4e1c1030c4abe8ce88a8eb37575d1f305a5a0aa7ea407aa4dcc0ac4fb081254532ba96ad56159335221bae8aed6965b4ef27dd15ae9b03be07867cf6cbc18ca9d7a26188d3c4515d1357e4dc307a35d84eda42265205628b789a28f2a5f21837aaaa0d7ddbfd3d2b1e6afc77bd9fa9ce67cbeb5b70987f627291da05f05596fbf1d7dde8f56f0b085588e5dc24d5294f270f42662add06f217683cd265f0f33d479e72844020217bc75b8a4c3c0905c78942783d69bff442ea11ca6d04913ba5d26ec490ecbc36ea64ef2a5dadf31c697191084334ad1567869d28bbd07a75984bcbd18d20543be96c0b8a136e349945bb9ed4738f845edabd0940a88a9d52d760f611ece7fff868897870297e86f5cac79192e3e60e2632f173625e59690ea239ff5c1783a1a2b50f91a61fa2138944b3baa82b532228aec3133c833678ae72b9271b7e37077e790a6469014f57a494da3caedee00be2598ca0ead17b085f0970d07b60a6fbe6b6f415de7699069d11753c365e338cd1348408cd0e7c3bc4dc793d63d441d8a777f68e0733110190b55c278b1a46750c4f8d3458c2da0916eaf43365a5455694c81dc772e4aa9555fdfea1a17ae32ce7c24ddc9be211d03bcb9cbefd176fe5e35a50e8461f4bbdbe276cb777643e04b0b8dfaa89d44b4eaab9bbfdad58ab0677cbd71c328c69a58c89ea1f4b8a31ce7c883ee41fd040c6201ad8b9643ed884ab68ad4addfc6b46670bc5bdd23cf4c4c4a79fb12180efaba3de9047dbfc3e2e2c7ba9c2fbdeea67ce6eded9cfbfde437c5c6b4afbeb9eee3e0f668063ea075ea29031976d1cc33adab773989b9656283d2eba1a6007423039d0f4d9688baa99078dc62567694a7b0a05a2aef88f962e48ab1133354c18151e4c52bc2ede1e087c533b725c6058583ff37d160e822012e5427d8c1ce3f6eb481ee27fa226bc9d5634607a440f97218dfe620c51511e3fdf1bbf897b140bd2dc07d40d39a38b4cee6501fc80abfd02873965f60b5f99835721728be8a79a85e0015070cad89c8aba5c42db11b398bfe01ecb33b107eb16a480b58b72f19d24659f48a5a939e13067bedfd4024ebbebce8ffa147c2608afff498ac6d312541542647d456fff16f65b4a0214c860574ee232beddb8b8c5f816f8a0f6936c4d8879cc75d42a880f99619be80764154f24281f8eaabc2b3464d5363c6162c66afef5f9e35be84ed194282c93474f3cabe93c59f03ba664b80085e18db1fb7d241be2ffabd470ce39955f96df5d50d48839792b5041321a637a82f34f99667d50743b24df7eff342f40ff2b8f9abe66ed704e23afb8f2879db150c14d799c925626992ab5e23c091518c3182bf208a756bdd298091795d19ac55eca570375a8c5988b01ec91cca83f1a92c3221232f6e38062e714916e53f00db7bb7d7520047c308d1148a7de18e34c3af776ee2617772c2e8a9a15e318455614cc0a6581548c11902001e6846fb0880e3abcd937aefbcb6a17c663ebea6fffd49bd915d510d87f5bd6279f1b655c5a8909e26ede9b84da560591a1f89815bb961a2f4e325f39195216a4c332ca19caed53aa2099a983c8f89937a3fc9a7dad066b837b8f446b1d05ca167f6ddff1a0c899dfccac7e67608e4ff6b689c20165e0134500a30bb28fd6ccd5f7b4a57c5bfc72e7d10136d69e59870a7917d66a9b470b6499fe028ce1ca65391a206134e41e1ffb47fc16e71ee6182675c3b9b1bdb550d1a96fffc707a0a9d33f74d07a91666b1c9a23c29d956a1405ba27454f641b677138f38ac7fa0094f3fae1c1b958a1f0a6390e490c6218c03b09bc6b4a369ded31d63d736b164b83c8e0069c8d9743206efe1683290053f745d3a09a76450301b9e01cdc2385511773d6a41b3de70d37045c69579e9f81571496a15a942a5bb391c7e437a9f77863411ebae7e7e385b31bf670ee9b6b54a5dfd99e09fac70c98222d8f4ca61e637ecf3b8bdc630da26e91a2067d2e55a05c49b107533744a9200b48849e85323b1c281267799b4b29b0549e9fe5a53e3f3d2ff95c30e0c61cb7c0f8f2402392b8c2c3c85f7294870029ea1006e24670d60e01d24c85cda29a02216e446260b1279d8ec469f33aa410316b73adb4eff8111bbc1032c6b56ad9faa33531470c714371a2216605c8e8fbdd3f48c13c819cd8ae261cdf8f0cd289bbdbb358cceb6242ff9a540bbc18ab2ff2cd5d940c0af8c42956f1d001cc3c157cf54029c598f428fc66a725ec7fedc2d353871b81c9d1e9a57357ac47f712a1f62f422ca887d57d25c3189af4d080c41f31dd4612efd5a5daf9b2e3c447891719200081fc5de88d3afa7f3e498530a93b4df09d900402e51dd88abc231ca8d88a6a9ffb2f0f0c9cc806c5bd380913f23e623158c66f78ed496f1a34d714e96f6415d58a0620bc50d784a2e3dba4e16b03524a0e70ed50f3de33fdf1ab73a53895d1f1050ad0c61ca1c7074077b770287f5be919a4c7e1223c56d9abc3e804ba0427a090df3fc32270c3f6c270fc9a88dbc0bbecde89a94972cf3f22af31a42d2a90f7e5c6b4cd786decc8d3d581ee900a95f3d08292cf1fa69688db0e090ae9c9737c9e7696b29090f6462caeb2b65976b7eb0d94b7d4baa556ef6dd4a1ba8f20faccbc0e92deb3e42271826a0ba15814c3989088b05152492e9da5c18bc9b0f805f0fe7cc225d960d6e471b4488e2e0ee59f846f7a16d71b6deb388853fddd9d11c29dd77da2fa3dea2e16554e5d96dfae5ed56bd1c3993a6d8d8d3c6ab9565c13066206e5eb948a5abb9429075f33e6f8474e88b3d0f04bdbf04a4398eb6a8fc3cd19d4ca04ff5d33e654bb89c9775576157d4b3bf0e336cba91171b869d22c21d505c03d657ec9eaf1fe06c70c4f5d3b4efb7b8e6037c32754b7aa2458548cc36535e4bd10532a7db9babbb54434fbabf2a42eba7718e3b96a31fcc85b4ca46f9219d638e3876c8104b498e6f939ece7c851052258d803c824c54f34e1b381f973d49545e0318e3294e18a5a17197f73fb685cc0c7daa4fc8b6bf64dbb42875c3ba5525af7cec14b54af27f98b7bbc3f1be7fa44e82f7063071873caa349f0e894eb56467ae045f1780826ede80ea97da0b08eec6b29545294ca74e8c72cad71fbab88e24ee525d3c6c92bcc0a047bd7f7e9505dfde9d2c83ffa24161ee8072db0af265291b3165fcc7ccb2b46c7c8d80a4e10cbadb60eaeccd71a446d73d70a8d16db0e67b73942b14072c64ba615268252f95e69e995628c33fa8627363290b01ec20ee5ed90d5d6154a3960ba64f69a6864e9418cb66bd90f49be08de7ebc35d76268a8000fd26dea3a39cb4df6db0f38e68ed53a5af8188a9cce12b8586dce838b286e32a780bcc12a53791a7d1bb3cb192913aad805bd3054e9f479882c76a29f77305ca2a8b13c630a2cd99e580bdd10a05accb810be383cc45944d8c9d90e83d07619ae65dd95a13bfdd8e9870ae85cbdbbd089757ad36e86b04b4c9714671d86e32e9c3cf220266b54da45c3de91668eef1a4b2625f8794b7a52aaee4bb8d6252fafb02ab014fdfd913d47fb71fe34774e8fd5a49480a0d0c2b9e95aba04cdc11ef2c00a7cb87fe0e5a09421887519f82a8b160423601056450f2b41c63cce65a868e08a9de72cc62de48a6e020d8e03f441941ae86e2442527c9dede0de58b5936deed6749a5a6b33dfa94f8aba9184785dd05cfd63af76bb4a8a56e38bfb0321496913737f378ae143c854b5c4d3443957d00094b2822903aded4ea4e85be9d693a3a2db190a57b2896f0c46c3ed1fd530f3aceaa64a1bff4b803a55c4660b774db852a635e959169a197f59254831bbee6bf8de5d7c5e5fb22ba6ff416ed8779cdbc43dedcd57c35f420309768a62dad39d2473ae0110917de6a99d467ddea299d12619cd9e06b78df1708e403d7e4bd2f887e12939d32697676ac1d7979fe6f3a8e18d7561e87e8c79187c81e3d176889e0a45ad85b3a21b9dcf96972e20a1143c0a0a431d4e371532604cd8916cfcd3c4fabdf67526c26465b2b69b65d30d00bb77fb4cadee3711abff4b36c820ffd8c66db8118fa94663bd01d674320d0a33c7840a7113da483de805a48f17e8310e97ad08580de461ead22072e9decdd7552492fd3bcfc4c0aedea26f5db0ff7548cb2ae72e1382929da738c05f0618e5bea19f292ab79c175ce2eca05f18c879c349075ec3c6e66d77e3e88c6b78789a1909e12c7a45d41f2f104cb7e167fc4f61709e9c321f53bd26d218697417173a75bba494a6d6e418972cc71dbcd6f895c658fbfa50d8580c1e319c86b25ef08a7028bde0ce548dcf251491cc13537dabf3a3fb2da0138908f27b2f1aca51669a75013975ee3112b4309aeb144f509cb3b766d708bf8147029455e490e47fbf32848d2f30a78003a2463540a00ddfd213bd5772e72e36f1db876b767e33a6567b84c5a5855c5987627e39e0950dee997ee2bd1aa9c65e80cce3eb6b034f91dd07971a9e82f2b19b2ebd9798188cf889bd07162a520f56f8233368b8698198c25452febda8823c5abf1ec3d645148feb36a32f3aa292728f1717b9af1bb30c4e446424414b3e8972e85e1e172148846b03344e9f2d22cd7e596017866c63267910f4d3759c08f54ca11a59dbacf0190106a9101f2fed2db5f492c2aba2f5a9822adf686f5e1f8f525f4bdbb3c62dab046c348ea06b0899c6b3f95b71e6324c72ccab7ca375c207ccb84db251de51a450f6e362ded0d58eb72702f5f8d627e695d2c1c58094a4ad393197c3a4e35d841e5b8f6231cc106bb8a5492da9c78bbd3704d2506e3b848d07fa7c44f30023ee1fd9fb7dacc72354fe2e02f6f50a8d4e2861bb1288eaca75d7b64179fda34bf2f5bf755f6d1dda570a0bcb261704cfe1e446486dd98b4db26cb5f976f1ea5eac8fa871ab535a3a3fa13069d53912f46b28bae379a45c3c5c5dc38ea8a491270e35703464764c18237865a0b670bf769ec5385ed5e16efc6b0e384aa088376bc683218f8081e039ece9ac66ba4477d4d86e6fe4a8801cec1a68220b088b40d791e3372276d71d16026978f6a0f7b83f950fd980a7959d4ec474e63b218561027f37ef01d964cefe462d3ef6a8f6faa7c150957b3b97f21b460cdbe6c96d672925a93ccd9aa67c6f8213eed208142af724ff9279f4e4dbfbb27f531cb1b6cac1818fd9dc912287137be81f52b41ef1106e65c10667ea316ddd352ae999105ed17fd52bb4ec31592fa45b43d6ae0f39f0ce39499775c3dd53d0973e74c1188e6d69daf9698e35a49e40fa0d35bcbd518f79859b64e1e3beb54106bc4bac69949c6554491e8c3a365e96257f9e1f40c730e30e31c4b3520b986868e6272f85d6143798b7aa58afd9aa0eb31bb48a361796ae7d47717f00203776903ca771869107c3ad2407808a740249d4784b30709844621f9234824286109e12d48e0f3bd75d2398ec45144d43eee3760aebb5249ca7f519b4931264423480d5f4989f265185f284be4ba5ad000617959fd62916190b30ab55c82a5b03c0a39528c082c9a48a7f34a6fb4b64ce845d92b4081a93172854b106ebf63118baca96d5ad204a43c91bbb886737e001933c063dea3143944a2f7b568dd7bbe329c1935759556d267d468a02a88b215a20827c6354be9089cbfd0cfd4b2c3fd66d10e769b4bc8bf47b6e9bdc96ba1276910b53356850045e38cfd25fdad1e48b798cb739ea8b65cf357e393ca40347fc78c9c052e5931e6916c333c3075f7ca9cf4c2fea51f26b56161b276321436e095f0d1fe4127ec72499304d125b46a99f18f17eb170b2c6eb0c7b027dd29de6f43db7b303643ab51bbcb5860a04795e66b4b7c0f6a4ad083ede30e1db479dd1e4ed52a1a8c482172382cfddc217fdbc16016dc3ffe87ec984bc6e194a54a385b4acdb84ba54659f229026ceac528774b842dc927f0ef169d4d792a1519a9e6447d520030b103cb2fd9db97eec074f763a8f0419dfb5ce01a013e46d18c0dc376a10848d6607d26e352972adeb472c2481b171cbb1b7f3421590e4b6ccc17f4c3b6ceb1c7614b1ddb44327bdb0271808e4430383a2e2efba545b1ac45f5bf71f34bff0d36afa1e4d6dffc829758b311653aa6ce098f59bf04153108826da3b5868106b34205237f5a401df88518ffed4fddf298bd8bb93c96b78d76504e86548cd5d9412add31f6a92af307bd9c711dc14829084f608fac5bae844c8b12e826a29bc6dd2a66cf6896a21ca43edfd219c0136a8b9c7dc50c36807984b1d5d00717edfdee6c3f3b33aa9676a55f775fef36a02bf94a4042165a1617e2419021ec7983e80930c5b091ee5c6d0631aaaf5307afa583d14660db9504b9a68fae76d497125cd981c6aaf205a06c8d024a5e6b5c0c49a60b1724d1abd8c08b7ac83eab1747a14395ec270ad8db847619ee20665e2c154b549625c7d6364053a054ff20aea6f4303862aecc18d364fd26278cd75d5904688860883ae9115f78e24a28525a221333b7ad9326011c812ba78d650bea2861e58c333d7c8470e5820645f265fa26b1f2df92e5578cc82ab537f28f76f45eb8727ed36a25d7271ac65f81ef76c27eea42938e29d07473ffd32daa40f3c43ea8aaed2f9634b569c16a32e25d836da9fa1d79b0036007ad370d013983bf18ecffe998aaf49530bfecf822362c7af3d4cd1caf1535052e609bea7d7feb9341fa17532ba587bfb3359e0e6e0a2409bfa3fd0174cd2e2745eab220e1613cb02058314b491d64577f9bae81c444413902c450d50fcc671b7d2adcd75a982f48d035f1787541063d5d971196641814c51f6b5ce6e6deb8a187527f0ffcefdd1533319d7a14d2a1f83d64d329d3bc8d830c8ceb44afb64cc654179a053bef5bdd8a1991ec90d49d369411adeb83f3180bf4a2d9c17d38a785603e784c1ea72898324ed6f49a3011cbe13227c4465928da64d86cfbf93917927705d03b307d86408353582b1c5e6c1d39758d682af90d3011996c3154e80368fe2a75a85dd3312fc701fe34c9adceaab97513822081b16ba728508697db7fc872e4be3a3eb1b37543b8e6e7803a8829eed2f8d76253554436ffa532c815d2c02d84558b26f08b69d7d2fd33a24ca5add4ced9085ef41e3f841be696c93203c83b65b47c3dd7e434d89415795d3a5b81f643abb68500b4a428d0e2ca732cb05e78b892f11e7d6c4a347e4e6784136261d402e3badfcaf4657d67ccd2c35a67786a6855d56662ba11327f6e6669301acacd46f9a8b37eeaad48795fb13690c8b1e547b02905ca44415e803c5a1cb1b9ba4b50a1beff8333b9fc27604b944afd7117471a4b97a2cb7e695a8c09b864ea2f3b1075fa0d1254a40275c6ac151ec283c490ac77d364513201807f705d9a8f3148075c4884be270f1a2fb625ab1423a819832b4ed0cd881b91bab530ba5b8ce54bd26c94f7cc604a5d78a16f8daba3e3e532732e0f1b25c3cc50b7022fc888fc89fe8bf5e1fa3e75f310e35190e9d1a5e4049cfe015c34f10a44321fe95513c7d2acb39ca353a1f9306cfafb3ad2e93bf1e2cc1358a20ea8c2937a5470a0de4e0ebde26425a7e614b0deb19d9ce1cdfbb4b5a60bac285faff2118b8fe6d1643f69d183528f1bbe1570aea7eade4fd234431d2baaa1ad6aeb2b2b9fb61250c4d9663e9f064e319bdc932258af43a3bba7641ee8baa699721abbfffdf1c812409c06f544c9169017c46a72849529e5709b4ba8ef349e8cdec9aad2635f140050fc14051730e3d82b20325ba4d403f12f1f1e6f157736d5980e8cd7f78296a9d6e88443d8b0de329f29e5f22af41244818803f8b3f59e47b7ad3c2a8f93b6e8adcf985621662780493c9d54981008a199e953f2e5aa76915004954cf0a7cd351f589dab4d8137ee508eab74d990d23837dabe42efdbbd75991aa50a5ea0882ca3fa963ebd5a93f9ebeca869ffda456643b833769f55051898d2222b6f0b1cea85db664793d1cfb752d657da6d9f62b92cd4249cae90af2c3e1866dd8b252f2ec3f2d86372d38e039773ad1f17a5f82eb1cb0a0a8a782e3abc61076dbf11fc14421f06221176eb65ef1d1212c001ee40c8e78b662624a766b25e86b6ff4b083dbdfd2e874d85c97958c48ad78331e9d87040bf822f92f7ddabf6fd43f97bf95abf904e2c67a367620efad480bdb31d9dee4b4546e73604d8d0ec4620558067f1f6acea58627bde39f2293496195f0f9fc2525adb25e4ddc9dbb0f1e3e9c0e6e4be2ed27cc9102ddeb9a1462b64f7f59a00d45faf327980262d1d0c235f5bce6d2d655e364b52733600fff31450bc38f5c7da3ead709573499ccc9d960b2736c8c82056ccde872f0349cc8e66b4f71342d604714a02d60fba9df7e201dc86fca8508975b4e0aaf1c5cd28f3d4af7b14a09392026a7cf6bc08238a0cd251d348cdfda4b90f748f3627d0165a333e3762c119f1d17cf49ac56709962bcff44d32fa8e7a90249228fa511ec31437162d4c989262ae672422f098999006a04e953a22bdb40d7aa051129bf03cf7e1f7b357b7c3bbb13b4f121a6b4751fb203c21d70a72e66410e667afee73bd1403afcaa4934f822ebe9906f0c37d7a7212f1447717651a195ac1ca09143b2f624984e7ea4a7da2fded88f5050a45109001a2bb72ead3b7a6f1cccfb28bf9891b9d638be8f0a37340630125b1112f53bbd97740451b67326ce21622c3228a6307d56961348b345bd7bd5a305bf642c86942433a69f39fcfdba85a9a7ee9c1eb7f96997e1eea42facb8a739015e1e5be8b3f5956892981c564dec2831a6c4ea0c24f8ecdbc5dfbb06f578e645a85e694fd8f648c8ee937c96c07debc113c23936c04dd219ca1c3b93ce897a8129387a60d32cdf240b307c82903762495fd80b4dae3ed29b98d2772d99aeddf7c35c2661b2125db97150458a8c13e0c80ede3e0819c2baf43cb9916e72bb1d339e3fc89d5e1d4f5791d51bf59e24acd75fe2f272137bd3ff6011e79bb4cbdd3ed774bd1a1c03f11430f7fae087c07dceefcc07417c79d8ce444a8b00a8d94d95dadb0d25c4050897a9af11cc8fba7ed256ef416df3f229519d8da80c1370476c3f3ae3ad217e345642bf0d1fa6204ea008febbf5a3930d8d10fc39f28842cf876abd62b6adb0c1c83dd72fc3af19f772799e567db6778659accfb673f71c3720f38b434e08f3e8cac526321b076c6d373e279ab1d012010abcaea9808f8dcc29e5cbaee29959129397de0befabe8db44486efb30e3cb7355897c454271b4ebe4840e99d6948dc2d422c6295d1ea0f82bef956cce41220b394ff3bb1e37f16a6561d54eb416976013f24e3cb4b1e6ec64d2042722789971f6fbdd090b4562dd5ce7d29a3c2e62402d8db705c1026103137520a997f33035fd4250c88a4bcf9725eb032022642b5721eff42a9cf0888820a38d356cc7c5699b89a292d40a39bfd14370937908f4c3cdc68705dee3dd92242e0b9bec7e4a316246a6a73ff52fb1445c5a0a9733fde8e7f4aeeba074b4ff0eed00059d8f374ccca73554d29e37de03f00eecdb332450932362e1b7e67c72bb56a05df17b821f89516c53b12cc75cd90ee0ce58bd603220a2a3a5d01d0679a6a2adbcecec86ff6e4ec4cb830c6f6a78f8d67676ccfa378c3a2fb45c0813fda6472b22ecfa4773ca3805257f9a391697c09738b3da5c4ff225f1c6cce449dfabfecbd866f9f326c265b49b21a9e84c5da6495af770de51f76f95d8419f6e73f9ceec912a2244052ffa2a07312ef59c16c872fff4adc25283a676f8f3cf0eccc2508f2d26426c1a46c8837afc6ac6b876fbadfe0be76cd4854460e0fa17ae8d173ed9684ebf4db0a531a7f5c0e5b3545743173d0bc8c43f086bad1b30e086fb8567ca49d74c1dfb4c98c2052a66f1edb0ea925281007c312c8fbf0e4956e943813d12e6874765d08dd6f25adc4c48e21f95ba05c81976d09f0f30df2f97e2a674e88fcbd89459b5fec246ee33a9cf367721fbfdeeb44df69d1b629724c1bbcffe35112e66b595a59e0929575f1b8c2f100a7763f3074e592a7e650cdc58a157886e1a847a38b168b71c2350aaa3f1cf36fcd91e77cd9f607602ca43acfc8357637d0eb92b727fad748701e9420126919f538ed22a06f29c0cf258332df928d0c973d0617c5e738b331873d9aa99b0e19f526f5be8d17a4bf05a410998dc60f7a0b95f6ce863f90ed2c75da68e2cd740b1770c3d005721ce94bfef06891da8ea360bb00a49c89f9520371566b7eb7a93532c481d2e214e5298db3f874b07579e3629a5a3cc634a5e4efa10c68d7f7ba580a50d154ba279bba3e7dca99f22926404c5f3414b09ce9fe8d28cdc6d4a10055f38d87bca89aabdaf98db99098be713f0b251f1cfe2ab781541d3ba42b4cc34110ee5e1d6630a73626737db8ed5e12291565b5fbdc87a2ea24221046afae7919f4c69a6914ff39ad41a9608954da09beeb3d9d1515d2ae34d962728d3d522cce2202127605b253375aeb885393aadcd502e2d8fffe6fe1fc156f36f48bf5a7ccc0ba7c4bdf0715f440c771e22a13077d9508e721ba416afb3d9a87e45f43427a0b8e83e26566803281a113bd2269c46647f8ff0a880aff08e0e2f700d76d6b93c63acf5e45b462c4f11c1f6a29fb308d7996e447532b4468b8a60c57cbd05cba568c99caea1735d44e501d37a3c66400a03331378a1f3e8ec4a8faf244bdceb992fb681117e04769f9c8c5921919f6116149028754d9162b4793230a385fb5be1f9d76b5ed241442e203aba498e423115676f29b3112145cf32d71e489a907797c5dbe2b0ab29fa107d9d0ad0fce81ff09e88f3523d215b2f9e95c35533dfadf19ce6453354e11e33638ebff57dcde4eb3dd98abda3dc287664074772a845ad7a230193d0ee4bdd26261d2e77a8de88e9acebbfcdf44768f6f72a4f46315f107d0d685a95e0710de6a849dc59d483a56d2855e902f08841020a6d33cecb1d6714973aceab1ebfc0b424213e1fcccc4cdd7fb3dfa86a4fdc13e08c7af5cedb3ebbf9bb6b54c00d270f5c3ef33bbc0509bcb2277289af03b5aa8cc5a38b21eb7a5aa7ef18a9f65791467dd621048f9a67500870176e581743498fb360fe0088b4f9dfca46cae2997f9e111fe898578e252527873d81720ff67a19678426c7ca81d52d1a1a1076252685f2581b55d7e1862d7e2873c4d671f9068a3357451aaf7e0f9325755a34aa1008ac01e34be34178d4def050ea312666575610c12421241d6a6326294299e94b0384ada4badca33dcecb31b2db35f3f25e7880d005a84f88787e34fdc479ba7ae87e92d2d697172269d94a840e31ab4978b0572f8d20e6a906ed2c55e45ae6475733eb0ab8a7801d43b15d53fce0e2f0aaa56ff9356332fc06c048b724e8fe7f1d88ee25c251f473e22159ee6bc5ff82d25b2090301db4a7e770f95618d8993b359101732be99a71f14668ad27bb08359830dbfb5909be13dedd025fed05b38c7c8caf87d467b6c3217b0c1e238926f2d89b47c6bce320659c0a7d70e5ac94c2486b27c96875f6812a313b5f1da3caf0b1c61afd958681a640d0b7ffde111a20fb118a77fdc32ceed5a4d5868349e47e2ee7e680d7b0f16237c80ff56d094bab5940ad1f56fcbe4ac9938ad7a8bf8fd36679ef29c65a8ea7f62acca6a5a6fa97919326b3ae975d766a2ead50db34473b398c4f9de8cd6a9accf226e265a83d962fc28729458ea5bd12876d0b6c13872ae414d0802b0a96e49589e65706bc6054b7b24fbbc783e3d6040563ff2b9829cf4adadae2b39f8ad26c3bef6dfe1bf64564e62dfc72e8030077be3f6338ccab8c9771f6f307336cd344530ddb34f1feddff1c1c107376c5b85b990df86ec0d05c6188e79e92d4cff02742f833a43d4d0fd71f847417da294d2480a8caa05edcf7f978cd7c0c849bdd5534d1126b3936dbc61022ac53d9ff5622d7936e6e65a4f29be33f445da3fafb6576e52a0eb8214679901898eaea9368eb58dbc1ea6f48a681143e8b8e6e7bc233276f725ac6df4d0465cf46e361fd41874bca86744b9b6ba83a837f04d95572bb21ee98b93ae6c222fb9d0e2a086bd19e9b9a2db81328340a3d38102ba5651105ba79deabfba7c2cb6b7f76b2441c7236328b430ce0e1f4f37b943811df8a93d3a13a469531460355fe3bc6c9150e023f20a58b25a448e5c9cfb24a88171b9a9b9ce3f2a687e87050559f63f8d238b0f1afe5f63bf52c38527e1d7cc020c49aa58f7631d882f6fde91b143d7c26e35c6798d4f8273678967f3b5d0dcab2706ab5cc6e7ae55c83fa06d077dee75a9e7f5cc3eb98d93bea098d8c004367078d078061bef53c7420d831a140c9ae60a0268f5c666bcd34b3b2549207dd382eaabc8a06edd2d343e52faf654170fe7ca36cec356619116ac855061ec5339911e4b3f5c10604a5751ceaf8f9774f6c406f303847da46a152fe864a30d49a1cad5a22e82e8ca8ea5a26803538ca8f3edabb79ce7472168e8d5050da5522cee30abe831abaf4725b091ff9a5d2da7b114fc977df66b8a1314a2a85df9a8de403e5f19c1ec8a84fce8b91b8c88113b00a095198fd5d7edfaeb9ff98d006abee3c729cc0f483615d75967ca92fc4a39a2b0f504b5d291a0c3b31a7e6ae9d2ac6f5cdac20f7d35cff7fadce8ae93aa22cd212983deb3b048bfb606167a2b4f14b231eb54d6d19225d5a13b7d5eb201ad88c404553958095b1d15a43ec49cc3c74720a685ccb85d416df46e660ada080ab4d86296454233ecd60962c4a10cdd32157f673e311f68c45e46e59b5c5be46b0057ca85157651788c4767ce65e951cb3e8c683bf9bdac1f481b0b54dfdcf44a0ca9a534a5b2114f1e2ee487de013a64c93268ede76255321f2fe256d0316467688f2053c6d7549be33291e403b05f6c65ba98cf8299b6247ef7c5f8dce4bf5aebc0c5d9cf22f278ec1d616c5d8523fb8d180cda3c2ff9f28f91b5133a4f731f405acb1104924f3afafc563e7f8235bf358bba3f919736394a2b82a8db377bd7d53412f1bc6991c9d406407e7b9325c6c5a81875f99af578f4d24496313be5321292ab6242a8132fd491da5c500111a48f0099c14efbc40efdb832077ce14ecf569f3659b88116478b3ecd01b0b21f8fa97ee03b1bd5b8bf6fa0996d1d78f4abb86bb54ad70feabca103bb86d7dab2b906bc29d325b5ca8fe3e39098f8d8e8032e6edee09203083bd01a3ec8d07b30f33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
