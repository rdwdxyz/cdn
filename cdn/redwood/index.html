<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1bfbbf5150f430fc880595f2d6645e11877beefc7d51c14fddf60c0c4f85f069df5fd66ff6c851a112af95c7237192133f62e503e456bcc93225a6c366a20acd8b1de9759aed8d34eb1e6c36fa0e06ddf368fa3d2acf8a4cb43ebba2536a3972fca6126ad3f2a2128a75039ef2940e42407794c6f16a3c0d4a6cea55f1a1e0ccb2ed4443462bc929738fb3dd4486ac4956650cc85a3bda7907efb2f798c11f5b4f05cdae056f1ce0773db02fcf684ebb788ab33127320fb653d75cb6e9f4115a9aead986c88c371ab28fb09702fa048a07f7a3d4acb98f2c3caf3b72bfc6611962ec99dde7364c104b8fd3b78fa54177a101b48e9b1f44d0252444b0005745096cba0262bb3ba4b58b73117186aca329ad98162c0dd5145c12c05cd0e1d51894a2fedeec2c4ada728deb6bd8093acf97194edfef0edf75524d8804a2202dd7a5afcb84836572551c0274c4c5cef41831153b95bc3b1414c73046d1cfb11d0e01bcaba141f1ff3ccf26184ab4804aff290675c1668fe0b8b609690de78d182953730fa23fd5befe36a50eae8b5ab77491225b8c26cbe440deb274e0ab82e4acd8ea7908284c4c8051ed33237d2ed383f3ca30ee6d47eedb3a8188a9a7c9529222e595f8c6e64ab25d7a7b6083683aac13a254024deb9c044eee9c3af10f4a97a6ba931ef8c7cdde7ce90a2577b80cccac0a40d1367ddbe17765968c2724a6cfc1bc37672691bc7034b2c288af679d9132e41a5a2ddd9c19c84b47faf07659ed9b34a0c35f49022805b4a2b87a922aeecf0bb63e8db0bf3678d641d8d60efef8100b7bd12aa7e35040c57f307e752fd568085ba00aa3b69739bbefda4a3695e982205a83749186794f6cfb405abdaadbf1a8ce1c5be04bb8f73ed6fb31385cc861685dfaeae5ae5cd695413200cc898148803b002b2ac73592224da9f458925c24c094ee625f5befe23396eddc5bd766a345a5b5b6f5c97bd90006c5727c4668b0e89016c555f510f349c3b42da74d93316f9f38defb42100934d15506a0931ce52bbe6dca8d9b3c07d6a071777b8b27dbbb7e1f6ba72e81a909bda03224594b7963d334200e39780a079856a94bcd06e2122fcca0a50121c869f4015ee7fac9d6848e8074fd7c722b67b68118cd2d3ec893f4c304013125aee189dba6d6d7a1c53f1b8e004b524881c367ee69c04814ebee736af2821f4f1e5859e4efeb7fcd032f1976427b5aac44d254814aca6ac6412508d31ef15140889d697002592fcbf627ebb12c9ed0327dc543306d20b9528544c6d5cf20641d08d669d5dc83cc637eed61e4ec65d17979f20f913723290d2f1ffb6277087a11c244949db46ec8dac860310d7629a6cbd6e68a83c2c1b165e881a12543f77b9f319f69fa467ea5ae28a1f2555a99a71ec6c6d3d0cf2a1dae8563e823ee7889f64af8b31d2e22bea361ecdb8f96d89e616540199b19156481881d180ad66fd93d9b10f3a6d04a29085bf5d46103b080fcef4842cda80fff28ae99b02b6c6675d1f3c6dab489eb2423b77323f229a15faa3a381b76de9e823ebe66e0581fac528d753bf646e2de1feb5a3c8aacbf3fcf74a6f185a8056c9614f2fd320ae668ab68b113fd559c34c8a9861de86ebbf21bc495c7149ce1c9cdc1f1683f643e9efb13897e3032bd0993f4b20fd694b746f075b442fa0665d139f64e01d3241e8c11825b5f1060c8be6cbbca52db91f8a23a415db468760e52f467891e4178231ec8849b920661275e956a776af44723b6d7f3a28e2b1768bcf6e2adf9ebd464cabd19855c5cc0e01b71fcc3a24f6eba1b3cd06359fe30345646941622a9b489304a5b05ff54f8d533d5aad646e9e7c9663528f351dfaaa3ade67a3aa0a3333ce80cfb8002ab6579c9c40dbf78340a0d3c5f816c081918a9c1bfcc94bafd6c2a0920c03e51935b8471b0da81d43b14e1258ef877bcd7bcc548d5bfc7f5840374fa6c266a2fc11f890f1b5560f5468a306ffd6c26a36f56216f56002da7e4d2893192bff5fe03040fa103c6759be7cdc76cf27489ff8548390cf0a960f5f638c42ab12bfb78739a7de62a1967b22af9e636e8ea20bde9141d74204164da3f0ba27b1afc500a38c93dc9741239bfced0c39c49ec20689bdc20a82d1767a7ad9aba24d428853778196bb1b292353e2835f1c0a727f23d83c56d2c186fdd141fb16765343224585ae3b590dc1b3634bffc3acb29ae565e1ecaf0a88aa0145031b19b5d0b06d624d8960a6dde0ac1bcb555945553b954e7e45619f9992b6738cf84cba616cb635a9fa7c064aa7982652b9a973543939912b4d83b35e342d5263c04e62f6ea696f57a018afa33ed35806bfaf68d5abc2ccb1c50a54df9af84ecc9fd60c1eaaf2b2193c48e0084b014cd0d2ba8506fb086ed59080314565da1e74d52a4062a83a44109f54d706241eab0efbde64e59ed2ecef738b76a7c519233e14011e1a78b1324eeff9d5be9599873f72dc52cff700d60ac93db4aaa1961f93efa7f0b3c62df2fb84ef3ae33b3afa146203ee5d91146cb152f511e741f388c757be52ad72cf8a98d107b043aee2ef8271a86d005ef306884749c106c2b92afdd1addb8234116daf389286b8b4c28774016be77991a7ecefff95b6d686a2b5e6cfcf0e657c7fd582720650e22620918f924347cdd5439552a53f50d5f5f7282fa71f5bba0085536aae21383b90b9be91f4dbb7c602a18a1461faa9a7ab66e8517decbea4b4dfef29b40d144b92b054e4e5f3d1d19678c1e697326848c782f1e03b2df1ea45e26e6cae47edf20400452ce110bbe72ba9b38c1a8809a0ec9e40d608c5b9003849ebd3b9de914ac7d53771756ad7308e5186c8d1e7830e34102c00e8132e2c5723e7c38c4d2fa086660a81fdc3afaaec034bb14d18688876d0a1b239915b1c6113c955d79124b7b8a75beb70d66acfcfcd87ec82dab42def8c368917d1bdd9861bdb51e510c8274a3fb1e6600495399da7d4a3336019dd992b78d2e3f718b1c73a2cb1a99b06a07d49fae41711987bc491f372f7bac08db40ad633dcc0dcef0275b96a5c2b4fff42d7ac45104b069c371dd60e7dbb13a01a36a3b9cb506614e61a7c00810d520fca5866864289b7d23f2a90b18728d80a64b1492d40e94f794a5ca2f744b9d65e04529996269b183fd5714748270d597e7dce41e9c80dd22b31938d136547bd8600980cc8f0a37eeb4d38172b7d384d35fbf279db4c5fd3267ddda1469b83ae129a9161ee9ee058460e958a31c472b63aa4ab57d135dfa77b0eb0db20aff5c4e90c9bf10dfdda1f3e8d7d5b8a898d402a2d4805153a687c7007349f50daf98e8309fe3e147b658a31b785d52b90764bcc72315f86d9b2d6edc88923cbe62d19b06f9a8cc65af32713d8e09332d1ed558fce9b9d3725503deb42ba79e3a55dd729dec9c5e003582339dddf0d4db66e68259637e6f3e34b865b0be212a217009ffafe9ffb244b809f90a590aaa68d78bad118f3271249d6383c4b57a42a1fb3b57155dad0c273d399da9d051ae1fe7165684d8df4b0532c136fcfbf32e8b4ee9cd000e51ab8580b800590115ebcee18fab1535f99b59752e181055c098bdaa19549a5f815d3a2ec823d712dfced4b725957a9993a90a0f04588120090a3ae68f46533bc79fcf0a9edcaa9775beed74718bdb6997e3476fc7762416dd363d41079b7e798afbd0d77e1177ef18396b611adea1745ff7400abec7007896b51ba3e1ef14012e60f36fd095156f5d37e76ccf1d51d06e5fd4d5be9137ee3017506fd5e9bac2980a26a5be0e6b6bf87344567583e3a5fd5f6f854da2bd25831ce7c55a4b76c20a4da60729744691683bf0f6726f0a2edd15483c209e027646e871468e8227204357db9d725c3f12cb7c14ac22df828756dd178a82dbd3b037ac8fd7015f5e4f7ac63b3ab264c73be06684930035e09b9c1753cf2b88ca81e965e52fe863d07639cc4bae36d64095edc6354eba7c7238dbc2f267f4274f0f6ab21a1dc9b63ff9a678cff2903f2975f74d5905533f905ec57ab8a0ec05fc9fb2762aa79b4f091856813e9a1a3d0c63edc47dc7f43dcedb10dac768e1ee67b02a8e6978c8a10974f3e3c48e94cabba993a5a398e975834e2e156e97a0df4b2107bfeb5f26d6f08837dab4bf8d2d6d61db4c98a1c33b6f5685e685cbd9592e4f7edf6589f6bee5c79758605f26533972aacab32893c2b16a6f19fe9234c4ff5a0c6b448a4f2824a00a54c2af20dddf4c0b1b3bd1c809e9b4e4afb686a279021d051c265a1b2038d9f67096f8d31214fa98e50ba63752874a6c60bccc0f72cc670abb7814e73d8e3e8e58bb8ccaed288a52041d815c4303aeff7aa6f76f53a198d70a45327da01dc4482f665c41186192af611731e3b12fb9b64b28dc906935ac69350ac6815165ede51d283a63c5a948d1d1b7e7f2fdea7b3d832d3d23c6add2de96a05a41b2cf741fd9c0d5a52f2c796bf63e82f043803b032c2bd14e1f8671e9b9d2a082dc353fb3f344f1409bd79c6e7c7030c0d35fdcee01b12640e4b867792e8a4d24e3b328b21a32d4b53e2ec4261842c118f32444888ba154c68b43e773b4a49548e20e9f3ee60a3bffe77740be93c7450b8e256e6cc049bcc59588db99e722fd27c3bbdf2b27a97eee0e561254f7a25c2400031b99e28f16135302f5048a46f81ded6b904f2a620fdf315aa947cc950d090fd9e66a3040abb33f645ba1ff99c74246b40c9ccd1a95742469f2abea35b253e1fa7ee2b13f6987222d8fff04792ce2487e6302df94152ce6cadcc63d4d7d42ffbef42413ba68f4c61f8bc79d26ef26b9eebdaa2c80a06ace75b92a071ce44a6c2beaace78f8f80506b1fc4e0c2e1b96ed41bc45c28753611f8630b3a62d5267a3da7e446cf620fb50e4d37d78bdd1f601beab9a0281b7d5db2adb7c0b35cd9b50ce6f7f04aa73f29831b99674bc7a02dda780a435ad025b7914a4a4d872546baa39f072cd3411253e22c21884ef3541c015bee86cbd088c9f3b59712afbb0bf7373a0a6f62e16bcc3c1f6ce1676d05ea459e0ff547e552b93209c55636b3e275c09a4dcee7432e4928fe5046e1739176be1890b2458e16f887fa9e46a9b4932e5e0ccbc6182d832a9729b84322ba9eae1dbc161d4390044cb5fd2941e24cfabdfae38f429b1b542239b2cdb49523cc0a3dd169f4dccde3e38f84c19633ddb696bbab0fa585afcc1d75712d7c6dac22196793ae74fd21f37ed1c845b4b2e6773f6fdbd34bb0520ca91c74e033bb21edc86c632734d4e30410d00d3d6109597e64c9d92670a70d3d28fe282ec21ba463a22df0edbcb2bd743494d45e72df6bd151379a2e0fc1654da0a1ee17d90cb64cf80bf2a7990ba5d6bab0ad5d6dd0902f271802efcb7ee50f30f70b915a87ee849f5a9ab50a5cc3f850edeb34a292f9c9f25fe324486dbe6a6bbe45d379ddabeebaa651e11be5b53811e91d468416b529d96f837feda0c8a55c567fdfdffc52b5bb4098f1aae783692f9c8b204eedef4e07c0210a0d651b74a4651d0b944752bc9aff58e65b8138994f4ebcb67657bedc97c3b2058cb4b3aa6818846a2baa9b0b0ffb2191dab1da62c375f8e1a3331838becc403245f669ee796a267f1319fb885121d23c99d42d35ad715394547c34d3b28bc9a71e48e001ae74fc4888e746a0504ef14a47e34f544a77a4bea89729a380f53c0ebfa1c31668f2277ccb4baca9da8afb875a67b79e51c061556e7c80839600de75ffec6dacb75ec218683f2c95635aa838b3c71b7b77f262d245a4f806191934976ae9b883063e64b72e14d69fb3f6e5c476c7705de7673e9ce139bff12c5b243acf53c873fd371004a1a3a9045ea680483b2c1450ecd34471e820fd7c6140a22a94ba702ec86c95bd57cca33e1fc59c2861a00265023891004dd49789bd4c00b4e95b00e52adbf85785ded22cbc5c49ad313deac917e9860ece16c4d235404c56f03e487552de0c75a7ad872a39c8bc0a38ed9a6f59a694358c86701900b7968de4da9443c1eeeda6ed04bf8581976866256210d47f3d473d80d8f6b4e2ad6a0a0fe275963544a1fa18cc00752faad26599941d1d85098165c33482d40a6d0aad2b2195871e7b7838b196e32b7e7757f445fadf71717234b1d1a1f5d7848f9e526c6671c4a67e5a5dac9452a201b3a354404984891db34f1995deeb04b62c8a5f1636ce94ba25221993159795e43f3590974fcf68d206ebae6aa78756d945e544522d0775b5908416c7d2fe17cb8c12452c40272320c0893980ffdf8e9a69ee66101ed0ad697d3ad572ed2a584c05281bf9ba1154f98b61316232784ff54331bd5170f5169886493947dd42fd84dc2bae991fc535a03e359306f994ec564a02dd8dc62ddb2d0da9cb8cf0e5af2d67a93b3c5ba6dbff2ea9176b30481009ebd9b7a7386839798c527dbfa4a3d0e26d01bef57a0731f09d3c3832f959a269ff77b0353f72f576488184146c52f83116a1b868584e8d23e49daa6a9d0eb1883b16daba87d33819b779ec9e2e254d8e4914b182fd5a1b05f2a0f41c01df8f14d9cebfd78a3fb964c382ac786c776cc08f0ffb35e4d9a18eee57154ee6be81d0d049fdb9f4f5470da2e60ee9a96a99e76927607d1b1a5cd1c32ece934e5559c65d0e80a1b5b959e0cc4f4dde29cb0f34eab6ef6cec8ba6de15e3c22fbf47224f4f71740e5d7e173de683a7769868b4f3b8ef126dba0c68720177ffd48e93fa82a869831310b9b6b3a50eb0bed2519191050f80dd93ead5469fdbe937f6cfac02b74e1ebb4ab43bdf4c1128bfda01477b46570235cd43ba54abdfdda7ee830d1ea48fe93ef0e07686d2978a2100e6a68ff8638183f8e9944392185526dda065fddfd345a7aa0421dc95f40504407138c40c9a80b56a9b6db7b15cd884ac735e24cb94f6843ed29a67d40dc9be55aa5e5d994b70b0ce74fdd9eae13206205cedf68bff30833c2cb9993e38fe0f4aaf7e464478dd10655bcd4e4d676e376c5537adeceb3bc47f8047788cc95174961c377066dfda869ca0f67e93f76eca2c3099ccac945352e3ffec6f82e3cd26c10a5a216dfae762a19d6b67dbbee6dcea507bb9bb7d88c85a7b52b8be39037697018cd0a99272c9a45df9dea87e64d898ef45442b65a992c99f203b3415f0b1b93e250eeac0f027755caf4ae8c2ca6f9ab76f68a1ef8f75711f7a1aab42c9a12f103e9f1741b9b107183f150554f09c36a43dad208cd2decb63f6396405e8df3d7385b62b5813b1491f9de33f4b9aa8180f393f915660bd5df135b3610e281e9ca86558f2e545e9c5edb61dea8ca082ca67a025de642930319582a931588191b2afb8a9fc778f34b14c82aca483d8ba90fef8e1bc5177df7b2d26f697ff1cd2ac632594bf90c302bbfa13b0cca4b2618b0d7f40d88766a71f7ec3587297879af55dd9e950d3de372a1dd107727dc07c8fea562135824ea0ea8719bd0154f95fc6ab0d5106e0fa213b61c8314d81fa0170fefc086a18063db5897ad44fee8e1b66267c1e7d25900e8104e874fd1b1b0de39d7df0ecca78c40376eda6808d13bad68802240ab1f30fcd08476eafc4f6dc3808c969adcb4102706357e1f7d75465dfee3425967e7ca420bcb015206210c3be5ca789f405202eaa855796534fc9d07e6934ec582726d7edc8de91dfebcbb88c13b342bd01a1699a157ff845d5747f9c0ad3cd6a80e96b1c66bfd78724433870f01e54d0110ae7ee70f84f06eb0be79778386dfc8cb41ced1d13b6455dd3ead2c2a3fd925c587e4c67df48d0f5112d6f5b9015a9a74b6f535b09cdf3f38c3d17249f5dff2190973bcec2abbaf109f7aeb71d575f40195a7e6a1beb607bff6154799cad583e764f2f9dc6d72e501c12f4b2f3180f93b0e1475bb0a27c1c2c2f96d0d75fcf4798dce0f94d01ba7df8462641115b33f4e253b52462d7a2754ac986dad4e6200f62b88f59cb42892e038d7b558809cd26d16ae174d09ca881014101c9979a2da5cbdc8dfe5ac1bc529b3345078853cc45dafb2e4eb4a2878a7783976a66c1694691b38b8a1c9f207d44bf93f5475f102fd497f7d210318a8b09210ee0790f0f22261a55bdc925c906a1c677cf6abc364073b61c6c83686868969d0f28622f4ed6e56892bda0d45cbc4ff40d67df7eddb1fe5ebcf19c60ed2a1e76403058c930e380ae1ffe9a109aea87aaacf00f3ae48bacb296071871753aaac4ca9004c808ed2f9d07371348c4a4d9a380faf19813c63bae9dc5ca8a4f052aaaf43126ce4db56b93b8fd4d1985df0dd11e77083dfdc3963618dfe5aad0fe8b2e30bb3a02fea83f530fb9b7d3465001f89ff90fc5ee3fb8cfbaae5dc1bf412a548ca1eb6251387b52be90e3311214e65dc2b278c1ee6fb640a4a81079992a7705561dce9f4102f8e30ca9ba7524424b7328f344d12abd9a21e333d8dfc65abdf0b881151328e752c279d5af0bbff31fda07f1d55378a34d024fb1a868a7472344522f97115c2a940d780acf1ffc3b8500206adbb854d92fde350349d71b23f508d58cb6a1a2e87d2c39a9859d3d858f5faa398900356ae5a0d365469cf00b2badc4db443ec6b7a47ead251ba09bb79d45692fefe8402d8145c14cd735f244b2eb65d0feef2fe624a371680ffe09e04b89b9b24305275e0f6167fcd511f518f6377cbf2baa06789b76e9f02cc9dcf5fefb77fff327c5170c12ae1f1d1a06aab6538eaa1aae654b39049e7577d07911f431fd69afb78132681c99b6a31f970068b0c732ec9733d6efbf0bc444bf65e858c539d08e6c91ca34233552ffd6a7066ba2e618ddb323024f75203a1addfaef538a679d17287c63ed2a3476458ff83aa38ae99b1a19f042ada5baf2572692eeb465e48f05df6fb8fec8cbf2b93768a61f375fa67254cb5230abd4d3341ec4a24aa032eb16dba8972ca6d2200a3fedbf85ffc379e6a04afab5119b77c8745907edba85ac419e2eead0a0cc3725f65169ec894fc93f88f93ca671e322c26364c237a71a3cae2bb680d2792e5d9f60dd1af6a8a9c8d68d8cc0d65b5768ac4524059baa72e11979089c06f2dce76fcd6b4b3341af733ebdc00524b2939c788dd252fb9cbd022ff9cf74695f042058622c493a154b6c8f9a041e4d450446d60f5f77b9c6b3d8001f7b6b89e0379399477de49d0db5ed04e79696ce293d8d8a5ba4737a9e4cbd20fa4897ee05461c3704925571ae061064b147ae87271764c6b53ae0024de3d166f6870804ad00a6f44a6782f286c76695658fc051973710cbee1f4dc23579985fc0318bed3614eca6797ce7de298771d747900a1e7deb7b522601639ec2496e4c06f5b503543d93cde52ff06036a19edfef9168d10bf830a1b3c317e0132087037cc4f636029a1f77d0ab44a71d249170f3aa50878ebb7569e057a63cf6cc7184ce5c6c34bb6a845ee4c83d2cec55565fac15156b40870957341954e26962ccd484da26741d1b65447ac18b9df4ab9562065d9f4b16817d81a2868095bac5591e0d144265145112a7fa22b4cca48e2de529e40120f88cddea79bdde2336d869f9ad57ccf8693b428c76894454dab898cd8615a28d40950423739e7aca2aee82c03c0607b6aa5a341e3b7158e3cadb055d4337a7fa8658f918b279df9c7943ee6c6517c41f98d332e28efade3506942ae104488989fda19080661418fd942f2cc08ba855461c651ec3ca55b7cfff9d0eaaf47253a333aad089621d47581709152297584dd63474dbe2c8048a1d6355632da18a3382b0df4d55dabce5b0b77eb9ea18437c9db4dc4d45aa6e1b83d208eadc1b26e9b55d7a9f02fa465e3145de403efca37ee3f2d57a5365f1e606dfd765d23b18d295c4c0745bee6acfbf745f335a416d3e332d896d9467cddcc3c7aa2bb7f8fed907e4f32580c1098f58a2a0448f48ea26f889f8373fef18e8b3ac788016d91816e3f303e3b63003d9f906225ffa6cb707b4bbf6451bb3f5b7f74450da43e573c3fbe8c9800f660a5ba36eac2e6e247f3fa796790eb7c6ef03cd992b92e236410cb2e2ea2af97cd2f69d5f9111adce34132b83a56d09d9c0aaec273e889eda9f31ad92eb0a591ce1bf7ae9a0fb02f6e546b8539e8c7b076d74fbc746437955044bac2509d0928a7a4a512a6489ef054410258623e52897e81fc0c551cbf8422abe6becba41bf7aaf70160f2f1a1a54ae2d20f7b2f6150e740d07cec0458aa9c36cc7e737efc437e36a6c8d0e834a2e5eb4adf9d9e4f4aa3a9c4da8de1c96643218109cb12755379577d32aa75de6e04442816fa6648ca72e1be8835e9eee3e1f39461664917b849eaf206ba20495bbf77c21bb07819706afbadb0f2a01a452837d3097484f5cae4041c57a1b4ba125b9dad7490e0df606bde0ddab3b5edef4030c5a3cff704bde7192f22c34e57c9b4da3ca65ebfc6ea1643d92a57f6f364ebe3f461cff234b40020885d0ee2e18a8f3c94590e015bb11ca4bb48202c0c4764a0d969719b1257cb1d07b101f0a9a6b6b1b1640ce89a97b222000ecf504df18c6eae754fc3225e73fc292961182e76eb25e9b0bccdbfe0fea24ad250f1e8c97de67dab298c138c2aef38ddd4d6fcc885d8ad9705e34b83fa216f2632d8ba8f26d2b7ab6fa81bac08830c0b19e1b56584bf417ffca2471f3741506044d6512df1cc1f9df5b190318867b576a876aba9aaa1c4040e110257d93e7bdda61152e00bb33d20197eedbb43850b1cbe7a02543ecf6cc8a9e7826e228f6f699edc1cf818d36004b1f691d919d17a2cbb3c95bcc866ecbb5b4143b1b062744fc380e224472b52f1bf486ef226e33d42d29f8001268555c9b89cd63dafc85c1a3b63af8b56030045a8d02920de02e501a1acd044f7c77bfb9f85a2498cb894598aa82045a9509a078a0cf3e51a30fee31a5f19e542d6da643aa1463ba4346ed0e26a0b221282d415b3a9c3dc282f7d81d67976b91608a08625ee012aeb16f13123b2aa9b799aaaeaacd6e046bca26825410cef6e81f0ab4444a39c92bc63cfebbba2b4b9537defc58587be06b978f2fe2c94832a3722489c9440fae5fc7ae771cd3c792a2851043b72eb2eb90bf24bce9c219d4f0c3c3bd57c97da61d26f3c89d8983daef5b679a8bc6ec0de6d505d9fbe31936791a672c0e47f705912e7c7b5d475bd626052b19877a366610b62da806475d5ee7da5074ddcc2f3a743447670522d3b6b491e3454fe6e122cba03c6df080751c3f52b7a1f11cc88933d92238f15edf45b7d4f85c8c13020a52e453c729aed898579a3698068e4e84e1b299708dc16448854c7ae285e51fc9e60105090d0789e0a8a12ca341100e477116d83d6d24d1901dcf949f291e7aaabba22f311c08c63a240d2cc5b75efce2de79938ef574859bb33f1bcdf9a1b57ed1ba3eb0cbac6b504b15f2339193e08f7ed0b795ea6dc34a9e9d21bda3b705fb336d535a65ccf61ec734831d97034c3497f6cb8a6cb878daae5a51aad7ff5ebbdbef847af13935337ea4dffa7f9878da0abd638e1ed0773cf99dd7f7a2ae8bf1cb374d527c3d4dcaa82a61b5d6ce0b84da48c9fb2a1e6e2b0253d6d60fdcdfdc358abbd65051a331577d6d2ebe79f792450d2fc1ef139ccffb9e3cb7cdab69c07da0872924c55417244ba31a101432927ec0d1f71aed28b08dda47e43ac871348dd3ac13f23684f9be6457ab6cf3217c448f66f1bda88eca4b833cf96f235b65759ec8d9a88a70430cec5050b2dbfa9f877e2d94877059be48eadf58ea28bc0efe955fee472fa849a0f28525d9af128be80d13dd43e66545bc1edc9e3743a3b88a88c3d4bb20934694ea53659b6a248223ae4aa30e2e7d0453e69f8b0feb247d0267fe95ea9534427d74d79c00692b4c298b168328dde6b7ed930485fc3c83914a632eb20355977c591b46347f8fe830d2b3498a855bce0fe0fb4caa7f25a50482389712f269cc8b1a0e4a05079b152625699d5e9f319211b4694b53b2a701dbb228509a956d84da2bc2e33b05b6ba63e086ceac0162e80f10d072238ce4c8804c0eec7144f2620eca8952cad36dda3b002476586468d6c0ddaf21d03aed684f1a25ce6feb96680e9bd89ce2d610d37b169350853a8747c82b31a6249d78bbbfc02f73e40c5caf2f766bb3f5706bae7163fa33c81035b3b43061d48b5c70dc73107dc521d8ab736c7b6d5f573971be592992aa726c49ec6d5ddfe89a2d55b8f5ed15e9a488e0d050c5744b6d442be30f1e50b27068d5775fa1e77faea23a361ab87ecec585c080e70364448516b27ac2e62469d6db693f44546e13cc6d783ba6cc767f155ebedfce48f1e5f3882783db910b36774987aae470fb2b4e19132b7a97f4fcee5eb0b302d6b18ed80adb245bee744ef19662fc58ccc87df8eb72d3aa75061627d3b5d3dbea48e90617833fc738128f4cbbba7392161c854ef808ab5f68d7555aa31141a020782d005552fd0773eb07b1f1b2961565e9e7ca79fc541047898077c810a443b0dac2ca528c9167827f5f7fb0bf3fdee562665c1ae62ba3cc08c1b818f43648c76b6ec32c3acb1b569d909ac9854f86a2009b4a1facc02a37bad4d41f5cafbab848ab784b83ed5b7b8851d48e0f12ef77bb69324da45e7f3a67de07db7a266dd0263852c359a14b4d392bff9b2b0b398b33a68b71d3975db96ac57f71bc2f25cbfd9e5fcc84cac70ee61f286354ace2ef9f3b17316250ea65c28ffe71410e762d87c406a735d8a99d2a2e62b02b8363f1ad154e837e163afcb4d26b98a087d742c132b6b9bdf5c11364eba57000e35eed89e585402896403dd44f09ea97660906d073b22526af5971ce4a0dbef30fd6615ae4be105e285985288a8eb1c66763c2f4d037bfda97f713ab05ead4746501dcebc490794b591454a9c3cb8dc961d76eb2d708588993abe658fd45b1b04ca846b6f257c3ba7dd99706b136f9679c6d46a7f3278dfed597467c51a3afc1f6f4db4daa554b2a29493bb1c4d2586c5f2a0c3dbc48f04a492d770b95205a9d5a4d42c694745ccacf7033248c78da8c03adf30dfde3f4ff95f09ca8f73ed8fe4c734f689086424d1463859ac83630023599b8a935a81b7bbef9268db70527ac641dda90c3de17582216d9f5546b3df517d715110f43d8289636314c809f92f0d1dd81451d99cee6bb2bde1a36494c654f772b82a361a76c265d15f396aa645528511e29d16c57ad50442e4b802faf88a13da3a8a30de1fff15bf325c90b3abc9ce082ecd630ea398831630462e48766d357aed432edbe44887ec56a9b5d0a3f7df6f3fa7dffb97fb8ee16ee1506d496fa921ace5225187390bfa5a7a4780a4e7f599c0d462872f636e419f3ccdf771ac10e138c9cbed7249c659d5134d5d048b58174cdca5d2ea14da5c60129a71192f4bcf84685f2f73d8433db241674470c9e9bada3b282c670a9cfba67ef6f306b336012978b195644151e76355093e4b237f82eb8f2c37c2ed8a2551cd0595040d70a984110a055d2a15b55d1e147a3d841ec1f76231c29ce6f0bbac832855238243aa45b407599bac9fce58a90b8996257452fdd59cddd76ab4b313dccbacd6843266ff5ef5a7c4d9bb8cc9e5a21d2979011acbe8d3b581b593a237be35635b5a872ba6cc84ea1a05b5beacbab8b17c5d6ccfea28c8cc7e13accfbb960098f8c9cbb75fc725dada5470feb4246b2baa233eaff67d31473241702b4e261dde5de176efb9614f6d5a3b9ec621d624682ff9ca38b64830ae3345a378928a0bf3253019b16c1920df554b3a0b3f2c89b8555b3194912228d148c9d0f2ee678cb47eca50b25a7bd2ca8bda69d0beb2906404903d9dcf723f58978934e39ffbd37c093edddf6d568b39603c01e8ffcdca9c80d584e43d462d00aed27b87da357867a71feeadf2ec5578e790f87267cd4d7a44a3de2315405087c7634028029e69faf52ec4dbd59d53c4b7541c1d3197db4ca6cede556c1832d4fac0e8dbb175d5e587162e83d57a6383c6fa2d14d16c17671a8cf2483ac88b13b3342274da82cc3dfb294c2499295fcb39d7ad1e99c473bb5fd281bbafebaafc12f6f9f81ff687f0e98edd36fe95721446e6144c3cb232768729aee5b2a61449fb04a7b55bae3b7d202153f7d03b3de97d89916ff562d49232f3e4721e64ec6d2f1da57ee2898307c9ddb9126d1bca84e7c90e87d4b360592ac2603c9977cc3e976c8f0572253d3541a7e266baa4356b659e52bb3b6cc4f187d3a34b762e0a08013c1900946a324ead1d9384826ec09441d5300197cfb38a2b71117aae73b46cc970cbe485aa61cc34fb2d2759b3d7b59d47ccf6643984d81a80cb8fdba422418a34d2cccdb99480ae848e8ed032cbf8fdef1856f4204a2e42aa741067580d509e8c0016cf07d0844ecdf38119d088d42862697dee1b30191a037efacadd09b4e6a4a26dec1a0f54ed5e162682ad680bf48a0a992d15883a78d8b12a09f4ac63d3f8e18f9309374a00b01a36b9520386b9efc432aa68e69921628ba3307d977cf141909af64ab32213be218faee359978fa5f27f26a31d4ac0b4b13b76fe7c9f7b0ce6b8fd5475a2a852e450e26fb13c44f7b5f381968606b31aedff0a936896b61b5f07467573075a7c562581052e1c228050dbcf988a2886c49a1a068d679a6e9c14ebf0d45e454f42686cf1f6622c999f8c92c5c6e3851c2bf83d3ef6d9ded6a682a27178291255902c2b19becfdfb1659ac23f76e79557de68e206fecec0a87fd364f4a06067a66dc27d3c2cf8ecb6be36ef422ac15490686e7ecb65ed3d46668cf117da8ae81825b2825048bd861fb4a32594bda826b72245da40c2761b12a8da997b427cb8a21991ae0c785c98d6ed3d2b4bbbd54c14d5c81e95389c28e5222c90dc5a7f0473fbcf698dd9f58b99998dee7f4bd827ef16d313313c615b91e33301a31c953224d99afdfc4d3fbeef18e735d537f11f3032a9b6669cd4e8342d451aac53367e7712855db3cdf821f8d6f1c702df8fa1c5384d6cb9ab0a614a573b0aa139488030f523c38006b5b812d5ff61d44c852044a1a5efda4d02c3c3b6aff4cebab7057de8b4a8b353a49427b9291d508fc74e21e6d4d120f6a24e7e85fb6765a706292a0e4157b73e8746202708a87b48b572c5c9a2bf263a63215814290b8eb22246a5a5c443ea78d0a81a60947b18801526d43f9718d9d8156cc4007ce2f149f9411ea0ec6df7e1856b9908fd6be2166a6b85d10806a4517261a199b5d4f185bd161c6a8843bd3956ad6cce9e8e270cf613858e92f11218ea91ca0c3ff039b04efa192daeab9587ea03d417e8dff92b24bd8c829cd5eccbe7177d2d576838dc8c36162bb04e37f4f09152a12df202adb1d3874a2bf976490cdb41ee577357dc57cf6523b1e21508e239150097bddb45d5bdddfb47d722766852c9ebfc27e9188fb68a1aa850e6ae8beb499a161d39b87be147534c361f07dd109c8e37bb5512ba54a992a35174228a8a219b485328cacb5524b04076b923d8875615d9cbeda993a8db30c656417797db668facf758e5021d19c7a4bbeeab9674635dd12c7081c2ca0e5e68d3cb921a55527e79bcafd80b6961ad63c00bd52fcd5004ee3a9fac8f3946cbbcc591c535db58425da179922e3361efb48caff3da574800c5d9288c84a560c51cfc960cea3ed2340b878660d604d6d1db4ee13050735c889a20e4555bfd9adc8f5213327c2f88f26e0b55edaaf1bf357fe19aa5a8a8639c9fbae876083662f501c6d93ad8bd892bf40d90eb01f3d2d68824c7cc504e8605b84c739d40fb514bea950efb04ed28ecde5e8d1c5098bf028fd5651fc2a1c64b3232b8d8484efc600db4918bff5e81a58bb9d9d3ac95841199c259dc0f97e1dea6b9651f16a42ed8082235c272783310119fcdba23293382235b3a2e73137a8d363dc84b729c16f85461dbba1758f2dde71574526ed7beadf1cf96d1c34874d02418410574a1d77a7cfeaa44e8a05e0607b79e49959c420ae12fd421330203ee1a9f5bbf125624b7e6c0ddffa1050c990c90856589e2ea0b09f2c8c1fe57dca9bdd4c6bb00cbd1e8c75ca135b6d9b93205a18f86e6684a6e72a7a70b70304896e5f69a589dd02d62bef3e7f50e26d113b6a81a1ea2ea43479d3fd7638c2623915890aa51ba26b0bc37be5394b880b6892ac7be35fcc6c6b4c6fb4ad7ea42b6f5cd51ca2d14a3319940382160335e098b5ef3bac22ccd88503b98f62246d5007c851a3139ee3c1c8aa6684a95b12890cf07fd051de0fe117b67220e16ad63624994d79222b5729a284b02f8ba163c144f0b3f4d1c99f21a14a2ae0512fb427ceca08accb6e774da60c6173d1ebf45fca641c56d67dc8455829825a9e57320f61d212db9088db8e8e42cd482dde8f20cf03976b42211259a06458ae45cbacdb62d201ef5d1092e562498e0f64fa230d4a4213990f3f0566efbd217a38fa3ed669f9cf926a0317ed64bfdc4b23e9d8709b78530d7c7a105572b98a01b9ed7fb861a4137a4b58f1bfebae72f1bca4346b2b1824cbe447beadbc0984926a346d16510b3ecdf5343a3c3268095e90c3ed0dfdab3e2067c3dd3eebb03018fff36210d7bc3202d6f47ab361e1a487471583ee124f839384f4bef8d02e0c797a287cccbb18efa139cb695e971c8cdb4cf17bb5d1261cb20ec3cb893e6fa804f503abcea1630e7e70aa88d8dc10a02f3779fc86d571388fe24598639521f265822e93c6ee6d9ef6af6be275dbe2704b3eef0b2456a1042ee84c91c19c2035f8f9149daa26fce2991df522080e77601e6df21e19055948a5301a834afce3227b4f78c0c54a357d33474dfcb9f283dc3bd7ce20f1d1c5a7a9008052a445c3809c27aac27a88201b63e10aea3bbdc1478734d850b79e8ca689daa2de148b145cbd839a1de1ad5b09df4b4c1d3284dc0dde2e851d1a8d43c874b0b9339d1cbd2fad6d525a146bb193be137969af914fb21cd17f9043a9c16bde6799396c1cf07013c48f4927e3e1a0df4a58dd4356960316ae7dff25566c3637c51fab34327afd36dd30bd5d5789894f96fec5b9d5b7a4a3691f59d9238f5e273a397acdfa2398419ad4ca27349ff605eb898437251d9cc33f40b6bcf962e1f954af68dc90956faea46ce0888f322ffaebfcf4a17ac26b17f9f6a0ff55f2efa0ab2cc9e0a45904d99604a31d818c83d8084c388488a2673499e73f3c5fae5b258c888b2b5ddcf2f5749a5f2f2fa9eb78a61648805338768a9f13276c4ec191a77323d8dcf0a5f2f2466e685336ae25298268107bab13f2c7137bec56300f66010509e67fb7aa26421fb24b78de048ddf3d3571d05c4e378431822933155dabecfafd9bb27c1daed27da46c6a9006e23e48e6369e42517b86777b73f18dadbab1b25dc0a8d61870f889f5d8e2f4dedc07d0bf2bc6574cb2bde40eccb69d848f26caf8ea211b16a3740ca6b9e3fd86683647bf38429fcd2b88dc0a164f905fd639ad80c34b76abbc4bfecf580510b005fc536d98b3fa8eeb41fdf62ab2d3d5239b4d4568ad3ae74f2010badf6919c1eab4c949c6b534928e8ed05bdc5cd5073c820cb95cd6736e76f7de2d8dde55dbcf1babfbe00582bfe9391a4d111477580c4dd7bbf85a6a4eb1e4015ede89dd304c2c0180a50068d60004857083089e6fa782f6f2e0d4ecc04d15f510ed2ca3b9e931aa3dc588882df704b60cc8eabd82a07fe0d1b51f05ec21f73f42d3c73efb3bf89524827dd7a65e2af9b9885e36949531e27d74fa5dc9249d66151e1edb4d90942fa64143ddd7d7d24d5f970397dcc1ce04f805dba1661a594051148f0375284cad56e04f186086c508558a362c15d233335dfdfaa8e459008705e57f60049cdd6d04808cb2aabdf72f46f9b1bfcba5b4f1434d5121b4f7264ae8d74c02da53db9cb059bf642c99eb7bf39c560402f62987ab58345fbffc15ba5bb1a22af53d187b458da74cdc14d9c066ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
