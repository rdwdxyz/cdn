<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8021f8e999948ba208fd5c3d88cf859f51928b9935e3134bea3e5175f144a0838546b6d9f35930ad5603980c5de9dda720f89757f98f35680c8bfefc4376c566bb09d25ba1c8eac8dd50d91d049fce76e83cf4a9f062bca5d221b3ddd5c40d494b444af1350c25f71ce13a3771945e0321fc1648c5f26adfaf8caf9bc914c2aa7564bba34346b33f0202e349b10b6f665bef6236561404b3bfa1b0227be259d1f6a3ea0c91859bdac6198548be11cc445475dd7d96baa4320b590c23d69ec3ae857c396c6aa69d932d4b7e8ff2c4a60bf06463024f14120f2d6f1144eb207923c3abf449f6dec025fdf3a690acc06d95228941e45ec25ae943dd69a07204d097546cb53306c0ad1b0206696d992cf65c9cbe37686ccbe469714b14c5972f04b080de1097f28ba6b5f8555aea7028bd36637c27fbb9f5a5747354a5c36db8c971d6d0bc7221a1f3b87b30bec42a0ad3358451bfd0b9bad770a05d7ace6ea37769a0f802d5ee0a5f708ad82ae5213a95c66dad6ea77c7f20976b1e22c57b603684a0bb3cd8c76f0b954f50d4c46fea1d6331403bd01f83ec87ba16b516a9005ee8ce901c8eb34868f85e95353c2b94f0055473b9dea8d4c960f4eb3d4526c16330260611042cb975a8b190dc56fc4ec46b4721d0225406d615c5d50015c82e67b618c2d84de7af9dc43b911ab6b090dc1fe724295cf0d4e504a401eb1b525594fae4b1174e60cd9bbffa5b9a038e9877cb19476a8de52af5e19541c03a1887bb13f41e369e8809ea6c36e9e03b3a1d8fcbc1c8ea23b589f39de71464d2a5b2f7c492694d860632ced2310ce642118e2a51defd69be54bebce6f80871ed361e3355dcea09ec7d285c959c4900082cab13f54f2889dfb68b765763965e51f851f0181db6c1e9f3d22756cc4613ed0a54017f98cfee617b0925032dbb0a62aa2327ca8c44b69cd5908bcfd790b46859c6d805b83867ff1d5e84f6d1db0a00001d877afdead1970a8ec39e061dc4d30a9302eb855a16735ae7032da30c45405e9e4ab5fbb4a8466fce230866b351d27202d256421666bd275427b5bc364e7e747e1ee51da78363732cb54e680d28b8118733d159a8210526571e9d25638b2cc0c24228f4f27b387f99b9e3b7a26ea442b8d389f7330e3e80444a5dc7203e4baa0e253e2fa3857f2e8e4d5ac6a98b7db72065dccd86961c8f517f4ca7f55442e5aa47d73012991ab84cb907aff8e0901ae76d9e0004cc75151b9721721e11d94637110f48bd7ce4af75566f651f3b10523d9e39e1bcdd3cba0fe0c007775ae18deaa310b6f5e7e0f6f1ebceec968d287035c3848bbef09fe10a224a832265427dd0cd440335488d1de78cf79385ecea102d14f260cd3300975ee787f9ff0ff1e81d8346ffaeeb1e6bd9fdd05a293bbd39ad2b80bf05b13708cf97841598a83f7d1919aadfe5f86d8713f90d08f697337dd41a239dace1b43a9b4ffa5b9713cc0766c83468bed15ea5de52a2862a6a726e10e0651ae258f4215c4382e4e2a4506da7c999a3f2ba9d223aaf46960d21502653071a8610443a49da0f005d53bc016aeed31f49de419a85068c8c17ebc80991d9d1e8305eccfe0f071dac89081df2a1028bda496ee92ae83ddf6aa1e94febb5fefb609d58b1a10b6e44120c5ee7a9d7fd72ca63beb6e3833c37548a806408eda1849900f48a6e0adba30d2bca8d806c059b17bcb6fcfa1c0d931838ba3feffd3e46a3e1acbc7b35b8aaa50f3da5829142580602baa65d6f93dc38cbd0b45bd83513917480fd3e6c211ff2de6aa35e7c7cde57d092426d22e201fbb0cd5affb1f6a9e93a04f725b0e5246870f2639fb795dcfa8549f78664be07651986fe73745f45523149c9c9f2fb2e3954d79e12a40bc810f62924a7052169812165ab2bf1dbcbbb2628294f29611ba57e74425c003294be69417eef7c6b5e51ae27c4bc6b001f2dd6715988b4236835d05a9a4bb96cdd643f33a6a9916a62b8b278b5c66204866d28150842e5a77dac6b09867f3be79643e230085791cc0b980bdde7eff6124538c908d1a98a25f758ceaadb44ee121d5184b926140af56c0c7d7d12313663603f190c63334f6e9daa63619e7b0b10e1aa10e9dabf84a05bd11ffd76b4e1f42ab882c11667dac6e24484f3c3eefcd7ff6bcad7fa0a11ca03593eebc6a3d2859c414564d486ed70a22dc1d6a76faf200edd246c9593e6a88f8fbc5d138b1d4695310ca07b77789808d9874c217660204b0a67d47155f59f85f88727292fc3c5078f9020c9e682e44d01e6a91e0f3e8d5d512b3b99e61b07b11fb2f2874515d32b6bd9cabc810e975425194d465fbc4a986eb99b0ee372969fa7242e50de910cc855d3e0a6f0c09025622074bdadec6cca6d0caa20165828c4cdd0a681e76a2aa0f8bebdde978698648b68b830c9f2d3ee684dd6b5cf203530491937391eae927163171adb32b6b53c0a6072b989be5f4206f043efbea9f93da2a6d9ced8b05de361afe5935c08cb9b1f3e04071f9d458890dcd734ee85299fe1790fbb597e40b6c77f96785afa57beee169cb463e087d282d5b4feb71a919750cffd0b0cc396b033900699bf2a0ace82baeaa19e313b1a0635f8d522cc2ea8859f684ab1b0ba85c5cb1a166f59d4bec5145eb74979ba49211eeacdd894188cb0594b22fe0750cbf6690a4860a13d2e6d30709b6738983cd9cd8d8dd7196a138d46dbfacef547aec28dda39ef13cb850760fb85b9376c11d5f6954bbe498058d16f9610f9c2b4645158fa1f30f5c6e5e151199dcc8dcc00f3fb943416bfc3e04eff78edc0bb0dc660417a68590bcbbc5167c5792190e16c96530f57a0bcbae18d09bde25f107189dea195e279151400015f62571feafdd30b2f6b2b43da529e1107ebde60517a6a42c055ab9f312ac62d0ba5848abc07fcc08ed1a7c8c0b3017090752d6e966d7bbbe29f50ba327a6365d18a0bbe002434a90ddc8d2bb7220b6a4dbc8d9a4f1eff87d4b548ef0f4ff1b2ea3a29e4c4f6502c5e5399ea4190591fbbac34dad577a9b832a2c3c5e16feb7b297fa24e1b0bccc1a7a3e113512cd680f61c6c24d93462e6d4a3afcd9f44d6eb44b31a35f9b264321204a346a970ee0b52a2d8b7bdc294306db88fa7459f71e63ac819b2d60eca2592f777a4930df547f38b899e611f34118e551b897f23f86d1f5dd2d2c240c3da32d230916ff86b9a06d00f6986c84b5619a5b0ae364331148d95caa221df0d502e5e200fe7cbb94528ba6249c92ad7f9f83fc7f5304457742b4d63e3e47e666d6f1a55193df9f74239483b8ba3d5c5f28fc393a0eefd684e3bd888e145b66fb16570a28e5f2bf32e9e3a8519bd76252b094eacc3ab74f65abf56d7bbcaf0886480db7a23ae494a860bb728ce3931a5b09c8d059cffabcf38af17640eef3b4599ab42d3f24719946767e2e01f9344f5e1a3b193cd19a5a74313d1f8609616ce0d73747d94db87bc8b40856790fb78fab4f4207cf39463e9fbe039129241b28877e83382c77f6afdb8391fcdddc09a85aaf59bcb503af96c50d892c816f35f24023a9f868ec8c2c097ba52954c7bf7c53ad2110fcd4c8a35df5529417824776611add21e46c3dde23791d7c782abc24e2556b9b5ff5a1edf53b14a4535ae47b3f30d0dbcb60726a8b98b80aafb5fd5832e45f7be0d6ccd23e245c08f1c010b16c9cd1e382cff0ef4845920783cbaa5394629b92d3c37bacd4e6ba470940969388a1899b62f078ce5d8776774792775086c8b503f09901b8a7a6246e7b4e5514ccd9a73266e89ce947fb9962903762f6b28356d5a3f494a3d628091067e3ba350bb0decc78c86cc7e2a015c83cf27f0cfae403afd00c73145756ec4dc4f4d9decba9e2db961079dae22b9f3674ecab0645be38bd70839ce52ca620913f51f044c04ab6be722d252f49d181de9f03dc85767a83aeabe18190dcf1dafdbd8faf12d01f14d029c3d4f79b5125ee50744ef59fd946f91c661083c2e37fad2ed301c62e9d1a8d63efcbb8b6d1436ab634e2234df072c18dc79bc837c2b64a9666f1e3ec25f912880daf5e0b22cd7fd3000b63b4a1fd8bef8f1171ddbcc24ae4487d1667dbb68fdd21f20e0a62626943420da3fa5a2eb21ead18d5107734483b9be778773a055ad16564203438124df03aa4027a214eb5c5da60872ec04b6c795dfa8b03820cbc17e8b1b3290f4e2dd0255daaae5e4661e0e2cd59fc292a825c3f3e636feb5fa091bc3f4b7a78fceffe5cdda16b7ad88acb7801fcf2d26c3cec3841a7199eb8089f23a5ac42468eb84eb4cebcbea74fd13f7d5b3645abe9550b7c7cac4d8826b86b1f507f86b78dd6fc820b75e61ebff33225ad527173cac3c37d0df69fe2a37e48e4e95a886be6f24b880754aeea12a9f6cd075bf06cd42632b54b16c13dcaf9b570c581bed601cd6976463600cc953af40ef02cb3ced43bc4d5ac967e64ef841922b4e4d35a868ee68602ab6326dbc8b2d898469bad38fc30e604bc4af070812f6bdda34a7cee2474d321ef47b73b6cd2268d99384f0a202a4fa6666adc5a3f145fe4d9435142c5f99b83d19228a9eb3de5073e244c1fb6b502e9455a576ce214407470252d164a3d1d7fd73e08b2fbb1d3ef7f04260f0d8aba906b7d3930c973f8b869cf206e350e2cd6a7ef902c4ddeddb706836cfe6b5438949730512e1c32bb1da0357e33159a6c343856f2e1b3a196725702e2a9e6cd1e567e60f06731611f3eaf6284f8b8bbc72b98bd84a39f9db8dc3ff4a87353325e9adbd271b48eb68b4e260b12eb4f2009655f50b82727bad9dfcaef8cec08b13046bf26335266599c6f9869a8e731c6393f8e84a9d1d9dd89d439b6d82ddae343fc6bf4216720d2a470c032ac7981804ee448b43809552ecddbee167761a7017d658849c0938d51577d7354d9f9e28184831153d5b785942e41e85a57b8de0414be810b1c3bf96bbdbc835c84244911f707682c6337f48b86878e2c17c58939421173a6209504b9a65ae394c31b18542e0c58f2d61f954cd01048d9da3bf86d1d3a9143466f8e7ab40211e8086792a973d64e98d57fc471f0c21ca0101d4ae2e142e5ff2d0e2e47fc6f92666277c3d73e0e73077408ea44a9024d1497c224cd06dffc6092accb3d6a40ae7671ae986769ac6931b0c6c7bfdafb49719cd9aa064d8947ba260d3e2762b960c5434c4cc0831f9d75e93e196b748c0e041708d99c6880d441009c9dda9e23f426cd16626250880d9d199694dd0eb294de200a1f6390fc3c3591724c45ee2f5dd8dd48946aa1ec6632e093bf194845886047c4df58bbe7a1b24dbd498bd9194033559fe908a992229aae1c01c634ed4d8fe38d9a2ceb76bf760b6074d39524039e1b362fceb9ae7354f3a635c7da60d5ea1260468db44df121b2593b8764ebaa6f77c36bc5d6037ec083e49a3a077a1d2d9bc0375af1605acd33b19bdcc6e6f81d4890be5e6f7ca0ec5407b5ec917bbd8b94d0bc159aef4a61697177d295e367f00f8de27afbbe7f363b17a1d899805184a2ab9966e53e670331a8dd7ed4c9d210c877cee21cf66a1e909a83a7c8f5831700046f0b12e21eaa5c751d6f7265b29093f859d660cb55d6db6c037abf379f5494a90bfaa3d5f69efab84bdb119a2d41fe10febba32dc3f164e2d5417d7643d1496202c96310829ce9bb46c85ecfcf22d8516cd6cf587ca22bef6a5bddc1653a7ccb6757bb393f35be54f9ea1c78e8f664159606161cda39c5b320e072818534267c3cc497e9d6dc21ab37a1a8935bb77bcbab33c9d4409ce12dda20baa4cd0535c72f91d9bf8fccc507ba0071005a7b2594005d5ddfe2eecea843dda43281260f0f2127305d50d20e8b3f477bd84ee9dd52ef759272ee2892b3d4948703bfeff2688e204d0ba1cc955eee8fe7bc4bd8fc5ef33904b28b9fc065b82733db30fb7cc14b323e1e355cc3db7140d651e0548f982d0d6eb0107fdbdc8cf88fe455c4d548b9d0c1700d34b5ab58f8b760b96bb60fad337bbeff190f6d6c7284a6ddf9ffd1f0fd1d346ce5ae5bed1822a1083c46f4111c66c6496f44e2b55119d967cfaae7515e568fd0d0dee791422293480a7a4a27c32f08116856c69187cbe9de7e91a92efb08d179bbb74d615c6ee3a32bb6e73157e13737013b7646746335cdbc0bc6cd94680a05c55e0d0863ce8a1c3a9643214d1c8668e5ff4ab1fe54ac4618bb59278881b5ad514f711e919721f33a9a64bd09053ad107b20949362eb8176e4deb32293f9a645d29e93c45338af898d55bb3ef8aa814ec8f8108b647978ea339fc1ce744f242e8bfe2feffa41fa444c253862b26c119d371e4825af056a96faf90c65fcf52279a2d8ee1788c30bd63058df1a41a90e027a80d2a1ed4927d58a80912a685606a8a246fd7e53468db07b0800a01ed1fc507723f4b364e6ac959011d4c78fa2a14639b8addf5b5389d82f809f9ca8c5494ddd986d6fdc4b72de91dd2c088fdbc055d91ab1d2c99b83e2bb77e27f6e5ff6d6ecabba231edb50effa186ad8338988b9baa92202d9d877746c38d0a2dc6f80464dfea3f130aac25e72d398873cffb676bfb1261ac02cade077621685b3a8670007020d4dbf33353ccab88e4d5801c620c55864480644c0c4f06ba9a66c1dc8cb2a49068e8697f04d2f4320ccc59fe09eb2e3c34b66030b0cef71beae61f191c8ca133220db2cfc3a79a5a66f40bf41769236e42316512b336464a01d301517cf34adb0796172c62eee4287a06a8c592bdcf005668fb0d69af38c90cc2f822f82b06c7f9ae582e894361ddba40af3736662ebfeca4c83d7442928442c8bfc4b73f4856a5d446b366de050b4bc04668f7a166f3311d5e00c3ae40534a203ab6f359261dc68630bdeb58be6781297a1a13df1a71c35e6227bc6c47593b8913c7107c7e550f0824731780909df8aa8b18bb58d4e608e0f786370152ebf26c53c32387d268b5442423ce745babedec71f2ace24d396a8fdf9cb2d165ec7d4812f8aac5921c1abe54770096be06d512fa6319b295981098fe1de3f344c7c3d49867210835c69c38266ab60af125e3eaf82db1c379f2cc1940f3527b5bc83ec9acb7640ee04daa2ceb40965de4d447bbdef9d4ea03cb3e1fe1673caad7cb354f404098094fc4ea8cbe1ab7c6b0acba5bcf275534a565ba6077b6bcaab00251288a6a234f2a6569f0d3736f1b4a3aad07d8fa4535a24324a7b6c41e2f7d1eadb9f44780664eedfcb5c619cc3f03fd6b6adbdde8ec636afd78ce59e07e444dd6e915ceefb19d0129498ddb1d580fc248c5c08a05c32dfd10b77230fbeccd464435c046fe6f3b372262b46b6968b5c0cf602e3ae20344776a8f87dd83a7353033c1f652a978756dd9ba78491f558bf1d455184738b3967e8d98e63a0ade0ad23b3ee16c29d48c2cd7a2b21d7c5145c5df465095294027c802890acf7099d0cac1c48d549eb2b3dbe80b0a78c82b30e2616a4bb183684e7706bd535c7d58174eed9719cdb278ef6c81143d5b132d77b46b2b9beee34304b2efa47aaa37b6796a62f8d55fc5678ba46680149fea613e5eaf6bfd228693f0074e7c843975362a2c90a7b7608f3d83493a1ad389e4e0940ac217f32fc2bc5bc658642b50629461bc3e782e66cd3ffb45148335c4b4ca16ab4e289d8e265e2cde3b5b484d0df384f372823ead4e7cc33c86f65f6ce66d973265433c09aa062f096314ca6f4ce2de54caa9c239eb1a41ea940f2d1e46954830265bee91e202b431434d2a555230972e84110e3dd947231cde7a18e01457e6b734722ed30484d211bfa3a8ae3da5b78245ea05d48eea101d33cb0dee9104e2f3430f43f99146ad8b18872dd8922ed752a3521ae8fe415ffd3f318b7534ff7439781f4a93edeef65c7a25e70e142a61efe1167f5d041d2ce065b1b1a61fae3356f86e53002675dd754fe730af89e28a9f652e0e5fde29fb2daa90abeaa6c25086fb1267c70342f73bccaa31a6c56b09577c22f4d6a27c5b13b45502cde591590eaa0f8bd1ae621da7e880e7ffa28d0a4cad62ba5948f122ce0ae6b91042678416ff51234f02cc0afc5e7c825a93452a222b3f975fa4d98c70d3385480ea892c47aaf83c5fc08893b83247a1be76195a1e53fb12e5f9c3ca5d1fbedff024791c59108ed46f9a3fe70b6ba09f72464dcd55a3392273515709728f4efcedc65434295774e2ff86c69a97026d0241b2a18aafa00c47eb19c9d930298cadedde4d03b7ccc3c2d9523d305960f23e2dbc5094f11486688dd95c9131ed9312ade4d706d1819472bffac17ddeefd2231659749fcbcb6e2da5be8f40496253a0fcdbb197c94e59c221e9a422e27452f24d08f50143daed33330cb4039a950f118007994d07557b7138d0232ca0c23718c2f2d5da058ee1a538f2913829ecb0a474035f0bdc99d4469116a4a7e6641e4ef8b642445001545b953458c8b17a421a52aacefef54db884f14b46c1a443cdb08243ace4af5b3f8e6986675109bcf7e5aa31650441b806730a029537d4a739c7df64ef4f2532e25457f3179eab4c516e125b931ad76d52e25ea502997ef415e46a1c0d3c09177f3e55afe370586e79a6316fe55cd141846bf82cec6f7083070391efe4e0cb35f55a7eb6977ee2dc47d08f81a429522b6889d234dca326ebfa0cc11da85fc542bf3fc0a40555cc975c582ddcaf3065f1d7a79ce10b2ee1ef3c7cab485e1366a81bd938f78fe35811a24d7a1cf9ef86797df3ddaf0041ac3ef46fff14bedd7c528ea268d8d1a8c5914ec10ad1c4fc77e3cfc0e3040533d5321037bbd86f6bb4e0a0b0bc7193824cc32f8261112c2653f1ec4578b33317ccca08a2cb4339b0a9477f20488b0fa25b00b670d3ff9c8575b358bf44c590a830debffe7aba8b828003fa4fd218315ce7e8f894a25a496cc59bccdfc805bd210a338ffb391e22c3f2042c95c6f720c20b42219e150ea29839d522b3a29138fa88502be44cd0ecebdb9a742ebd9e14353917d1d79aff98752e47137b65cad076f1c4201fc8fc73ef38b66f9c137810e1189e7b7df30aef72216f400862280d89b50fadbef0c738fd4aa1eb1a9bb2591db07bb952330055139246a10d3bfff26b416a7fb178c842c66faf77ba00366441822318752bd45ec4d0726f0780aab1fb567cb4ade27ca9c0eea1ba5e6a06d6a622372c01e76fc17e91e79e1779b700c6973271227817791051b0aae39b6183295a9bc3825e3f71c3208c148ab30fe085be1c4fe6afeac62f0607ed38bf88432406a55e8318253ea4dd9d9a79c411dd093f7b032dd90418c986d33eae5cba949e0f495347ee52e75673dcea589e0e1137f4c6eabd78f40e2369b8dd970d255ad0aadc81277f50a202e04eae1fa0e61407630ecf87bd3fa763b65c6eb885e3a95e63311fbc7b4be0081a25a72380de161ff325130fd9df43fa19c7e3fa45144a5b20d6937568a264e80616b1320f6afd6b5555619231c0686aab3831c56f0a3bf9057f408183df04f5d75233adb689cc178d9bb6c34cc527b8e598dea785b907aab2fcfdf76ed34a20202987417d983226d05c7f82bbb3ff98a5f77b1df190ff8b23c7c89f6d22b14603229c1d655cdad5cdf79b66453bad31cf7e850789a789df2a4542a6e7c3d0f938bbe1012104581e26f28f32c5b96d63554847304aad4fd74a7e21cb436e8f370f99eecc1f2b9d086b18d5dd55d631055b85ce09b5a6461fa95860a48b96fda920765513b248e5bd0c5955ac544d3ec91352392976aa519f44be4a74b3a6ac0e0ac94b4d165e8917527acbc92048716b5f0447dbc715208702787fe1ff0a090de679b082cc2ee658df1d03ee7b00e0d9e76a9e5f7423080a59298a0e13df1f3db2807a4292a614e319e18fd6dc5f56068fb4717a937795d908308cd5a6e2ca56fb1017a9619bbf98d85c48e5ef1b98cab01bd56e72ebefe5424c28f2f5e4adfcd65f3f0f6f5decb2b541cb00932793cb205fb095140ce80ff74ebe7e4171b6c60a1d340912e6925f3fc68f11ec821818be8d0e9f19ceef33bbc54df48252ccbc0b7efd154dc5a758026aeb95484fd852dbb9ea6ab3339464d3b4b699f44dde353d536c507e165e26dd5315f9123fe2f2ed70d29ef0eab846144c5c67dfb2debebedb5c6c382f5a13c90f549f4d6e44c3777abe2fdb22e04ff57584cd57de0a78cd46558b7459ed781ece4233921c653c571798f1f981bfc4beab11a2cd660f2a10fa88113863509d9bbac1d594065d2061742b2af658c0d992bf67af965df6b1672b807e45e55bd75c9a217af13f3e3a201463969e6d61b567bf6774af6606153a0c1d37bb64412e676c4b0b162d19f865fcc3f4ad49395efa69e90cbafdeb979e225d5b5be166e630f3501845ffe7b5b6dc059f041555e97f57e566ac48891b7d61426a4591d4912ab8daf0a888980da0acf23130e1ccfadc0e1466e74dee16f928b241197a2b3f2f7c73035065130d12756b9303a40e7b88195f76b5030b874ffd0a7fcee4be3825736292cb8c0b4c9ca28af42dc400eb33a4f4d3e6b013ff06013915bb480fbb28f40faf468d7f7fc08ac63066065d01a4a29d67943b3aa642eaa11ca07149b82aed1c8bbaa19fcd686f8519144f4e0a6cb37932d9a52384aa5e3554d52c412fca880a95dc1fbf77a6c9a0cc21eb42bba65335b580c0a0e254d1e56aca380139052abdf510885ddf29b984ee5b9995d11c3bf315df4484357bc20708e790fd5308f99b0fdde81df9b1fcbaf9b81503a355c83cb666e3ffa9e452c6ed4f492a211c6bcebd0feca7d2d35de5410e748b68840284aee49728422df29865ad37b9c20e41c6ff882258c9120bc153f0309e0f6a842c72ee15ca776b04847f273990ec3cf4fde7de4f5113844e5454ffa6739be7389bb464ef75b075b98ccc3ec52c9593c7c06f7514f3f9e7999e469664dfc29e65b81732f31e8e1cd6a5a4bf252ad8889ef4a8282ae46b7bf616a655c5003c6f6f36144c0aecfa66ff2455492494f34ed6df1fc89e1d77cd615670c638e24c8f662a68d49f11c2c1fb9b78736b552569833d76d90a544794ce6827cb2d3ca37e352b25f3d0c17e61e80a46e68ed5879e83fadadc0c37319a25a1ff818338a862b6335b1f48e0f32c39b2801a53055983c272a0d06e894ac42bf2f5dacb56d3b829d20e569c6655b1e14f969255c4ab498a7d64453a828afe48aa99cefcc16cb7d7e70fe78c4950f48e7e146b674a6026e4129c869345362897f29fca11a82c37e520d98b97497e9ef7c38be5e9d001735783b758201eea8a0b372db29b69455567b2f048ab65dde0475fc33112cb8ae99fb8e537715a3f0fad08ca5b153c38e85a969235ebdaaca29ce5e5179fbdb0c6c4e2b29009231890c57b165d718552ba2056bbf2e18d7af432cea4b1f48f8c3111c0964bacf9772be9e5023400783ef965e6d257e131e5ba38882c27b199a9b498c95164c991fe4859c3533489faf7f0490c0490b5143536c49273678c690d3ac97c78d81aa60187a5f9e35bb9c4435190075404f33106dff8c984971c93b9e09e183882a856e342af5a09f8e71fab982610a6f512edaad48cca7eb81752681a5ddfea76a9f882041dd4d940084763ed99e0422bdfeb249ef5d746461d4417dd3aeb7bc726049a83ad9e5d7faa4e236b20451ca4b5155f851c08d6b509d6ad5a90882d88f396eb8a960f53bff76765da7eb84badb8e0b2e6ae0ba6bd9b78e59f11e82f5cadd8e4d046eb484fd2ff08e031b8ab6d0c30fc28bbaa1d901c28722d3f089beb1d8bd330c317cd22512ee17116b9a5cef3622ac47ddf9384e20f3800f420dfb07aa8c1aa44d82c8a0d47f2e4c798cfb97c217eab9175883342b638d871f1c0a76c3c857d605d38c7bc73a59864adb6204fe6924c03e481e6894dec5be5914d822f1e83c17bb56548f8aa380e296d9884fa9fd181f9ba49abcc806ec40259b8ad1f2384d41f6b97797717dcf9c119aca6e0f1bbf50bd293c2ef2c843a0910161d545413dc14400a4ab328a048d9d1398a2912001036bbc809a0638f21782c559135be93419decc3a5d748ec30e29bdea0a0d4c88dfa7f31a9e5d6d12dc92a09f62c830d279c82907c33bfd07b8ac40f8386de97871f7b453002c8fb7bc4af46a1b247bae3c7b2e10cec5722eec3e5279b060ab30f9e5d1e78ae2c8e4a7bbaec25ced6bbc2ebc03f37fb6401644a099ab7fc6be7ea54f25e4a3c3632615921a6dcd90454c560f25c3c9e96c0e0159ecca533421a20362e11e02031833f696bc815660ae7c428f17391e14108b3cfc32dbcf646355b1a3dc0ec78391b1d017a6e3c76ce916e186c88cf84888793cad70954a3594ef51c95f835a5e391cf6a6b3b66e576dd4df51b0a3f0c3f701faf78e39330cd902c8acfeb981dda8e209afce288c01beade3c390a5be32929b04f2d2a781dfa6f6657087581b4949f5c66e31c4f6670eb0bc559308b0f578599bcbe2737f1c0504a6f91ce8faab5a3d4aeb680143ba98611f049c807dfced07d1955344dd0db2e1aacdc59e3066f7250e7df0764036747f86926d9eaf0e1d1c3cecb891d130ab869bb855177860cc5535611e1943184fd5e9a4deb71bc924639144f1ad6b1e64323b59652a8577174c8742e9809a1720d3d722fb54448efb634d619ec13bdc8dfe404fbffe9d33468229a3430c0da11a646834695420952311234ea5fdb5c93e42951cfe792debfef1567ab6208c61909b8ec65641440a5d8292d5fa8b135ca28d1cf29d24a21d16607e0045043ebd710dad27b97c96b97e9bca6b00185323d5ce2965270d12112e2a01c0e8082abab645195528dfecfe89e3a081e891eadde98cbdb5dff6cdf25f306a27a466a3e6dcded91cdb772a80148cb3638ac84cf08e8c4fa50c4510ff2d7b7292c460f5e20f5c8bdeef11e7fe5dcd41325707622da50b40f7bfe89fbfddfc7fc0a5cbffe17eae1b3f517ff3c05bbdac48b8a01d4d2373557ca8fdaefe0b686fd8d05b364f535e3b1c634c6716e2322d32d8f3e9b79cc77d928f1947c02944cf5c9b52444dff26793c4a9f6d692ce1d132a7661f84304f7f31e97efa07e219ba4efee491d01b9082956d49d62fa4bd31103a7a3f5d2acd177c2c0047da699ef3e49c3bcf2b60d7c6145db2aefe74a5d2dba962e5fd06a09f9af4ed98527082ae0948b27972a0482be77fa6da6b0829941414e41625aa9e7a3a6ba370631a8d45d2c08312cf43834e5e416f64050273ee2c21aedac8e5caf3c2e1d480cd0eeeb228ec4427644f5e1d2863596559dd50e45cd414941378990011e3857e8a46b211ea563d6edc11f43f36ba51db60c54c284272cff1f6a2579daaa25a4e07090faae1b8eba27c9d55fdb77488cde66a19571216ac81e45e33b694e08728d1c9b10ebbda48e93eca98e6b42f842e879550b8f924cb52b30aeeab4663e2e430c6c5c387c3fd21a68308b4a66557c8893c36e834d051de3dda0cb39e791ece8aa1114cd62f57781dc940212b5276b867ec29351787926829b684e499406817caf4cfcedb9157a53dd32cb8c954ae196aa64f5d5936433c0a7c4f7c837421d3fe9b3c133838800b856ede7543abb46ec1b966462598e2ba489de23874e771b2cbd0dc7fb992addd4b637ccd0e81ac68afae0dc992385406aa949e96e303e266283b6aa8fdff2a11052183dbf06aec368211489d7796b92ba8dbdb067c1bd3d36355214d8c520841a298c4e60fc4f22a1c8eaa64ecd6169a1ba8312bddd693ad57d9da2e87afc0052e0db64dd1f8b0c14ac89ea717473e7d1f92ea02243c1670407e182264c5b15ff702231166643542ad5591c4ffa30265f993b53f9782b45e0b0ed170f8d9900677687812e5f353685b414d5e673657d4390ed4b4177e31645cfcb4958ce303a118862f3ff2adb50fe8d825e6aa4f68e7c3e9df3cc684a8b301a24ad6fdcd85e6b357519b4ae32c9fcfde2d956d4215a65feb4420080355284637d158dfcd68b4febdb91c5f04be1aa3ed0dd6d93d5120f8d5289c383c26dec4eb829b965642cd7a0c3d5acf0b7faadbc0ea03a770feba52b4b545508ded967326b150013a8cc803d0bda8aee9afcf96ce221986d3a4e9fe7123c52f2345708a57c17e01365b52b59742e847a86895870fd51ceb831993cc755460fd6ab16c4a0e25a649affe5d419a0983b41e7b40189b2fca1e69a4ef34e3ff8b823ceb95f29091293d246a7cce71d4e26d65200b3d3abf3297b162cc8bcbe48cc187e490d08f8fa12541714d3fc89eb38c8c9ffe157a78f8d3923aa37b092e4ef40bba7d1e0e619d0d490f67575ca4710537c6e1e79a4abf01a8acdd7df6df8522d75736ecc91dd3eccb93e2d2867d30b5da02ef37174ba114b421b850416bf136f9aed82b778072a22896cd5e179c31f5e7de181a227b7514a7ff2c0dc2c7f465018ec885be3f5b1254651549016769b68b700cf507354e70f1195b60a54e78d837ab0b76982b79adc60101798dd60958cfc0f724bed98f043507174423aecc05d71cda0d988dc926ef75745bb7dc5558d4cd9ecc45fd55c400a99a09ff5f7e6763cd220924e0a096fe3c0fbd5d37623a68e6093a309e565625e7c4bdbe5fe2bbc852a4b5630b83f6f284a673e53b7f792df4b7cba2ea10dea4d804498da4df4f1bae27886c46f649550d9c332d32a942180d4784eab4bc98147060e3e2f2769ce79548d22d506fd617dd557fd3c409f9305583905aa9d5645977f8ec15e69d261f7fb43ebefa063080aceb84ad3efcf5db63b5e6fc9d56349bc39faf917fdfaa4f91e4908f27b8066655e51178f31514c17e80882a3bf73ade1082859960926d0c9a0b4bc9de8d717a6378adce5eb311ccc243d26f76aecbd9ab4a366ac603be4adf36b774d3bb9cb00ea887350eab68f2f9ffbfe7cf2c1dab28bef0055e22c2325759aa8e07b66dfbf192f826b6cfb4c3758133cb1cf44d3defb25ebe4b9bc477ad27f86e7f0e408154864eb42083b8e78408551ed1f30f8045a7e489997cffe5085bc13a5cfbe9c07df0fae0007d732962fb27b514ea52a189722c73b7379443be969d2e5ff31b31f70692405a074a925e0153d13abf4ec0f4bfff5b5dfe496bd5ac7ae53ae54edfaf8206884d624a5c53eade617cbc02ff868a97eca370e7139abda44fbffc97067d985f34e2e12e0073573108aff26d30504006a9b7ab783e0f26d25e9627ec914ffe29092f6b4843b35d3a270329e7be793a80b2216fffb85239b5e7726bee5f76c3eaa725e4e7f8f52748c658ba03f0b92624ce21c36234c78dedae44bac51f36ae6bf04e7531d65ea55d47170a7ef2c6b82903b9afc4eda03a5274f828bbaf665b69f05cc32f0da2203d8635e7d41d5ed3d4d5e6bec9b085e1d5bda69dff1feb8d49e782883b6bc77854b8686c0a68e42ddf5bf91932e7271e31b487fd5ab9b090f69bd2880aefcc510e518387e82d4c9e9f3bb4f989e2254d68cbe57d21706faef60b2b71c01a15b1adee2c8ddc7cbf82a726a3fa593705214d77478f17c54c53b56990ac73fc9567b90ebe24100abe05c0da6d81a874ad10342cde904eeb6d1ec4878cbc56d72faddcf7feaf0761616f35276551ae64980573771b040fb41746140a7951cda7d3252fed8b401ca0a114d306a772a544722c567127b993672e4cd1bc4f7f65dc6abb67a7caf55e22770deea60dc0b44b0ccf2fefcb3fe7091124dacda2f70ee4bc6ca9f90ffe81daa908ec4384e0ac4555601c1088e717db1dd25c850fbe5a424d6a960913fdc952c12155a40ce454a8ca5b758d0b2f9bfc1b499f700f56b41777ef683be92c1cab37727770bc6e47a69abd719b0a1a9cb4099be1f983a51f2001b4d3bf1c9f9edec12517ac13e268346e52d124fe8d1dcc337982bf01de2e1a514ff361131c20ee7c57f92c326aa98cb378f4a60af82a6ade774c0435532a3a4db426be34ab0ce5bc077a2e28c5f4a6d94a7a4fb17f97d3caf89528cbbb2d4df2404be970a70d78775ca44488ebd87e9e43c250e15c84a4ccc22be340c73ac82745faf11d90bf63be1f6e246b481015b25de9bbe6d09f011cbc187c4d80e2139be4015db5fb79990a218aef1a582ca6d04e93e089b83aa32ffd8307996e76ec981c2c7eb23450545c17ff91b11f3500296aeaee60289025b5afef40d9f63c79d751d2c240afb5a37f8c69374f2eafb7922e6b0038c762eba6378969eadbf6476046b75e5151ec1ceb177ca6e5299153fcb867a2781de8a8750d23a27b7c72b2cb422d69eb3399e75ace8f4bc04b4046856267678c3d9946f25fe124801ba84f4c34ccec04c0e9af49189defbae073410a87f5510b7061b8c8784d18e7bce76d396e3136e1d1b2c8e2ca28f87b01cfa442add981f3453ee486fa92f183114dbc943a8fdcab0d78ffa6f74b1289418c1b50ff63c69ac36ed55a50ed21ba119e9c744932b9dffdc87fdf969584a7474b33c799437dfa84026c94f957b1a2e6d747ff42422c18191a824842aeb827e9a489dfc27c1542028e66e9aff6b7bb04e0d35acbfda501587aa33014bc928b5b1adc01208b3576872553660a51431d20bbe2c4a825b4525451d0cd911111b3123816b588d395005c88566b93dec09703b51e94f01c35c21308c4e0ee24fabebc2eac0415812582db05e08354409d849ad3262f6877cf32cfad7e740f5dc34e78c2bb5625c9eb771d3922bdf9995df15dddf1bf462ea17c5c3c007b692a333e749ef11044fe829db32a23af743803a37d1f110a0a7ac49b62757ef3d86fdadba6be61bbefac84467fd3b66eea2046896d39b08a74454d8eaa59c929dba315d7e87cd2e2a0237e4958b9ab768dd7fbd4afe6490309276a6170c4fcfed3bc55f4f9bcdafd026aeff724f92ee74847b66d4f812b4d2b4fd58ec1824508f1b393487b271fbd8d250948ab24e2c3507afff41abc64528e63a05f66378093c399d553bc18955f220d90e219b02b6df269aa2b330dfd7a36dfcca2b585d93f601abfa8157c0089ae891787ac80a76a082805db5f280efe910ca7a5ce9e614443fa6978d587fbc577eb93b35133913eed422db8d067cdae9b7b41960ee14b46c877a7fe5aa2f6b1167441cefc3fef904f869c6297b991a0231eb7acd4fe769a2b8e6f771522afc56b81b35a3ef13d6c132bb32604ca9061be22454a797dcbfb4bd9fe5b07d6d872fbf481aa5a8f847542978ee46a4034bc3aa1f613db7738b2ed35caeed21f726e2f7cc05981a60ee050330aba90497afd76a78bd39aa3caeb7e742439e7c1954056fd04194359d9064a4d9ccb469ceb81e2d64ff89eabd56fb6e81977e42ed5a66e3c1f88a3656dce98eb8c7e4e006aa8594f6bb1487f4bcad9661d13e2365156f57b022d7136aed0e81f0d3f40e594f740b0b80a7ae202cc49b724a31d4366b91631b0f118b8b90a33fc26364678653a6cd612afd3fdb0e1673dd5cca7ae1dca08c2f1342a5c0d3b8f8cd5335ebbe5e8b909836a9602b82140c3a14d7ef405095af5b9da2868df1e4b84f402309996cb2b0418df3453568582c05dbd1a8e415ce09c70b7f9d514ccd3d78a2382fe8ffb136cfee8df93a2ed7eb6d57b07fd8308c434ecfe533950dc68175cb4910c213e6755c2e640cc11bc5f00a8601c58ad6d7ecdc5bf0523d59c7f0e1526bb7d9947b60ab1457f6fcead681a04d0fd5334984bc5ba9b9d7cf704d1f0aa0804b30e42db985f42d4151f302da635a42456dd472683717209d8133df5a5ebe39e75f57cbdb00aa33c2df5a2f41cfc8ac486e59b5215417f9b7238f806e5f3006ab58ab6bc0466d08675fbe78d13f75e7ba5d735cda40d062b403aa5cda1902b627834b2a5aef47e40be1e30de72e607d56ea80a26adf72f139498376d6d9b2085684b748bdf971fe94b2d3b9a2ead74fa007853b8d83cbce2e44f1958a87313af7f9811237a98168606cc488907488de49d88e74ca16a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
