<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"081bc30705eced6b5a950acc571673cbd76605bbe3894a61fcecd5244194d135c8dbea593527485d2d30556e30cdecb0a220da8b2ddba54b8447bb2faab74cbcea5a74b1b8b5282218ce1684c16213a34f78081ce4dad886d9e01c139f464df780c297ca752cf08adef4a329b61b9ee9faeca30654cc42c2531f917b61652a2c8d720adeb3f842bd45cd0ac51a3f7097323653984294acc787fca4d55f3dce9da4cc3f341c3d6f05238cc4c456253c142651ce4145c96d9778014c70a2546ca352024f1ba39a9dd72a30d1d55aa4e7d65f6e4db04f51ea4d077bbc2d3d012e04cbbd5fcbefa08fd19b2eecc8cedc675b96bd98732af7e6e482822866ad3a8a3f7b6ca7ce03e822eff040347c20a2ada76dc3a7e7fc66301d799fe619665d3d8dbbbe97461b3d8bdbd62658cd741d0fdcd1c2949981a325a86e55fb4641caef6506b27df1f0a9995bac457cd6538bf743e6e3889eff20f7a794b1533d0d8a4c252296ffcebb7bf0b1cb9ab1515deecb015ae57692cf4232ec0daf47525105d1548e59095b4c6b395577d965cac059381eba8050ac374e139d6908febe393fb316c3da9ef05e8da284080c75380b16691e16fcc5848eb9794d20564fd55cd5216087ee7c394d5939f1e2dc069f1d221cdb9f6c24d7a988a35b883adb5c55f7d5364394555ddd766c1bac8d302320ecd4a776712b5b746f5f942fb81814dd70f835ec0da7d26cf2ec49aad8a38245f28dc2c9533dc1cb2fe93a9304a852728e01862ae7c8b2d791fe1a4a701d325c71c908ae15d3bd634ef68f83b92473f78f3eb64984fda4bd198758036cb7f218ddd874735a748042e7d24d6d4ac8189089a4f8e72aae08f27096ebfd84b4f9486075d04a38ae0595e78af57c3f41ebb5e1344498dfef02d2198f4213b015bce271d710e1aa7f2f5d18c9cc3777c105c2b723694a4ad5d04ada911575ad2e72c54de125324b401689ccf0ccb31694a950253626bcd9f4132d9f6e47ebd65f83d2f81731b4a6bcc8ac6e8b11b57fc325de79f9232a75f031cab8d68cff8e3f8c0801f605b24a756813529eeecd6922b3166a2ef460aac320a8c5fb986a8b04d0f92ac30dbed8d2a968201b9cfb1f5f04f25f87d9ca9226ea6e18ce048f3d81bdaf6084c898f4774b2821838826fc5615ae17a2e47c32669a38da76246d420f51ddeed91ba10ff9f95b8400da7bfdfa41c316edee3a4a05790049cb6357a6cda71a0804ad9821bdb9a1f1bb488411a7a0d2234c87724efe9f0d57bcd552e8e66f6c38b5cab5910c42d8b7bceb858a9b7d522b17241642cbe2aab5d46c435d09d5dd12c23ff538beea6335ef1bbe5765eae77bc2f453af8d955fa44dba1ba7b36b8b9f772d89df238a36cdaf03ed7a4f5be4adfa89a777e0084ace0ed0c176571d72e1538e0528a44c6230fe401c159b1413b0d6aefd6d104b7f0a6ab863730a789b4df236461294bfba73206eb333479c65d2e05860e724ecfb72d170b2a05c789c1bc76bf95f9540d89bab40a54c22894c29c8f308e592cccd231e99212831fbd78a9571a4ab78e27d015204769495fb97e148da0874ad59843020a7604cec42e32e46f9aa4d7db6317bb0a5352ba6cb00065b505c9d427ef6b3e14124d1a0c40d2a71a3704549eccce030b4f4ac76da47d49cb600a5880ee2a0e8496d8585d5d5a32cb230ff8aa2d205c29b3c4c252f2763c88563ae2b540ea62439c66442474f4d8f4552b9e110c1cba3da510ea88e0d367264ceacac0414c9d69ac7fa2b3cb0b42c81056ac624702b616bf074593a45df004620b0bd3e4b630d1641768dff5f0e12ae7ba19912a1a398027571e2fa6f4a368fbf9c820e7ae8d2d970f932bdc1498ec80dedd937a34b282a027400fe64d3b18e1565d166a99f1140096a2e6db899ba3e6c878ae500a3820739e877c411d1269d7a909570c7460a253f663a6fcfd727f703c0b872522634f45810897fb626225f2ad4854ade7468f55376044d44046f0798ae1ee333bc0d0bda07d458f3b756e3487130045730ea1f73bc222f1437771d3f8b9f714e14bd8077ca904fda99794988ccad824d2a29d8927c831d6338ff5cd38a6be5ecc5aaf6253bac51cacc978092e7ed150c4732cb1eda5ee7a7bec21ed243b727976070b41d2c4952fb40d56645ae4070946214bcb2f0eac84218ab68e9352ba9012fd74ed565783b57f6949e05e6f73adfff7bfcc321f5d10709346f6802a825a076598b9a1719cb1663c242a2ade56465228f6e9228c6ab41457767564cebef38b9e419053f6b1a3b73075863e99b706aa2087095a94c773e0b816ca237770e99196f262f1877ede46ba1b4ff3d8c9b1a9b1e18516b090c39c11f3e3636f9cfa718fb6f70592a8fb3b45af1149f22877474a6f40bc32299e91ab3a310522108fd8436148e3c87454efa968d86e25590f153624efb93dd4a1d781cb605752c94914d6fe0dcfb09e9d1fb67f0df7204e1e3480ec3f0c59b5c939dc7b1838acb575941a9967b2919016ea640a0b3b89fb350c09bc648c6fd0d6a897156382e358e7e621aecfedec143db5b3c5eb9fa3e574e16c2b3ec7fa5b99697a453b6294f84bc8a0a372c386c02171047729a9982f2fffba8a6756f22d2de06182326efa6c6ad14d6994b7042c3d9b88d31be1b67d6d2f26024e2f7b14d01275e0574edef39434d60fbaf4c396c9cc3d2e04a82ed638e0c9522dd14f4f29cba2386994cacc253264f4bde91829c0b0012dc4d7cfcc0a293ecf29adde54d3346ef1fec025da2033cd52102952a8acfdd453eb88aeb0841d637d9f2ffb7fc342c726d503b6397b4ad793b6edc506b212b3ba2aae7dd8a9a2402272105fb714f700f6209665197f425e997ad01caec1b32dd83f25a01f243ca790db96c7b2d447e5b32e2db05df9677ea36f8270fd37f9e4e4ccc21a9bb497f815bb4077fa2c7efb4a57feb75125c44a76a135bd092f6ba4f60d10d67568c4c3bff0a01f11c0cac7f00ac79b47c189f2231d0fb05c4f957ff6045be91d81321a2ee51352c9bad9e1315c7f25356879a8abc0d67532dac0779151c0f67fd98bd208dbfff2e8a52d6a899bbc4d96743b66ff285f463bd9a90929d9ce33788e21feb6dc9413d3f4ee0a23e2a27c8968ab618e17f0577da49e72fb45b664d0457d9a6bd2f76e6150b231b81e101e16558a4b600d76aa3b4840acd35d7fed526a83510a65e62983c7a70f39a5465cf0a4be92a12747b229751592ad43e974818c28973c4a2ffde6f03f5f024fa8024b24d41e9ae719c9adffa6891aacb97352f68ce9318da1c871b4fdf51d4c7e288e1da4be21e3d7077b5845ebc1769accbe526c4cb13016508caacf264a5d136552f9d2498ed9b04d939d841b9c0e4e79cda618af575118de7c59e163d9e27b1c53e399bc15e883fa4425c42d274853489b6490573729cf9552ee07f0e6d0fb0a101feeeabb8c62b2544e7b9c0b96fcfb465ab9a20b5f6177846815e24bc02398ae07fc7de5de5caaa26f55f6485376e9e03f86b7a818233fcb2a55deedbf71c40762439e0791f8c9bc9b1236a0c3a19826a724015736128f026e7ba2dc67c38bc70632ca71dda2d8392dc2a759acd7762b12e6f4d4a8ee76fa585bd9b4291e959914b850e0edfba80a88b1639250e79fe53395002b68040c244884364564a34125b948a2c90253f12581f6d026bb3aacf2fadfb3cd0bc5268f251a56fde4749a9670c14d7ebce533226caea6539136379b60295a65e175811bba8368e8a4434b23588d2d09255657c0125df51fc69237a953d888600cb808155955b22d2de6d7eb02dc42241dc895651f0999401bac530856df43931ae25042e9e52a2c54708ad417c03c64c8f9b475090c14991577466ff9f6c479f1c526745105376d04156aaec813568d73b3af6ea902da2af6c921c3385b926382e0772bd1429236bbf080f404fa35238c0dcb56066aa4ad16b0d3eea2382185888d27446fcae0b75867c5932ac3e46cf90bd02ccfbf7b1eefffff8227a2c49ecd399031ac7dc2f019ad4329a9b87998cea00b8379f0f5bef1a824e13f83fd80b740db814100db1054b2494e2771ab2af01cba7914a2c377e5223a32b79babb24209092eba5481e6b7cac40a82cb81174032c4f06fdf2832183ba980dff9ad8dac9e6510d470317c5af3696958096fb45e9ed9b4664d18475c6a5b23b400b72ad016b8c7830478aca4898b3b1925a2dee8c91e42d22a2d274f2e0c119d9b588631cf8b77d203255b77973dc83fe9ed6a7b4cc30cf678790f838f38aedaaea00d6104f526da8dfcf88d8ae302a172e9e27e46bf0154d31b265cd98e7e27bc92067bff08477cfc0b918e288be6ae0bd572a7b728287e78297a36118aa3a43456c63b7938654aac3e59f6adc47bfb82c4f123b45ae5c425bd15a99a3582907d3daaee3432c8785dc5f25f25c4bfb28875034303f03c4a2c08c602915cbb038135c87387a6d86895aa26b9e401ef345fd870cfcfde2e802d3de663bfeff0d76071c67244c912dc9ea7e3e47d1e4a14c186e216f5a9fe73b5ef98869dc2534f1fb5407666a5371dccbcf2f433983ac330301d83faf0bbd8658b3a467c8670573b9b73cc7272c6c95490c3484a423e7a6d3cf577613f8b65401ac943ef9fd36d4f8eb948b047b61fe27674638488b2be4116908e093f53afd14920c61cc570f8e4ab3afea4b5e742a67cac046612dfda8ac2f14dc232df531372c81b20a9ce434b5c080868bece36c823f1a44e22cebb18128efd5a73069659622c77457675ff9b7ae364eaf3025855c71c710223ab35235d69a71e11214e1ea07541fdd83dace6ac9fdfb929447e56d583503ea363dc401561dde580f7a4980edcade0e51da70655b13eeef18886e27912ce1a0fb0e4137c56d7a78449ec730065dbf61bce02b4bbe9f2ddbe32aac6833ecc0180486bbcd666aba1e1458267637607b517d3132168d1a12f54b16f14df7ac701910eb1d5839a9739d47d857436b8ad30677933c907bfd04c948e235a9c3a82485478e077b10f20119a9be9d777527e8a0d334ce929aa05c0d861a19ec2d2943dc1a2828cf0e938f2fb069b391230c5aa67bb14a3fe46b25b49bc9dc361ba1b12b5c42814def9e4b28e1561085734263aac8b52daf9327b9985255bc58547f71fcd4f00438981812d8f339421d79d053cd9d636e39513949c5c59c9d3b549bdda5782d47baf068e1416e68b32e3ed41ea2c86c43c704aca1f3a6518ffcb16ecdb9235e3ae45a22db20075c0fb0b9562269fa5a04a8c5704c2d974921e0592f6f947fb925a3bdd73103948da61cffeab48e9f897f3d513c24b3412c3214ff73184808c343938d13defa2d7664d48d9b7808ad16a267176c8ca29ed16fb7c5a251cfb105a7afc29ff7da6f909a35a7dcf4ee8a751c1912b053f128cf49a85aba0d2e5d74ca0782886b13361fe1fe9917e93414e1c307f18da5bb3a643760a7f58ee3e4c3e90cb794fdcd521d27f5bdf651e92b9050e979d6454cfd3242b8b4b8affe65f4f9f39cc0dc29b593f9c1f05bdc20ae566a4118d77755a7d44f9e00d7b8735132fa3cd40fecc1d0831bbc625f9e62de74c97c05449bffe5b885e59b7114e90cf1645637680245884c323130f2cf3d1c0f9f3f6cabd0bafebe37b1b7b44f0b23e32cc8f791c5d7c82bf808b16c3c670e2dfe1963718ba2baac78863f342f908bd753e92b87373cfe567ebfefc75167b3bcbe8ad202c486edfe32c4d20a26a691c8ed1a3a66d2b07a4405d9ad94da2839551dfefd60fa28bd41031d6995cad60eb73456951f52786c77d9f842bb64bad8db96c4ffe12966109422348812210fd9e8f7699bd5fa5cd5fc17848e87d4358a6765315d3fe59bab273c48d7756fe962ec911667af13ab7609fb1dade034e827910316680d91ea70339e9c5fde3dff7dbf4503d652eab526cdcaa049ec059bbb8942a50f2dc91aee8bb6e51911523ba3835ebb6c42851addc9d6c232b39c3eb80d928fda67e0c5ac06800bdcf240a703191ae3b37bc3d9ae3006e585aaa7bbb10a57f596e7ce4a723a4465e071d487d21a8ac8a2ced949923df3fef3d56e345164f1779d38405fbeb51359f1a61af1bdb7b335dc74159dc4e6d0710934cdc1b1ff020fbe5173d35e35ab7c88ef38a30d27d00426868d000aa0092a78c8de66cf28de45f0815244ecea5a915f05161a6f3cf13e9dd955b8317246521a676b9902362e10b0d76a53799dc3ce8a5ad61c854f36d455aafd6fe9b6675f13cf4303cf0f31bf09a7b3b536badcd4d00c89757d0f7be54fdee71c502832fbc300c87b2e2f32eaefaf37686363bc066e8416a250073a953784b63c5d3a02b50f37fe44aac297d264fb988f5cd7b24725e9367b34f7f723ecc9026abaf1318a44409b13486989ba53064de5f7027593306184470944baf4e6b9c324453c297b319a24b102d1381b3d1aa1849e6b4c51464ed6f98642678b69238512a6e83c25be46cfbafc06c430e22fd1d5389506de4984fb3a3564a51caffa52820b6601bbdab7d7c96b7dc22129704c354fb65a6cd7aef301dea0b6b0e93d4e13d6cddf8df03fc77735cace7c5653fb079bb431fe7671bbd35ae2d86722ab7807e746a7a5a2b9f1218b43924cc5db4627282f17f16bdfcc46cf7ba747dc4f3517c7229a4a652d4dc4e7a0d2807cca1a3fce8c75bd82d9864133364de803e7040dc7d5a0a1d8e70ea502aca5ea5d168bdb2e9ca6cacdeb3b83f76e3e5922e1275b690feabb6813b443698dedcf41d8b5e735ea6617b377e17a9a331cec4c462e1271b390c836fe1532f490c1ed29bb07ab27a9b5fcbab4b99b62f2f89dd90069cb72bfbba5e064cc9fca23d7a49550a46c33004ffd64e67a04de9142dd366b457631b117c812024acfb279eb02a76a9c388230927a80c4f57eda425948153949803f5818639af78c35edd32d5b2c6ab53b2084c41a07555a3fbb08074a90516e04f24f2f05e4d064864f984013620ac874a2388d2cd2c3b13aed6487a07a7f9856ca1bac917a0f47c6257ea56283ad7af4eb70004e820306709fb8d2aeaf47da9f1acfd2ba30679afb62de6af33c3293c8094ed67f9031a9da084c56d167d116ec2f0418b9992a7a684ac3e9331d5fe51d0b18e0b81f0ca158c35c4862dc30a668fae55bc98323366012de0356f497293898653cfef68001079264b431c05004687ac629d39530bbbc6a43abecc506c53e80477006c7dc1a4e2997a835e00027b0e9e9e0ab4d146f0d673ae0b60b4b2bc514d4cb82ce30cf33b9d738521d5917c8f2168c1531de736513751620c1261f3235515497a06cf1e4265cbb2f0d35823ccd7f9e5e849730ecdab948ffca304363a60092e49aa65b9fc1bf3bf1c5ecfd2a33734c8d4ca651eb37ca6aa6dbf17650c22b73f5b1bbad48ad50f45d2ca2938ef0deca94cf64d94a6b822c69940d20c89949e97bfc019409e10d3530d4178d0c4a5a25a1d64c3909e4ae865a664da3207cfb82323ab78a24a28f1b1c01dcc25fed8724aeb2154e51aad74da29d1875cb5f20436723ca96166682818e44d641e023ad0a450c4d944558e92801822d3bf205d60ae5082c3a78499cf6a7e6d6316b32ba41800dcffbe6cb06e20af6b76b6ca9c677e9e99fc7c034a3ac1f920b23c81045634cfaacb7be8791c199847dfd93d28e8780cc1b7b6a5e55b7c10888391919d7f831a4f65f3de83a95d7a96d48dc93e0ce6bf4c43a647f1083d40cb0ecac0ae32d2b34ed874b4839d4b4d45b6d31b0a73411f3ad49714c11b02d2b5c43d665c3329d72fc0f2d68071f8afec85b38af66c9ff47fc45dc0eeb01bb549b303abd592d5869c59d9e70035eb641ff74ea261b0a77e78a2549ce620891d644e583dde1e8aa5b59b4de2ca850ffa85cc886341871fbfeef9844e4e29709de70a8e0a8a192afb013f2e0022b7bcca7c416b6c0880590f995f93b792d51cb34135ac301bc1cb9a8d90ec5f9e63c55104932b099ff2cd8a9db7c1b4cbf0269830343e74858679ce41ff5f9c63c14561c09b2bcc91325977a35f6b65c30b9fd10446e1ffeb9080e87d6000278082e71573d2bf3db2676abeff02dd4a7f663255cae46767dd89b88ce6eb9256e02a87a08c3d2fcf88ee727f4b60a349cb7a7193562fb232c607eea35042132a16fae7a91c1ff92c5cdf3e53b205287d7df1b751fcb08e26c896b2ad24b92a09cf2e90c332fe0d54e9ea0ec5641ca07bc87ddcd67d60bef59c4dec74f263e4600c96dc035f7852399f6882b60757859e1fa1fbde1f082299edb0e758631a41bcad9293d8195e14d7eb6fb0dcba32d909e63e54af101f73b012f6d30e24cf4326f248e5139e55c98a8aa141eb9db13d7d045d4fb51092c76fa12e42b6100a33c59aea4ef9960548040dc4dcfc54f0b3d0f986f3bcc2a6ff8c599c9008fd4532bd71f2a7efc692fe18b8a9bad9e5a9e60d3d986f3d60c4fc16b24009d21425164c9684284fec8b0b437b6f5d331da7f2d1439e300f3560d7795b1d4d04277d542ae770a9b806b71afed56cc75b8f09375920f4e386cdc10885616334c9d10648a59d5abc8617970f42a545e96dae885a01d9ef53ada8683f3c73bfd13db2de6a6f05385fe89601bd9b7884849a63a80c9d8fe332e965e8ce5425b2245233e624ab4f1ac3cfbb8ad2150d19f8363392c3e423f9b5ef0245190b61c1e6660ea3cae0c55577ab10eb4ed763d6c8e30d5926ac3fc1d1a653b30df0246908725309d6a543981ddedfe95613e266b17a94dc10ce6831459ae8623cd527400930ec18ddd5e6e0be44b71f4984d492bf27640984587b3d0d1362c1497069d49d6626ad0bdd16ab618bef4739da480175e1ae7c13ed51d150b2fb7d7f68a7af6179e3b60a0cc397f152fecab2a9097e41fb8830fbc04da17a5d15cd056b528ad90b8ddf54abb9f352f5fd9c22bc0be891ffc6db859699790735975dc24b24ea1c2c66120c38c9dbdb4fe841f8416f2609b611d16907ef4db656d5e33d49143651d0f4f6072e8350181f8ad3fd87da903b5d59d41498dd622a2528d47f09f97b9ad85f9a62a89c458453ca36b58395c4876518e3c82d10c53016d3eb84fefda79e98a27c109be65efc8cae37fea368777926e24ae6b07e109c7432d91eef767e9aa96ab36caa035a777c80e258cf0f2966febab9c5d429b7d4d6dbe5f0453fa28159b531eb6c497a1054187f3f7bf794c513da9cc160eb23429e9a9af9c4b61b9672b9edb5ec5ee63306ae0166d032ebb5d876e806b3322d8abf9c0af2c7a61d4b34f7e94535d51f6d43dbcd926b0ed6b5b018ee783e2d14b19617cc8a3e61eab24f5cbff51375fbc5cb257bf6d012348e84b47fb20e93a5551bce5e4e96f0ccf0b5b25dd3359d8edeae6452052916b2f5f376059c3d01c8b8e5655cc674019b6c72f217f39a5cc5a258593b941b17468336dfc0e833949bce7533c156ed07200dba2d02eaf1da694584443f413ea92a9d0f061625962dc2c1ab7e0861dfed026053cf3221ce55b0e8f3a62b6f203d624b3711bc7fdfd2f474b376ad833e2c321b8c0b2090cf3f52715e38e80355d1b2a05a8ff66e488e6a29a9999df93c01ecf48f4562a1bbe5de6a87b010890bf2db8b51d4028481cb64e6a60a7244d1e3931cd5ebf466e61aa5728697366b4e7bac33c369b355cc85d74b449fb7434302fbb92c577ca1f48af6c7e67b501a54907d9a5bc9c77776d2f04e96254853988ddaed9154f5eb145187678e8f582155486f108da070fab2d1d492c7c7cab6565598ff6b36cdae39d61e9da37a6e354688a3b3193fda58a43bac7d22fa8bb32fbfe011e1eb66719374e3deef8aad9afd8188f87b3ceb4c83b8b6f8e0bde7cdc371c93e833fcff5b8e42d567f004c162fae29b6346e1aa73d997e7742a9368e87d3228fd6406626c01ec11fcfa6dc79a2acd106e1ed9dea3935385edc9a877510bcad8a893c6aef708a5c6df7579f831286d99d2d811b1d7a7554b219ade46d09c4dac2ef9e7d6039721a7f751d4fb0cab60ecb0ae932d5c64fd607c06cc40fa50f773040c21533577f442babe2da6aaeafd9f1582b0543314116e85e2e5a278728c11f3d450369c87640659e8ec86534e3fc66fdaeb6b9a0caff4ab6751a2d39ef01cbe7764c95103860f4a57d7ab7cda962e194dfd777f3caf5301a09ca20894fa7cf6f1a4b748579249feeea6de65b845a4083d78787158b66f459fc81733da67b0d1301f289eb798834d063057b37649c0839a380373b91eb8648d318677f8bfe18e1eebc0ccf51924fa5ef8136dbd7346bcee6a045d5073c7a6a238fd5e5fc6b48d5474335959489110ffe53cecb3699d5a685f89a9054b5a25b4fd9b27b06c0288169c234faf3621abf75d42852eb4ca92b5e31d4b5a89f6d97177396d8f4ff73e3f0ac230203df3dfedbc628cfe500dc57639fa720abcf82c6c3e2de6d0b1b839b67fbfcc41402fc2e318c48edc13b3f3363d68e58df930e61ec075f2330ff512943933e7c21f9502077a238837279350e050d674cba3fd3662e65f2298cdb059627a1769d4a976c47d9175d0065b24f173cc4d91ae3fd16c7fa7e55bd903a9bcaa9e94acd2660303436891946f4d9b7d85b4b679e1d0b6b9d2aa209b88b7fa5b007c5a3ab819cb42d73d005d5660660855627042bc28ff48b274686f021add61d9c06c887661e99a4e5239c57d8bbe6756bb5bd510fce1e66c1dc41847b798e0eec27f697c5884cb9929d58bc7c311a06803516475f760ac1d64448315636b781c9f51889f63082aeeb21b19ea00e7b8ca464c3165acd931b8e9231f5da84addea34ff8a2ae844e747db40719f82351517bd2b5148fcf06c00d31e3ac89cb6a1e8e78d484d22143fc042585959bccd8bb3b8513b062029c66f3f781ea9dd1ce3a984854c9d405d094e4bb2119258baec45a00671b6a26f0864cfc4ca62c94285771da32ceba9082286e248d5c46b9aa0a9564649ee0cc84a5c77c15d82233ecbddc6974f127ea135b2a013703cbbd5a5006d2f5563904dbaee345f3b5581d485b0f3653cb34d1a478ab156d517e7dd445713f8e4caa421bd74a242e6f32889028b6bd7e63e221bc26754882b9424de61af4dfd95e31f393a0b1b56319fa6371f95ce45e9e4e6e11527be23cb12abb142b35ec8f7b73a2909aebff4c3cca14eb4aeafa404971d465f479ee886cee84ae37773fd4dacc8f495c3e6e1021610fe3d7517b79a85d2e3cdf15580f7b739a1dd641f75f1a7f74f9e66d583d95d7bc6577b46c72eedbc5b585590b66c197a88b1cc5773237933970a51d8c57f8818541bac30199513493c614f660062eca9dbb8a52903b32daddbce5f759aa6ddb0ab87f057d5254845618dfbac89ed5d063ea15b32df7d86bd7e860ae6170f55aa621f0efda1f077c4952e3e5fca070dcaa7682152c7c65295126c90eb3a571a9bfbabf8ff351e03c7bb67317a2b9b13fe7f4d5ad6531a7cd729b2dd1ad4f85b8bf8c299b05b4a28dc15dd95244e9104e5e86d1561e074c16a13743288a1dcbd6705abd1c867ed96c7a407b47be839316ac5e98d5021a60c02d23a2257bb002e6407022872f33450fa395864d38d7e3d4a0138d4d09fdb587f0327f428456b3d89f0fdb68df7b6b9003ee42676f4523aa9632b91e2ec81c117efb32c5c4ceae369bce6489470cffab3635be81f3c2debf21c37d0f439ca6e65e0c54b3ad0825fde0729ce78ceb200431e43272f91fc2e334b0e9d2cb6adf6605fba707b436fab1329d01daf1c5254f5db197344ad9cf40b4707b9f9b096fa6e3481ce3e7ae6788e5ec9b2a76a495981574884869bbb81b8b4ca65348e303dbe0eb747701219f72fd7db71280cc7844c82bb471daaaac3cd34877320f9eb1bb68b74e720d95c450b00511f39cedf2b9b4aa97ccf338efed8bc43fe9a5e34f7bf58e38c41a1f10cfd81480f39d3569d15b5fcbc56174f8286472a53bbe65682d6038eba0d522eb59b72710bcbda0b9f2c51d7688e4ab9af3ed25a792d2e2b9d91cf327dfbc368bb1f93e8bbd95b455d3eec66fa42dcb4d5c4eba856c20c0eabdeff5717319f7404b2339dfe5c9483060e14221017b804c4741cf20177131b8819de6d4ec9a3d6482361a4d6ae08cd70010bd14cb46e366489441c3d8edd484e51eae578c1164dbd24383afaa2b6cbd6a796fd38bc0ed30b72c988482c03b32029ea0d15b6ebb0707bd8507300bc6adcc8a94d02965633285140fc5d89b61b7129a2b9320778ac6b50d826998417f2a4fc90db8ff424570ef11a9122fd8d11bee61d5553e2bb640849f14d48daccb174b3e4438b0714a3ee027bc7c8ea4256bf0f8944a3da3ad853ea4522b8fdb1ec279427046c23c11c85fe259067e6b3dd289ba8d3298aa9ec2dd4113f944163c0bae6433d09306b42788070d72101e245337c3dadacb8761ac4ae2a7e9139704fa7e223415a2f7587476c23b3821c286b0befbe888f3b893036c74c5dc2851b24baebf4bbda544ee8c9eab19706cb9d962fb0825f4d8e4d8c4cd79b49a0c2267424b7a1f130014b286004abccfb4ba06a4faee6f511ce217ef55140b938252e7a8c89c4c42136f246201eb00a5037a6d68ce65c2f1715bc4fe79b970f354aee635a8beff0a9d8e89170204bc726082b92ad4b646b0bd468f90f332f17bb871f9cd9cbc9f65a38ac4551fbfcaa8b67f576f970caf65658af24a481ae61f48d7ac5becaca6e725a37dbc6a4e9dab91be305fa678411ac8bb23be3616170a35b439299f7c98b5f340fb1536aea32c4b4a0faf6e4d34ef43be6646b578cdce32cebb6eb348c205db3fcd4426222b55660c1dad19329b1752538bf52bbb9b668878adcd6fcb3f1c19fcfd7a2db1a4b162763adb84c97e217236b2b86ac2a412141611e8b63e791b29d0dbe70acbad21b7b680b2ea93369c86905e93d7850f11133fdbdbd594087fef2f718cfb5a174713d448a9e0999416cd0c4c62bc3fdf45fcd7df5873c1e46ef6baa00d12092bc7ae0396ec7127719db8177c5ddae5811e4b5b6d1493681852bb4c3ba5aa40bfb8bbab87f5357f9828fd65e51c868876b86a6caf618059e8d2babf91980b21950ee57dd5aa8879d8b6e465833348c5ce0167d3585afc922796cc8c8233ef6ecf49cee4e594f697d513f40b7ca245909000aed56cd11322188953b48056105bbbf2d69e89c4d2f3eafc53b32cb94251c5482ffee03cc065620fcaa958b0b04233bbc2a7fa1e1e0f35502e270cb0fa20e66eba45aac9e069a5e9484dc0283091105bf19965717813fcc42331772a3aacaea7b3a9a2e17d1500aac04823594e0938f9a627d6165e98aba90483301519bb8298fb82fbdf204c69016c229990faede951ab03a19a2dd03f33c6cdf78dac2cbe6bdfbb0083f1ef3a83b1c03219bbcf9417b2fbd0289736b76f00489fe1bc1728f40821e929f5694cb78765b5351271c56676e56ad33068119a8f7dfe95f8d42e288a99aa34e7ae27117a5a3b6454ee858c78a56db86820cb5b9b01f483550d91b11180df175d43c387e9667b750fd068255624a91de57fc05759174964245646daa4c4f46273cd2d6251ea2adef107dbfe406b208931e3c536f41bb8f9c571cd47b0e51f3680e8a3a1446e570b9af1a02c090947b81f38ecdf1aa7ad90e3c07b806f62c2c029fd97d39da671f2e4a8844d9d9eb4c666fb2a95dbad56287d9349eaee5e6ce5dae8370dc3c755b6661f5655a3db5f6c36861aa74e8fe2168d711a52711637d321576193185c4e2278cd97aadcb4680bee0c418e214f1d92d9245be5d132468f9416e104289f77ae887a347f0f0c5713e7786d629f8a5335f23614ed3f013bcc13808704b5fbcea87b991d5a88f307d0b0a3bac6ee8eb72ba2ef812af86902f24064673ec09129df74c25a1950b041acb22927559d00340a80043e68a480484a3e2e3edb5999a2b59660cadae6c4e4ffe7406d4be2399a428ab51aef2330e777903f5083878055637719498292bca0a3001f528ab486821df223738652d6d30d7cda820bbf5c65766b6571b5e132ad620cd06d459049fbc261cf5eed1f5efd2c74399de3952864b7783587889e2d74e103231f2378c6195c2fdd5159c61b2833049a78e276ce4229ac2a5a3bbdde381a51a3ca1431a9ac86b0745c5562ed1cb8dec28a19c11147595de5b075db6f16113d6f26df5b9a6556e9e779a687cf1834f398842fb9c5c9e3053205d21f8b00eafead0f841fe56deb31776a66615f8e47666b617c521c4952e7d4e20561515f60e516e4358c8a83fb2725a380cd72c04c60341543ac8755350144da49fd84e4697ac5e7acafe6846c32213a42134e66a4fe7537a191e37fe651251259f9dc3373ecc47b082760a01eeb2e4386432bc558d538af9201dbcbe22f4b7000e80233375dedddc0d01b674b94592cfd86c8d038ab796eecbc4715b0923bde836c272c4012269e5ab2bbe1f892d1772258189f37cd8c2117554f4aa465669474c3953fa5d05fd7e93f5b01d13679a706e0e189f557e16a7bf0449d61a16225f80811f554769b771a54691b88988006b5788c18dcd9497f8a184c191469a000d50cb0d58453438b75ed80ecf5b12d8a82a4a4e7d8b755db51de0e93ed7f99610723967784ff0b63cc3692f07a5af8e046814fc29a2db357129acdab17c4262d03aaa3df8958cb4230be86266ea0f3d88dba1d1687b9bdbb42c02634c6051c931eded80f96cb929df744519e61655a2c701fc901d8b659e8054c1551b27f13effc3bc3b8d486791613d88e9f17aeff54382bca1e6ff61934959c2afa7ec64b0194d78d9ceec50f5a34dd7e089a443279c1a15901680a9bf29d29dc2e565c60a00cc819316ed7bce612139b77eee8f82b32ff55828795faba0add087395704f0c8559b079a80997e180edabdbe97a60cd6320623c46f0698c8a1888d43f0f0e6ed459c47911d6224ddcaf010f74a21dacdba356437eb820aebdea9c4fafec5e7b4ca1b92b5e2669362c6359970d60fee5c8c745436e93cddc4f928eada0748d4f58b4345d85bea52a1ce77f063ae2023c4e965","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
