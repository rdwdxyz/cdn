<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79c71b3b996aa122e2f02ce4e2d4962e2c0d03d8f41c9b32d74b908b755d164dd540a2d97e8328269e576353408fc8b17b3be2f990e36825799f6548e497e196f9e18bbab51e3073f5c96adf2dfa3dcbdd2e478bb8eca00416404f5921133a68ee7b4c0e64dc764c3dfe9ea7fbd0ade4fd03e2e3d983928051d554878b842386dc1f7bfd0bc3f242e98c6be2f25d0d1a56e3eeba2c33aaa7418d9c6551026d2b28ed4b4b0760026f7436f79cce2d204fc582ff838bf0234900c3f6b662de0cbb31fb0118f16e5684631eb7c6e323fe80e6a28acc64c0cab1b2214aad640ee26feaa0e397d7230f527bf03a485989f83d74d55f0cdf999a5518398b6eb2639b0555d373c4e95e0978e6b8ed52f2db3c07b8f419fd4e28d5561c29e80fd6ce85f6b0f860e3e39120b3db51ac85539b33997a8e36a8ca7a0b017648b47c6742feeb559f5403e38ce6f4083cd943edc01101c93fda1be45f7195dcd7da77be3d295f5826530d6a8910c9c6feec989642642c9275d145b22404c3b6aa1e21f1d689a80756fd559580b1f3a67af9b00b3847369fa6fe0d3171de910669eb6ef697d85b48e87743471c38683b218841fa12cfae9831660685329bec8914e02fcaa0e1e414dc0ee1d85e39be56a7b75a6331cde409e986f17d0a4761283ca7ac301a3c57dac227fe619bff45b32a3b5cced1ef0e090dd0de31a52c42afdc49ad7ee184d3060a96f5f9488eb8d12fbf0b0b1c918f4644cb916aa0807dd2c9733968136e1e74d2b29ef54297518ed45547599920d037c0cd4343df1ce5df3acf1cc09372982bb0c1c3a8f88f4ee8080fbac5a7342b51d4f446d42892894539194b05dbe265027dc5e88f892485b69b41aefb951d6814f9b9aacda23bdf5f200e81b5724d44082e8bf7770eff5307449d6c98c6851c18798521e133404551069e6c9d13cbf5e9b47bb458582a9280dd55e582b700785a9da5e284dd55ae2e292c3e7833a1a4570eedde467292bd095113bd1eeb219811508e779840e384e59a755beeb564cb3eb418e5b1ba0511485f4c88fab2485c0aef3cd9edfac747c5b65873ba68367d1157cb9dd73a08cc4ac44d144884c0c187bf6f62b153a12900310b4339e8e8918496c61cf832a5c55858e559da39c571ac5fd428a06faafe5a98655d9981202d96b735f8b227c8085c6ec3329faf51383103db6ddfe63e0981f2fa5b5b813283a8eea0bde494d976994e0d956f19e4f99437c4ac9b43d896d5b0a0d16dee02a61307281e090a4102472fa42df2cfcb268bf99aa38e094100ad188e973f8c79e324b9d37a20af0ccd967d0c82bafe053e1d148a3cd2159c5aa4553f667b7141e9572eea1a5f4f64bf893ca1ccb90d62ec8b4e0184af2771fed7aebaf865342d311a15a1b8afcfafaffa31a4e583fb3d24936598375b68a85a4beacfe24a60e06ff5b30307a3510cb8dd6289928005afa2b3463f130dcbd45e830f667cb1ee690c656ef5ebb4ed25bcb84beac92dc7e87d5f04cfa06eb00a579617e47ffa6f7067f80f735c943a37514c7d42c1677b8893acd9d226ef53247dae6f287877df02b22636bf7fc0562645b216fa61f320e17da2582b83aa9d844ec3ec21e7e83a060f7a0670d68a532af4863cd67749a244228b4ed5736f640c87b0f75515a4f8b86c8afe810f975428eb8fabb74f671197a1350305ade74e575307799c923e2fab89f5dccb2bb2c79742fe4279efefc59fe753059d805457a115c5ea1d243e682a9283a8c1f3c81b4fdbbfcd45fd74da98739fc8981d08788b72d775fa676d85951741de58c0052520abd0b1cb163f4fdb0fe6b90be80f115c87a8a2bdf3444cb85a69be3d53ea751d5fcf2abd7aeedf411c92839da3f30f84c9e6e7285e96da08d5f3725946b46525fcad6cd7d736377ff59ee61ea546d2ca86621f33fb579d06370dac0a9848c0e3b965e2949135e703df484aa1ca6760ba327b0fc0cef601d474e13ad6d748c2c1b17872bc614d4281210155c97ba4d77571888cd48a91155a9585339288912e8c02db1e53ded6152001d796191de672c36bcf266d0cf56305242c801a5c51155fb9807b473f269ef3cf4e01de4265937ca2264420707abe53129448719f88530949e7b73dd73165334ba3abd20d5006840c3f77f126645c03482654afdb23632bc77f9395d80379e2f71e7ed98e2e248fa4094ee3923db7c35480de8351565c6ca6ee091b04cf5b96a9c62faf4820e7810284ff402ed326fead775c2f1bc0ffab91812cad5951d3e8e0dc8c79972c9f943a273d996345d12ceace8125cc322f76ca52e14b6f0ea4e1f368404ead9455405e2fd8eb0415cad569551d74485964ad92ce8193ff0c1ca90ddc61e373d657d7d5fe24084a4c5c466c0281ae67b95c397af60a12ea815ed94de07d9dcae293f709f65bb22f06c278ca784dfe638a2d2d49203dc94fa616344c75701de03ce8802078a157e4c6f4613891343fd9eb1883242e06d6379c52bd64d273369a600096313a16656a583c18fc3fd5142986027178418d6705204675d54354b01253a00e3a5075843c29f73d1421a8a29008c1fccd36208fcb13727dc4f5562cffdbdaddc80aa8097985f07161b36589eba4202166c72c97348cfa3c4cae0a34675a78f6b7eafa4c5b3200f20962721602d79baae875119f01d20459db897faad07dd46cda5742eea51018b6a18a78e8909b33357781d6869867691a52d897b9272d255a7ddfd6bb16aef6c09ede1c7db7e0aad3089f8ed2e890c5417f00329aa2e9d13f387f815a5922b8a8db6827f3623e14dabac2b760e43d0da29ea08dcf6dc9d9bae88790c88e371957b3c032ecaaf98fff1fdc1cc526a4aa0304c6be8d0641ce3df9202a0fea04c4130dfa28355380b2d25aa2049ec02546880a212bfe7f739187050e33cc5a617f6b1090fc0374f96bf82543dcc5d7d6f713bce67f1bb7c697d27eea3f221215bb949469d40db1add03065ce0ec51f46b11d89065c4607f621a2f4ca83da0e01ca63aad528d854273ece4571d587e8af1a46bc3b99c74f9e7d4cd42411bdce11d1ea11463eab04d4ff2311aefbd4e5efc02f9c8d2d00ceba16dd561e05c510515067770fef0b54d3539f1ba7cc30fd9c252b512a5f873aa95f62d8dd2ade6ae8ab5216229d78328ad28da0c321d8257ee37ea197341b8ed3e65dcbd9b8a949ae981b80fa257e666884c6e75269b9bfc1446e380b72182be5a75f0981d8e00e70e71af86363b037c778b7038098a7bd47a46fdef8f7b55e24a3944437cbf96b6b2596525efa7570387133f07d17424b77f6c7d583a1d344988722df8da9901d3bd5848bbe6de7bf0681ba893e5868350c149017de0d16f23b83fda59c0fb6131184eef806dcaea3a101997f5ab7a0aff85df6f47c4ff23af9f6b66fcefb77975c64158cc78fec4340873e60866c7b458cca3847c72eddea4ad63764e9848eb21d42d580f57b01885b99915f21f0a059b40fcb0cde47069a79173a2c6eec272de164a4bf8737f233ff9e755abe6c25979aa25a4663fbedda199fd84095b0d75a86452f625267febb5590a2c45ff8a138edffe4ad3034102608aa581fa35673627b6d27bbe912135f96ba4dcd8b64a8a00880f10f6c94ad737765f0bab89c1537b28de5af845503c4bd70fc58c4ba7cb800b9350d0872ce5f37ad68b0daaff5a0c41bb36466af18c000d4d19490a8cba0c29236004f23dce8b1f162cea5fc2d5a175743fd5a5be71009b269879febb2bc3ca9724597bafbd18adc22822e2efe4f9de6aafe08de8a5f77ec077044df76f0342108d2b797e96d9f4e4b82ed321f39e8a2452cfaad7c678e2aa7af6796d374699200a78a6c052cc773c713b1cf3389c4f18513e5ae005b97b0b3483bd6dbe10b8e461255f28018e70d96e91df7e11cb9cfdc7e6ff3f3bd183d43faf2d8c569cde4c0acd9ad3033917147249236abd7fa330d25c7d63c87940b6755f36987170dc4f51f2b3eda50532754a59ffab08706b476eff2ffdf262cf8290cefcf507e1762f2bc6af3cf12c0f8c377037fc19bd110c4b767de0d21214f0d421731921f6a1c6ac8ee00ccfc1b2ae290e7cbc69783019113445641fa6bad40cdb3d52e02bca445893ccf9242d0e733f4371771cfaf476f3547402723f989691c4a32567b5eb36a53fcfe303618e799bd8893c0fd2e6f349cb64d80a518577fa982de84ef77fd4adefa690a56d739f7ccefde3a7dc81ff70d4ae8cbe902193d0e3aca05a42b1096fbf8a740c4272741091349946c509e8f6b21a2ae58e02a69e04eb25bbe6c9cc83baeab1e924acb95c29ba83e626509fd6af1e2045234b46357267ec9a4746348f038f5a898a32b4162e39ac3e7712910d69ff9b696161ec123d9de1ed5b41b7945b6bd9b31ef18ab517140055c50f432f6819400b6f8cda9fc64f6d83d3010e47c760fe4360d56cf57bd87b8d82d08ce7e93e6fcdd5fcdec998b48a7417c2e9b73088d52ec11bfefdae3444a6d72074acffc231c9a83f9e25e560f7159a30badec4bb814dc83c600305f030ad8f2444bc6bdf705949881dcb0d602b2614c2ef0b9b74d4172c3a4284a739e6705fef56477eff77387209a51cd092f0642b6333333b791d5ce86084b8736a6f6cfd86181bc78da22941219f3092b5145a2174a5d44ce1f00280ef37518f51cb5cafcf8d265f9cc50beccee5d1cdeb65d96b734840b6eea15e67648ae0d63d333a86a0f03a8f1869a5c9b603d23b3b968a83fed474d3b3cd7c993f4cd5733b70654704412fd656aa7ae78ea84d89bd7cf8cd3d9b9a3a09c1153c0ec55461a13ee53bddfe72fc95e91d672388ebcf2f076f3fad331b9741c76c37c1772f4a781db529faff85195f241651319181e1d9d9517947d2289fb3503797c0ba4e8871a2dc5d879558fe0e2f9983ff10c7a7b25caf9e45597c7998749fe26c10a513c6128843f45fe066e88e3295b2246afae2b7f53ace7a5d054fb3d1c0dbffb20efba4e85084d5bd265f7956c60f5ff2e00acae44cf22906e287d7ec3f569b9f757d6c51d774dc5f1087de718e7dd8729f8504789f8769e680ce7e6cc571715bf4ea5d098ff17a9aa71cf0ed056ddac575986e4a7a89f58c33ed4107252730943e16213b244d7c1a9eee0527830b4653eea3d944e4961e979af8007bd5269c180bdf7af13c91d200fe0b2045550e2cdf12c5c4a304037303ca64f5763b54d2ff7967ffd99916b63d719aa2938661b35a949fe21c870e25c03b329972a8597c8e6592b7dcd61bd7378c24c99c615c84d738244f81d56c249dee23489d92555fccbd2241e6a88a13a6f60a69713bae771455c54b43a2f8a69506c6345f92dd35b81c6c3cd5acb58b82eb9522a0042c310ed572564832486c59e5e74c05aede2e98e83667feeaa75d25954a1028068b86a1f28465d39767f40d58baaea884df141668b9886d6a2181dc009cbf382c89cc0ccbd074620e502334eacfa739ca7714664f57bca8eaaf3fc8df415e9e5810879ac1921c24e5ea870a569cb51ccf1b91ed6f7e93ac3749d235488b6e6ad1d8c2f185790efb27b55e337dbf3b75d1b2de39f427979d74dbbc31fcb1802e43e322addeade613bcf7b2a542618bc0a41833b35f6745f6a7b660c58db58f9cb6fbca78659b93f55d20327cb8802aaea8396ecf16189fc45fce6a9d56d2f0a02568a7356701cac70c02272492c2098812cd788fc8d0e5309d55873403a385802df5a74f1528bf3879bbc74cc4e6b206de9433c082a1bd3e9640379041f9f07e100db353719bd023bd2d9847053cfe23db00dfc652e1b71425e37a6bbb4660f0cc498fa16131b5d06536e985b6fd2c4186b1ec6d64fc6d2565247b366bfa509fba4ddf2bed69b1840efa3707f7ecc058f80ca4c452edcff8ec96ece973c91b4f877110dad5afaff07a4ccea99f0068346e26281f9fd5d846d305b0675dd75899ee2dfd54851b31673344c86cfe94a8629a2550ea508bd2a5907cb9061f87de34a8b8a9f33df17fcef6da77e5521f36c41c3cebdaa2f7637161b78648a48a070d611fd174a99e9391d059d73d653f0374b50a9fab0edc7255a4ea08bfb0598c653f2ef0b954795872ace027b2c9326d7e86e27fe899b52143f91f911d1ba6ff47a66013257012fbb5bc3fff9463b45fce5d6ca1fc02d64873b4c6d95733d59664bb01b3507c5b7cf9208f49af2c766dcaee05933d48ebe737d85adc53fa19e07e80b7bdf12b46ea64634896422ca250fb24791f258d11566c85acbb9becc1e06dd7a1ad4ab5bac6fe5799263f58772bbc0d224124666d7abfdc9cdcb1485d9dff270203a61d185132c30560223d55f31c1abb6bfbe9efe3fa4fdd01613880c1f88b75ed851c79d24cc61b6ac3ea7627313a8a4cfd79391868918e1ae4993e90bd6fa7f3e0b052216aedb4e8101e389e5e8fe23284ac27fb5cc22931f240d25445d380d93a204a574ad72f663f7c0b58d1f4f98d5b490192ae199083a17625173bb906ad71478af1565c73e6b647ab47cb82a8f5653ed9102836e5d112b0f4e1f7b3c526fdccf0303861510bfabdc4b614e3a96ed82dac9d0ae97c326a90b85e73662db4ad2ea62a8eb02de4af8aed58a87fd5ade97b9b1066ebc828bd308b2ffb35e6927cbc75e11d6c6839673bc9207525e12d05bf6d1c3964254f9388471728c725f705bd66e0386a2d58d5841c389181c05197d44e16ced2e671ba06e86958f79fb5ceffeff3d31abe7add113ce88fa8873264f8e0ddca92e6916ed29a6186cc11fe0ca2b747c8f1a2ab55af53356780f1d82cd9f11ae55e7ce85668a822ecbde4ac630a9f76b1cfdbaa0759cb15200cfe38171b2d7427522b9f9279991fbbd6f37af527f7366a1e3a77d5e98be36565d2f056d653b92eabd42fc8aa330a0648005ceb15dda8c84fc977fcb6c0412748427c7f3288529b89d927d84b7a29412b81c544adddcce6d744e9b3ede8ea40a60376674bbf3577c1237698dc4ef367c8a83e8001daca9b475ee1a6ae8b0cbc56f63441c3066ed0c2a18958f93a8132442dfdf345bbcfbfc616e806254a90a6bbcffc69d61b70766fab4df67303a915df193d164a3d92d51cb68a360972458e03b27db9ab69e5a2b8049fec19d809a1f3788b30d2af6309c7acec6ab97b85c32a8e8c013032d314563ff84363155e85d3afa5c85e4cb30ed83152b350853a9359ba88d3f8176b0f6e2ead3b53416775687c7447261f405f2adc9e3c16b907ad5b6cb926deb1d0f39891c6a62675fc6b36d06a9c998e982dad9f0cc4bba035c9f458d8cf69f2ca35ce668c3790fdee3641c1de759da11480fa2bed3d4e1633cfc65536f91c6985ea161e26fcef83f53904f917547a64b6f610d7ec3a16f647eeebc26d29a1256949e458d6bdcb4dc833ab63e5cbb9a44c02bcf469614af87ea302f02c16cd12ea39de628bab19d1894d8980ea2515989ca2cd2751ecfd1bb1b8ba55ba0496fec5f7ceca73441f744367fdda0ef0da780b4e02fb636312128e3fc381feaf5a288178c63b325d3b1ad4a1f4829ad21ab58263f6aed25a71fe20b5bc742763cef9ecc07eb59502193875473332c66335ef3d98eaedd6912872e792a629445190df57e6720cb437afe0d4ce2bf7492f5c7d86249b5bbb716473b21d052069eb7efc82ba77ee6e7460f410fbeb7656d776e9d59be22e13cf37e59bb21afc87d61d18777847aac56a6e587c46dcb2c2e7c1c027a515ef278cacb8d557375cbf137ff7e5aa149976df89220c5f5c01fe9a5eb00c62d7e983265b4d4999d55d01a15726fb469bb13a61a02aa1b0788d922b89e455265902a02e3844c7a4edfd57b0750ead22e993b4a71a1007432cc03d5ea535df69cb2aa93e7cb658125ed78ea49d0d5359ec45ec7ef9e019636685fac751459e82cb1a00001b5610583ca565f91446f6f446120174530a33663bfd00e5e660bd4e651c4031eae5e85db438b791a60391228bf436a5ee7f4fa658a9e873000667e0e491f6036e64a38f1adc53c9d5d19d4c8c2a297f61c28994b79342d9ba49443daea44ec75500e004895022458a8798f3269fbe1afc6879884ce3d323464bce042b589bd9084e7592c07289e741ac02b41c2fa4a98cf12a60c3532e56f03915c55130bd3e7827f02e48cffcf24be244fd536472763d8261a3c0c5ee18892692be1d22bc40fb7f14950e3b483543da4343b77e667a4d538a1518674df4102292a895de50ff0cc602e23ac06345607c8b7e3504af89373c39c10c27776e359038a1108490a872090f42ac28ce1c5fb5ef02b2b57ce5fa9a5d3d35c4bcd7729493ee5d417a70fbf3ed4712c75d4dd03095c0aaba34e76650567f6e7cf57dad667cd3e84d04ae3c52af5a22e9b76dee96650a9f63f839788b61dc9f91b4b9c7a3920decfb2b96f930b681f9832400d63da7c84dabbaf99c8fb38c92e763e47d805e423dfaca30314ec97d3a334e27b64bdece7438ecc7103b06c7e435b87cd03a274711d3de5c2bb489b3fcdb7808e60ff0e6efd85aa46c63bbd66a89cae8953755ca1170a2624ea66aaa234c9fb75a9a2dbfec98bfc957f92614958145651f13039e61538fac494c92064dfc977ffe537ee7752bf87fcfb4c2a18c7583b53ecb0c30b0e0bb580b4d6cb97c023867778f709385b15a4cd5c9fd37189c871b7034b9f2c8af0e5e0f26d71a9d3eff60b97413e39b102a9d97a806fc9a8881d53ff970ea33b99e56c9cd07a76e30b22bf568cf31671728a01320dad5342203b37e8f8443b83b14f653dc279627a36ac9f2f110ca1c38e2ebd142498cb2487e733ee6288039b45c02431db728c6f9510df3be58d3666075ef335398f0bc22b333f76c488217ed114351dedd36a3a1a5ded2a7d2c3505fc76ece4ea8109af432498771633b198374d8912f5cc608b093d1a06c89447ab37b62ddeb982137ff7b3585a067dd1d24911edc5afc14353dbdc5216be2ebc2cf2359ebd7c06df9b1060f1bd5d7809c46d35a94fdf6cd896067cc714ae19f32286706408eef449273b172cd82c3539a8dd5f64b9b2337c847faa73e9f0e54a591e7f68b9106e629cf02e74a8724d0b3de2203ee752bf9689523ff4dc38b10b0bf6e486a9d1636f33be579076a530c8e22feb23251bff931b85155e33422a7b0b500836e3293f617a534177235106e036f9c11c11600e43af5e62fc6fbc90601a19a5a0284e160a9c98fb6b9c371fda4386d265eb6eb98a71a5a60d305e0aaa5a81a76e92a10844d5f95f46554d38d97158911941319dd7a5808469a0349c36bb701c91bb72700e7dc08a0b5d2b66aae6fe70170c519d201899fc127d2e0f1c9301de8edcd536910f32402a572283662e99b6e52596b96cbe193d95e3c5f106b0782e400894775b638773784f3b81a0063e7c09265fcf84ddf3c7bbe01f0d59e37ae8c3df2d02bf38e0be72b930d1da7e6ff5f7403881556d76c92c9a400c976826cf8613cb1fd3693651b9c5bff37ca903da3265f24bc0b5fd63915827340e5aeceedbcb95794ee64e824caaf43ec2b27f57f83e62cfeb384635360f89a80bbeafa73dc127baaf135ac00027141f5d6948a9eed66887f47ad19ab929d1297cc31b33a53f3f7eb33688968b523c28590e85ce53b363eac1d842e195a48b225be683c92a1242db39b7814c2566950d1ddbf82a53250e15eab73b6bfe4e50349ece8ba4e9117987ccd75013888b7766fffec7d4d83077c2129373656ce3e1f0b8fff3237fa0b8253511b367995445808a5309f594aed2c21509726216dea2dae12ce79b141613eef7def224f6a358ded54320d26f10da0aba945e44c383efa05443503eb299fab378d873dfad50d5f4702f5798263994aee31d925d58073657edb5f946b09be58c2cd2cdbc74daecfdafb6c52eb5841aa8c8c46697f1ea2c19a9249eef68b35afb7e9f1420913a01d312c41415b2c45291fb2bd4be2b354e9022fac527699a2de484bf88dffba87fb1ef09dcedbf5a9a35b5c67586a7341e0517eb405c5e7aa1fa581e1c4a88d28705a8ea7f01d98834c645f3c6a0cf9891f32cc2980ff1609fd66a4c0f04ba1cf16deaf7d739903637b22ee47430b038712d1c136b363db5198e5766dc933316718e9c0e9733010439e1f69877714bd08b2dcb41d2ff28112b5274e3812548200e87c746ecc24455b2209289352a6b0d6a971f43c155b4a4625eb4dfc639eba8cc0b76f465ebda7f569697ecf56793a23fa32dcb6a39fa1faad314bf4ca7c3c84cf9bc9ebfa86c4f2f651c910707490e84b74d79acbf44c9b798880017bd07872f312205aea37d84e644bf691ff0d1e6aeb73b5d0fa6f95f7bf9e603b076133f9ea11065816e1c36b1bcb3f234ec58e58f97e4b7e8e996e0087cea4d17dec85f21a277c6e7cb6f94ad8bd02afc6a1586123d9d712291c75e73d86cf9a67813b7a4d71b35112d06c1560d9b88be66e5c193721de14289cece08799f82fa83b48643e5422686361dea9c580e5bc15c3728007819266a4a87e2aeffd16bef68bf02e8fb0f9b4e4fc41bf0e0064eddcd6ad8588aafcdcc44cf2d109460e0e8eb9d0047fb0cffba2bb132a970885a93d9555fe0ceb550ffa0d574806676eee38941504e63a0a86902cf4780be32cff7922a01f7a5fc94b53a83c499c9ab3b86fb9fea2b67504a991effbd191cc92ff3e5e0145972f9e56cdbf04885811c1d041070f0a59d265e49b669abb857ecae6ef3f34f338429710c833bc8c4dc85db9f86023f815b5d43af0ba74aa7573ec3077e2e84875f96581e8a7939466cb31a94c91d21099445601fab83d0b458e3899e3a6189305a047b85b14a5419135f35c966971bd56252c7c0546efca5ace53e374358cd7c4e379e9ba6e6ffbc310a4063626b13a7bc61f64bc5e005108399487a398ba03485937b0288a2dae3aff47dfebfc30c31dcb5b56dcc625a36b86ba8e0c094c7161268605f9666ff0b448c2d43523257caf7273cd4cef9e36ab065ebe72b424265ac9bdfb15a24bcdf8140f54a78ed40953cceb95212eb414db814b64ac9b6a2d1870fa8d1c713fdd60dca67affbee9b53f6b0a630d794d87d6eb348fea64c841fdf513bff24582d0ab17c84e1c376f245bb22c893c8a005975c2e15e2ada0038febd2eb0fa714ff7ef0225c9ad9dd6fa4d3bf399e9053d7e7f5df01a7f7e1ab8b9ef45daa4c7c3497548d86b4eef7525f21cd8341af259de690f4a6fea7ac3a55d42b68463ffc4dc3b627057bc3406caad49ce482e56533f60bd0b6c830a0005ad7b47acb1339bc5d61776c38b6a670f7ad6ab956d8e5daaa13db9c1b186db05f152fa127a6208aa0d9b6cdaf06563dc38d53e5cc033104dc79ca57211e2c6cc41521e3ab2211a439d9d03f06ec12d189e8d2eea2aa753dc9e3a5ce4235035a332f32151dd210b752deb50bbfa103fb45388ea70c5398f212fe243484d742fedf6278341349536f82c19fb6f9e82b3a85833638ad01e798639b23c377a4a3a0a696a02bf27ecefb35fc607196b52f4051cf5f7882bc119afcf28d992bb940bfcdda249d28e88ec758e544c07fe104dd5b4d1a5e2f6dadc69b39d9c862d8f6e2e95ab3d5c956179bd20565fa12a194d2eee193319a7bb0097a5dad1cd86f45a65af489a420b5f8c9d516e016bd8f3d04b313304c688e8ad66f9be2e75aaaeb11dc3f58135ef23681ac01f4a553e68df66634fd5af9f099d0c9ff8f9ae0e4237c3f8bcfe0155ee09a7a5f2af43321926cf0ea6a8cf109289a675234d7e82f48713dd1ada623c47f0df7c70060a194cca5487ade55046647af63bd607d54a525386d0b66f42228d0c145d71a4d24bcfbe241a431441281dc4fcf69bf347533985e5a6810ceaa31a88243fb0226fe88cab689370080c93979505a77ac5cea3efca31d9cc100e249a20cba3d75ba7fd64b2005080d71bc9646ad600448f17ce7bebdd6be2547740a12aaccdd97fa272510351c3f1e49524f3fa72a6716c2caedd79abef767f820313414b665e3c3d5abe856ba5508652c5ef56f6b25b9e291de9257835ea0cb6a19d4a27723649d1f8c09f06aff4064f54bb903eefda1d8f75001fa6fe6660fff24050bec4db0c68cd3276183acb312e380f8424d3a03916a2280eaea9e7d2827a5c544836f590b0482e9a44f8b56e9b5d5f3cdfd6f1712f0639e60e848a4c3d195c885bf045143913de7c2f6952c6758f456b40340530eff5e6bfe921903cfd377505413f6bfa1a7fe0097b8d97efa7186f0802a8e2b4fa94cb431d1ef1eec8b5c7d46955cc2f99a4e4c73dc3922b940ed3c59b08d0ef1789c2c7d57c1c8f630fe118ea0ddf8fda099556c9d111f55a533ff75e2a1ec37bc322d268679e7bf01593c00126d1571b61b1615237447e224f818503d64e3d67a354d382d6ddba625cef7441307eb9c320e36bdda3bdbf76be3f5113baf5ded1cb7cf0505747a74598f4bc6c48edc0d997b3f6ec1faf8963b0231fd018b1baa5980e53be6d7f10841a48dc6955d019c1f7b0fb7da5a6f68edaaa8bccd14084c90a393fe09da9ba2bd23221b50a0b58847c5cb90d1bb430d098e97ad737ab2383b83d53f9d8f232678d86b2a761497c2b7f12d7b2e9f9b7c072978464ff74630ce929b74440cb9bd2611c5fe1ef38a20e5b3a3672d029dca4fe0693c6269579958d6ac24387287c3ccfa4c1f2e431f0ba854c00c79e4d4cf7fd73f8849681084b8fcd281bf4a30814d2922be0dd600ca0741e16d60d06e5fdba0d01aa53e81a19efb77fa2e352a8b4a05f6d88c09134d66c2ec43cc9bd94efe2e8b4f90078c4b82a144fd254da793786f6acc68c9156b65af29c8ca0bf76b96125df7aa96efc0661608f8103285a0c47770ed4ea334f748fc6660c23da4fc7e7757379ef62c0b814992c308ac37d4595b8eacbe5f7d1509eca1ae66363ca108a3c317c5dc1db468b43951519afa085855a7acf37daf427975f309899b0f6d59236a889235926b817dfe7d12a227c5d9d4bd3c1873285b4891fb7253c148daa26e9fe39ddb2a75e380dbd6a9fc674e5651dc3b58b18656dfccc88d1ee659b5df319c6e37d50f402ff912b60d5165c2c49cfbec4e3566febca2b59671a885e98eb1fb348b032d4b5565094e292a1c19ad5111ebc3dde4df1f0af9376115ccb3339cd292bdf66828b3ef9759b55bf78d869cd40139f9260cc545e8c0394ab68990b5c297903cead418bc991a4c3582145fee4cc427d5e92d7cd64772e015f91a1a216e4721e8aa05a090147669b35febe4aeb8ba1ff4b1c139abb9b64148b8249d25e7dccd10db242a957e030e730b733a628f5d5192968bdbe78c2fe0ff10ad5ed14385d9df178cbf594abe9443ded3a893749b369dbff3ec8753a959c34318c5c4f42332b4253f3c34ac408d5b906d8719a9d5ad82c8fdbd9491354fda5951eaa5a3ebdd8e37257d618bdce86dd4a1aaa6ff6335e366e53f8b2c576910e568d8fc18f28d6f3daef5de1aec79f6488cf920bd7befc80d21039846922d68720a0acbff32e1c4cc5f25ce19e9af5bcd8d446447d288db9a79ff76fdebd042de6ac718d77cb447147da1fe6f9a961a56166efb143d2161c0c155cd427e54c2c7adbbd31dc46f3ba231fcd8ed3bb8e56511dedd0b790c15c30d894c2d37bdf032149932f9808ffac98b415ea45f98af1a4253e80f39b027294ecc5f0b36e4e4afea48546eecaad9a5920d9fd13e0d9c6a0877a9870685589d689f7cc33473b990f4bf43985eb5d13a95fffd8f49ada5851f30aa4f886299c4a26b8fbcf50ff8e0f55a87cf36e64af845a4f54bc6d211542fb322959930590dc70ba26e3637e882095bdd7b52194b5d5f8cded7edb7de049a286948eb468fcdebf0eef01401bb1d6fcf1e78b44cda59d1026f1bb4f90ac89e8f236647cb1dc4ed6fd53d6d9e0575ea993ab18734ed042e1a0323b6fb1d4f64695e8cda11f4811dbb70f68780fcbb18aa03c680330ac977270e6f60db3f40308da2b62102537dfcdb54120ebd883fc1aa216bfe0c82cfc42b03b8df2494dce0813ec89088f922d29d9c0aaebcd7a03cb58c637d8daf1999b41b3cde7636f8ef644ca3efee23d33162b4d6bc527e07e483c9c1b73fe979aa94cd6db8424d1991313e39d84841fc81a89f0e03c69df68207971159ff77c4dbd9b59f3cddfd37cba93f469a6014559c3d0940acb05bbd2177d5acdbd088280b657f59746e0017ffb54e1b8e4490edf8499e667e1b640cc2fc04d73d76a0f8a33d3b8f6c2a0a3b81c53c8dd22df1917c6f8d492cde6e2d04afe8b9e8cc24795edf8d468759c1d2c77eea594938046453ab7bb82e1c0f0e94ec8322dc98c365079ae32af2075a64c7613e40067b5f6c0df1191f5b050e5795f5c65c8077a4d4444a8b4eeb5068f535eb50720d6f40a81cbfc585dfae004e9d66749bb78456f5df5f871f9f1176a48799c294af8f7e7860eb7e1bae5c096db8e4f9bff9a102ad2d72e57db2e9bf35f0c311b50463efdaa6d61950ae3230d14fbc1e0dd19e6b248416f93522880ae437a6771a64decdd8167172769dcfaa0cc82e0f9ffe448c3c84ec83f43a9ee07b878845a97e73c777f57e41ca2131c765ed9faec36146db65692a83f01024ae6b8951b346c8f55b8711f42a4aa244e9203b942fb4b9cf04e8d6bb0fb6d1277d39789efce3494034399d78cacafc79bc9c8e22fe3967ee68dd0f98facb831edba30baf52920363330cd16b5d84a8ef8f01d90aacff77f09149fbffca44dd95d37192778da7db8aa6c184d738b2ce0132676509334ee5166c7109dfee62fd976fb83c7e1353286ffc75817ffd4db2d2627dee1585ff961721c80d86d18f686b95da50ebbbf9308b108d6302a1130ccb6304669c23c59e8ab6b464072f4ba12ba6358eec6b8cbd5f99fcbe7d278bff82c09c7f547de57fd6bca70fbc7a7c7d00702298c163072d1e77b56dbb1450b8a94b950d97d3ae55ff5072889ecaa406befee15fe104c48c1f30eec3b071765040056ea02e136e2bbd13f07189a2968057c95e06302208331ef306aea18ee51813ed5b3b13309a7af8525d672f723e07996ba93df984fec812a47e92ed72b1669f7be0d4c594bfbfb4f48ee2e69aade00c446acc6dd2b157b41f2aefe590c84704bb5e4038c3a557ad99cf7d3270e6094477fde0ef1fed1fa59da2786d324c9e1db5d087d5158ebafbbfd830354f2faa2f29f1f83f5a1e1e90742ab96a77b0431fa9021341e4b9cc79e06ee7da0c9ce01d4f56ee105a444183c01dde687d8c2b78b8a401aa69d3368d7952ebbe8c020c04ddb68b0dc9b8f9d969623a9c5fa37d18d087ffcb4a7a8ebc8919a3503aeef7424abc82f526261fa1fbf7925d797bf7d774bc193bf3a9eb8826e28e867cd9cb84919df4baf5101ecf3b3da166c85f4870792923359f5aaf1a3159d8142d104a10e81c2f5c722a9426ea324b8acb5b6a5464ac1584238a24c2ebd844ee81d456c0ccd273dce223624a41c03b1054c9ab590e30551be085807754182413bd6eaa80b1627ea9279322f56b890f8c5a911da4c919325718441b4d812ae4c86f2dd4fdbfd193d092ba86cf48f14419c4b5d9e79d06badc11788ba5beb1af9b25e25913e0f9b4b6f73a455fda440f2f1285cc52baf7061444d29ceefbf385c41b5f600c11f7d8937b7341031158962f6b7ed400b12ec96051ca3e1dfc03b6fa36e5b83ada9f5a51ffc0f7590dff26ef9f2069cd7066037ab3753c906f62c22bf65ae2a39633ba34845dd789d5262ee1318b455c3e66e34aaf3c0c423389032b40343a521f78438dfc47964930b6bfc9a4f1b236600b38cc292c42f29f91e5963af38cc422ef8fb526df4787455ef7ec7e195faf3c8566dcedf829741b5206ddd80a8bbf7868eabe4b0c697bdae377d06bc3ad9e5bb07d86e8a753ac0c1fe85952603b8b28cc91245baec5f663bcbe3e89f87093e34595b6364f5a97e817e92b52bb4e2d235e82d534c5096d534c911f3644ba7cb095a609c3e5f4843973a99038218ea104ca4a90a528d25093a0342d175eb7e467d169fcc34fbc0e15fb51b7038a1b62ecee917396dcfde5551c4bd63aa39cf649f5c2caa84bea487c586bec2f7c1435629dbc7876b6d10e7f22b57a0b4c7b5930706a70313c97dbffd1707fe973351a9c3d23e980b0f84d55d241a0b2d9eb62f7fd374573ef050a2b4c42a55f39b3e67a52a652a4a7fc946565c9ee0093a3794dcc60a6e2310d8b0d9e9fce2d64f2b35f27b9d054942a448c140e69677c5aa8aaa00e655e6d01316992cf92a9074a6ad4cfe8db802467ab713cc8ad286af75048aa6f21d4adec750ba6ef9209472a0630cdc61ee6fc5a257c9de3191b86a161a7ba8accc31c4b0dcb50dca2c3d1881f9093d1c9858d6d30befdea72355b30f7b7e0f2b69a0351073f131bc8c1ec176c729345ea8d29488e47f32c52ee15881684170141dece71bd7437365ba60f6db45e91a2ccd8e57f47744708c90b8818a415ad97c5eea2e46f5492ec7291387ed5136cd15a6d5b5398f7928861f566fb7b45e1d08c70b24c6491efeda80de12e9cc708051ccecc8a2693589d8fc87bc4257d2805a2b84d5b514c168dce6d72cad17989831ca5cd8f78182927ab49acac729a27eabf28b7bfc4073ee822bb89ef35086a53b96abe68149f75b9f890a1c761c3ec986f5a2ab7a0454f43b54e996de13a4f3f48cde2f847913d92f6b36cd705fcbc0dad97207e7fe22041f0c5500cf8eb3dc3fcab260ef2f1b9bf4d1c4290d3e2cfdadabf5053789e7be151eb0126da21b6bcca1771698ca07410b2d4153b0885e2f4ea7d0a6a579227305e87428fd4dfa2047c06d7a50e369a79ade42f403b553043e0c39486d80e29594c5b09b6df3825a8755a40cccd4bb44910ce67f4224216218648c96319b862fa193b9abd78ab091ce0a4d8148232e0aab0ba29a5290fb55d6c870eb78498cf64218e416e6635fd1d4a91922fc4f03b522a6fc32b12d855260ee457e9a81ace20ab523b025539e1a44f3511ea8476962e858318316f3cf8fb3ada0263042924b8008de52f4aeaba92479f58839c142a281e869004b071536d32bd406fb9c78702ebd9ecc5d5d68aa83ea28b0d015958c4f41b1b5351183d3c17979924db3fec3d5e602cb3933ebe53bcfa64724e3636d3e89156367b1a60758690dd32ee9f53a57f36a272e7cc893d2348436cf28f06696408c129cb248948e107f2665e6289202fa37c1750732894127698cca0667418d471fa5adde3f88ed4c54ea8927838e00b6547e69108668f8d1e301e5407051d897ea3f348ad3ed252580040a7f078b087815320bbf987b6ba96e96ee9595c8169055b1a69c9063baf8036b271ed1f712fec65ed502ec9d813cc86595dbe5b8b588486aa85852aa6b7c903338bc9dd7279b3969ddd9900f1922b6a3090df7757d5c7534b1a964d46245f1ed355f2ce282f21ac275329a0f4f5d9aaa883defe25b180a910fe43dfa73e7bddb44f584d1071257b9702c4cf1f1b64b1114e95333e6cb512f2f01dadcca51571e1ddf9f799e466c524cd816d08cf02a78f236417fb0c977328d263f750dc0c5dccfd27e431878ae4e66847aafad053a70eb4d8a07aa152b16147ddd360b988156b0e1209a7de60d8897f68350284421a307fd6a6c4b71804756ada9c48712cee61496b5184a55884465dae626fdaa1782201c59871c8e97bcb6262bd30da2500ba6577243adec43d60ed5cb6c3554765871005a518cc72c50782151938b1b87e2afc7d7664cbc654288a13878f97cb459de98b26de66a35f9084921d2df2fe7a7c2a1659b4dd5fd640fbb46b33701e92a813f6f81fcfef374459b444b2732673ce0ef83080c603d0d0fb83c18ebce58c5766543490c716c2508d8c1e98e7a640529956ba44ef5f5b01ba7f27fa1a34c0834782a431433c0dc9a9d32baaef81441eb1cd5507839911f219b0baab9c9bb5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
