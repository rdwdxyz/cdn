<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41e9b40fb6146f1244e485f7fc89d150cdfd91a1ebc31919da1ea5dd05781d413e76a78b02131e11065f9d69321e776b3c29902d28d3baebb650935dda7e5cb3b84eee4442fa9ce2f221ee88e4fe623c59801bbcf78edeba9206dce0ed80947d6334dc056d30f7f8d8800de553b0bc7801ae1d2ed4a7293eda9dd393717ab4b297b9e22193c8f2be985fe86a838bb74ea961274571b5a9492a68b187ff02493f1afc5d70dd5e6b118d8c601f35bef058d28271c505630f42a816044c531a32215a82f7c0fb38f4752ddc0e14292a0e247d6d3f0a14cdb6f41ce073bd65ca3eba7aec8928063b7741e618919f6de90c91c49311bd31fdcc7ad111e4c07e1500acfea121b7ae7d077e9ccdcce24861a1d409db1eb5e7f53933fd8932ce46e94d137b03ba2875169bc067fa42852118ae8ca855a9204e2d52f011a143e7b14081f6a7f8e4b55b1f81c63054bc055634d033ad7008f85c4590fea068fc40cfa95f2745d859b310353f6238a63c8ef831596f49e04e422b0af35818411a525137a1caf67efceb807ca8847e4752278c469fc33eb0f8001b2ac9b93befc325590a589f14ba4d9c3eee149077d0b457c60f9f746c109151b3619583f9109bb930f02d26bf469a7fe55b1e032fcd8454a23bc2159a388cf7103e14ef1b37e9c0930d498454ac49780e8a6d0117f14bcd9d7de4a98efe78eda29e90e6647fbd23176b7b91ce39531602ff94415c8aff5fa9fe9b8bf4fad7324554df3562f08fbc41527628417e66f13b534ac557b3da061a7ff1107e3b5e31486b5f43b8e7b70c0cc32799d05e31688da5b570b07a71983f5d2830231dffbd62d540a8e9e7c30e380e62317f5111d7289355593c2437e402091ef3226eafc7b839a48a4eb9d43eceb2d24e76fd5c51b7f378b2580bafdbfeed0603b71773fbbd8e944cfdc8dcf2c40009748374d229328e5f9c93edc4fa1bd4611ca4c9da45798548a101697bab0c22d9461ffa68e676038aab4f50ef7f8252b0bd16c6287cabd745e7dd1274dcc20f7db20c8092d901ee593c1deef7c1bb9418806957f759c3ef2828d21c13293472bace15aec7191080dd636851e0b9ea4d37471051aa4a0febc3d79ee289ec299f28db06e4d3731bfbaceaeb70f029734ec5a21f8917ba38c199c8d86b58e5da8b6c210985ac89df07fe2010236547f3c29b7093dd5c4e2396d1f7fbc7e8bf5c8ddd721b7f4ce9ece2b18a5af6bcbf9af2ab001b316386fa56b4ca1e92a69bb4724c8412b728aaaccaa1790e95aa5c8571ff66a78088250e9b252b7d5cb9299e848516c2f2357217a132f3fcf6c14638be035e3ef2aa2dfedbe7703291d17e50b4af785f440b0e5e33999254af7f90601d662e3e11f41b77f353fb2eb8e5dbb3b7da8ccd49ad50020c7d1119788808c380052275734e8c98661288e3fc7d4877f82ab619bc3bc89ce1009b0a3c2aa68052bab2761e3ee019b78402c5a83c2bc42e669a06f0f3e5f78b37147abd395220f548c3430906ec29e950f37661a9f573a9ffa343bead8c2cc3e1119e595c5b611dafd9f0c52068ced5acde07e993d365f7f17e453bf1fefa4d5f8f262826a3a1bbefb351fbf5d08e1d5dbad74e6dbcb4a980c7ed634a1c7514a70a6bc79c2974c5879622f7d762379a83c6ccf441b5355cea2ade8a778924ba79c340d41048d5354ada45ebf6120d57d0aab592a01432b39c908c1683034ee6273935d28cc3b25dc1186ebfb919ee22464bdd8ec3d29089b3336d676ca021362cdf641fa7d1c606f5cedd5a81496e9a522dfa2aeb6a41677327e54488ee3ecfb1f0cc7fe92587d1d8d4a4ee9dbdca40438dcdee1442543b6e7ff8e6a891136e1ed305e0963c236a19c132a6c7de3c4ede63801cd7c8a9ff5f25ffcb59e4862edd5628b0a71f14c4db5cf427cbe15f9f9c84256eaea9792f9e8d280bc696a3ae29192366e11d18e9eb54122608dc8e4e3c67c82d0fdc2fdd178304fd773caa8a4cc24ebb4fcbcb9a5fbce0c4ef366f2f608bd529f5f59f75aa7764574d96cd74b310d51d233bc3dfb63dcdf0c4b3482f25f94429756f319bc433c4ad23e7eb0b2da5549e4adbb303a854576c63ac2f75d1befe698751cb4a9f54700a5fd06fca5e6e3baeec138aa6c457bafc283d7c6e05e86a620dc2ba195bdc982d9386e526b61e74af373dedf50cf588f1baeff7eb2469ffae95977e5ac1d7f17507d425341e90fe4edda1ed72c173f259cc8d9659aeb9208e8334a8702ab7998f82308426cdb4bafd9316d38275116a2940c63ca85a26a3d0a1ba16fc1b79f013f4dc96467eaaf0dbb2da585521a36e62531441776e718543d4954befd9984e5e8ae5eb514060dee3df127ef74b1685a180ab42b6917ef45779129399fa5ea512287456df78318445629ee580195031b0a4c99e9da34e9a19c4f5630b8958a7f1d8ca8b8a9ebd60894c95bb14042732b41a8736d12d50f613216acef38a710fa623126738670be01292e5342ce79e828e5eaea319b2ace485aad8cfff5e89819ae2437fdb0359a98e27f13ab9b7b5e73edd3b38f79d137372a3913488423dbe3a443154a77f7b57b4f94d54551d42d7a944ef5b9af83df72f598b6e772c0ac6df5a6b8036f94ef0c914c535b895e804e23208cc8dd519c9cb0d605a8479fbf28419846468aa88e2417c579a8c5e63d59d9c8b15689a770e0cdd2c6b0ebdb6951d06f35e5486240f55462b6630d054960361067f0b007b59d8f21a0498763984e8ff5acc008882eb54459cad480b0f39a9f8897a94d986e211d9f4b400f04b0db54e2103eda49618047ddb3c8462f54414b373fd6426806683b8136eeaef9ebd5c4adbbc40bfafccd5a7003be0aa1775373c490a5cbebfa337f218b2e764c3259227c26086531f949edf24d1327d9c36a24dfba28fd9ee4a2e7650c39449c8dc08c7230e49ae8a7b7b983cf83b348dc3f8ce7f4faf00531d709b02652b1f26ef37b68af4ca4769e2f1c08f5e5c73c997609a370403ef122e8bf097cdaf85e0a1dc6c13de033ec11c84801ea748cc9f1885985ee989698863e03134869c0ba4a21a55b4b72ba44def3d2c074949b853226f60a786753c319b5a715800032d968647f2fc191f3a993244fdc1ed0fcd9d6ceeb74b8920557f4f4612b4f563ad2e10f70b16600bbc0f8b6a6a689ae4631c38916e9d7c6d3a028ab81cf833bdebf20421a98f2982b62ef591b8692929ca29670b9f6bdd7741f81ae16feabf805edf68dc0a150e8f9b21bd3790638f0b3f596d0fc0f64cc8471a7456d26f54e07b11e8e5dfa5724f6154161a58b565035431c37188ed3384b338a0bd52ecd1f51a0f87f10d3102466ce5e4cb0c22dc5ec099508aaf6e13b32e7f5697347549208c52dde25f686693ddf9ad261fac7ed2fc6c16e9d05f06a1cbf8179dda0f75f66c53e22befa675510481fdb812f467c5449dca853ff367eee461b92c3e2c7ce369f64d30768d9ace6de518d77222891ef269d84b0ac06d9104820f52616d48db4c3688c1da6283d50f6220a3f25e854d10a0c089ae30fd812a1cd192ff16be418c8b479d887f6eb8648edd60d4e89da5a55b1165b11a1213dbaed1ff3a5bb6c32255627a65a1fd20254417f092f374061b8f9b40dddc1d74c0813bc37d6d2fe1deb99ad8fd4c520bfb0b1f457924089115e851ba73949db0e7020dcb0f8acc7e464616b3255fb30fb1b7554b7c15ef71a774637ea32c34a9b40d6333094993781952428fbd148852a619a684935a0271a8aa70792b57b8316d57870f574a3b70b7c2460466183de46014278835f70aea550b3be117f810b344c3c41761cb9d6d63416c3cd368724f5abf73056793ed2c243d7edc239dfd61f98b5055311b098af281cad8344bf9aa1c7a7cee953c14482a721fa66aa0738c0b79885269715846049691e741a67dd0a1e6a980e1d00c3a781bdc0f233088b829f204ee4bd25333744848c0b3ddb4bac3da03829d6b4654819ef4372d0a3eea7691e3ae45c0e85fc7579971081b53457d514a2b974e7407b3dfb6144ec43208a43a7248ae198b9f4def99acc8068ed163bc4661bfa173419397db5f86e74fa7e94a69336dd3f5e21cdb2fc37705b674663e24ac890c60794cdf5be5db67a8477000fd79cff74b5bed9a89d579ae6fd4f7841ba03cf7be1ac16ccb376fb4d72bd66046c89a1806698d71ad37cc043e881d18893a29f735f4dccbfe1ebf7969c06f36dddc4ae9d095456157abbdcb2e6ef6437ab93f13cec7f19b05b3131cb0e5a4978d8fac62a7497ad9015fa680b384e9efaeb939573fc8fc2838337df21a3e27ee83be637c5fd39b0f5371784f4a980320687db6432669d5390080244209bf04f22236efcb60955c712ccba75b174ff3c22fbbc50a2cab17402cee8d8c5718e4a9840104fd126ddc07b499ce63a9712995e0a89d36c317beb03a9ec2e34f2261dd181cb84b5b209b8a59a497580f801db7bb02e17c372470ede7b091612e0eb9be99cd8dabf867dd17a09aa9a53a4a7d1b22ec6d6ea183bc1d922904afd954a2af6ee2dd1ce4dc6ae64e5964a57b8b0185ca2e0384655cdc9071a081dfabc807f65a0e70b7fd447bc3460b3c4b5034604b075cc75fb1b013768cdd9081995931e238d9443811ee085f233e9f838a00768450d7a9312de586b63aa3c05bdb9681207838fce1d8b081dcbdd77a4daf655ced5e4a44fb75046d6ce67d0bad200cc539030a2f2b0556b9faf17d860e29c72a547ba494557aef902c879b3d50f9a92507ac217a8af162bd28555d5790ae97bb77082b5cf5a0a29d5d78ff1cbf1d9415bf7f8103f46e5cde6b47a8453549180f7d6bb827fe723ecc0b8fed03565613d2aa371dfe5725df2586616749aac31884aac9c4dfa4f161962ffcb97befcd900758848b366de5579aceba8db4f1ad952890e19fa8744f5ffa8a9cb8da01cbb30ec0960209b8b75acba70d2453186547941af63b5b427c9b4500e89a79a4bb19db3854bcac1daca42b819fb82dec868b9b5fc35ab98b835762a1ec8c5e3fdbc3cceee92c6f4255cbc187d245d3b203d55c1d404775dbaa7784a63d1342fb9e95889f9a6fb5912d1eae17b0ad94bf95d7ac680eb7a018c95cee6475367b109a63375f61513703a21c49385448cd5dced9b85ff92b3a2f009bfcd05f72749640b75f8166bd052a2559442cd2ea8117d6882383d32c52d1ff0662bcc615fac595247c22c31b28d0df630390ec8f362400f5208c30fc14eb28c92ae9f3cad01615d32efbd6eed3440e86c6a9199f99c2385780de89cd8acaee8b7cd017117719e61647bea0d7bff8bdaa8c7adfcfd8235f2e3ec9380b3638b2ccdbca0526a1641302b7a2ecab4a7897d1196892a0d2151b04d8e3888ff090298e74e01d0c4f35cf5c674421e567eb5d5b1259b3d16e79edc15bfecd1bc1766eb48250cc9ac2b5816b2da46569e9141fde42b3c41c24873f67791377a75ddc747f4802a515410bf42e42b008d0d8f349eb2e43eeb6184c9874c8594ec8adfd11627b3516bae1caa30756ce3857df58547398022609fdf3f98a206d8f2abeb827b8e28223c32d6bca4727b5593286ce3e524600d1aef3fda75429f0db61ce3a4312bafb7d3db7884743c5f8f5d8ac7ab94a0915a6ece04e003cfd31193bd0dc86918e7bc9ea29bd6fdc3ea084558c1ba110336cac34f82bc0f3ddc0cac0b3fd86c1ee4a17394471b42d8f0eaae42b889908abc744e38e8d0acc039802bbcc429c68bab95de71070ef0407e272b15addac12778f73b7b8a89aa9c71612701cf7dd9bdd30667f9204f0135ffb997a9f7f73633de5eef01db08795782accb68acca6cae7ac571d4f69b5a79b5ca06b5b90499d4b5cd5a7957418b42746701058fcd511a4599cc85ae0aea4d6ebdea9ba5c0426f1b652adbe32485c4d28fb9ce3c539ffee2203ac649c09b63d23423a92ccf4e22909c2f2224047cede10aaefb95b8adfcbf3919d99b56a7ce00accd69836c4fbd075b58ec33362f49a9f8e01911a86c4c71f2429269f63cd977f9cca5f91f5b39e01695bccf6a76310cfeebfd1aadfdd600ccfb945baba34b7963c0e8da5c58ea6ead78a376452d424172022f8fe63ca0de35720af26489a14122b6ee8f8a515bbdf2ae0c99637ccdbe3a24cc300af0022eac36f35719f8a9483452db45c257981669c6e2e92838bffeff5f5c732903398bdbdf8d832a01f5fc2dbd9866aa90fd399475b7e850e47efab87d873c46a67138eb19f06e355af432fcd44ea312ad488b7716f36234dfffea2abc4770bfee771f748e95b5ea7928abffdc39a8c496117aaa39a930eb3677ea6d55d53763011b4fd75e8344c77a9e068d5be095cbcc6bb62f2b7b04f6beb05e202fa8f30bddb75ccff55cb99b944ce32ae50556ded61d2c25ce795ad7d272f95aa81844b11f885dbc701f743cebea8dd3014112f7ccf4325e426bd0819140f50526abd262eee86b6c64bbbc4dd5d6b37378fe52a55696ba7068881d5c5566495c7f9b0150f25f68bfc4d1cacdee7bbd3946fd8921c156e885c52c93af0a03569d1056e09d4f7a4a013813acf1a014e1853a1a84eddf9d1b2cfb6e6bfeb65777bf0cb7712474e60fb124c37cee21c44154f57f0b7a804f91e71dfeb0a4dfa00a7063c51b0737091325052c4de5d53bf4e0a514099d5b527916c521873de3df5cbc9f768a212e8fa5c97c0a2a5fb809cae14d3d53b4798386a3269329378456a1cc64831bfaf1802040d29d0ce81d5ffdcf1e39a32320cbb78729c122d8960a87199edeab2d6c30c85cfcccd3c4f5e1c2b8f4f5d39cd4b71a1ffd7a565778aab4eb37e9452ea329e7ad7fee3f0080b6348a75320b9b5d030a84a50b4a07ea75496a62a51ba0bc57d3b05f5b7cf8ba3e666b27f31070cee935b0091e40f2f547e9cd31d65034aa82c2f06ce6fe02425f6616a2898608017dc0cdd2c0e75f658b5e874a99667be5e59fcbbeaf66603040b379452f40b2146c4c5f17f6600de730987f9b60cc10335235d6ceca17efeda23bf8cb958a00d528641ba24b88610340de8b33e8d93c46555d296950492c4c3e8425958517906e6db7c875ce08f2b036879e60ce62eb7d0f0d710bd155fe2b2eac8d8e8439d88d243e2eb77cca3c22103c1d44fa15b5d9015bec870432eed7807d83b74f93cc2e8f9e69d23b220e2f2db58dd2d3c6727bfe2beb8bad1f5a9771d400ae9826b970eb72ce56a96ed87ea365439426948cea06c87eb7b29f9777a3e1806dcdb36eefd6621f270eaa401ab0e765695cad20de3f75249a2f5e133d2d2305ea9b5291bbda5f7f1d02a91613bd3ef1720cc13c22229b991f7f58eb9c303a9fdfd63a35028c21dd0130530f6b3d078d00f1807ea6c96057a47764ffa1e6f5166104b85bd860c80a20b240c7d3811e674817bc86d710d8e20762465fc68476851bd6f058af073c75e9e4f53ca40f7c68e7af30e0fccd7e04eb3a81a6182c002d240fb697833677a644eaef7b3559b7ada47ebe61f6827cefe8fc2a9cdd691a648116463f0a9677b7f23e3efd6f12f7f061160c6118b61a251c207cae4a57b289b407ce9730e46420273dc3754857605d0700f52d4e0ab0fe44245e71597b8fd28b3584239aef370a5e4029dda83973d703fdfecc2aff469d90a3a11dee1090432a77ba634d9db344d9cadba0e45b78742cf9c45ee56e97129555f7e3dde6a849de1d398a540f13f02ef86e977d86eef176308cc10cceb176d66d36b0940ffaafab54ac5b5d6e399b2569d6cf9e2532e761a338e8f3c6b30fb328af0d9cd6111776984aabeda4a12cdb6b6591343c40aab21819c4b7d298c565c741ee8aeb6f9a279ca40efbb73522f8d916827ab8056a0318092d6eac244c10aed531d96afa842430fd915f5420f3daf051929f3b469a0df439604dc2f26829a8dc972e312e5add6940ddfd5c64d46de4563acc98e53e003810acf69f983eb9e9501c55378692d718618e1636df40d3fda1444a08935043c1d12bbc89533d870c2825b51bda68a88da0fb158845ac640c6ba5fc60856d21781fec8b14241d0f1c44b7ad85ca3967ab3c77738bd5144141a1efd7a1dc0c4e4cb2e2b5aa2aed11330611186a4d06b3b3dc8de021a1898e59369759d3966f2339749ad92a91556ca996f0bddb0b89e3509b0368b80180b04a59153f90dd17370246fa34310afa62b9cf7be5667493db2fd84c5c6e02fbddfd0c94cbd0aff51a43a7c092401dbb2df2d5700a3c30e02a61c2f2a514d6906f7c64ab7714335b8c0a5798cb840be5a8688002c55bffbe81e12dde4eb027a8b3b94a9b35a9bbcb6fefd8541f575e85c0b93b4d1e8006a52969a75b6e0d6303ecdecf1874326e277a19da6366c307fd8a14f7927da7cf37f3ccae70da1a742e37e0e10c780472b442c4a50524bbd294fb08794b4b1e604339bbbcd276cacd84390bc0415aaea8fa769e2eb7accb16bcc08e7ab83bb3ab330353ac05de450ca48bfc2574e08783910f22bcf101ae92674d0f957430327bcc69fe9dcf059c4eb0ebc96450c69d6295c3f46609d9b6d210bd9e781ea0b0ed623bff532fa6b137e08d4763abdbb2c68bb469f0fd7cf8e23f0785082174c095691ad08b5939bee221eb7f8276986bbaad92624efe99ada4b1a3d716238003e13f7abc478b2e3997e36f57c9ca60caca6859d9aa8b09a8b6f57d436cf0f249c10037563351434a0bbc7e6ff2580f6b2cad5dd61e5d1f58655da336d0992b69b204f5892d2d3dafed25070faf2e07579d798cb7020d064453f1489b449c0d36aa75ea2d3cc260b2a12718115780b07ef89a3660677c3e1a8a596408588f2020fee748fca0e13603fab609884fb59e723a956c0b2b5002c303263f87dc77dd1677126d90c5aecdcfb6f96dfdf9f9934c44ca8b80c02bf3b2abbd4b4518409b0a1fa5ea824901ae4f7caff179096324a948b1609f2e9db3d091f2c69d3747545d47b370b08a692ffc3726dbacb2f0df44feb040accd8d5508bd9867b0c5e48e097aa10f186b0327c4259a6bffafd1e02c6069e6b7c2d6a54837121db8f4dcfa1fff57fa56e02ca3b3be01ecef63d805e74471ad77be16ac3946bef818a588e1e6321bcb872a63a040a6ebc2344cc0273a3b91c7e8a3782cf07ae795caaef7de0376a688c4307f581bd0a6ce38513b9ff9e4aa2a4d53d4a0ce2fba782e27c1c264b8563d1baa125250f31bb2d3f39075a7db0c164ee90311540eda18ae8d6207c04ce2f06af333f66b5970a5692531bdc24594dab63a0d7a534b44f46c14d2eb16e3ff2fd4bbf89dc9d70f23a6b7c80c727cb3e23e10796fede915b94f057d582bb4664a0c2b4e4dfcd328aff1c210f360b7e45138c3f495a643467294e41378d5b4f1a593c9079c344b7e2280c38c149fe93ad42e9b93cefd6f9fd0ab1cc44d87faae242239394e14010fadd4040ee665c506685bba558dc4171ae0da603bff7252ade0f97523d30dc4ab32626dd20e221474c2f6a7dfbeb8627e5774ee98ae5b125893969671a1998b9ba18850077c2d923b8b7b3944281870602272b8d0f994e9bb3b3c01aea78ad4b73c98ebf7a5f02115e817a32c3021d7dea436dc846922f70bbce029bbffd72dc924dee84f544b7e738dd36a583290a3b1fc4acc9efe1d29cb392d319efb473939270929048c1ed8507e3668aa0933bc5f6563c258f925ec6f4cf854f06ecc25d4acb3738dc72a7f525b2a0608d207086b9178acc9b88e4969b6957c5444f0328467e374aa53faad813ff846fc231e89a5fd696900bb6b7f9e4c1467dcc424b4ac5197d28b02c329b2c50a51b1a77b2de88a903b0feaa0ddcc6ea3e70c977b3646bc73fafbaa4ee8661ccafb1f9134334539bb7a486a9161f20cd3e41480fa75e501c6e6847ddc4dbbe36e9555aa7b142d4e290a4afdf43517d5c29bf0c48e22138a91c38b08c360de20d0ba922f7eae9ac310cc22dc6d2756ae3b625ec3b06278f8fb00cb16c2c4ed41b7b3836ba0e5b99e7fc4015e7e6f58c90b2f2c7b70890596d1d9f4bb58845889a57c4e24957d38d47135fe273ac5d1bacec27de60c316419d015da2f5db7c2e232c2f82a3f857723e5d06e9e1fab8a105fcdbedb12fd0ae968cafc472ed5b7f4400e29600d9bb470b146589cfbbf5c27fe7dbcb30ca23a7758b4d182ef83059d18d276e90a7d2dcd25ae2edce072da960a00a9d898da1b1d729286536300a8928ef80e82209809ed65879c1e44f288855aac11b8bf23a7e515f56e465515364c6f0f24967a4bc5e06e9ae13a2fec6594525cb91857f6ef0ac8a54c0b11548a8389cbcd5f3185cc49e02368bf60069a1a01bb7a6c47766f80b7d447c1804351126daa7349155bc62703582f8a2965216a214dc6d7ee44e696757794debe2699ffb018edfd14912b0e7c68998ea52ac6bef964021271b27a551294c2fe2c6ceee2317a4760fb4665fa7ebac275e68df683e3dd2a78b80430c16be8580f80f347c526d8cfad1473c1bf89c6d0e6f4f257469ad81fed1fd9d69e07aed9c6ed0bc7dba4daa4fd4d937932bb941d5fc265fb498a1352ffe357b57e5f55ade2575926078fa07348d27923723048e0fd7779e4fe59eb30cace10705389f530dda4a145d5f753f2a8fa2dc146eca3a8f94a9875a7be4ae7e4d1e011fa593e7d039470ff40c0aa90cf67fdeb0c75dccb927d6281111e1f954cf8833672697d9cc17d86ccac057fe339ec5d2f41003b1d8a38f69b9a160ee48343df001efa0b1babde1ca0643102b8ff1fdf2c6c4bbf4ecee0366619b75b91c20464953839458e6dcdb3a2400a99fdde35c0502f1366f54e0094677a058fa896f5a8c462d146af7888a2b2874236140cab744a54ad26b3e4ee7026a48493e0f4dc7f4424c472644ec4422196fe6b6b0dbdcbe34de1635c7bef7d65c8af97699d643c3d7273977833953628d1917a4df1b9feeed8097f1c2e994573f3a530f3ec0572f092436b695c909997d8a66837e9b02e2a868d5845c48904d62dd6fd7a0af76bbfa2d40d083ccabdd0ea84d5c26edd36af7d08e1873d56207cb65d42efe820d50065ea5b109399d87677c07fea407c1fdf1450055a706f079de7684f9529edcf180e1c0a0b79512406e23d00102a650234d05ce82364e9c3f31d6c6786241027a8859a2ff54688fafb530bbeed2b8e3a02ee029fcc4940ae11b693a46f733b18ea1332215089540e74fdc20fb8cdb6c2997b48ad931c58898ecc528e41d31fd53e2a585dc92246fadaa9c35ee4ae2c0fa3b9236b3ce3fe727f4a3893e4f24c89096ff7feeaeb4898d759ae03f43fc0d5a9654d14815175097b3d04cc81e98def70e180adb58d9ce7727ec881b5e49853a0b2a5b61d42aac6f40245438657b0a9377890ab296f5cb51d3d4c1adec33f040b7b16b04d09775a720b0333c241706a91808cfa21dd8b091ebc313909ae3078765b18fb5b675d2185ff881fce4bbd818489a807699273fa455896568612091864830eab4212a7ab9e8768ef2993cd96c47dbb20da2d3d424fb1b7fdf6d018194bbf5b2c2c89565817519287eb7fdde0f52d7994dabbfb3b82b3737832ef4d45268e4be01e548653e9821c0b5703171ebcad5e4411d3f1c9cf2c4b06ef6f23c776a289da8e6971c6ca18a8169f10d22db7ac1d441e4831696455f37b5c5712754e8c24f586688a91bb6186da502bd3a6cb67a270b22a0b667d43f4feeced32a55f6613294ca23336eba343c1fe3e40da2499cdafaacd8259e674b7e1893032682edf104dfff19d667b318d5e5fb16cfe39ebad1db5b29780d636fef93b425e98e7dc4535186714c6a1b352ea656067228a255c1ca67699f3a03d4977fd2b32670bcbd5a99d13581c96007f2e565b00150667a40eb13d91a059379e4d775db428b6d8df17bbfd5a1b1128eee4719d8cdfbfbeabc19f2d4146985da6e51332a29b455682b6f29532ff74e185ed4ee53faf9bcda9ee2d8de7a0e46a106a3426320f370a2614ace41e58184ab82765e73263f86524cfd03dde0de51cee4f90875b042292216ef2bb6180fa6832280f28e563a3cbeed8245408c200898add9548647020c8fd4d091bbdad81b97abaabdab1dfefca58aa5bd736b01a59489485e1b4daf858cb5e784dd01bc51341276fccc8ac083615af37a095fb70d80d1bae66300506f6e1a18dbb0d29cf4db8b23b58b1137a030576ed9a92b3b430a0c36ad50308c1ca845f9deefba791ce0e153496b3efbdf5ca1343a482aa59b8b76e079788536b660ff992e43a48eae45c7171e721894fd88432856d66ef3276e4215e67aaf8ca5608466b4b31a34de5e60fad787b477425bd8c8e4611f28ab4cde722a0101e161187952d7d97129cfa0f8334acf8596375b45d96ee305c93f49d9f769c0ebee9db4de7533253a0965cac3a5f0f459a5d698aa30b8410bd264eec83dd3847a6da039116dd94a3f848a93be2b45df2d952767443af57685e3b7e4f7e58f7f2e7b0f0c05d4d830ef330006a5ef1923d37ac6b90d30ed1a3211c455b9fe5a5fd499a9efa2bd60de1d391cf7f929f57d3e3e5c1e239550f313ad21d0207e7845d71de333074649b37e98daa40b72142d1495917b650f37c3a602f1ea23e82612c58c71b03be2091fbb0d27ac8c8383d9849f3900e3f51dd54b734e31677668bdb47b17d9bf702cb92e9e8805cf00cb3dd69c3783bae7ac7279f32b67014ee96f4cdf582e3ebd945f07d39d3d183990634934cc70e6536f90507c9767f0c79bce22fa5a4e2d3e39b4b31759af0333ead933bac1c919f3e64658b9c1217cfa83d0c967366af9fd4a698ab78892e889de43ea134dcdb45a6ba1d5478ee33a7f53be15cdf1dcfc06dec4b87ed6518caa176825c3757200473b7f7c0d789496f1eb32ef26608cd02612e2351525a7c1e810b1ca46da41e4ae4691e24d3d0d274114fe2a31da15e1fa288684568b492f84e635cd508f6907fdee6b07956f99613a883d27e6124c686a3a83cb2d93c2a6458e0da3b847c0b9853b59c9786428f6b75b2ffc3363b1a66b61ee1977eaab21273dc6875a852c6080b0f07ed56851c129d0a26fa4baf852f7f72f4c313c6a2f6f8b8b0f9c42c89710e82fa1819453f150ab077e0a48ac64c5003971a5b76a8982cddf9d1e83c10546787e95ede48bfea5f41c7e3c78aab1ef4eaaad1ea2acea5da9a96713073c00524c7a4205fd3a0079c30a8366860a51cb09ece0e07007bb38410f712bf8a80624480bff4d546c26214b656024bbb0516f26b87c182f79d9bfe0f800911f874980475370187adcf8f126d36434b5224daea49cacfac3ece2215fb6a1dd295d587169fff47f051b16e0bfbf1e93a647ef44e5d19e86ca666badba7f9f0f0b2281d7fefe3014628c56704340e3cfc7eb85a7c1b77344ebebd1bec27aeedfd655d4c206d0be2bcaf64d9efc1a97a02471f06bffd93510ff7ec83e077cb98b614807a92473590ee0265233af4389958c6a4d3788dd596b49534a17c1aeb94587b74f6e4d6287a9c7ed18a2ec86b1f24473488d609c3c8458acb099f00c6815488cf04dc08489ab3254510dc572746d42ee0f0149a1adb17a86caabdc22bfc53ccb9c7661ad1e43cf4a94dc545f04be25dfb2a818b1bdedea8157616fde46e5333010a7d34fb94f33024633a784165ed0dfb4f9f671f62a14f73a657150bca137efecaf517234187403dd89e89e79645db67fbeb0cae646d1c2a0b12ce7b103d17da78e9918c85150cb2b2fa6f97e1ea74098e369ea4d712b119708a4033facfb895308d8c368f1e379f266ee9ec63ea691ed3efc6a7458f00d92d851f4f2dcc4383001a015b9980fc2f901c0e8e66f4f29835b7dd0e5263dc8044c2c5bfa06efa84968522c8ebd231c780a5a4cc37627f0fd091c137ae174779b547a5169c061b7ae26176a834341fbc05edf56ac51ff0cdb876d47b257fd29b902fd1c1e692ba08c96cd9ab48505663876cba2fd5b33c52f96f63db2573e7ccf3d448a8542a6f5ff0aa500ec84a19737725328d7bcc83f7ccd4ffb5d6f4bdd2beeb1cc2aa2c158e865628d308e6d5c1753db391bfc83ef3804e7bc8d5f0d2a7095550c69d41ed9a285aff76a87bc1df877f56628ebde3e532dbf24ca1b53cfcde23d3128457c5752ccca98ac06cfdf0b78c572084e7706623174bfd869ccc304f22280dc0abc1528fc14b57cadcabf30ac5da3828ba2093d78f8d8b6771f8b22341845003b12ab1324bf52429a3bd4d002be2e995a346dd5885aaa4252c80e70e6f6cbc48515d1162be8c28f004b8fc570ede4dda15185db2cd523322fffcb22acca6d7bbd3b687ec2d3659e3c6454585b2abe4f93f8ac81edade732a364e395a1d3a7a905dcce98e99447f4a4bb6dc022eb1757f2d10058e5da683e1e7212fae49ac815566b04cb67595ca66045e820362f8da5b2b15160c89e33d2bb442fdde76d9b3aa68298181adae89b2e14a9816f76ea8341ecb4ce67f0a85281c0f3b721eb0c89285d546ea04599c76e6c01dd5d71e0a156d63f268c5bf12ab7368e49d5ae8057985c5b0219c11f4c4ea131b895bcd6f323c6fd91d980d9060626b42b752eafb9deb89c0171bc6ba8c3a0a023b3cbf1f80fcdbff27fdf07eef9bba98b6517cfd90ae7e62b7ae3e61988bbd037f3f8418c0f4ab57a21232fd7b72a7d27e0e355e64ffba2541b4edf4aeb3890ab28fc72c67f0cac7da0c5b4803a7cdff11ba212fc1574c6786b2bfad67a015903ca673b5125435c1293646642794e50f4ac578004490c9b3978addd3025d4e8a56d7762b77369e0e11ceee69e407198d2e7fcaf88cace84144050d86850a3db1c3a86c30c29a9d2569410b28cea61f16ff7831636d897309b4a0289982ab9e225fd7bdf665c44e4f53570828c9091df08f7a5b27794860fcfac35f64edcc5dfc1541169ba3baac3331525489b43f9db24314ba4678022b3c23d9c5f16ecea1e12a64c224aec0577b2aec65adaccf60d70f05d472a63c2773f0837f6a2fbe52f428bf5295cd46a30f6bc2280b1eeec3539dec279f2de5d5589df97d3d366786dae06afe5e9d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
