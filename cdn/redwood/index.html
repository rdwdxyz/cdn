<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5267e414a6d2ee962b43af41384c99710130e74309652159b38e853b1518e6623c4d63f12076bc61ea4ab1f9fa28f60f84893b28242eddf95b5e1c46c34e761726a785165be3f4e8383c49415b4b8b7e15b826b60982254544579b6a424e820a50c98d3f567501a59b8f7c8a52fe9b9c9a7c22546ee9f64e72854367b295574586bcea8df611768ca29a1ad519714809054029b6e9948cc2fcf84de9e8877822fc69914c5971a37a71dcdf84c6196040def59e6fc2e89fc84a74a20060d412dee0c6c48f01baefeeba78d9c3bf29692b453bce3d4b78272866ea4c161ec2c9f2b80bba6d16889b0cd1453a6e375ee039af13555369cf782054534a31dbc823b58bd5edad0cc38a83cd2fa785389ea353b74a8ae6dba0becd5ee6abe6ee4bae31a8111706115d97b7e8cad5af52896858d9a5e75b47442249d5b60fa17427c050e0fc06be7cbfac5eccabb3d7cf7b1df070f0d4c5e5056dbca949b32c1b2f0b07548061f279535037667979f822fcc06f1c3a155dd781df0a7d1949f9226397fe1ae9a7aa37594e3cb2afb07fa6f8e956a55a2b61f12b15cf841e05ff488be75f018e53fe95a1950df43a541d65f23f28ff1372f94b86d17556c0d1e905365bebad817f0dcd3452ad4b1933a97f01cce24a143ac51c58518bd88ca299623ef256141d49a65e25809657395ef8283d18a245ad88489262072b2ac7e5d3f35e8e0032f96f623d8a9af79ff3770260a87f4394f0828d812c9b01353655c691c566d67c652828be3e68c11dc1487d1ba24943477d8a116f550e0648599a2ba00a878145062c022390fc91dfaaf9b834715369a57f88692c2a5b13c0585a43f8963ad4038d76b98db2ece98545fdd35fa79dd38fbf1e8bd6104e1e0f70f0261d9297e30418fda09bc70661cc32819e2b9595d745f38cbfc0012142ff7b7dc2c4745c140094d26f341a79c954882dd8ed0ee258a2632771c27c4e7d0e22ba9ad6de4ce994fd54996556cdb42f9599787acc2c3e015f81f63c6f0cabd053996d6eede913e4c63bfbd757c9c7635cfa745e12198ac89a9dfc289812a6f0eed8f1331d79fcd717bd88a371ead23acf78e2f6fcba9ea683c15905eb1a594c02e616b8f1c070b35de5d4931df6f7362d69c34c32d73b464535e527f0c56963384f872cb59761f5e12499a894834045fc42b81a07ce696df380f8babb34d1bbd25e6925c07f624b4e67d91ae0ad9d1182d4714e659e27f5c59dab3d2649741d516789f130b05fa12acfc3b775ae997e7f884546c0a8c18a10f4f0e0a9c3df1834ee8b2584b7b405b918b8952409ccbef9200607f5b281444533745511e27c7528d33f5f9154c5f9e96e67709c80fa4b5aab0b2984d5c985db88dc3ac13b04e3d9f5e4c898878631fa4146bf4915d8c5cc00f35b14513d6e0a0f241e1fde196e60c33be52f382592b27f2756977c3e904d4bfde87f7539ffec8756230397fce922b62080ff2eb458d87162a57599447f57f520a07f00bc6b470fbc80520baea4b07fbe5babdc95b6c8ed457172bdc3f376511e2e0bc1e7d74cae39b0e5fc50706a2e0f365db13534569b9971afc351c2959245f7e6ace6418c4f090eb82647629e26eee4394b6223b4e9001c2e564da645dfa2dfdab4dc8f0015f135200248abb534d33472085c456f680c63c0d9251141c8211cb10e95ef9a9256164db901150ab471a32f979999de0f633d5b7c7cc159764c88302c711aeed2d26a552abec47f021bdb4244470c09a3a1a39a47d94d70b4be91e6ad6aec3f61bf9aa4073243e500eb43e6f1f953aec8bc38523c05522221375196f4d311cd4c6789dfd3e8efee565a9124700858666f7cb969cac3287ea252dbe46e1ce1b94ab5d72609d5cb3835c1e6113ca4e4b34ff9e0cab213e075810b2054d019a4bae69b11aeff4d33f3fdfc343790417c6cc0e31786764f613243daac432156eab6a147d5bc8277cac5753d2ebcf626205e54e5513d63a223808ab924e17ef26a1071571c650aee2ed71791973d9083fc7972aa979fabbef79783f2c6cceff21ac4c6ebf7c0db65fbba3cc30033f3845d8dcbc062972b540497b52eeb4df914167e948101b5f4916c222653c1439e9a0fc89efe207e1222f6150589872c8e4a2071f03141b4000af63da662cdc2bf3a91f8cc67d7a0273165fa5d60844b45364091f3afef8b0e8db10ae3b9000bee80ba59bb349da5ed62ace663a880303d2f93ace51110aa04f613d68b4981b42d13fc344400c171e01a8a3ec7fd5f597c50a0d8468dba708878f27738e6e2bb932359b8a4b8cfbe0fdd7fb86ad2e95f5fab892b6074c349346e0e7df4bf4f16de2fea3dca425ef23205564e8de86646328224dfd03ac341caf2ec472cc26795015d9560a0d5336b6eb950c992fb15537eaee1f3eceb104bbc807d1d240341409f57441d516fc36ae80c2c1a96403b435d7fdfa2abee296e5e6fcf5a6b4ee835f8bc4b0a1f35f9be23fd92d929817392294edccad04ab01ec815b494c64cd49f4bf3227dff8dc4ab0bfc5981130a601c492b8ad596102cb36f01a552c1927ea7e7b5d267dd194ad81b8875c2eca2643d6e79529b47f0f7ac33531afbd422017cda511a614f61128422fabb5c782227ef5bf9743c13212e5a59e33b789340b6fd04c16cbaf597e6d1bd005c767ec4a3a4ee1c41df9b27260f3582e5554deae0967504faf351520466fd10882eccc7ec2bd954b13ed67c0a481e50d48f97231cb6f378f4f92d1b8c46505795706e3a5a572b605e90ded4c42b9cc960c9c17b3c674a350ef3dd9852b2677c5e41726e93cc760458ae6a1b926c0cf8a71e02898efc71c95033b1e989776649a101b6c5e54bd1bc754259bb66eaef44e26559f6be797ac7b0b082f5aec70d3aac642912fe5adb0d8d5d0cd1f744e6ce946e09f419cab273fd68d20d52bd00f13411a41382880c9a1221d1b9632f5be82427c7939be5ff8af200b9dd24c92457b6513212f9da1e0bdaa5e0d19bc17c61b70b5b94cc86a5ef5bb4497a5538748146871e6c5b7fe760d411b9fe940d6738d43a56690b9e7f6fc3e7b2ffadc883252a2cc9054a0dd11e32ea908c5f57d6297983f27cb1c6c11d871a7c4bcae3d0e6e838190cafff3e307c615737c0478279c6b4dd72fc6249ee8b3d685dd8ff777bf53ee624c81f0ab34bbe163926f23f885c0c8b7875a4ac8975e7b22d1cd4831141da1578ab2bd2df65eb509141b49caff31bf70d02f93f6f7c0ad07f0824f597995bd3cf4cd857efff69de04de8f310d2cf657386da9c7c28ed7e3a8a789c52c98cf966e27734d39abe522b8f5b8555e5d4cf2adff4685138640f6039e412a9c550093ba5a61e38f89ddfb3854d964f9a9bf60c419f9da9be3a76753320e151cd3cf1461bdf428f5d248634d2ce9de1c4cee9ce751d32342825f441ce26f486d20ec1611021017f162464c6ea7b525f5ee054d97704554196a52a80ef7bcd9db5e55180d05f731056e87b73f29667494a394752418a26cb7dc25dac870e35b7acf25649ab0df3ba3962f2adf8bbc77fbfc79ca26a610b4c9b3ce01a681d3688eeef6dd53aaf0cdac940355dd9f2801a4b1afc18edd9faf7a3a69c2decaaed1881bba1d0fce927aebba51a2f23add4423213e14d5a543e20424a88188f60659809f9fe2f543b8bf35f870c2bfe8040f5c4ca7070650fb027e8940a415b6a3706045ea72b66010af331ed48eeb564a77fcf6a2d0243ea5be5077eac1e15ea4f8112f781c7fb1a09596e47c236a9f5d8352f4c2bb14264516b1bcc13452dfd499d3a9cc84113b4de7c9945665e545006b4a6b7d5a56cbc67fb0ff991b00c3c84a701f7672217c353b2e91df55fa3b379a8ecf61b2351138cc9de4c4b82fecf121cc76f3979e03d043fac6b4741b38468a888aa0511a6b6f795e0c2a88965502291c1bd0063863019855aeec56b03020b1764d2bbfe7ff28909ff68798b2a3f65a2f6d4145413b5ef3d172c7674932987adc87a6e430c12b5429b4cb470b7c185bc5cc9afeea8b987e35a28cd6488711904c0be9b1bdb70018bac515aadb87f08f118f8f802675702ddc6797f1d72f1791006f870d6fd0c938f3979fb112b03717e4133c841fc646603216a0eedfb7830640637a8b984acd25fbbeedf86887428e9c86fff596ffb37d3e7711ada9fadebeafa68e2f3de09169612eb95a973c7b14d3ab202f6b83be428329849b01ff0c5643494547326723a010ee66576414d5f2687718f8c863993fa15e3b04d03fcd6101adf8b4fcf54373fc6c3a2d85754cb14649f1f018681d1cf61cb90383c944af354e5fe5c69641141fcf8b30d5981b0d42bad77fee43142744b83fa89202d901f72b4ea28ce9cf27550c28053818b734e8a6da99a636988d8301b52e9d03430256e4e1f36aee5662d650ddeb715ca3fe828899a4216c6092443d11e429dc3ec159d66ba82eee6357d1d98572efe99e52b2201c82a15167c96969a48474d29aff8fe61429132c0ee2bcdd30232dc567a9e9e0fba5fbea0c00a72726453567ca9ddf3391c8c2f39ac50aa0a095f32d679ccbcab89b99eb8c8531ab895a6f67e02e4e3df0c0f311108f0896586f172db6a81313e74940dba85f186c6d2e2bbea5de31a6eb2cf440684ca74d289e1f2ee5cdf96a4c5e27e3b11617d98bc00c302d188338502a7984b8ea1a0e8fb3a8e843aed12a83bc53d7e7960384f64be77f7f6ed7e694a87ce5b890b3f1068d02dab57aeaa7fbf8e995130c19e5aa553235a8751d3ef2300fadd2e62a7272a1b83a6c5de73c3d19ba07a2323095cbe392da037bf0a24d123fce4a3396e5c8246102d71a5795dc1bc6f7344e544b7630d5b9986a3f2aff950e9fb25585397b59a311b4e436b658d01f759747090dc12bdd9f186a539d4ee9b985b27f3c56ace1c3099c8314d4a93226366d32f2ab2c83c8c360d058077270e9c036449fe6283801e65b0af7660809df63ffffdf8f3b6d786736d5cfa1e3f80af4513660f58c2ffc6eff5a21453f8a4c9e3594b6ef8e71eb75e0281ea11f42d2f0caedc913cba15d6ee281a20b3a4c79cd69c218346b5f45df1f9a1e14975ea40ae91276ae199990f9105eabab2cadca7255f7684b69497ea02f58462ea415f688344aa1f7cf628b8255f154a1ab1f45483a80bee214c9b4f87bfd7f97a30c23c9a38d6f11522a204d3f4031467d7073f95ab27c80bf1b7d7fe372ca148e0034fd5d45532f1f2b763b6ed78819a487ff28184c0ee4690f68e57ffebec0b595c0990fd57d82b6c227d2fa5a2a294ef27571f92d3474634c7f584769f79e28a8a2fa0b49d615774c7e98e497878ffd997385da0f5cd8599cd1c70fb814d12058ec8d20e826aab012d06c525ce57972fce86392b7ea2ef7c9d5e6063d8c76a214807fbcd3b4e958da1109f210ebf1f537596a937382d2fbe31a3a6fc9d853d4a26c2ab783140d8fd9338465839db889db82d7246350344eac7ff5903ff6d2a168054672d4a9321fb3651257912ab8092bf71584fb72338f5b4e0fd0a833caa5705186f29bc38ecc5d29da1a5fbd1df4f3d9dc4b49f2ef7be9692733448dcb3e403ab2cde7a8d7c14ceac92e640f67ac42139d0cbf5b20a6827967b94ac4f8476c7999fd5e36b8c02779a20ba9f769969bc8af6891af03de3a98c079e08ff2c18cbd13c12d10b5285840ed0371804636b02d12241a956cf5a98aa65f0242cfca905d6be9c7bb85a7a87cf21dbdea206c99758f409a011882eba487de7f91c2516c2ab5bfc0a361e77db90e81d9a8a27428642c9854e0f0e9bf5ec1e25f3ae26b46cfb371e3f7d59c783bd624e88e593c4d41837149f529fd75197e16f7abb9b0f5bfd20d6e81ec79e38c3b90c0046795dcb6211c0f6ea22a24274919c6df877189d43940c0bf1a83864d896bc962c0e440a6646486987d354f346b34950fccb1389835e0c06dbb9e2a6c8b6a056d7fbb411810a34e9d1b5fe3c1a311bd734575a95862111d476130e883a3a1c0a4d99d0de7c81286f3d819608919cff9ad6c6b4e7adddde88c0bbd9e0b34951d367773a6e32465f567fb87d13a0c95132e4a2220a5ee605c9dfcf6db4aa6aef99c2c47c22435beaaaded399304f5f6db73a59e91b5646d59f69be55d73aee216a16f028440342692087e894655853a04d15a83910908d3226046ed77dd9083616fc1d1e83f9569ae5e075042360c331bc2992e46a7af1c1c68875438a21bf5fd062e1a4719c64a0696545dcf114a90b6dc773b43e2a0042c32951f26d663bafefa3c307932a20e8f7cd5232b6cc568eddfb0ce28a38ac3f372412361c06a3145aef51b2f5b222509f028e14790e41dd5f036fc77df1d2f59cddf710d3042d1b85de8de8e5a97eac4b9daa02f2bd9a67a6895a8e9932f6412e234e94e871c8eed59125107802b62f49b308564df676539391e71ad5f2bf53666e884e62e2ce411efd573ca3e5097975ed42dc34cf9e159f83e436b2953999138bdad1cce187450475cddc42ec1575dacecf686f62116d8d777905e6b37a25b2b961a95b96e6bac672712f20af2125c977da374d5515f854e39204158d56700d9f6b55151667541bdf68f63e6bd1311becfa9ade160d6266ffc1b4823adf8463daac06eacb38d48054e6246be4e6cc0dfb59b8d27cbf608306a2272a6ab32c6e87d2071fb1b34f1557ad022a649a2753396fea45a0b3abd39d12a167a4e0868191a300a6a5ab7f83e3af5a38b1a7eb4f28e3c24524736b845c53c08297753dd1ce7f1331dfd34e636101558bc7448dc922f60724bad624b9b888c23ec5c642687fbb7c786877d258a6306a5e6640191642e221dcf8705d0e1d91ef7d56f52221e6442e10a57dad1ed0932819ddff12f3751183fe0c881765e39e997591b90183f13430c886e62296f487dcd209b5370d7c31bb16842b9ff4ff533fc1adeb983f51edaf7c587998a556485da0b41c7d71cba70be05f4c6d7ab5ebab9d4cdf7d21126b6d60b751c3edffeb241145d4c4dc3ffbc3b2fe7656daa90cf810a52e99cb050bc878d78a4da4a494179ad53c162f0a4faf68f410f4d3a32cdeeaa9e602f2c15989925d29d813abac14c77d001223ba50e5280a6a9a51f30f7e20832ca64a53ff9a8f6aa98ab77d1c58e36fe4409389f135b57a22ea422535b808f51d2cb051064caa6a7decd25df7885705fcb3f24231480b7a1625880793857c1919195f31429480609cca468081f5d4b66c70dc0bd769e8d64652661b34b3414f82a53e0cd462979c0669dcdcd2041ee45a48198c0d151cc960f6d36eb5539ae63e1d42baea33f030b0add0f73082d4aabba24964852686beeb7dbb4e433faa9a84cedebbb4339acf7dcea53c8090a4e964b31cb9d9dc02331fa53f8b4565d95da48ba72a60757ba2f46bc7a04949341e2b09249ae93bf4ef11e34be8f5f5526897c91287b744e751f4c00938e2617f4274945cf59558139b634e2c352788ad7e3a86e6d097297fc7cb3c3a60c266bc930c9e395528093638777e99e90b479d9038d723c709e73873daa77c4bb6d640826b84d9db9b01a0cfc5e66092eacd7f1e0a45526ca1051731e2e636afaf3afcdbaee63d1907943dd71b3305ce2b73bc8419dc27338a9946eff8fdb3dfbc47e489df29b89ea3d1f126eb95f4be4818d6785fc32c21677513f175c4a0f0e347f47ee472b47b9ff87806f9a16c8e1080b5f8fa2f845a50dc155c8c28cf62093526d9c9811cbac0d1016f946e7a00e16dd8723ff96e73c2eabce788a3c948d700d4db17cf53cf00039fa1158bb796be417d64be1e031e6a859a8399592476ccccbe6a7e0cac039eea0bd469811eaccaa9b71ff68dcf772340f10e132906d80def74d8f116dcc9998b900aa3a0d9cf7a53de1cf88a4fa6a7e2a7421870b2681188f7fdb46c6625dc1d15d52386dcf46bf229a5d8b3dace419fe0f475f49fe242a52905bd5a272afe59e368d1626d9e2af9d244431310e22df8863d8383e5a5145237af79f4b6e8e053e954d4506218fe17a90dde86bb7b72a5a463407e11d6ef0e9ed3a6a64be2078bfc6cdca8a2bdfc57ea76957a247a6b658912de6349d0434ce2f4fa292fe5fba8b3029d051388f68072dcdd30c72ab561a773cba17f0e50564ebfe48a60eb17e8c294e015f35f09a973a0b794d4fa79452f033d7f2d820efdb2ff9a63b1867f0404bdd7340ff0c12656c403a7627c9a0d761543ce431af9c3d832e3970eb91b31da889c88a7f472c76ef013fcd07ca458784ce8a27e519f828ecec04cfc0e48f682de48ea3e7e54e7e7bd1a09aa40b830cc0ff86aee32ecfb5cd343cc5bd729272d19341c66cabd81786870083f448143b7476f2a66b63b4a5cdd0918b513b50295f30f9077c9d32954077368b136d27ddcad439d073e2d834a0ec4969628b9f799f0fd82a727e98064e71cc7cc6daa46804192ec24197df0faf06130a0175c1d7881de41b88f636ca95f8e1f9d551790b35efeafde6513c110e6f773bf1ba5e39365398f527e1b17f2f3a569d156a78572c46f93aa5f87f32859790fdd0e10a16b2b45830ad6d8da31b12a1a049c92fba26c2f5f1087d827143da60d55d69a7a12e86725e1bc12d58a58a96ccb401d3c908eb04607a952c20b31663eb34039e70fd86201f11c3fa5e39d44bbe03339425a9129444cf37671e7f7936698c01be0925e22ac16895cc24f0ff6f467a9cd1fb9bb2fc67f975171db044eb63460433f43838934b89e6a2ba33b5c7e38b5b10ba6d6cb3268445924969304e0f63266fbd1682aa02ad97b35809f13972c3a7ce20e610ece9faa816e8e1e9f9e8ea8de2d58530fdcc5a9b55573573a831ecf36b77c3a872f2cacb0c54d96f401c551eeeeff16ae00a2e79aaa7518b4d6bc612033d2887f2ac36f09b16df7bd5474f728a3152487ebd5173f33ab0ee0b8c3b8afb80cdd8e6b65d0d412209556a0ef75a2a0fc82499096dd8b628b319d23014a59c224707e1becd97c1a78809fd40e9201abb2d3cc2e8c0881e8f16faf3d717777c90bf8ce2e0c2cb801c1294b25ce1951017d340cd50bd915c39ac11b6b65606143cb5ad4deb1f61a320df47b662cc7807c349c67cd5b3809f20596e5280825c06339689126b675409ccdef5a67b5a30406a540985a0ee3bc25d9b4879518dbda37fea049cc236728e975de62e75691de0ccc4bff3ccf0befbce28dc4b8c6cb5eef83811991a40fcef6cca56b2e0ef7048188ca7dcfaea9dbb03e1579ac63174ef67ea2d12c39ea335e6e0d6dd7580f08bc270dc8603fc90c7a6e78507c157ee1ead38ba975ae87f8199d07e348e3c5ce9934c5fe2e2b7478cb543e0dcf134690ea8b98c624cde4f3ebfc99cb6064b93fd522738cc2d7be1e9b2529a58d14c33c5ff94b9db5050733360e8b8b2051c00177a5f3ba30ace24192cff84f15d3c6b1db5f6e65d3ab1f2a5b9ea16c5c0fa6e913cfe59fcdfab895346b075338312c30b820c7b36091b16d2584f21639bdc383007f8e0e13b183f2969867fdaae184803f1b5cf14307c1a9a28650205591337ed37088b40e853579381ad18665944908f4bc332fa3cb89bf6fcbca8c5239510b46ddd06d40e516d0a71b5d1139bcea9978ae57225f8ab210285243d629159e49438a542b837144cbe07b6b7ca4bee09d7ff980bedfb13f20334389cc4c774e290c4b297b4f360e2e780c33f48d03edd06fb74d06136b4c67c17013af4342e3419913c0621ee762807383d8e4d25c0ac0558816b6955b14a5e876dfcd4c8ea888dd0431a75d34954b55a3b73e3c1aa9ae01dfd191246ae61b4ff322bf27ef1682fad8aac07bbc9e7a23158d9f4f9c17addd9c05e7b744a7d87698bb48be8b560c5a33923abe91fdb86191c27f2498574669951c30c5a85ab1bccd691b4e90e35e6c9df9de10bd6a419afee449692cc1821cdc3d123511fd93654b6d2875f1b55f01db6de8ec01560914cca88003f20dad5984a9be91445c73835cb74fef274bc75d4552eeacb51abcfae13600a178e67316d8a707f6035d286d49166fde0950c4a23b0b5de1875f4f1a0015c58b25700ce9b2a3bc76558a8a7abc1f3efb4076a847d7dd4f7a7ef19a7c2601e3c7731b54ff370dd3d7fd59a22ed8f9b15cc2935de67b1c2587f816d9255b89737533d0817ba36e06a3f126f2947770c68141a1e0b32437cb6b933565b9076f086ed03806c61e0f2bebaacd10804462f79c706668a5034ada1f3adf627eeaa77884289eeb0dc60fccf7742d62ddbc94cdbddcbce78143f32c4d07ac20d249290cd0e30d4fff7a911481ffb3657ee007fe74d23614f365f92be70d00f443bf1bd5832ead1ad579a7e25eea25c3642bfe15c1542e0c1d962d016591f535c502bbd515af0fda1b96a8d6d68a8f8eef88167a3ee68b6ca04a9d1510ffb42f1e6f42d51e91cc984ccc11121eb89f8061cc2ffd4b333bed9d34ce19a07c5ca66cbd2aca889d34c2c7f5083fb31e8320a7974a1acd7112df3db1f90e02f1f97d774fe950ea5c12cd1986950fbbc8d3910ff8fbc273fbb0704a77387c2bb01f3bb471fd579cf9a7f2e58f2bdebc1e30a1eac8bbfedf668e17f86a76fb191b4e217e2ec13056f72320c7b53002de5660d2d7d69c0cf1cc652aa9dbd85a876000d22a5c07125bfa5377dde89410072cc115ec3ba5b94f15cc845916eb0c677ec40db1a12d6a7f367fbc993cc7ef8f6be892d417ede1c03e314f637aeb3eb63968eff43c1fc7406b5d8f42af6048936e650bd31b0d6c67c1a3d4cd4bfb2d9e9d7c676703b46d84e7ad1f3ad8243d6711b36a7b7d5657c72dce5af7c4d4fbe1959c13ae612eef69dcc87ead3a9e11f5550e8d47bc6f657cf1b53b2e6c609f02d79c121da7bd3aaf689dba7e38d200910c4fdb77442556916f03d514d2175d88483ca49999f525e98012e6cb8bb6bba0df3cd6216dce20e7cf8a128f2453a881445d54feb6056de322dfc73f9d77bbe6bb3c9294ccad48ee8f309d82063b550eb3bb90e15210b4fcf049778164f614c2e0e53fb105a3f39bdd301cb3d1fa29b5f384a4a7133da81f9eebbd39dc814fcc439dd1cf0e71fab3c95de0eab21366a8245bf1a6962daadcbde0fe3e53e437677e6a35ddcdad53da46c39a8cece5fa6b1f0e39d540d21da290f6dc56d9ce34d14814c1e61bfb8a1cc8ec75c5bbc2f69dc739d94fcb12e413816bd0b6207df70588a4ef7f36ee42ea0dc338237b3379928e90dfd8912f249cf42417cbad4f8748564ad08d57ae5fe35519623c4142f011fe7a3df00d115cc6111f5547d493ec4c75e8d095f66e12830381b4be3190236ee7473972ff2487a1fbdcae7e4d184127ae266bbefd4188cb44d23ddb14104ae9cd5742e7ea731e8485d2630ee4fcf62cfa3bd32173ea1405785f70338865527bc1f63fef09907c751be5b047f9a9b79b13ad161fba719d9ffa94eae2034860ce56dcd8af72b2c8bbf76ae7ec428578d41b5d82638113e277bc9ef99e49cac923309acb8073af18b951ef601b98ff3330c9d463bb90f40b49eea77752c557a68f4c3a1cef518d331f525bb933d8726b0d206c8e3e1da6c9b0cd281d3b9d7a1b42c55b98d5a1f9e4eb1675040760b57a7cad3a54ed39ea48ddbefb4f12d3f6bd6306f7ff945e8c82ce140969d301f4969f7980a9e4eceae6ba7a695107d85c79ad9da5f39fb0fd6ae65f80095b11b86c2517a5a614c9ffefc27bd039d0c8be41697282382682d61daab072c75e37eed6fa79c1f781c7dc82e2f224e35907e3747bd79f929c30cd5f8f17a83ab6e62421b78ebcee4932264369123331cecc6d4d66c59c9b362140c14ee19c457b9a58b43a98d21abc09aa73e6ba1de31b79308ebc386a0237884214675bebc4c78db7d79a73200af32d2998dfd903febd99768ff6de0436b8b8b98401ae691fe03682aeb079df76c7ab2c972aa475215f3161dc3e33c227110cf98203bd818c656248555d8cf5bc4d0ccac76ff9d01ea4ec6721a2c5ec29dd807c3800acbb67dddc982ec5fbba8ccff10f52dfceab7981d1206c6c4b2a8ed0a07d1036f4ea9c0401ee910db0b9184e31022a4f3f194c5b01549b72a38c9f8696d261711554af26273984bf14543615ccf88ede0c771940e3de469d260b3b8c159399688d15a6b21f19e30b0e5ad30611adcb2b3d5269c3e7343bd2b368f69c9635d9810bf3d054ac9d1637e7e26f7bf7534ec3fc27b5fd4a295ae69d1bceed4191e4ed5d56766210f38a5b3ac279c77dcd001b7c868c200bee0ead3adebd910bf36ce279122e9d584a838941ea6192bfd86c721806a96c7f703b7b968c9c8fc228e0fda19444c39e3e59bf78ae12331779e07f1042d8ff11ca3e0854435fd50fe3527d92a6dfcf9c5853a8c0ccbd52124d97300ed697a43fdfdf7ff4572ec574cc7a62cb758807588c7353b27ef4559b7cf322dd135981c163e97cfb4bf15431dfc5c064761b852451b33bc98b411443d1a8f4920942bdc5f81bbfbef80188f6e2f2857e3c48bf238eed20243cc21b283d2679dc3f2b56a0aac58b37610970eeebace795b0c2fdb44bf633537e4b6e73483b21a9e638649c04b3160ff06cf785d65cfa06e9621c2eb74835dc8ced82e3d43f5e59e17d4b035907d004439fd4205f3590c5d5180feb0f00d0728f9ff8aedc3edd1e46ab7e1f848758caf5cc642c96ead28fb4a18db727667a3181a06d8e1fb19f80aa18680f7b1f128935aab5ddcc8279b8f0d6bc98ae86d6ee6b289df93b963ab39868f1e412a5085431ddda321893047ca676183dcc381acb5f2609cb28cd22c2d94607922649c73b489b9d10392bdcf06eaa193af87b5039dcbcc7f7cb5dce81689b5c63d241e488f44a0d51896914c57e468405531da9659f83e8000af294d36c610c62c66639ec36e84cfa1afa1bbd76b30a3792654f3d750f9324021cf9ac190517615523a2f5c968a104021518babf225ff747da6eccdf76f9d37128b5426a08ccac153a0308557c3af90ca0cdd6fcf3e1cabd5ce9453d93fcf4cf0667cd0fe1b178892094f0d4ed562688c1881569f4fc386f0e085381b75fd61be6f2fa15be11d60436e431bdc2b64324c103bac213e3d8db7c7f4644bc7254aeddb0ce6a8091db3ba7448709c0b94e072eda83ab7136449db6eac37b99e295072c5897f8c222c83b9aaf1aa2d4a7aa5e0f329a339c10cbf58ed3ba8c0aea6d39395aef9dc6445b3a390bb6f82ab4fae8475555c9431aa82315458e85972bc75ebaf4588a66a581a17d40c7fbb266704b5f042212aa093c53185418427e115a0052734c4f97b95c85faa9740c8da4b9ed2db32376c4521ef9edf2ae52183b585f1fadde7d0d99cd911946578eff006a1a3eeb3ccf34289d0963e684857bfe6783188d5890d22d2ecf8a3384791376f7a70c6f1212ad141a04c553df2abd57ac499502fd528120f4cdc03763315c02b1742d0d0f9e541f62bc34b2d94511e7373a071a200be8a0fa0142ca47bc08b291c7868bf5a9fb9d17de6eb755cf247ad52dc9835e5149d2eaa1ecd9be756660bd2a4fc18607c6d47aa482f800d42742cbe64b1f6d7c7ffb0b5ac040ae945a28f12f2e23a9d251d02f7e92df042636614c30d9add748ec016ae34934e084a65f6eb2550fc41301f64ba1aa2a310aff354889be10d54cda133df353e126456dcebd6f4006cf7793d1bba89eb6736184a1727d7b08620bda48b42034b9b43a53ba518420ec13523ee686b3f0cf2534b7820b04560bdd5fd5fcdc13b22cd46d8986aba7f41e916ad5bf6a9be853a4a7a8b74eae5bff06562f444cb182ce1c055c8fcd3364bd2457e98346830cc9fb9467a35b9fb51aedc7b209cfa207635d78d90c9c56f356c92dccaad4b7f3f4ca59eba12d0cb53178926921e7f2f7f08cb390e814a445a4b4c78929301bfef0a9cc2efa987ec7aab62352e0dfe0924472123fc140932e9d12d551be149f6e2aefb36c78c858ac7b7c3e3ff1cd0886eac89c8cafac7dc86625e11b38839444d627c3e4105bc7dbbb6f4fca5a158e696a6fde677219fd8f2b0c474e40f5211c2339d46dfbe76c180f327b3ac132012ec5fdfc6031cecf02ac850fbc7542d6ef43ba75759d1d0417d1105d2ae1b802a9f1387de7974a588637a2c487d52f55465ef69ca4b9bdb337255a73b095fd6dc3ca720a5ee8fa6c42c1a2af91bd4b07008e591da5b0fbb7a3f3bf88cacca18061b4e342027be4790f240b0377a89ba5949de96f17da85edb3ba551d29e329629317d3a24328329d968ad2b9d86adb0bf4d1780afbc54e733962ada2f0579f7320f5bac76e479a8c3e3a5e05efae6fefb5367243e59ce9587ab5b77f4acdb88fde2ccbf678109f84945bc3345275b57441eb364ff36ffb371a677c52061754611686dec182b8accc04512fbc85fd987997cd5761e63dacc46a61c2fdb0e4dc18fd08a15a3c2f74198d23538e91499a6acd5ddb4362a837de9e60ab77d7f90fb8f7634571295d347f337ceb67a8a1bcc2981e4048f59b38331d22090c5c81faf19c9a1fcc02d395cd69bebc66b8ac1f84453aed29381a8a80512e55ec6a9fb6d6ad33be790b98f5d6e287e7c3a565ffb55c70d9f32993470712e4d0d071d23df5d0e8ded68582be1d48d5ca03d16c3ae031f8592ca5ad25fa9a62a79fff4939525b83a9f36bd43671eb2166f1d57d953bbd8188f397d2aad23280b2b966850a7a4b8f1db222648e336d4e17ce7335c3e62199f8c0de9113d9282ce964c8156b490d8a922d3418876b797dd50c5b4266d0b8fb03fcb44b9e803722fd92f87b1f8b440a80a5ed4087b984f5a9801de4788e3ea7a917a4ab2a80d7306ca5cdc01961737991ec4ac97b71c55d1470b138daa6b949bcdda8ca6716fcfc6ee25cfb3773427666c4259f52aca7f3ab5001d06689e353f9a5ec7907239059d51bbdb14a1ef21332a7f2f78fd051d5fe5102704f0edde4aa61b7846069d53f742c8c9a508c0e36d06127625b9230fc9d2ebd4d4976bb743193950901b312e58226aacdc640f23bf1c98ed253692fb3f9c701dec9fe9f9d10c823176fbdc90b9bbd6d847cc4b7219d90f1e30f388622801","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
