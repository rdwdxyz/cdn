<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9a9b8f30a3d728f855b4fbca2e2af5a4b3f4a8fef09de8a362e6ad7c45ed2dfb97bc9bbb1a6f98b0b521fd07c169388b041d90cac21abed0a98b24c1e457de79d07359f3141b83d21eb58794903074a6ecc3057f2bbd100abbc7dea23b5e5683202b0f46f7c973f34df594932f95a084d0525834ece9b43f054fcd7abc1ed135e159bb49ba8810cdb747cafc6704a68bb7051bad58887107d2018b55da5f7b4ec727ed084cd4210e1880c1213daa02bfa5d646481d3074563d3dc3e243953f75fe840181ba9ea955556a9bf4daa29f7a5317cb53585737b3c199794734567c8c3766baed9cf6d23cc61cfbf6a47ba3447dc0356e6a1fc2a2581d549cd4b78a36423762001390483ecfaf4c15980009e3415631751f35018ca7a609182f8e68bb3d385e5759acc9f287731f7600e032663a0dcf582e6a0ba4ead6de43438f44326ae133a92148195b8db28cebd97a00dd22d5e1e3225ba35cef72fb2f0800fa8579f7e08e11753aa427769549e44f0d2155c62804359d050b9462d09f4e2970fe416853d07b78718c7b322af9e5258863aafbc81a94d8aa0c2155208686b8b2dde837e893730052c308a27175ac319b0bddee6febb513474743c011e125aa14e20d227eb45775fa78d5cc9aac00399ea231b2fb47e96a5551c8bf4ef4d89bac5fc6e0fe9d2340cb34bd232f000785c8489f4e08a4e271ad8febf4e64e6b269a1a812f28f0afbbc5286392a10e97dd5fc909b2a7dc78266f8bf328c5aae80e6cd5f94520ee141231a7d7ed3031c57eca746818e7aae05355e5329e293ba96b2eb0281c38fabbe6dc3b1c9c05608334afa432ffbfb5ffd6b49d0dd9521c4a7db3e6b0861e809a49ec001adec1cf06a08f05da051536f4c41c9b1f0e42863186bd0a28e53c345f7f31789aeee67975c40ae435069d3d08648a65b542b8f99304f17e22c16c370322b58a563e472a1af913d101f7c6e86f8560acf932935db319050c6740eaa638b28c4e76d6a18dff185028371cdc4cfe35f87e1b19bbd84d4a39d0dd8befabaee86b8263a52d63e9db361d27294da9459517a52e8f860e3e55175bb53a56dc28f26a9f08bf681113009f220d8bd82ad7e876d145a1d7303aa82739ba5a8ca23e128081dafedd923a366c0b6088ded34b58e4f0bb9c66ce95af4ffaae5bd36415a9ae3d165e955b62bfa91b351f49629d8f9c7d7ac80a99446e0b96f03c4d02d7f4095647701f3f8f10e35de6b41cb0a8fa1e44479778e750c1c4bd5ba4cacc95587287d12997ab5f64621b6c33b511f290822d94523f944e43d1fa0129bf931f8a0002f578dec355497ebdda68a8c5e7ccb8944a6ce6861110199fa6cd81c5a6a215b99517af060f27752ebcb825a4153c5f43be6f6ab66ba0b9fa9581b9aa513a2c6823539c8ebd4f2c3f3a2a1685248ac38325ab1f73294477fd81103dbf5b4b6cb5590a3a8203606b27bbf1e311e62da85611f8d80082bdecb52bc3bbdc3ab07196f3bf6c23af1e2772b7b2a0f2186fbb0a325af418b897d0a82117ecb9e0e126c12ecc65519e46e685c34e34c186b2b3cd421d816e133122aa7c9140e8fc21ac85de07fd1ffd3151d59c85a5369a499323076763ceddac7e1a571e63d867e82fa618d4a52d786729c9296e270ff5a31e0697001fa8fd0e747df99693799b477bfc6f5ce2979425439a33e5971722c09efe6d32d45b1df8a8214d90d6cc3444f499f8c48ee4253a557aa67b3dbe4d3597b5d7631af20dddd63dff7f15d8173c25255bfcfa649b4edd77228e79ac66b6d71cace1dea0f46b150ed32fa3faf4ac31552a30a84637f4d4835f77ccbc6d96926f4ea05ee3428232b702b63e4a55433711d9e7e29dec02a15fa5c208c41fc2cfa95e4af7ab15d66c286f8216873b7bdc8a03cbfa4a57508e19f12772003e894fb4d571685d11c9c0037fbd9201a4563f413d653aa4f161c91ba2f2e82a324b35613520580fd10c38fedde2c69007ccec90a9930e1286b352a2cee86fb7c623ddbfa4149e7584eb64f27e1b597873844d601fa1d5abe08f67a316a80c1c78b18f667a97bbdc9650da85e0fcd1693cde631cc7dcbcd992538b2520ad40e394a1cd73f359a787a60b9f347d90323c372ae567cd4c318dcf8a09cca1f4fa837cce333ab471522c81b8dc6b707e51247eece1c8e02cbc6c4899e7b3d50d20e44d78a25a0acf9850d4669d18923940aa248fc24b7b6e9ea25ff9cb309787a46a4faca0ad9f4a5d555e63e3c0ecebe50cceac1a90b7c3010fd5e1d874a0ba7f8f00ea18825d7198192665a50958047ee6d0d97f44039b76975e1060c8f2df80efe7305b8328f917e80cb858446b15d8eae1d6d172c5c235193c6ab354016227b64c864547d82c649977bebd712ca7037a5d223b61d9312bbfce8ac324794a1d252a98e3596ff5a46797e9af03377f54ec774b4d1c7fc6fb45aef8cc17be80f94287120e645592fb3f1667a1868197ace17768de6a38e85ba8bdb685098420a27637ca722d203e17f362fc43cc5439df25d18a1a053dc40f90a8d8bdc081ad81c286e3b8b0f48a3c4e934019a803f1847377b018427b8e0c16ab5acabb8d8ff2d19a33489527418a9b6cab4c0fc5aacae27fd70742dbf9975089203d0d9ce388cb1ef0f07fa292c9e3a9bd0c2c321cc65a4b87e345c92a03a23ff90ebeaf7d40f3ee8bf4aea730e735c5658fb32cca7891add69d0ec9ff0d2ba50e8dc23728b22c2357c24b368136d2018f46814c7591df392ae18bf27ef0ea6d87892ce2eaa9dcb14af516e09d859aa22ba023c6130252265677eecc9dc342b0bcbad97ad286a187a3ccc60a9e91ef788e3e48e6f03e5934b65335a105bf0073e25670ecf960a68dd742ded65ad9a5fc087cd2563ed74cf3b4653f00d34944c9e0b701f2af595544d773291b6c01790c42aa37139f0e002b073d9c7c5910577e95aaae569f821b44970faa8329c9f80eb7ac1fd6a8bbf5c345a0b0ddcfd908ee36b2e3eaf3e04961ff36939d85cfdee112244a75c048a7f2584c5e99f791b1cd6ba996d9be19eaf48233cd86e214a571a5502083ddd1dd7272dd5141840de4da5b6c6b7361aee0043b736b51cc80bdbe14fb9542e7e03d8e84ab9f4329defedc86851d2c22ab88fb831e0e2688a14a94a8cf5484ec1a8717305d3d21688528959f802919770087de749163b80b127fbe3d9bcb7368ad411b494dc3ae492575152759482e58ae25622e5919d389d991829113dce22a2da398eb2424388d6ed2828bb87d525d5bdd3738326ed23c71e353f59b9ad51a9634d7c016c4b967fba0e1bbd499d6b7c57330083a82ca28f42ebcef756c5ef148f4d8391b38d53642c1dd4e7a53be5a6423fa8dea7403dbb7c8faff282cf5a2b0b5d8f226b3a2a21350c75ff51de650587cee2de5b9140413a92877fe432de2c7bd2017171aeb2d18e2d6ed4b561bcd292583720d61a34affc58a2d13b60c91c828d0e616ed4d2c7516b1b1b6dbbb09e6c26032e199a837f7c90e8bb145269344ae86966e1033d876da7f26e88184e08ce18dfec3aa09c02c410b4f5dab2e04121167703bba377b20bdeab33fe0a0d68f8a64d82b5af083239924838da2b92757139ee6d8e4f1809667e70be602754e03f498d09f42f37af33f918bd6a7060096fab217c053b2f75947d55efe5d16a26eb9382b3ddd7cc1460146d4d893c1a9e296e0fcf6630e2afa34206cac37eb2977202d124b3e95a9117b665a978e66f42a34e2384c04f19ce6578d791aeeeaf4b22576ec0dece0eef3886e27c1734188b2458ef4104c33def3c6d4ba40bf1bfc249b45d109586f0ba1bbae5200eaf482619bf6eb91c63ac4347723473dbe28a1fb8709ce4f5da726ddffc887d64085003c841f3005f7a7f6c71c259f23e47296abde5f52ef4d07132fb22db8a1c973f9a7f4ea375685fd9a00ece90db8cbeddadb06b2f823b1b28d1ce8ab363283495f079fa39576602f07955161ddba87257e6b4157bc0391a43c70f0189bbdea5a6fdc01ab8cd904a714ca8787e39c1084af082e9e8d52c60fb28debf008ea4500c7ca7ef24a6d4648abd84386f85bb63bd6da24a53a7547504e6c0e15d103854ef7d207f4fc99ec523c29cad67866bd440878af4138965a8e0629dff020e2f6a41634b8e5d29e1e054691069d56f88fa0325eaf5ec3e31fcb6c453ad0155856855dc0bbb484c6c1da136a2f71ad17848296d6f04244f8d1d2d93ab28071bb1d92fa7618849ef8c7fc85e131fa7ce9a14c075fdf253b18285c4d51da3069438dd643f53418f969ae022a7da27f1065adba09924351a4b7995417634baaaac98c237b9891869eb1c05fc27107c99ea2d0d6d7e3b76951d765c967aeaafe7e585065db07402fbaac7e11a6a7143d1d1a306ea1aa09265961cb8a3b4d8aed5ca282dc12810d5ee4302c667c3ef97924a6aeb2aa00b8835bf249d0e54c96ade131c3c486e862e823a1aa7e80adaf33b0b90e5dc0e143efd4d0873710a2b36f4f0175f8263c9f28df6ac7e402673e05e2a2dc5ac59989a3f77860223d2f9b2326fa93e43c4c38fb36c661dd87fa5bc325bd0dbee247f020df22ce06990305caa0779a656df33f728e89f7bf23b53be39290fca1e9dd585c82368f95de183f00ed9a211b4dea58bcc933246e27776177cd140b39ea77a93d79d2a0fd95e583718acd98914656c611ea851d167e2e03a95be50e821a25bca8bcdb45229be5e031171cd5e9f7b9cf756d8cb607daff1ef908a7e9caae0156eab00d5eaef85891aaf71a464f86dac21599fde8a07c3390b838f97464ed6f76bce8e162b386002beaabf77ad015baf4b242753a5fb6b1bd1d22ac608c7d7a5aea384230aed5e0d8bc8b56b1e7c614ee4e8b385a7fb62225502796c2d759a14105ece392a94bf8e32f0f7592424db47ec6b6d029141909cb1496a10ba1e6b87c545bf3eeca0e8db5140c5dc2d700989b70dddd0e16736d2b1ec1e780991552d83f28368e6312965a12d2e65891635f41175cd946aa05f47eeb5c70ea3b62bcaee25b9b23d32acb589821f4dd8a96b8eb3afd8b8031021f82ef55122132dbc901948def39f33ab68e6fdbcc8c752ccf1cf8a54d86a4fed591eb54efd2ccc2dcc90de8ebbc917d607a0bfae491fdaec41db0e2db8e42faeb1017e4e73e17aabf520926567908748689909889396f967bdf87fca0995f5ac6428d1bb31faa3b98dbc4a5f6c618d857490c556825a37a473e422eb5640c5f73f6e8b1bfe0513be8facf530214c8559b5ec557728930cc2563606590a53a1666612d049f7a13f20d06f932f0f821521a46e129197a888e98431563d790ade72a62b7fc508e6b3a2fe4ce422ecb667542773b6ca02ba0ffa04ca2b525d7ad1022397716336ead0323a7710c1e932798a5a9488696d74af7ad1107b72336ed9a86fc618964387ec0348706dbe0ac1d190bf6198d67ed2cfb3d6431b69d3d421fae6ff83d5e74739b1b41ce60833ccb96acc335578f96c04e327f747c949b9bfeb4f2283de86a70a3c0ea52f44983d1f8b5c3990b2f04ad22b16236f2058e7f9b2d2322d916511984a6fc68566a3a64a97dab66a42409c7918db78c0a4fca2e4e8b630d37516ca6ed5ca8995ba11de9cf98ce954a3d405b0960fe127bfbcfd2714385475edff86f6bfaa825fa66eb9f1df990b93a9b233dd8ac1c8a024edd5607327a9330f66c93ba5b2252ed4b474780fbe50647775e797f46702d313990b790449e184e9512526037ae211306938ff767e159bb662169c93082a07fb9b21823929790c6a6a4f456e160a57dff2cbfd6cdf951ad83be75a1ffae52a987766e9bb50c378d991cd4ca5cc1c8b35fd9e18b69919854beb39821de983bfc6795536eac858f7a8e9031eff271e816cd37532cae106cffb4d47583ca80396b9570956c141ef4c3f206be0873e3b6e023c02c8ef98ac703638d2de71872861439b9a52ac3cc2cab5f5461985edfbcffaff4111d6b24835f51c9516afdebc19d2328bd59305ac2bc7bb2768eeed5e3cc10327422e2fde353435c38c3aa62536f9a22b5ca297e9bf23e95cdc85365dd3753f68358415c13bc8fa74344d338d62a9adbcaf3413fd39e2916fdf2d5894633986e56de6d503204f5dd195e337add55cdd326b9363ea1cb5fa96c84da6b5dcc3ee746f3f95fd559a301b5b56696242a33f2ff3409851711bbfb308a5621db5879d57ad4ba457c087ec721159af2c3870ae6456f2be167a1c143b633a9b826d00a16484cc65656e5c61e5c4c1a9c952e4dda8a61d7964e84bae5edf7cebd6626faf366724750fbae5e4573a94a437accfd76f32f6ffb7ac5b1652f5007dbdba60ee0ea6685638bd4e50b3d28b9238f837fcbea0355f6865fac884b859174856301f1467012e0fa9f828f758ed3fd111f91d30fdc46a456efbe06966b0a7735e604063a7d4a06749cb01a57a2caa6b89b518959bc947448dfd6a676c40aae2276defaea05078afe015f70fbf84227c016f7aae0d6c24feea10d537cfcfe93793e2a0d7a80730fe7d6d5519088b1e8152e55cdd0ae2d0d3a2aa20a2bcee73972d5b16056fea8dfb48d693ba25689bd8be8f9fdb64d251c573a03537be66232855eb73b0dfd4113a4b81cf086259eb03484e6e5530f1adfcdd323ec36012fee4294ac6db8e8ecd7d9e364259e030dbb069a3c585fddcd3b2cbd34e9d7d7703d7d96ee3a81630ab56f6f87457650f1bdbdcfb2c673368663b64eb8588e14e7516e1663167e8eac5705a880f0439211c15fb793d47a43a0e2b90f41f0dff6cbb44fb825440736685139529c52d2f0105029c5b723656a575f5c4833bbcfa466c55c7b959cdbbf038e7724cd36ae4cf6ec80bd055c1634d8f3206dcd050574d6dcf21f7d39a365153d1f13aafa07797e36a7a0c834509b68aa3df2ba1c943326170e894426bd704a6274a1e70b23a2c8dc7e9c8ed762382a01a5fc902de521751135299fe8049879c80c26ab91a0e6b21b8dc801b9da3d61b60cc1f3414299cc4b0acb403f8f500294d9eaf0f6320d19e52244d3cbc1871a6d0fb2298b150cfdfb7f4a50c37b8b44b802648762947216fa907e03e094295ef8dc5e38c3219c2e0fdfb6812dbcee24c6e03b3de9e66cb43a40d2a66d6a1d5551f7d3a9e208f3cb47be67af8def5dac40ef371625edbf9c9b9ff0d593e990f35e722b86ad9d15db14236379e524d21a7423051a30353666486b48481f2a1b9f8f78b37e68406f9231100e8854f19686797cf8c317a64dec93726c7f18af17e7e4e514e5355916a3d5b4220374402165dec015d9b009a2ffafbaa4e32ac79a6d186061ff50e563e2263c760653e5850b3c0966bc69b311532e2658221bdd3e392c46c10ee344a9d058127389c392844bc361a980aea7f81c280e118f039d4f30f219abd1d8baf9634b986624b9b96afaf0daf8a7c2874907919423483c8f79c7980d7c9f491854e4be91c8a5ec58e1740bcbaf2270edaf0effdc58dbe6d7288e1275bcbb50528f231c8414bf6ab2ecbbf9a97d964523e9122f824eace2d6f1c10409444b8444db04d656314b081c08eb2772c2d9fd07ba55352f5fcf75aa48c80e231800546b0899d4e4a55b188d9ab2599f993e4b64dc41ccc6d96d6595bc13be78dbda90fdbd219256e9f5834cf2d8277456aea7a533516a26001477b5b55a45dd5ca642e65def5313782734506a6a24ac9f1c38422c0bd7d0f79191df4e1bfcf57a9219e7f339f8ce192dad92aa05d37f3a4261f8bd8859826051538873551d434e147377e66fbada0aa40e35a7b8b763c35343e23f008b4778d093464848aa384a8005e7644faa84489c0c57fe98ae2e72c8a95d524ae2690034bf476f90d103663076e7fde3625a79e4c0f18dbf67e93de16f80966b28bf064c2a37079950ad3defc821c218746dbfa112596ea2c493dfcc832619bd17f0be462a1d68d8a970fb025ed2b536e7cc540af234eb10bb1fb9879ed45987c02966d98ff56d6fd3b5171b03f1ace9847dbf949d193628b6ac21766965382ce18e12627b504c4c8e807238bb1990a94a3c305bdffdeb2ddbc541281630f5fedf85b76c872bea32de9231936b835e8fed328fe869fe61b24c3519a02532eb910352c6f2b190e4d0edd22b726c3b3528863e1e04168128a8f35433405350aec5c668d576ca35775ce1cad14ff57a8b923ee02d03ea0357a6723049954a5a1c3240c682407043e6ab6a2b709e1e61240d1c4ab4fcd26c4259e94daf9adf6daf75a615f76d7ba6c96bc5995592b2660c3ff331701d91a5121392f056f985e81f09f3bf7bcec6e6c9d54dd2679f60407c54ed8d23bbc07d72789de42a30e211dc3de0820d48eb4417e5e0bc223e3a2a253997b7ecb14e316df0ddb76f66b00acb0520e26967115bac31b2f74cb8b4a9afa1d428ae0272bbbda28191c5b141bd2ff4f42107ed8eb505826626884811090592e47f60e2acd297648155dc4f6656795e438c6e6733249e2ec4ea2789aea609f2922aea33e331d2e3b8b84ef596568f5fdac65bc573aacf33b6d679d88d0bfd4cbde95d5f4f67c0df6c35339aef32aecb78b0e4377da9df4ce3bc3d576f54f6b032058738f246445405c3552e0250d466a8d54ca53a007074bd26c69e94744b2916f3c9207b9c8a6ca386017cde161f073de58c458064e5d25e0fd20973cf3185ce3ada9f643043a3f14f7922a99fe486cc2b293a9722b23b3342d24ad0a512ebda3a606f524b266428978bbdef90f81173d80dad917b3c536316136b03b4d211675d7b971e56529b168ab24db322b1fa5c478798bc906e25e76bfc884d16420e7e48525fcce1e5810547193d30ed535a5291d471060f7a4bc9c19cc3ecfc94eee95515ea11d78a10b5578e0bd023cfea3fe3001f16dbedfc1d252a0a4fa924809bf28244a30c03877f9497e16869f04768662a81e6dcf2596cb5c2fb5fab3899208b296ce49d73f4539500d9d1e8847f0a196dd81a6dfc325bb1a92840f6248851a982649acd061cf0c95551a612a86ef768d8a8e52233c00eda0bb68d5ca777b8310fe490171c6a2e3c7a196fac95b45d69edeed5e47c83b1e67d075e66f54dc065cc23add4dc71e6d137c241c817638746e67f335e61f85166dc1502eb569a858c6e9ade14d81bd8a0843eb8e8b52c0e706d65d95e555c8f7a14925627d8ac1d696f97d0b06977cd7c79cbadc8b35771239568cf91eb1ef037370c63a8c1f011a9bdd79a6c8c0de1d9b0babfc7a62ffec26f2d60bb717b7a63e395c7740fcfeba9dfcb2b42f5daa5ccd10edc7f3a4a50159a46493fe366eeeb6846c04458dc256f41e9834a42989e09125287c338128e6dc08277a102a619cbd2ecfb410dde6467df5e0f5724805b5bd228a37c55a404841675aabe8fed5c70ae6ed653f1da1b1ce4b85d1b01ccba40d0e902ca4179da2862f16753d10a7ba18cf253e40730a34f01eee7b44a1ddaaf3a3add0d0e8028244dc63a55a5c8e1c9ed7741859908950df25d445c478b251059a6822ee0cae6185976f82b37da6f9a5c73cb83f5ba08c87fea912391fc615a76128c27be29de119b19301c7321f6e10a233f106d26081e5c93178615affa337cccc8c6161b10f59cc7144dcfaf2a210d45accefd1655cdfe3ea0b8fbc142bb56db655d0c3d119530556fff4b159be35e4e0cd415142cf4360af9f449c62b473af8213f3268be4b627f7315003cabb636887fee941254e29aaf5fa7e186ce80487060189fa15fec3467560fa12d321865801848c5d4385a12e4bc70cabd640270041c0c869d9cde0ee75ca0b738dfa78dd98c0cf91374df07e9137a93cf3ee517dc01cadcbfc56564e5acd243e7c0f0758ceae5b49e487e50202fa98df8a42071552a3bd81b658dec3f9c1026629d644b711d2adf6c2348152c3f0eeac09fef4431589eba4c7d88454225f87aed3ae1f9e2c3421c18bcac7d467aeb4e8aba92610d4e8eccd59dd6427df7e59da759ed41a603e96895660420b2c272e8720a667cd503c1ba462852594f3e53b42b3ae15b2ac04b1a3889bf1fa7636ffe181ec9b40bbe55a6d9d7e1a09e884278f91a0431a7f789a1207e1ddeb34a40f330444fc987bee782606b62d98728193a739fcefa5010ba916871bb54086c93cc0f9f46ad6930988989877d4549d47b7708b1c0089ae6b50d4e280cf8824a04d423334031f60d7a1edabe5b018d55aef367d7d89e5591c57ceb52495812df2da0b31c3bcc15ca21cd02d9fb155d68936388775330da6e0329b2443b0c2e0d27e1b4f7b8a3420388f322d5a90ad0b597719682f2277078c6f3f5102be44a4547bb7fc441cbdb26cfd3de30ee0ad5f9ac76cf3013dfa29d3217cca06353535c4a31a76f64810947888878fc1c6715f8aa69b77773687f15b46c0a969d84117bfbae6d4987ae140e79621e42f377f2e91c1e35462b0f9838357349e9c24707e7c0b579f804de981a9dcb9e148a41f04322efdf53f1ee4ce2ea949c2e3f73d2015ab77df25b26384fcdfc4f2eaf177bf1eff4fc0ccc3fbe55ab7159f57291a1c222e866c2768a35806cebd4ed61d13c1ff47cc73ff5d102fc9b2f8608d1f9747d2e4a8ef0a66f5456d9ccaaecd5becd614756033978ead34c7593e3e019f6f9209d3abfb68e74cada50a02631e19514b3302179f201c17844abd3c7f1e074637023886c691b4b856ac9eedce817b371384d21a5adbb602f7e9d9a0d87ece318a075eabc603f0960685432a070f728198fd90f4eb0f03c04e68cc5e520d4f605b94566077046ab79ebe050ad15ddc46f2b964390c3818a9f56a94a51057377157da0340ca6f532a02c8d99dde0920dde66591f162c6b0e5a7ee19509dc2ed4fd3af76db49793f15f0fba1fe83bc37ba284ce3fec7db0a746c034541348dbe05f6526d431939d9b1b328f50800a822fbf7ba23cd61c1e3888c8bf5afa4f1ede70959bf9fb3aec19f6c892e1f66bb46b4e536455d66c09e359a90acd20a4ab6e59d0d52eca4908496be96de1e475358c4b56e2f87487077badf30f4fdf37dade06c4b71788fe133ac49daa3e75d80a7685800edb5fd46c92f7e6706ab11fcb4b112e4c542eb3e7e118394d0b1293ae3f07727d8f262547b004183c0b2bb73fc0bbaa027c14884875296c17f4e775a64d7a1ad6bf1e2eda7df3a4f664c71fd23d5770fdd69e553efbde2e4b73d5bd9fc1a3581242e530ea7ff57048a67339ff7670f523be446088b719592939fad085d4aa21eb74b5646ca698bfd4caf884664704c3d55714dcad77f95f7755d518a5baaf34c70becd251065cacc4bd347c0ee8b537f9132cefaa703869fb1852a7f787f9e8a5ba7bcfdf708c07f914a9a937e6632175e33651b8170cdf9945d1ce8cb58ecc04bf563cd3b217885e5386e4022d74cdfe8d4f931519daf7f6ad69ba78b7d226a91241859ed09d24799d927571488cec518f53e19914b6efdee935557a14846f8b4c4030d07a84b40b6726a8327c5ef6d7737398f9b3c2b3f18997f20d4f43742ee86ecd53f964bee42ea6918656dee8a35029f630c33cb574268c72ab4b158e150aa407c1261504a30c54a16a3260d712b762644007f34164ebfa2a16d1acac5b859d49fe953a16471a06e8b13f586c582dc5b81d793367063536df44ffcae3eb4514ed8b925ca16ef44ae52d1964de3a43c397d7bdce1301373eef70a1544b089905335fbe0b0aaf6b5dbadec35b15f1d62cbc436beb8b62c63570d0b556b57ee6a2fba54669c46f8a01de34649d3a26aca92c055d429f845aafb58fb16ed322381b8aaff2b9ffcedc3c3e47cd585d3b12eaad5025bafa305437da927a85acc6333bca21bb796551003ec59d7578ad11ea6d777cb09d20f9d8668ffc07b8227ee2f768bbdf4ba256ed868fe70ee7b05bedf14afc2a385723391743e621f48bc99852c4cb592a029a26e6efc5542d2dd56aeb921c114bfc107bc4e1590dbcfcb5abe56ad8709e1ac913a87563d79f72689a4faa3576a2983ea475dbc941c9208c1a8fe39924aab164cb78e2478306b5fd188d5db7f1423bb15ed58e0c6bc7214958457a36c66a4489ae0e2faf02fcac58b3c1d5465246c3054f5402aa398e642f784fc1ba3fdd8be45745c3420aa25fcfb6da2372bdc9480bcc04aa887a6ec0b213dad7aa778c6b3f48b0764d6d95b79eb5dfbbb387946fc7f264317b640bf3e4a5777e32824d4669a07ea8a5125cb71c177c7e46018a553ccaf36c3121ec1915c2d7d171afbee0907fb013734c642cdb45d2357a5dc60815391b8203b319bef4d3ed600e6e08bd85714edac0c264e82d7c96e60988c9bc12d21c5ae41236486c7cae24ee8f7f82ae9383a4826c6d9cb2e4672fc3b45c8fc4c891ec05d3eda68476e31b43d8ee7a8cb94272c967b95019e8a976bf57e05029336c4d356976a2db9ffc9c3ce61063cfe983513bddf39af2ccfc7a911720dc3c8a6fae130b3c55fc00fc45046da05fe13e4d70364c3d9e4b159aa38dcc69996ae8f98efc10c2d588daec1ff18d6f2b2dbe1d2d0acb4ba36f66db717041f37c7b87431887072f5ad33e414b6a0067c0a06c59244ae2138e63c375eea7f37982351ddf98ac1294f1ad7c8551d979e3e46be09383f42d9e54b4777e20c0d64aa41638172850a6a9327a2e2b250320c4b02f7d4ed3d1c92af5327b34968503fc73b5a4c56d28b147fa8e27cb843c5fad980c53670444852d2f543c140322b660a60a92d98f6f7774616ecb0b9a797c170af81b260d4895d8eda900087d093c19f826a2d9d74d49d005fb990bd7930c0e600e94e99df08abfdc7992f4d45e057afcd4e475a7a3f60e26950c0a01f03c5be448b2dabc85f01413574ca6d9c32cdf6503d3f97ee850a38d02f7c0e118e55c17403b37178861c8a7f6643407c8f17a629838c62b01c2beac82f8466a536160f79255ab0e845b6c19353d62799e1881a62a110d71fccdcccbb7d37fec4c14c609267a28c467b50d31fec0df1a19488332730f9026087b9f02e94be187d17e4a242bc2682fe8fa2f675d558c31aecae294307e88953616f692f50344b81a2a15f95091c349ca386824a70def45d8fe3016b77182e963bed00809a77268aa36004e93b87b70dfe900facc9bb9a5d8404c74435802d4138bf20813d3fa31c7eba5840eb9241e6bb2381967976a90dbb40f66c425c29eeba85c6ae320ffd0274e5109f6a744ebd7005e1273fade02df0d14b81dd0dfe4e9553a812f8eef2980f4d893ca68967cf6a43f05f4287cc51227ccdd897acef8e1fa1ca8f1a9cf72fa3d3ba20965146860e8ac6ccbd921d9189c13c456bc38bf163e62cc958edc735f0250d5be81d6a6481e98194db199f75d03bfc4a40b0fc0c612c9915edadcf4582a59dbf3e786801cbe46ed14d261596ed6c8bad765e067c43f3cb20c4cfb5d4f2dadadf553b13b104f429bc62b0cc49aaa1dec171fdc78a49265a8bbe95eac6b472dd02bdbd6d7fedc7e8f273eb444435159f05f490727a4a83160ab83c73d395b954e1bc1eda042c81273cd34641b148348a8028e7dcbd10424abbd8889d5567e853aeb63607a802e8a5ada83ae6d27ae27228432b884a28e104045c5c012bfdefc2898373d451473aa7f41c2b1aceb11f1611f61601b0b4de058b62e17de90204210a4a87000594c90e987dc1237fdf784c82b7bb1873e90631accd4f3b5deed1fcb916d8f28c4d7283caad255f9db51f620e1bfcdbf43da44eddc1caec5cb4e5b6e8540dac9a3048007c9e47e8870c1f05b6d7c07b4b18d2a32bcf02de3e77c42b407ca0849f547b8beb09d80d5d8acd8e342aa768a63d89a2b96c7d4f20c6bb122e52d1c29914ce0b3dd7a455f0e840a2f5d688e8a2c94778dfad1f12a5674a5798fb422de4f1bd235531bffe0691a04969f3be9c38a50f31e124b01e0fed8c37728b4d70af81db4d0e0a1d116c07515c3bb392f6ece7eaef4df6f393045340a005750d659124bc527eb6cfa65b8c89fb987a28fda7a8ba0dbdcd50914031a844dfeba2721f76a78574f70445224a02cc8bcddf88b497cf107d3f516dded77930eee356faba28e666e5cc6df77b29c236efc1b990b44048ad48374a101523027112a24ae2798592e81f4b40dafc57d6c66affad55956c778538ebdd002094a34de76644a1701540e5b559a590a4cc5e94aef0ec9edeebf2f5e9e165fa675daf9eb2d070664cb63305f52802b86cd8c3353ee52765b6d8df969f1cc00477f579263b3ebce19433a14851c733bdaf867fae13377db92842f5d184cd54e14d5430091ac914509dcdcf582e1b6b40d96d74e82707749bed27278a8ae6a11e2517791553ec2987f556d56cebd9f4f1fb9fdcd3ae015a0a3b8fd8495697e16ef1bce0fd00e62092d103d312a22800b55b3d7a168e0629e81146074054441ff8fc41d2d49214c3088c9734d11f902d7d7dfe3e91945542c7aea64fb6f26f3e56edf818310d08e6ce154ad26a4b4d5b6c9f35697ec6baec36c5869e05749972bf4f83ea6fcbcc4ef8596cb628eef650e2070ef12b367bb8ff41c13e33c8a93a48a20ef06d18a79c6f2306bac6294a3adeaeb75f7b15dec55f1c76912ea3e153661ad921b9b50d66efa4573d93aa1cd183e372026b233ef237cebf4eb557987034665af562993eece4f0af53b528f393bcbabc47589d24f41133dc96c9fed61569838b2ffba1f18809a0a2f4649d44fa2a806fb35fd108d60e8bf9560c5f37dd9e981f007b63970d9dc3e22669eb30c0e8a0a6127586d3625083cf9a7ce21bc8c4cb9a2ecf5441a515f442ae634b585f52561ff552ab6a605caf5e898143b74548b238c60ada3a557b5f67966b0edd4473a82fb944f63f183c96f6611635d6490ff8c26bfc3074c816045e455240404b11539ae993c5c8d3d9f77c13b946902feaeb5be5422b584b0c35a55ec03dfa21eca8e11fe69235cbb6556869279ba6320dd7c1cba384873fbf7a43558d1afd38cd74e2be7a7258a5172d5e94c3c4ebca29ad5bc930d8a49e0fd4fae3f9385e3ad74a93ddcbfd45a5eb18a39c0c6074b55e2bdf93a962fb7f69edfec16a82fb1053526d10faae7cf152c4291d07e7d942fa6cf1146c832f7dc02e6ee0144dfca4166774c1059924bebf88418a2d1efc02a24c1ccac76ac3e14982e45d0cf3328defc67706dcff0e693e9bc571047c07c40631aaa780e824ebc8d6204aaef5c707c0f86a48a87468c56dc9950ed8dd50d082ccb91da2118f1c7d451a7f1ac1edd03d550dd5ac80e11fe0590dc71d5c8d145a0c8a585ba9d93b71f201cccd4468e4eba2bdb0203155ed944a8aab969c276ffd5f28b1b53102bf7fa4a720aab4a7200268c8da4023d0a7b3823928cdd4b1904fad3bf39b9ab1a751e46b6add74f24e04912ed0326e580016e4e095819db575b41818d8b61591d381ed719c61322c8dcc5fc5e689f9527aff1cc8b96ab736a1757e089931392e7c13e2d25a71dccc226dca061a58f48bd04bb11ce9bd18fda8c940b8418276d2740726c40bb80e46344da44cd2451c341973500d0733e77cb2c7d874175a27e604fe579070847077f812e1cdac07cef709d561fa6e8129208d0af41dfca002ecfdce5c25288f0e6d5b7538f601418902aef9914f2759dd859964c5448c740ed061cf36541a16fa0e850fc892ab02b0a67c63f761ed2580da04e380a684a715fe28e76cfd0427f64ca4990e029501acbdd4dc8a645a6d35919563be54ccdb564fc29a059717ae7ae2e15cb14c8ef90f37d975c3d77d961d28b36df21f3abc7a6c1253f3884e2b9b744c04a28b5e251adb789e3d7576ef02cc0aff2d1bb0f6e3b0257a820b10c4aa3a87e2bc18671f80f55351d763b88a92813b6181e08d23f2136f87a76f60a8e02cc69097f5991c0530ddb36e6a0a8cb98fd29886cfb160bad6985b28a73853d7c7068cbec25b2ec7429afbc0ccd8914338b704bac5ba3242566410082c536e0b28cae839191c70c1b2ca1afaf1da4cc13114f6bdc46289cf292da5a2438172f3eceff6a559c783aab253cfa5768c1743250d57095533ee6a10d3f501f3dd37dd5cd7d33de6fe98cb16fdca9a02b53cd68705db7363f6348b5692c3151a0249a1699cf5bc62e19bb57bf0df29bd4b0fdb3c9f6d912c0676a3650f1dcee7f38d0e8d557a468a0fd74db7b49478617ef861a6a0f4ddfd5f49dd4062d45b6fe9ec08e1bd168e4f4431ad8559577b7796eba24dcadb13683dacb924da0ec898b46920c2ff83e27b4963eb756bf620a17ae9045730d17e2f02e1e5e423dc89b9dd85c8de74b829745a41314d1ee5b8fd8a00b99977bfe75bf828bd20f0af2e396a47aa0f54cabe4c45ffd744674f465488527234ccc039e2ba777285ab88c4b3bcc850a9051f2a839cc03696225e59086b4aeb7beef85941a8c41933ca608bfb294c8bd2ccf3f2b7ad6cdb8610816d9890e652b5b9e2239d420365f09acf8474c68586bdecfd9d3652b9df8fe93e134da68229d40e314c2c7ca9c08cc6b4c980b34b2ef5e1718970b50941dd4b0720066665dca79f3f6fbd3ae3c5c9e37a12a60f21f52fe8af44ed85921643ffc54765959a39cb13d5db95a2e3a4fc062a71d0f16fbe5823e23d13a83210ddf45984c6da341696b71973cb86e9baaf23aeac997ee9071b5f7e90bcd2ced1d563f4f2e3b42593665b1160ff5c98873aa30f47b4acd02d227f828a358d147ed69ad06b095fdd6d4782acea4f9ad614602c77d112c43a875425c5c1024dfd35d3ee496734bedd396300309a40eeaec3810262f6b840f1088e381e8dbb9507a7771eda4e704a4e4cc929fcf79b963228dd5eb0a1f29b5fe57196c9005a316c45d8c8414df806d2dea9141ab61296f729e008488ce94fb653f02a857bd01426fe785b1e4ac51dd1e4499755a8480b79b5579083dec422b4e0c29d03a9d1629e76d27895b48389a60fdb6f0514163e0abe5924de0e0bd5b2ddbe800fa0df49ef4745e19d9ce2858a227215f883c720d66b849925058e7b07f9e5f659833882ee7437dde915fb4ea55bdde55cd09a448248f91db89efdb2b3aca2c2aad338234a2350c7c4c7c5d398515ea4d78cd51d7015e1ec17461c2bf2ab5958501b80dd8473662118f516062d758fec2dd2f4ada734c496ade2aa09c8be6f6d860bc1b2437ff1f77ac91d91ebb23e96cf586cad7e6005157f118f5ed2c1cfc0528616bc035ced4ebc3c0a8201db287a39a9111e1790e0fef5138efa222e04c1d831afbe14126ba8dd72ef0a3de0a709019c397c88d11041b8d289780e649f7937133d92d32cadbb9c5737087aa13dcbfe071b256d10cbcb8aaf720634420ab28ac6c3a85e37d4797a0e16afc91ca7ba82d2779a815bb39a01b693a676e3f8481ec31947d7f52e775e4545393e2cbd08faf10207a486405be24f63473d615b22e43f995d04e026445586e6b9889147b5ebf6be84c563b013340a78b0266f0ac83cab93e443b8840c7eaff620cf0106489bdd19c727a5c7684253e1be9de05136195ba471787b737f9ed2c08a9d90aaa03f402089cc2815c63ddf615c9f647db59d6d8fa014accd30d3b57688e9cba8628c8dbe2d8aaca3f1f78326d69315c7f9b93ff7bd75e7ac82859d43357591e15dbcb8f480e67012ee6fb11a64699237a9c8e90904c517a165bd327955ae74124ff6a69a6b0385cacb2b0f1ad5329857b8c97e6ee20eb15048ab212497536e6c12a30d41029c29ea8dbb6be59b39b4130b43ee423df983bcd7386db93557bc7203e84e90f8c4e16b07e4e790f29170629ac4842a7133b2397f2c2ff0fca716b909c3bda7314aa3531ae8fb6c414a85ce38296820a3931fd1e9b8ca98c57db7bd45b85764bf92a3e1722e2d9aeb19281ea7d4a72327b67a5341f8c0f0cbbceac1ec4ff548564e33b5a714316d3b6858cf4dd1c470d5f41d7b39d76b4bcbf2856aa4e8043d1750836bd8eb4e0fa935f40a0f753a5fd0f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
