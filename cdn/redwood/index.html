<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff9be519eca9f624fc940cde7d377860fc194f95b6c3b7b769832ee7f0cf92d1a32129f78223fd7114b175f127812a63d9e53710591c520628cac9658e156567b39982a4f0359d74347c85fb710a9be1d66b891580e2e7f202ab7d1084e85aac8796ab50edc7db7947761ea19735df1a443af053f874b6e76297d11236fbfcb920a845195be90999732a2d9edeb2b054d68248e6d057c90cb7fb40ea8b4927ffee5ab4f8bb673f635b22022c549574daac1176b55cc75ed9208508c057bca9d911d11926b810e528499e767c5ff4eb3cd0053a8c3f3c09bc1cd879f82c7e667b03af8398c54ebdc7580d9abe89fcc39da2256608c57f5656f5f819a11e395960d29bb923c20993b2d1ae951a76ea606b07abb2de3012793594b18cce0be102f0dd100fb94e70e8907ec3232be4957735aa2c2aaf0aeb8dd1e6899bc3ef2b5caf3419c16f5bde2a283b32939dc32acbef73a03d424b977de97853462655050c6719424690514e550fa607499c1d077b76b78f3aed5c3a14767d33207a6a41f5b7a97fd4acca6485b35816e8b97e918f7e81843a08213342c76f5b56880f11f29718bbd8249e4a9aee046eba67816eb1446ec5a5c0d06bf5a561fa2a1ca3724c9878590ba69a8505c9cad8c5a075f7563c833750b8fdc9536aa8d4ff28a3e9e3494fbe13110bdf5fd7c5787c7708d2d7eaadd6bc0f62bb90f9d8e62de20ada810b6bc738842b4f849a433ae58ad5e561ec2baa3cdd77a247d49bb471b173ffcfec18af94944dacc9bf0728aa2180919d4d49d1f5acd1c993c8e8787f1be6a4e7c08b60581c668c8bdc1395f2a7301e78f1f1ac0ff71142f7e917aeba596dff1f36276dd419e1b9e2efaf1fe78901d35fe5f5bb5909aae1503fbf3cfca1b8b9effba00ec0f172b0c27ef78e9af4a92ede0ddc4656912dc1e4efa90c0520f2414567bc869e487638dd3f6fabccba6d1fc97206223275f993d731a4c4051bae67a90fe3bea412419f707aa0e552faef58f6b8c49922ddd473020b1523e574e6ea9371bad587cc28a70783b9cfef0c5a66e60c0625fb3cf0f6e65a5ce82f3f8baa390b92939b9532085c446b606fdfe92a2f741ff30bdb2583ec370ae94f074c15f7e2da64db13422509a03988274ea1d5d368b02f5d49274588d78a6c2f8629db2c1032a7d1c93ed9987b13dc79248580710b76dd6eb3eacbbb4e8630bf1b210afe26e1ed8a05b2eefe899be05924ec457aaa4d22b59a8239624592d3e39f8c995f08bcf1514caf9c50b1283851e1293d8682bd41f666a33de7be9015e403ec78741193cf201aff78848eb6bc1f8b96e62cd3a51df32b2c9f591b908985059dd171d29c6803a723bd2c0b0b4404bae52fc8392a52a86def6c0c6a4af18cacbc91b3a56264ec15afe51c1b875ec98fc2dbd59d7be21d0e95eddade2e465263467e48479fac538deeabe8ed43dea5c434f1eddc6bd8b09389a43a2c0b83526f5e3a2213a4c761aa05c8e5c29ab734fcbc37b55613c72e628defb41af568aa4efcdf7b36b7c77913057e13168da2b4f90a1ae3eab2b8586d5d09f419a49a0ee4447337acafc317101128851abeb8b370553a4b02d6ee9640d32154fb406ac948581ec8811b48d035188389681890dea2b78079f13b7e9c00a9f864e6eca77d97f090c546afc2df32a7c2f34475a94e241155a2d2d8fd57865c212ddb4a252430d88c55a4ae4417401b291999650a31710dc08b5182bb01c9c2f5914a8c2af836e020605fc5d1c0e72df82e0a6f1e179a1e7d6698a3e0a33ff59830ea4d3b0368b0c05a5658d39b6d5636453fe1eaa9c84d0ef2a819f984fccc2eac84cef689ca47e811490a6c3a2e2e1df05d550b2836f6fe767629b1c21166c0d7d86f3c92ed44a525c7e8f65f2807e3bfb59dfc92d4c27d8b811d90f4c49bf90407d75e77de25186b3de2806edd76a6e7f9b0e93b38035eb1492c4640eade7cbc75bb8b5f7ac5e23510838a98dd40b1e2f8cb426c009bbb2d9e2b7938635449f65482ae8503208e65b43e49f56eb981e74aea23a46885b7034829a34a062886f92c52653cc0e5d3beb5a49394f08807a9ab9f1eb252a95821d92314bfe028d23fa1701d782cd3868eb27efe2f05dfb0bfdc23cfdd9016ea976a585e978902d06aec84f7c892675de682cef1be7f72bc9e1f298ae8f611e12759c1862921f09ebe3fdf08d9518ad84c33bd14b37ca0be9cd2bca78b50c5955ff5572e0d7fdea7601a67a587450bc4fef449912d0fad5e94b4f76edc6c8a17a3f0366e2e3ec07fd0716f09dac358accbf69d25ca955acac7f218ecc3b8cfef935eb05ce0be43a3b0cbdd84dd3e0d93f31029b8c3a78f39ade135a323fb8ebdd50a47a51fffd298c5e2cef79237e97274e778fe9dc1493de8a889926aa0e559b702eaf984e23ba3b802d929223d23e3d9ffb5ea251d5ebb639681b0a67750930645fc0a810598ce6ea716e90b0cda8f628a045fca8bee448c0f514acb110939cac07f3ca1c7dad5c0329462077560d9775405d9efda4f575802bb771d45b6ba48007dcff0dca863c4d4236d6b821197d23799dd757cd98a205367d4050806c575d56fcc24af4ac7edfcc4dfb647a08db8cee3bbb479b8be987e693bb433218f8755c40cd0b519f59151cd8194bae806e408a179f4faa85ba473b7b0a15952a89d3b44ac272bf670cec7b53adfcccf1a3823645f8680d57ec31106cd9933dc935c22b64717865a7d2d47ff1485747f788c5fd0e2edb4c3d03e9ecbdfe780cc786601a17ceb308a331f4c8cfb0ef862853ba0a9a0d7a95b7cb6ac91955199cf3d25c0ff5e100ba3f85ae280a4d4f553bdab2308acf2666898f6afa2a861978d34da63e697a884cc53ed32b8af1f7e3c1bcc2c4b8420c1818074eb7b4534d99ba736fe6b46c6680e3277c132f5a6331b30ad5690109958a2eedf7cf8764676e9081ee537c0e9a9c427cd34356c1ae96ad2cbb8154234bf358af86f52007ed1d4d6ba43c011c480f96266728694c0a1734d73201170d0c5d4a66d1d5ed81cb5fd9e7bade01cebae8e41c4dbfb3c3c26c8551a0e23a312515906e98f456e847dd5ea26d45110e816c5234d0b16279381e0906e2b6c3610ca9addace73ecc808e27fe1f957e73dbb3771cc63f9ce227e04e61b69fe58ceb3ed09686465e23d2b6de2eb6f1156f238ea5e66b0a6e09de0cac30ba91b52a11bac5e9880feaa9aacf6471699a57e4d78234401d3711777f20f5a9a5cb823a417dbb07988fb145c9b417979a29d410cf704754efc280befdd21fdd952628b3b9025810239aa5019620fa962069980d86cc939978658bcae49dbfabf7fa231741965db4cd5c4ae37a1332709fa8cf434969ee0cb92c1bdbf5c6b5f33fd308320ea53799a2f507117d635b74a589f58d803dac4818a762bbc3c25c2a3a4108c31fc7ca009ecf6a9456a9eae9dd62e62e23ddfcdb82e4e603cb671cbe5df7b06e79db8fc3242b77fcf5e249ffbcc72da5af7f001a49823a3bfbf6810e7d4f00e73f5cb901ac8f37b42fa2878b495663f7c5f3911b2da8966ac8c4bd1a8b925463fcba77ad9c050dce4327730c8e9828dbfbadfb32fb7163ad92d2bdd80adec0463c86470646bcc3e4642d5822ec568413cdf380f01c67314df71f92796ea2d0dea0d56c63467c4eacd253d6e69b17ee8a22e6f8aca8999281d641b37c2b75eea06dbde98f3863a729c0ac9945153436199f10ac1160e8f710c5fc99054c66e0ebde0fc3d246932a4f25407dbd017bd57d7c8c9f3c7424ad4ef17dd971b64578cbddc1959ed0dc16a2138fa09157a752593a21a8b044fc57cbdd357ff767f6e83a7f7cf1ff57e3b53884206c32b6432818177379b54e5ee333dcf086bac7c232f09127fac1227fb356b95271ae642d4cb793c8d89744426000b9179f5caee506efafa44d37cec1a859b7741e654f9b0edb39b2342e251a3fb557a9855597c7e8bbc0d0781ec14b1b87eea4574596a3f308a162864b0a994b1f20133a101029454ce7504f2ac373690d366bd903e8c98b8a927b274716710b3b46d236ce7b4f70776989d82b1481b8adf4534b0c3add0dc8baedd9607c350f97342c75a55587351c7ff5e2cff4e2265a998be606c369ab42f31935ef53811ffe6928f4a19101834a06cc2085473070ef0b2247a9d15a3826e446bf2d115a7ff7229086f22a2844d3dbb6204b0125ba42ecc6777153d840255a99ad1b207fc564ceccb7ee5e4298ff467b1ac6864cfdc76f3039e3935d637edbfb3432c10a70b37ef8bb165bbe7b2e2e73918baf391790bbf67a307ca5ea66afd49e5767e12eed1ae59b4bba7075ff735ab5ea9a9d0ea73764c20aebd13512b0063aa9b5de9d995a4f2784416484d99e012ba16b0867e4be240cec9e8d87eab9dbe7b413e74fbb7892af657c8681fd32cdfeb337edde214146fa9bf854fa58b00d48f4a073c36fc8874bfc480e6e7aa6e8f8ec4b54073ceb8a6825e8d96e4a28b2ff3f08ce2c5cf9c74da04bd40305312639499db321bef0634e01d16916779640a94cff4e44a4df2cca6124b722272df8d7d5318de8a6e7e581c75c29d17807fc2f04c785e62b67677f2f0453b9a3947b6f9a0148d3517d04a6b98bbdc0bd2268ea1e201ef5d77796c97b2e11be0860e5597ca2be3f04f49c1c948e4628b76bd285c281b040dec66d7d2bcb79e11e93a88bb50260a3caeae4bbaf16c78e2d770638aa8542f47788832ad4887de6d7142a843e01d62ab1321e6fcdc51c23dd00fd6893042ed93fb8d2f70c34fcac88916ac04267f56e56cb573c3cdf963ef584f55e204bc19d8cd86c5bebe69f49c5c80492f1b1114e970f2949cb5c09ecdd2a2ae883a4688973e41a89a163737b2b4dbdc7e663290c2f02a6c39340bb8d9f82170c97dbbcf892f7e87b29679dffcc2dbcb8f841bc16a4f9269b9469f4a1972a1f4ed0f51b66cec7d319c4537becca8444d621edfb5e8dc90c6bffb5506f0c1782581747082f4036fe10101d78a944f27c9e3e4cb110260fde96148a3f0b99753f4af9455dbcb1b3223b5bb1ddf930ccdbfd9ef80b3f287dde59ec1df9a8834069ce3395f2bdf2044258232e32d00c92a1d625872f0144d5479dc76a014545f3d7365de3756484b111a32ceaed0f318d890c52e97fb210e4ac9076a3990858c9485e540963e7891c91d9e752fb325496e70f1313770b690a8b077aabae28588e715b4b8220383a2003113b5da846bed208e573ed08fd992f22b51ee7ed4b444a86f155688de337a96caef0055397313adfd9e420d918d989b77019753c81f871b13bc3a87beb73922ef15793cc68a67f30d3b89e72e0eba0ca608858b38071a632de24ae33fb5202b17efb06b32555e871efeee5998e4be241afb0832ac275011c8e5761bb3f28b1db396819d453ad2a0647ec0e4cac3e95d86b837f46a42671055adc2d0e320bd8b5557c18970e43033ded4e853c39a5d58ed879232b632c2be39ae75cf3a47dfc13ce699a45e3b70c69ebf3781704f31e2ec0e5c0982a4ca36992a5a904afb790b42856f5433846c5b0d5101c5f798365f5d48049ea66bacf65cb3c6461a28f29f5add559a82037e99a7357a1a8655668f998ca9aef6dde392fe65cc22856939cf1b1ff75fcf7b17ddada96a25aef4e7c89c27e9fc4884b648eeb1f2f17038114a7724b542097ad2e08b6979bc783fd7876fff4982579519aa7ef68a31fec46018e126433d66a4e675084efbf9e860f19d7737b8428c822babd189827a26c50878f73b3fc4a428aa78c243af26954ae1e2b990217052f88852d57ea2b0178e748d87b5632fd8d67771ac3b443e3336c3439a8a8178fbe35bd081a21c6aa74e11ffb332159936c8a04e5b14f766c5f418b76c86d5295c4b76d48e25b4b2007125122e01d666340fc69d4befbfc6ecf4d09eb05662c46168fd52342a796458f0126941803e1e7fc448ed7b0b1f1ef9f538da1f887ba84fc11dc1201372cac8b876b6e73b7a88bfdc861ce2486dc6c63060dfbe5ff1ea20a5100a050f8990e8db17f5ba98eb4e6079a6775f82fc9dd363ea5dee37e11d5ca9b156146f3db6e1eb9985d924c9f4e35f06e19cc502a328a67910a996070d691d555727285735117045761e271915f76acdbbc594b464f2698fa9fd651baa376b077207e560125654da3df9c3baac851d2e24e15b0c1bf3a3431405f41bfb7c6ec79e43850899ab8e2a6549efae328b2016becf01745ed04289db524ccdb2da7d49ac480d5becf47bf573c127176465786c84a634c3cca7014e13151064bfe588086498f8111b7bdba12ffc110e062e577ee7a7dbe37a4faf512462f30717ff3cac788eef09c0a9d9bcd994a0fd84681dabd8184e01586892caeea9e417fe4b1fadb5d30ea8f73d13438c889442ad0e12770a931659c321429c6a41155f30bda53143adc4a8ec6112c908ce0bc02f381e5322f6fa43ed2ac48bb46e70fcee2d866bd5f23ca7cef58a824f33a2592cf58287a2339816b30528726eb892c43e961d5e1a74950b0ce6017894e8d7ba65b51bff55309f20f081e86cf4766031180936a323c3fff7626fbaa1ebd7740b70cc0cbd26dbbbfb7abbb5efef299cf61620a4a66390891c5a7035f7f3ef3f7cbb44cc37651009c416c777a985c8d28129f4d38eb81472a96aaa17568203a4818bfe404f82f9cb257e5a0f1e4c898c773e5c6f1d01a3b1046e47736b19628f6a1925c1ecb0fa04988e14f7c4d8449e25726615da265bc60ca5cd3bc946b541931bfabfb5bfaad70b467c1ddc77059df66a31f3217fb5469a96a493c98dec9f316a30a80afb289781038e790e0fa2130cc20c7e0231b1dbc6a62fdc3c22e79a9e293f370b7ad9c340f41c59c24367b9d09fdb9d5d486f0a9ab0f081ad9f0fdf49ecc6443696abf0ac859770c03a7ccf3b2a238f5ff639b38f604fd9ac8ddcca63399cc668c7dfb4d4b274a2427c8b63d0772e0bb027f02f909436af8e994392856d5f80c69c9c62baf8b2de98c02e050ad3681cd7e9ba2f4f014d342f17f46f84064845e73c8b6739b75bfb180afff28ad95a4e289a361214444f4d788d31ff2eca7d299487d9c091ad9fa847f96302e2ad3d10407feae91f39344c6e61a13fdd3ca6533d6d2c61853de5ca660ccb2be29896cd70ee6318d2c7a41adef21735126d7caa8b72ac3d027b96da4eac52b495ba835b4807537a686469d089471b3ffe95d5990336691353c0be2df2b077b011c09e3bd030ef33864e6b55a3f4172fcdbd5a145ad89fc3fcf9e6488f711f76146d647adbc1d6e1e572f8c63999781f602b8e41c1455f430035c1dcac0fb7dbf03d95910f1ebab5cc3c955cefa6c7e7f842d909f966c4d96318877432a4051fbd0bb37c451262b7909dfb223370f91188b511f250cffb84c86d088cb505921ffb02a88edd387eeaa98d75c101b080d94f3d15306d52bf56963f56a29669f079a29332f12b4e4af17cc2760f46121d90742b475ad8fb69200ee8a5a81d30cdecfa4838cdc1419e6b6f69e99ecbb6803b27b029dea859c7e522b5d72f78c182aac7cbc4ce80aaa658a6b7a63c6eaa3ebff8c603144dcfc1bfc7b54e8c936c2729d698406414ffda0ae7f6cd2119cd4b8762819157f5062dcccbe142d99e9d386948a9b548b8337072ee278dcc3abb2352ff4f33331ae1af63b3494318795082f5771ac468a9438f69e99eae058e7756bce44705569d3313ed2aa91a80fca3039445b9a979697bc1ed551979536591f68c860f67d2393ff49ca090d9ffcbfd4265bfd72c0ca9bcdad32f5e31053206d3412146bb0bc5a6a16da7c47e0a6bd058db0b78e89f9a043250a0c0e647f39f3d9a21f0c643eebd016155c0c8e688ce1b963e65ff840b9b92bfec05a7d10041084a068d3eee65165f7c5a4dcbfc335f68aefb1b3b0c5394d48c00fc0a93984c3635cfa16ec70cc6912d8b87e80fb1703fbcdb012ac4eb05688fa3a4ef3248aa32e0f838e6ca83faf12eea663a4f4481f4c44546339704b5fb1cc1bda469b50e5c14ab71d6a7fea3d73df50a90185c920ae8308230160ac6c84e111ec305c79971ba53bd68bc17ef3ced791c70a0ccd6dc5afe90deed6efc030c534bded8fc80e9905fef3f3156270e5b433e192f438579b2ed6c2651961890312f25b4ce4436d3d57cbcea14802caa15b70730323fbdc7808e85a904eeaf2775da33a6ab11c58cde15a19b449e94de1d9e61c3e469a11fbe2bc9e4b2cfcaef5eb188ca651aa87c116e136e2bdf7c36946752099fe36184da402dcbeb28024c5c4db5d249bf7d21d8f2ed88ceaff3b78a4b933eec68fd213842f8ba01ed46042ad34e1c3a4ff9c039587e7f79a4de285e6990d75d4432219297e73101390c4f60d6334b05cd5c81f27fdce6a62e0efad8eb0d98a3022e281de49fa09584396cdde91d9e25ebdbf5716512f679f9fe990b37247e46572e75e7499a2cf2a730110bd5567ab933cc9c5144ff802acd4d73e4a44f8dd300861976e0ffbd0af0d9fc49f8d054adeb2d6d0d02d4d0ffaf2ce65b62a8d3bda9e54d484ff7785c18401226a0c2b3394c165ff9bf3f3f8acd973d63301d2ecdc73bfd7943c2abf287c1658e7df232906bc6572677e2016de0e1f6a95ff7e207beba272d6743bc8d7646b2868f5ee19589e9075aff7f390ea7ea57ecd1dbdb291159ec4727f910f2ab80d9f12333484bb6fd607bcb47d8c958c876b4c79dfc97168cb22e1e4c205d81676e6f6865f793e35bd997a6d45106af2653c65026def4f0a585007c9b8dd1f28b1659877e788fcea1e170d1a05f65857932f10b57f98fab4da2a6dbb1865f9f4180586ad5b6571ce8472332acf61ce1b4b127c8ac0822dc39047892756894dd3e5b17c18c768025f4533eea6f49df1626897c23cec805efd3e502c3c89e8c34da96c02fb087cd8e5f312c82151bbc50314e213f272c4c7485253bfe49b39371508160c02ae190c72ef7a158e8597c9323cd3930803c6cb38b1d18dbbbe34a70e634f4783d347a66689a5313d6f88b13cf5c451e18bd437248bceeb506ce8d904bfc2ac9faab51b1a3289cda4051249b43476e0890876a5d31e09a6527786ea102cf8b8c025f07813af0e5dace1ef8871da339cce5e6c2b8a5e631a2611e47e3610bd9bae23ad7799f3f1f01da67be5bd2900aaae23d386de8d9a47e2f343423b53aba76ec94597cba4d808ec1c8474d62d40b5055ec034ca4117333903458bd3a8834eceaf96ec07dfe716f036cb0a8e489afe7bae864e42e7cfde5f7c4b85a64fb905a32379038a2a4164df8fb07525cc795d066979519597d303dab493a3e1bd636a3bd0a588bb6df0f843ace47349c100a3589b971ac59c5741cd45b2ae6db4caaa1e4e82bc6e902f961330f80b1174011ba05678b65db2b06ea450fed61deacf66a9d3bd876b1ba17be7a38a283e44a02bf4342ccdb2a72b71a3024bcbc00f1d043d4cb2a0d1758facc663b4231f534887f146152b195abaccad38f22abdde29fa65cbe7d52d8353bbef8976f9d8a40cf4317eb3788cb32b2dd45f67276e56451af1cc729a0d4d48dbe2808b3641793b48473c78ffc4ac8cea7c0348cf743da6bed54b798bb2eb7c45ccd13026806a2691cab54b88002d2f0cd4f990c2f599efdcdbfd32c9d5c16424f65c847fbbeddef12f0958286e256ba07fc519323b38c79d9133f2b31762fa3f6a9693d5cdf5bd2a2ec2d19e83701f33ba3c7de41283185d507458a2224b057d992485d47a4189dcb908b6644410fe95962c19bc763146708e6d97aa6ae4ca9d3edd238071fd9ee5ab57864500126bd524b89c1aedf1b3ebc60b7f010d76aa5a1155aa0e9d46dbbf5a4c5b104a0091b35138fcaeab854a2af48b9f07660f4d0f429fdc1f8e5b62ad01caec40e02c78e79e83a4df57acec96952b655b1a236a62bca363d8c2d6439ad2af59a72de49ad8dc241eae7a903c645dc98c9e518f25cfd67addea2a310bf68c584ded5e1959464c02a2cb694a6e0d013656900c525b054ac224a29ec40a8df2dec1cf0087a5343d8252985ad321b599441ead111da3143c74839b44d04ab3da62b10387b47686f7214503f17117ebf586f181289076e0f7442cfebfa47b00b80a4b4e14fad9f72ebfeb75c3e58277baa184ecd8cf4a7f416bab2530fbb463e7d5289d99318b98b996cdeff84a6be29c11f388342c0bdba83ea9ea0dcd5ca06e6b6fc7a23cd55ae644a6f0a42086e5ba36b7d61f8142b1533e0aa3ca6fda25a237e126ed61504c9930be8df07fab7d674d63331749797cc680ee5093f44684b1bbf3320c1041e56bcbdb7bfcbc496b73cd3ba9964e7b786ec2d0a1bb2680266e4c859637d96782723eafb3849d217c57e4e132fa5e64748b369c3a2a652b9b57159a27a64c0ef513758c28c4d438e58acaa54dcc88a9ffbaa1acfceca225970b9c5b21c9a4c9a1847e76e624fea82b9ab2bd70b143028dd189bee49131530baa2a0bc4563e4737609ff6d0341eb3d767ffe85599a38e4a76d81a4d5bb94c3ce0ceed7feb2c6299cc56e289fea7b596667772c1952ab51470fed898e940729308cf9566e9e3abac756419ff49fe7729badb397bbb0040af94c1f02860ca6f9bbfe862c2c409232d7b615c3215b909e5b92388c93142fb6688018e519864c3046cf52b7a2921a596552adcfe5e2b554f805028c6bf4e88ba07713f1e80a06ac73dbd4415b3bb784059eb06db099256ce3358b0a8c1707883906480b8cb010f052b3b709b44a809a7392bef5bfa1b919db9358e327ba1a14e6040c63364ae545cd2b881f75f9f370feff207057a7b3b47b1fbef2302d289b4795152720015e3272464338fe158feeeeea107e09e05598089b9af36cf972f44d37bb6c7190cb700407d2cd36f74853731e1828d6c4249ff853ba0ce8f890e34cb47be1271e549104bce4a03625cdcc74027c23a631ff3f55cfd27bcfae2f3be1b279e1f4da16783559a9a81206ffb8d5a171b9b8156b178f32935c9d2e73189bf458767c38f29d63192fbceb655767e2a12d88f6ca6d2022a36fffac94b4b0f1dcf07fe6bf4eb8cace21bf69ec87210a9c33b8ea66798971f8bcfc30a56538cd9e325efb51f18036dc4e9532d1fdaa709e37d729566dc5dcf4511cb705c09acff80bc45793f20288fa6eaf54581ed3419e75c1d6aff4fdd48a837b988848683206796af2e56b6c38a6bb904f204a92317dbd263b52d46594e1b2743761cfea4c075ce4656e8a9adf348337057c4d8fe587177cf6a1761786b713b0a53791b806d37f2d2da9ecd194d2e06a38056d80fb61a8fdbc4be7859dbdb9a9e448cce35684eb701ff165267302d942414d105f780799bb22f1063c2155ce2536d0a99786c1719974448d88705eccc3404714cfd0d8a3c60a2e755ed4de8634daef8fd8b2e831002521f0cda1a8beaf25161b1a3765546f2e8322d2326403bed153e3e61bb1e818c985eb43a3211a1990d323a1d0dcd3d763b68aa3111ed8cf0db6b7f104d0c23f50e12ffd22489a5294e5dfb686c1e28824f6bfde90095418244007b9aaa887fcf2140040b95d03f27cb3f10357cf7b5b42f4208f5db73374fae863acda5dd28733dcb4d98f4e40ace9f7533e317fd4d15cf9c045f4e684be3b3407fed8b5351478618dc8dffd745361499f4fab4c97b9a0635529f253f23229f69ae618e3bec4ce2e20e15329ca9e4e0d36fc3b2b64dd5b0ae9b2b2af1a40115ae935f1b66b330d5a54ba34259c3591c75748834769690bcf4a29fb9d8a9be66ec21df040bd109f57bd754adf6a6d8dc49b3e0bbf296ef811fc00bb6ba31e8079723cc2732ff8c00de46f7103c414aad76f5158a7e143358ad3cda25117eda5883db59e5a5752af9962c0b284406d3eca699c8099c85df53d81cc1e88975aff4673db8b9dd0a60258537efa038d48cae6ffb6c1d6d13e75c240c58dd5dfa65f1651c8984345bd7e7bf3098c096c221fdcf4a9f511413a974e001c56299b52cb73b17c6a4d8d01a5e4370322ec45c8de8dd76394bb91dd60b515b511aac2d932a965cf86234326e5950f890d298126f621336ddee8dddcd156af9b95ca017332328c10d603396342af445fb2fa919a525c0242407c5abe9e54136e7cc79b2cc003e8681f8ec46534fd230449f9a6b8a76347325987af657ba5a44c15ba25f070e456461ac9064ac532c5cd1bcf45b5acf8c494bdc7fb37441f4a2b165f16312804f15ec03f4e79b6fb2b27eb9cfb20e8504f068bbdef6103da2424a8077bea75c5c355ef3793aa78b1d9641df0c8bc2647b26fb7a8bebd5007cab9d653814f0c7850b01eeab04ddb85df2b422e8f70443354b50a5d557b57f11b0fdf69e1cc55c28332949d48bd10cc688032965cff264463cd15820796c128062dcad352e00302c63fa9fc7e219ce456ea2f59a73e26dc22563ff911bc6f4eb862a0918a3f0b1ee196b66c55adc61e38e92a7b66570b8ee2c146ea8f4c2fdd05f00cab4316ad6ae7050862d1b99d5b892234f16dcef1b3dcf592dddd0ed341e9dbc687b68e901ec893fbbcaa9bcebce31ec2c6d1e68185b554ca09e5aa41d11c3617adbc5cea77fc1c2a6b1d6a231959237650cbce833f1087d6f0b4804d9e54180750797aa1cdb029a284b0d24b0f0544e14dd102df3108cb11652aa0eaabe580c31eecaa33c9cd13929a1ae5a75a2bfa94f4bb517396a9ed105fa4df8c879b8c4d95dc5a61e29ca8e959c66c7da27ae5dc164cf2814bb2901a578b52a50d5d07297e76358f7068d2807e89eb31c4319f32ca540b21fa2728e12903ea47bf91ba87df1ba6a0f45e308ad892d187f0e12146b99eb817a7d4ad49dfef03f59a8daf639c86465d049b06309be5bc77c04cf7e9c0c21362f1b014badf7172d59aab85c572229d7073befab020c409d23bcfdb6c1413c10f54e279b4d441247b1205e996e76fdda038845c585dbf8516dc12e69a00c87a29784e7217b6aa6c02245e12703939f8bb69a7fb1bc43632e52ce82033fcfea12d68c08fe8f1a88563b956b38ed0353e63bcc2b98f542533a0a25f538c3df72c8f1bef619ffe98574429896501f9c93c0ef80f6055ba650a2a9eeb1e416c7739d6d9d2ac1c3f615e33ac004d7d959db7ff82be8e874f6a2fbb2267a0f7b60d24f00739d328cfd3ced994d6ee98750d92ba612772314a8e668c5cb65dbc73160d4b1f3ccd4ca6b007cc0506baaca2a5bfc81b95881c10b6c88920d734200560138f53a3915279c70f0fede6d1d6844a471dc49b3a2a388420d208bcb16fe1510688eed0296fab461c3765eeab132889d3f5955fa81a4bcabfab086e6bd528703b7b98cc22a3becad9ce418547174adc99830c99e6145097986d4913216240ef38bc8ad00612d2cfdccca6fc7652f4d8c9c8b62d01f65128353aa6c55d49e9a8baa26c1649e946917f247cb4acffb89ae2f4ab85d8c6ecc03bffd1fbee9cc5f9aa91c4c9f131cc2091c572ceff6427a3ac21006befc6115d8f545d70accdca606b388d6658f6b85e0ea1b4433141f9a3989865195aae67ab0c24c340a8aeb8d6063b317f1f5fbf69646dcdb4ba114a87b8fc127cd51bb620709d529982ec5f7788579267ba1c54644452980f8e0409b09bcb6aff368a8960cd9c50739ca9d60d1ed1ad9347254016f3018b8187b6a31b786c5c74d8a955a4fb36c7c0251c54c4815c1edccfb824664ca8becf1ea73991c33ab8a4c612e48ceb2ffb1b9b533be2095029b40d8957360dec74e54a01277c8555261f9f76b5fdab20460c58a9aa3b0de96a0a11b5be92ee5c84cb725f9fd1c6921202b58bc2bcce2fd4015a0484879e25b6c73cc4ee46e5c74506f3c623c301db60a4409eb0ebf5ee6e459594274f80344397ff41bd9118e017f5aa8ec4f4d93a3ef21bcad6d1c125b5917d6ed54d2fadb177dbe98a5c92cbbc8c739822168bfc3ca6a8bc9d8dd585218f7220fbee89b96e8a15907e03e162ee3361a88948df23d35125efd3f521b12ab1a353c18d0979f8b328aa4048be5b1dd95fa63c86e6129722a1e50db508dc49e0497744ee13eb2862f302f9ed9295912d8e4a6cf974d499ae7452e72c6f29dd3ce590b5a111a82c7bfd31680795b53057e850d1afb896ca9c3b446cd99ba80d7a8f8432e7a6db634c1419ccfc8b2a39058c9215f7f6800e6c551a01f011fe7e6f3b06bd7e45091d424f9a03598f28e1452aad5d42a54d1e60799c65533856a1f65b2a90724d873e6e7d65461cdf1c665655ec633aeee4170de838163d2a2dc2e1b2c3f421e3b6700b71cce60c78b358fd911a3b55983504488dcd04a27fb3b29f76bad9e920adc026d4254a01700bfd556fd9d273c24da165e8ed12421358de8447b80066182eb6f6ab77385de0a90fe9dbcf48210a32d3f2ba256b7b0e2088be0d6b53e28479b8a942dff41323c73b8d3f60d99e5f8fc2f0663c3aa59c6f4eca45173f60b4ad1e45387489e08dc3b66786257fcf1a26af2af8cc5b57c505c80d181ceefe2a56b4dbe7fb996b2123b8021ea9747a0832993dd89754196608d0b2b11f4f20cfbedbd5f61f275031af8b82d3883ab3d451603877ba7e5b40b354133c1e658d7edf7cb0397abcdffd1df3cb9db8c74b2fd914864f2bef475071b09c11310ff3e8e3443c36881fc2d6847d098114b72d2c07a1583b1dc57d4bc1f534e0dd658923539012b6266b938cba06c7d38c1aa597de6ab3dd32773c87c53eb1d5bd1b2775337377cd2301e55ef49e6f938cf08fc9ee6be6bd2d765f02a7d5ee7629cf3f865df1fe9db96ab0eb707793b641d4793e6af781d22bfe7fbe9e454febf3d8aaefbd36584ace47f7e935a87e6d4eb8f7e3557dd781129bc4bbade1e9a9e331c0936252d11d2a8998f376b4f12f0a0272cb80c6716e5c949d933ff22c94e3cfcc8b5450cd8370a715d639a90aa580b721050929d7b486f74220efa17c920a321b42158be554ecce7e2d6a2ea4776d9f17c998a0eedc8243004983bbe231a652caa1f80c2c30c2d6a6e82b946cf97e8e28ce2dc98a5fa2f26bf392b1696d638c08084f9378ddd80a58ac2d87e3e0d0da2cec59854ec88236a52e1bdbd090d046ab854a6bc013db4eaed0d21009fdd8580b5d5950ff14e7b04a09add5f867f65a9184cdadc1620e1eed788834ecd2c361ea55ad23a4a1b0bc091233abcf6b8e6c031efd7b2f1bb4df5280de5ddf99b28ee6cf400ee982da513544a3fda67844e66d884b2a89f41f5314dec002e84e3405fd689d11c9ea11cb66938647fc030fd228b8cd347412a149f2868ac1d7bc0de6c35b3178dffadd3ddcaecf365a1e6fc80cee511339a2d7887c820e6b888b38aa32d5324d8a6c3095497b3f25583ea4463025ea5e01334c49839f4823468d30677e19b55ea7064d0d72e004cba7424569ea249b9a818f3540ff33b04256eac2b91f842b02fd9cf467d638471143b6196ef460a6c816b760c489820a1b370ce58a28beb1ccc9af1652351a20b5804c0f94fcdd492728e8da2800e2999e607c761962210d952725c210de00b2e75db2fc616dc4f542769bbb60ec581a6115472ec29578a4871ba0ca2217f305e5c563ef756a26975e3f27d334676f91bb9736938412ee29df76d4d2388733c1adb3f742647f2b5be2ce2060f12ab15d1fa5a54e09e6a7caf040236bf86224ecabf9e7069ca68e4a2b3c70ff4799add223a2679c869af8fa9d4e72074df8ba6cf0d0b838415b9e15bc3de653ac98874cd1f9cf2cb3c8f308780b12e5f99cdde65bd71ba45456675a171588f3a671d31e1715e4c5c481a732bf30b4c67e9690c9dd89e070f8c93e0ad0cc95a471fa64db2d9da7d19d316b09d107f4457f858bd0addf75a7ab769ae29aefcde82d2aaa77e18aebb454663b20cd35c424dd6c9b10afde6bec10b6b65ebee1d9e91d623216a58520d874d1e326f9bda9e7f7aab334acbef265ccc35570bdbd4fa7bbb512415972ffd847cf98eaa8b2fb89650cfab1aca8d8d2432133e0a8418b717eb52b4b8cd3866127566d43fd2cf1550f3fd17ce77b30a456039b15e9d484c3b587af5f7e9161918f9cf87d604cb797a3b8092fb275f5177fe03ffc6924838b5374af5a7a69e4906afc80a66ffe3fa724b219bde55f0a093b380d42824cc2206ccda04b49239a7996645c75f71c2c48d82e9f62303bd951433b6d161dc49e37fb59f075a5e94240534f0d22c16c3ba1b8428f16f78cb55b5710f334ac4725afa811d82d675f78844f2d00ea9fb6c47e485e29f10bb149aad08e29fa3bfe8f4baf33f4adadb727184685174995f0629b6d21f51b975a57ba9230d0d674bc242de30ac8c685d648a92338741bf6aa1c6b4232a3265eae0a93221676654b9df629296cd49687286cd87353dd2522494e81189bbb60a54217ef3ee117e043e1c52880e08e86f7abda1e855a61cfbeaec0a6835d636b8582831760dc3fa6eb2d940178be61f89069087f0ae34e4dc7c1b217bde9b137029c8a542891d2ffa2bb1e5aaea2bb8f7d12341a259d58398523cf1de68abaa5fbd3ed62ecb84c9d94f594c19f3ab06402600e0100ddc9ccb2085d104d091e1069982acbdd68d58b26a624de6078fb6a997c1a7ef2fbab9faa8575fecdbc66e14f43dba5ae4367175f9fb33be13a53fe13d916ebb1fd85e1600daac290b2f62daacf8eb5576692aebd8a1179497e9e7a19abba1a0356bc72a15e6750819e550e3adf7308dabc99ed24b2d2b5cdc574c177b3a434481dcfa6c344b67bb2ff4f9fc66e9453dbd79102690bcb7c753a34574fd0cf31923cb719e2b423019d859521ed44efd8972f80a1d6f1d4f54a583c756b3e6dbadc2d8bfd93630fbaeb6be9250bdce4327c21db539b0b82e7adbcf6734946162abac3a6bc7d79adec5cf1e806ca8e6ffb01c117d017c1bdd5721472f83698e894501c16a14c15b14441462033370938960b39322b0c522041279642e9d4afbe62505d2fdc069822b67dd41c40bb274aa6111820beb2501e9ef41fa626f9b04d9619b2bdd9271d56b40b9fbf190abad2f1b9f1f11af5df73c989ca90365221773e96184768bde3094b7f4bd4942d5489fd36b60e234aa0d6e0a4fc00e39bfd754aeb1c719738ef8d54c7b8c5f207fc5f18efb9a897460010980ab527e52d8715b0e36a935b19d43db6715c0519a23c076af0a49283131827ba30bd3da72d27397e40ce830e3f8bd5b2e5c9d9770b312d34cc231067979baec848b4a62170d4fcac4f1959d98cf7a38fa750f6710fffdf6b201c495aedbafb013f1babe19e7cd8cf1410472f1538cbc5360fdbc4fd707834e2893f03d4b1f1774a6dbbc071b86c244d2ebb7006f9dea249e6f90b1a745a539e9d7d8911d1b0decfd222ae3f9b6d31dfef865535932182169983e932b4959fbde253df24aa11549a0d40879fdd9f986df2c678c32eae50426f7e986ae7eb9eba7e3aa1058b9d6ff0150e8ea494c7f1cc7a7a8fc7b6c62a7f0bf83b8385840aca95f14e81a8d010fbe5e3f326b259368c5c5d966ba897af39370377be3a4b02b5c1285db9e894f6828b7eeeb4b61d34f34786929c36817a7517647926ffa430bb6f6ca01bcf2556be7316865c735db561357177c86b238af8c8250525ca9fd6553e5171e74934d636adb3f1481e0f4199d3fe16d4e31d5b7bd55ef873ebb37378ea4c05e233b350215df090824e19185c66172be2feb77a0ae404216b744bc66c8b24b463434a892797ca48f01d97cc6fc299f583af31ad1e01cddc32ad05d3032583a11cbca596382b1be3e79f6563f83bdbecd1a6d9926f5928531322b5bdf4e49a9bad4c181fe4e8deafffd5e3b9202351d7d5749fcd39a6da89abc54e961a636bedeb2c69cb4370d186e565e9d200e195a95949647ba652096d81d7570d338f22e04d6f373b0b00005b175f832814265f9a594cc1563f44c238ecf321c9e489ebc49af44fd28d69046909aa1ff4ee2b8290ffd906cb0cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
