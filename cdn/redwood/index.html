<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"979337d14918784814e6f6c55c5faa1cb00adf8773e0c9d0bc429165e7e86b56b951e8a24b48aae3930397eed21f4346f8092546b286a4b80065dc13f42f10afd33d9d676e9f467087406c5b4014061d63e57659f62b867903cd61c4f71d025a2d6f4a0988c4bd1933d5a70e499dc73f04c820ec49df7bb50922c6e72bf6726b20f228079a1001cfc8d965a780727c3320ea41da5e03e481f3fe2c7152775991c920ef223aa61c47553946c9f02b0a84185f1388ff41506564455b270fa21c4b18eb9a99fda55b3c2c83e9e8a60699e7159e139edaeee2a55d2660c637dcc7a80042ee4b1b72b8696c8cd0d1dcea44e5c6d7f2952a38cc47706f57093b673f99f1e051767f37ddae72d81b20da32819e73fec82e437fa05f8cc3c5dcd960b65ffca9521b7d347e044c253486dc0338aee09a34dc93bc72e549fd0d4515a9066bc515f25545cd1ee0a302fc5eaea0faa5c33e8332df1cfe3b74dde58d1419bf55a94b62aaa11aea0281fb794c52599d91b471821c5e35b3758279bc24b53b9213426b64cbf15b8cc389f701bd9c94ce18ceb3930642238b21ea388e2b706a7521109caa3224a1cde6b3dffb3ad2609517690755bb414353cb02b9a5b852913c99f6d1d18ae0c8d9f0e17fca259c37e93620b6a9a1419b645483301e2e305dbce6eae6bbc0b3d7e175cbc4aa0b5e1d511aa006b0f7d25c1be190b4a8646b39c3140e18364ea69f54bb8f4a23a54b05af113adf86ffbd625be6d1024839dfd3fc64d223dbfcbf969db4ed797490743145a34ff81f5c62cdaa52ff67aee73cd0fd0dc859bf9c4dc875bd84a4b87328382c3cac1522fd119ad8c574e20ff34c291df2cf794eb149acabb39e77eefd6380ec0be30d20e460c2aa83f22d613962c5ada9f61f7ac234081309fb58c4f6ef62d724a9053e40445e4708d6468fa07098b60216dc2837443d4954818d8d79b49b075ee094813458366292e46f8870f35f1350f76292a814a7bb9d56452ca046a740f39cb98a248e54a266e6273a16ff95160f3f49884c7ab2e032eb348c3ed75d018f0210a7819a92cdb3b999fdb910abc751dc226ee22a15a906f9b7258cf0c7d1fa767a34c2e77907eccdf62e2c724d4638d2a5b11a183e1fedeb4af382cc84d099c42f9c3cc12b1976069ff9d512b3659a06a80f20579c6454524abf953b1df0c930d44147be89a78996014a33902e0aeb1facff380c75fb401f8ffb6ab4181203fb75e55a2bb404b7a9c12e45c3dc3387f8f39a8368e5444be68c0a3678b38fd30ae01c062ec6bc7b18c28b3bb4fdbddceec56788b7f34cb00bb30273ae87961e0ac6844a06bd9ba8841052d10e52974491f256bd403d90bf302f564c539bba54e61b514c6f2b9bc15018076115ca18ee5653f1a708c05f7806fa00bd95e56c75f60eb6d10bf9a9af15e8d89e10d920fbe259a73f0a42ba65ed9f608bca7ba8c94d1bc30d586affad7cc37271aa3b60b0280145131e59598c7b8e5f0396fe310ad5e379ca9b975171bcf06f5e3cde82c8324cbde2559252e1d59e0fa865f730dfb6f08427ef1425bbe804d63af17e54819b0bca79dff9832d8e52947e9ef7f1a8bd82f1133edccdc29f9a39041345e306cbad6e7fc8627a944b5e79f2d36cdbdfc7ce416e3dcb431838d691a4a9f8ae280e4d528ced6a9c0898f1349a1d2a3b9411b6a70163671e53989710caa54e05e29aaa34d9924ab616e0f8328cc8ea6d01703c76316fd6301960e56b1970b09885ceb49af27e9c445fa1759dcff6ecd60f81b9902a62b28ffdedaf65e962c246663aa2ece679d8b2cf9e4ff04d850163080436dc8c1e0be07ceed6b2420d72418cdeb07651244624dedf84f3ba52b5f60c5634805c3ab652283bb40d450f23e75194ed9e0a3026b59c102e8821b26a077ac18d9e58471f527d7129d61fb27cb6264f7f81fb6cd0e5b171af9aed45a89fef8d203cf0cc6b63aafd9142e59da10d83bc03f4398e791caccefb345d7640fe9225a3942e5c03799e96f45b5f5ac5f93fb9e9a9177b3a4c67f122974867666adbeb992a6c09ae20bdc37b7d928b5686776bc5824b94a3c464352054e6ec9bc9382faeb84236a5a81ea2f997febf4151d2c2192f5b80708d0e0282d91d58bc3afdfb65dfffad11a9a44ebc2bf26101d762f9818d9e919a8923e029669a208ea9754fdd9333c5b0e70f4d43b13a42c1d12456576fc86bd25c7579b513b678998f8fe21d8b0ba5c90dd509d01ddff7b15af1897ed19fb592c031920c094ab2671f0df5f86370b530eabb18db270a22cadda1fb0f21d58108b2d154fa97a1a0b6b0fff03c700a34064edf7ccc6644ef9de4837701ebe7c7b3ce55159867578f9907b9c161ba9efb36fa42d925652114f3512e9a0a41f5afdd1d702c240fe800c384f4fbd49068d1e9daa01ccce9c9cf0b87048e4660e30c7ca18f55456fd60b1cdde81269e2aa72a1a4803cef65c60db840a707b77904598821be878aef8bfa1450685ce34d2dec49b0e3a915625b0cecdf8ce75809fcbf3c333d4272b6a90b5ad5f928c58526da29c10fba3b6b030c370b1643dee5af1e7d55d0d118c393465b3942968db3a6ec0237a6fec8af3269f0d46b7c25c0e3378519f2508e58d7bcdaf1285688b8c349fd185382f0a5b5504ac636001d6915327cb637c8510a650bce659e6a02fc5c0bfd0fa08a940a834de76b3ddcbce193b7a3ccf546aac41d8aa1fc22362dbbf451439720675109307a54725590366c587419025581a008534aafde4a5b282c58c9642479819ffad58fb318434cf0f26f9276daa38b5f58965b54cf5dc1a294c4a02da068a16baac7ec431a6d7b76c9fea10d67f17b8684c99fad45bbb4ab4fb9280cc4af96f93d290f1e45d7c355fe17fe5526b0dd245987ecc12b48c4ba0e1b66f62e711282cdd512f91faa1abe2badcbe8e67562ad50738a4d8de0534cfc46bb17a819fa167c9c23dba8f8d4c33b0349db8e06c9dad6fd7b6bbd1bf35953926026866f957d5cedde391f9b12374ef601b23600b01602440c12868d53ed45a5de1927a8aa807053cf86811b59d7b7667f876a87e7d26fa071733c5438b1d1b6ff1fc8ed219c8cc77d8638145a16f2a4e9f87bf29b629d54a7658f81f722e0b2d14b3a113ad64c6807569fdb213872eedffc28adea07a1df52953b0f6d6a41f7dac4193749a2eed47331043abb921f5c674849373ce416ee94029753d75e8b910194c5abb19c25959a4f78660934f1cd62a64ad2132d99de8c3b033e86def32887f38a349a4511f8e56d46ebb401ae499303fa7c96300708c1825d540535e27d5abc6b18680b6fe02fd31f9b360dec5072fa906056e776e1e935d90d8e94151290ef2ff9a4e47fd31aa9d17b6039ac9be07dd89540c7c5938d5212fb85a6c36294c1cdf82042b38c0bff3b8857aff543c1a2fa408deeea0cbcc35b9b8171aea81097405cee23a49560e29d9cd0b0231df7e550962a5e7b4203f02f5648998ef9ddd6e3075fa2b8495bb0bddc4fbfbe34938a45d5fbad02d44a0584567a2f2a6616480398e448637c7a519c4d11e60655852b203d9313ebc710ce46db385332d4c317def2c03fea9c7f03a181230c0158681099cfbc2eea482d33785012224310cd5612da8b7ce4b0e2cde9dcf62d0694d53125ca4d300c8053e5a9156e84083ea45206ce50d5538688b8b8e60d13565d75988d0b76f4d722eb368ba11c84a9fadecc15bc2d28dfcb226cc99f50deb73b278e3b765013c688e1557abe9ad7816227d0f92bf67bd91aa9c7468e5d69890b4a3a72db1fe8052f89dadd4a2ead4f49c3af16f6180aa23055cb99a5e3007a7b91e855f0ac931372a35800d67eb01ece871edf417b99ad772e5a4af1de4949d2f829c5497758d51fdd28f54e734402ead860650842fcc00979935ac51983d05895a76923d3f71af972f7116f1c344cb62c01b3efd06a85af72007eb4827ad40d8d65838aadd72681814d7278e5e0a5c6678e6835f9bd8a24b5ab598c6aedfaf8b778de909c67e275824d15c14ab6840e09b8e7c568bb88c977443ac52f8bf9d2161509d81fb197b3112f43b759a2f601e229140aea65e44c5ed42553e7dd3eec870a0a20bbb6e13499f6abe579f93813c0d64e9f2b0077069430c029c6b68f78ee794f676846cbe449343c12a3d92beb3775f6bd4fdd193b7c6d78d68f98716aef1faf3faf8e5308327e223576d2e6df50021e35a8977313611f4d0176d29aa40b1a4fb88dae72014039c4e59527a83a25eb10bfcff512e691986be449a859b98b73ebf9773cc7204604804628cf80fa00c644f45096773180bae433bb6089d350dd7ae6f9ae5961684e5ddd44f684cbaa0e2985103a0d0595e5331ee034951d7ce8a8aa767ef3168730f6d183daad92c91c0fe9516759a9690940610190369d3b8ae72dbbca93d2f80cddb11d7a78c5b3fab6aad60ef3d745f529e3fc457b153593eaf7da84d42ae347acc072b23351a34569f8414fa0869a24958e46f8f8545dc940210cae178d4123841abb33772b9f492055d42483fafedacc424d59832f05bd038175f7314af79a953f2a4b291920a8bc0189eb096921306b52131dc59fdee0cff9f4ad24636f2ee0f6dd07b15de00737e4b95555d3bc1200fb32cb44b916c4a78a739d6e7f5c5a5afa7f6473484b3bbab19a9513c479208ce613384b8c71f017ca749bb80027be94636c9f71cf73e23d45269bf0d0826c3cbc64f884c1af087add2c06af619a28ccba2ba2869851c5b6fa22070462a28ed41525ee30d14c4973f15c98496580f24e34d9311cffbfc9778359c6350ba603365a2a98fbcd3d8290fc8a381cd1945cc334896de34a890e0364cdfbc925c813aacbdb25d47273c66b6134fd1191d17d046e46551e073d18f5efd58e8bb6df0ebf5d942acf675a740786bb4f9f2592dcc71f2cafe2441b05922bdbc68281d7293af0d0df5a9d722c130d32dfd0cf14ea9daab2904bdc1c6e5a9c210a4f917e46ba2c2692ecce663090ae125c10a63c050dfc68177ed4217ea3a43684c11a0b09ac62437a474f7c2c4860761bb6531ed215c7a4c18e9ea19051bce4918c3099ec629bc83540259f4f0816397305218910ca397a7a07d21de4c188526937c7bbfdd226f82421982918fbe2fd1579383c313797f05dab1e2894ff110a68677aa0b7a6c1202b16e6c2e483f029c5dc60704c6b8681b1af52f345378ab7238b4a2c70f2c8ed050ba63f173cd18e2a858a7dea1bd009a927747a40d67c1948ea4f66679d31395a730ab7587cc10a88c9ebddfefc24c8dcf7c769ec98ca7f5bd04eb72bb630d630271c9739ad8a652073a81db6fc3cd8f780c6dfb7c0be1333b38e13d0012cb9e1d5b2528e65e9364dc171f9cfeb812ae6e919e49c14f33e1bbfcffb26930e19e0e3aee64cba1aead4262997c09995b680b5d9dae11c929064d09bb4bb50a8ddf3686fb114e9d169dc42a68ab766f149c62d57ae132e51194bbaad53df2dd39033cff91b7d201335db94e26d4296db0cbfbc02561e4ba24c7baa97463a4dad5bfa49692a70de94fa946cac3180af7172414745153f402efa6011f9a382fa141a4fba07f611ef11a23dad78f5cf621dd879c6d9274840de7d53a81b1d5995ac033e8b29bb74173c31cd91e2d9673df800ef5099091004dcbc9b99d3564ecda1cbfe2ae9032891dcf06862636e0da25965f097b04e616f23be5d7104b763939450a8dfb1be7fcc979e7844c70526dc5dfebecd1ba1f4d50c498c4156c6132b61d1faf02fb0b513298daa3739f18e3a1be332cab6631524e92b07d99f81e2dda6de60b0818aabd3456403669e80f1b05ea29e2ef451ef0685eb871b4c8ac814295320ef0393510f4d2783302891d6810e467c07d49c61b2dc742c4682beaeaa3d2adca9333a752baf915121170c345cb968fe8f0fb614fffbb6053262aef3fe27b178b40ba4cad3a043669a5bdec65aa7e2985e015ef3938aafde40c2848c87f7d4d7d1952f51f5994d01cece9a9ffe66c4f297601339c0a1b5cd53769d0bc2a2fc5b8f78f0157050ec9a5e7699fa1286186595c2afc890baf579a99a813ac060b0ce831b9d4dfa660f0dc0a4d119bc115d40916037b562ead674b18acdcd176ad621ebb805593b72a785b17fd433f5b4c8d856a1ac5d0698e720a8a83831e7021bc7f0025a77c8344fc85347564ba005b582d870ff7cdaeb46b56492b673c7aa294fcf0bea343400aed38beab86d8b606585d15f412995eb947db026c7baed054dd6422ce5b3383568ab41f152ee0db080c442d9f0557666cec3b4238e97405f89132fda15cd8761631c2aba3be05bf1f89a735381b7fd7c05f0b71b7c441e5772c69e37ef0a1d9dc32955cec71acae06d4999e82c13478b02d4ee7e7b42c2372592c9f53356efc8fab04dc753d0230a29b3c85ecd8842ac12277c134a31fa907bf5a15b1fd42b99c6efc531bc7424665fe7a4dd9e5caf7dd204e5736d5aef0cdd49f24d8d9322c1f5438317b2df9043cc0f32c5523c1807d7fadf9869a264267e1491e97983a77c77fc145d0a39e1810af8467ac2fd8f8dcd0a33fa8538f2a70986f384450a915670a123f606b704ec0f328ca7cfc80ed0c186ddab37b9fa5237ce5d68809af3dd8ed5eddd80b51fd44245dc117353e10790154701f7536efe2e08cc75e6a36fc406f4e6e9ed8856f2b9c7136b72d79568af486cca8896267a65b02de210a45b8b3a3a0313dc832a8847b0f277bfe95d1993a50f86cfd45ae1db250b13f2dc740d5f02ef2571fbc75417b88f70a9062d06a5bf4bc16ecd9fe3794ef98c4fa27c6b28dd01f5a58cdc406f7d9679fa1f3a0baa9d2d178c007fbe8b38665412cf1bf9b841631eba6205458b84993f655940a3a9f75250d607cbd8f33a37c420eeedd142e2a2fe8ff14b56a9c3ef4156b81fa9e6db134a4c65da0f50a0dc0338e387c295978758323ff8a5af80282ea25b32acebf7cdd23293a24048fe92e567c7417c335bdeb3ee85d7918c3df03fbb89ed97ac67a816b711bfd15252ac56b3ee1fe8311d1d31240abb02df02f14d54f44d734417f4f0e29c91b65cfb61b960a842510732e0c45ae5c97f42c12521c217796bc33d9d8d89681d6fda1025a6e47c846054982239d6684cf8cb491820dcdfde20c066d14a5de81ed835318b87ca6b3957cfecf3dc539d0087c1c327b1fd9b091b2acb0e6377fbef57ae32bb53ab4b80d56c1d9f406284f861df0a7533ba2d7c58b3dde990c7e97e198920c714ab5abe5f4cc8fc7fee7595a2401fe759c44fcdbd4d05d0063a13483116846faa1aba86924ee8db332bb324f279931e07b11bc2957692db4aefe399891b3b4257ce475d527c4bdb1b4942c35d9d29645eb4cf0a860c79a8e8a45c9e88962a1517e86be1f7f08274610c603ebd69e20e589cb51588d067b552561d99f814f052e63e315dfd96e7f86ada6122047ca97b95657df8e3e81a3afeada11be3b782caf71eafa1cc43ddfe53a032e3cee6f68173f65ba6090d6c4ff75b909f459ad6d4ed0f25267ce0ba9fc29baf0f694f51276affa98a14b49fd65ac48320af433023626e4b7b6ea1382c4784bfbeef83b1da61ac735e70cf4f1254a059db8d231925b013d1b58312a656786d1d7106079e57ba4902c23d55b9c00993a02e0d6494f16b76b4a983a459c0e8e18a0ddecf6b65512d29d3b05de0a75c16a7e1ef80ed7c8b6b83e1f652e6c0c5ab86eb056733ad81513531ef87b2fd302fe48cf43ded1c1cf248638f0ffde7bf2933bbc92d008568a140f62cbd30bda26cd1ef7d23f4130093d90dfb533600fbd3cbfa97c5d57ade5f7da1615d0e320bf1e1cfb5b8f3f50264fcf730141ea0aaa9ac5213787eca0e246f476c4640222f8980951547a81634737033e9c4ba216bbe14fb7fbaa836623b04a6fd7cca958c3fbd2fbeba016cb7b0ba09625136c9a0df85e04f19daad4765a98140b65ab021a5d43715ef96f59e546458054f7cee1fda585427b8d03987f8870573c119e5a16b570216401a6b13dbf284a16804ab478a67755bdcd3b83baf445b9a8c7369f292ef34dd7c6a99f89548e020f9267ff1f98cc7fdddfa8420eead56b1e5b24eb4fce4476a731fa12941de7ca1c9b974fcf56b9607d58d666ca2458959bea43ead9922a39e7087f624edde798a3dd48088aeffafa7cf624fc1a0841e36f89d57b48627fbf2a5a8741a57398ef38226324e01f10bc78c513c9d1a87072d9c6c6e5c7207a672e9190c5be001ab3431ec51721536306a7c6b5bf24b1945f60aa90da429e545befc291aae1bc15b3f7e99a4caf5f8fd56a773173fe215c9006fa7b5bf98c3276d8f859bc763bbfe72f435bf6fb0e77e4afa658985a99a8c5a8bacbe7cb94f8b7c6280baac87c76dc2845582991bf82ecd3bfa2467625d5f51a2928eceedd12e360169963958830e2e242aa7c56f2d2b49d0ab949711cd4e4af36d8ed7545b66e44916dae80524f207694adc8b841750b7e64d71029b5a81e58a7532fd357ac75cff3de9462d5d88631445da71c0a43edde5cfb1e4d05972e4640fa2fe4301b84ed4a19730fff9a12c33b0b6c4fe4e71aea621db0b580f498644faa44320a410d819e2837462651e2599f6c0dbed1606f8732edabbd94bedf2de13890642fe18dceb7260055b90e88893623d0f867bbaf0a33ff794f7731d3369e91b631632f874d57980be07a0d7da32fdc600dc8e235b4ba5c9808753f5838e26e2b858727967f33ffd6c5055ecfb38569f0d1a62fad0d2b8d12e4b161e6080f13ca4ea139a424c021ef9e348dfaf641c4bae5672a8d1004bac154b242bb0175e194fd78b7133d20f3a1b0e9d76f6c59572b54efa1e0f928fda1d227b4c67c618b7743ec5fc83c35a9f7ee565946ceea3065e800f0c73c783b7c0c8b4a16c163a935e188645ffdfbac1525a1ce135501b4d7da8bb81c20950a9b1b70dc64fb2fd02e7eba7c4933c144bf5190f4dcbe9607814d3aca8c42032e66907b677c2bca6c420377feda494e1894471c7fb32bf74c02f308709d4991259d05870c485b94fa1d20e18cf5777f1b7b4ce3ca336f632babfed94e7cbd00d8ec997041ddee4081de74c17b63c80186ae204445bec51482eef1c27dec74c873a9427965ec545ae83f1125df4f9bcc2fe562c8d66abcb008eb5b5de89ffe0cd0adb3a27da9bdad4f2303926172edb337d39cbc8bccba58bf9cc555ba8b446ca7f7fa79e99282343d61e0dd16581f9f81e65560708ab89a4d1d3c0de28309a64b2f6fe0fc0f8164039aab4a8907b5cae97e6c3bd3be42e435a1ba8b4a3a8ce4b3585a01c784248192e0fcb47d7c1c3be4cfa20c308bfb8400f4122ccaa45d9b32b9e8bfd179749c34db9752bc28d5c19767fda00b523b781d2bbf9abc6354b0c884251e3ccb7625cc574d7aaf0ec245149029fb3f87634d649bba2f0a1547acc22b287457fb835e419254edcd50559dc56abe558118ef441276f8f45c7c19b7278759f4978d7145c1ed2a8f27c4605748b450da341f2012dbc1210ca97ef65facbec421af9c11f74ff90ffddb5e135b95d7eb278e987ee6a1cc46aa2f6c08b3f14605a6b48567b6df6ad3c320dc2c9c44bd4347de6c3659cb051ef9993d8551f6cabe1e63b3d96c0fe5e984764382984f4af66c6fad4be72f079a6fe2d316603fcbaca0d0c2aac99d7f89f025fb1ecbc21085fc42012115f4256c11292ce77b2b33467a0b15dd5bd74047ea2246217041ca4cf4d0251309f737c088b431ef994eaa3cc92402b90884875258cf9ce93f85d2cfad64b87bc63905fdd5675b8356645004ced40325ab5a60f9b50050d7c26b787617515ca07b8be9dc3e0fdb1be15f62cbc6339f2e5916cfd6b61b609ef7f2ff4532e6fbb241fa3ed8d851f39d561468718883329037be1839e9739de0c677271b1ee100b0b235163fe4a2f2918b0c11b9f6cf15d52c3a57885e47b261bc3868bf96e9b69f66273d0f30f57ccbf120de5e8b3ace443ade022b4831abf56d83c9858b1054c3d8b682f51209a42006fa8d372ddc512217128e8fa0a71cff61dfa0bda47c9cf62a87b18b6755d25e74e3f52ff468ad7a5a3cc4c7a44b8eb712aa07d9fb6191a8ca5aa5388b877e3f47c650090759d5453fbd2864ff67944d9e2c305f4915863d78324f8ca9299f0329382f0ec162a7a5f4e6853acb05f12652dd85534b838776054c60ddebe7f7b728662be7269b18179b36eb900eb4c7dd09ee4d0bee4bf33a35a8f61933113967f5d6629f342481172844ea77f10fd2e9bb3fcb9c7e137ed3c0b783edc040e63eedf3b2b5b65d489d6ec1cb93291f5cb76b9b382b9c139565afa0faddb2e79cb1b8496fe3d06e68c319227b9b9b59adbafb7d889c9e39c322ded087b1eecb79f6d954539553a5ae4e7594a24cf83f371b1bbdf93d337476c0c420d7c1e5a74eb4cb1f56a4b78300c82ca1a5ffd2c5bc49848d3ae32deca36735f34dc9a687d68efaa896d81d377a0b7a114a50fd96eff17dfefc9d99dee0c8bbc345bb808a0541ad3c486d51d2efe1efdc38b1bf8798ab9dad27fd6e201c4a63735956ec7abcd352ad8ad193077e23e40f48fcede2fbf20e41d09a4da76e30519a443d526d7dca74ca82a4b91a33f627dbfadb4610176dbe68e06aa355f483cab4d7944991ede5c00cd1f7962e97f4598cb295e051729d4245373dc54f146f4996e213d0348fc282cc4495359a9f6c098ed7d2c906ce0ef6a795f8105708349b24df1a964497172c5b30a747587acbdc222dff89c0f456bd11da82693c1c2a1cb02030a230fb09b045550bd0c5270ab638b559f0271910b6e8442cffddbc328a8cd60533f588cfbc99e97165bfe2090a6c7a917fbd6a761e0c5a07f115440fc08eaedff0b644280a8324c6d3d3bc58eb1b326131e70cfeab79b7195204cf5bf0ecac4aebd923b0022d8630f4309fd03ac1af201be3551b891f05e89a97e0f49deb85e8857b09a6aa020e1c5504c35b0d9bffacbf5555ecc85a728f05a77fefa80d03bdd866af382e669e1c3bf0049e31ab1ff61486ee1c86fd5fa9c4336ad305e8bba8c619cde27b38966544cb808e4b2fca4a146cb02aaf0020a6ec2053f053c7de6f89c1c0e0dd1f42a6bb09de2eb017131a471d9ca6c6082014cde836a3d67de77869c5fbfca9aa214cdb3586462c6e0d3ae0de0e7e4ab8e7e11d6c1b7c0098e20a0c187c82c522a542984f3342e82514452f8c4abe37359f4c2569b987a871081710fefaf791747fabb20aa037c6c0e1226fa547180ff2bac4504b61a14ee1dbcc6637bb5e2665298b94b21a09df1a352ee1153004f70e4063bce8a2a3b65b6be3c899db00ef7950ed10c4260e5341880a7b74173986abb423a2ecf5cd6364836ebe175ff946db482d454d3cfd4743de0c7097bf23388a092c247267841ef19303810baf83b05f899e733631c33368bfbe3310e08fbd982899c91d8d15bdb3491337e3ef63a01559b53d372f0c56f903edba26450c730d20f27c3f0f24b86883032b401d98a8340988b19a6d83bd27295e5bb2893d80c51a61e7340d9564aad452f63882980de3943b58a5d913f31d386b3046aae0c9b337b672d925b7f25fea409644135e343000e1c6085d7f32068b7a3762229583cb796dd459464579c0a3a0d867a319256a13966e42e15c96969a0877fae53f81d7c3f94c5b8fc07afc8c23c83762efc717d9f15567c061f5a3588867ff28637589effb7dbcbebc96e1a6bca4b66af59321620c1fdd51ecb35f3353488e3e4e00206a1f6098586d3b9ba2f50de8a2cb39350efe86639c6b1a5e167cccfdd9b4a83400e1bb9eef2237b0ad62346fb246a837d2d5049cf0baeab6db5e7f539883450b813de11c000794046ef216c1cd46048020885bec401c65f7dd10fb6d9c86b694e7871391346f734158aa3a31c8bdce81a1f8793c0e1641d7a7f8f05c80061daab9c13bb024a2953e16fbd70fb46752b97c11e850df0f771997da899104a71762f7ef1a438a9561d3949757a83d66e9794c8363d678e6fb649d1044d8b79b7cb148392eab48330e2f5486fca9196a2db12495265e2385c1288a231ebde4a56b92c469810fff34fb7e910975a648b4cd6ab765fb607dcc71f678be0cecad75a303ef9697810017f4f8475b4ce5776b0b8b854665c9c5c0aad46cccb725f7190bed22b3fa8b3a58c859fd8bd42e0a565ae202dd4c261b8c8995d1b5068e74e8c6c8a9c2ed8e7b30f52276f1426d86a186ac45233333fccd4f789d8e5900f2862b21cc346087baa5ab15336addfd8e160c8f2f37f326d53f3174cdd3a3470d97db915546d31ea81168476c1000a2de5ea21e9171e6afbd67cdc5041e99b3852502201c18a6adb1d9dfb6a661fad132588230fe36aee09f2270cde6b9ee946e9ac07ff61a7357af3a4ca719b47fc93220e17fa586c2fc805de2892731f1dcf5ae8297c0c2442326b0a251f2be03675df58b90657a163ae9d53a2fa55ba2e8b61b187fef267d9e7d0c043d54f7edc3fe2e630b9a209d5daae56d4efb43e6b4b0adaaf7c88df320e6fa2fcca789f8bebb48b6b0c2fa744152dec3d55291f2c84eb134567040fd0374d25a1da8c77b83968a7550024003b1fd62b0a68896a3b34e5fcb35b260396bdc27acc0f06efc20d7b9a2a7a71a4128abb1c968a99a5787b50c5251646f270e322cfbd74e7ed9b2a5443876369b606000231198ae819f641b6cdb02d77a728a565e5d0b178a8d7ca46e10e3fc55190e57e9b2240af507a355d5ae152e4da21371ba8a6a1131acd4e3c20ec28179b40d4ba987fcf80977cb87e8c7d51b3c61ccf859d1296a5f25bb5642a20581fe5158dacd8d529dc8871c3da0ce745d4a148b40876d38f054373cd4302d80ca87c60138c1b0bbb0cf30472802037001c42f0171955bc6045730bdfbfb30c19ab8740685dc1b9cf562a3d9ba94a0b05d1a4d4b3fe4570ccc9550a1867fb25f1f5cae0692cff467647b550fd83a888021a7747b6863f4bbe4c6fbe063e4a76a6c12559a177e00f448addf20ffe8caa173b078a5ce8cdf0045ad895e0a3ff3fa279e4a2aa12f563cae03267782b164334b9dced583253f34d4c9e110daf059dc226125dfd11d8f6b2d187f17472a1b1381c3e992668bdc6444b9c1d93febd57dc11e958645f0adc1a3152d22e19e25ef094e610b72bf00809bc9d6756f18b2459303092fc70fc103bbef360ce45d6e25aa2b2e6313453708f2dd8d4c06c6a6ccff17b2f92eae6976549841feb2dd0bcdd2d9637ceb318835846bc4cf84f5aefa334751ca061feb4143803c06c4254bed76120d7ed0b9632f63d888d2d45fa62a307c83a19034a01b036cc9288e66bb35bf9959a02c3674c7a1322f56bc2ef965751d901d1bd837e4d77a1ce45f9cdb2ef4457299ed92511f92015a49bc8ba46261c625fdc88485d3f1667583a5496b282634935c66744c9a3f24e0c7f53d969db50b12a9b6db525b9db6343308100897f5b4e4b1caa3f0c546e6c1eb9154b10d1f6c6f7dbdf956a4a85c7fd4450e93a566bf4848e4755190fb9d82ad40a199558e0b3bd9be8644876af1b52b21ba7ce90459d7b27fd142fea132955b262ef7719ecd151d381377b4c6fdeff04e4b44fd9fe995338bc1ed32ab808f143f94773854e770b174a93c70a745556f52a226e3398847eda53e8b86fcda973889302eb4b3ca4ef4089f84c45c85ae0b797b1e0b9d98cecaa549be3a13ecd44043e5fffbe2b2708dae375a3a1f318035df2f3158e84a777b38c50ba8a171a92e900ab653b58232f3f8946be7a8969a8a79d9142ab82551a15f48a8e989ab400398af5d1e05bae08e84b1f133c6f73947493d67b57225f87d3db71bde18bac5cf311fc8176a367cce52f54b2be88721399972bcdc7208a21286740008c1464c9e9d359ddccdd435347d53692148d6b5aa606a01a36616d806e267a1201044cbb4692cbab9acfc57179eed5f54e17bcb9a74665a117ecfc6c8841e51cc13dca3a38002485419370f2c0ca462728a0b5cb778a608e89522506eacb227fcf2f08d74f52e38fb5e7badc7cf0e495676fbd5f06a5e8e725c467a1b41b0ed1f7d40daea2956b9a89006400462570c391e272d1c742bd04ebb8dcc05507606ed43d05a7d2ecd49f0e409d232fa4dbcaf268877366f38101029402a8f82674c3dc6196b8224c54cea333feee324e2a010c7cfb5ec952ef1991f3d6f69b0e6aaf09f00f1ad36f6464f9420050aae958c124012307edc0c7290f0feeb56a113e8f09b5808f49f29c0e4ca59928951017bead3ace15f9c0a1ca0dd908b99b6f65ca92ade59502a4fc7e10b4f003f22f81591522435dce36566740bd521dcc853feb92880f7358cc0db3f402e1b619503a54d2e662deb954ce28d704a0a041ede4a3f4f6da43a26481a64e670d2aae0905dc062f322055ab19950300c9562de3e9b229facc2c4f347e452e560932941d491929b0dd93e5eafa7086f1309c32c1670bb9af6b37362c14b2cae3aedcc12c5175b57ec5784de4d3b721b6e3fefbe1e77bcde47760ec497f783ce5ff33f943b4b8abd26caba2e25d4f1add06e974b973fb001f82e65f766e086749407857c58568fe452de3c9ca14e246535eea223b7e773d8f65c001bc15c707468d0a696386645cbe0dbd56d9381bfd206ee70955234dedecc57877d776fe50f50fbfac1ba3c4d600370211d630cf31b3053e9062e08fe3867990fb891ed6fd24ed9255e4d2396c1a4bba146d2435c6fbd14233dac90c9521869f324f062892d736a1aaed4c9991e9ba48a5985d6d5c8d4b089df9f32d8b32b14892bd2c56e80cc5f8780423907b6f022af17f02c8a490436617ecc0cd8a981eedd8a312f8747c165806dfee142006e8e8a644bb30136ce80fcbb84cafaef65060cec9d95f8c3e1002920c5061d01454ab237868b5e9ec14c5e96792173719ab12f0287d298e41e7afd0ff8f717981b3811da73ec2cd3d6da13526f4b41ec5e77bd2abb51b20172829e32fad8715a8e4792693add6c6886fd3e235eab537660bbb13efa4345662830c66991f01a83830c288d18b9419d824898c460fed397eba3632400fc2414fe345d8104c55d87b49e82018d292100f570bb622309c75b4dd5ab9a3b62347a6c86803b7bf2379a4bcce56825d9df2a39a147e8899dcbdf56c563716459492205b846179b635d3523426c3311808cc734eee97ae8d6a4d3a1bc5c510015f7f789eedfb2d8a11083517ca01bc028296000a2d7b722ec82b28b9b869d1ac7eb514544b74af2dc9113ac106464af40d6eed3dc75b4808cc73564969be6e5ea20d2619bd7cd2ee1a258cf1dd75a45857e19a47f6eae800e63565381c5f14954e302992980710150f9a053d76ee82fd9be387b6c8049f94378e4dfe64f0e9d281df53779f8df3e38a7ae40e57d4bdf130052d3badb5f93d463cce0745d311e9043e89963f4aef33938bcc00568be473bd219bc6cce0b2856d63dd5b047884b69c0f12fd05f029922f1e5d68631f0da9371287dc897538aadd669a13a7bb5a8bc677fa535badbcbe53c7dcddc4ae46039b474f13c73cdd8b2052c59798a3207370a4e1beb02ca6f751592d207eaa32dd0b8dde52dae64c2399b335b9242e2222e9c608e1114fc467865c42064b252dfadfeeb80c526eccf946ce8cb8daa113a01ff7a013d91701d3b0bed881474958b40f15cbbf41e203545a4e39dfe5cfaa8dfd908a3ff290f2f5a66af83d7d7a04792ecaca195c31523242d14d03b3d5f8dc72eeeba8716afe6be3a6f9f8d49ea1500f444c204dec757e1e0d0010b07e032a40eb2379b41e0d8fb69c226fc2b4e7ff8ad09071fbe5213baca672ed960f6040c5b9c659a638fe34f9ed45efc26a3c301f0375939cfa8475e0855eb236fbc0520b7ad8794695d72a441c356ee296182f85da763c63da0109ba541a1220606c3f5de99da85110367e56f77d65c24ba1edfb994f462c3ffcbc29d38927e879b2eb3654a1af700ce68b12d6c3bfce8f2648e8f97231b31e17fb139c8ae4240554897665a1d72ed550a3cc66c931cd1b299826db7093549823f2768274795fbc30617e21247cdbb90953ee4dd0cdc2ada894297c9c3cc633363a2028cbcdbe27ff2e63d33ddb9ed9f22c47a8374bbeaf95d0a5b8d337a8594211111ff5bac28d49972e11980c29ae13918862bafbd11299750a945e4b8e8fea5335b2ed52aaf8be08c6f6b5ad628a0f80319be2d22f530f6953d16da7df544d6487ef797d2390e4a3b2ee5c1d18120d56def95cc510f07e7dc6aba0f3dc62da7678979da09ce3e083f46b8c0ae4cbd52b41582e89656c6819665155ba1166b556decb9165b5d6e0d20a4c35820a659834410a21c79ce45b9d6e8587f4980f770503c1307d87772a285adbefa055b7d5f72b3c13e56d10d8ab524f5270f2389d57a806fdc755ab1c40b9744941c3d348fa858aa21d21d198e937f82505a120b36173c1a50337c1f64bde220d1d9dc5541fd4a7ff2d9d4b55f853d072f400d243a73cc9566b2bf9b0580866169179221e0f6097cbdfe4cc3ffea62735cedf4b37ef3b0d35c5d31585c278f160aa01d13a450bd7d662f8dcd3134dde82575eb9c58884eacebe63994c7bd8e1d0ab138c29110450b42f85c8131b151617874dfb9f5d711dc7e483d674decb243c96d770399be151f21fad840dd2c9a09fdb68e3a1ce4526e4421233dd07d645fb8e5e823c008a1344f8ef8dca3a2119e78d76adeabafe596088a99c2476f14808b290e4ad46717ecfdfc80df49e7e0ee08877d947efdf537f1e92caeb06f1d622e1bad35f398bf58ad07231db660a405ba53efbfaddfebfeecffe198b0d1cc8e9e4f880875cdddd1984a485354cdbe85b26c929d67bd6142cf031f0918b8d0aa22ff20ddb630f58f54fcfbb8fb7d436e33e896fe6f402769e1c4233222dd73dd5b23f5f5d86b018a88f4ed84b36116fc9ccdf97a07b199aa0632893190af30fac50b3f0036ce65a5c9d81575004d76be792289fd851845a859f2f212a0945a21c97e183f7712c03231c6a14549fae68905dbd17e11ed3c23fd0eac1cb1fc575fd2ffc2e671c2c00cf480af195cc9dda14d495597feba2e088118b5b69b9824ece28e526bff9d3e95b8eb77cb3ebf4122ed40c72ae6b2ec14d93c7b00dbef0e0eceb6ffec4db89698a6b4b3bad188f7e6758ee5ec2001113f10783d12d5b0f3a48ab35b69f046ee3e24817252d14930d8e1e2b710287936dd7262756fb4768e435a7c06c3a3044987ae77a1e2a88a1cb421446101bcbfa36b9a0ca03243ff4a2b32d307c37f26c096cf1d5872f6773cf3cc2f7322129b28e1d87ec88765e89dede1a1fbb6bc5242126bddb7ca6660fea8f5ceaf609c0630d5f9198285d316b402197ca2353d5d31cb22d8ab1285588fdfd19354b3c6e9e2e185d52ab5ff7ea6fff101d65a7e73720aecb282fa780ea1b149dc44042a9f9335c5d3d2b745d7b9651472d4e77632602308c55bd432d9cc77ba0ff137fbd8444160d36a7cdb0485bdbf6ff5b376b2f5d88ae4ebe5485e6b8436be0dcb24ee724a0479cc3698c9b9320e9e2d193735faa9c040a8ee35b1c63cf4d30f283dc4cff0711f9ddd13d6ef5ad000b10cbcacb9998aaf2c823b0f2605f434fb1c3f269c9ade478cc6a038dfb9821c5a94a5b64b4cc35e3d83721b0e320c8f26ef81a88718e8f0b27fef3e3ba768159cb09f1a133b08257dd43b000759bb31032ea4a13a3ce937c2dddba43121d04853ba731d1bdf2078b296aadf5b870756352819e90c1af989b5e111b1c3f87d4c7903d24b456f1efb8c23460c0e267472b9981bae5f76a971f3f248da8dd257ccbb4063596102df009b608a3fd1401b1331b1c11abbcfb6642a374868b69f236b93e5e60e0e988df73f33e676de4787f59f28d7ac81f8be0c8f76e60a4cd5cb8a20690e5b5d6ac3087ab4c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
