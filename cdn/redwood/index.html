<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0a2d6a3350bd361b088f81af2869c21da1eb4835191a21a0051ec33537ef9de153cf97e89cd9bf5a05ddd6e10d03b667ef9ee185fcb01d02573cd7944ea97885d56c5b58fa4e275718be1787fabfbf57b89be324269cd669ec7cd1de014c9800f0c6dc3bef2db886710dc7304fc3364ff1b7b21064c198a6a1501596f191c0dcd8110b4e960ef26638e72b49dfa6a5d5b11e809f253e22cb7f352e6291d743f8e9b3bce657d9663002844c263ef97041302b55ee5b4a5fbd53e232ee1f34aa0ca6a80047a849665b22dcc527e04c4dce9886fac6fd1f2893420fe2adadc3f980af1715b87b7698980a9ead742305eab2014e1e78e301a91cbc8618a1f8450cf38a9d8460b9e74843ea808fffa90bec1174d85391ba1402fff2b655c91fd32279c9fb606b710899a541a106c14ffaabde2accc27c150a584dba657b45d5157ebe8ec030b7d9f5e46e6728b3856dbbdafb9bfe9c04d25843c7a8add4a05ea9a9128cf9840b7811a9fafd844f5a3ae906ab35a85677b93e9910e2ec2107d3076c5c6469e88050a4724fab2bc55a465a1c508ee98dd135c4662df64211c3973ee48a761b5707d0457e27280d6e397664b65db5e68f0f44b750c697afd61e68fc3539ac5c08ae7f137755d3f0c3d95cdfe7d27512f828415ae807d775ad08772d2815b152fd0634d07d2dafc1ee6b420235e1f83804fb8db919394dba386693774e91a37d6639a850de986321833aceefb8370d0fc24c21c60cc0ba2dd712fc31cea3ee2dd44a95551a7a8b919c90f03393cf04f85c708d007736b7baf4884bc2932670bfd50015b6d6b72bbd1102e56f60c2eb53c5534be9d83a8fd177e453da1cf4e514d6ea8442e4786c35df9f4081f342882f8dc7023f8798a1313c665ab017dd347825c72fd96b8fb55efc88a1c0e3459c6b31a811c6652c42aa9f431f1f17b33c0cdb93e0c29a9877e5a21c28dff8efeecdb4415fb83e2e0aab785a8ce4710e3f3120893d2e77fa43a87aa5e2f756dba8ef52cf863bddba1685996defc9c2adfe671920149a3082e28adbcebd6701af4f80b722f8c35bac008b3733cd35bf5a6bb698bc4c7c296fca81ede2cc9f5e874c71ecc0994c0bfd66019327741d759aa0e29af115e730a9d40b3ddb090838617cc1304268012dd78edc8e51357b1c0f00483132f031b609d608eaec1466af4c4a6eb4e7a614dd5745134a76d2c62ba705d96c2c93147a93259291c264ed2f2c396edeb0923a8751319890e160479b910dcdd51cd1be4dd215e83e681cd3c9e41e2855a209d56a7d53586236f91e2c5bab2f5ce568f0c5e497882793b05d64ba4930c911599268a754a93c20b888871d97d03805b7566111f64adca79472d2c3ffc711b7854fee20e158d6bc4b897b71f52aff43794fb91ae461e04ec5de548cc0afd1c2f4bd211d10613a973a3ba95380c079037bdad00e295dd88f6f7bdd02011218b506f33aac5536d6353c17137b08d9b939c052765dd1e542e63caa10289a999d03218b53cd16893b47d7ffba23f9a9ebe1acc4abb966e8a268ca553f59135ef3c1fa7d959ba27032f72f117e3d16a688a765ab1d8376208f786e48ccaa249bf39d0f4889a2a4f4bc7fe0ae97e22e37f6b924610eba56f81bfebe10609da57b1076fb7b26826103f2fd84204e02343964e472bceff092225a449c79012347f90d6e31daa9fd9052b77caf55eae2155191d439f7716fa2e27d231402ee8e12fcd561b49fc1092fd120833e31ee4421ac008c047dfe4cc1b9b1c1db1b7ea5c34a99403c4a02f16a08268f63de13a333bcfff8f21d3d11c67b791d25e2b0ce01c6f72b49840eaec982a8225e7aeeaea4b93ce5971afdd99ef78c58c7410b2a78d53765a94c6bbebee0d526b0cfc596003f6c47b8a22cf69767874c7ec0d136a8753388db864039e30706509f35166db67c1104a4f9a7943fa025665812eb04683a6b0e806f4aca146811951dda945d3dfd69c3e6534d2437a757c57e0e545d0623529c088cc601ea9f052ebd2ed60c1550fdbcd1e694bb6d931de4ab82cf738d4e39ef9708e680c8040cb0965c77442a1b17f2dcad3030353751943ddb323bb49413fc8124fbd27aea30f6251b9e2269559729bb5b7d5e41cd597eb45d54ce3d1c8d81c691e05cfd04cf5e1a6170e3aef9e40e9e9ac6a5faef362ecd7aa8a4c97d58a20ce8748a7ce07c2aaacd0c94acd25faedaa05f681de9776810e9976f5d6de35211460aa4a9a0fc522774f42c8d704dcf7d20b61d6daa124478436cfa60f6c3e68a419e2854719d9a884c8dba6081cea94897a361d36d9b83816577966246fabae2a301d1e482a829d1a9cc2bf4960f3e667867f55edee47de310ab11d8206e864954e386ee509d56e888c8f31ad512820e16ce7046aa50d2782178264a0cf0e3068cacbca74586734174345714256aed657192f6813facefe9042d4b2a571db45dd017c6b86d3b50ac6b7801734ae376a39dae35b300adbcc8ab0f59148747f89a7047ad22c932889e784afa8627cef50546dd6fb3f684bee52e8b131d2102fad7cc52222a860bf6c15679dff7fd0e5ed62b8102f508e76fdcc1a07f9ad80cd38f82d8f2206d522ab0fd8c8375f966ca79798f62bb5b3411a6ddad4d506cdfd3b24b48bc5af3f3e17519be22cd550c588a52ce2c9cb24c594585dff48d33c74185ac586ef7fd0917107299dc3a3522bb53407e0665e77c21162b1f3d7665a6aa4eaf83dee0276369cdfbb6e2257820f1087e8a1321e38a70ddb7a6e81c60733f1ba5ccd3a3a33a82aba8414773395fbd2d643068b03d561dafd5e37d8bfe61413f78e12baa6c41973ec37a9b1edb3ad070cf4f8dcfd84a0b73f530e76d1e2df6c95a441940af1a8d6860eed003d852bb87ee74e0630d992090bc68d7074a9e579f5893222fb788e4b8198d179a5bc8b0ad1737432d288042a5fa4597e63351ad58860827812953654f847c996e0b59fe3cd366ec535d3ca5f5076c70a034bdfcd57ada98a624ea8f30ac5967737af61c7bb6eecbf36e6566dfd018b7101959d0d8f9a83dae72cd38ded10a02750464120f6bca368ddd7072ba9777eb388f9160880918d515b8a8e0a6f974e3eceb4ce8f647b957b90a93c87733cf8658b0a903582d0c2d9e2250271b9521a0ff647f84eaad6df4ea1495f9a29754b9f12a5c8610f30c68d02471c9a1c9c288f80232874efa79115321cf4570b178eed19a3fde5d2d57f832e5bc7ff53636469ace85213c2b838b117e9e400b1116eed670c0dc112e3fde078198a2c8211a1ddebb01347c344740425fb733eb245a23f0b6e0012b88906f6b5f7f842335f1fd7a0761355c273cc94de278ed9939872bf1939123f6253ce905309f1a38559cd01077e4338a7db50e73e4fb50d2c53c4268bc323b812a644580698398e146ad1cc10820551818aed716293656674e15cad8db533380b9ab4a6f85e24e768b98dd2454463294ceefa1d6e4f0e622b283554d68e4e922c849f5e582ba8df207105992fd0fba616bd2f7fededdfd66f5c50781c75bd4ab2d2c8391a69a808ad5771c57833ac7da0972bb7692f270f3f72217e2129cdfffa7a0309821881d00a71bd195f7d6b87bec16833968741f65c2895f251a4abbe9c4aceb411c192a0c27667d78626977d9ffaa12157492ea386f68d661d41f073310f4b400b57a5fcab7331c6ca3694d3926febd11e447b072878472179a522aea2ba9e167e5f4b9bd56d1904bd933b66e4130d23ae1c5d611ceb220e95239f757a2fb1ce651051ea41f3eb3f9cd0faac93d0e2c55ef3fe9a63147c0dea8d5e0078fe6128838b7cc1b2288990327eced22ea14372c3bb95cb7564d9387a8bb5562417db2f25dccdd1a9064cd5e8b7d155dd97f53a100e6c11a76595d954e19f8948b637f421148fe5344cdcbceefa8f5f92d14cae2b2cdda6b910185f6a0fa088b6893e986c19518c072640d2089ca830ddfa2104dcd4d0640f9522e2ba9cafbaf19c7595a92df5fe5bdab11112f9e4931704513cde70c99d92c50e3e6ce162e887f1c3600dafc5a949ba2f7ce44f744b46fbc288a0d00cced5ce0a1a42d07273b7d8074b3d93c99fae7da3aaa025113e8bea10246f5567b3870b5f90d5736a2510fecca0112dbf16478183852a58b538e6fed15160ff5f84b100463cd783e8387a3dcf5bc60941ad60323c4b1fe76dbf9d3150bf3fe951ffed78e7eb5f25aeb5ed11a81fd8c9a1d83af91b5bd2a55740b60e24d9cb6a314b9c6bd61adc68d2c547707b2225f89f393f5932c115cfa447f90812789cdad42f13cb5bc52b1f77f026313f0cf33dc25eb237f7d0cc20442c88efe344460cb56305703b2f30dc8264b5fb838e8d8dfcbd5e5d4624f66155fa2b4d37a381ed066435b0fa27a458d598f7992bc71ceee070cb5bd72c28bd8c77fd62929c8f70488910063124c97e5e17f538caed26c2087a059a87a320cfa150e1fe1d9c02f89c1e9d7662db51b4ad7ef1014ab20e62c24f3f418a0110dfcd2124fbbd8b95496cc2087d7b4d09c3bb98a70be923d53c9fa169c895652f448ea07a770d60d5a4aff7dfde4c3b65dd3262192207ff76bba9e022df34137e45d7160f1394df9c9585bea8b62662b5582aaf2b48092a07a354ec7ed7b045df90a3baaed33b8ec7bb76464b8bfec19391024e12540133f5b2e9d2b1344bf43d670200f899e9ca1a7f7867725a5b2a88851827501682d524d344275823268b6ad5e0272a15545acdb9af173e114d4acf7fd64b6371db097607ebe6a8c9a5c22d1ec26667260bf98bda0dfa877c645542a7a80a9636977a04e16beab507b274de9753644ff05987d5efc92447e42add90a8ed58b95aaf956fb935f12768a1958421d3c2483c025fa0a10ea2c27a1053ba8d0168337b4c7289733cc7408d776030b1bb008119f273ff18748c3938b32093c5b4cdfd0b64785048c651414075be4515987b18987ecaa67a41adc8ee397cdff4d5133e12a44f4f61ae873a4a5a08da49f89566a22bf05a92d931508ee8fb8733a21d3d93d06962fcc9f47d6e74bbc9c8a35d58d11d6a298cc37f42ca974130bbc51cabfb0313d3d6371a94c4a67863e3013588033496fde6cc83ea65979e89ed312f200b33b276ae4b8a343c000579f4a9fee10d0bd795070d01ea2f99d21def540f5d69b8880bb56caeeafdc30bddc73f3871fd96a58cff3a2a546e2e841a36dd1a803b86f0473e8263fc1d47511dade87c7cbd0ae59bb668e4e684ee2ca19690e1c986b1b10373104fdf4db7bdbb0b003274d82f5c8fe0c69e4a5f9f12f39d743c9516113bf55eaf83a35ed6a070356060b4d362832dc20f846929cf7a2a74b5ca46edd0e51e56b1144e944c137d684ad558634b236e8109bc95e5b3b73f74175da4a744a0ca3cf07a2ebebadc14d43153c1dbe62028c0e7f203f478dd31535686e855b1888968deda9108ee85e284a33e77e9d70aaf13677e1b070e7ab5a1eeafbacdc83ec67943c7f9db01dc4abd193699f1892a6a185f7599f2ce2e553cfcc44c38b5fbdb1b2775f19bc49e367125693ce5ca57baf32c185eaa87f7f2f666ca4087736e429051124ac6a897f6b681cc7c11c9a6a6176dba2386d62d8dbfc0cfe84840ac82c1aa39fba8c99271bde27ed6b7f9087d7c15809328d6edde7ba11ff45e5c20dfec3c4750ea10dc5bf6ccee39947cb5e510c53718dec6285ac4f4a86a3622fb3c2ecd9064788ccf6132a950661a07b1885511def227f230f18d3021a4ae03bbe4fcd37b0a35f385e5b4db19b20af5fd61f7ce747396c90b8c3ac79a52d4b968567ed44de9c15e8a8fa7b7e6b514d03f582507648aec4d668e7ade8c3f3dce9be684f4e8ce59f6c6a29a1792828c6d280124c7bbfa5847b4ced62184775c0dcc54ff41e7d391543377a0040cc6aea39fd7924d0c7a3af8689b6c512e0529cf9f594224b7472fae2c031d9aa6bfb63f57e22e64d6d0725c4f3ce4420af0ac3dcbfaea1772fd79916379b362a5dfb2bdf83a49a26cb09058cc8d8a022a002814a4acc549308515b8c6216e0a868b3f6691ba97005455154b875692f74c9e715d2d3e452c4a810931a1f4685b0773d478efdd0581e9dd9e70d1150e7f90c78d7cd17dc4a9fbd788f457f1242c057fbfa5730d8067dc812cf2040d23f13460655a6edb78c601c73ef95b3f8338efb8e372d922df47e16967fec22f14d428ec3d2c57bb1b3c00a0f51aa3f81fc8d46a318f9533275a973887cda9bb1be698e980e7142766288083b0ac5739ebc342a09115b98b6a7af2a39ef0525879eccc309402f98d7cda8c8b6c49fe4ed68fdbe1e3ceec87a77dd7a219a20e2f99b047eb983a26936f5ce560932f53164d5b51681eda560ce31b4e9a3b753339a7eea4c17dba8a40f5f81473e5d2cc1796a4b43217ecf90c18951d278a0dc52f8f166652544f08659085f60b94bb3634020d409471f243c097d79eec1ea7b2b557db15b89730daeabc74fe884df85a58bbe71b8605cb387ff2047c20846c7f0e9f09528c1686c5cabe881ac8d787357932942e09ebf35d225f0ec53adb01290d7d537321e26f83c7b694af7eb38c047820076259753e9803c632cef9ff9edf0ba86fea0011d89821a0fbec5d14d40fff2cb5d3853c7fb03c848e19e09bba75ad3e0732dfd1b1aece568a05d73ac002d76c7915b149672c2b0c8f9513d27635e9788914917df99e1cf468723f65dc768cc8dd4832fee98a8c57e28281f79ba9aa8e0a794d2e9130e7d4a4530c375982fa547fb5e535b844eabec8fba08b633a8f950b5ca9a75ec641b79906e2a8a468ec0d79c95a6ce7dd3dfa3f74dde1990cfc27ed2b4267ae839ab6c0b0c5d47deabdb97807e29a684f1b9fca8b11423aa80cddac2191169224d50b367a94266c11c017a2ecf50ccbe8360adf1230de4fce8c5d8b72b08e7b6c5de8cd5eba7b539e10a84e4d9ac5ce42a436c757ac540da855025b9b288a017824aefd9582dc65e4bceadeed4bd16c3f85c8fd0a72aa306d0ff3b389babfcdf8a703e572b697f36d43aeb66c7fcae6adfe1fae70e49c55aba3cc0a6125c723d7cc07d0f2de6996f58b103ded626f1a9093fae02e51ca037534f4415a2b2d3feb3dd7b62f329324e292f4760011ab3f5dd6114d693b9434bb2c2b7a6f3f132f0abf41d762760db885258e0360f22b7dcb4ce43bfcc8083d5dadf58381fbc8726b2b0e022f2fa765cfbd8b13eeb41ee20bfda1b16199d275467c5ebaf7bbd3d36a6b8f16832aae1786ac375d899fe6e3344df345cbc4224f7c0f100417c50d613c026b9c8a137e3b325afcc89ab4b883ce6d25984670261e4324e180cc0fd4d2afcb02d7b159594aa2238f87aa304fd1e3faab0198a910a555480be16e6a520a7bc1330ae1a5fcdf2eb44d23ae944fe376133ed29bba2b9e0d523069ef9f24015843b78564a123575d113c11ba7481e2363c1f958ea36ceb7d6c8450be7ca615e6be1fa845716406079d015aeafd70b41ec08b47767a046a4a0648d787d4626dfa372ed34a141cc35cf0039d40a12f24511d93e62bc8b269d9452c4f81bb30813503f92b09a00cbc52cae0d6aab5cbba8764e0f9d6b52f621846b637cda825a89f4c4aa12b5772a1a8dcb3d55fd4a39ede072f2cc9862229decef5618e45761036a79537bd1827b86a0c3f4192b786283adf7660a10a7348e6785a41bb4c344b9f667f35aaef436bf904451fcb7414c839c3a9ab442784466ab12a1e0c328226c13967f9b47a9ddf810654e99a165a74c217451560c09471d33fb528e47255fa3d5517f4d4fbfe425c1685514f374be90cc3fd1107b5de7ac5f02482a7da900f2e59351a2404e41e4aebbd90aa4ce48b26cb427809f1052e79bfba590bd02015078e13bd955f14cf8c80d49ff1543b2a90add2d5ee06f4a78a502b1b28d9c3b3e3b06d53ff7e497fca7d376ca365751b2f2d0907424689e198de1a325d0e66b2147fde2cf60c9926fccbecbff553de117b1b53f2753bd2e8b51e8187c68a0913a4fbea630f95cd66d4714c66a599ade67604ac458cbb5bc6a1c9e09a589dc32f8c19832e8d1a4ca5f72ac46fa13d615d054d38f6bf80bbd5c1f29119fe206e6cbf80bf352e09e94c6631647fde79da7efa5130628d5fd1853ce2c6a1ac0b376e7c4bc43c29ebb24695657112653bec317d70bbde4aa0bf6f7f61ae6ab4732f60a3642eec96e2e342a213e4e3a5ec615fe8f74629ac5d0c1e1d687a26ea4d7462185d0b2a9d904685688d974d72243727d262ce62dbc6afdaf0c29f4bd2b49b2577ffe979abcd2081bb3f2ffb1a403f8d61789f599a474a04cde073a327ef3abe64e58a00bccf12e32a80a4d0d79d3da19243c2b4182f55899462cc966892e302b4c3f4e7fe174bb0e216239434e9e6499110bcb6cc5c4bf9b3f8cb69f3deb013f231448ee42cd54c3309628d2f4be5594c5ea33075d814e7101c74dd94c07b64434d195425a694ccd0c207d0f08586f02a3773578c0070e28095f26a4315013f0f20f781f9a84bd62831582eff2b3f86ef332e09ad2ddfc98ca543596dafae193b8d3b71db94a0b16beecca9b61fce9d050496d6c66c57ceafdd1da91ea0c39edb1c47e681a1776435a754189b2cd9f05c82021265b3e7a5a397bbfb2c2902870f33eb60b2c27a9042f0c3046306bcec709f2878b98fe86357f40d4515935c6808e824ee716c2581e9abb25eee3eb54e2ea9625b2e096dad18d240da9e8c89a2e859c7076cd1506688d9007a51474e9dddde8de1ea1f4813325bb451d05312cd0e9915bf61481cf1d570e72c9bae6229cd5393cde1fe4144e2029e0d0fa1ff0cd5601ea599cb5719d9acbef981e5d79869d37783d1be10df4ba5c7f43a7feaefd6610e33e801752eecfe8cf0beaf69798e2d0259e521447f26ddb37a9ed9dde342b4650ce7e14477491da602fb5e6c8d95077eca827e1aae599bbe6c44b8a01ba09ce4978c96d0713499c6eeb7568db7d5538c41bfb96a265cc7b4083f74828081ebf2a502486b8d14ab440210ff58db83a3ae26a3bd1e944abe18c146e4c8ded750d88dcf04ee16ea1777e4396e0e0412ff2e895c899897a31b02d9f9ebb4070aa65bc30a49a5ddaffebaf497ea142a9673dd5b60cd10bb6924a139f9e7e516e53ff4ff82345e7de944da84d90195be693af394d95db5e7587f3c3420704e602d1e951431ad9dbfdb698dfd99c7231528d040faef96c1204b95bf884c1721a60b7fe95a160015043d4289a81b4745b25c40ce0b91d5f766d0153b573a7105b690a23a9286d4de45e8cbb39a81a349a5757a8b4b73a04807e3b5fb5b56800696acd7ddc4a86dfc6fcd4a6b40492d8a933a4e10d67d958814f8ccc2b592212604b975911cfe8fa447e9f0255a2c0032beb6b41df8e820da9ca30c55b17d5dfc322d2ae0452f46982e30bbfe9fd1c1ae24a290cc0f4ee0ac6e707f134606f052791ff46a35fc51cf79a54d1211ca2eb04c6a71441718074082d9a6279cc7744ee83bc5153fb1c124442997b792ce35e9f0f7d47658c05be0deb8da8cde07ac175e834063c7eca4427178c111419e19c2666397f13a5ed0b3049dbb4a73500a68bddbd2b024d20e717cc3436e19f6ef074284cd77740ec47da5040d114b9c06cb321f35c8f8444cc156b97990b6d871e63e1e614bf7888d66446401e0ed4d7dcb01d37f25ef65e5a9e2be1e9ff464f3bdfb97ea5880a8a45bac1a6c6991ee6ee2900b88b6d5666e096398cf2e3b2e0e1a1a65c7295a1ac7a722341462188575d8fd3570e68ae440e9b586eeb53d71238393692e24a9aca7ac2c651669dfc9c21489505900e6781495ec1e0c7afe749240b3abe3cc705fe0bccd97c8f90a508e410f22763dbda638a0bdf8cbcda969ff8b319bf7daf5af34fcbf05df586d4535effe693ac223a1dbea3ab082872ab0ca5ea872c6cdf913b8a500335da019b96520b42273f97c73300a342274692062ff54c9639523395e035a59101b435da2c3d13f8f1fb70c6bca844f27c45f106049df318f0469aba3f7cecab91d78ed72aac263022138dd0d58f0ae4de0344caa421c60f948ab8888ee7ec780175af778bf28b751c359cbe2e53439813d970622ef9d30935ed423accdedbac282d0bfc9224db3ac1bdd53f61fa9c4e5402b59d3e5b840cc6ad1f5da8f4f62a71543612bc06f8c84ca7f4bae5c9b31f3076aa670142e2294d422dc7b96a872335f7ebfe5ff95d637f5981a4e73e049c039bf1d7524fabd4ccf2afa4392a47eae07773a7e0a987ea08c7fee002f27272c3c3814770b9a8d27fc7f1f5f50fa02c35658f6cc1460a5e6e00708c5f961cd5c3d681d1099d181b9c0a2d612903d5afeb9df2d7756093b2137d59c3e2e26e497c45357e852f8fb50c140452de4f817316ac7a6588eedf785c1fb6a14d4d1dce20683853b06cc25133e51967f76a94c3e20322d2602ea8c93daa0e3eace933e83ceba4a1e2eda02dc0f3c3d92056b6c4ea29c62fe60a519ca4297b2de32bcc0866ef1ddae644aaff1f93e995283b6d5b08cde4e2df4461aa8191355821fa722d1920e8897804a3acfae06282487a02e88f2ad93741677ebe25056378fec289fbcc2b0924b2e3a15d3084e1b30942d8c5348f8781fb372fa682a090b72c710308ace577729efe5457b3d09ce69fe7b2b65e88ccc3ccb8a900b8cbc972202caa20c6ac07da68cac894877dc34e3e84ef3e87b9b909017a86760c2ab2e2c26c310bb9d1c079c83beccf3f7b5d94691be34347793c01f446cd8c0b5af5181831d3d1139156a09f011cacdb81035c574823c5f74f741370d2222bd752be16ddcb9a9f824183447b3141e1b72b3d63c09353ccf9c78119804b7f3d8c42d1d8fcfe631816adbe6260a17e3a278e2658f47669e260c0f5dfdfe7c7056e2db48e144ac23429b3747afaa21578dc19d4c0b2238546105f209278f9649195625858adb87e1da5f592cf5383ada030ab9cfab9f44443321fe1a3e17562a50fd8dd81269592725c453c87a2a6629870ee3c1fc0268e0ff2aafbe683a11d765dbddccb0021fc2b209ce2a0ebb674b0b3dc53aac6caa1eafa44c590a4ea7ec6cc9ccb30d7511f88243f08fd1c05e0c1780803fc8318bb74239b3684970cdec622438414e57d825d84fef8e24fc5f3d66322c77ed7c636e208a9c7d557fbe6d809a33692d812b44e8f0e7afe00056cbb81f9afa617e41f1e0113b701e55e1b2c6cc5a8061dc7e5551014ef891af2599f294fbccdd8e5b5b0a8f604a8908bdaa28df58faab90a8fdd0f6cc4d3283792912216e5240366f85e8fddbb2611556a3ae3bdfc95ef3b8c411a32f913823fba01298b30335ccc4cbe6dc94a47db95c154ca80a603276ec8e62b9dc28975817fb10a47ad01c277c5038c5bf30321b8505f10264ff08fd45c7a5c35ad77820e2b79323d56076bbd07a79573f107170e5ed3436680a2d1ca3b99cea7e45a5155d2f120af9f0f744371cdadc688016adaef41c6b67990658768dd1ce9716c23bd384fb222a35037b07e17355c6555468e4aa149e13c93aaea362c584eccb5eb685d57688eec9daa13ade77442e024b20e205ff451d497e7b9dd92ef3415722b2c9ee53e1feffffe831c7605a159b62e5698cdefd6f2e4cfdab5a42d89010995009e1dea5df6d59704e52f563150228d99e03ea9900604d3b1c4909b08277793a5e44536f4dd0ac41bdf4a447817d8565c3a649a358421d9abd0c52327d4803041bbd907b699962d53c022c67d3c9b0036cb58bbc764c88e3446bdf657e6243c000b9dbe7cbbfd48afd524c422c710dfab9873ca55311dff80967478a80d9449125b044c17ff6366e7d21a0e047efd0ed300a029d3b84a36c54ede9dcf94d84e0a3f1f2df6695b744e2b17660059361f6cccdd55b9e6b871e3abd73f80ed08eaa9221b96172de685f2784656c0b9f918fef81cef2378a53ac112e4419be284d0696091c9420280aba348b27766be40f6accc831170d8c3256fa8fff7e1233c3aaea2074a28b6a4ee11703087f8076d2f2edadcd143ee4af9c545e1c58df3c41a5af4265b689446d288100d8e9000e2d37ec00ed1b2bd55674527b891ac7a9e576933ec859f3d1b43164b7fc5ed4367d55700458370c3b5b1f992be472e5be24985ee87b1810c90a69b8381029287c57edb3ad41caf4f9cda478fe3c74635add6c79eba385c87f9cf2f3d0f6f2577837531990a0ac44a725e5e03b52570cf55f0beaea142c0b324f146639bcb07b832723ce94f25471821fc7c80a8cca6d3b21593b00353fb01add528f318ebcf95562e6e568fa9095a3d4af912ae706a6f9e500149752fdfd4ecb0fd7d5e6672fbef235f2257f3ea4dd8f77b73c65eae21ec7ed07d7d91d12acd28000fce6d622b360614af33a38dd58ad726f46d4b757ba31df06e016550342850abb26013c0d0462e170c66f92a51ca24ed003fd5818bae3706a50b20bff89dc1692d39c7bdf2edb68e8dd5ac0e817111ed7631d6010a8022d511ae963a66b10650a7109a8fc02049cc02889ff7dfe42c5ed18b060d59d32c9d5b1ef6369fbcc1a61a8fe9a740a667cb4199e985f9a2f8ad796e56a7487df79ebbddda330246a9428b1656b15f8d97972226d0a3a558d21524de50c5808825971ca9563dfc76ab24efa92f80677622b0e100ec6395b45586292d1e493a53ffafcd26ebc9ef6f44924ccd0a4ed99ede26cf3161f3d7411073c35112ac6e47d0144cff0ea1c53c064bb40a4d6b3b592730e63e033bc6d1037f3509d94e17975f8b4f00ea06d6a3e98266e85d420634fdc3d50110d60aff4159fc740ebf734fb3f2088bf2b153915c2cbe66c07652917bd4fff7141e223ba2c181e5fe9aa99c530f488eac33c5bf440e6910b1ef4f362a852ae632053d8bc7a9df6b865c64eeaf5f4b55dcdaad79a6c4b405414d7a7f2e46b9a5eb2476c36d45289a16218f1835f3ef9277c54d604072772fac19b77cb09656993263cb528ba03f51be693d2f818ab7a4679f5e9e2a3f043d7ebd6f90528a06df62a0853b07422d658275f1c1f610beb6c72960e67799ab99b68b8547b3e72c4141daeb89336fafbffa9c3f6fcaab04c71afb5ab8a00429ccf1bc74a96f1c860f102229a1f1889ea4cab844e3451b09c9b5e148a9359c5ef3fa91617246e4f2e139e996a19c631ba4625a6c058a3083512fc352d5550900b9634c06284add201279abe2b4ba564b48347b8fea7211e3d571d21a26648d060724e39d529725f6565c9f60905f7b2fc952940b499acf50557fb9123af85869ad74748149b9a6a71edf347cd652677a5aabf0739420a4c9c86e98538c6bbbc0ae8883ced74015989ca5b762c2027940a60f5045a2de93a0e70fe4313fc401c83b170a00fd6b5a4cddc990b728265db544e7a6ccd3e385da9b28c99c14ea6fcbb2cb480ec495eea1db6249a3f68fb486b26b4ecfb57386f440c38fe969eed5b226bfa3d58c3eaab84ea20713cb3b0f72c13be403d2bf7e31cae25e024a5cd87adbd9792eac794d112f7fabd69932ccaf32007b8f34acdba35df6838915a159b6a8e2655a3d4de24d3d02ed2ba40cbd3cd8bf17d6ce670f661ee07a243615e5d9450a87e03b4510b2de8f03f3ed4215cca6ac9c2f0ef4d5b42cf4abdac3a4cc63202c4ae42d78d87381c3b4dfd21b54cb2a28ec53eaf4cf5031770641492bd0b00272630da0919c668d24843dc4213565894714683780942001c541e92cd4aed6147287e6d291c405bbef0e5d2d647d174117b60337c731c4ba4a1a51e590d3ad498c20cdcbe4a20c66f1d7611b1025485c375e73eb0b704b78c620de1b2f81244b7889bbd2caf7238fd921836d8c1e03cb0172637e975a8c04fb7f60c6c10271e17c71125a4651928d15cf3b195d390dd839531d909dc1329d79559a9d6874aa983b2f01435be6d5448a6b5c54ceaee8cf1a8a244f9ce38530175a41b4c596c2f8c3a2ae69fa549374dfbdeb067444eb0214be406aeac244d2ad1f71566fc826f599cf35407343d843e1f719c1efe9dc4ef818129eace1741b5357a4e7a0a6078a9f4ce4fbe8847a1871e1da123d1555c45653d12525f78f1025c660141ed10273aeb3917e6a23825373c86da8970b87cf749136f1a39475341803c7d8abafa8f08fb9e4f43376b75c89002096055f03b0b3ceb350678c65e5dbb80fa4e01451805ee98cc7ad3b67e1b8a4c70612dc673b6d63d887f3866eb338fb4f78ab6b7060bcccb51e40e501b1bd8e9b17c1d500e5eec476762d603929bb4aa7037fdaadd9bff6b9bce865adcee88bcd817ca6a0f540116d1582e525a945580ad697405c27a0b5c598cbabfc5c8f5b0501df57b2c96cd27c9bb9762ef0a62eca492e60869143d44fb18371ed943f7ce2e970b955a825aa9f9827b888e1510b12a8535d4325dc66791a9ef622a9bae348034a8d24495433cb01b8589d3f774ddfc45414166fe688045bf01d1e3cb54dc32a52e067404b2bbdc1a0c2d3b79a87cb24c75691c8bfe567e471b2047455fdd9b6f1b86c51f1c90fb01e7d2f579592a7bc3709c38249d9b6a2ebd3e449e82f3fd018c74b2a8ecdcb925077aeae403702445395b4121ef76ebd813e43bae94ef81d6f2e799df9bf46896001bbdf1e9deac4ec1cc497926d26d0ec5f8e7e2c8a851762967dd7880206a713ffa10c04c4d495e6679da3525e7494ff8b83a63ce9ae9d117549d6aa335e0e5aa9630a4d6476610b699844e31186f446478988441abcb310d6042fb441f5119fe02e0feb7774a214e6f3116a56d12a5b10da90a359feff3e3de4d490b698046c5b4e33a8a42d7517a340c048ce02ac9564c8ca193d7343d17f51b1ed712d7dcb8cf0bbb059b9e6e66d9192b5e3623b572a8591d1ac729ea5f055f571e1951535bd39f3417a584378cf8fda7b83a08b39de84b47e9e5bb58e2aa7f2d061478f6e75419c3ec151849d02c26e6bab7a3cdc26c72fa1a49c8024f477e6f5d9f07ff8fc9132423f8d6ae8b35fbce542fdb3f090d405b4aef0ec4c77a430971d0900bd4147489622a0655ef7b1f9d50edae3fb25338f7acd402f9c49e568740a07ed0ed0ef9b6128e286ff72e7c47a99cfbfffd1f55b8657036c6b0dd94ec3b0fd152e0e9b403bcf5a3e165125e333f01297f99599be4ccb00c20d60fe2d6520a062fded90ff519be1b37f7db93a06adf4d7ad896de4d2c48759426622ee8c1aa0951830ac6331bcb25bdb6d096980d3665619663e33d574b588f3ac5c3f29a2c4d30bc37f5dcbbd3a4ce413643727328ac915863b1883f28b1cb123e9348a2430a84ca3f97bbf76356fce7b6b0de6cc2c1e1a4d849c2bbcfd382f43e257ec7ce9fe19b58dcb3021b02eacab09c0eb15f80a78e5038a0aa7bce7f6421c85ceec9623e364c7b133f2cc2538357ec7897252d2fa80d98262a6fa8612ed14ee32e28c0695db46d0610b5ec1e68acd4b69062c01ce94044c62fabcff2609fb299439a611ba350350b7bf73ba3f43e86e4771f4a09912bc7115296bc2f49e536bd102b4cf9cd186bab0c3c1525e2e8aaf1d9eaf3178d64805d57f9ff3213b09533acf1c8ab40f7545e39c9832650c7f113fa247b05eb130934d2fb7a0cdd40d62d4c0599e659cdcd67a0297a2fb2cd8896c1621336d4c0db2b44652dec490bea04949dd963a11b877eea09623dcc49413bb084b5ed73186705ad4deeba3c979a1b546bb51bc8251639571c2c07871fa0f0e597526cf91adfcab43d60222e7f5d0cc0881ca20d37933a3938cb8b3dac3411f510a15be66120104c3ce818adc4712489cb782d715983b65ddc29c23880c03c0d66efa7c6d8373305ce9dc07ea0c8d63ca7e4dd1d83e0ee2e1e86e3534b04a8d77f9067bc9385e2892b0edf7c821e934b3af87a5f4a39de9a797daff595e580bfcb80b62d56c6e784673077d6c3566cc813ed073ea49830e5ff25be4898d32ce525ec3ba9791ed77d33b6d9b0a887f32958fbac0edf9801f77dad3ebc7391c31ed71ccd9da249afcc6c23cfdd2aa96eefd471cba98e2b0ee04dd31cfb7bec8aead5761bd7851c15a711e39f1c66d96edc5a2a619586250d4a119074a1338f11c322ddba8d7149fbd20578d1250ea9ce4d79003e1773be798350e143a036fd06702b46570cbb11d159cea1923ec1ee3ea1d56ce54c792291f2ccefa055010b188277d858d86d89e66749f428c0735b124e62503fd9921e42dc1d852b6e6bfe85a393937bfe19f1cf964c4f9cb7c6019bcd01b4e17a7e9518de5fc5cd8ffdc3a306de1690a5f3e37e54fec6178955c618ac4fd07fe4e59b2b623a5321e15ff338ddaaac28a07ca500351ad8997f67c8a772b98a6f1f6f11b5e0ffda16e4d5e7fb67bea3afcb8d10120c764c51ab92656e4eabec6bb8d514ddb69d84da0f778eb5a1dab371fbdf009a79f966943aa5456f69386b086a3e2066aaba267c353d3f6846f6f60c983d4da92bff41c60f91837589019535bcf039a31a263710784a54aaa09cdba0af03cf7a701b2da3ee8c0d2435f30efdd5849b1e9e3a6d771bf2909a5be0d7c588e7849e97576f4ba5de73c4eb1a07256fc8d8ae8a0a106e18e3057f4b7603881a4feb64ff876e24e759ecbb47879a56ef63ecaa217f81080e56c941a09c0314582841462f643507704724b069a10777d8539f065fec23fe3a1ad35effd3da93a22ea595aa3a467a8005bce19df7a542e12cfe653d27fe2d57d7e6269067e6e2731962dbdbbade0f0e1c5da28dfdcf66aeba0aba05c55180a4dbab003bda80a6ece279c261dda91a8c1eb3b894297f29a933e26c234d43a9f7283ffac06ed6608d0977666672c0b3545b9fbf5dc57d91d657f0a9694cb50bd884c58972e8c82f345aed558ac646ed02046da76890b5b973cad151a50d9a52f6e58bd5c9fe3dad8c27064be68e790b5f14f73aef0194d957cc4866cf7db5d2bfd423f155cccd4d33eee81f62f42d57b54ec1cd6e478f5a9ebeea2053f715a826f3a436e193d76fc5975e738a1a3b8c56f438e018ede99ed73f91132ae85163986259ef4cb69c9be801c32abddee225f6ab0db3cf3210c42e90f652f691c82420ec0cbd2ec528eb29f71c0229a7a7b0b4722436c7ec4da471c5eefcc16772dad283b28e1ee3ca652e977812f1fe5df55bd6e62b44f6ea8d2434bcf475732e030200680a43adbde6711878767429448bf83198da2cbfb809df8ae620f3a71a7f71738ed09debbad3fa4fbf47f7849bd7682de34670c6ec9178e6f71da88b272019eb8fb9a5d9e84d7fe8577fcb637306d549aa7849155d78d957e37c1309bbf093a4fe3db0db7dada2e972045d4df3238c917277326e0289fbdd086a03df0b52f49efc5d3d3d88edda15b2936b882e105c5b42d15acb859f5f6f566ce5099ae717f4de1d163997d08bd137e50ff4c04d6f9e40c31570f9c6c14fb47f88d1589cbf23e43373cf5e1fe2fc70b7958210959c50a3f1508c1a9c39d638c4b199d9e27b1757db1cfa475ae785e2c5596f2a477c7cddbf9e386eac0200fbb9bf1e09c2b5c6e6e8c869e33818871db3f1d51cc035500a1c47b48905b5227ab7242c15cd3b3aa1a0a6f12dd77fce65a4c1d0ebd9467166218eb3894c7bc66b89bce4e586c2a7a778472d03f29edd2e3721bcdb42f3a8ddf20528f456da8c830a1db2dee0eff4c6ad143be57d5ad0ed1fda866cc2ebd4fc77f53ab14800aff39fa1a60af265f6d8391001aff2709256002c241311d63f2f42acefe5f01ac8e41af7f3d069a65aebb38f647c8b64406a22302795b382d1e5b5605d7ba0a5ec9e20cf7d3617281bb805991ffb4f55d95310ccd49513d10f358a8873f07ce4aef0fd538492c6b6d361e16a8120ba1d935c1247504b5c3ca465d9bde7935fc5ebf15e1669d1bfadab8e08c19ebfcc2f594f1f5eb1797fd584459e34d896f51a509e1bc165030dbe2f666391a1ba39ffbd6beb26bf4582ab74d4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
