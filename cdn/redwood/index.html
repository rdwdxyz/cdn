<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55e64a30b66e873878d1c1c22465f9c3ec0c1d081e00f3f03aebef305613e8e82bf95bf84bd2795b7addbb5f46ee67e9cfd3de3bd429c627b15e3de5ae85375df496ad6bdc0016b66ed33e5a284d7016e4b9899c40b8cf465fb55b849b3be350a31bf513ee139cf0bde2285f46f1ca047da7cf87c7983f190aa0319cc370c416d58de6cbae1c749b763f5e07aa68a39fe0227fe00b1256671c686e2117fb6f246892739d3f0c1e0b6837d0fbd31b5a201103fce9fda6cc51ac2939ac9b5cea64ca6aa2d3dc5d36ae6d37963f20e77fd8bc1f801150b789cd8c6fd8c95ba0c231e59883ffc0302be3c35a44aa07595fb999d6223e17a773aafb701032b92d4c4658d62e2899451af4a335e44096f413edaa48c4cfdee8d427d0668ce8401001d7ea338dd6a80f37d0ba0d5552fe6386b3672d564d4b95464ec59d7981bb35273216445c80aa7bbabec7fd8e91df293e5818a91f346f2dd194f930a0d056388af96fe0f7a2e5eb8f4365029a116cdea4100cdf38c8bad7317adaeffd26bf3cea15ef11f5cb3251984808a3ae69d0e5fe8313d3ab93a75c87a44fa9a8268bb0b0f25ba5ea29c851ecc212970e450714b37f574ab1823a1ff312645e0c7b331a47611105d4dfc029b502b1885dac68455772788aba2e1999958f167323d9dbd4dfc72dce46781a487f68af9685dd99f456bd1491df55b13f0dcb5478c9617de57091ce455e98539b92b008c868b0dcaa272143169876d8f4bd9b8e85c3ca2ea18c756fbb74e0a2aba694c41f74a7102c1b52213336c07cc155f3a89e035d5e734f75aebc45d00ba56b2ce7a84f26e3a3ca88f4bf6ceb9ff387b165d4248032f53ecf6ec90f354563fdbddd1742535b5c2a68db595081324889401c1dfd1c666fcdf90074cffd4ab63361e9882927830a5cdb4c448f7544fbb174c746717f92a88eef723b01c08268ead3f2dc029ea48afea051f3a5297ff03a7547068e804773f19d9ac47fd3c56bb7e6ea7311fc4b2f73a149905d3dd744b406982531df9f23eca7e2a2ba870406b0527bd1ad93b6ea9ad6a5307491010e8e8d534a016247c7043ea631185912900c706583a03842208215dda2a7b82fd546380504ae27b3889a41f8416983ff74827f773e582f74fc8b589d503eef8f4b7997bf3f346c45d5d626034d6614d7198ce78905b3f0ab6c9c8ef1b6fd846dc73a608116d76a4e97fca495219d61ff46bbc01d188c15b5d60f7dadbc3169311cdb71b13370078d867752a0bfed16ead505a12651ead7a223d0acf5eda37d89e723838da42c72cb05782313be5dc940589c0c5a5e3e026d1dde66d951f00a2f745c25a5450d144e07143f2d9e5496021732ed5627082f8547a38a592545ca12b38142669aa3507c96036b29301f888b4640109ffe78359a9fdec31fb85dff255f75d32ee3bc97f05521632a982a8bb9ab9f37248accd4dbef52fdd82938e6cd2d48303a8e6a2b593543049a353abd6e3b43975be08e2196b6a79a878b8a3adf17f46de70284bbf72a2bf71789fd8d874e313fa6536bd9a74ffbb5dcc2922e40213092456e7332951af25af0e74554c9258b11e98b1d391cd7524af8354acb82288b3cfb76e67af8bf57b897b3692bec1baa5d99f97f61e8cb4e698719d9e631f61ea73e5726059134fdda88a3828c97898062ba646ef82f638749ed83344a150be7a9d8b0fb07ee74bdbbae1140622c9ed8d434f2163c860744aa5c5d7692e02014ab6dc7dc2c0fb087d7b9d03739e1bed8c6ced69148c5778e94db6f6198dda44bfac904d73ad8d7f2e5b11d7f0746dc5ed1c5f8111fba64931d1bdcf47c028f5cc21cc01c43e4bf13a928f029fee745ec47b230da6af9470fabe5d655f8027930a9daba2eafceefc1ae0e8178846d657cfe027192ddfe98908ad7285f934af71b224c87d45b1153773efce6256e5245ea11de380392b547b822f8b6313abee0837feba7d4ebba84def2cbc2f82799e916278aaa315aefc5ab6217034c4abbf21b21744cc473afbd9a30d1c80bb80a5fcabf9578ea09c1888c0b632499fdc5af3bc20d3208d4caa600ca88e4e9a03a84bea7dbdc9856c6bc7d0f53dcfbda9f6dba8f1f95dedba986c87ba6bd42b4c2ef25ca214fe035241133a42d49f9db6e1c5c2e24622d26d1076e57cde7c89c8bd760db441924ed3cbdeeeb01594bb7d5d29296366ceab99bcde03e7451726bced8c21e2504e57a6f1ade9b232b6d0046cd4cd4f14d3ccc908c3bfdb4b8bad4e7b68277bbb01e736ff8391c7e29869d18a7e560e83a9e35f0fd5bddf89d9ec5a40c8b8544379b080c6806fdb62baa38de77df073a098e4fd19b281985bf017b67a4444754fd3e42ed8772df7bf0e718bc345442c1b3a3e7e36b4ad1f8a388ea541a3b1f3ccd4e1dd402ffcf5312e8d3ad032e6e7ec23f870216b39ef2eba13d9dfc0eebf7138fa360d4550deeff99932bccd670aad08f244013b3b9019d9cec920212a0660d0af12e357e8ba7f9edac93bae91f3189c65459d16d7799fd35d60f75d639ca6a7fdd5b34866a520767240e58142848ec1da2decaf4802ec7c7a41222dff3b7ab11e63f877facd29c069ea5942d29ad2f2860c560c6896c4e56e47110a6ecdcd735e86540d1e1932570f8c74ceec4310cf0611be3359d29170b4eb2d4038e19c62ed70a474e6fe4ee3a067d935b51be749e6bb9cd89a5670ea62ade859cf5b16af4320d35b34bc35a7f348ad76685fa115fc4366107a641e986c4111ae3afafbe8bef4e8f3f972bfe5e04c745024815886d8b3b3a8bb137464c38e754a1711509960088168238df5a1bc1a62e9872bda49659a164ac81d6aa08f527d7e10e32cdae9b586bf5b5fa8b8b598ad6772104499458afbdd90058b08f38ccba0bd6b4811263c1249e9ab252c299afb2c50f730eedfc07f374914cb82a1a47fd062a32f3b76478d7b09b18f6383863368b0dd2fa7fc48742cfe2d5ff8cc19f536619af93d67a9a46b317975d759f20f244b42dad637474a21ab7003652922897d453d7de42425a73656ee0c429482570165270f1a1d86511bd751f1a420534c45a964bc623a4dba71f3a0030cefbf92c15114d8b9c8c58be7c0ec45b98e474a240ba6ef75500191d2aeb59486d2ec7e9c65bbb955cb66f2f4e2a91ca7804ecf2a711eb616a9645694b64682de7c1c443f310565892e241c83e6da6ca47b8b873997de37fb6576dec0af8a1b46f211fe22f445254b4b69a99c70b5ebd889effb57f301957db2855e4b235e3ed3411b8d7b61e3df043f42a8bb5b4592e1c6da143ec8ea3cf714173443cc4359ff4f4dc498dcd44cdc3d8f83ef4ca2028fddf09ac897db20e564bd0b77cd4c39517de1234a86b4f27788d1f51fe912c73297506295c12be3433584f359b67e2155c5ab60bf3d5fa9c31ec557670cffe83c9717ab7e34f337b41cb804203781ae025e7fbfa321e1647bb84bcf93cf8e87db0d0c28fd1c2a4dbefef3e47de8a9a490fe3b24cfc559a5524611a506f84928d36ecac2cd8df6c50f613badebbe805472ded3c5631301d4f9e5f532b941460fd984e4287991ae985133aee00b091748e5dd7a2cdb28ecb978aa7be531be2aa18e85cdf2b3ec0756b1022a45b49bbf9a7f6604ea2213030bae2cfa521613c0c9c0c626c503bcd398f98239ddede9c831e3606af5a683bce0a329c068e4368329143664826285cc195c59ac50d1d48d6b04373a480edd0b91977bcd87689e2e150acb804224cb0d6e188df515ce65ea921fd5e112a5ff397c7d4cc806248843d506de133f03fee07b544ac483f3e530e2ecbe91a84015c02a9086e50ee58dde83790510b3308b1144619a94b39c69d72f55d5a26c78bebe243c4a65c066d284fca1760d574125cf251a316e0102a5731c660a2309bd4c8a5d4ff615cb26a7944b230ed04dda44ac324fe5e6fdd674209e3ba65a2003e952acb33e7eb76083d0e88a8a0b19ee10b7ff3b51c9d4b010e5878d861a3805e884d0d9bc5a512393011bbf50af03da157c8b7fb5ccb22c0dfd46dc27f23f6f4d2fc03f18a2c5dc76793ff2dd7534c7015a75b5d6d1d2e2934b084cc27c6414bcdea6db9a6be8210000621d16957b2d1470674763d33011300eee22f93e1897a982e90348721fcd76e81da7c448e3a181abee9c4cf89eccc97454782829378e71112fe5b3d3bd015691e69bb0a10eb7c510983698e7c9a5ab171e541d1c6b2e4f2f36eafbf4603d5f3b51dab2ba40cc3d8b656044ad59e77c3e400c28e76a726334125d5cfae4b0810e83d1491be774fe0e3cb8a59e31d5484940fac75508ee63fde0f7754d590c4fb55f758311869e39503a01fed68b4ea0b482f6943d6285995ebcb273228d8281a27f639d2f4a2973a373a17bb06a89e2a6dbd421c3d19d552620dc22beed89e399149b6c2255c909764be9884bfa9c069bb499fdde4102434e342bb1183ffd5546c08043020b656a696058b596ee3e1b0b44a32e5edca55da2121b8ceafb1a3dd563d938080f3a8dcf25a88c752c49c55fe35aaf7064465473d8c3948ddb562e9c383f6dd807da325df18137b027522c5097c277fb524e04c4b34a09e00efc2b7210a0cbe59c04c8fed58e079d044e135b3064c15191b139875d09f3de2d378b6f6b310a62750fa1324c72c4376553a7d1f98519cf7825149b6fd1ba96ab3934bd56f3de351d581189032ef7438eb39095f48adf05bc91cd2ab42ade5ff836c805a9f3eead514d4ff1e9d76137b067e08f9379d9dbc7389144ed691bed9e0dccc6cf7966c83b6b90e8675084ed2d6bb63fcf839c2086fdbc9105cf387b6151169ad8b231f8c7c6f67587b1e38265f381d0acf7751341e16d05fc241d23cb7a613284fd86e3fd7e3f6b5a3aa46cc294863fbec5fc33b43f149243e95d40a99344f55633f78ebe2be8dcb50f8facf449dd681c1a8cf833fffc23e88fc7d6be53920d1252b6941b0966f24ae8a15e81a82fd911034b09828dbe9f44e3686bbb6ce37ff9f04f2a2b94ddb4d46117df79245f04ac5a98c13b73334b03fc04c0dd6c6580fc9c15b85a22ea7d6d7ead6120492e8833b4f7dc63c052952ef5d0f4e928dc91fe2d13e180529cdd9f9d7f4edff08ddbe90d02cb786815ffe4072aa1e3918ad8ec97b11620519f2e645c4a459e64bae842a8e4b4e635f5cf60331b0aa39dc328a6efa8deb94a62369a847c8a5d2f593e21e8b286a3b0b3275e147ba37fa12bbcff92ec3cce8ebc58da23120c17f452b4512d807a8a05634867b8b67b09dc02048ae84569099c3e349c4225c36baf90621b0b1df0bd9db401e66038ce02c77bb9e8bfa406d2bb07e43693e55812b2c8390788a2a4393613bd590a67e888ec197503c38a8b6f8e73145d0b74272676c881d225d2b75051f348cd41935fac214ced33949fa4825afe8121a2c0a39f47cc0a0ea63bb03ca4846b04c47f1466acddf58adcbaed384fc6d543bc6af7c7e930a821c40674eeec621aaa9e9f53e3338b78e34ae4a91313491dcd86ec22f50b804960156fbed58195209027de8278c47d88419c720b18dc7e9f69d4a9a176200ac9a86e7aa1baabbbaa9e886592e009c66090b6d73bae76339899507bcf78eada16233307fe2fc5f1b752a7364b5bd0bc5b395690e8e38fd97b2f35a7714e90968b1a972fb69ccfafb59e87588675fc355d2edbd1894a9cd1f5a5a7b099c4a67ba3786a0dc0bd9d6f65185a5fbcd22bc885b00708955ba3834e3a7257294131cf69c177f4d8adae58267d519e24d66f74bee11c5e0e0f43dbd4acdb04b4bb331d3f2b46abe363322dcc13a239eefe97be5383ec07ae02d420a27e2505a3ffe824bcf8a06e181bf047e72d957a2ad20162bcb03b0d600d733af95d9696aedec7aefed4e49b366e968412fd02b23d4620dce96e3f2236964ef336d7b21380325919b45767a31cad4bc24901b38d75ddaf90259e6724ab06bddf157b0cfa71158413bbb8f82b0eefd1ef2999466e13c90215aa41a3db5d3d96d4db54f134e88fcb6003dacdfb71742830fcfa3e4ee26a09a547828a8d0b2756d88f5db33cd60bc56db49cca6c97ec7b3669b450f13155ca817c9a9de149c962852f108e161bc62924b321e1a4a939e42784d660e61203580cd2534f466925a012a6bc1e86b875c73163c98c4c6f7ff6afd30b4e4b101a94026dee9f898dfd2baeeeb077a33c8165fa2fdd38086f1c4c085bd5a881ef4a0b8615b66b9d8327e57fdc0c8242a212f26ba3bc1313407787e12c42d39745158603049420c89080160380ae50e34e688badb3ccec11501e603f69ea6168d9ab02f51243e07b5709465403357ed9db2c968460a737020be78902dfbfefbd2acfe5870e291948cc9e5b13aedcb728573963f0867e621e1f540d218201c719fcb831f8887f23fa7f7094c4d5c8db253a87f5cc72de1fd016a87fe9bc7a73d43b8885beb6871e3e9e36df65cd9131620f92cfbd248ec529a43db89fef88e6b4db55e672bd06d34801a8a65cbea8eae335e452ed91e832d67566651850cf141dac4e448158abe3b0663f5d8269a54bee258d2c35bac30133b2b26f7fcb68570de5063021829ac5c515bfb221ae4c9a89b1e71dffd4bc0f5a0977b8cd802d1292022993dcc6ce94c2ef59de111a914da20f0d6837acc0dd8ce1441da2c09d61ed0e3b31c38551c284f235a7fc8c99ec97081cb862afe90da5fbda7d8bfb7f8b9eb9a49792d89608b462894017a3db79ae7b48510b8f9298b4e998d1deb1f90f7bdb71d2c874b77cfff35cdfe297924256a7317d8c036ff2c59f988d0bfad71a1ded1ba0e5925358d9010bc90b30b86f198dedd6f33afc7773d19e0af51d6bd61dce6cbcfa7a18524be8d89edff0542caa983daa6bea519c706c86831c4291fe94eb41bc4003f4fc94a023c9be844edacdb6a717bb1ab4d7daf8a15531d1ece75cb2dc78f8692f973d33c2918b69ef01125008e04e9a01ed751425071d8d83d589a6e7615660e73b1525edf7fe07be40ed2827df200350e781aebe2503480df057389bc2e6114c41cbc0cc96f572eff5a2ee64ae1efbcfbd5bf67f54e374dead7a47b539bbc6a6be3382097badf33d72da04d33f9995564ad60067f9203975e7c8c52a35941e3854a78d3c4985beaef0199ee3688563292b99296fef7e0270ba564f0c0527910b70128c76e13c10e2d38cd932322d5796fe01c4a3b01fae668367f36ba2b933f0d62d8ce67b69047cb0057a43bc60142d0a750a0736ab714c93e937eb126bc89da2260952df3c576286b742ebef1055f433ea037b0bc25d978127ce3b6eb146b33efda57f359618c43f6b3bf66ac6e10a46d2be028f757df589c094372c8042a4067fa6e2d4be7397282a2445a2351e9e30bb6d729af005e728750dd08ca2510ec0f6beb23867ce424cd9bd89f65aa069b52d4e59d91b6542f90f75239515e2366007dabd242836d894463a8532ad8fa92864079f2985388cddfdcf9579f87454b5d902db7bdf58652c827ed15efc988c6d90fd6ee5e786e643b99f534620166caebe0221be93e9d21e9a9c1a56e782b56ecb2a165dd31af55354e97d0b16a7ab1dc773bfd557063b1b38dc39a4a9fd079b7b02b38eefeab058c76d54f616fc72d216a48699f071e6df977368376335a3c6c19359454a3ffb4dbb7b75289d61103061fe62f13145e9661e6dd45a717c81692cd61aded8a943b284007682fdada2d018ce068eaac629aefeba8b89dc78449e6b95b95007c5f1999ea3288954f9e85198fcf56dabf1e819cabf1f75d595f89b46412b612ef5985d55ff35a12374125bfdc20f0473a8280084e7d2b6b4bc5809dc393d46bf54b8a92ceec715dfe1a6fca95faa1a00ed99ed8d199368eed184904812544230f7db56ce44e65bbe92f9d919f9c217be724b707a83292f1d055945ca7671b66cad861a5dbe11aeb27ea0ccd99ad340711146f3f002e9404618142877ed83bf0e2582843b62ecea530ae8f7686ccf16974892cda86c681ff96f7067b73c3cea02765423ab13ca2c4a3f848e9f97df56b16c0d082c46134bdb5e01c628fdf2d1bb6bce830f7eab9a79143108f9093be365a3b386888ebc861bf8a07c78abb9576a4a1d208672e2bc13c269e135a8fd82c8010cd80a5c785eaf021f9f8bc710f0b4ddbd748d64978bb81b33f8b43b3606f893ac2adaa795a91021e11e1b345dbe716520c0e7982061372571eccef638d51e32b16da30de66ad58a47136aada2e1cc6785f9e7be1fb49ecf098be36fe3c061809c19749e26edb7cf0c7720b4fb86b38298e796d27082f6e1dd2cc8dc03fe1ffea78d91d963bdfc12bf54677b061c9d021e44ce8c3753b659d6a83a8b4dec80571ffc9f08123c36db09fb9a0199abf537faef4e151e832587dcb0c016697206187bbdaee839d049df875678b891eb0ac3f265ecc29e05b06a0097516b196520fe0945a0ac7a10f79547b2f4b8ab6e0f2930560dde29fcc49be6fb628caca02b5e567f90035df0765fddc45e3d88b1aae0f2e5c073baaf33fb62f5bc7624ba42cdbee559958b3044e23ec04f1942c3c741fde80b7021e9051a3b1ca90096f70a2e8e30a4ee12ac86485fe62ac8706b0546bf79309d6aa66ec1971a60e327489424e6f5ab7c8033e4060fba5a05ef71c856ef1849912fb344542d2d97d7098e6b6081f8bd1c15d59f6d22e2751d4e44042b0b7063b7de27f86b3da528f1f23581319e077df7080d523eca225966a0a757a0bb096ac3eb9513bff9728ff75caaf0d7283501b15cb3b2dfbe43a354dd4bbc2493ff186389bbde4402853403c2616d7a5e167cc4430d1dc4ff6a6a1c1141c89a2a06227b724659ab7e8056988b44db47c3f064aec2895717a385e1119f7b29a3e3066e19191118d38b45f75d42bd22b7e555fa5617d6075cd5e85345af78e2eb47ed3c8dc6812cb9ad2c9224dcde2b430a52ce3f76dd8f1ba34ec7d1af93b0042b7ce01c1d430879faf17031752d01813d63a259c02a383b8ac4088cb957a38390d9d445b849a232ddaafd97632030f2597ba152e65b03321ef0f5cb04bb5fceb9de101bf038fd4399ad0ca25255c1b34159fcab31c9cadc0f832297c12faf03544d121f2830ea55772a79e3dcd4f6fcdd0ae4a3c3a98b4304e889009831427e8a67d4ec2720b1ac3699f51ca820159ca69a9ec99f9644b240314386daa9b51ca5097885cdc3f8e7c7a3a14ecac37a7e7eeb80b2dc36979acf6d666d34eb14debcf501d874bb0640264a47ab337c3d669ae77b5ef418987c43171dd4db9dc23d6628995e0eb1de879484856f2cfbba148227cc88ef2c37600846c1fdb18ecbe6d8bc714710afb8f6c057522636adee02fc61abf8aea39df9c3888222ade6d80b2dc49d9494a189808e8faae7e27ebcfb869a17968dd454e0ccdb264da190942f8615f76c720369794b1ddb6dfda562e4c7e030b459f37489acf346e29a44ffc03f0e4f385dbffbecdceb9b76cc9e8effd04eab6d464a96239e2b7c7bedd1c8e5da8039a76029a92ab1968c648418a0c8a0e5f580a9af992fa543374e0a5375e319e20ec90da158e10143be8c413fa9cec3fe1cf9c42a850907ad6247fd9bd0f5293b91bcbba526cf46eac9661043c17ed000642c047595c703759efe10d6856136be49ff58a75c77fb8f5eb25a28159018a0012f9ce18f22934a711503be46a0976ff22a44aeccd3ed52249f18905538276f49411e407f56fa61371a7766f9e5e5b32d88311743030f38f57b82061f6dafb95b1a9bc6867d7d610c0f004812c02da6ba5239758e75818d44da9ea0b1223cd88c8759c333fa02e73e8531330f4b38cb35a4d437a29e1c7a561af1f2971820ced0bcb4097c5b80b6966ba0d80b77906a48d2d389fc4da7c4a1e33fcc5530406df5c99febac426f2ed4530f8a01cf502481bd460f9f64318cd5e97a3516efd9fae82563ba0f1d4950bca7fe730cd765b5f659733089fe4219b7e8db597b805d6aa516ea8d4149bd1c18ef0a706f03c15ead131c8929aed50cb1e54e5575d8b611e7e31d3a22e09d9baddef06056f2bbc407d37de2661e62f39597b9ea2bcd27e55f4c9e134b9ac251af2f1c52ce2eb98ec4e60ee633c3d2dce8e009a94ae435a5f98e68194f334d5ef8c40e3a86696cb3c9ed96c36d7d45572fd49b74d007c3d6957838c372675221b79642eaec87e4d1cdfea3f5769775682e2de7854079eef2a6eb8c8a95286d35654b4add1c6e716a257621cbc9a7a30242f28f3f8165b60b513b008d5edfefe5366969ed467d3d1384bb5f489d7fc41585b7aa598b10c41dffacfe821a66e52e7d3d91643bc053916ef27fc578f36a3e71d1d9c6acb5aa6c8f0228185e0d623ab993c42e0e1d1859989c670914433ed23c81e42008efa1534cc8b89822e6025301a3a188aea7a3bcb74c1631bed145f5040bc08f337c55f4586e7a95e70a985da8086555c118e500fc369c6b90774a7461f24bab6fec903598494c54c245b23e67d29e0c4981d92d6a3641664b18fb4b89d72a2a24db5f1641b7a1672f1fd47a97062045eb39cc5e8cd1f3b2fef699eadf108eb1b88a9bf1c29498383cb13c130dfbe6dea6f4b1558ed8c258430e40bd8cff090c404d953c74ecf40b62c1b34a45aee4ca7899b4d1b8d5b1add7fc25308e727f57c6e96be3064f89522e8421ad998724128a647843dee2e400286660ed30e6e448d71f557524ba5a9a954d8c3f9168bbae29772395a77120939214d4a01d7e22c2fb3f120eb91b862c6628f5fb1e72a492ac4d5e018bd8c1620c360a64a4cca48b02895264f2863258e91a3722bca27098b38bc5d0f68279a940e77a7d90abe293614e07433cdb4121c0db3559132ac6f0a32e293d3d5aede2666c978420cf4fa2a4080e474485eb5e277c2db1d16d0cbc2a5dde6dbacf3d36e885d9c8c418cf9f1f068cae493d5ffd113e9ba4e48882b3106caeb7eab8de271a29213a5aa895d20795a4b19495ee1e052e1e702a1df9445b328c7016d54f743bae491c434c901d7ce14774d4d54c29ecf80b91cd7070040957bb5a05db022d425ee755d42e2e18a30b84c4e6e18d0a74332316f6c93c7905212bf6abc016d577546858e4d87ccc9d113cd9203d6f2999fdb6ac1825d5421d93abb87bde6f5be8fc9332cb2f49aa127518b0d2237e24d59894c9203110681eb70cc1d9e5cb38beedd2d2b137e7ac4ce7354ef26f04060a7610f2b9edaf08193ba56baf11dad51cced86083e838df9bbca2b5221bc4cacb91258d947f5664271f87867a1dbd76c1188405941cef805e90a94510dfa2661713772e13f972a12412df2cec6e7f357da9bb644e59974e3e2f38de65506bee76a57f6b9403fb7cf673e6ab346d95709286b98a689fc7c028de4beeb214bb9287490035daa56a3aa573de7364b5714323ae5854e6f80016c28173cf36b5d5a80cb240385cca5ac6d2b01cb51ad372a09f46c939be76f7922a81afa62d6dcc152deebbcfc5ecd9215c7a55c05a84d13164b5726349f3e4ac55ba09da9d665508d89082324802d79b3d613cf6ea1b040aa162eca8bc0dd680d47b1e7b8ed28c3a838afb781eee454658f8971124d26711e98c02817468dedfd3a16e2765468609652477eee984afe4ec87c8f42f5dcc6c6ef8147cd3cfde689fccdf22545262a82962f8267f3f77df7ba3cc96975d88b369a50df2906c01f90706e7a23c04f514648d27370c04c547f8423cbbccd06b7985bdd3d01e6f4422bfdd456d572ae27c751eea8a6f05d4e6a60518624b7af01b28a6ba9a718813b6054750c2fca3602a9ef9044e3b69aca62cc907b06dbaebfdd0da5ec0fbf516b06c5a97263365933f50d36baa92c7143f983ceac0c2aa2d005f1cc0237e742bc4f69b1fa9add3051ef63bc2c432f595fc22dbb13cdebc231f15171da0ab001ef98fe59d18e83bde14ad1f97b2a24778290ecb9f2824c06f7a032883b2a39da0227cdcd6c625d783341d0df72f1deb7357d49b81680853249d75f06ec2a6bcda1e07c3821a3d702fd707a28c615df0f85aaff66a90b3f2ee9de9717c88bf3a1d2581678d3c6455f34950640ea365100372b27117b0c518f1793d6b7ece6d36d0e33f1fa7f3632e2f93d527b334bfdfd6ee8a4864bf90b9e3b1b2870a33265d93c742e9dbae831af54a3cfe4ab7fcec2737430e3b77f3c9de6b0916fee06ecf50294c08705488229cf82cf47b4abcbe44e0be06c29e86cf130e46ff2e9da27af19717eddfdeb24daeafec6f75ad9a00033aded465ebb2b25697b7e6c0588b17d65be8124473ad94d9bbbeb861e4f6e08f429ed5a37a653062ff075db0d9af5dae70317435b7b6b67c82cb0bda802967282be2fa17829b7cc5d3c351e533bb1d4b80b4709bb9e600a38d81481fda51b999cb92f224a28a5986052b0b5cd78e19d8a21cd75672ad60af93ca54ebabad1ceea07e3c03bf75803c82b8fa6548dfc9d229e92d6c3740e890576965bc098fa4fcd8105f0627d9f2707b02a3e110a7fecce2fda5f4ca60f778fdb237b528cb51f637b0d4b149e7be3f42e89de256d318f37430871f6cdebcd0157b69775c7f0f405d216b907cf85c5df0bf41d9f5cd0323d5e148c5b2e04c2c1304d3521c5677850e3a929fc6e8da3392ac3e60a4852426032835d958aa98bceb6e87f1b8d1b0426f3ea4a22db2c60c2829e47de7eced1c5222bed01d0378e429595265f8dfd7ef9d16bf6047bee6d2647ac792c0b75f369fd14e38e10c58002e53729f665ede172d35b3f99374b092b5ae24e93407876063818199b3841afdb6b1e11fc5d599b158b9e7a56bff7d1f863be388846be564073d74c74640932f74e8a89bc94c87e0c306e763e40ab4909564c2e4b165b4162d313bc0ee561cfe14884806d657d6d35ceb887d2cc94ebd806b9e19c57d8198fbdbd4a004671e2b3195ecd5a1f6c2f379b5900d7349d7c9f2f6ea4b7df311c0ea8135d59a7d153e6d5e3513ccb0bd7b9b823fe7a1abad0bb1da179b7272b3cfc4ad31ddea704565a7b807051ec7d540b9e2ffb3770ce1c9baabdebb9e694f0faf715213c5997b4fcd2f0486e8c21f85eb93117134acbd01727881e89d59b0e0367f7eb8d4bce02eb218e6790058ebb66a6cb83bde8a29a4b1cd776e7155ad50714c14548a7db712d7280792fed323078721e50c2695a4ea18ca646153eb25418e519b692369a9ca16275db65737bf64ab5121b37b7d16102e87204aafe710611e28650e10a25ec7f5693f50ad0005031f070e8a6e13b1f8661df5c5519f93ac170abf71ece2e01129371125105cca6dff4db8c0b81a11ea6084c2128d54423a916e429c21ec241b462576e014ca107e4161bbfa1b567bf52e4f429b590e8a677fe17f1e179fc5653736a3d3f19fd5600d3193e1566a401fad9dde073ab4ebe28669d417cf0505bc2b311dc43e93526e2e90fe90a0e72e44aa28513daaa73aca04d65c66bcfe2009dedbd6fa9ea7934a62593bdedb768691d9bb82b3376d15618d5bf79e82c1205bea771d468c6ac9bd9d71aaad73cc5ce1e2065dbc8406c36fe393302a0155333abd4801385295a97c9db1a63388c0bc28ee73da117d89c4102f52c0a2f1482e4cf5b2aafcf498830712df421fad7fabc4fb7ed3fb5f301b4152f2bc668f5e1f5157823a82c7d9eaef140680620afe090ae94764ad3947c43503ae7c84939b5f4db2d5342edbefaecf76f64c49946fb5217292c6d3f37acf2aacd4ae0345ba09efa76886763d44abd56652638a538f43ac4347d33c7364f747b8563ef727fec6d9e4f84ebb6ce4e5cedaef45fd06fcd294ebb1ecd966689258225c9869ed464c0892d9762c44c3ef187f481b57ea637caf12fb9804bb09771027128971702efb01741f118b36a2141e2af8e107fba258cc0c8c4fc6f5d22a74c88ba3ed7352f0bd0905b9441b8aba00a6d7695ce5b52d64c69ca0cad1d2f4ce11cfdeb768c16a81a493d05a73fd0a0dc66405ae15c5bb039b4920b81eb221c8124f6d623c65d1d05a5610e07de6579e8d4563a0bad4a605ecd3d0fc8bb963b5634985017a05f14ef4eeb28db91a6641b39ad8914cc33794067d2f521ed36eb84b44cc41abc482a7ecc1150b9ab37e3f2b9792ff65b3f95670ad5b49384f15fbe18cc3b1f131f4e4cf241fa6c9fcf95edfd88bc45b5d5b5f4fc45b848296f23c35fecdffc3252e23f583d6a48ef656bb53983b18832d7a729a308292660146878158f690c34337511142a7e185cf7ba96febee9f5cb0e9cac4c0c0c4459d8d692a59cdd80d61d2e24237612ff973a971c128b7563d70b38485c78724c33763acb7b9fd919b22c829260a713b2eff62c7457d6cc592f98335b490ef5520dae891507cb4c402c8ff1b8347bc5f5f2a82334e60a15c02e1b8a2d619d7dcb7d2fc6fbf1521c3acd4c1a48cd9028ff3f86feadf12848f3cc18ff1f7d6375a846fdae8ee355d1f9c19a7f49d6cc6832a7f362e93bc53ab3eaa70955ab5976faaa03777b930b68fa3bb1eb3099cbd98ff0d959171394f5b91080c210b08989c7d6ed362a24d1dcee8b76dedc4a9a784826a9cfe046e28ce19660f54bf003cbde8ff13145e7d18ee0376c65c38f5be68892a5fcaa057258885e7827e6e480794f4e028c371a73a0eb51e0c524fd873b72ba695ecb435fbeed884b62b5c4b9ab725f796697adb78cd7220dc521726392de0fa8302376a75519dd716d1174900b8f6c5d71513221da62708f418dac1ff116238962eaa471e912df4ad2a1148c202c917b89bfe4031af34cf44f59f8ead6fd7186a5507f9a3b0b8b94a2bf50dd0e3db05368ba3f3410d361e3a043650ecc017e233823bdcd29fc69af37c77802bb6fd1d5d1f7a3570a32f7b0a56a643ff91ed415b35c0a89b6b03bf86a9f5ab7653e920b72fb967afb1f5de9f92d9c85a2b18255336eace563dd65c7e3395fde3c8e121c6c6446ca8491505b95605ab8f31aaa7be936134857086a501ab8cfc85867425f50a1190afc3c246231f3e1be97a89923dc9de1dd6b363d73869aadc75c0c7a68250575492386babdc1ea84a8a04df958c4414a65ae0359b9ef604361fa623bba5b7a3bcb3991fddafd4f18acbde29165b05c98ca38ee55718fbed5eb46099ec66f5a89b9bfa19424db6c45bff3d44647db202a9457bc479f918630a75377191c26f9600b5f5cf15363420df695193a1eb1aa9c4ed813a4639cf1dc66e12995bf73847ea62457f76a9fa2970025e60d013c89d1030f7ea40a79faeaee15ed79aa06f6ac62785bb823503d70992f15fb0b1978db88cfaf21d071d8a96842cad64219dc36f99c03d80b2a548de34148eda4abaa7a4923ed499d37f25f1d9dc784fe18f8789c664d78b7bcbfa8ad12947dcd311465b22c7d338d6aad1e32b6cd33133970d65f1c4092c4beb2b882373eeccded3e0a5d5b86e850e53400fc2b6fc6570b9adb2bb5f4337e334285117ab18c3efaf9dea03476a324f97fc35321618d3eb7346a59082586d848c675e911d8445a510272617f0a6b066d4135223435712510f16910c876fd5220c8c54ec834c0aa9408cb8016a8ca9a9230fcb7269849b43f9843969df7e0e3b73f167e5f0b8d8580caafec33655594dbb3a0cf8f1238780bbb910f277861bdae963d6046e095527a5cd88ed14c4b2875edbdc5bed14d90a458314a9c8290fc39b6d625211c3ec3609d216736fe4b5b5b67e3c5e0a0b294aad508f4a7dffd8e6e333d2bd34c7802217a1c068d3213e961c07550c96ecf341f36e213dd0481baad8d20838d9579a7204ee855cf668e42249b2317a5ea1753e854f30fbebaa93b2afb731698b1b61586f867d862728ef5139aa8b956169a22cdbc927d9115a48be3c3ef444f93274183802091fb2b2bf5d84e116ef3a16a40dbea9a531f415ae90741f77f6516e5f5d6fde5f7aaef25f1f3c260547242b0902f38b736ce04e24f9ad6c4856c67714512fdce1b1cd6561d73bcfcbf0253055fa8590f3354382885795d6dd4e7b75aaa977cec0a9a254ef46d86c1e1bb76cfc9eeef467ccdad38e88d72a6a1b2a3da44aaeb86e481cd99f3c537af372f4f282a310f53f611db687c6fd64be9a2115fccb229eb116b610010e576cbd3139a7e9258a7202578ade77dfdf515414c74404fb4a3c4d6a8b6a9df3c90590544175c2ffbfa970a2e23e1aa24615ea777d457064621a5cd4b4227d1924f29a88dc350c9853c50e35cd11b04e83c0c6d6b1193a8a20cf7f2d2fe0477bb0b9baf71bcb37b181cfb3c9c7e4a9476c416451f4dec13085fe5e72b0173b057ad50ae3978b7339037f058da5309d19d1fc88700d0abcd8f3418ba2cc03990a7c362d8a2367d18993df7e19ff6b10fd0b535b209a4c672a206c6da4a23984549bdbe2059e605ced92f5b620521daa0d4503f34060cf052c8a830d4121a9a53bb306bb6ab33fa116a046d20b409096496b0712f6d51f1f515e96b3fdf064ecdea3fdc67e9b1e65ac63017133bb169dca8f198d342b415adcf73876a1d31fc78f48d620be50ae9fff2d3fb816fe55f93146720d7abe5465c08823aa8ebe752198b3898c44d8fc7366b5fa68ef08628a5c07f415c3e0e245b2ba9e838732f03fc83f154969f9706f365bbbc3a1faa167a3a14255ff1bfb9b0e9efda5b3292433a1665a6492624122a3efeb134e06de8ad0222909ff64dca737888a0d04a173b2ffbdf26637c0b4f1c3f40082ac9bc0d7627152ad637b078a32da1d829788f7ebdac6426700f53b1741fa8750a5c35d3441bbfd25bcda4c96f3351f8c6bc4c9bfbf2f2f812c4ac1ba1132387c03ae8c583fbaa3dfb7211b808ce8d4a9eeaa4400fdf89e07904dc3ce829837f0619d07a75a69abe634acb55c9527590d9f6f1e176aec90d22ad6df41605978db31f724053ea8dc310d54897ada1d692601d7382beec01c5a71e412899306c475e5beb1695471bb021fa63f2465d7c5edf87605c45a29d800d41d534794849cb88b9f7282f408312cc988f31c17c1fbfdeeb0d22fdef6b2a70a92d1ed1b28a8afc473d41d33ebe637b484ad9f77f0bd2a541692e00f5f6fb1b4ffd97d95b94042bb70ef13b43d2f048d90b7a66b01909f2f7ff3c47ea53f30c809a427452a73e9a448b7f1f3d8ed4ffeb499726b8b07aa505719bb3ce2b01b54bb332762a4ae703d7ec2a9c8fc928b76e8b7a5fff3bf0b84183f9ea4cc909a0fa7fb9f970179370b719c9f8bac8eb70850e0e42cfda9de48da3f0d1def799f9ce3daf90834e0cef146fdf1d77235b78e5b1c5e7d5d3f75afee2d00dd9580c7069b0a189c3540d898389422fdfdeb76770d7d886c763713f7b69c34947f1ea6792009ebc8f2f7886f61e0e09d9b79046b06f227376f1d2b068109850b52b08172484ad17e40ba3a279a6d46059d370e55efa54f3af687455a68fd8bc570894c204f711b3cd47ed33e9675aceaba8a2509806357d05117c08c9d46d0a0f1d46e99218a9f75313f28c602c4eb774a6732c2ef7f0d448ec2d9381432b2b737c07cd5a755ee01cc3204cc462351cfaecb10e55dfeb37cf10ba5eab8e5afaa0522812f687c3c6a64e60ed403a0f84dfa8224bccc07002af03c061afecbb7593148d9a0cb4da32faf04e3194393f27e8db90d4299c4bbedcd67996b1c3df729155490a2ee9c8fdaddbe6d822a67bcd3a63b93dfd5e1c9c1ea6191a10fe76d218044527b05794c55804d29a06df7d30ecabe1fac0cc0f46feba125b7b03fd7114f11cbc77d8cb5966df94f6082d9ec812c50f7c3834454cf50ec72fb45f64ddd7034929ae9a09c71c0d3de6cae837eb0bde1505900038dad9d6d9f24e146f4feb367363e5cb54e5cbb81dbc457da72a7a0e5a067a4d8afd7cd8870085d9105d99dfba4e17ceef410bc5ee2e9cca9a7ee46d1059feb86515296a0ca959b681eff181e01089016fcfe8d481f3850516c7ff1321aaf07d52722a881df995933f4850553494","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
