<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe6618c489c2eab96d094aef8b049a4f420b00ce545915f20c79a218ddb5b4620b8b0126356b60400525478b25ad57bcb9f65b49e0581c4e6e44a5801afc33b5c7388410079b977cc63ad7fd0fcf105c71e42e6114eb6a9ee43450856f672bc83a33033e16cb26aadbc3bcf6016d830a9da55c66b659d75062d12480b70879c1d97c09cf893f48652a26f4cde18fdde8ebf41eed99fbf20746ead2fd36c0812dd7bc431408469783462af07ef657cdab0efd379c208e4f42777af0336a3a6d7af1a0decc2f6e71b3aa10721296c18efbd12d5f61329c71fbe11c8edd55dc7d6882a0df79e7fb799141b649748e88bf8d2177f177a699c31ea6c73273b79ad0cb49aec378af352baaca269af5372ff7cfae493fff98b229f727ae481f43b362581b9a3388929b894a1ac67e5b64fdc7e5b93c0e38b240250cf09e5d63eba544d51bb097c0c5be2fc78ff8c75075defc49d7b326b4bea73c68e475c5bafaf34ae2191972cb011a3197fd6cf7ec322461d832c2cfd533e4bed364139a20e5af2e05a8872ab710e7bf25ed4491be75a1f31290d4e55a1e34d8c20e35d7d4a0bb5d8d5c3878b2b1f5d5e898dc8be66c9bdc9252e33ceb2a755962f7d444363c232bdaaf96d27ee552a779b5bc0f5edf7dc18fe52537d22b964690c95e515bf47ae414a73fe47d97ad7c2860f8eca62b8677713ba51fd03a2e955ab4c097cc4d5d53d9c1e936a582363d1a2f6bb506bc993f5e6963584576f3bdd4b20622fb15f3bde254cdcab4c01250306d2f29d2180bb64d1272adfd7bd3708fd5200c15bd29e2ff7d06b73695826f696b7f756557325fe5c6dfbc9d6d357017c5a6af9ea737b801a5a786e2ac6915d426128b4ad641f9d3532736d8cb1b5e7662c9e969f260ec50efe0ef0ced5464ebcaa68107e7993d7969aa44322663977b14e6454a31c891a9eafbe9fd0177e747369b322256ebc2d5d7f7f2c4b3e75ada37603eafafb8726f4d3ce86666cb32ba3db6429cf10c871d8d72459a0b74b22a7c42be71b25151a4518f9e9e837043642ec88307a261a69c96c27277ff5226c8237a826e0d9c19137ae9bb9561ac697ce543bbe4232c0863d509b03e02c2ba6602b30046d2b4e5443c18512c29a00b2024b23fc0ca296209da5668fb2c57b0c03cfe1c589ba7fdfcc0d019eccdc99d6bbc5312f86dda14d4aece4463146151373daf46f534a0741d7c4f9c467b6435e7d1a8ac57901fe27040897c0b05a10113900f43290df1da73883af763db4b7ff61a6d5f071f5a8a44fe4ee48e77c078c914768888fa2c35848a89754ce780809fa18a5f82d90a5d68f551ff558b6e923c4d2a98d6b1ae7c220e289af4076faf6c515e751626453f08266ca0dd637a9878e7db6711a030651ba42a7275741d5726be069a72c226b9f03c66fdfd8802582298ecc32c96d98de77c01420efaec530e1136f48fec41428c3371f2e60c50691a01daa838b6fb4f74921dced7a5a02d3fca3da49de06d6a900ad2cd75827b0750a98dc4e3539fc7ae0f82a698438f400c3175da7018369bf19bb70cb818d468e43c56b7d7524fa35ba0c62fcf78e9a422eb427b4008e0f98beaf944a74dc5d64c7070908e290350a6e8f089e558109d73e3b672fb458cc291d8a66148473e79de8a33af21ecdefdf2394083e5dba3b8f6b0b464e52cc1f58a211cc45c4f159d024e38355b1e2a40a2ed2919801c9fdced50abde4ef4a3a6f55eaee02f37a04d818f1759b12d573df2964ff854b6d4defbdfa2c61b4f272432e8894a174d779a06f67016da206793dc7b9ffb83126152fff7ee974e99a536b581ae7e90495288e00ad9abaff478cf7140f1f9d1c5810ed8c7eba9840630f5add545a1683c75efeec1d8d3e17594e5235a7b77776f69fc81d75828f57875ee5810cf54812b65620aa1426e190b660ba9d6acef17ad21fe5e5f6efc65984f808db85620082eba36005dbd74b4e73693df86d9ee2a1985d2d46e4dee1866b0f86d08c8aadee9860e93de0b598552d49cabac169208d0a1a2d91d988d4e192cb529a41b9f49b288ffb26a15563eb16453c42e4f4b5a41060753204ef79eae0a56ddd69d2e23498688e19a97eca79666f8eab676c803e9824de0963618373c326e70b0af08409fde70f8da63fed8d707c55e115628aa1286e2008305f89f8e87d340b7950e6aa903dd0430307131b69c0778134a55d055f8d0694c41d41eaa19aaa97ba57075e6bed899edfaef2a6e2790682b3d95495b800b09f235fc8d79f3999a9bda952e9191f6c1504746b22d746cfc23dd012cc0cc6674e7280eea894e8d168c6c2c1bf8f0cd055f68740e77e200ba01b151a6f9cc924f55400732bacd28519450c438b82c9300eec9b7579b1d5acae6243b9ec8df876576f673faceca86fa12baf53f66a4518ef37fdaa484ef19bee37c2cf94f53b6a37de28a0364a03f1dffc828e7577c38b4025ada422968c47dff7b34a6c925da700fcee9d511e522ca1af9155e1d6ddcbc19c96e8ec26db4084651e161a7ffbb08bdcee29eb9ed98a87469bcedcfc2d03f8717c027ae943968f5d358359e7097f728de327e570f391e7f8c37b856e26f781a8cdeacf5a113135825025d5f9322a6253ba1f294f0081f4422e0e37eeba1857f4ef1897497add905b464d89f070639d42d9548e077137e5641134336aef72acdd30bf631476ffb8c12f40f56e28f967e3244020fa2c7b3ae3d2df2e5f3fc8db3ad610ca35df6e610db7f5bd07c3f933f24e5bb1f48e7cd8901cf85bc1937690dd5b22cb087c59c08ad55c3aa2e34dd9f18975170969bbfbe449f8e94e9f553b599887f831095f3a144bcb01f9ec7c74c8f5d34b34a0ab34017827d0c404540e741e83b9fb31684974f600d7eb90741b2366ba5936d3b330c2ae9fdb8c726f89b45d99ddcfbb3319fa79cbb43121d9f47b0c6395a1f093b68ac333612ad5cc26202399a55f4b988fb77aa2746fb7720e59f9fc5fa2dd79dceebf5c5b06b588ce2673fbde4466edcb46ccaa9165ff48557341c921ea7bdd754a1adede91aaa42599704d414c0731f67d8770807aa80187fe5bbe76713f38cafb58d8eb03f3d50b69d05dbf2cd75370831e231fb8b49c88766daaa48340187d8b4c7ddbd8158906228a9dadbc00d813609a6a460ab33bc3aa3ff991dd8ee070d7dbeede9743984abeb869e25b1470a9bbc240bd73cc5344d599d80241fd0100e6c8958cc454d8fc02c02a8f7d0e000dadc65d1d0b806accb0cb0d5acf5821c65c7258c8aad32aaca8f04c600af615bda8deb458294c05dea90aaaeab2113a00a2c4430c2e8843973c2d26cd8377d058704289507d0c6da51bcbea657ab8ff37046b3978141fb1832810e0becbc786d43bc35919135a6595dd6f314ce2d51ee9ca96cac919bb7ba0c42f64d0080e61d43e9d7d20bb144881c361febfab5f37de8d693d179e7969b9bc627882166a48283cc52e57e841a0b8442d62e1fe7d3f5530d42e1c55087aa56514094f0e4623321334800d8a477479c0a0994e84761608c990d078878aafd7f06f509673b5dec7dbaf8a5384544e4dd9286a5a78c5db71cf6ae0aa64443728728b3b87314b0f616c788c8853d2f07a5c0121ac4c1db24b0348ad1731d17c8b10687ab025ea23a16005d8eca4e2849818e3604dadbd119584caebdde7148536827c5166756769390549953fad0eb84f063de0875500f20e74c224459ca1c4c14a4336b9b1143abe910ddbe1b4701c1a9f62628cc2d3db09b1300e4d7c4fcec6358e632df993afd100f1a673739bc0035bac04f035b0ca781838d0e00c05a72af68bbf9e15cf31fa6215d1d314823132233c5549e98cf063f4b5c48a6dbd3f9b98e63e637312201cf40fd4db3ba9c9e39a44934738304200795a394adfd2a72f08fc989b8e8271697c8ab4a484ed3e56b4af9a174c453016c5ded92928ae16271ed4927d5d8d6e47f85d438cb31e100063546b140836331b8ecebe5a8025748a4e3ed9c371fc2a312be8fb7eb02d68e6994bad6dc9af1b10634b166efb3147a5c0e2139d3d89b35665fbdcaf98120ff1f9d023a16dd6dd537ced440e68957595343348c40f5044cc1aa96c1d60b1c8a4b03d6e9c07431f9433b9b13379441bda38cfa34f40550254366981bf20bc9bdaa623e934c6bf24c42e0f1ab63a3ba08e196921f0e0d522aa7f5b63bd013e78fb35e8393a4531dd11c11e7d732956b63b2cab964e1114ae9235b28b868a264310ffb1a00e6e319af93c6927f8491468baaed5c87afe45b54ac34d050d814531326e2816c84b4df4c76805cbb93634cdff663e8d1af652ebbbce09b47460755f60f573be7e36bb122515adb7ade83a7eff08c1a1026d94cb86c2d5abf3ca6f62dcb617e94cb0e7749176824681bf675b37743b823c76c150a5f959257946c0df408d7999994762d4e26029b8872a93c9d54e4f0175edab9501abc4ce01db1a1a476bdf3b44d0ab940f8c660c0f91019185dee2bf3754441dcfa518a8620f724d9fce6fa7cc3fdaf61fb88400af40646e8dfe5b635004e5f30c04048eac679ca58534114c4341670002ec83d1696926a04e9694af3e54f316221d30422788255c864bc2c1d9ea98b8cf5911b11e3c51e27c109b5fff567c8ef49c707f5ce103dd2601a0c6e3ed9938129c03599be6dc994b963861f01e7719f2365cb9f30fd75f16f25d5233ab6c2d19665a3eabaa4c9be243e6f733cac6f1a9480c7275afa45d75a1c9ba5955af6847019fc68aeb4f6ed2d24ba346dc1422cf0c3d18948dd89a8d412775f3e14eda3bb2f3e29ce4d8e9640f5ddf18fa5afeb1312810082914115e545e2ada7489c61f9bfd0a0e8a709cf3b817d68a34e27de4201455c48a1136130b5638b4d4b180ebc1452c6b5df6d1dd6566aa4b3af6930be645a48fc0d1a5d6e763bbce26df055ae74c7905db922a2f2a417d0dee5d83dd6230e3e2cbe8859aa0089ee5420b2c37e4043bef58bd40edf0922cd7ada105ee58c45916625a8c25860e080a24ec04927b56eb1dab6703965385cebda695f5421a70e7365534dc127c53855e4b3ebde4e13d8ba8ebe368cd593db3b1f77df9c254d7b0bff178f7f53551f127876560f7a59ce34363071f79bf17a60a2842a086af915eee633b3bb993592ed0c79c1e237f666da5b3657fcde3d1d82b009762b666162c265c743a23981fde39d2cea3bb57c6ace902ef8f87974b14ebf0676c318bfe573aa0e745472439454c0a6cd4253d3fc38ce71473760d39708bc5d694f99cc8002af81f36a0cf33f15546f3806c1714fcfe3b244149e00ba3709a906820c38e5f67b96b58c8e3311238ac8779897d45e7718bba57f18ba9a8e1a1ac8844b1a8587dfcca2f311f9fdd8b021bc1c8bcdb9551c819dac596a4a1dbe9e8210999cd8e7f65db0bc006e26a4d305f82a51de7ebaf3c613fdd21c86c9bb1ade2b44ebef808a6436e1692775b58bec18d90e2355345e943c7e749def8b1a12c6f4893ffc92e3cf5daf056e06deb2afcd14c525abbef56141c1e6645adecda362028550d7f2e53700bf105bf23243b920dfbfcaa13aaba7a29f467d1fd413b33e4d1dff89f6b078344fc31cb49d5a3b2fdf0258f0e3ec29ce42ffc5233f2524482c96b0afa0d935dd5377a143240f9ac78c2944f1ff4458754737df0d4b03f4c6ef76b904172cc6c8e945773c2c5e21b992d9d9e5582489d7e78a44521e907294f6c5a7e86fb69f1113242678ae98db52753e63af1305f394bbcd236a1dc9211b07d797d84e35bb05ac59bd7faec3a5d2e5cc70e0f64441bfa909f5ecd73ad17c08e375690f8c7a9a010c1c9d3c3c2d7785be18d5391fd3a7982442e18b1c2ce10c36cfcb048d6379c0b8ab19ee331cf8ce6366dae45830137bf9c66972fdf999bec9d4ed7e572ba205b467a6e53c1e1b2914108ea0204afee04a6b407ec687542c3c9d182a191bde092e7a20090cfcb19e28931586815c15daa27a67910d83f77facbb717ecbeb7d93bdc5b903d393feca34aa93327c85ca0081bf873e61ea4b43a59370aca9a50151fb8e9d2beb4abde955fc35d793a1159abbcaaa36a41f48eeb2ef7afa17e4bf36c571ad02724a6b57ad3f524e282d4820bf51c01990a41a5fa43191233582a1eaf576e730d87dea7805eb670e9de565c1db79f9eb6bc18bd06a0b267fb9856f1007a98b51086cae3b3707e920e218acefde086da5ec0ac18166ed3bf36110655901cc6803a5671d7555889e6a6542ed3a9fb5d5849bd86ebf801dcc415c49613e3b2fae40b3d8c48872bca535545246c72b0333632e3492421081567401b2ad74c8e05e881a8468b16d4e725c66ea0757b08302ec4949233107e4e5071cb9e24db42eb146d87a4a93193067985906f1ce50231edd0df811cbe73168c1a0f428d004d12abb8d2f39e9490d65d04a8604fae3c3f2d589928039a9e0499fb0f14c5199342ea392275dde2a8c7d5149bd84ee32e2e5d866927df82ca1c60f0f4b9cd358a07f306c095879bb27fde5f303701eb6a480b758c82b65cb593762f455571a1609dafc773507252fcedb03f501cb1cbe21a278e3f646c31fa87302a5fa0dba1df792bbab5db55e1ee97cd6a911ac714ba16eb7bd598a98307e756601fc32cdd8b6069abdecde8052a6857058ff8b4849850beec98c6d9ab823d01795bdad5aa925b1bf75a2e7876077bc5921f2f15558cd037ec3956b668560fd430eae7a8bcd60c99dc62ebdc3c55cb6b126ae4f03271f03a0d03fe5a03fbfc8261f6796729823a41e5dd60b5274acaed0a60cf9ed050b476f2be8e53ee7a8f84bdc2df24504d2fe3a9baa076f55270ecd9b13667dbedd1d6a0b404aadf5e047277ec2902430070fd604e37cd8e2af8964260758f7ca100e9d262ebd65d6e833fb42b05ae545b9cc331ea547d91712169dac17e02bbc7b9fff0ad66e31cdf45af734e893b58f8e401c3e3a7bdfe17009ff76fc09ca41b88c69778cdbe40cba0ede6544fef2794419628bbbf3e682b73797139ab3f34ccc725a66704ffdd8d6a1462d15071876d93b88a15b408acd7961ae0f21584618dab11aea881c675f41308708864148e3f8654bb39275fb06a49243675b6a3be6da882740f7406d2371adabbef7276daafaa9c71e4ab7e609aa0a040646ae065f09f1a4884aa458a2d164b62ce2c313a9d9794d13305c785d0879c9bdc1e4210285d0176ceaddd6bb40aa76cf71a93d7405eea5bdd83ba60daa9484521c03ad542743f54104fc328b131fa9d35d7daea6a0f53e946e408c2eda1db3dfab4c0b58a71355da493521909768e6c891bc6eecc5320ea0c35023e6a8ac9af45b0f457a9e86d1213fce3adeab5b4f333adcf099262e513c29982dc413073ac20b724b49372fe89f90c999a37353b28b3c56ef08a074742a8fb573db14a4bf2721f284ec90277db776f57fe025d6d586f8af1e437f419cbb427932d7a5a7ab1fa90e56948c26e03274c3b8b61793bcb86d1b50cecf519eefffd1c53dcfa8e71690852e4a9cf78d152eea7fb62f3a971ee0ccb09019cc90f9eb7ccd06100d20e950e27c0d326e309f12d1c2493ae72e39685883273cd562d8a88b9939d9a2961128c9de8ee02fae6190435b7d56e8d1436922f01c31f210b99f1789a04898d7aad1f86c170d894095b1de31b126de145467cb9e2cf09153382aa408cf72588d2f1e7e0cf292d9b1c3e9e00c63f27cf21c7fbf27da4e23897373766092214b9cbe7380be4c996e92e8b0cbb0e05e059aa804e94329184e12d7348208c530d32a848f22765f2943ef4ed66ad5b47f7136e7ec7ac88a6dbfef1438173be469d36e8b7a7d1ffbf09e4f60e610d0c4a09f5cd280ba0fa8393e7acd773351fcf12380694ad98a973bde4dfcfe7386bbbc954e95aead0b429bc46094c5f13db1ee3c23131269801c87a70891ee2d98c5f129609515e80951d0ed850058204f3e09c32066942e95785c2a0186eb5e9ff84c157e51daf60247f2b478cb1151e3e15b1672b937ef60e68b0f16ad1d241c8082067f9246ca081ebbd64ee2a3f015404d39572d35caf8839f48e567939bc6897153d8ed8578ee289e01c849c7875970173f3d2a387dbc332e4d791394b43148e48802d1e1f25ed40979ecdfa95846082f1f38a06918bfdfc469606270754037794680d24e237f2e11d747bd4476fc77c3499bf40bad28fc23d35ff681d4099216e64ed328abd98c2ccc54ba96999cc1c1ef16e68ab5cb1ccfb83502bc46fa23c4f44ff8c6cba77012b3cd4e4542d006e0eaf32b0de8f73486939d87e14a25a3ea7488b6fe781fa60480fb48bab917b3dbf617267124aceafbd0d122582f53594305239a057bcc74a6b4abe0e83f7288aed9b0d009a7ad86250240b5c6b2b967df55a7ededa95296631dfe8c45f6a38765bb6a705771ad0df32badacc9872c9104dba1524482f92cded36cb891c7759283e83868c0761127d13bd197aa2b794c85651dc5c994a3fe657e8618a2ae742a9f5da45ea7194584721f2be9885a306c871cced98dd92f799cbeebfa37cb2c828abe1ac2c5e44053794e70767879740835bf11d4128fd4765510f73eebbd38d79c3cb3ed00dc83071b12de5328e5f1b8c217315e6bef08563868c77fc51b1098a3cdaa788fa05d187cee25f4426606c9ffcfe8c058829410998b9a274f906fe35a8029eebc58eedd36002c152de6d1cec892dd1dda7270a1f275ea50ce7b7524f2e777bb041f6abb95fd58e01501676d634c5527bb3648df4bbe57c413bacfa3b0a31ab3c26c3b406a0765d32cc45c001d67a1e6baa03e2f9d5d935de55159418882698809c5ba5b94fbe32165a8842ad56bbb16a87b7c0da13d29ca69f8024f96643b9144df054c26f3e74edcfa5a13520cc11618164c443287ad2cfc344cbef5260d947aa3dc776232b8221ffa4a5e7b35df29e78a16d0c8ecbccc7558d8c1795d344f8036e6388fba7f36fdb7298291445a91e79f9b3b0b15ed7ff9b7ffce79aa99540ea58e37a672c24d34d484992835dc640f64d6ef698604fee27f3f51822608e389778244af214f6a0de78413b80da550fbf25ce11e65e4417486bfc5d4fe6684aabf3eff8f321f36791550eb0d1b1d3516a57421d018afe1dda4abf107a88c7e2de619ae824554aebeffef9455563d395806476c4b58bd536dd4afa5c04d74dca2e381be186cde08da5328e41b6a66e43525fb84350d8034ec855c36507d3c4b2ebaa84205ea71736ceca70fb4bb52afe4ce8e2e46145293f8be9389609b6e8aac4a9f4579d6cb06c8065337e8310d6ed64585465306299611b04ae75e5c1f5d0f1a4c4d7d2ab87518459d3105bf16518154bb7b0d329d6ae72aa323aee7d59aee42aedefdcb5e3081c28fdc8f1b4dad7b538b55217132a72760820d280833e15a21eb1743f6e41a09258d1415261ef3672b6614a2326fa7399db6a907afbb67adcb6a080b32f8917e17e4fbbb00d5da125e0aa85746aa7397e05d7c2a52cc686cc54f1db67165f9e1861e47512b61781815c1fe59689ee1a82819a5241fede0eb615da638e1cdb19fc007fbad2641cf284b925694a1a85cbc5c64352f49ad4a9fbb6bb35e773c8010ac1ca5be134ef6ff9fd2dcb146e565424a18a74b50f27df40cb3aeba0cca3e2d2a12fb76c4eae323f4298742908f3fc53c5aa6ef455c5acde6a64caceb076e261e94ebcf08915f44e6119e802b442273f32ca82ef205894922b98de879256f3a1fbc58bc8da3449f9e501bc6643d9ffb5353fe75d728614b2cd04618890aba74b100fc46247080d094673f129aa18070c2d0299a4cdd86d2554336d8d1a2b1ebaed5230da182132ef57982d51d68b0dd0ce0fe791e167ff5a7e23ba4310a56cac953de0fa13136be854d52c2631ab6463bba2d5e44c416cd9341549addb3370c6442949a417682eb0b3e2d79d10bf7a05b098aa7588a844ecf243ac7aab0cf18c880dbb573724220f8be4381fe2498afe1f40ff3f9e7fd893588bbbcb84d92b638d211d4bff7ba5e37b81ac1b3f9841546b6652af557af12b2759eb56ad7413b658b2491adf48b090d0edc7ffedaf0f95b28052cfe12e543be3929d0005356b913e32e4b1f644d90f12e21759e75a19b6147a4d2c66d7b79b65c200de3405cb2485ff5c37ebae9902e7c3cd6c5bb5326a5df5213fc3f8e90858cbc9d4b6cc7ebf449ce19a6a711bb5de88c5390b1ddf5ce5a22c4d86bc945ece1a7de69163994d1f4381041da3d2949354fca095e95924c3a33c888168a2376b404fa14b879c48603acc534bc4e82b162e9f7f3db68c90593f025e84002091329caf15d1eeb24531028f87c429fb90d4b73c9e75c9824f14f4d424f5603608744085a68954c2be6512582063e93483027714cd84eea14a4d57129d228e859f17869103541c3468c04cda97189f103de077ef583940acc903573ff4bf82ebdde126d6e0ac22cf4a2914498ada5703d9398c6e0e90a740f2b20b804564ceff66764e8f5748fed7d68eade6db1432066b48553282b074212b4b65fd2f76c8b15afba62724f838f30e0e9ce5cf4eb8f876dea6d4360a5c4b142cf6571787d159fbfb66fa2d32e1a6427ebc45969bae520c46dc536ca672cadee1dc45b12689c677753e9a4ae145b39761140e6a5a6e8ffe387431f7ed3ddbb1cac1ae80b7afb734a772a12acfbd5da4bf075a81dbd059146625ac179439daacaa7d0c8ce5e59c179e417df31146cecbd8a4e47429f6c38e538f65706e2e98df9fd002318b05d84b05ebc9a2f87eb6e0deb11b2fd0c64e0cdfbd865724b8b3bc0d403087939d7c9496319bf376ddf0e0b6392eca30dc6a8d488892ee26662821d552173761067142e82898b0f6400fb9cd1bddfd175fae1cfac3ed88ec2e06f9e89d2d8bb17e981f1518301f4ef26cf20b95cd39f2bd6025714654db6b917b13da9d4547dcc1cfacd7fbcba040ced5e2971ef9378684ad7ef3cc44fcc93898c20e7040cf5521b9bbb7d78cd67d078f8141acf3a7433cdd3189a1a6b91faf13ff87b96542d254335aa9560470c2cf0a50f8ada06b006fa2396e4ce0c7ae928e948ae05a65545d9e2080ff8c9fe2b6a603bd34942c8b44d3b4b946deaca4639ccc07a901b8d46abcb414b08cd15575608b7f6a9b222fa7026ed191daf32e241207292965353dd25427958aeba5f596778b0b2c3c0fa5b19914294fe07a143ee97f52f90848c33efdeb7678a1af1bbe6b9c6b0be29d7cea23ce50e93bf703df38256c535ea926691637d24247effbb678e28592949750b457e0ad5ebb8227527737417b82c35a216722be03743562d7da28efdfa17ba4e111b276e2533602124599a3ece5c35d5cff74b5b5f6e5a43d05b842eaf05322a560cafa7f8bfd358e94be8f5e7d4321c3d51ee6328e0a0c5784a9f35e26433e12dab998a83115f44ff7ea9af72c075cc27ca0f1bf72d4c37fb633b5da085b1ee47bf02aba4e20d64f75b51010349686b59f5fc22212ccbde5f577d4976adaba53c53ea502cca59840f57397c0f47b99f2b0b935df7511333ea240ac6ddbda08635129cf61e22e58540acbd24f70f7b2fb97c8dd99e2994f098d419ecc11044c19d76b88eff77649978d6bd05f0ae45e5d57bead2cf61684dbef44bc70373976dcc864186ebf4efda5f5511777ccd13caa68bf0a3ed4f0f96ba75ddb225450f37ecdacc9a2b515e759f5d059ae18711fbb03a0891067f202c2d833d27fb4fda1ed982453799e79e0b13b23a2d5945e35e40aefbac9b5e1765d66781fca871294a6566f51c067b087f44e42506f0d9ea54898d3934373f48947ff7c5bcdc94d7acd1247b7a69a15a2f20755390d6b7e3416f80b87f0a9bb39639c1a7520d833efce8146145b4a3bdf8e41b382252125aea52a36092b48f2005f6748b0abf0850d537779d6e5cb7200fc9038486b9735b97d77ac52f17c8a8d731af64b01ff7689f1788acd2d1f290505c959baffa5a72ae0c8ceb468fa21339dbd701aca6a4c2c25c04324ad568bf8264d7ee780b4064246e1289f31530da6fd9a8d1b2a6f4fa04986de1de98bdd4e1a1d5e8f3d0966ce7148d4d45f695ef9b87a58f35e92f6dc01d468bd7d09f18f271c1daec2b877344bf960d306ad75d809d8bd23f88d741d85b9200de40184d2d6cb9ebee4852e8765282ebf7f9292aa68d97620b658a542607afc0ee279ffb7c7698f4d31d1ea3dcfa62ff77cc177b545acd3282847ef4c37ccd412269083ada60b0030c9c186966165fed422dbb42042c460e0351e6f5a90f2a54798d13f7d46f12684543002a9ffc3c36624a087958b9387d95feece7e80e0f49ce77ce9805972a3e134fa5bfcbdbf1205586f47372bf5d4f86cd610fcad44720e0b0ada24c8be0df92df1f8deb3430bc9159466ab33d6886aaf349b763ffe79eb90727ce92f40f2ca87834643e26a181b81ad7a8dfefc4b7aef17f8dc263bf2551a5e2c0e2ac335c5a968c2cff87e6b6a8ceac1a6a386785d64a91d885f9e6f627276859bd4a7041dde33048895ad298fd8596eafa55d37d9fd56b3795d51c718fb44b41b7544fec9b337c476320f6f631730fe7a3c3c8d63e8d6e91ddfb7faa5c27eaac6d528d30b8bc3270b1f42f8676c3644ade485c5f308904440ccf501015a14e3d703f63ef5ba7721c5e9fe292f415ed9b6399440a1459414639d4fb5f6cacc4c8dfca89d1b56de501309fb1c7c66002109ab1c2ac4ead8f816e3561a67161dde593d43f115474995adabd0db865452d27e8795109d4ee0d1c4ace5b7f01342e1803dce033f20d79ae564323a16e0843c0b06ddf4f7b5ee5a9597ef7d1edc96fda53487cb1903627f7e5c6e42a30e292cfa86d8cd2033966906937e9dc086beeb7d84842b105eebfb7334f82687ff5830ff760fe0387ed895d7bb4abb359e2084a48707eda77f0e7b465dbfbc2a3cdd66ddd8c2399bb2dae7fa42314e568787f473f34d33f6e4ff2b3eed0064aa780e4c8445ae49ee8581823e4480f33b8695e187302b09dc5eaa65b5bd10454e9c13c334b1184f9b5732277d33a47846c4694d6a36afe95348f99f0f460ed530c42ac589355dd99937d528c9a92ba3c6b109eb0fbaf38773f280d4ef77b90b15cae2f572431d4ea24df84095b67874b1f16dc7311a6a91504991b787bcdb7c5ee8a289a4bde5e3736e876bf62c6d5ea2a7099ade5cb0042fa326e6e8fddc648cd33a53bda87d715094459e1eb4f0e851cc359446a2f16d44297c4c6edf80f0e7bada2727afd9feade9b87cc1c28614ed1a1bd5afaa06859a69448b46ae26b0bc0b26903c0f2df39b152cf2db7361fe788ffca7ac846608b523dab72c83cafea53530f10ef118b3e6aef0955a002378394d6d9f6b67a62d57eb6f0ca0193d3c77e2ab84223cd1d2746204a0457ec61d9c6d8ade9f0771d5ec10ad0a7013761fb3dd8b53f211d3293667234b6b9e1308c1fcc507668f3867433938f7299e210c78e9dc8668f1a69c09115b962309c02fb3f00987c2f9b2dfe6cddedac48ba7b4351f5eb473c7dc31d5f60c10d0294aea3eaa7bb874ee8a04f5cbc76ea6397f1aca3e19cd9a632616b9103fe3677055444d3f9ecfc595dde7a19010f18090d4740ace35b338ddee281cf24420e870711eaf6793e97dc616372a4a8e43d625d75c7ff95c07efe4a325af4a18e1f03f72bf2e1c7fa08173ee70b89bdae80bc476d225b2fac4c94333fd1352cf1cba89af486acdf26b2bb3a1df6d95ab30451b4caf5bed92be594cceb328b0f3d5d7335a2d04a527897bfbe8ae9553b9a4d0c72e837521a525d93481830c882b3bff29ed506bde9bcb6cc642fb96f05a1ab589a80b4b1ef51f358804b95521b94500cf7b3873f0f86b66005ca9b2c3ef5d42d3cc883a6b6a8d403ccafad3bba11e8420d9551968a61e74961782092d2cd8b829e59eb7b8adc2445081b265d08bc50274f61dcded801a0a19411a4567914a274636b78adbb3121224c1725ece0d95b0672e69d47d8b7c47ed1d41338ad5e4331dca5907d0910c1b9682393b689589fa5e1024188dec0301523ea6c049df1007616a5d8ec88aaf9801fe481af9c374d0b4ff50919728c4a7fb9529a843bd0ae961e2a4845a85bc03f81164a282d99dd790e8be008b5400f359416675f9c3823cc3f79c58a3347cdb93e6ef29ce480452f6b20ba05d069329d0df35323d41c78fefe05ca74b0058434eca59b5409c6718f3789c107dde247bd549714a0b6bdd724c2449ffcb8aac88b327cc7df5412410fa6c55c312af676e0143fa7e3ebe2321dbca74a1941a0009b903ab751570bbecfeb86ed788219a98d184054736df135692c8c1eb5c0714c052837133e6daf3bc671aad8085a2c7eb6564efe5209ac34e85772cc6be317a32462b61b0d36fbb128dfbf4915a34fb79deeb2d58733d20c32ad8b280d1614ecf914ffff2ea8cca61c7a986b5a400176cd716358f216d618b32f1e5f36e10bd8bb0eb6da724cdca1be30865edb219ab4dc53a701f1efa651f973024ecb5c23b204559d37415cf8cb3ff1d103f6b3f597678ab17c43ef882a3de19e0f5ef5642936115217fe1246c8fcf795fa11fce0c016a44d5cbe45a8ff0f35a9295dc44b605fdc4c1336392abede777408333a9f96793d2fd15a3945128ff4a250462e3fe366d3137206c1c410fae60988447f68fabd45b015c37d7756635bca58d776bd8899b9d2767ce9bfc64cb9d2d6bfed7b6c1a042c5fee103afbcbe3d9a2e705a9e3f2472686de89f750255f98bc63be1c1917af5aeac37d0ccf0795a2939bdf4160bce924613fe915efec1f99087c7bd779cc9bd1623ee3b01797212cb878194c752bdcd7136438b7c878b200168bbbe6f9faf50dd7297ec5edc0df13b3485e63ee28df77663ed4391ab9a196133e38d9f5497884811dff39d3fa7a3b4145ce0809c346fd10ba90cf1ae4c6a6985a5ccde06eef18f28cd8e0b702735b6ee6558fadb5d570e184e7a3942554d64a940cddc30e71a74ca53b4191af8a98bc4b509ec10610a31b85c0928df7dd866f9ad5754dc1e57556500caff669e01ae4a9331566bdf8d124cbed7b7f5270d1f49f17c49b8e9d541e831a21df40e29b531b9ead13bc3926fd8ac37ebd264e488a462297cd7ce671846a56c5b36ffe6987177acc3603a871506cdc4308d25d116631b3055220e10d00a9d11918c00ca9265455fbe614149c114479453c299eabe3c8b87daa4de48372e683c0894ae6d47b71bb748673ca955f8df7c5de5625823a930473fe717269e20affcfcaedc4b7cc25b3598d37b5bcf8fafc545b04c44a53699c4e765f55e90e427cc255b7d79b2d4d4ff86f64b0ecbec185a32de024a354ae4b3712ea858daf9f6392eb0de5cd54edbebdc0b25ebafa733a305f318cc7af21e4127b2a37841e316a13e89b4c1c1eef57f4425899a1c94cd40a9320ab50f2a7bf682a365902e066cac83b8af2ae6d84cb01549166a467ec943b297dbeae86029ef8a2fe8af568acd2e0ee1b8e1f244e753e766c873b34211d27f87f772c7985d43d73efd478769f2bfa2ec22e73f9d5c8c3f25b5b213ae54a3e72ddfc717998fe3c88c925c49f6cc396c91fd4ebbb6fe036393180d113a81fc0de3acf5958251afebfdde6fcfa7c10c36bd49807d28239805d82c3d660d11155fb93f5c4694a5a9aa1db98adc1b70ad16289de01d70d2f74e9581cafacad29ab333fd6582c5e9c54c3d8b38314faa4b4d7c8b29d682ca4effea7e04be4e4ac0ed8fd069ff3c63939650a29e41636bb49e9f9e01abb9490da5082dc666f21ffa919d394876d9a8228b2b7c0f12914128d08b87b6e57618e86b683445c3bf54c02829381cd117c0620ab1d9ac4921c22e47894c935b7a15fcfcd570586966a77fb1221baa4da9e8ef83db4ffa5fb098cac36b7f0aae70579ab071ad0351aebd4238e6e475c61f52980b3d16a0150c3c661e802988589c93b3f9d9fecff5dcdc49732fcf24a0cd67d836e6a61d4ce7e442d260e10a44239c17e069e980ac9710cfc1bcf2b6683232027b038ad6ec5e3c648f8d985fb8dde23a866585ef1b95e22dba0104f28e6ad5fe32f439242d60246576f979bbb9193ae1a89f29a73dd0d6bc7319a0e6bdbec1b93947cdf14502af4b583587ce473ee66bdf4385c0c7ceb205c7b772e9e32f885c98de33f58693b0b778ebdf2b73e47c06a6d1ae5fd837a57eabb9998992589b766bbff1e07b337c150c4002e86a93eb17309e1410f356538f015d282169ef77e15d8864ecd87475bb555ae744a0b150aae96833ce00563ea9a88a194b2684b89d601c92928cde7ffe27724332f8eab82da869e7a9c0ff6fdb92296bb99b31a6c5be4971c54a4a533fc516b23bc3842e0f7fb2ba873321e83eaa93d0fc342a74f5966d4fb34d6d2b97583235e80ceab397a57b0523ad9f5cfa1b2dcd033c8c933898b5eefcb796873f0421d634e0c0a988e38e3fbfca4eb10284520663cddcd6b574d3ebd4aff069ae5a272bc44e05f4384a31cb7bcb2d7206fdd769e01a23aad1fd2a532ab6bf5736529350a9415dbd1c09e332235ee0b2c68724f605bd4d819555aaf373294ddec1bc9ffb8100c817b8ddf631d90613f9813e11521e152a4fb4c6c758067f96d5492a7ddd28572ebb26df42fa801e059258be59b1349f69996f3f0900c20162c09cf72b84508125118251bf009ed8ea5c0b4b1841b8c178169baaa6fbce2f9617e90a304864e12b0813e3c6a9b199999184ada10316b9d274d32d9887d7d46e70d2c3939a290968266735abe0551cfa2eeb14994bc53099ba0d636a449cb3b7dc967e6116a3fdb4aef4c7ac4eaa49f5c9b934c442c71077c306ed104df5efb917888f725a6aaa3a669947ad92d6a38cfdb0c88056c4bd9eebb6f22b3ab3729172822ab6abd0c930bca15eef22a1520e1f9b9d4f243a1a60c64daa4673d0787c614241656b871f7512dc3c348fb7eae243f0c569e26765fc055ec4e6445f2b45290a34fbdbca700604b613f00d095d61174dcf69956dec85d6037e58d3cc37e59db0bb56fd93fff99da1db5f661f2e0369737fb9e5b35eeabc01e3fec51d3047f055692a24df994760bcd35243740b06f5c872cbc767b5e7f3f3909dcae813375e9d13585c2f0e6cbe732056c92d979d21500fbe4a513bd8d6cd9df6b293275bf061bccb2dca3fc3652faf61b64cd89da8f910837c2ef2746e5597e79e8eb45c35db5bb50e0d866d6af7cd5535ca02d3e7c6d4325fff7d06475adbfbb4a276cb1166c6227ba0e252601ca86994ecaef74ba008cc47a487e67fc53d52336c927bc7d4affdf582aac2870167e85b58d2ff41f059bcad64d3d8fea8aa9b4c903cf4da1db74468bdfbdf5441a75495251e9595c64ff9d42337dd4ccf8ae93e0b6fe4487c9704886660dcd63d5f35747dbb9e6330f1984e6a38f6c294283125e2137cce5c41bee6dfb47a619b0e1a802b7d0494999095793b15c9a1c8679ecb20144dfc45622f93f989a4ddfe9372254a7ac60529c7f8cf024eb9d2575c2e2a035d739ed78ee7697225adb176bfe51c8886c079dfe087abc2253d7a6820912912ed78ddc113c5251a86a140cc49f4eb2d903d55c5370cccf4834a42e0cff4a0c6354c76b1d7d475c276cd2858f506315a38379b21f7bafa9d8a27c62cc6de22dd43777f8fa5e7b799f3c2d5b48e9546c41219fe36c43c46ed4dba1863344011847bd7e2fc6bc1e8aff2b1d1b84e5f3992e87069ec2b9c505c6cbe11e27a3b6e607a5f21be411a2f2d16fa63571709137d28059d3104af5cd7ddea1901c649289c4536aef6def5d2db26818c73052edd1262b801b022076f32889196793e8cc658b430d7d337d859e9bd05430239105b9010ebc5a6f5d6edcf386a823864f75a8eb11cebc8a385f8de3e8965f3815a0b91d0bed09087ab25440deb3a2305bc372cc91b0dba0056fdb5ffbfc572bbde75cd35c03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
