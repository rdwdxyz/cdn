<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37142162c0fbd4527c5d331dca572797c78d9ec30a07a11fc4b9070dd0a58e0e47fdcb25ba80ccba468ee62d605039abc03899c8eef8fdf39ec2a5842870c5d095d5e514da2905b126f0fd20d744d8ed9f42f066b63f5097e45f41ae7a8e56093696fe936a0d23d9466c1eb2d4869dbe2bd9c6ae3b0d557f6d7212c32e12c510ae36427bf3ef4452b1a5a5ebb02315a3cc072ba76c4233e5098c77347b04c71e2dfed553c1691c637188d9157e8d533f7141d32496a4e22938138b00bd44114e8312b242944c938777059038f633477cf0da6c1d97d7e243097795b1acdd0b0f2420a88021f09d6a23dd5938a08bbf93ad9c5a83bf4b4d4059360b99ff94a747415c4fbae86e5da7d5d88c83995262dd991d190f8a5cc9a979691d34ede82f5720177eacf08cf6267baf9604464d6b0bdd072a46eef6b754df15bbc368c3ec274ba2de91aa432f7fdaef12bcdc11f47278a1f68a9eee914afa45c2b1d7c6f17a0169ae22756b3dcf2e8029dcc7529bded2fbd9eb59fbab111fc0df13121674b6ae944ebd3645605a8c8412ef9eecbd70a97d1584e56267b24c3437f8d9c141c1adf5530f15eec555c55faed3d711ea389a801ee5c09a586a4ed60fecbca3bfe40e0f00c0a816f5c5e2eaff8bee9583228bd7dfdd5479716494180eedc573be01aaaa41fb68f6f2903063a373c267234a354c51b29c3ad48953bf6969c00c084bf349d5c98636af5e8d29658189ed9923b859172560c4a157b2cf396793a684b6b1f627ec2d7301a27ffd7f72ee18b0b992f12702f51a431dc6a5c108b6046e0cc8af5d19e0019e93e0dd211dc154bb75e185fcad1f864d0f2cfd1152dd6f786e9af016f1bb090aead8595f84a5f41f7b4fe5ad0acc7aa960e28d3661ce16fd3d7a94be1d4b68c61c505fbccbe44fdcd2de8c25a7b270f97046164d00aff93d6398370e194d51e1eed17e0b1db25f2a4918586b40cf1151e1c3206b8890b69bc876e98717781de6fbc2333bf4edb5a0bfba3826598e555d3cc9ebe0e994b2fc3feaf59b11e877ef94c22ae0a96a957c3d17b695789eef9074ee760cf4c2d673f2e0a53614d941d8c9b340afefa72318731eb60c65a49e1a855a207431ceabf4ea4253e6f023103b3a1a3a19498c84aede69bb281ec9b93e10e07c315c08f91c4412b4732722cca7dcb89a473192a837c5a9bab4f7f175eaad3737859a37bb68d38bfa153df5521b08f59013588da11236bfb9b8804ecbd380f1cf84471d2e8c10a690504f247f98b9f9f1047b91511e54deb8c4054a0640addec0ff5b3857e804b6910c4f9504c74503ab5c2ef67a9a40c0d2ad6649dddfe8bc14614b39b1f301998384a86fd12c4c2f5242e2b0393239844e76d20955cbc6a7971c1214f1a17034becd11e09b275b9078ec8939903ed4be82a1cc59e98e1a0aac0f2a6fe4c18bdc2356b1f5348251738ec1fe5958ac3a302f4a99780f14f2b9cb3bfa47f5fd205c85206ba5c368734b15f52998ede6824987f4e344f4656e021f30bf7b0849d1374386cbc804ee7c8545b5a830ab786c9e5976a3c2fc3d47941176fc310349ff77fa2247623fd82f62786bea32685c7a3c7b779de2e47a8566a29b5ac54d0f92ed7314b9b487ae3cba11d53e493db0291b6c47164d0d11ac6a91af7fe2fac2d867489e841af898f7991a9d889899840835c9af44c025a1e23615bc0f697d7a919ca7a4b0ead9f0bd871ab00e39dd3796fac59eb8f44d4ee17e991fb23ac11756e2da1442447556608325f22afee16072784c98514d6ade74ce6eec31510f30573254798b0862230f0d5a43b6ea2ba986181d6328ace240c4d5ef5661ead3e1f6a38d71fc0fb8e125d41b755596feff891699b0215744245ae751afd544b249622d8a08073d850741e89f46acfe018802d0f88908f23f9f40b7b08aeeab8c7f7074c34b60c24884f98ce4c6748e4f8a23bb48708ecd7ba820e95f459829ddbd578d7c994c98644b9dd0df440a7f7416af45c13c52c377273ffce5ed2dcb8666bd44dc2a93010dd8fa693b164a21048baf7e8a87cfb05233fa19a677297a834cf4610369780417c89a560a948d1d2150f2bbd13188f6e5c9f24345851aeeaa5ea579a61552380f67d6c2963a6ff4da473b2dc76de7c6d40859d730fe6037dbc1b2b14443ef762557b703b19e39949b1024ef602e42039d2444b00abe5a404715dc1e7ae759abde40d0a6ba2a870a928de518d555244f2ba70f426a2d0f698825babffae35b22ac8570364f1937beb894c4f2cda22a1442b8b817bdaaa37bffcd680892e5622a7154914d25ed0f4de115e49abafb83dc82341d387c79795a302de049b9aeb8a9449e6692c79a86531c59bf4e2e9ff08f6bcc7806df926a96aa6330d4f1c9d43ad13c043f1c127ad9978f699c37ffb44fc522ce61739d4a07b62f2e930ff1a4ee8f6285bb593e771be2cfda3b29997753adfa71838e94f281fa250afc323ac1921e90a699902a1cb9e5bee18d455f06a8dd18e14c3646b5fa5b9d9c4911f9eb0c3473d4ca675a0b6e4b73b8c2f7e462167e532b53ee249f89ba8a07665c98240af71b9eac9cbbe7c4469edf150c1cb910825f289f9cd13201e4dbf50213b488f97a8b15abc4995f098cdf80d38ff08f36cde28f613285c6bd35829104a90128ddc34dce2adc37f6d323b0c8b9c446a6a7bd18e9f25acc9c5776fcbdeaec72275315fe45993d3cf933906a9a81234cb352879bbfe0a12bddecafb316bd3c1e50cc9a6003101366cff1de666beec77455343d4d8e9e6222bb388a53489b1040fe595b281d70fb24a990152bb8e821f183d00e8d68996cfd48fb7497cc5eb969deb7970245c0b47df52dfd64a43509fc480e4c2169ec1289fd7cac58e19714fa1f181ed71f54abdfa13e7ab29c3e3baee11f25b72ab5724d46a35753be38e523ff05182dfc10d48b920e50efdc4cc72409210e2d6a07ae9ddf074de7be18494f605b6cefd70d5ef22f02c483771f1922ee2c4833c24064f77599b7af7f74fd0c08132ef862037cf7827153144353760043260d21f901ab6a5b30a3080cd4000dddbfd7b2865ff80997867b19fa824b5ca7694fe1165c1e840d5313eff13dabdbb79d074868d25c84ea5af772f08cc23c0a38c070fe3c2bdb531c8200955aec079e13f37f4174d738e462060f2ca84f9369e2d1fa73f2f7e9d05ce251d0f35db8f50417ee3d37657bb7ed7e0dba04dc078f1ebe397e870897f120c160c24a943fb8b4886b268b70096b2fa8ddc9578976e367f073318e9c7881c4976866135d18f1f3b960e77b7722f6a9bb41bcbd73ad14c5cc72a2caf2af3d1b1e6075a33fdb84eda9c1800c5ffbcfb4c83bba3504fda8b77fba38e11d1a5fd97f6ae25c481f9c65baf695058729793913ea658e4e4ff9b5364ab3bd3d0b25a500d15a509e069cd942389133002ebea098dd73f64bb1a53f01f19c7e942c89b6e23db0936b4fd8026ee3001d66a2a42d3687bebbb483b510d28d98b4e2e30a6d19b0ee008a266632f9213afdc9cfd5a9dc26f13b08c848ddb4ecfdf0171542b2e167df64acf0bd35e0785616fc50bab76657d9034277e937ecb16d4975b62a7f5425a993fdf85a7ac54e2280ddb67fafa6933f469db0f0abd7c406d5047c37246ba1b727fabee21b59a3910b03df0c3f35f3cf995695fa722ed89aa71c1da87c2c052bc924c28c6413ed799c867fb3959df985e0da5f036f3fbad53b2edebcac4957c1858d52e7dd3b3717e45cd507ec6bb7d810ce9b22e140d3eff69d618d50462f221de4e269e0c864a7e91bebecff0775631ea4043c1cd3260e5edd47187b9095b047c1e401d35af73a66b03bf7931d8dba37661d2148a32710b9ab7317b647b29beff41dc031a625853a3b57fb18c8a1f3223ffbab73cb5f9cec7a5d1321191dee21e8b9cd4bd4feb7515b8f7bb7a9205f97dcf0448c916a22c172232e4568bcb5a756401daefb4d7c783d97bfc34ab48fe93c252061be7adb702ffda10dde332d5a86129cfcd523b03bd7b07f30804f66a3a65f3982b0e97fa615920829151fb918c1df97bffe2f70c9d01c56f21c307f8f333c489226dd9998a25f918ce66ddf07f26b30f337ada190fda39986143dbf9a6a7794a777fcb37a0e51fe63cccc4c8b9701bcc2319b36df785b16a8fe753099d23c7fe74e0bb2dc893ba94982477960e2690a73268b3e3fc58456a1258f762c1f0c1ad0c46075ee17541a347b402055e57ffca2310ee60efec7e65130027531a39cfdd60f5d822c3a0ffc6c5645e122606a462574c747408b1dd6200f7392d4ea8d9b8d5dbd9b6504a3a7b9b143d31372610acb1999c9c41062eff610a3a042a8185c337b8d52f88aa5924b09d7befd58d56d68d960b6ecb6da2f14fe34a768c7052e8743480f754521cd025a846169c0fd7c05bede55d374d921b10728eb91f67a31a88de158bde59cfdb85179f24cac3df67162fe17c7a3350032f7ae05b0807f2d3bbb4f8ec7cc3d4fde6fe122e977fb6a248b6621f70fddd9ec4090c6c056cddbf43650d57ca258ced745da25eb605abc160273a84e7da48b4333bafbeade1c74b41763f2cfec5d98a87143462693c777322a609d7180df08ea296e04a03c27140330bd85fffaa1f3db7ab7f6d0e563485b9ddb0be451eadf3d165ee9577b8f3260f1bb2b0538ef4d182dd5e9ae53714b42e3412463fc1ad5a46de331c5e3483c40003501ec7fc9cba94bb477ca378a97a0831e847a5cfc2ec01e740c68fa6adb163bc65b3407578eba7e68a3e69f3811945b232cf6f347de0c1daa87ddbc8406307a86ea557bc9514dfe57103c7b458be5434a0bf0992fd793d9c11b000f142231fe88997044be2ec6e6134fbd17db5c3ff5a06a442008a28a59b209bac44931e4ebe7f6b8d95054b6f35b25b0feceba688b66d595c85814ca1c58cb7ebf4d2664a873b136528406fcb3325f5d0df4215c50c3ed92c2be2a8a121b24ba933b3c0aac3fb81d82905bcee7ab0b1371b94d6c148a5a3c3ea8c75a1b94aa90bc6a9f6720e36830b95625bc9d946b07dd149affae01e3f245c9ee86bff88b1e246068e61641465d0cfbd08e5b95472846204ee13855e6be54478f3b52c03d35443388ce973cf608a58006ac09685d3fba561c6ac062da2a08aa6c71f43e1fe9722da10735b9a342c268323b6c9b0160ee23698f9357aaa4c43c6b4a5a3cb69da2e2959ec515d0730e2d9e2c293f6dd858549d112d280e9d7489eb219dedd29bc9828e410494f73d56f19abff5a5146ccef7fb2686166f52027236d346f33c169612022fe11b25c9af7450f1bb804a4571b30755ac383fecedc2e39d54dae346066073a41f50210154494d1d024015fa9e33c2612a141297c1e25b2184d5a27fd467e77b8282d2de4a16edab3d2ecbbb251dbfbee232a21e9185b6b1809ed0da74ffffc5cdbf8074cd107a1ab0686b87ffcc57fdec58dc882ae409d01767a73f82ded6d4c0fbc707f0458f8137fe07be02128fbb665bd580e447118f28c0b1989458e6a9859dbf774b3e83d614d4fbbfad9c6bebe99e7b40198748d921793b993a3d8abd2dc16b5d05a9a10c7d91e24170dfa1d6b4754454fdd10f9c29412a7e25f8a1a4dee48e3de94f644e4e5338d0075f28bef4ecf03d5154133bc279c1164ae62bb5ecb65f4fb44dfafb712de03dcc96f1de9981ec3d2fbca175aee9929f6829604c06bc98b30bb208972edbe9edf3a128ed80e814f91cf6b39a6b088ab00e0f7ccc83b9eb0131a57e8bb9cb7c2cf7245e493f35bc3ffe4aa31a06a0ea994a66a04d0c23124c62cdfa355c672111204574c3c503c87825ea63c139cb0da5c99aadd529ba94a503fc3f371f6485326f6b7c37a92e0bc375451d34ce4076dd494e4d903910172c7b75f5e05b393e8274bfea49c83f1603677b3ffa1f914901b04e75ad7f67589f547739ba9e556c3483f448abdeca7311c6a2583ff43d4011db68ccba0466484cbda0f639096a5212fec4807734114d9893ded35cc3a6dad8525ddf893bc1ab08a2dd730c7e2aa15ef8828aae2eab8f7bd3b220c5586cbd45ee071663f609026dcc98bf67312c932665bca6069b24e965822d84cc2d4da5c124eb20949a40934b73871999690ef846779cfb3e3114b27b72fb36df63b164657d98e9f9d958f587776aaadafef07a085c4462cf0fec3786381e23615698f30a96215ffd881c0494347698302c958bdde963ca9d187cfdca2791f705a79f3ea6918c5733ad4843e19f8f73006777b7c8b2718dff8eb3ee7b499eb43a356b5b5d9ca4f1554ed81a29431d62f765b2890cef3d7d19e80963ab6089a5f237c8268917642f57d55bbfa211bdbbc1c1d3242f91f78970e2544257313da3e9d42dacc094a4970452b66ebec1a1abb1cb579ed6c3633f38c5adf93c3b8b128cce3cb8b359799997b730e07bdb84173ca0c604984377222d85275916aadad5b20e8c1ee0c9b1be438ce2af13b2b2f91cbdf2141d730936e3f8d5b8b05c0329b416735386107f703099b9f666ad6981de29cbb7ac44f766a962642ceea25375da860dc35d538b1142b6954e2d3ac60f27ae3b24e65db1b8a0b2d1d6957fc7d7465678d359879ecc3a5ffbec6ddd44ca1c800dbf14fb6e43680e61f3c1f1c5ab06891fb757fff0e298221d3663d0de3beae1df39652c7e44163106169cc54fe4fc1ed08a2706177815259f63e7aeebf10653d1592425cae66e1a06f79b8fd6ebe58089bebb707572c95e424c15862c5db03498f12bc405b347870e776cb4f22d17bd90ccb718add9d4e860c667a7201100d69a7fdf2e7202187a755ed8f9d8a69565a7b669c2fbe32ac2fedcc71b7fcea200ec10eb9c1bb422995713c3450f3ec03e623cb00090db9864dc2dc682f927d1372fbc16cce8504b963754a4623a271a20e53a216fb0de1c90e746de8892240bb7136c4f875eddd5dac881d3cca2d8d751c0c92665b61c77374d1e3c044e5b62bcb4315ff6781154a7f28deab47da275908ad71882535f91e67975e6eed0ed142d8d66eb7c1abbffc744427a5b2c4359b68c0c3c2a6726a424da74ec60b6ba1d342d35c32915b1bd7fdbab716f0c3cc80c97f436b02d53c2b1b2a8170e50d8a3e9674efb9ecf4c2f473b6ef1d8cc0484d583dfda47012babad552ee2d337a0a125b33a8f33d0a9a8ecfbe2c211757e7485c9620d713ffba4a29ea7aa41303809e13c1365f7336615de270009e03ae75e25305364d74ed633f71994a05d774207654eaa889ed8c8aacab8e94c5d767e3a8c96b732081a3cb15f42629bdbb42efefd26711efca8f38b72e46bb65dea7ac68aa28d1c4336b3f792e8a45ac12458fcfdc9f83c65db8b067e8cb04a5ae847341195a9765337c585b885ff84b507e85b346edadce7064f02bc46f7e3db3fa340356b312c0a0cd6691c1e367ab9d19aa122a781d6b9fb5ac4b2493e19f17bf6f5f44ec4b0d9cf5bc3e95ea96022ff81e09ce54d3be86cbe1178215a5b5ed38e429fd53c00b9f330db0d164c497dbe9acbfd750814750078a25c27d56769b37787c5604851ba2778407e9fb4f2561cd27d21342f588c6a042afec153191a14d8272cfc0c864d29e8737d415f352ba38f72e35ddcced99e8a0bf399251c01107fca9f786e62bf280adc5bebf47b6da378d0fcc3cbf58718f1c5e3dfb4137ac163672826f86dfb11f2975b638793e3a5504339f5745a01476c85bf307cab7e3d7efeeaf2b42323147291649d8a5892d160ec6b584c64bf6c30d827348bdf357e9aedb824243832524b9f8bf109f9fbfc5b348ffaf1c0e44fe437a54743c857f808f474c9c6a2965eed085d3693c2a66008eabb712348f53cef3fed2449a5e9e7dc35b129ab9929beec922f11d2636b475398bef1d59f18b7dbdf71381b4fd61b03c40e50b4cf198bbe62e6e31100d29a822167087fad56fb1f5901a6d0fc7fd5af2b9c26a8c0d85e3937e1d24fc0d492b31b301f31badec5e65aa421ff6ca7860fbbe5d1d02a1afd1fe4f4ded01d1a0b52e588d95a32442ebdc465ccd1cc7936247d0012fae8a2d0149464ed66088d1051a7d6e5ed889c7cc3f166aa5a43b132b4f8e783d1f1ed98ca3d0824aba44513193d348eda1001c4cc7f8f87fe550b92e20a43a87a363d89ef6ff7d062cc893e612375aeb896adfba091d87548facecb4526df849a0eb69ccad6204023d542a28d2541e377e42d656604897dec3ee55c43aff2b6c8e5681a6c572a96637cb65dad9fa1c9f6e7482bb4f27360eed24cdaaa032445bc2d3700a9c58b1d9c88567be6ae146877bb1148fe252316500cba95d660c4c7e13eeb06db190071694a8617b2ff08d6927d16fec06865d0648216468d1a038be8167b75aaf9ec4140bcac914c65ea5f4a7e3b47bc584a385b2375b55f5221dace691d5c8c3b91f6cd8564167bbed417678b9bf588926ecc76232531d3d3b67163ec146af3bf2056132f1f4d0e9e07b04c607a4a4c602b64307dd69732b3db7b073748b5c0a77f32157662697c0d466f2b03454bfafddf108438cde3816485c5ee02208367ab3962b6755e2e6f684eceb669829995877fe4b3d2daa08e05632bbfedca27ad8c067b4f183feb80e7a467f9c6c427bce8a71a73486b9ec324d4d436eee3d5bf7169dae98c21f5c66893388ea7b6326f75993e47f2264e27bc0ea1800e2c5dee112703f31579a27af6006e1ad9467955f48b8f8bda58d135ed1021f0c1598e4dabd5af16fa734d80760f301ca49380e9239a533a430dbe54565986a6899b4af7630ae9df9b98945a3eaa34620d71ac27e11546b6b4354aa327bbb080260b97f5abd17a2cd683f248d69a390e5666a8e4b9c1532ae2e8900723c733fd9d2aacc9ebe042875b5a4fd18a62f2710f649af6662c833e4b2d6c5ac308ddff034989c4c0b123293e7a5b1cd9f0dc5989acaeb83f38cdc9323a9c89677524db70ad9551e6df60f0bab4c23a922287953e897f4e7a128e14aed78fcb6266cee4a8216feb9e45694eb9af923a89449afbc318d6ea84d418d8f6718cf45a5205f1d9cf2c8cc354bcae728ec4654ca7a47ad2a298387ae04b5d579b8d26db9189f4f6982d51fc2815751cbdf5d90494026630ee8e554267cc3cba64e6403be6f7e392e45c69ed1fbbe724b0f4c15f51ac7421ef9369468b6b1d2cd81f5fcd4718fe80fd9a6f5feba14e8f4324e8a5db70b498a931bbdc6c0bbc1ca605d28e0a729301f370a34f3d1edaf514049bc72a63e42f8f22d1a7bef14380dc28f31a468b98fad07b1bd55841613b817b462f4d2674c5e847e5ea7071e64de351014ae5293233d714c279a052138d712891913f105456b3aad02fa807d52c9b391ff8c1711a1834eae8a715432fdbef8d2e7f68bf4009a7a153bee07205fa5b380358ab9d4e494013014f511c42df83f1e0e3eff94b904f8f9ce48547437806be3d541f57854cd91e4452ce63c16912bbee60c0478297006ab96facbf44fbd087e82472c14a461bffc0ef6c2f4b031bd9adb064b3b4e5c2f071d8d6bd3830268cbdce28071c38e422cc7908fa0fb7e63ecd5674fe8232d446145601a4fe51dd773d9954a85831af4dfefe160a2e6346b797587ace260512d1b29d4f9c36dfcb49d42405e83faadc3bc5e8891ce72faf244d5a1311d1b8d3d4109aa8d7390ccde5092e9eaf3d9ae0f9022b7ca2dec51a07f76f37f969b41636698c663f8b7297d0f8406dbcb60bc6f8a7224acb2c11033189e36834bc195c3333448060555e209fb99a26c61f675df1b849593fe0e77bd1d15e1abf3dba1ef477085eb03215d0fba9219972cb719cee4eec2564c7e0428d36da26b35f295e574c0a754b200bbe22c48af1276c9f73bbf8cb6b01e045994a4c5e9a70007d40b64c9d15c407a8769aa76b08bdded25fb5a7ffe505e7352b2b89247e776156e0e13d13c8cfd9b01fefafa294c63c2629b637847b786e92f0582348770ab9ff6e9e09dceff12563ca6db80946ed5dd15fec86b5db2f405d070f39f4fed911fa7c1b641f38bb22f00ab12f169ea0a691317af1aae050b98d4db3cbd02db78ba4b1218076bf571263e5610140222a9d07ebb907b6adb168375d455abe347db13195f6c4a635a03a13a74873357ad749545050aeb7108dc173e9817afa80d43ba7b6c4c8d4646e927d46fb853ffc796dda56b3e369602734d61ea8becc4475b32086f957c54e05a37a773322fdc3aab5d61998ffb48a2e9303cbe16baafc7c2d82f10d8561967644eb87c7dece4516fbd89f1bb10a9ff5afae956e1006ec5d27a96139843680a459ee71c673a51eda6b25abb3bf87886f3ee230924f19255f8025a3cb5e77c3fb48fca4bbd01710de5bd5da9437587f702a03469a4801d9da73c64e66cefd541dec219eb2d77bf03bb0c5318e9d6cc6d09b40977c99285452b94d01c36058b0f1cba9110b57b83fa17d0a31c1a1396b2e29998e0c7da95f1d692407ec0b4ca3fe90a96b4997ec9c1505fd3eb535e8d2187c23509393bc4a492630d02c6579089d56708360def62e17f625056f244a6f9cc07861106c9379cd22c9ae3c2a06b30df58f5004d12e23ed35a0987ca5bcf2b54d55bd0c87927e42d64acb7308ac1ca270be145f8e3b74e2dfa33124a8464f303fb4f8bd734eac47dbf24e774b9fd71903b8defcf1d3532198b392e1746dce19ceac04f0984336a15bb65c9a0c375223a7ac1672a49b832028b7ce309eaaa9cb9aff5fb2472068994da4f341443c272f4eda4c5197c455a7ed99567815d9a8a54e82457da3568a7872bf3f5227956ebe09e83f1a47f19be93b3819e3cf8b218d262dc201ae64faf450f9d98899cbbf71098fa81a22cbd1ea6ea8fcd614855f32d1aaa9dc50cfe9bc2363217c416a23b6d58a754e7ae67062b125991405512c804367c5876a034f62868ade8a15d023de6123d55162e6c9d6173af745ed46e8eac4e5d4aa923371fb06797cb66bd4c094f25aaebdbc8c7ae45c4b3997153affee17e56f253774434afdd4928a43554334ac8603683099125de10ffceac63d91bff9693ea20147a9ba59ef7bca5d0eb1129393e95076c9a650d4ebbd06db34c7aeb28d9290817e4bf9c8c50abc62ca2ddd063dd733c2d4f9bd3222f31f36d7a76e6fdd36eb3275b3cc17c30dd80e2214628c75e7e594ac639a65ca54137e180c6682a095844f992425fa2dc1817e71e0c1eac8db9e2c9cdee3dc65fc89287f78deeb6eb367bb91220846e411fc5163cbf0d32779f436876f16ed47b97214f6f7df4da1fa13e024d687215e93c2043dda95e1e3c63ae250edcb5e0c14580a9a577c4c09c3d269c46ecbed6292feeec1e6a83e5553b432f7795496c34ebaed2369a09abe579a281ae3c2b94ce126dddbe9d97ad00c126354d65f59f14bc36a289c71ba11e8a78b0322ee7821aba6b07c07fbb4e650605b00d0bcae6b82fe1f9713d4ecc0c0913b92b769d8096407ed5e01a22420c3ec1a2812c229cccc1b0df71290b2c4d966b76d48144da8e0fab049cad1c2378f3e7efc9013c1a62d6f17589e85256e755a698c6603753cc5041accdb6de6bc830a4301d9c125bbe4ce88cb7ca1ff6db8af763f4fa6fdc63572ec5bedc02d907a4d38f2f8f44a8184a7302fd48da8d6f7f5ebd5df0b45df1d9dddf0491fdeeb3ec1ffb9e0f3f9321642a09657b80ef4f1e66fb345d1f5d16bdbd0573d7edc328f0c53a1f90efe8662848a805b75d4c0f76a441e14e24a574170855c8275c04b83532aab62a9a3c77a0d0a276acc770c56b5c02c3b299040271056e2dae36848b7b88456870f20db098f1eb08eb1490e361ac964bd5bf0fdcb34a9eb0afbb54067acfcc9b8b4f2f2c1787d44227800a822918a74f5f0b5be17c22f52e456ed5ab12c360a6360adce1b917c28531ed1aeaca950b14e58db344c4882a0961bd8c78f5fc15cd0512da1e9d7f9cb249e67f41f16e27c2dfb152139f2b3a08a3804345e4eb7518c0549a7e19964f27f65c679a0f159be0421cef32d895a0c4817b0be094df618d32647f5b158debdadce1e611a916d85ddcebe0ef435412a694c0608ee9a9ce584315a570a965d6ca66ff3f7a8013b9f8772d60795b6454b243bf956036acfac73aeec8b094cd38b214a83fdf66927db2c9905485040e16a1b7aed7dbb26a811ad9633e0e2e57198295118c7d2216955c25bb6155a6168db55e7f540174e0c0f62e1f15d826381959e3a80444e2877a0e69344ba0d593aad622272acb1ceed517a246251aee88b841b10d7b89218d40d3e7bfa9d265185ad95eadaee19917564efc56165904115a3112b43f0114e2001cca8e7cf85499592128da4d6443e327d9903d6a2a4dc15e2f346c2f40ada716c70764e12cd12a7da2ef8a844572aa6c282d1a897ff668de055a14b4b461b6add05bbf55edb661ad4879a355ba8428b0dec717c0be7ce65115d10f546117525992ef2a33c5358a446d6d45f395f1d187063d6cf83839434abe0d8f013dc8152c8f43405772d40c9094eaaaa8ea93e4da26d943c3d761bb6e0f495972d25fb10c7aca6f00b7ff295ffccc73edc68e43915c21588cc710b68f724b8bcf6fcbd784f81d8f36048134020d99bc7b70f783ef166235e59327cefc75ed9feea9478227ff570f90587594bd7cd34354936dc095dd88be869269d48f6a49e4a6214d10018efd6698d1df86802afb1e9106a5255a2caf90ebd8ce1878bdb29f32147fdf6ecbb1f58be3039b0865cb74e1559ef492f1f04ca3aacc642c50b70292c89b7b13e2a7cfaebfb9b697b0c417c3558a9a7c7d916023c9a94fbcc11249cd49b5fcec81026f69682f9f044419874b89c0f76ec8545886449386cda9eec8b4d23e5090bad965be9f20b9ae30bc6f1d0b4f4daafd5f1454da8b8682840cbc67423c7cbdd9f95822b06b5beab7770d7f38e57b7416059dacb8ccba85f1c30da63067952005d556c7466d79beb412af70753eb08f19f9e49e0e4c8351fa87787cd51c1d15999d7a2eada07c6cff636ae05840a7789711323a8c502169fcf76ad2bf376a7e1e5bef2e35b4b939fceb2280630f97bb5ebc265f8992215fd4fabecaf05afe55343edf971f691163492e1aad5365b5fde3424e45fa16c332d7fb97ca9272ce0834a2b6631d6f71e08b356819d9b71c055300f2073b34ee74713a3e58e735ea0f027fe8688027c40e2532374ac8399d2af8920b50f67581d7171a3c5254e146b9bdcb914b36646bfc084951c826d94f9021758b12e280057acb9c1012ff99683fc16e5900c5e77eb7bf26c8600efe8fe8f066d481fcf4788eec1025ae67a3727bdb2dc97a7c5a19a3eb23a91591b25e6422625f7789faf1366b3a54a3cdf316f8ffb5487ed9923008566b261172c1e034c7051fa73933a8c59bcf55d927d4ad4331e57eae0d0c17422a6b05c78ae56723be685c2aecae6c0b96b5b6c18e1968147c4c527d0c8b96941914a8697c0db23fbe09728144bfc6158b3b3e0c8ba137a19e91d965854267b19c2ad7b605b7ccad90a9ca37799d0cd56bd2b6c8ec9de31bcdddcaebe666bd61b103496e27db86bc7c0a8b217a9367aa4941896767a2c4d958962a0d579ea3387d11320fa77bca69f3fa3c316853521a8772e976bbcc450b1ab625e57b21c00d2dc034db6da81404a8573881e705a95db72d3117f7b82a3f64b29f18a733372dfa2063ba8fec20d34137e269c28a4b8e604c4763c287668165a08993c8d2f6f16637230c77845342f9488d4e65ce26e8790cb0d912a360290066dcbbd818ce6d046fc94d2705225a72b499c1f84f448ef039c9b9b200dbaba33f292b1adcdc4e4798cbbe90ee183d48587fbc09c2eabd5076d46a863bd8144f05ddbbded8d1f5cd720cb0fbf7d9536395978125eb435a04487f8cbb41420de870cb19afb295740bf3e6ad9ca20b2a9121ee34e2bfc7a101dd4977a3dee3065dff263d5849fe6c83d1d49268edf1648b8b81b3e224e93ea2ba1e28a7afac9573b8ce991747a95f2b520b181d51b3c264784fe3b45a41e80e3590753376a1286ce6bb7ed8e2d1e50ddc4f1505c89b8942403ca3552caddbdac1a00890459d0aa98b30246b184c32d4b7434793e3a87fe097c1ef1379f2b5929d90d1cb83b3e24ab14ac17ba278cc1add96f4c8507f0996ce7727d97c019bbb5033b148ca1287ff26f5ca3d625c96f007d081e4f6da271d8b96709362e5a2b26390d99654ffc979aca706046d472a4db2287f60ec0fb4c938cf09e5521b73f057b175e829cff66ce5e1ad2f18128c8bafe3f2a772430e8f69bca48ad9afdbf22dcce5b81728807b69c5a35ca28de2fd5122c1d918b61010a1e89e866be70eb4df83e2454f315eda3a60db048be1572c05bcada92497f2cb824754ef261c6067ce2756c6cd820f575c4e3bc7c9bba3e8bb7b888ba85770f783461737faa079c3dc2e2f48003cd0b47452a397aefd9adcb2a4272f08efcbaca0bae25689814c5b6013cee2135d1c1002289a8af280f81b4c52923904ebfd3ba22fc12a719d2161fcf416830956cffe42ed3d34405ab202a82360b8e989dc613ca59465efbf5925af70969f48891726d72d6606bdcc9991e605efec058dd137af4abcf5a510d962327ec385dbe248d9ada3c0f413d06504db14381a7b10510ecc48ad1371406769343f3a037d2f584b0544076fcbd09088392d9e0062cf456f255179d3fb93f9ee5458b0e58eb11f58337217244d72f1c9a7c6fafb9a80a2b4c06971c6ffb8086abcc906c47cb4d26ceb7bcc6a6715a362a0a61be30d4e0716f4ee8d9091f5334d8be8f6680aed440be640950c2386daf1f0f17101b6bbab5743626cba06811bab7e7b5d12c2edee2388c1f7a7d16293bbaf233ad7d416edecebe434aa9e0b9c8c08fbe2777a3a0aaa033e11d4a3beec150600971feec88dcb3f86e46ffb2347073a4a7972dae370db241de98549f01510e84dee80bb2bf6249e94499f114cea70f888ad4be6b2ee125031fb02401e8561485b87667c8812da7a135f303a702eb3279499e5217ba331529ae15bf7d1b69a9684bddd9f67b53bd5f8ea734b6264514280aebbc8769f845b2af1c86e279fa76a45503623584fc70e3fc036b011997719f3b5a24c26be6d1d0b7f8d860cc38bd513a2eef499040a97da7a8d208b61e59df58d5f263628590e1b13aa82c80e96a2afbbca0c39d4edb1b28ad67915003e53ee93da4323418c03c5e96615530df768844474f3724087eb096beedc3532eb78acc2702e697c9142703e580ccb91514c0c0fa5967b4dedb9cbd5bc8fd5d65c371f8fe0cceaafa69e840db9c888333acaed1edba47607bb72f41fdb91276eb1426a4fef4d53789e0c292ef8fecd697a0f3f2092595feeb273a55d5f56d8191f045b119e344ff0eb492c0d039a59f5d68060c62a0603124933d8d3655f37e6c72593934f26ff10ad238768c0616091d7cd787c4f6d7b74bb2772eab16639641e2bfab312b0732f062f07ddd58b2866f025f7965435f43282479b3ffe01ffc937846e65aa7ca9534a93efe8397bf058401e1b4a259146872551e6e958993003592850223dc8920784918295d4240902c279a3415c75d0fc15fa94616810f12dfabb18f1ffc7bcd72104e8554fd2d758529c0669c01b937889681f98b2cfc252d34fc1a7470d4c682f0d4d512d0833bd672b1b069c4ff7ff2a74112b7a54c1858333fde18ee71ed0beab70b41bd2613348b135428f564679e9068f628b01c84f4433378cb8742c8f32f88a6e0596795303d0d2fbc05684c1691826f968dc72523df2a073a4e39d1dadd0529d677e1f2dce47cb53c2483df31642eb8098c80b61254289cb884c380254c3912f3cf71339c8e45f87c6a604b0c74da2466b64b87cbe2f94a676a051b260ce6f287717ab785b09d5db2cdf7d948badb16f22b30741068642edbe46dbaacd7a69ae65d819d6714c45b88836bac33cfd843ad251ff5d0d87f537a8f8107e1d24579624d60846b88ef6a9d7d356a34dcbf73f4b86a6ba2ffe4eed66d782c9f5c32325c6209fd69e92988286c5fe444ef23a993663a3b830de7d6149735532b09e3e671827fb35460137067f809ee5749b57df2bf167723730715b2d3e5737ae4b6a7fa9ca565418d24d42750c6493fd2ca82c02b4cf3d3d8d063be9b511996b5ebcb63086799a3bd289adfb3b7eca6998929c63e44e02112b17762509caa6135481043285545bcbf8488c87502dbd2a616fd7ddca2c02239f21464adac5ed762a1025dbcf5b99879e389232380c3f6c3d8bc643ae60c21364117b5e32a9727f728107423f75b6f21b7dbda5414cbcc34c723d2d9ab16cb1572bfb8f06318693af58ad321aee5b3f45943ff1c7d293d978af6ade08c29cb9230c248aa64bc055da34f5482816d932f45017100c9806e45acadc064705a17dd18fe2067b501f5e68582e676d40fcb3c0301bd9d6be0cb4f6be212a821a205cb0124e79b225580000e9cdd7d3228fea68246670b5f909de9621cf8ced6ad7c05f4352cd9c3ccdb4291693fc88cc0f41d5c82f9637c61a0ced6da2c39e788024d5e5208a41b98c32f87aeb79c5527d9f220a1855dd9f16c78bc257dd5183fa72fddfbd82eedebae3c6cb11bdc5dd9849e20963eb41b96ee65606e5a3bb00b28cd3052027fbea9576a71ee3594a148bcb23e3ad030760938a2b5df9ab868ba3c9b291c9b143e506598bc3c777c8376d65527eb9fcdcd29d54b1660057428670a4a3987a5327cce97076c7036e929900005a1f1e540c4c4b13053d0cd3f77ccdc5630d116465a88c6aae8738376a00dc5d523ae88c463f4a74cc38a2f34618393b8984916a938dbf4c3c2ec62dd7b1a28900d0a9d465c062a68d30f812ef06fd036ed90ab7844931628ba617af36b56cb02a958e71b08b6571f896c5121381a497c77faa27813d813dfc7d94a13437839f0a4cc3a65b68311d00168b93b600673a535cc6c2213e42a716e03df1e85fb8de9f0d74569b763f7486c8a222ca935fa0f45ca532df6d8bae0fe4274232693c8097d9ba918a57e2531c4c9f1d76e87007bb061b9b5494a68cdb1342d3efb2eaa6eb8c1d687ca2121c75883e52f82e595400faecf01675cfb17fb1f3cb25fbaa6fdce054ae27eacb226fffe3739e36fb31d3cba6086a0cc558b235d7a062fd0cc3433cbcf1de96b81e65e61eebfcffba510943b820e4e14bd8618806304a1422c3b0ffeb4b279955b6efda642e2255623330b4e9024774cc98e32a293d74d6f0be5a4811b25ebfc44dcb3781b0ad8e6e1c3b351c61729892840d0d6fd8793f43a9f03d5f801e24d02abe8d6f1c40c5cf7ae55332a4db54902f15acf1d8217841f18be57c38fa7cae18309a30bc37044e855756ac3f31985e331205bebdd800e8130a964a806f2d518a8ce344a6fb698e13290a5bf2cf08c2f95f05775a125155ac8e1fc3b9f85412e87eb183788bdd7dcf6d34faa1ff0a487007f66dc7ee3a09690765bc2f7b66ecddf702f5cdcd2fe98371fff767af92c5515f608e668b04acae8981e38cfae18c22eb0cde69fd5ed334f87c004a467506e9fb00db0e66d3ba24d404f64f11b1638972edd9bfbed6168053d192b11008686c6755fcd3b7032f3f17f7c23435067ef7ad86b601bfedc22f435693eb6ef9cfca66ab23ee619ef3c0b5efa4490da6c5f30fab738ba8ee24a7915f9c07f366b1f7a0907b9e91561da153bc346f45846a57d26ea003e1a92367713f10c0d460e3042a3f6442e0ba893eb785dbd52448fa9dc0978c1e8cbf9d907cf018cfe8bd00d31d0697f572df202dd430a58fe8d279b373b2404c21eb7a08738dbb436d13a2c5d0757dd7004be85de250f0a9cb97c4a82338189058f9ed27279c36f7f12ec470e117c07481a4b698a2c13af638d98f1696fabec8dc97238cf9f685aa8b5ddec8e12a5b0cbb59a97487649bca687551ae35cb54011ad3168277d21e3d08170bd8bca1d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
