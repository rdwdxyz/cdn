<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66d6ad72e1e89d0c1ddc5ab3e6499b882d7cfc77e76cd6989cbe41f9cfe6acb21a9b7b25891298aa70a5d3eda0d3c25d8da1c1b6ed4f32b4d3d4ad6b107fa873657e5eeeca8c8b89eddae431c433e2900cef5da196deaf84f3f90e0b95de9a24328caabf87ca6ab1928bd4a7a6fa59447a7a5da4f4eb0a541dbb084518784af8b2c4a9068666cf7a18ef914962a41c9dc7637184b44aea12c4afa6c92199c86dc16705e9414665f3b6ba65f8406befbbf496178dc60d83101b2dcd6d344527df156422403a924988731cf6dd91d24c83efddb9b138a3c24aa3f0ba02bfbf423b847e3097d00e8ef6c7aa226fae483fab1838b8da5ebc1bb93fec79c211e4243f99ddd52ac4c232fc60953cf8bd70bc21b542bd6bb028e61fbdd8754b6287fa537230ec628d20937e7bb7c75934789655c65b11105576aba1d49f0b04f1cb771d420bed2101dc01d9530ad47fc7c3f434191ad2aba2553c2bb9a907c061314074db631889e4e473a39a81bb65b0889cec55fda6b3e4ebd6b14c22013f14710054626ebe98aa982596e3a362f1d697e15c8d2d98763fc8867c70cd0ae48f98eece4e0ed821668b951707637ce56c589f6990dc4b6eab0b1200136b5316cf4d94f893a87c2738df9a6822885ca7673c3510c25ccf7f5affa82ebf98e6b18b475946b35ec87bc862d0158c770415894104e6134bea5326e6f0a30e1235a2b74884b2735080ccbff9c4a9c6ec7d261f979b29d7f8d1701ede961fc3044b8e5e49247360b10053c5cf8d588281480891899803b4a56482ccc1e0f1dac4d265c1bca98aaa0ca60a24bc2ba8bb14018951bad79c8f4bb614fa44ae37d862ebb5ab1f64db46b79df0548ce8771e5674fdec43884a7afa21a68c74191610a9b1497d265e56261254113e1190d33dfeba3f547b46b0c4c10ab481828e3231c2d94a7166ba4d95b414c062735daa19130bb4fe135e802008c2223059f1acc3afefdee2d9f649c862bcdfcf247bf15dfc11a03659c2513deb90812e0579ebd3db725e5970d4c6194cde248ad6ceabf876f3603ff005ab07ce20d4140ca2d87f8874314777ae362fdf162c663a005fe3985080196628a5b8e683d37fb25aa8917460e80abd2d59c8aaff845c5f355f2861c7a5c1a461ba2439910fe476b04024dd6b0fed3131f7038b16c3dfbf6593bde39478c63344df90e236b41b00264aabfbf960266b73bd44ac8d3e9825c6e413f6d3a66359ccfe756fb2fb95960a20e164b369c340c0a773aa8e82372ab5406e6bd83094c3500c8f220ca7668a0ef18e32bccc94337d73a46bd5d639883581ee64cbbf862691a298d0b77294bc6dfd0faa92aa2c28f15946d25afed53cc04aad8c766201c759c590b25212a2fba515960b192df8b59f5be4a5a863d7c4331f82fb03aeb7706b0eea909ee7acde6687bbd5dc53c8de939e94d99b55f44d9615d10c1282bb757ab407e0ee189b49f09e42d8cb47761850099f0df0117f359080618966dc641604559fa1be2daac5f3b969ae0482b71c6d0fe748cb9cb2c280b75b6b2310fb70c73b07ef052fff68ed7b4e9cb03df2ee51677355a2fb954b784b0e0aa2b119b773ff4cb33ae38a8211ea11c876ef465fedb1816b24e2ad93803765f949af9fdc4bfbabc3f503249a873433e2de1fc27f89118a3e575b47166e1cf7511852fb388c329c2e2ebf9f54d7b0b909ad6f31cd32a709dfb8796df8f01a2bf701bac7f79d714cb0492e930ed07e14dc98de21db1fb6e1b747fa59f22d9602e7ef6fc636b889e8b47c7839069e71c8bad2d3f8ffcfe370ca05cb53c533c008235b1205b2cd5cb13e97a9cc36d4b64ce146a1a2eefe426bcb6e6e0bee85cdf555c06e86a8f8494ee5561f2cfedfd48a77ace6a25a1ce18f7d1ee550bed17595e661b21d7d1d04c8a8e719dcd36f6c6ff5a30ec7096d4e2cbece5443ce2a322a554ce1788d969a70174556e94fb528487926ca8b144ed03f479575b45f70c9623747b0bc865904310a7b3e7b63c26bdbd943cc1a07826c5d8758bf08dec05101b945fa9b7af759cfa2d0a35884cd30ffc331820c99530dd9bb2e5c93799ed319a725aed7d32c4dacc98599fd5f8c07ec6e6f5e5a749a98e2bba16c6cbefb79c0af0c6487f94ae07b031ceb3ac190ed756179310ee6452ee27f8b9b8cc649a8c9e94aba72bf26560204902c871871f91c79709494a1255e998b0e66497d27de4cfc168e4cbb9f61c1a4a435a3a0816b8631bd84f038c9143e1e30f13af1d1a4379f294eef883dbb949e1ca3bdb9f11300f990a83d0f00f3f6118c8999c54f53e67d06373a05777d97f3cdeaf045fefc5f121c196b39bc1bc371bdfa6f5f30388a64ed02605d943ce4999a7ca3f74acb6f20db2c71acf74fa79ec164caf720872e5fe21f20fa3125f73c248aba15ed2c7314f31c9164f21c7eb1d161a5fc7756a19738da758a370171e312ea7c1ae822e5885f91db27a7c7d46603570a640c02e2b2cdfe6876b2f4e1f745ea0ea39ddd280a90fe2e03222c934fc88d0ce1172728d2cf50945067e720b009b43f1ca11b64948c1f595f37cbd99a2ad3950d9e9d95f2370c6f4b421995f64e4292265bb4d7379e3566e26facfba5b2828d6240ea5a24009bd519a44a3a266cb24c6bc87e5c4fb142f50d019baa2bba2016ec3bedef02b106015e06627cc15042a21d23bf8a9ce4704cde19570d334e9ab394c279af55526018fca7db236742770c84cb08ad1d37223fa7060130fd51304e65984b6426d9b2ccde79193e6e3f9ed325cb3ec94ff3f60ba9e69534e17ef9bf7fb79b5d89a9d50a4efba8b49e5091004f2e52c10394118efe32d4ca1c5a26379f6b0472f1238d1335e344fc06581ae52f0ef81366abe3a915411a03a98e868450c49892eb1a9a6276ade50b1a0ebf58155f4145c99413d9690e4ff489534829eb0259344b273761c0ed1dbcc20c08660ef51bd705a8f46c2f3c6eee2c5bd37243e8f7297bf181b7bcf3decc9f35654c39682cc84555ca7c52a8b1aecd683261b639030597b7cfb327452e3ab496d33ca45ad1c2c0d781024b71783625ee4f1e8b2c52d938a80fa3f70bdf03469ab88c38caab42dbf195f9879b0ec40234c848a95b3720ed712a8d7ebf5734b03d4b2012336d9642722edeca3e9fcd1779ac60ac1f0a6ce51970fbcac0425573e3b23e44ca04b64f73e64debaaff5f1c7345a08d471b3956a842f92e19e2f01578dc6f0eb89cb504f04fdb79af49c21139ab237495cf037d17100892d944622c9dea8768ec5c689b813535ed97face9d25bf44d88546cc659d42559aa6bf3c32cc264c480af1a83860e7c908aae1b98f0d91ad7fa1d2fc2c15353c592e8e89685645c467583ed1ad1a1f50d2450e9a0a5415943a8e951eabfcace7818c6d8a2cd5db43897cda55e0ed9ab4b3f709b120c6e133abba8d01c41b7c08219d7c3210511def8f3f74b1b75db0fe64583796d02e236f228d9079a9ca536e377a34b30438ed9c1033c47debeb60825cc1d863d6a34eb5adf4b0431578437e0ddd70695fd3734601e1ec0c1076ababa8ac4295c570f29a87b647b0de75b25d07377f2f3dc0cabd89f45ef393be0b6a9f168ab3490de07914c2eba4ac6242038f096ff188238d708f64cbfdbad0b1fcf1f527a7021089477d10309676c656060db3454e1dff585e1efdd86a33ab68210aadb3c2361a7ee8cb932a7f588f775e62bb6fa32088fd98984c6555670a6299b3b695fa1e1d1b1a932771cd198df051bf7d8593a144db8c88d439341312001aa2e49ff4ee1d11443fc0810879b346a1c5dd2df46c9c6df20e4e88d2a7dbab3e756c8f6fb4331c826ef295a785b23a157c521084453796f11030447272ef86c68de9d11873250dd5af2a7803197a14c8aa8e904c2536340c4592ff7d693b592160ca094f3505cdd5cd759b9308e8c242ab3687208b8f506b05e4c991171c338d9ca66acbd6fb97d84901280b2bcfd3c5c915a2482a55c2daeaa31cecf352084bb883feaecb25a85b6658857ee4ebc6606ce72509e2998d83d87ea5ef7c43963f867e93dc01b80c64cc3d6903819629c3186ab6b26052c8b66f5f1f6952f74f8912989048dea0d74f4f8af11c11c10b1d5dd786600a59ab5025b6408ca96c5b5c1d4c85057d4117268afc45589f107c9c9360225182ab7070dc8aadd71c5b6f7b0630b9e181fa6b73b411425cdf94e1e94028c08e1ae0f47dd76453e01ea9c14dea392c6c50ec359a76f485fd8263cf9d2a9f594c7d21d9ff899e20b965967b0fc44cc774a70304dfc8b78a628b6a7852b5ac1288a813e3e38c33753e6e0fa638ea42538f2f6ebe24f9a4cd32282ce222f1d13196cc92642ce8360cc966f6546270bac7cd8e1fbfeb58dfecc4c2fbe6e2a4bd9d4caf0b300abbb6671b9497d2aaa2ab6e74ff2fbae5c84be60f292b3ba4c7054e3a44874ddd4d0d2da21f4c4cf1f47daf02b0715f7577b2a17636ff17256579952b80a266d1884ba8c3b1b3aadd3b818aa9b86dc82e311f4eca36a7763ae7545ba59e96dfcbbba6d14043e8d41a2acf2d0dc61315e3fac3c9d1f18efebf35591e0807313d4fa267af5e44358e64b1f7c7994e98a4497ee60a874bf697412704dc122288448df67e29f11ce1e972504e2a7566575114156e70023fa0fe0d47bb4cc97c6483ab30dbe215cfe708f444d680ca726894ef88994d8b1c0a6a8e6cd25f5053bd78693cc1709a35cd85330ec8829e54378ba5a7918b1aa13bb8c2cd38e1dc43dd5ec614fed32c7240282c1556661215a56366764283550d9bfd761fbb7c7fb6848cda7dcc57119dbf33a6b5781af19cbb49fe2ef44a9f96e55adb4f728ab2a8116431056a64fb2ce2455e7ef99531c475ba541455093b66858616078ba7726a9375fd1f27c1f377f20c6a538691ee306e6b1097200f454576dfd4e55426eb8070b364a3158b439cfb756969505ab655337c02561c12d4c00e04209d38ba3f89b7831ef6a49916c04aee29c4a51b5d4c5b4f4d2c94d465d868957f218e8581675e078273bb7aebb558566306ed299886750e8e4b9ec1ed2bb021fe347bf6040381c4ce2ca8218fdf8f45c190c4c85e4e0ebbd91ace537106e6ea1a68c403602280a30d16c23bdb4886999438c07c0c3244928ba6d534d9db42a62e0fd7fcc2ddcdd19ded74a509f4363428885e193061e104d7d76e1a62e8af6ac0d568ba6dfc47862f92d98864b2c1ce54c4394b78845d227bfba683380cefdc93aa420cb55e95436f319756a5b1c28dcf6b1a52446cf46ffdf9f808846827f4125a4d8d80e546ee3a21a2d5cc9b5a9d41494ceba5478458eb7c21aeebb2fc569dd49f2d15efde34214d39074c4357b1edb36a893690fe6049348275b7b022b2a7b810b99b263b295f0783633fd1f910d3a6ae9e0f35dea3e9cbcfc66486641536968ae30c1092e3fe83ce9d83256f8cd9b9072cc9fa7b21374b1b3a840158a8ffd45a326b6e4d6096403a16a8f63430c4f1adb894946a8f50568bdc89dab45f5a89d89a2288a5587614955e8119a1ced51a77def52b0d470fc8e9fcedfa97fae04f7818bec2b20a95e1133a674d4ed7eb9be2dcfa3f5970c856f6a37da3a97c8f439c841c6acc9a4514f0ba6d92742162925df60b0c84b8b27aef10be0efcaafbb01179699007ea7e9c1b47d5b9b0c7f70d2a3d52f5cb471f0181d34faa1389e3c526524aeb21e976b23dd7f36025f3d3c29906ba0fd3232ff8f13eba7e9cb398a7d88775f4d2ce57c9203a4c13952f957d447a7e48b288071e4830aaf8b43dc7bc8bff9c96456bbc3d44431133ef306b86f9b2cfb46b9dcac6c48a52c470e692b3b60e5b012b0911f1d81d416c8c72d94c67a3be4532840781d0588958326041fa9a0b0985ea12af08fe6fcc5069702c18357e2230aad5155301558d4eea3479439a630e63812e9219fb9c46f5d1ece7eee572a52f1ed7c752d2081a582b3803f01411b9cae7f9b190b055e3d77b9cec4a05fcf509ecaeaa62ec05d81ef5ee9787f0335bf54d4fd96ef101cbeb34951b5572a8caa1972fe8522bbe83a1536bdd456574849cd6cfcf7d1a12a3da4a24c28f0b27df8b8d23af4c2d3ae59f1bdf5df535c1c5263d7d9545d90c9d1b270688268c284ef5fdbec8d7b29c67be85c8331f6454699c2d009018a5075accedd8ddc18af045b7445963c8d2d88893f6d282cb68b2c6656c53b3a098bc2ca7cae2fa3cf6a5b53ad4c68b3c7513f8a7a61faaf3db1a5afe5ed637486bd81f90f43bbe1be6d1f3e8a53dad4fb89fb6808af2c62c8575a7ae583157af83274c35e4d5c8da4a8db8a0f16d282e29a1b78bbd9d6f5e6d94d63727d4f92681ebeec2eacae74d12c7efff68affb70e00be21b82501a7b501865fd14a6cc0f9020e62864eaf69f89b09778f22428257bd27e69c00b1d603f7b569aebe407437d4b6f5c80788b4b9dec82d61fe7af03cd0a0c0944bdc53dd00bf433b93aa3d9db0b148b838b1a67ad16a29f86663bf83c2914cef623784afc983a6372b193a8aee22594f7bf4b98d5399cb70353a8b81ca2a9de859c59f2b3447146a2fa7c20fa457cf86d9b2199773d11191e183af2a6f90f566c97f1e45a7595f584bbbbf720b256534891bb50587fe3871a5f3d5ac5fb3cc9d5bfcb840f9f3ba279e0f21ea096fa0ec844f7f45e39f2156e9ba717e74b849f9b20b0133c97267e45db0ba1886a0953bfed92bb7c5707f44cde1d4613626f6a42d0a5ccd3b1a47c4471852d905ce49c25103b8c193ab13c33901ff9b44235b36e2f9043bf16fdaef600e1289a9d6205b6305eee6ae4c597ff0ce34ffd0a82f2e58a4133b42d5fc79575ab5b908eca462385bf1af96e1d04a3c59ba40b68e0405fa8e644f8f0fd9a5df3f6aa32e52bf30e61e0b52a38a9fdcd89e07df9ddcece86ff12248b47aed262e861d72d45b5a42891293e56ba5cdde3a636232c822930b3a209d64be72516f491f532052c17ceef775735946a71e5759475da1b19cdd2c002e2e0280db0c43497de3ac4e8a444f22fb680c1ee2542781ea9fc34fe30416b8bea00f12157b2e9935f0443efe6cbddddeab9370300389800c15c82fe18121317f2e8b9eb658df9de46fd3b11dfc63ec0897a743d141a3f5b3426af97c963cbdff13989718f1cbf7d979daa7f50360ac5e86e0e55f2ff22f39d5ed6b504bda8c08874e7819788dc38aae924a20b3fc84da036eb914f24d17d623a8e9bec40dc9b591bf5e99c1adf5bed168de30a8da54d02da130203ef41893a06b4cb777b883375f42821e193ff73bb2f94a150f75d510476188c07c8252461f99681076c6249b81508ffe3c4fab6b3f3d692c60320f2487a489531f35808912fbb4a71da908d56cb2ee1045318ecd2faf170053cdb81ac2821fc1eba5757ab8c5ec66dd36b628ca43027bf19364fdb2448b14f3868b6fb12d9f0db9ad6f2557631c388200b72739e0ddc248ff6c857915c443f7945b13a570b1b26c1b241be5886db44f09d5851e874e8bf742bc2ba9b6248f728cc4a192cd1323cc7f655343e95b08916d8bbf1cd0fcb6b199d405e396be91d3dde47fb5d71d2383b897741d0010808a77388d23649237ae88eb862c5141652b913844ccfa401b8b2f99dbb83312912343591f0f09adc5a9d3a20f9b3d827f52839fcf55e1582101e993192f49922f53c49019c272f011f8d3c17c0396b24842b3e27968945f86d1d4643e0defb53886e11f176ad7a354c9038d48681e63d9bb615cbb1e7302e8cc2fe323618a0c64f77a332d2726a047294f747c5a468998a3632fc640cade2770a2fe55a7caf89ed5decd9e3de79bef4e37bb59567dceebc20c6bd9e88147076992d80261945a0bef8d9e59b753c6e29942e080fbf91ea612ff9b893cf6f7a0832cd5815a39cbf849d9d134515cbcc3b836c8f5836e972e14fa0b1ed5631c54f1b917d06c4cd0b06f0c6242a42aa04deff8062a284b8ee29c704c05c5e0ce48c6cb7c7565baf2e1519fd101126e1ecabc36e53863c78547bb62a202d525afadbeb4d2f97a6dc22f957b3d215f3d119140ffcb3380294d314b9b2620c340709b13d86a7e94d6e5c40972f2c70ae2ae81c6c06dc1be9f228863b73dc84723e3b5cefb8b74f82a5ddcb20989c6fa338f839e230737bef404bd66170232d8f1b1dac64e12099463396f6bb5c5351643ca46938fb299d52ea2b17699ed2e80ba52bbb57b5696bcca7b2f6e4dcc6cd912b83aa5e266ab19e9a27f0a9ec1acb37c5d2f682706651ed0b36ceddae784e038bd6a50f9b7cc954045fa1fba641bd11369e7967cd17032e7aa809d633160727a3ba2f826e79eb4c9009f45c762780e457022ff5db6ad8a377d44b2e3fae44fca9f47fa9d9089ca601d6c5de90392378f5a5e912121b8d93f6da906060c7cbe90136ebf58e41b9bd27048c4dbcedc266df280a45220416f8deb128f1a6f8996469b2328ec07961fd73580e5c534b53acad46d74498125be19be1b8e7ad0ecef54f87bc3a6f3f6d2457452e3fbcc3ba06ee9d723273e2b68241fac7dcc95e49c5151108f68314d58954d5864c3bda36247ed2b3ce7e569d008b7ecfdbd24f0f2d3c0a680631712312a2a535ea7b148e2dab6d779cb34f7fc49cb683c6845670e07a347bb717e045d73a9bf44c7f7c21bcb8666748b0b100c5d49910bb3c702e6dad688264321eb0a6793144a79170f8effb3ee25dad1a629ee4dec85f85d2edd663191e05f70f19f9be11a95af9b8dd8dce65a33baaa9e733a477d476d3c2917223e358e0bbf536f96a6f7e1d96586c2e43ca087c03311ad5254067d6fc5d2fc2a0b2ce930e14107038f49a288f9d2d89a8cacfcc05bf2586b65235d387e6ddc1d95c8fc3b77e8aba74a3897e0b180c40536b128655f698dfe7e6e9b2b173659774c1963755b48e7dd7ba0e873556d56c0f310bc0ed462082772012922176358ab0e2ee4e7f62870d534c43647cfd4d62460aef6186a09dc57e04b455508ab29c55911b49646644585217d2a0ebab6845854de7ecb0c434c6c3882a8f47ca11c890cc440c0e6ac2cbd1260c7164841ba90565af96f6c8c0334e6622bbd2496f66730fed2c51adf9816ecdd0355a59a976266f4432595b05a89bd7be56c8231de1e8ec56a9c6fee1a97b23803762ca810e61e283822dc6fdf95dfc27d6960f176ffd53219d5278387104367ed7e8683791574bf4670118bd4c0dbee8efd795a5bacf6a4abf946bac4ba307d068cf68194e08a923280ee761672fbd310236c0c0b95ce4b1f6a78a3827a6d3f4f83e1f15f1311178c34faa35b9c365a6815ca1341975e5e3394444cbb9a703a0c2419ae56b339c65ca470abdd6b4885aed4ef7de3d59cc7d5ace78fdbbe48b4859247b38ec155b325c643143f8f2775de115c7c892ff29e8bd6b09696544d5f683d31b8b0effcf89b8e952f2f4f7fa6f435422b0a8cba22ca7411f706a7435a822c1c918ddde5edf2c2174d7017ece27f769e11a6005fac10ec31ebfcb665cda57c8f56d3e7cace081c0a76042eda158ff7eab3df98001417d28e1c87e913408716265d7c903332d040c9c776a240629e03a822f47f93fe3b5aac1a1323703e1b781330897f94a93b0c1a9a8e2e11965493c432e44ad4baf5e4449253db65fffb5b77ac7ee994c96adf74bc32900de9b5b8e377d5713042bef2172acf02a85fc246c0f9251d7b55d5263f2031585ce1e869a4ba70ec525cba00ec5a7e98b039f46b5af60a0319f76949c30f2429c2e24fbc8725932f71c545a9613f907ed989a0bd50ba50c2850b77e138b772489a3e49989f06fe55c0fc3be580ee008241031fcfba15eabc426c70cd8a62acf46029bfbfffd085c95ee678993f14aa70b17cd02238bca6c4393c301d79e5fdba3589664cd3e7cdc5cffb70315c60a6cf081ba9d7af7a7d9ad4ff7752383dad3fab62d3693d0c22684c9dd0e3740ab2dc21e6617a1f6b592254943684703cf2bb60528e42478f12006d85ef9747c6649adc37872cce2c3f6a840cddf91c883fb09996474061a8073221ac81f2f81425e1af0632cd61cb7abbb519d40b844c91b701d244fca8ded30fe6815e1bd2eafd03e00f6564245292c920e6566f0006cccc5f449722add0b167cebbb201986c4ed35cf183d631d751338dbd516ca44c652e5da2e2fb962b12986731d26ac4402769f98e69e8e9e084da05c3a288e1090fafdac7829b4df6acbe2c41aed22de283e657699171e41cecb148286b3b96e57a87a079b8a3ab4e8034bde9aa410859ab619fabc1d84dae963df218ce3ec8fb94d57b6ec6ed12f54145debad08021ed48061f67ad528b9d620c3e814e10542376c8a90a60f61d58f8eec89cb07d8933cb2bdeb255e04bf959fdc42bb7987255d8f55fe8501c4ceda57d7f82802a1e84e6c97b96c3987d438a1ebb10abb92e9f83746a3f7beab8d9ad4b5d523910f432827163544bce9a4993bc918c1746f4ca9348c0450e123a839e01eb9c96356d1413883643f5efcf4798cd8b35b949001fcc05c00bc15cbc96ead924534683bf6de5220748f4d7d613155e40634a2290af4394e7d98f94e95b0d0c2da6b95e8f3b641cd9bccc7dbc387ad43dc3c7891c8b012c909eb4be8d298acd2449944ff069e60f464a93d4ee2875fceb1bdd8bae9afce255d77a668d9f8a3a548faafba9cef7e0dd5eb22d500921c14b42ae03e168864d9da5078fbc1ae20ab910093ed609c05a1ab4589516b6fbe2b6457091bcaf8c00658d72143b4129d200cb496b6e0526dbb7ccbcdf9f5608eb799249be9a3d13b62b389377d3644510f70419bb75e0b206f474a2e34a9853550dd5a46a7a78655995fdf8690003ed38ce36b8fb637ddace7aa4a0e9fed2f0c825e0891a232ee30bd4503b730bf643c074e38bc67bc51e72a81bb68a9eb189bd43fab0936edb9880a9e418cab4d79847eeb07d3077a98ab2fdf737a54896089e9a49608c877ce7fcba318250afa67002de36903b73f5361e6fdd141c524b97fb340a46e2a4b6666921d681da6f005a9bd08512da739d46d65bc1111203bf8f9740fd9ad0b874d7377bb04e05fd888096d8063ff01c97cbf5d6eab0c862fd8b33ba0680eac83d2f9bff2ed43c79f4c426d48da85aa775c1948ddb35ca239eef7875cf86c8b527bd48d4f91d38e0a3184e7819220adc5b388c800770f5a2abab6bbf960eb927af00212b2eb2963c7efe775bc06055bc4eb6257893f6b238cec1148e91f55567f716410328d223025d3e97f85ab07eba17ef944d314c182910ad971cfe455caebcc0e44ae469316d6f43af759c19d950df139daba36362693b06e9a37fdfd7abc2900a99ca3bd0c6d69cbf430265819766ba0d3d55022ab192115eab65ef80de32dbacc443050e751a5d919c975ae086684e31484a132af849d259bc0d8faa339dc63c64df896f7478b0f5f647f165f14a1cff1424451f76fdb56336a12f15b5e846910ed213e9a22eb95e39acf4efdbee92ad9b1fa55729ef46f34223e10a796880b63869a9506acf019c0372eef51fbf8b485936a4c5f90ba0f6b16e2a9bfaa5385117f8e0e49152744aeaa4b68094d2743ce8702bb32bea912ba1eb3fd061921ec7ed3c7a95b0779f19ac89fa6c7c89769b236387589ea54790771e97306a00978573c580cd5ab0870109a2d2f04d9e95245c8d382eebd9f724b760170f2fcc8f415dc8b47aaebe47a254fbdc6bf28db2482d9fd07ad79effe070161391068d6ecef6dbe1e9e529bcb73516cdecfc2ae87f7c7945d1b181060cf308f8c026e8e1be89010e65a971741a719b7034b2b8fe4778b81944bd1455490e8200ecfb737a24a1173edfc5c5fee941a92ee093feb3808f07ec96186dadb48d54f7b6ed83207445ad3b925c7840f1e895d35a08adfd7d4d0e6281a07aaf7ae6085c77d1ab50531d15c5acfd66a338296f35ce1927e973962bde4790ba694c40ef2aba6f4a7a428dbc323c61d21294c154ca5feca0050ad842d200e05a7dc2a76d32599c89937ead24d88dd702276da3b88b145cfc8bdacc0e4be025ee7d271b9cc578654394834271301f1a0b1bacc2e625c895bfe2255abf11781f5a4c83687ca84f9302e18cb092f90aaba7c7a8bfac34a9b258ed4f717ca03c45acc1ea308ed68405b9a8713c4deaaf5249b52ad70d72b62899d6d1046716e605d56b2fd7004db4d70c8fbc640a3b058831e1bc5447a6f7d79ebb9df468b32c5c0d6eb1865fc316e173a315b88a1fad1c6ddb58143ad8bf16c5404feb4e1208a7776eb17339e14a5206aaea38c9e3aaafb6ed25691a39f97e882ab2cb6328d55258406f6585a41dd1ee207efa5e7956d4d876b0e18b006d9ca7d28177fa82b54862d2eb80e2980d75da418cde67980bc2ed655f95d0ab9ca78e99863ae1bdfa7393e6fd99cd61a851f5c81b87e7124e24803c262cc83fca6f18448f82cfd33cec2236d9c95a367a45663c9f3d37e0cf980e47c919844fe9394fe9d5dd962708900a2bffe760c0ed5a56945cf82d3f547005decf5db006e8070a1f1094cf148cf5917bce78974b520a15fbfd1cb9f405eb031584d87735ab1e5e02cd7d20eb8fdcae2d31cb3cd605622c4728676432c95f27b5d2d5837d7a90c3a6cd3f2594b51b4c5c69f9db405723681b85b7c9140f8388b874c40377e481889d6d6ef379bb10982d88235c55c97378a4cd5f8e023629dd1707bf3355123c755c7da3c941c0ec9f2fbf6c934951cb026b35ef6adce5a9eed64d40f4014460f9c258d2fd1f189f5f8fc4cd6d35052b7aac473cc88a42fe84550f574e15cabd8a93e5a7a19607952ca2f01d92f3a27699c160b55fe4d8021818393a9e6f6dccc71a81a1ac3e51a596cf7e046a7c6c74388bc142e4e4a7c4a1f66bb24962997d26ae3efb31329ccdde829b7c5e0fcd0c7ba54c6bf15c01e08465fc34f5d586c582e6e0e4ffa3b09c767428ba3193de2a875863e394db413b13178e2c06425315cc941a2d12f383ff365dc2f6894c7c57dbaedc942c17612bd4635e2d087bce75035783c52932616b6610160e88d3693d4ec13622503db19159089a1fe2295f0a5ce703c4df3a61811b75068f64977eb74ef97dc77d04ab8a1e00ff1e7ff3ee284869ad5f9fad0ad28fd207412fd1544ab543d13974b8bcb6488a3b38ad5070182ef3551e39c88266b9b1a714cb21db6c12e631da6d642928d7a6eda740de7376d5249cc282d922b472d28cc46fe5b98d4482c5ec1a31419c8e51f0d919c12b9bef9a6b9112728c50e5cc094baf5a4e4804226e68ab6da03f92bc20decf8ae03b70fd59c618825159d120d76fee06f3458cfb9ef534cf941a82741234013e3dc47f28cdb7679c396d1b1132e84118b25770576f097aacf3ca034188ed07f853d7b575958acda62da4b1c204e34bfcd089dc7041c9c6dba3385d30874b5b3af6e18674cc2eb5c85e09b0f4d5ee4168c21ede50ae1ce954bb11e5d35bd9a44d2a4c4b6633f4dd2044d430d208e7a8dfa19d8c5f885140919c36ed783b1238647410a5562d5e0b1d154c205324f44d9006ae7c8744c289d18e64cceb0afcdfdb15754a8bd1a1fb7bf15757ec4619a143cf63914efc85dbf1c6f66baa624f68ac78434c805ff94f36bc80635276008b79cf325a0053bb7244ec067ee06f2f6a56ad8a21d78550d959cb7d028c856ae70496a53e84100f05ecb774fe52a4f38324f82bc15bd00901debae6fd45452b0528a812467a2738d8d35836dfc5917333c7954ed5eef8a7ffd74f87a1bcbe47cd33e4bf450191aadedc2df5b2cdedb5686346641811c148b2e315c8e52beec44e263daa6236dc58e0933a87fc7d83fbc0aa5f86038bb5e1ba581c795fe10a4d3a3f2df75f6ea6b32b4bcca97c3b32c31ea6e2644ed90cbff696cf31c5a793651c383f4d4d5138dec32601e74981fa02ccb7edbc72bded6472e9e33644835246632613a3e49693a2182ec189761d5af7000a04e45f990495dce04e0f9b541c3c7333ef38c290038af8333200f1eba5fdc7202955ff0f94d9490f02b73dc4ef7fb779623102a7bbe52b0a2f1c40287f0e7a457ea339c5e81bbff12dc3a19a18f7626664a7b0dd77e00529b87fb6b701c34311753ecd0fb04f671ee56e31c6bef4a2a4820dd2d15f13e25d57ee6f8fd1bb6c38eedd30bc6b0d57c92ad242e3403b5998321c78d82a6cfb0dad3c6ddf502c8ef791e6da12c20d40fcb1f08ed61894950bc0921dc28165fa73b9db6096df94f47d8527b44dd99fbab5da2131fb293a9835119e945d87c4ca496ddb2803389da11591581ebbc713800dc1a3625a847a38ccd5d4a172af29d714a84b4d65c331c1ee6f3a8a9ed4dd5fd19e92cd710d0ffda3541da3492956d24f3986755bfc376711b6d84f91a7796aaa29e93963aacd5aa18e78da71d10d3453c396e438bf5fac6711bc71546f518bb7b6f0761faf97fde68d00c181b3a608f3dfa960575bfd069936c1cedb1cd36393df4783857c9a804eb6b70f5e89e1081267363209bfba8f43a3993711b1800a20facb112c1f6b76011901ea1b5914fbd4f2b45371dca7a7bbbca4a8cf1f9d84b5eecab2f27cc3b9f2f5cdc1e2885d18b8fa4312486d138260ad602abbd0de453192333194f9ff7f463e32f2e0d782878b5d8eb38e45fe5391a29b543d63373b9b58b9ae97b48ed8ea89c88193dc0fe1d10496663bae682dbde9321c3c97d8af8d22da3f2848cf86a882bbc2ce6bad5c5c9202e8c45189e37e3e19e5f3160e0f880309149a7e327d4a0a7682c9b68c987eec6271a6c060510b5b198f92a26b6fb4e822111f650f14932465f8a697ed84ab9abb62bea5ad6756010ee00ce444e5b24c222ba5b17679a4d67549a2d317d4066d355bccfbd05e36dc7be096a1d851444bf62bca993a6d98dceebb2050c8509dac4242d6b4a8e47cf099ea1ebd44842179115a010a6e27cffeee9f32dea54b37da000898442f9c37bb7ea4c64c8768461f5a81c2f9586970a7f2584e0d9f40d13149e03cfe8b8adbd24acef5809d672312caa6f595cbbfaeffa22553f356da8f0675f5a8c5163874b8443efcd45d61674089019c253d6c456963995ff3d4b4e81e2f54dea9fadc566432ebc710b68a6fbce522c157fbc73b68f1ba2fdaf0bc1736b16db4e7300d3b9df29712b2f8d7955e60369b274a6aa447ef653661025c6d886acecb05d64817940d42f0e7b0ce5993811a2003ffee7d152f0176188bd7e0a63cf2c22cad2ead8f6bda2a26aaf4d3a94b124808f70ee33f93ac55a2d29c30323c8f81c58914627043782a692771f9a02a504dfa37e7af14a7370347af8920fd264af41db03a22954e40da31a104882e80c4542fd58a1d20f133863e214556881e94b756dafd1643f2f8e6a82f57157969c26a34aabd511a6d6fd2daee3967feed195f553d511361b4b554f8c231751f8f3c777fbf4a5197c7ff05afb5078bb6c74d87775cd4da56209fe0848e34e6bcdeee23351793d7bf76c10975ca6656978b38b8c635b231381c2dda930ac4f115affec30460686fdfd1b58b26dbe92390217e8f451268f927519aa1a8ff80daa1457a5829eaef763d92cf660447ea7f7fdf2d2525af19b75f6a5b3e3be31733181ad3a2e266c5d00c375fcfb5db1e64b26734880c199fc0043bcbe0119ec01b61f24631c2dcfb24242da4e3b51d8e90fbf84ccbc1d8377a29da8d5499e9923360aa2a0f34f4a25515716ac35e46aa0ddaa1faeb505827eb6f71fa3a289873fccd3eaf10479417d2ea1f7f202459b6136c30f3389694f2edb35dbfbb4ad56fc8d5031c4c21eb048f4d0f748a4ceab6f24a24eb88af68476fd77452bbe0588f72e9c5bf22dcc491bcde4948b61c4808c2ec20ca41fcbdb750d1170559d47ae03c3705c9bd9926580e2ec2b6fa469bc28de5ad6ec094e4dbd07d14fadb493aa50a63b669382a8354144e8110bb79a02ee78aca112bf95bbdfd12b89494df15d17a3501b8db38411ca53964f721aff51e46a387d847d540e62efd4b15816d9601f8bfe65b0ea50ce0be8f74fa6aa00a7f564742999b7a226b531c10c3115253173b41c68191e4087e8c3f9032567618767f40685e2de1136132f2a324044657bb789836eb02292c2a90f07860fc3a1cee8d426736be750f59a9e5377d3bfb9f2b64d04279d9729066d704309413e8c7e238a2bee3c82713fb5d77f9ad1af0d0cd3754f1940601bbdd209e6d4b5e23d3c9a0a1fce682fdc1ba118fae1be1d5c7a70d79e49ae8ed79aeaafb9943dfca694e0ae4f4b40e01bd173ff12f97c0d296bcbb27b7d2b7c776b33123c1ceed54d957b7586f14332556e1a585b2aa03b939e31b68395339bca681cc3c6bbfff85509e2b5ea51a941586b77142e857943523f8237b7c55296a02cbbc2368a5aa0071f3130e61e13dc700f43ebcbf09af3e128bf18c21338934a4f2adf1e244e5b9989ccb69b284304f9f6faa5bb6d20045add32b0a02d7d0eb38e8009fdee2b83143015f2899120c7cf0997d7e21d57c05c0d67c79f7b41655af9fd7ada9192281939d43509f9bf296848c4afd113bf98c821bff6f715badf00be89a7a4f172b4d2c880440d30b3425f44bd0a806ba412e07b1565fa4d4f89bccb4607bdc8b635fce7cf5f20c8a8b3387c37c4d5445f5205cbb8bd40b7d8ffd30537cab0950fa202cc1d1c18e757fd6ba43925c5a87e144d1ccc9c71df9d2cbc7d242a00dd40f96194f62fe72a037ea23ce3a133fc73484f161702d3707853eb68be6ec1e33c053ef8938e6dee0fa536c65cdf0d29bfd70ecdaf4d83b0882a1be1b6e5ea3db24de41e88efbd9881aa8f030c4f677de87d4018834bebc31af709e478c30e696ede1e60cb96545f6739e19ce77e7c7c99d845b330df7d2af27ed0ea30d672497f2772d5f486586a8386b9182c466fa04631ce237aa6acc5f46ce26a89c6b4c661a66d0b74296f43dc2876019a2f8ab510904110e53c577e2a070e0239a1fcb011ecc8d806d511aa2cc57cdc2124d5090a77b3ad3da5b2c5bdf1876f78c326003d1e38a45380751c680dadaa7a9bcabb8eb9e7d03bec7326ca0f93485bfb9eb9330bb0ab00adc076367b40c6b2da3624c7c95b61174dc0d142b12505855dc0ddf5337526daf8c992804076adf060c5244eefa8671470836340873c80c1856b885528dbc43ef17739b747799da803a8b090a775711bbd6b5fbb702ee411a5e5ee90673040313ce2bb4213412151df8c3ac4a19756780dc44dfb2d9e7a26d1c67a0ec3c7a7788d9d845a31a726b48854367d5dcac358942854ca46a06fdc3dc8c682d6bb8785dae39dbac4a0461184798421e3977e623f8c30f2bd5170e6f49058e23a1a4dda4c1e9497c55efed0d5918eaebe0354001c772038d5e4966d636792672bf3aa73cb7dfe1a22b04335323a3e30cd0313abfd06d6dd37f915c9b842c610071fdc3863c491e9779bad0d1909cd3d31d5889a744f0cad7ca3dda5d54d70e8ee2be9027ac761f86184b0e69d188f27cc2ccec46bb1570994de3691032445c68c72205f45e62cf5b42a97b2fa82635b05baa98de2094db1bf31ff7bc7cb1fb6d6cccf16e9cc25800dd01a45402201e5994aa129dae19e694179ba744a29e60175ce02c6b44cd94c8f56bd61dfa033cce68932ce563f563ad0081172837bcb61d6405490c8e501051a2f43bb1bac1eca78e1e45aa8a4c3a93913e6dd3ff1bdc045513b590201e4200944919159a69378d9841ce0d2e5d205a07a1a20f34f19c7725bd1fa98aae6f8d0998a259c4f66148e46e996575bbaf71758d1ba253ed8c65b0bb4fe74843951883e520be5e5b5bda8679090f76fe829ae5fb5a8153d60c98a169fef1f373db3d44dd1b163eec337c1ae7d4ad85eea18716662a6c26c15b181d0dcf231536c05d53b6c4df526dbc0ea10b9d13ef143b0376ae6064c661397289b358b65119b0fa3e91ea7b8e002cc839d34cb2e384cb343e013","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
