<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57d3ce0e573a020662a52f2100eebabd026a1f4050fd22d6ce706abbee679276f94c028bcffd03155425f9ee2db1326968b23021b90bf437fa48ef89521708089ba50f9dd439160b6e62bee618ec602166462ea2137c601047801b183b03b5ef67ac72ff12cd650adfa93f848478c7bd29912e2c0396218e827200e7e8ab19765ffd8cfe61d10078441d58e6429ddad56a64ef69631a3f13c947b1758c98b6cb3d87855783d8fcc5261801b248277af370d7788aa1af0147dc406133c18665509ae5834fb258088cf25e80dd8d8394cfb46e2b8bdebc72b371ffaa551b67439e2bf87fddb0e6dc54b064ca45aa8cb3e74b681efc8c15e142088b6902d4ace3b4d9a5e1414f84da008605d43ec4118fbd068f34ae79534961dab4d65b59d934036a54ca575bbd6b775554a69aac7fc5a236344786c7c9db5966fe57d98eed867436aa60bd4305529aa7d95a1299b66cc2b201d36c298246f35bedfaef5fce2c0388a99a86e1b6c7788c127ac661379a1478bb998faa0db7d58524512945b2f504ab8e8637df7dc9cb3e7248c22ea44b45fb742e1d7c5883655693cd8ff733a2552362faaf6d0a0ddc31859fb426afcc2dd58438e3f11af7a092dde08ae645943ccff19660fc0c2279433826a583e22597a86abda5828e079fcdeaed88b60e9767c2b659f8ab681bef6c403e9c1d574d6b486165f60890542223c10af15f0aba3de54a6cfc16eab29a271fcb94365e467b5354496ebdb0fb9af77f945164de2302f1736c36638ce1f88da9f565ebb5133e0d99babfc3234687a46acf59f9a1bcbbfae2657d28417529c8d49740ff908bf590dfbe0193f8ec9c21db11f4d3234b00fa08816e08cb2aeda019a4c8cb760562ecb1d76c269dbddd6935b16c09f2c86b0e58b675e5fd09163e9ff5e10445450ee3756acfb540b3d0a24ef6249fdda1aafaa3c0ef5fbc7b97f2775f06cf33168a393bc2720bc08fb4be5852a071ccd01f204e30dfb816135138245f6d32bd921fa4853d69b7f9bcb94faabd2b892b875a8e2faaa5c42c19a1da6c57cae4ccd31d88708821ce836c1ea6d54baaa23b3caae2fe6da215ee1fc3cdd244ea87b9253fef1f0caf4832c4738c35f4243059a8f424d4b482b1b7e3e5a7a46fa39e0ee4b67a5e6b7ae3ba1e9e2b2a7a925ffa42117875b40e51585a3e222c608faa43d758cb3fd1c221c1f3b8f4b413fe12319d753b0fe5f0ac525eef6f3157649bea141d9b3623d68c7488ee7fd3bc41ef8ba59d6c40ad6bb76a1a027a239f6f9ab357aa85e08f3000f68ec5205303a875ff933c7619c4a2b08ec32d850d020d0e0da8357a608470823c81140dd7e2f2382f4a7fd0d62a2d80cc6b410d18c3c5b08147dc72b3e8adc89186c73d42550063c8f86a3de1e5623110a392dbbf155e210d5b3557aa92e14b18e7efa07965e98d1c2e1d2c33d9ba6920474fd687f95f813ddae455404c6a4c6b550aa19d9d10be7e1562ba7b17b5ef110f1c86e4f953aebcda73f3e1843fef8bad871a680f0de71fa29d89024184807b72a6b8a5d48ed30f635c3d6184427550918c863c720bd002ced0f0a826111f4453dae3f4b775cadeb346b52f42b6304a4f433bcdf3970e08a527d19c5d8e826e680c86490eab384a743d6b6ad84ed201493f9707443754e593a26214d1797b436e90ba44c164d9094744f495d37f30fdb2312ca7798159fefebead12597251acad9a7e5803f6b4c491ea4383a75a3ef9863f089b06d6c060d81270589e0823289ec86cd13d4fa095e4b3559b3e0b4137ce9515e85b24a361a9cdd2418be92a5456877f3247d28a299d90007ecd9e551c99c737f1a9fe9833c8ba977c91451c61eab5ecf7263a36285e677d2fe5c59d7d10744269e6489fd0caf5865b1c1e0922e7b55567828ba5c6d9c9c39c500dbc2c3cf94252a02b73e4eb9e45cdc34e43e500fcbb358ff1847adce125dcc298fc1151b331b7c3d4ac84fdee74d2145a72c84d4f74c53215820df95db60e9c09946825574f3e6f1ebf504ce0f25ab4858ab91478a33a0e3eac867af68a3389ec5aa44613a885b7d37a743bfbc275363df502a7860aeb8d9ed918b539537b0900c671a8455927daa6dfa02cba35a35f808efadd6534efb04d50010fe725529bf138be2d6dc328af13ee6ed075fb213f1b443f998125fd706a038f94ca48d3280a5d0c7fae5af2a91afd424326e35b01f6a2cc2bb7d20fdbc03a6e4f6242fca9a43cfd74f08717a172719397f6b3787c3a9f566161cae7e339773102025495cd82f589a4bffedb985f0d2c70097c685f9cf4f37addf2003ce1f95f09994e0a2d9d95a1a76688f56561f6cf9a8a84067f783c08459c1758062c1985944d9ddfef08b7a4c960e3e13c4423488b54198597de7b1a3d3eb60936c29abc9276209f6f399310197eba8b5d8a246103d18dd22a249e700dcc9ce88d7dad3f7caaed58ff869401313d225bf6d001eed35bd65201274cf0b502c62623dd413ad4e0aab3e0eb06f2af98d3215600805542d37c12ea888451c7b03022935ec3fa4a1407680129a62fd7adea945b6fd99677e96d699c5858a1d697e2db7e6c558f49321a1f7b0359744464f7051ef49c67d150a664c45bcc1eef77ff77d58d6fd8eb9e15558c51b90abe6dd04a5a9dc948cab58c4bfea5db67b13601269515dfbcc801f9bf51fd12837b623c1fea96297f66ea57046ba153985b73dfc0bef3a4b6ba321400a65d39b1b2be0341a17bbc377b6e5767f73c4da05adbae5d258088125b4f4096a982a9923d15cd5396d86d0defc96578edc31f711108788d4add3c5a846807ac85f289015616982b13d93d10671c1d73ca7d1818d8d8e1bbc4f2f9c3a299bd7d3c91e362e60e95b0b921de7cb1fea550ab99d5ca0e449ad3aca423800ad1312b3d4f9160bf593d84b591f2182066d13ad02a4e16d149cdc2f3af1e7a1908bb0a656da9f1d04fb3cd7ec14062b311df5709efb89f67787644e2602978521a24af548339803bc5e7d8ab90a2f2f1458aaa591530f5c28db75e95de3100ff713824ac0fee247c87cb1bed3024de0b3744a2d47b1fa3f5ac62a2d922dc2714b5edc9df222b64c68bb008092008dcb5e291b7a4356565a6f0ace78e5ebc6b7fb51034968f69114149c10cf0f5dc37a9c8136e50f8c38c8de7e8371c8e8cf9841e74c938037fc5a06b445d54f31bd1406c79a7904890e9ae218d7bfb88aeb03496f98c8f5959f0c027fb3f086d893199b75b20290745a11ce547a1d5da06c39b4a85eaab32e73dac0dbde3c2c89bbc5c1e1c18eeaf8bad628cc2ca169b299fa10f2ff372c0c5b5de8903082e7e7ef5ae40dc18821f7cc556c75e5c7da443a6ee9facb87c5d6b676a81aeac13143f4bc5a4d1e534a01a58b20d84fa4c48afa6cb96f92ad332b22c8a08cb1eb7c2274325f64403d680e9ebb239c724fe84c1f9ed8d7172043f09e76c877cfa1c84bce0d0078a72663a5722fae533b8dd241ff4214c7198bf3f6faea8586a64f7503529318f22595466f1101b8bbca181c366f13054a94108b7389d6a7fed7c637c83118389f29dd68c627e36bc39130727b9c53b076e9cfd022bde0211611e07f4ea203b0e586b3d53d1e66732cd8c8f0dd497f02715ab94960db24535a2bfe7137eec319c2b80716763cb5b2139e766e89388cb131ab3c7d6a99fe828c054a4aca96ad7caf89b896965608108a701578ba09d18d9e5816637dd96331ebe5bb792a439f31a001255f9d86c5667490bd3e0e7eef61ef3e9566fdfcd6d54c14abca60728b6ae53bd0f682a5855c1a05e7e2699f5690cc177f5dd9a5aa10ad9d14f1b751e8b00c25948f174779b71a421b0dda62878ab793c6f8bae6e29f58923f6874c58c835dfc6225fe5628db1b948e46296d84ac8b6e58348444e76a9fbebc9108698f01ffcb3608d81d5c1c74e4b7268a4422ee438fe94181872dc15f1d25bb1cb651596eabd2e598d8e17d9e88026693d7c3d7999d4b6c67b3e58baf53601d20c541bbc25d9351999e7d13bcf62ee39f0f73f8d7a233ea045380ca9fa4cf5271b6910c136213eb04cb31dd2011cbef5b45cd191733d8bee76e151afa0862803f586cf64e4e83e9226d1fdad08bbfc7c7539d6a0e9d709aa2ddc82e1eaef41dc747e3992dc46493139499649024e51658c4457dd9505f7c08514cc4590a4eac8212073c23287f23777f5aa78ae144c119c33b99f22d88c9f70137fea9c8e38da33b8c19b9f7a140966c0942b3f8be27050fdc673e2707add44dd50fe4759b4a594e21152f12fb58d6ddbda2c0088f3238399eeea21c439876485adca222fcb559d14cf114b6503d0a5bcd6165da9f3ce5c6238699f94c63d47108c41e798c856341e5c753d046cf35ad6057b351d25dc6fb7194fd42f34376a5b4bcbf7bf38704ba6c439a430344ab0066b0f33a2165f3e5052235f325dfc9e49c3fb73eef02cb592af5c8d6e861e0f742b09c07d23f0863c7a20eecd139bc226bd74f870bf5d0755b7552951039495aa3f3276a80525682c2c7852f3c52b88259d2d599206bc53b3004267ee1980c3e244266b3b70aac955c6c18c3c8dbbebe5631371d8ed71debe2d231dcc047692151e599b5df761cad0b864d0aaf129d86581e366ed03ae0e547b01f7c1382a6ad91bb704738ed2c3094bfa615dd424e95e34430324933111f8292155d78d245b3df4e0e5e990402fc0a00c0a05c4fe7d75b73a1014cd853a3ab6d1741beb9f782223f9179be8a8a6e86f6ad1a796b17527c2f507258496e3a46dea40353542d5d489f30ec6476e1f65a4571eef05eb07f89371891f84d770cde8c833729973cd64eef77e3cc6daa92f9249be5dfc878cc2937c6fad20a9d8e7e747c226e90f375cdefa749af885eb33b877d181666a2f187a48ef28f6785d837bfb23e9fddb0d39ff8598cd7b7d22fa8d8271e5b943e9aaff64579642610cd6ccf3647f93a3aa72d48d4138563c594774447ba368f1d53a9a987e533f85248df78964484c5d0f4b65a17b9ebb68e42c61f4740d5272177b323e8fe748f2cdd383a11ecf107c0d572e807f9ae339c9e44bd40f90cfd041f7e2d008b6394a57df3a2de9da1a744a55c8c5d29d80fa14085fc3a25954be731e1fa4a4579994a8442fd22cbc71649b847c139ffc96d2ccfb0bc8ee22d9ae5fb4f1b21f6ab543fa0faf524938e466680dc660794fbb3347d090fae5e1853e2c87ab9a1569caeaa62b8ea194fc996647c600f2e1ea9eeba8ae5279d31fb0e73e624588f0532acd151bb6e310dade661249f551111873b58b551f80e319f71b79331769366ec26abf10ffda04e549520c9467cc1a1153972fdfd59757ed45f04212f17914e2617749e178a8c62dd3edd0a52bd261fbce03dd6ae3828b99aee3f620a1a8df8ab22f22376b4d61a006af58aa488a2e13323342b47e5e3f60ad765679bd5fff75e3544f35fbc17fe95839c3953d1cac64b95a37fd94d64ff45eb85d6923256096a5113a21270525d1629ebbb74f6c1854267f6a8cefc5b7de8147268af9ebd59ae9bda29e5b4fb45df07b3bf597c08afbabe07d1053759a8e5ef40e0f2435135f19b761e976e60021c234b8b43c3ce04abf0054b6c1813570325996a560cc1362aed0b6b9efeec35786596d5c4920de78df4e2df1d68fc114830848c177e9511a5e0e4e0101283ea52a7da9abb5a7f010a0976c1f7b409ee763ccb3d678efc88247c5554a1cf46e966792eb71ba452406256d94b43034e74b8968852e9b962a53e1f4a95b4361e14a096823c31bbbebc61ccb9b39b80ea5657cf74f6da82c3b185e1abdc586c7659efc0ebac28f17dccb48b623037ffd52a0f493e7006819a0e9dfff5e36064a7d7d7c6f06e658ab27874e81c693215e1d7b65942d4d64614b574a26ddab02a10806683e216cc462dca6499dc49739006b0b84d07d145bbee4f648993ab64b7fddc3daea003e1a7bd9731d8e48aead4e73f7718d201aa049f8b8debe1ca0326b658ba85077056e4cae56dcf599a6e420fba28048b9a388419c26f12744147848df206683dd03c5f1c0a17841668c3c527e0aeae2b4a6bfa99626b90194900bf2a45cb1115fc8e605f8528fff8324344dc2446ceb8b67b3790c425d49e79cf8389cc4b0b06dda385c2b856b54f2cc4d2678f19ebca6f77048b27406c291c3bd2521767ad068cd191ff76d08cee0461e13e4b4ab73c0ace901a92e5160cdb7b75a60aa95c2ef543ebbb3fb597c2ec78388c09914246ba1845e539f79c2bd316ed64f2b869fef7fcc6094711fe67de206ca769291c6c211441cd888e9a2f5810fd2c37b7343e148cc9e33952bf30dc8693edcf5f08285e8197952dac882919931c8f83273c7a8a7bf4f93c3188437f8f21b5b4e0b7b8da435a75f04212c3301d0282872b3c0a888a7692d459b0bed335ec8fe1f063c354cdd56a8a95a953f0acbb9cf45a571f2142d622dbd00c0326ad2cbcd2891342af2fe23e53d69eba6b3ceb9f6e8a2462629cc33c780a49b6246d28359ce7c419727a9835ea051991d62b6c30385c5e20b44c3250aa3b1166886c9ea01206c5803453a669ade7c9601788606f09328e9ba82fd40238b410aa809376117605e82e433829e413b7b069b453d2d7a467aa3a77451b91214fa77d8f5b9c5b0e7a387e60d4db549dcc181a998d45e7d5312f3f2bb84b69dde4e5682a1b81c1682aa2dca3878ed52396e914f17aedaa737ed98ac030d4bdb752ec6557c5c9fd91fb6149a6aca33d994827777b660d6c16524622f60b33a3dc5a2723d3340b73eaeaec38a1c91896863c63269b2bb19ef12b31db21dd0efe99bcf2a93cdf686a7669f3a1a56392dfcce427a669bffc6b568adb6991de01d83d7b95ed42a610d952cb4292e21376bafd5a7abbc9c1b48c0b7b51724ec7160695981d9f8c15132b4f4b96e910f66632a78dcf14b00c2eac9777b9e226a0f00dca83889ae7b935ba2cdf863ba3290855e7b02883f9f3d35de7da16e7fd1ad7773cd46d16e49cccd66b2759e842529c09565f1b2845aacacc437f82ce69f632cb9643d42d27594dbc2920d5e1d9d288c7cac845b17e388be3eec58dd78ffceca1c02bf281d2b9400ee2e98a2408a0739ba233e88c0cb5684af5b88b5709b4cc76c267aa734faebcfd15f6b787dac74e458565a1f0fd21578efe0de4f67bb2fd977f36780e2b8ce530170521589fd62d5d091ef8a2ed10fdc89daf73d12f89162702677d9b57cab5d81cf7c06e637ede24277d539f3b79cc293933bc2af4f15bcaa0db2046441121a56003bfaee6089db25469f122740141ff50400c40a1187115d7a2fbaee447562eee0285e406007b62742df0aa58a213ed88363562bfcb7f8986598802ba75e3120b1ea747b1a6ec2c0ea5cd4b5a4fbefe71d069c4ada868d7ca1bbe7470486ec3c0d4bf2df7c6a7ac72efa81a68581c45b105431ab07cf90d0e1fc5d77ac9860767c859418aaff22d86cf03962ae2a9e6e0525f6e6067ac3bfb5442aa243b5e82135764543dbececd36455e0b2c08e960c0ac8d351c7484d757b354732259ed353fa5bd251eb02a60f464969bb2828ca5614b7926883895fdcb9911a43cce91e5d06a826669f1a202c046e8c9262e189220fa1b2df07d5c98d60e2048bb0817bdbc5e8e598a4a66ec2c4471d0b7b4a80566d8c7507d097fd4eeb072ccd3bf21d2a599a5e9673f0855fe537e1978e0fc5f2b8533a3be409beb98fe3f4b16800cc4d2a0106949b889935317df0a4dd3932471eae14fac167a870fe85fb910fcd06338a35e478a06a48361e7bf496185c52caa25f30b298ff279b8557a6b8509e3d9dba69b208e334d6d8cf078df130948aad9bbc0a07c067a95e9e8bec4a2749eedd1e1612a3af9068790c855707490ecb3fab1a371ff3e68960b74fa10a8a83f149919d198f2cc1699f832f731eb4d694120c966e32382b0d9f8f5e92dce5c98818559e367e04c08e46d4ca7a422292b5d3f89f0954f8af8e9b68600dd557ca630dea36f4bc5df5777162047675fde0201f80a9c1d5775a2d09a40e9373118dfbd4292a8022665c077394586513119f10418882fdf9b96215eef49e0a24522b2d7bbb7f336b071513e23e96f2a214e9ea999197871e03eef9e836723861fcfcafe4c91ae4a0d0d7f48bc3c19e0ce800ac2174ea0f7ee8f9c708eb9d070e0f45644dd31cdddb21944214ddb3dfe6c482ebc464e7cea07f7394ddbc29b5c1fed44aa8a39c607ec84c34700d9461a45d34c818fe01c4a7c3e064444049ec801b6867c06d238e33c21b29b0d03658e9c30e66b834e923e583a07add0ed5e4a891546a5e763acf33460ce8153a69ca5a8d00b651dd7e65f10a287484a40a4312ced38f7c699152fde1fbd10cf50a325413992f26f918ba40c70fd301d1cefd3e74d07a8c0ec1643f8aed99f4748d45ce7d7d2b5c3727d71895081be86a17f999efb5f9714a3929996b43005083344b3f77b82307f283fff4efa648bae4503a81ca371646f8d1ed3bf4698c803b345bcd6f1936c0ddeafc28c329d2843a1b449eaa12100ebd4a144d7bfa6639c2627ad0110fdcc1d8d3412b4c4032d6aeed35f4551862df677d458e0dabf62a547db5b48602b914ea7fa21421835f793531398f31c38385cf5e2d49328ee3fc7555879efad2b3c916afc6ed84b08c22c2f6ccceada7b16e15d78dc38e4e623b6283807042e9ca92eed065cbc4439c2ecaf38837aaa614bbdfafe541f5423335341d361deda15295a26e4bdae2c2301960f9efa15a970734bc9e6a8b10548314a6832743f1c9d416fe30d58e1b63d0eb254e9a03c5818e133b5988f506cfbbcf68f4fc557a14308f29962fc21fb7cd6ad8aab73863af1ea8e32a8e067a5f5eedcad042f079da4e98d1e7ccde0c39cef5057a8374fd438f0f7901518bb93f6eee14178bc4f336a17b0f225dad0f67a8324fb8536097e4939847e23146149c1118ef3b811ddf74c550aedaf1b94cde69820b21147d6b65d16eee7d2a11383a8cdc5ad1b42cb7f2f57360802efc0112e64d66dbe6f07e6730e2d06ce49991ac3091be5cca9c5878edeb2d8ef1166633a5167c6623d2bfbceca08f7bb9e08e7bcd7c919f9fa3fa1c6c7157b25deb44b723ee2ef7a2309de53c019fbc421938627dc682fade020fcf4be8f991298efb57e4d039843f7e208e649c909f65e3ccb5c52819b040acf3430b07a3fcdb6b7bf8d6fd722da554cb6977275a4bfb37285f4853216d939c278c3b8b72fc040ad141b0371b6efeced13c8f2059dac796b99d1fbbf6c1a3b684b594803b0cc8ecafe0b022b882ccea2afdcffb7a79b380edf9362c73d609ca779822eec0713c683b2e940d7ca86b7d6af263a73947825486cbed5eeea1c6209e539462b81ed198dece168133dafa7d5e3d7a68e613cecaab6b0eb9bfae27dee66712235a9fc3e3e80acf100762697474e00f9eec87db7f099684d3ea64b59bccd89b6d745edfbf553c63a22f38a261bdde8e098e2c5f96ce968d8059ecdee13c00bab801c6a67ee151c04dd4d994c61ddf97d39696452028ff64f5f6091292648298b5492b1012dfa25a90b5776bee59186e0d3fe42a63e316cd54ce56b61f6c80fc7a76994816199909b4dc9fc75123e664f936936c1783a5122a054352b83ec60f51611d891b3d2674a900e1a8c3eab877d137d2ae694ab1b67b113efd2f2325593644fbf8d154267fd8411c1a63464f73bf4ac29e24285b627841c0cdb532ce773d01cb943407e1b3b07e96497b84ea06b72558e00fdd66953ae839bdccf397b5b566b09ffd484ee42c723066b7027ad04d6f9de98ebae0a58aebf1a323c4018c25f827e718357c8bd22e7c38a17172dad70fa80b0b53034e5d372c4718a8f879319dcc10dd9454c4c74ef2841c0f4e62cf9a10f256f54b66bf0f6ceef0a6f71fdb58430d8579f3615d30b9ff1b16e3b3b0e157e78dfdead96867d9608f2ce314f06a86d4321cc9ba16237e0806b136a34a535b16179a98197a9bd2951250feb80eb160b8e4f95509d3ba8329ab727bac381ca86b3b691d4af7e6d6e81cf924f108e9ec3ae72d5a00eb50b247240b073fec2a009a46b505538b01edda0eb21e9dd88149dc8b90651beddffb9eb95c89bdb9088e02cdba41419a9bcfbbd22c4844f05d271855b5b49a51e64494eec6ea443ac9c3cd21a5e0659dae8c3c8e70f45cd295899cf0a1ff1d147662f3f3ed4be583818dd6eee525e607a0f38a8190c897af4d63b9b1500b2af61d1b35840a37d90a9a60070bfecaa5044fa5a3ababf68a85f724c4579fb1fddc73959a642c25b7c425dc25d574cb63c6d8a0b5ebe2c09cbb8f2c2d230f919ad3b0e0b07d77768f0723936bb0c72bad165e003391a56560d83d737b93757c47f54bbc5db00bec6ed6135d7d00994bb3f1794a7f733be2c37676f2d7a7881f2992ae5d70bb3c04eeb01b9965411626461dfb7974e188cedb7449e292f678819202c6119765f8f538b662f9149e9972fe574288a3705294e84a7f6ec278dce603baaa89119ff11f7d63c4ff1278a1e0584b0bf550d7c9f33378975ed206c86f0f441be7076044c7a2bdab58f811692eb6cffeb8f2479f7e722afd96b612d771088b1eef2c8abf4d089626ae296a070ad5fd6ef8132f37908f5ce34b37ba415d156ce3053e650ec09e29e14c2908abdd6bb17fb14340000343df90cedda8ecbe0b8dea9b0b261d0f99737934fd0543e55cf9635720cb190c36d34227ae043f0d825c4e967fe4e1fb4bf907ac2916db91a3f5403588dc1f17a8a1da486bf88735d56ad567801caff79857db3e1cbb32a9ab612e424ac41d3a3dbc6a853d56dacf8a1bb4f5a35d3676a88ebbd4ddf5280f5712f7adff2bd254454f8b7c53b5de626cd04f0671e7b9525aa63d2365c07f348a7ebb5dd42cf045132230d18d5c1fc4209de5837472f218585fe5d241ac90dbc0de159a5cebdaa065f94039931cd3e19c9e89da99d6a6849d5efc0d0283dcf77a8c605f962dfdbf065542b0f973cdf056f9c91b0369aa04a48c759f3b47dae6bf6406fd3a91413a3113916f397258c54981a2caff8ea2c0c83b4af31f0d154614b95b8d2a59eb5eb9ff33d6648cdf02eea3efdf52f662d370b390cb2c397b1c5fcdcd6e727666c53ef71722fb03dd2fbb1551fbb13fbe58e1b883959673e08add14f31c2f085346c37eb6e3351d26cc44e6c7b188555f2906d7fc5022e8aa431f9d3d8af23f14cecbe0d07c93e5f797d45740cea7904fe6c5c016a812f2f9b5482eff17204413c6bf5f1a04c1e4aab8eca2efdd9a4a1026c499cfc58b295bdfac87811e99075018e65338529f618dd704da14ed0ed79f5f173ed364b584968eeb55e8f74e862273809043fdef88e21c189764cb232e502e9c4631fcc27ff7a2305c06e310aed5ea4570f5ca210d4f9a6a48b4715b20b7d7a9352b47acee8b863a69e041637035adacbb79e3906ab189e215f28b4109d833b9ff5368102b1bf2d39fcb8ee4256c5fbea408b8f011f8e8edf7e7a5556a3275ec060c6829f59b0e7f56ab81edeb8de6d05d842e8647b63ec73b8da8b7071350c3861333c0b58604c3c173f3681b105caa0bb5ad2b3470e55ec05af99abb33a4d8dd287c979c5973505d7121b9cf51f98df3c5a7423d7940f075592a12f1809cd85ee3c5b8d81c741e3af499649b9f27abc87c58b622a51a6be2c90d9f945c6bba5d0f915d30800c9638dfb62e58423554a7054e2181367d488608a29988a3d7aaec2fc45b1c161a2919e9908ce0dbcd53743e1bbde2823edb8c12f8c7bf8d497b882330f81f8a5271860bee2c28b4641586f3d2658425c960db3e197db6e94eac84683fba3f15c1f9e74731fbc55c973e3839dead3a73455a64ed9abec0573fcc1b7bb1387391fde5758b67f32ddbdaa5b90e25e52c2ba9ce1cfe1997d4442f727c98f95b243cffc57d6e376e4939a8288770248849a8ab3e5f2bf7eede350c8d7c7317b6632c7aca27223248f501d594c0853fd7162bd71def345acca2a2473cf5b5a2109de7203776c583806b73f5e0c6562a03773891bdf3b6213158e00ac1a4194b9ce99ff88ecb1a20856ae98d7c9282efe3b60179ccfd674e2e5dccb5bd2eabe47aacdab7264e77bfb4dd7502cf5e5f1ab92b90a5f436b1850610b5206c1f4b46c4ff769327e58acfcd2981ca03551a3ed3a90e78015e960986940d5d93883a2fc16a4e2821fcc7e50b0aa8e07bcd793c115756e133acd5c40a166cb9e6cd5a7a20fb59a6dfcad4d1a706a5b848b8786fa63609af72668fce4ec14ae26854b21734b9363cee5cf5ffc60406697ac1696998a9ccf1d3e0772b01f25204a671c3a8f19b64259babc7aad19bc6fb8c240e8987753233e0991e616f1485672fb78bed48102475e3b2c64cab78ecbf8e644eda4a5c8234157cb509cd5026204a71d3da1d62b4068c1008d3347b28f0ff9ce72689981ef0981cfab093c4f34150f1b273acbf184b2d15e6328ffd0d1d7fc2de7c1e7e60bd36ea2b21ca3b2f58c8e28d659e65de0f8e829dfacedce27dc471473c25bb0104e4925a789a0b336b2c6719a924952acc2d7d960fcd36d1364ce57186d09537979bef1e9b2e0993a82c7d1460f754c2188f01685a0942ce83fca41c4a3f6439493e092cea251b942bde260e0fc44423d70446305ec98e3f02882e35b9623a4153d574a7de9364e1ddfe0b79ef47d83bc18a936fc8aacf174fb2c79803360ec5c27076a606be693e2bbb4b2da6b052719d63f360c954eea74583fbdb8701aace38c3dbcdf30456a3fa253be1a21419544eaffb5a3061b750b5184476b1109ba4d11eedc2f227d800092d33f72872b959ed3ae05dcaa206a3097ff44217d575a3944ad0dac7f43e7c09999fec87924219a6ed8dabfac217f127575a9b1e9d3267225429e73eda45c3b22bc19b777bef3c1f03bc7f4584aa4f46d116a990217f5be0320ece6bad4dcee3e7cb65c7d03581695d623eea7b9be8a9dff45751aaa080a732eb15982aeb15802ed47a210a6ad0b495f03842e84e13fc31bce6f3ad8dd8cc69b24581556f7c72843e3ce8f5d03f5dbe50c52e4095c5558a058678e4a3e0cd2682daa551377b843a909aab6f97af28b8c87ffbd9c84d70357b29d427064fe4cf74dc962dc04182f7ea66340ed25e1ec385d6e56862f26e704ccbc86b404ef0362984940af3833b59864a5ad9e8c99527a7fc2550a831d7e000f9e81afcf5e77fcbe9e8ae1c4ecc4f46bb083a7a1969552a2caceed8ea0edc6fb256f1ea650090ea10d1cd6665b73aefdc059fb81e12be8390ba1fb2f02ad751336208e0b9b21567f0eab4dcd8e7c595fa4f71ac4f3692bafeb1308af505ecb05a9762c0af880067b34fef97e8174c307786a64d539e3861a1a9783929f5893c60dd2f6958c71406b0b7b0c24cbe1f9186d668873e397f0675147dab6c70b1834da765f4856e7b6d3727cd5695a874466633d8d37cf3942a8a94d03323f850b337b99366747354d131926129551d8430e64d66519ebfd85461f7a388266fcce9871449587fc9c324d7c98e130dc5d99de780a7c3ae40b78212ec737f9ae8ee430cb4dc03d77b52c8748e07631296459fbb637a76f12c3491e2df64d8a7358c45913934eb3007bc5048e85adfe54dee3591bfddf2d7ef2b73d414d15b01de181baa1ecd207218f88307b4665d85cb2b8777f1fef7050cdb52ea1ae09581ca38f27a7abfc8dbe588a491f07fd340c2f82ba6d4c5d2080ac3fac02f48585b03911fb4477f0513586fa357737aa3eed0cf0cc9a2fa01940d9a775c526db1fb21b3601918c7729b5b834f04bed206475c372346dfd72815df4b578676ec8890bcb3f20db98838cf301a46740ef8e780552cbb025607eb9fb520880d03e254986c8d9d756fa249d913d72d85981316b2b4a00e3140b859bee51bdcb064c16b506d5155c8667a1b37fb73cbebe431fb7dae321cf25b938de8330388aef0ec107ffd188d8e1d430d0462cd633c8e0948bcdb277e44b078d74bad664b0234baacaa85389771c0bb30199776432a3dce886865cf0727f13ebebc024bd5394ce61a5c25b502ce2a3a04882c8bbbc49151f198d02e5c304320f3f068660d9acc639bf7f0d4d31f7e44e15106bdd4fc6c280392d1587b73c8b4be90cbdf1c4aa53d7426f2a2ccbc4a6ee85c8cdcd080f30d91d3325575b56c29188269c8f93b3a848749d96e265e60495b71b184dfd09711b4e355132f2c4e1a88b6c4dd72bff18a851bccc37f2ceac29533b53ca0c6479f6c185797279b3fdea09186a717d1387edd0a4defc07c69585a813dee9809d1e1d09ad99cf7d5716ad362c01534dfdc146bcada0e2a8bccf6ad5a7307c8f7554e0f9293a76bca1e2df1a8b282f7135f3c60d75b14cd7837f6519cb41332d57ab00d27401c80e7743f1d129c35292d2c8fe13c11e2d5f5ed6de2e9c455cbcb9c94213d3a0cc313c067d6921e5502759df528a852cac21555f597b9dd4b66498db028c7acca7571a1fb80c419937fc1f6764dd88fc55b5a63e32d81dab3241fac0e95059712daff6cd082685f6ba0f13314c2d9a25ff296b189f7a64ed5f99ef1a9d17a739da67cac3628d5be4927986395323aea5ac0d51ebb3cf9df28e103c9b036a66981bf4fd06e2493508cdc5031f09854f2e5514870fda4b6ad9bfde69a3aff9df81eca19c782abbe1fdc52d5362b44a89e4eec3f85a39dff8fc1970eb4c5d78458fdfaa0cbf627f67d3211ce0e3a1a6ca8bb3517330e9f6ccbb66759153882d5b8dd0d791838590c6a4a506af08f129f93c9a5cc0471bf03fa2abafcfddb79c1f360f789562fb557959d1396b6c560023078dbe91dd2b259df10969f119fe3c6345aad87012fe6b5273d8c1837739d3b3d254eac84db5b5191c711ea63251a1574f52ce3c3614cd88b95db66b5421c1a3a8f0a7c6f5bedc447076e134657fdf4ba320c50b8c0e1c63db850bfff62661409e9ce8afbc18e21fc3a6803ec8b61ce2dd32a0dcc908a7a89dd444d7a754d3aac32b3315e133ab545534f1898e89a67876170a498069bdc173b7260a95d7f42166736be31f71dd7abb6f69c98bfd54e8d1b955c7e117753025de64d8ba932b94e5747e89844fb51e8a3e8241986b5b8cb3a1f3da5ad578db3a0c10e60d49ce8851f8726b055ebebee3e342029770f2dd644e8fe4a682b7f907a977e812ddf3c70acb5d62b260569146cc47b84c1dfad636bd2c10fbbe869cee8612691d5bfe1c54f033e665fabe035964a71fda53290d9437155eea527a9c0fbacd6c048b9b00a62c386db8238434e8486fcd8a44915f8a3d82c6705e2d89a94170a6d07a85589923879791920d501fa2d806e85efb2e8e11de97c38ddf940443957fc7e9544b078f49b764d3c57d993f4b474e90bf1a73b7857f352b32e9b9e0dd6fc8ec6ff96a93b7a812fd47fb58d398f7edd0f64eec1e06c5a340e91d944a20a4e4d18712e3def26a4f38dd2bf96ca060dba5087d9581c57720d130d6e2ac70577f5f846947caf0284d5a53170962b927bac67883e308dbeddbe97ddc4083eafed2d3583d79552da5b1c77b29f51123cf74822f6724a4c0687e6dd7b1f18232153f70ca79e1060dd2eafbb01a85776e3adc0d2f4de0d7f8156d8d0d0cc7511070060d957c76d6878bcc0a43e27eac40eb9eb49c315de86447e0ddfa877ee62c75a7bf1bb0f96b70bed7a4568c574567260a7081e5c128ff55b983e0e211c1d6a9a681e40dd571042b691ab5749849274259b7a015c6366034ca9b6eda7b836f22f6c89fac901d77bfbed4d23fd5ff2c54951e20af3848f449f7e1648c28c35040bed2687f54348f28c027b9b61e53bd1e922c577cc4fd354081dc9a42fe88a1bc5414f795e8b941f23a1d13f9d4a7f893059050490c43eea4bedf89db591ed411a1055af6cfe226f1056f305db4e46a497b1c2a55e924c62f111910c96966e2881ed509099849428f8cd7ac8231bd1b2ae1d34373e53138eabbebc08ec07844f668aca6c12bc6d22df159f4a2cbb0dfacd3e995a293fad28c32dd2062fc02b01212f7ba07bc6ea135f361938f7e30f34b3392d2a320df23f2ead56687a700e6be57398e06037f93276f881869c303a9dcc6cfb9a16d985c1a42c7d5d3cd515689b06117561fbc6d69ab4dc2b3a8edbe7b23d3626051c649a78c7d51f4c0a952290051777eb2066bc0827afa83c59654bb208859aa201fc3c4cb4f6724268fa57a746692bec8bc48f77bb39b0189c352ee0f890c5ce057780b6042114cb2dd6ceb14c9dd02a02e42c3b4210696f85a022f32e1804af25dfa65a444eb902b1c8f5306b2fdff7888157813bf9c03aa7138eba05730e0f83e7ac8d773763797d2cf2f708b350056a05c83903b05497ce411b4f9f4ec46cba48a3c16ac0a11f92a7b22866877a11da39bcb12f195764450e4e30eaaaaf6e496be5c6d2b47b19a9780505f8d9e44391c363c0943a14ecce114cf039e3582a4a2d0e2c77a93258c0ef36a0b2bf7e1f3cceaeac9bcc616aec83a8c44473c51156f7e65a02552670272c163d3e7265a3e51b9204080963c2ab13d9cc123ce8536ef8e9e4478eee058f11091079c50130f274257b960810f42f6b27169f15a6113e3d9cd192b6e6e2e59f744434577a01ea9543f89a1128d3c7a653edae79f77924b86a9cc27963ebd336282bd5170d70976613058b61fed3f9a5034fa30a656ba3842040dcd684b58eb32ce941e55f84bea29142dbda6961b519aaea15068ce223b9ebdd0bd752131304e15ca7bc16ff276637bfc35f36a191adb1beb026a390fc277014b5c6eae05f4433fade5cc6c4d8603657b939870ac9c1420ba544842bc8bb43d5d950a70cbe7ca51f3eef66e0ab1d4908784548c8cbb4e2c27ac352fdec4a15652351b5fa61045f34cc7d28c137b32cd991744c4e130b851799174f39f50a39a4e12888691d2a390dcd67c9ee91887f3dbde83484746763154f22363f331ec0d058fa1667b588a20a3b8e4397000853908e3e4b807f3c473726e5842101bd56735955fb05fd3e9b0d1e43af87385b31b4e62004cbd4f9c5d00243418be2ec7c645c7b14eff42f6455fc029931b2e7cbe74dc2775a4a156ca92406b9412043809748740ffa07da8be4fe866a455c71e00c873ab7a4b8b298dd76f35198c61302f93a585b200277455af481320bf83a6d5c835678bdf5bd032b57fef157556486069b8b636b322430c4c3a461ab1debaeeaea54d4c1aab85e95d8f2083573703d1ab3e0a7849bc70132da81a68b2b0b69cd26db2d1d4f7620f42808cd137b264ed5fdbc941aa6afea6b66abdc1600d6279c3185f3a1e438dcb888253c3e83fd908724b8b68f32958d6ecad7076148b654391e6b3b44040407b603137c32a74fd0924e81aad30b5689ed89a44929238695dbd6af5f122968b9dcac83fae49fbb0a5d331e5c3ed607cba1bc1304b6e74f3193868ca68f4e5110b51f172f06fd2afcf3f1361af28a2dee68a4c6e6063f70ddd90038439561e9cc9a9d86de492262e6f567062c3b9c76c4d4dba1845af548862ab746c8764e3b5bb6d0cfe61f728da6dbb6ed73d87568b09af0b0f10dda997879b43227f77ef721956059e4e86781d06270e1ab27086ec3608cf1e261eab0effee26cf88779cc913526aeface44ceccfbbaa1520320d3d1b935446da14b8fa9c959fd0a1f60c32370284263673cba9e303fca71a9f8cce6392e99bb21545b5e5d41ff0881985cf7e252eca302929acbb590153eed4bd4a2d0f824d9fb4ffb47102bc95b8fd06dfa90e4e7ca722e206e8df062366711113cf976ce60c877b5b46763573965b8c2f4b8fea77e26ffecf7a0d0a538c8160c86bd04a16bb78408835b1d2472831244578488938f84de9d52c19f2321d750131360e0733379475214894e3f6eeafb2c142c7f2d87d1165d6d371123e29c9c6e4e57d5df7c4098","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
