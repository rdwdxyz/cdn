<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33c4796e84299731916f4de27270a449da010e5d34a20d0210717b87f56a8efc116a899a522bef3b63384a9d18d3d6e2d1ca1aa5d88bd032a88078eae9ad0690fcbae0baac27927c9891d7de13bd55112113f21583321c0427edf58a57bcbdc80ac6daa43aebf01cd498fe188868da8873d6cd644eb131e73bf84a08a9d5f9dfc70e4081cb6137f1cc077719d54c99962ff2eae952f204b9e66a501be6508eb8686b649ecb988cb61be13e4489edcaa039b20685bfa8f089d126b4c29348bddcb55229d1789f3eaed2f2a91e99c37038032bae3897834f865ae8e13bba41aabe45ba96a07735b874d4091cab72537ac5da4090ac5895d58695950350f0b872d59119c54c76a50cfba81130d223d994dd4d14651f08a11dac2c6ec962af928f371991afde1726d7488eb40dc6cb33fe9f3d3ae6417f40108fe468a61a9fcba5a5b1369593b79bcbf4a68675e9a955915fec7ece80931c2428a03e5badd110c6ea8204a11b7b9ffbc48884d113425549d0648336c682973619d6f49b2c2e2003fb303fd153c94c21cfdb1affa3fc627548cb5cf65b3665201a063ffd9043f916605136a4ec99ca39b5173ad4b54c9398bb7784b46d8df77ca6861f47383925b9bfbaea12b5d0768cbc96f5e05fe554631e7c6d532c5d3e51ca68f12ef8cbb8e5269c19d3b1c4de85df41769c036b96a583d17f48d6a2c0387d8612eaa6a391a3de9d30a171dc320ce8bfb4e0c10e858d162ae2d0613265a70ad3443e3de1a564d674f97b4356eea2f1cd270697c05c22e74b74b08473128a51e9b72aacee6199bb50f61dd961fa5772b59445f9a3376b2bffe790ea502320367a394cc5531ce82734fd967e81652c14bfece65db3a0e27942ede5a2df8caff730f52eda6a1df07f07ba5e64fba38818c13a311fe4d3d3ff0be14ba5cd89918deba44b9bea16bc68863cb0664285c81860e1732697b5cb51e6a6db5c446e00ad7f74796b0e22bc87851a915d98e39182fa2787ca56a3789ca464b95cf5ad10caad9e429400fe9c5572975e7da312e25525c42f4221444d7ce7a4813d74db244fe4a7f0394eead77ae8033697ba800c67d3e9b291c616684f6aea2ad42a2cb5f4954b4e65f0e474161ad80d741abcd6eedd4993c2e35b944ce2ab33c2c34c9d8a1ec044bdad9198ddb4fed396b2a71b02d14e9e58bc3f52e4ddfa5f117e5f2945e0e50635a48371a371fab5aae82750c3e670060a5996151c78050897e794f22a3d2a4576eb0b19a389cca923257f50e229c24dc1b5548bc8acec666ffd11d05c1191a8db7c95065fe6f8db89756221529d7e2ea1307641215f493e58dacc199ae890ba1717bcd878ce01c76936a55299a9f63dbc071358402d56b8ff4ebed9acfa4ed7f6794017c0ec00b25c220eed7858c4983d7fe0779737a8fe744d8297b1ded11528a13da5e3cb4e57b07d183fc0056e75ccd3691687f6bd0135e16b5cb38e85440cb49b3d893b22c9dfe3ce2a3155bddfcd7ee95a96118f471007fa0fdd86b3b0fcf96d9d144e9c564ff4361b1664c0f8a4f87e10cb4338a2c5e780cad66ced6cb1a6416fa13c067325fd42c85fc38f3caf1cabfcdc91339290a5d9b6cdf43a35287e7108600d98b3e1ea3687a69c3518f088727ff754da04e9592e62c74647a9d394fa800e6c7df102cb239366712a65c4473cca8649eef0e9c43902aadf09fc784c51bd81c3d18523166c4b7a74e8ac516b3c9eb36ed93f180c368d01f45caeca670c13d80d3e148e96fec930b046b051dda54ac46c9f10c46556042804a45767ecde0a7e9761ec897f62173e3e6d798e79d46bfebab4bcb8ba1bf5e2f7f495b3a699c06160d6ed12156812289b44de48f4eb6be0134920d9a19c617718e62c123acd8e496e7f5ce1b103f158d79084163350c77b1feaa243a4767f1a19984ed33253e1f1f3a3680efda1274fc0ae515c2745e47bf7c3941bc96df802df80b34503703ad6ad15365928bbeeda980d18817ec853c3d020a8952eb1f93581b37a08fc387025168ac07c8fe674cac44cd61d65ad332c72d5d6ab484643a68234778c80ef733dbad246441562b592b1a75a7d7f7a15a5024d3a644f53be06a15e45132b18b80262ca5006379e2a6b56d7fbe7db1bf33e7f9fb39802063bb3d1439de9c86f88e0f2b1affa3dac18f4e5047e11319197f6a4e939e47e59623d380c2c013f090494e2f336c8e598cfb5c0b170c748c3afd134d86fd33f2d86c5b85adf75ea2e47c59b36d18c4b066c998d2bb3be23df7a47249f11278ec57ba7f6b846747fa5534b193d95a0e5f89527321d03947d2850da054b1cd7288180a48b0fd314b1024eaf7a462bcedde08b96d76504902241ed5f4798b1191167aa515ed2a2a2dea05126aad336958a23a6bd996b22da2e6710e40fea49d0ce21dbdba27e9dbe301ed956986947e3d5aebde18aee726e7f36b4369e1fc689a4caffb2658dc3acfe9e386436fe6c7378f122d7a0eabc051bd6a83cf2400b09a83e7e6416364d66ec1ce4471e1f3af5c517e8a098b3d96691371a7e9cff5e9a74b09091d7578dc820ad814c83862a7ef6962ec36d780774784f1d691c82569bd719eb03b0dc876c18289873b0709cca18ed80bd55a3080f78100c16a44d441b1a821d65dae9c87f3960c9d1655beb940b9cd7678d36c10a8468f6fbbb2978224a61a79ea586daa8a271ce452f4979043b2b6922d2415d96f63d296c5b2c35c23e1ac80fb79408594f7ca2bb0598613c3d5be260b4b733d22201171ce11dc2c7864ecb317672a1a30ccfcf74e98e492580a2ff222e469124e10868da5d7b7bd86f1edff533742cf891c0b7d75f873cb703cb7354a356695fb5a4a9b91df8770254502588157e53636a86732772a44d30ee9c4e20311f0d23942b7b6e03e531829e294873542badad73cf494774681c523bce6d4711750b05fe409e182082e2feed676569e9ca4fe6d5252624424bb873d413732005c918a38ad8dd9c61dcf3a24e35b3da8bef05a50242aa9c3c252f5f3c6fa2850b456b0aee4209634d35f3688c5b9896b87bb6a8f6afaa7d9c7e4018fe43e60d9579d515bcea61a7b905fa44b9a8af97baa4d266f4c4a9ee2f21c0813c0c51ca308b3eddc488d41c86ac776fc64dd55bae1dbc21603f4a6cd3ecefb7e1c7093027c7e6f7c74f7a7a292ae9e69b8f0e7c795d3fbcd02791be4b302b75369cfe166f99e2866950f896a073b54b15e6b64ebceb8dcd80e986b55b2882247f95d002127c6dcdf4658908d64161323d51fefc2992742c4c900e061f29b66fdf5c2db21b49bd214b48f4294354b993862bf4b0388e2fa361140efc37a0611422286c01508b340970046764d461544b491567e9363ae4a992df70615b255595cc1a799e7ee27aef6618558454b49d79a34e7cd0c52e147b98ae36ce98a6fba8188cef63299d9e3ba250002d727e1032d827437c2d5745ffffbf1d798f057aa906da2fbd36828ccd568e1482047133f60400a294d7012a127584e0b7620e7cab15ff89506bfce03193e482ee874247ac0b44dd3fcc37bb3c4f8a3e3960644c64e9db94330e88d8b90646ce7eeba37d3e6eebeed07d69f231155746784b6f6d1068ef57e004c7641397d22fee18b54a016484d8884d7abb26ffddcef5aa470852cefab76e5fc4c5da3ad1efa5cfd2666400ea62ee7fdf1d819c9315475300e8c6e33c26bcf74463bcf8cf97eb22e52627871909662ea75d44eff53d5bbb5853f434ce1fb2245d887273246da2a27e274065e8b5a07019541b1f68687e455dc8653963a8c44f8a2669a5524a0646489ec3d025ca1f536ae7cb737e57a0f7fd9731cf4192eff789260b5c9d62be1e65755d462bd8d521e4a936179f3ba9fc5f66d04449b7ea06626077e6feae091c54351607aaeaa77d14ae51e26711dcda1f14c3013a7ecc44705f73f9006a59c9725cbebcb81a5f446d20325d58b76eba2859606fceb2f736e1550f69aea0afa4ce25fc18786d852a9c194468d764e75c1ed6e47af6b6572d891e6d1c95512b4f8ab84563a64efe5253ab1347ac624b976b82b3dece8ec444983672673184ad882ee96db7142c38c26544e8fe870b906223dbe271d766aa8a67595779007c1f0ea676002e1dd9b954daba910005cc418c1f1a674501eaafb8e394e54c6ed54788d04c5f244ab8a0f1bddaa626707806a1d113f7baecf5e3493550f745164d4183201fcf532750b4e0600a2686fb021d5217ebb7f9412f09c1e0b1047b48236b69a6babb8de52907e9097d96a0424d281b4b5794f7af509c0886e3771446a59cf660344c6e13541c6aa4a04580cc5c1bad662dbf8ce6fe1526c67d4a2edc3b168f86c8f4f47490a508dbb1dbbecb1a582fbc064d22230574e720e0d7ea0831d5d16bbb946c5f25d6e4854f4f7c73904112f451e1a66835ae335cff4c9f67a83e62fb08075e1f24602f7421fd093a298f8f09fdeea53b6a150ddfb1d2674d2fa6370c7668de073ea2451b19083b98a7e6de23633bc3210497b9a817355032c6611e0890906d6f1ff599904e1ef27f67c623ca22e9c90f32e738eb5529e9b16fc7e4eaf92049dff4860d611492812844978edfcc4d54d5d4758d57cfb4436082b270b14061ffcfcc26075aa230aca2e86e71ddc7965427f16de37688831f8abe8507e5f1d7cf86bf3cd7dfbb7be48f6921dae0fb8f4f1ec3fb303b61d1793d0b23557d7ef9a66479e92c9050eecbab6e3018896826a2541d408e5d1983d488300ffa5db3638a84b3ff6bc90df33916f9aa0931e91b87f6ad073c8e8d372284a28f3e51a0314dd2b7ed2445bcff36183577ea97f1ae9e77b6b2632b60df1eb194d45407fa11413f51fdaedd3a242485b1940031c1c16a01c682a597c1509623853686a4128b2b16ba29065d676e8efc0d746a37362634fd068b470792bc51d86466253e4b10aa54554780e02b6174918a2bb1bf97ff3e03f60ded22f999d26fdb220ba38469c25b5a98c63225d9775b3e9432dec77aaf9a9740896565042ab1ba56fa69a5335eb31f3863ffce3f42cebc75871f548f41710055ea9a8aec28d5e395ffd5113abac87ce1b6da3de7f804cf66a8e0d096ce378243b2526e739d61435c0d9e87c823f4e72faa77e7b87a59e751799f171a2ad04fb13f7221742fe39a28cd3549f8fa23e4480a947a43128b6eb06c922459c4ed3ac25e3b88a3998b8b0a148ce96f4b64ce656d5b182b700d31a371446acdfbc4ccf082c8e38379f5f73aa28a43c9219faa7beded2a87753d0dfab75b104e191a50ed7dbe2fcf7d1819e6f03751ec4c4e07de35ee4b7f44c5eadebbc3e22cf651b565207a5fcdd2bcd241a5b3c6c78543584eb7edab4bf62ca99988beb2eaf86de33172a4e5976bef9e05dfc8163d1d40e630f09282bd0973685f6797476e290c00e83c5865049e416237e40062d13524f9fcdb90c34f8d1f21a90235248a46cc66a44048451fc63294f434840e3c63e904a55347c14f74e3b2491691cfc3cd2c34225539c17f753331cbc892f81b2fbad9f2d1be16031182e316654ddbc53a3246a648a52e2fa04b4e6b23fda880706c98d6742adaf09f350eb45a53f14153d7b5404ede53ac1fa79e089765ffdf9e6c69489d1a82649c2c2e3d9c7c0150fe4b2cde234cbdec9720b9b92218834d4cafc7fbb97f316888f7b04c10b3580e03cf82fe30fee4d5d6b8637261622c09b6e8cdb0e5e3af8bd819516b9654e6055e4dc58db021dca8038f022882c7e72abb6f351648aeab09c484b12c16ffca0bc41017e01aa7a85dfd654df2201c62391c6d1c193a66bb58857515e8fd6bb8e706fa135581b469560bed4cb22fea3b0e4f642c7d3ae2155e057b2d8edcffe844f875a659ab4763019a8f7c10ee3b4637942a9021981d4b15530fbe69fe49476dbd00e14e9311fc095c1db37741d81e3fc4bf244d45c327f827d78079de2dd9da520953961f4dc4fd8acb716e099338e4ccd52e7187ccfd9360a57730b8713d03e1e0e7499955e66491354cfaa678a6635ba63c97a5610a0f019317a651b5066e83e8cc137807debd808716ed8ead604c04c482c09f3a9202f9fe4d98b7951f0449f7c4c61b188af3bd2d183f5a22a3add6eb8bcd1924823af0dad45c5582383ba04f0204f8e1fb0bbcf259f561e4b928702eacdbe6a2405999794ab92773490f5095bd506a6e6472d9df0aed84445fdb5c0125d5a55ab69a530935ad91ff5d54ae02cb624b31c1367950ced32f142b4301b2ab2b519b3c7e014a8cbc28536a9c8b65890f561edbafa13cd3077791f19640b1811e3fcfd87054ebf9ad8d8990b21af2edbafc3b598ec75720fb6d41b840004a139f3d81717a4736612cbf575d157a1d4e40155f27ebbbc1cba644d7ae45c070352717e5eddc014efa243530d391203f692b429ba9b9bba6c53fad5575a68e35043afb0c3c3b82e3e2dda54baedd86f021caf41f78bbb00d83a69327929932654cc2595da0f354fb6fd532bec96ccf8ed3153052d44687d1b9213161b7242eb8e315fd2d03f947b5b8907bd231d31c682dc94fd766dacecab7885e0beda70c22ae29fead0bb217d91c835470baecceb307f1eb04685debcc2a5dc2ace2a405e0a84b8e8a34132738c6754ea37532be2d98e36a1a810eb037e29fd19ef958d2804811aa4d7128795f4dbbe880e618be5069c1af0dbb946ef64fd67f4f0a05b08e8952458169356d27f48497867222f31c6daa1bb40a72e7e14a610b1a4a102624ab6f40d76e7ddef51ff33e337c3e7e2f29d95a611fd3f2d2ec7c107a5d457b501977a8b5e93bfbb20cd941cbaaf7d83cdc0bb457318f4a8351401baf82b085436b01b3db9a351905bebaae9554f8aaaaabc6ea2e80d270ac6c1534d8b49f1d1aaf6c86164dda68cb1cc55d84157bfb7881fd9215e93bd3944f105be3c02d00d44873df020752b9408a16c8ba4de4b20bf2d43fee8a94bd775e42d11be7709a00fc7885f311b960c7599fab98fe8589ca643f5a989a101a4ccba2ad7ac0fcdaed1f4a864361e0df0f049dc032f7ade13a24df99c2861c83b33e1b93620060a78e450480f0653aba3681e97b664e11f0efd5af1aaa05eaba8547c45e40ccc5adf14768cf42c9259ff42d5e98e3ed01aa3b83a077600fff1fe1bb3439ee871255b417b08a622feb37f683b85272f3b3ce608a330b27606e5c45f689c1ea31eac53811528b776536f461e7648a25668fb66d65c2eb3473bb10e7c24d8d5d74e317468c5f5c91299f6756b9d54531be6d566abcdaf61bb2481195cef4ca6a9c5b93e596a0f8af4eee94e788004658960304163777243372177ff81150d0707be87a712e2feca44f7bcdde2ce959a667a9adc0bccb2c4e04f87880ed46d2ba8a2f04a81c950eca48a953fc28ebe790cf3d553f4127e2248da86f3b84750f65b7297132d01a3c9ce756d34709e0878120eac3cb0bf023a8e5703b375abb3b92a635f016445f163d2c4d8821891ceec1a5aa9e26995c39b6a9431b214b86a397207280c8fa1136b35664c7b1139f9f29812911a5c7d6504bf4b5137453566d8509b37e224792fa1ccbf144e4c4d2b99469fd4a31d6ba0a2a6c0bf53b8eaf76a104f736aa5a6160d5a24e65b6f04524818e66c7372f2e42d42e43eec7e2930f041e680c34b40a446715a167ed8a9ebb0949a5582b7dca5d5e45969fd072cf2631015afa5bf789caffe315dce28f8a726375f49497d45a39e8f6216b9370773d49a24ae5add8ea48542d587cc40d8d3f3a683809e84e81def21ac8b4f09a5d81ab34d8decb9d03d45e2d68a6bcab9cb4d24c9772be85424a832f9ec3c6235493768ead179cafea6d5caed01e62a37879c747d6d0b7223ab2bb6bc1dcc09018e688367c7bef4e4f3b49e2c209c90b056d344c8a3385de000d16bfa3c20d06b0625ae98c4ef3a1ebd38a646caa71acf85e1acfd2ac7243e7bf32ca118e42276dbab544c3ae8b22144f6ab9c4604187060bad1d80f4bf7e85fe812eefdd589f99a301c531cb57115ad119bbb7db51260dcf7cf163a844290a2eaa4b5ca597de37b30501b7c68ade1e5378e69282aa04a4c34ba98cedaa682bcebb565a1e69400aecfdbbc3cdb40a318e0c72ce1767d58d3a50c0c8965b606867e99c390e92233693592728b6d3d79d6f0b6bdda212ecdc0ecc6485a779f2ea024125d0d49f4cfc6d578de3f3be7fa53936d89780174f39d01eaa6106ab4ee7d9e32bb255638168f65dba73bc92dfb6deec71f37e503fed2e46c3e9412c13536babc70522deb246e729fb6146d35773b4c5db4e3d5eb7c0894fa0f9952f1d700999e9c4ffc57175f047eca018ba53dcc16fb53fcb97837f07e05db79cf23dc8a96c97de8aa69305147cc4d43fc03a68b169f91beef17acdb4a8ae223506539738658ade822775387ee89ad35982b52a52f0c65e2634da5d1ec575b8c3f4456923aee5d0eaf1e2dea5f3f20db1b4a8bca9e9a7539f0bb7554ee140928fb59fa26a2aaab5ca0640fcad07a7c3f11ab54d194b1e7bf7abb8bafd5c371a98353761e4ae99b86f89e3bb25957b5197a04fc05cf9326b66a8a617443c3a007bad04814bac84e39598c75e700cdd95f7472518b047336f6f4c785b3559b3b22e33e76ae8b9911bc595188e41186cf3ba21ea2c61e53d89c59e2f89a646161bbaa5b10e29da93655d050d7008a5196be94e197a27112e257d952c66ca2de14f26b701158a23d0a68e589256697ba9a4fb2a62c4b68ca62ee04364939a7cec4a9e7b8d2a6bb4fa29cf580b2b4ef7790aa8cdfd8862b7048fae2360c5d379b397aa6c9fa3ddca1b2495c50a21a61a41b62ac4d1f0787ab9804db77d3163bc1c4110c4b6fe6ca02df656949a8913cef6af38ef1cb261670ba16832948bbd0299b15ddbc2433776e060d25748e402a83a059eb69626f880bea7792afa4fd0839a193af3efb4b4659dc1eb3275f36ec011a9e974a73b4d72bdf1c671462c9bfa85f79d94917dcd0ecbbb3446b8393cc46b26986666928b47933375955e4aa59b57f9f05782b8f49b0f35563836e11b96dc0448f3dc4607b8497e96d2e1ead3875f30e46b14fcfe0269643deeddf02c7851cf787eb397169b7c6b58a381ec65bb2a201cfa3b793bbb9cebda83c81ce64384a210653c876baf61b67a62508ca89febbb1e8011eceb51e9d2f7e4dc51e319938940380c4365a8832505676630f5d72ec561fe32e3607198af1240f1837db46014ca86f2885753f5d65a0a6667d559cb5adac239f5c64a49c9f6cc59d535f99d57175da7a1735ac4891d81d9909585083d08bb0a1cf6b532c88fe4d8426015cf2b98a3a9a5d09657d31ed6835a65f590241ae19e95a4a94094f622a54c7130ebe07cc5a56435a40893e40520a3dd2a67b64a75f4f6be4613e7d3c59d26891cf69bbbb468c327724236b268997df5f5da6b437011276a50015643f810d6fb57eb8a080b766bfb8502c11487c251c15012fb31da7eb27614758c7cbcb8107dfbc85ef606488562ef57fa5551e4838633a6181a7d46f68f9632295d1dba9b59f6eede9708cacd5feb8b2d7179cfe5b6d454dbd7a4fe7d60c4650cf26a2190e6111a174d7036ed01e25c3cdca562ed811e69d5422ded888b4ffb64a603b07b291c20485a3bdbeba8462b52f972f7e8ab66ae40327aa4db21d6d0ffcd2002ce4a60088ea38d35d271febd6f5bdc061466d88ffc4f554b94e1da5971b47e9004fd0e885aa7d1e3a28a00fe50f49638e39742086bdc46fd03cb0bffde5a05ff125b6a91a255b47d0a23c95aea85e12271101905e9edd9c32a54cb5dc43326526a4d56e75967fb0b1b03d339829b82b47c0c53260c50702c23ee398fd42511d6eb2663e464d13413a708fb305b1d85af3f5e324e581cebfa97211f34877003633e575c8e2ade645a4a5fee51cd92ec43e7438665126d956d503f4b72d4aba04011c68e7633cbb1e58c1ea5af011c0ec1ee49dc31aa97489b3d48d3d0f2ff739029d8c3593fc64b0d8c5fdbdb55b3238e1fc31ff2bd041b090da62966fa193f075d48d6bcffda4d62d0d69b7b968343a7233f721a2fd8ec1f89862e6251b88441f33885252040a1d22fdbe677788932280127da7136d099edc18edfb806adf03ceb3a88108286bc3d4f6956e8f9ccaad9a23432cad9d3c91a6a4bcb33290031073e4372ac4b02dfc87d1bb69ce242beb5ee8d6a89c81880e24dd426c34f7f6fbd55c799d4909156cc162e167f2e46a3c9eac38ffe0f8ab6ac914e8d160f263a0e8152410e2a50cbb075c77c8c3f626477d28d3419c9c4761b48750ce4efee0803b81669ebde29faa2f5206e8dcf0c5c7e9b21c09530839889a013af6080703240ab366ee68f7e5bc103bcded05f5c1d8f1d6f841a49921b84c3e0e02d3add82be70a3a956594bf6873d251d9b2fca66a8c74fcc98ef3de3223368e37ef49ff51ef2d61c1120456d9ef550d6abfd8d49c3ddc63893c66a48d1787ebe70d2e050630695e465471c847a4acf40f641d3e90596c43e11afe584bcfed0570b2221afac6b35c64d4590e2870bb9acbf4b7a847a90e3eb7d34102279f9021db72b70c309ce3afd202940a4d3296bd8df1c353889e298dc42189fe298ba49191ef306d24e2e780e8c72a0a38859f4c6e64cda353aacabdb210dab63e7f0cdb7e3acc2f79e0d083afcc609efaf2c5e0d6dfaa734a0c1c29cf96269c466cae442f7e8b53e3f837a5c5149c1e313534715a83ba4b8c334805b4f4ab51c7fffba498fa99c64b1560fd223e3a5653f84363cd5d18c70616aaab08f9f10aa8392748d6d65d2a6638a0d1c24153c1f368d2a16302868cf68f24c3fc50b06b41901bc236ebe17153d4d4609f65c976d2bc3d575e362c6cd5aee8747098b8340d0161f95d0c7807c1c468a25e1d3c1766ec1fff40681450affde2d2fc33e4dd613cfe03973fc328f80470430df05865d3c869e75aabae850a9b99325b7c2708fd30728e617284b7436473525a7a01017a54e9e8f9284221a383e141e2b7fa5ed0075c2e6f057a0bcd01f286c21672704912d4fd88f53ec9311f383a97a854c92b8cc9ee131562c64c9152261b85c1de515aff31212c965ef7473dc7c9ab67656ce8482beb2d6f7fbb4be17fd0cd3e855e44bcb206cc8afef35251387f9c93aa75d69737edac61a8c2e67c68c2e8cd530dd0ec9cb4d032f229a8b5cfedfd3424d321d9606bc82f7565975bd53e61a803b04261e2159e037b1f0316c4ac86de24626f385c887247171d95de0089c832850259cf16d9edfc9fad0717da6039fb49fdee2a324781338e30c675311ef7647e7d17d3ef27b1b4d7745c6feffd2606e6be069e59432267f4920a3632727898f3f586f316762b347206ffb1fbeb3707ce0d12439605b023a75ceefbb94d219b308f582bea693035afd91634ae1cd9c23481bce8dd0015d4cf230fb78195fb91a75c4e819b30b2ca39657fcb218c18ad965250b39faa2b95be442cd61d145db299a967e20e6150735bd2e963702245f298e1026d8d326f1b7dca68630d2bb894988861d8c18b82bd9f84e136ee6e37fb2e2eee6298114b3a428f20c557d85f4c1bb1e285c31267e2adceafe5965d6901427d2e0beb18ac786c7e9f5a54817d8797afca86306dd797821a3b4bb8fceeebbcb53044ad1ca678e5413e04a7a79c7a71081cf23a4ab084e8a952b816e13f8e7df742e9019da8810849775659b7af5f24d2f2150c416d7925cf4be8fdef809c2d09125f4eb268c62ae0cfce196033555325888f02acc5fb90352e8a90140cb53c75acb0f59e0464dcf7479e0af3c6071e20681c6fc1d25506a967af8b7c2f6eec34fb71de5edbd03da47f47a10be9ce0b6f9f8d91e279eecd1bc9e324afd1f480b4f078b2f0372c957239cfe3900e17a6fea160396d462e01fdbc87c5a001005b48d4162c9b183f41194fddff9fdb00b2cc443238d8f6cd4d295ed0f623db05e903a0be26c3c7ba719d8442534b4f6448f94d4e8e01d0610b650ac37637d63cfe9f606545853b88c79bf54d2ee2d7620b4600717dec88c48111cda295cd2b9f350881153b82ddab957bd4707d5d2031bdac94f751f85c18e814e301f4dc914f626a198885a1deb0fbad1903e7206cd75814556d4b2ff60f09440f8081806af5571d132cd9fe70d53a3cd29f9d0ab7eb311f1b13187ae605280d3b241569024cb3dba41d0e11c9cd59af6bee023d27403120f68995cbb621105f7d7cd0f49d545df3df5e1df6397a7543deb4cc9d6585b5ac81c963784662bc4f1c5eff3d9884e1820a4dd260a705c99b1f7a298b60298ccdc11454b8a44bde3f70e021954c181d276621814599a9ddf07b8f3bd1aaba80f07c3d91a6abc6b5b7d340fc80b3f89ff272eae94e11c613ce5031fdc6084c0f33cd0e556db00997f1c525ef58f11336c5d1650bd1ab81b8e148f27f89a2301d2d2a8bf0c8a7d8ba6699e33adeca54bfa281147cd622df1718d317f67d0f9f5d8bd8e77a4f0b899660d01278c7721234eab46bc69efe90d2f60196cc59fc51ad2530ba255f4c6d135e524cb537fef6f2c50012bef1031d8ae62001c25bd2fb8e826e06ff1daf5b94345c8b36ed419fa46eefc873f4cf607d6e6be461b039f2e006c0e1d389d7faaaec9d4923948c69e5612511b96e605ecabb040a99b1417751df39c278b45093c2e15a1f6119a8a547b08d56cd846cefb6efc7d771a2f5a07314b6ef3bbcdaa16b874b3ea864bb756ffdea0a96c5ee4601a41f174ba6ac3abe1a639f3683f5360fb72b155d56a3a96749e03f35e22a728dbf771e1a85be3f4266ad2907e6de92017bad694e286c8dfac59b37b942a221e854b2a11f43ecd47f8179c5f47d1b2dd71509d0f5530fa7d3df117f7f44472140979c1eae5ca834142e1ab894e1ac43e4ee720066afac4e44e09945f8b94296fb082352d4340ecf38e007e7be1d632418aba22f772520be8a1fa0fe4305909ead0970114da9b5a5ec599f3376cf125153b074b74ccaedbe4a93d03d2b1b5f253e182c829f881e0cccce69cd51a230df22f7cb43c17b18f5a027af88f43a52f5d1c5d68347a3440bd9d2f47778dee5418bd18ae723a29909e8d5f4ae35e7d5e63db9998de2820e2414b73cb23a854ee6af26c836bc51d9e955c2124285e2e989782483a3d40ce13a85642fba5ca9463b286727e07bff221deee275ca2723018f8fccdf398c1cc00e1cfb2e35bac70d0a7d22fa897630dda29df961439c63ff1c1707e505d79ab504ab7cc29ecc9c82fa309be007caad74d5170a28569e6ca36641cdbbfc8078928bd9bf70b4be31456801a59ed1e42115287d23ed398be9bde67ab168c5bffa62d938bff4829c93daf6de035cf7ddb1e7d0394c22e02609c27e00283b58fdabc6b93808a34ce933bd5522ce8368b2a96ab740e97d64dc0ad5d301c1e90f1dcf6e442d5cc98881535b919c9b1bd94e374054b49536dab26eeeea16be4273bad144d9b633b732148846e0625d3df8d0fddb37ba4e5b5de6d55691aaf69cea41e8a26758fba906751e47998ca4bcfc71524dffa406dbfbdd53cc959aa2969995005f3563ca49c6d4a308555b8973a29b9df09f5130473118b349b7ec43dbe7a981137b1924833dad9b333a255d75c5155d3b55dcaefac7e4666e6b3a5cad1ba070da5f16a4c4a8f47127ffc4bcf39dcb8f7a77533d4ac426e1299e7f49afb2e6ceaa7c89239ca1e4e273b8e95b75b1beb5626af1a505f2d262dda6f2275cb2d188fb58f21b101769ac76a27592e45f0aa94af37572f661dc069e4ce634adb9e89ebd1e4281cb30f38b3d81bfa6d593eab35d785f5d7ff1fb54e1eee1e8a5359e33bcfb988b1ec5316c56e8d10e9afe94c652db4154c3ed187036d499e0b1a21fbfea147b7d03a284f15ad45ebde4f022159d4b43b75b28209c0b4d4845a2b45908f6112aea245d373f882e44c1db5ca24513c60bdd20e863420e3c0111e39f3d12950c98ca8023522bd24a82cb13614c67b08ec9190a7cedc0cd8f05ca0aae6f6bad503ba49846719b1c14af6c15f2b7b2f4f6e01852aa7d014711db84f8225c1bcf6a2dfe4656955eaab32f4b496e6d9cd6432fbcd0de3cbb49242971cddcb5044b101210abb2ec97f4700168ac0401b8e1da6025846f9ac3fb9a0fefd40a48008ef3f1ece31db8681fac57f6400c43bd14d86d80340db35a84c7eede638ff9ebdfe4153f4d24df8a97a01209baad77efbb86ba08d015af2eb3ca2972fce33fc6e28f78c56518f0195f2b2d6684b1c9ba9abd5d0475acdf955d069863150d375a4c1e9f49d068f79b5c3db1429ff540bad54e3cf380101e8a4c7c33a47f21f1f91dece9372d7194d6fec240af4ee389ed676986153cbc383a9c2a66408e68f009ce255227d919e0841b16feed809df84f2a773b9d13c36ac17ed1da4fcbeaf154bed504e675a3e1ad1db1f501c0cf6443576b5663c096e53d6802fddcd088fbcf7da35a0aeacfe4d887afed450c3708702dfbd2164fff30ca807f0afa92ff36f822973bf77b1e866a19651a77dd1de5608b694ded541dc84e8c492c4f3f64984a03e716459d1d30586a7d9b62a433303f0a9f45032183b19195d9bcd2b870179bca72580631dfb605c77949667a902233c2ca8c7b514a5f6589b5fe1ee5d845340892febf9372867c757da1cc29383ee087ac7b80d1c2d9214f69925c9635865d3587203a9c9762e11882c6778cdc1abe2ce33f50b8c89b5f4edd4b2ee88b77216bec2f1e82ce6d77c59950c6a7f1df5d773a0d3d2acfa7501cc25e376fe499dfb3c94a5f31b57c1ff13a22da239a25ac0b3d307e5ef02bb86e3884c4837989069bc86a7a33eeb774b4d2fb5c4afc115f73ea9646c5308b71bf9f5137d771e6836256a98001372a3285f4c3c31c68708c8750107e2c5431db7cd4cde1fc32bb07f68217506cd0ed39aae437e1c005f2093e7a28bc719f04abf60bcfd177ea55eafc685162d2a301ee8aec9a0c0cfdd3999c2bc28b22261efb4246b58909d249b8f8dca21f59b33ba3f9cef3404ae7b5e5081d18ea080589b7911bba4e81fdb4e5b53ea9d87173f1a14307d34866cb222e943b283d6a160f2c54f361b66cf19e00099542eac2b94838cc0c4d579f3d9503e31cce39f0e28e70c023000cdcfa8d8d57165a2a8aafa64dddaebcb964914e0817b0edb18615e6bc498cff824590ac9b1d419c2652f89b92ea8a6588f3a02ca206185e0aa9019ee69230e6a1a64f328f26879a8eece4ab8ccd8516010c801c7623f8236abfe0e10cb3a3daa3e1a2c9cd164230c0ace30ffab4c190b6fe363f6dd5e451a90e7f2d98f8209d9cd0de4459723382fbd702e5594032b45708be1bbfe6b7d799b9a8585d45f55e35cb7ba51b900aa916421a30a3f25f89b023c068f58f0ffe8db16b72e949742b81e38f369d2d5322fcd0832f72fbe86a08438bd9a70454513335914b68d129d4b432a4532b1bd24874e6c1067199321d53d696716234ca485d2e6708c5cfaeafe1510700cfad14b1f488b59e1864e1c55a696fe1b78a5091944fe45d63f7d23099b450bea9158c60396a4a92357455ada38e361e6a15adf7d8ed9f276a7ee9388aaaff5830dd6cc937ce6b3c775cf152b49ba17b9545c404eef746c22b3be5fca0a44a5a744151b620e91b52de2939f7c38be1d3b7c0c87af9ce32415336f5dc9cb3f4feee40f7c93f4c3b65a1b7f4c23cc794a0985fbac43a6f292813e6459dcf3954cf91b5a7eddfcb11a49d16ab068cd93ee52a40ebdd0208ecd0171589f915019fa8d252f98efbd3caa53e28480ac6977f0d9327cbcdd5c2924235276d1aa7c9047dbf21e159fd512063cd1cb2ffef25b3eecfd3c8daea3c649f84df383e1cc8062088e2bde356e8b7b4665556d2057a34631e469a5d79ea6aafb5433042965f52272260d51b537713606e376adc65d880e39b9949386a3ab7c2ce3bc5978495da5bc10707427635ed61b94c69bfb84a8a5a6ff14b6b3040fbfe020c323028c5dd9bf63a76a8414252ba7882e98dc9af13252faba28bbb5bd33fc15e74e42dd5bf4558a93d9e935646cc5020641048a3d5b10e0150cd2f3332f53e2a6cb43bdc594a9647bc336d953393fcbee3691915896dd67a82da224a8cd497ce0fdea0426b259f56bc66eeba808069367be4ca60dea283a86dd82dbb1e9ae449457cae92562b02b5235d1abf28b064fffd274c67bf3d5a9017e2d09c8384e117e7dbd400c7975e23eb6c4269ccbf2136b4e12e59b0d832f7be2fd00c083dfc61c8b0d7d9fdfaf78cb06afea95e32b0522bd96fda1689ae6f35f3e38f21c961920004848fab74db972c16007e5f5964bd9db09d182e00fa99b8b925b3f80af213b2718163de1a4e6e495f949591d01c5dbb1dc82874a1b652d0cb1937b96a3d649a30d0486cf8ee34067bae196c717b78abfe5203888e0f6029a0ab5a52d9092b9ed384a24c3a5a427c05fdfe46f5c96285d83ab04e51b7ff06a7ccadabede7411ed043aec0f3c04eee56d5a4a623a9e5c3c1d71b80cd0ca395424a6e07ce2149d88ef6c899332c8aa0da9c0eb565866d47971fe1a502a5350097b24d36c67c99c92a915b5ce399744a0e9a245af93ac101b02dc29451c835f7f4c6c33c80c4d66a220704c0b2f1b0522f3bcc10bcaa16f090138638a1749cec2e3a8ba4348258560c298ce36dc6f0fa7664e05e66c227fbb54cdb80f355de8e4f4562de617426c48cc5025fa53e687e30698d83ccf9c97e6074d43966b814f66fbe4507440c879cb53e1f5fcf1a2408e0b05a11ec4a3deba757756fc9ce0f8e0c4b93371746e6ccafbd9240620c9e283b175198756ffc7bb3d6bb83c82cda9b5d636b57266ea674db4df2b5553066bfb8f75520f5647f379c16df4244ff9bc9969060cc10fd8af6443a02afdf475f13d3a1140c6a2b5a7afdebcfe22f21a71a188862b7f853551f54912cbbbf760c6436f50d6006f4a6d744bae146401005495deb558f9719ca77c0877b68f5967c81d404a8a1bf7fcee0314093578d262a4c2cd884c8e7647b489fb1b89d653b84e6a1d1ca2dfed32f3f376dd8a7868f0f0ab54c9ff4078ea62c19753d329a96edda0382d46fd9b427ebf6551911e980cf746f19a909f7aba3800b994315381ffc23962270d8fbb92f52d4030fc782d972bbddf8c9c0c44dfaa2a69bbda4c91a9f6c269e4554f15d553f78478243d8275d3f09285da9c8e4dd8def367098434989f82db239c642277b58a18ae05cf8ffcf157402905e170a275c750c123a3e32ecdcea35c149c12fd0930404cdb12d20063093068ebd4dbf257880d858118b3fea9e9307bc9f29f1b61879420cb9ed3563dcc1f20338c96dfa863ce6926011c6012a8dcffc2626a576f5cf660a57db7ccf92e590bb651bf04defa3778dd10b1d2ed5449d036eaf8850498e83f74251cf67ec5017ae2d84712cbf60df21a41ff792d76849cdae111d2de167b98d26e05a6d92b2d0a66a61dbae4e7d5456d129b64b536bc23d60e959355275d976b8e1f5af456ddbee18c6aa6ffc03481dd6e66045d784403151d20b6e75fe661b47e89e5b5b5be074b1fb2b46503abeab5c41c09527ef64a7c195876b110601400906c6f653153ce59fee6210e5531aeaa387856ab0b8a21c956a0debbaaee400f79c23ca1b815b712d557a8d44cf02464e8677c0be1a0a989b0cf41944c51b659a1524a3b869405ab24adfa982979ef4a981a5af375c3182ede2d252bd960087be844c2829667a9791aad38ce5050f7db2b831dba258d2633b16c2cc03dc31bb2180d5fdda8d5eb4a6901e2a66e790208f45cd84151966ecdbe09357130c060ceb76d70414da21d5b29360caa835efb35e477197b99688f6df4f0df876c2d60937487163ec2451fa29a158e27c67adf5fcc962e9d7a4f7dcf048b2e1f92015a7731acd2022c0ff6c09e3f8fcd7aca15623306e7087d2fe810c12819a091052f2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
