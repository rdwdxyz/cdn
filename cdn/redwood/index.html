<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7ad53643d18d31183afbc5ec411be467a428801e5ae366d244b34061c904292832f9d22e99b8529a0eaa6e4be3eb50bd0809de1702226387e8d95abf31ec6bf1d9e212209a6749782924d33e94a28f784aa21b2a20b5eac42c04ba55b03cc4efc91d61a97f62a37ff4c0a307d3f73e41076219feb11271fcd354572c4ae90eec60e43b20e986aad75d376245923bf848c58075ec353bd9b7a23d700f9d13597cdf70aa1d66fabbdf4ae0537b85e335c5ad8e706ce0cf5ce84e9aa5d884b72f9cbb5fb7df9d026bc3e2f23f833bafc4ad6d3378a72c96c8b66bcd14c59b1291ded9fe5bfc2a7122269943d185313dc0bd16cc9055444b9da0692ef96e49c0fd786b306dc1c0fd6286bf86a1be76fa343be297f0f20b4e06ee09ec8257047d5e2498f7352e0a5724f32a3d2085a17c0524b55ebfdaea5f6d80a7aa93d53d9c885d8c97d787f82f4972ecf98abc92496b17443541dd9f7e6c769c7dde177ee492dcfd60414b5b67e11a4be0f3c10033368c3ac5e0dc886cdfeddf9fbe66f69859b24be382ea88aaf0f7fe2396874f626118cb98734939827b5afcf1e634e6fc9fb5aa1c6c8e83133d330a20f6469d17e23f496643e01c5cff82fdbb08a198df0e7ea19b26a02489195c9ec3e43f3f8648337d47d5b675219d85d2939709e0f763ed670ede87e744a78bd58732fd69cbf99a563eb8f23951f73a26432e14ca8bb5c8f32ada9f71a2c0df5fda3fbd14521e739f9ece93e8dd25fd95a0610bed48f270d0ca34d4a7c6ed149c4546b0344108d7381fa1ad311fdc899fe4f5ed44c6c0ced97a36cb6f5f9ce97e16969b6e1d1b86e370bf137a17e0a927f3e440ae63ef1d2012c7d9753e7c7edae62246e6c7c16ad063d256fb2cb633e59991a57fbe2b31d97a0b0967fd7a1b9e705a23e4c1f659539be375d927ad3605cfb3a56c09d9c4cc0487aa1082f72c21e373ec3968348ddb6bb52c0bd9d3a4aff4404194f27668db17772d1410ec9461b14f4bb52b02d64977af7b70cb74ede9fe5f96a39616470b91af728bcf94847c5356d01670e4cf4263c0a7ed6bd89b8cf9044cfb8111b60338656e139e7f5ea7da4232296d9ed9174cb99ff89e2beeec2e449aa56dbea8ddf3b3b77d1a8a810d9e486d1cdd78cb3e4196cab77723f8c956e4d2c5d48e8a7436894cd98b9fd5ab9364d9bb1cd434a8a39a597e42d7af6c0b23bdd632a0769870a6f9c2c32b11521671179a805f422740ab410a27d259b37fa9d768a0129e67ccc4a7c1da16a3191ddfdb09c79dc8558249c8619f3e07d827289f2b2f27ae9276819adbd7aede8aa76323f7dec59bde3d66fb5d7c655882c751d458c80e1276b20723419bb9c8493064ac9f15656ca1bd086372ddf631985fb18dd0cd592ef23fb6cde04dd0295e332f53e0863ec830da48c326c503f634c11d39bc6ff6bf51362ff6d75d8b0b377591e77f266f02f28c9b8cd3580c29a12d071cc0c5a21fa19a019fe6d487b9f855afb0b5537ac0184d93f0690e8529a745245965523e7557a4b6580ff2cf4eac6b2a50a54dc65e136e719782bfa8ed0552cab42c62850f7d83d04dc74e063f63da92dc4476e94f6ef9575f84b114c4316c8e49167e286e1da36dd32febc76e1b3f083b9a94ebf11c81fe1e57f0848b3529b3284e52cdd9f62fa737eac27a5f6bb8d5433095168f1d2536b3bcba9f67018c0333838b0b201ffe9692171042195881a7d35781526038adc85a6e4891c28b8302853d08b1c4be903557cb371945501e4b0a6f7bb1d53ae7780d06aa79fa708a35f0a58943f56f080030e0cfa93ae4ad5b214c60b5c44495aae1618e791f9e5dcd63ff165639d48bcfbf45f38b54d8933fc859ae53178dc6ceeadb1efe839867fba1e840b059b1e9b764b72559c946a95c159c13ade49a6c262ff622b21e3f0106d66211275739ff5383f7151c1a905db2a86a042b2bc3205d6ffe03dc5f33031c3f9bbe380577e87d74f703e6fa640b9eeb7042d9ba860e2271603a19c685c3870151430e93120cac9696473dc441b6830bb8075722280637da42defdab4fc82ba4186fa24be4e30cf065040c3fd85c3069e9878f4e7f8ffe318e1c45e17a2c00a7959b41328141dfe90d5ddb52bcea57207143ae297358c49054adcb4a23bb779c1d3ee583470b0d111875d3a6a9c6acb333547012735ff7962b507b22d5490b0d7a1e9edd6197f5334d21ef2455664e5921a69d1179dffb24be910a137ea8cc7cfa3eccafe2c1d32a67c24054e99acf2e725ae8ba2f8bb934667d7b65859e93fd04dd8880053987d32736b6be2c51cf5d7c1956dc6e400bc03ff6539cfd3936de49172136ac9fcb1391181aae9e13bed922861d3289e1588172c39bcd841c39b58ff4fa0128f7aca3eca2c2f17b2888c612355ce5873acff197a7ff6c1053c693bcb893b4a98a658335f284b2024454ed8914f62ae5fe6a1be954fe21479531de03687438fcb7c074a0a3ebde76e8ac71704dafd7c4d60da1b5ad578bf6684a75bdf73cf294002fd9cf9323a50f0e84d81f79caecfd1ab2ed64588e57f616717d84d283c21b13d654bc3ae513289172a2bb25a3d1569dd3668913d5d1db0e65a5d29db4fc828c0d3e090d55096d4399e6123203451b54a088b1a5f468608ec26551ff2832e64c71f09f0a602ce022bc04495c10bd18d2d0a2228f07869e34bc1d73d1f74b544b7aeaa240d22f17b3fb60e6b5cbd4943f1efe59ed87461dcd3f873023e7b50786c314497b8c3642d26ac2b5c2579eefe4eb29ddfb3b36f76447c8ad2cf3198402700fdbc726a1dac6eea2865d561a177565caa855e48d6e35796c39a1ae0101c056cf58ddd580e2ecb83103fa3d2edca2745bb09397bf2264fb79640cf721262a7fc61e4baf2d02435b5a884c8cd9ce4aeeafbc40d1ef0d8d7a2dd4195d77e87c8b48e31298ff815cb3d2e9c31d7af58088b27f94e75b19ecd4a28743459f61f051acf8933db0272d0cc3f22e77c02dcb52dba2086cda7ea9724cb340e1edd611260f4372a89d540acf154eeeee72dc82447bb20fd2c000f297e6e08a57037ab5ab331d23db5396d12672adda4aef6180aa9bf7dab60fcf2bb850667f081b758ad4f90d30c9a4ea8c08246326ec465cd93d1a2f8344bee994c13da33732fc296c23838133dae7107ea30b054fbe392799e4b9959a67a4555cddb4c91b828c89f297519dcebeb4f92d52a8b95a9f47c95097f3a1e59fc6336e68c68c9e197d38fbe726548b40acd0d40a1b2fcf4c12bfca1de49067ea8c008c2b845356a67de8ef50068bc4868d69907a25491b89947c2de2443ef47661a63747eb69b9246425930c01c3d78f72664bdd0a186571f22f3111a69a9e2a5341f226594773fe961097d5d79cfec9c658ea1f154077d75ece0c8c1c38e6d16918579455c3f31e6c7c666ab58761e0746f1fadc64245dd58c277208372883d0306180e1e6f17a2575b67b623e58765a2e72b8b50e119a31502c58d11b7212b74d12207b3a2df2c7db3d6d6f4617e8ee3de94f1dc2696cd3d39f58b7422323e1360e08b3479c8d7750919be4bdd20e5c2e14e1086b644cf97b44ff461b55af2bd537b20fbd1c34d36ec92ae51bedc4d92197011e1c5046838f7dbb2d0f0efc1726b8ae8f66ab31c73b3ba6e750f29aa9a60c29294e0708119bef813eebba07cf5445566795f0473112f7359ebfbea1a5cf3d34ab04871b411d871c81361d8cf30aa2ebbbb08854e940339c8d71c66b10946b58f93d468e2f692c8dc472568d0537da440bd40dcd7d624cae3504a78ea7ad5d05cec5b9b23cc2655503d5ab96616e7c9670da6142d117e3d8f6be96a70025453d996071df3ddc38897c19792d4f6a8d02cd72db27770be21d9644f3687f92a4b4dd60a510952d0efde9c0097563c754970c8301e11acb0cedf81723fdb823e0228f8079354a1b2ea8048be0067c5514597910cc683fb00ab3f2093a7f41cb9315af7333871d8f6ddca1d2a37852d432cb68102fa606b49f0db9004b458bbf1429c14975ead8f1275dd024e5af1229a53a2f007b9be60791e34cf92050bbaf65d9305eb25f29298edc76aa140817a0ffa2df840f5a78a216139bed624909570cc700e81e68e12671adb953118ad85864d3c0b99409032ae72b9420b4c40a851c71019508fe91fc89713d0160ce055cbe1c7cc4225afeec80e01417749a191df086ab456521fcdb8d0315cdc13bbaf8b698f004a52e128c22579187b0d2db474b81085544a482d17d0c38db8284757e7eb3868e73ac2559710dca5d0ffa78a3a378a0636d13c88e5f4e21579672c26f206b3c3efd5ef79cb945c37ca2bbb3b180eb9253511587df1c9cef081a30d7b2675d7da2657288229fe51857a9acd48512316977502b1017d97a50540908bdcb65e0356c3128fe90a0ff0c58a7efc4f545f4571f58cfedebb3a6f0c6ea334ae90154cf3bfd0a84af10c25a095c892246ced0a4e220c626b0492544a6cd3b234b6e3143ce3fdf1a4bf5b526eb4710f7711f52dbfc7e0647874956b3db176624b93348b0960a97ff635cf1b84dea37453187e02a8607f350b02796d79fc588daec58bdc8eedf777d713f926c858b443030802b7d7be2d604607c76297cecbbe06fb46bd41c9bfcd199913b376b28f783fa7d70cdca08ac5c6d2886dfa6df38858eb31e35a059101a20ae6fe85cc4b06e15e5ff374e9efef131432ebe44bea6a7643eb3e61a7219b5ce40eee87adb1f55fdfb1ca6d5c697faf7af3e4a1b82a6cd535ecfa9f86e43f20359dba63ec55ec2780ae7adfc8851f3e92255c4cc17ecd669a33c9a570727b1be4ae0550247c09a52f2cef34d19c35437b3a0dd7dd31a1303a25912b9961a3bb4bfde40aab40082f969054437a58ac41f139e33bc4f44ad3dfd90175b46af3a0f41948c5597c1b5c5227b32d5943ca0ff94ed837429dfc7a3950eabdce1afcbbff583b1fbb599351255cd73e00fffd9ed66878e1f4e088374ec55eadf7425439ab516dbedfc91380f783334b2da8f06190b188bb450a2f573da750664f6b51e8bacfb2595b8c32dc2c36b03549d8c4f394bf1976cee8b865037df137cb82032e6789dd92e3c23234cc45fb267a9a91bddf0cf7823abff2c9ac679143d064c0c2f0edd0e413398749177de33069c4529ac5507e9cc5afb084b788c116357e97a75b9203707974c85e739d0c319099ebcd39ac02ede7812a6a63dd5af6cf4fc88279df87bc86538afecf9a9af3a9c8c9511d2a3f0b7252a63f968180eabeccf0a77b446ea34bedcb16baeb87ea233b54de4db7bc85d00e024be44ccf75cebfd6c0422de64a4081eab4087539fc9f8f2f5da4a502882809e71148f7f03ae738608d44280f87d84157d5bb60c35178bdc98ca80818a8d6d11b0c60ced445aea938ea5230fdaf64a4cf300f0e4ca53a6fe0b32ee29894c531771edbe160df7ad427b3f6495655ef2866f0ba1d77b586e5f80430e5690d2cf69019cbfa71e029f6c8be25b1759f18e72e803bc119e4e27874e2eca494fd72c0e23c203c01d409f50d04f2de76f33f943d5df80a203c4a58c05fa45cfcdcd825898071a689f2c12d25bb5119ccff01d8faa6e7532f611565e902c4e95d2bc6d750f18a47015b61cfde6ba047a22c3942ea563968571bc7c7876c5646130fb4763e516a680ec1cdce547975ac4595e9c5e3869b8a3dbb074534c62e3c868c434c66e49788f5cdd36257bf7dfd610fbb4139bd9b90540955490886843b556bbe8bacc68cf460e1b3356309e86fd7ce1928ba1dc5b546fc4f381badf3cf0a6cb8eab8808cf3db205b2b21066cffc655a9fcc8063dce28805387dee45f69c00b6b2099d01c5b37bbba9e250cc4ba9dfb7e7985ef8241b8b7b19fd6cb8c9722cddef542a375dba64c623c961606f8f18b1a6e7b821924e08519585f88196cba129d1a3bb17c8b37ebf324c5a892b554d95bc55d7b80273d03691566d5491f36df7f43a7aed8a44f66149e5ec702fe7e6476be7e66c6af9f06c563cd6f3900f66ab70cbcb4472b8e88c31fe971e569bf29c8c56dad861ed0f5f4698fac53c181b306ce86aef3ed57d42c1579871b451fb91a607cda000801c842d4a5c2f502f1312ded8feb41657d1397200bcb59f6b4bee79372154550c7c9fc7c7dcbeb21f1eb9b7872bf7b3dcfa2f825663eca6b5325fb1ff849bf2b19cf306334bca750ba61ac3ca3795373f12a4a050cb56df241866f2082ea599acf03ae747b0e6072a5a914a713634be5011fe9c5dca98d6f7dd3e6310f5d68e35e6978410b1e00c1f1385e6dbd4059c75c93f9cd8c2c3d1f191d20e7def1cd1cd08fb733867e5d5a02c74d9ac5f5743bd53af6ad9839709b96fcd74a2985c1e0252060f10dbc5822ea67dc9f9be5e20ce379d5ba84e00f726c5d2452b24e216c00f2be326ee561659bef731bd2a7f0889c427c93687d40ca9d92660fa3d450d292c77b492987135eda90b950547f24c5e3ffdedd61706b83d94b7861c54444d2e190bb80384cb13c46ea4098848faba91d1242342d87c9e7433006406a068087445e16931cbee87b65161b0471482d0390805890e68418bf2dad01b73939770914b11fd511a3c481452a654ba825dedb52583ed682e49e3dccb0c69e4d57c7b36dfdb4734a2f897ccf3b83d59543754c1f3cffce57ff6dc2f96c623ffe72c9d6e51002d16226b12ea414491857f82e33950b3317a392e4e02746d4bdd983c9b23b22ba2cbad792902c8554889dba5f59825c48a30307c5631c24f00c80873d98fffddf5731973302795052f9e50f3b26d31b18fc0084046f7e964c8a54998bf2719bf91488502e5d2159a6d1e627a05dc82a37791d5d1041f0d1f31d6dc472fe340548fad6184beabab28b7dc796d3506212592744b3cf057a1993107add6e5863b2ce2091697b922c22777a33b8543064b298f36d2860040cb458c643713e5344332101fac8f3a8622f453f22e6b8277fa896a61aa1325e99d8ae875ced631de474b96b8588b59fbfee164b147f9041a28ff58aec0f0fcfc2341e9d83fd89f6afeee941d123c22f620ff4a3a22ca3695f1dced9072e6a07fe19e3ef85c01f0f4d9740b80561f3fc933b38a03d406196d7e09609266da3020af90af52731e6662d0e0fe758b47d504dfc1a88747b14000b00dfaaf75999c9ef58d51b6250fed73532a968d2b3f054685032b02a3dbb34ad0c0cac0d3574f22af85fbf6e2470122451a6c7dadfb16dab586eedc32b0931051b38367c20a5ffc62a0d5be845e3c2e0063531a1ad9b16cdea06da3d8b381681f553404eae8ea5d394f69eac091d5743ea56218a91c8970a1f38568cefb3e0cce11344b52c310d224ec68be2a379e4b727217d1088682778e5fb66d939183f868d6cbd186ed2698bb356bf36f808d9e945f21f405c8dcb7b486b234b95d6992389d08a4fed76f5d130de895cb574dd52d173447619d03ea6ba47ff2c444694e5846086d272ce81cab89e8b448a19b95efe12390f532f08f5c9ae348c7ada22a0cbd35b7e3302a58c668a4265864815176b35daf5c9b18a49179cd288aa9ac2ed2e3faff7b1e7559bfefdb380f4634d5fd1a29e0b1ee929b105988629e2868331a576e9d9e9a66c7c789b01999ae0908baf0e091d07c3b9b48bdef8181e291ae52a626b6e5b7910b9fe2e73b64a5c06d1814fef46937329ea40f9cba5cb5de95a4f2cf347c166cd2c0e5509aed99e515cc35e5012b8d268de891cf1aee54aec6e945acb8088afff98fce60d6161bed9bbff631fec294ecd3ff59fb16b14c58a2e4211acafeec8841241bc4f9f693101d59243e378ed95aa80273b79d63aa2f560920b72b7252f5f90a3565f3919718024a631651892495e0fced90e74ca362fa55b3301585e32975c8b3e606c3b40630f2a06b75d21ba9014d6875e25c5815557d8762d4f94593486bbfec513a44d7fef11e0e84b68bd13f1859d8c535bff11974f23c1ccf351cbb2e3bda9b0790400831c63c2a62e0f25bb7c207e6df8606dfb08586df3f20ab1ee0ff99ba55632ba997125a6ba00e9ad20ec9a5667d0f774d171d1e7357654eb793cd83cf2e4e0ab199fd332e55703bb516a644d213250b29d144fcd1a35faf6551816daa3c9bcc5e96000cabdc7e409a30fefd81075e4d63d7cc9b95f2f5b79c90d421d1eb9d89163fa12ac5a63d23a669b91df28108e7f34324bc11ebc897ef9983dcfc05cbb6a17320e1f76e3a9499b63604fda2a52e9fab7da50cfc6b53793dd2673bd8d96c495b6c1530ef164616184f589edac2ac56138326cdb15de863b93caa7d7659695dc8ce0cef2386477b8c357ff448aa5267cb967c611ec7912607a2e1e66f1d94967de0822c318ad257d5ecfbfbff907487afc986752eac805cd1eb04f8312770704ffa267717d027cd0ad5015237229ccdb4b7762049e8bae516c1443b02b4bac429cd5b9cedcaee83197e6ad7933d36213a439d5f9b67104c2aef0f2bdd9f0d7b48e091e9e66c58fce4791e87ea17f6bff6e218030d77988ce40cc2fea428339c35047585bd9de33e5c06bea791067425f5f4b1085819bd91217dd7ccfe40d07ce745982370872b4138dae688a24df5e2d05565fedc07eb3864b33d75db1fd0475f7ce93dee543dfe6adb94cca4dea1cedd8d789879d424f2a7fb236c5099c2f5e6ca0a2ad78bc16fd9587cfcc01f452c90345f5281e2d1ab1964fca6ca5e957e88aef6ee7e710f7dc93cd4fdd55f84f558dd23687cf0721d076ff753ed23b1facadc590947c0eeb70d626288f60cee20707bb650ffb86365a23cdec352d97065b390f2d4ffd0a0daaa1bf185ffe79c3d3407f2ec9faba188f33fd9d5635d2077d7486dcf80c910a00d5cc66d7eeeca13daa4a58624f07cf5acf0d1baf64914c50c271758d584556abad4a2d429a0e9096128f5d219f89e56cd54aafcf43ad8ecb0252be7107030bf4f8a8e54ec576663537de16d25056953182618f2bee5dc81af16af29cc32d40cc8dd89b608476db08292055a0abefad462b95601f8b37591b9344105b3481d10445f53bd349832dcaa103a5bafb67d23ec98f1d20fe1b8a063f736bef508c1250df61cb3cb158397afb3e7fc0c08708c15a59fd37e14c0234d3289290a4c4d85f21f39db6f15a3b2be237624edb867f3f7b16fdbc0642b468e21b0f1c018c4d0870fa119ddaacf7810f8b0f22d702be96774af918324f28e331625df3932e9e8fe2cbc0f9f4a201160d9603564567231441bb8dae13f06a1a0b9f6f1ac2d5bd9d86df28ff9a7e06219ccd96322cd8a07a165d58c5bb730e13cbce6a0cbf5792c22ba3e30467b0505296d33de8e8eb576a5be672746d1b7931a6fcda2ee56ba6075d5d48ab196807df99455cc4c36a792c4b4c76fe5aa92ac0ecafdcf037e2c833ea7a762c198071ee4fef37bf2fe2aed90847aabfa28e80b48a7eb1fbfe966eb7fb20d8e7caf6b6ff02b8400bd0b429138a151fba6581d1e5f85731489c96f32ee0cecd53bf4c2cb7aa259b2556b9c0a20d606347bbf1a2d477429a2c75c4fa06d6333356d60cb89425df9b400c2c1477b78c6c1d31842da5e911af2d7225fe45301c6fd2bef4d58f56e8390dd9e89be1986e5ef53ae02427e3214c338179ebbb0614c0d4517189598e7bc4e5143f95d7b6f7d8769ad79aedb7eda204a7fd6f45eb77edbc286884044ba1d8fec3409dc38f9aa09ac44696d64267f4b0e5b1df706cad65a49bd70a56038aa02ab20387d12f8eaf8c40b5a0671971200051adb920fbad0416a34e897d9e30270b3d81d0d6e43a2d510efc4091ce3e0846aa20e1bc14e329beb0a5de016c57e9a89ec51c1494763f376aa744280d694107c2bd0fbd7db259c102536fc02b9643d82a5e1ba214f62f99b3b7ff6be61d5b5c11b4f3b02f798d243a80962c4fdeb26411a33a50a95770c9b5b79cbac78bcd592721a69b1a0ff03b08695cb9bc8c3b17c2c09b2d20babfd28596c793ec068336a45bc1dd2e445db130bc5b7f997974edb2e567136ea5489436eeadc64e790ca2bfdfd793d0d05f860c35af116b665fdb8c8a6592a42aac844bf61296f7d9c5eb46f44308f22c7fd5f3f33e406f13827da01a856bf444223071204a15b9de03f1dee0a7d3763af764ce698ee7577e1ca8169c301ea8fcf96e5c74d8ff1576b48fb569f8e8f2123f02870926d63d5164765d216adb95185d7d4d979e4a23bffa227fbd107ee5d0403f3e0e442a55bb7a8bb0d1a62bd9cf08edb21be1cdcc48cb06987940f35b93b037fe913a67199a08d8ababd0840dd1ae1aa5ef54c6a2e08ea20a78197d37d57c86e6222b27a4652ce9ea95f46456d72b9f6392e6d0622dd9b0226c5bc949b3d096a4c30a221594c1d8ae62ae9e216e2c2604f3a4f27b2d90c70baaab6d5585f0e2567922381e01977d565861d2b2d466f9d25b8a9de1df7b1f6d477b04aed9d84a5c2ce1cb158ed6bd9b2f80cbfa2238beea40d856f1a8d3462debd984f3495964ec33fb27579684efe9bf6a334a6572e2ab0ed76e43f64d200cf9f7ebd540ca6526c06d8e2dcdfd29308119f6034a0aac0aa19f0c723e475dda409a164ca7d2811c9a01a54ecd8eb8756a35f1b901302edbcc0ce02cb28b3f809476e566302f65c026b5d3ba2275623833ff1f79341a3c304002eead0ad739f8961fe0608f98a3b635e142c968798d5bdedd753f33e6bd25cc208c947e193343df3728519d750472988e82c8df632aa747ac955394c0590f6b30692e19ccc50aadcd396ab8b767f20858c330f4803894e145eecf0ab4ebf262e1ebba55adf7e5065f3cd6590c1f958abdbb526c286251bf31d5b7b3dacf776629d9a71531e17623fb1701d4a1912302b5c8f535c1a19f5826bdaeea6a29b5f9b9b0dd30c7aa9b03154c8cc91b9aaca119418777d9c7c59c15d89508ec064bff9f05e5b45468039139ca6daaf43835dbfc4043125360043fdcab55451311eee8b9dc167c25416cbbf588401d6333beb55e4e57d5cdf895f85f61bdf16ff7d06d4cd24aeef532dda8d66ab2a0ee71d099137107e90745fdc810160b2a2423da7271d76ca694da0bc6aed36b28c63ad166453b7644f50ac1a56e462ea50f4fa4ceefc954863e4b61b30543e9fd2de2b5030e67b1ea11b3fd951af766844bdbd470a0c36c8f495daefb577c9bc444c1323006bcca1d439f8ae6f4f859228245e9cfa4b7b434e9d304de90f9b727d6d04d538c3b7859b253de8c1ee4eb052b2a3a60b4938d699d54ed6c5c7f5a67c542653350fb308d3ffe993ab1580a80855cb64fe684b3978215ac5a182251385f3edc43f751ba98fecccc40a3c53ab295a071340c4bee89529a64765a4bbc2f13a0f402c113b14c3e0521ec6d1445c6894b92561369dadec4bb896c8939949954ef221deeb1c1be143591e013cf0cb121e2af98d51e6914389c1b58a397607a9fb363e2bd8f7791d8c61a3d8e5f8e19f1d3af933bea0a0f4c148918317a0240a5f33ea251b1ae1bef41ed8a0bf232f3752e6e9ca83e4f7bcd04023b003d37ccea8621a9af90a123eb79792549831f035f50c5cb66c590d4ccfa199b1fa6a6d3510b8c4a382b43dfbfb9ab83fb54736afa3dcf339d229d37031937207649d976c62682a623ae5862bb789c068e6e7e9415580624a79fa6cd18e79ee918412de5ac4e6931b65c636ec4089d887044b52b9b32f64f2bdc56b70b5c874a721a24d921651ffffeaa4b4a2e24efdeea33297544e972895a2061eafff5f01ea7fbe0280a4706f4bb8b0a9c76c279feb91b1480107a3ad84e3dd393600b85800da01a423bfa32458173f58e24483b0a0d102623c7b99ad04f36d779d75ce006b78c6e26bd1f68e4c943e43e4b9169d7e988daf2b5c1c79a0f5458e32edbbddd79da6ae5c5692036637816a76bffc1282dd763b71e79aa88fdb80ca8e9d055619e8222091e94b5c0156526adfdb9da7dc8c28275b45c479fe6b9196acad4e7a3f2a6472741b0487856a8cdd154f597348e7bc9dee9d7bd5b77cadaa8613c4cfc6a08a61dd792b6b580b6e4564f0574abd3925f93b297096a43ba370ee8fa3090afb1d9a90903f55520e8a241e1a05679b925a214b3d72408f07b2992b748e5c826c6735bcc791907723866d4f6a1941c867ff752d6820467120ff6f4260c03bef57fa1eb766502123df349d7ef8acd72a88576f0db4a61f814881b52f9d1916a4da4aa1eadb7bb662d424fcffd2caf142f356d8166286c29282fe65dcacb28d13ae4a527503f0650a676c3f06461d1e4da7c0c1089096ed913771187e0780a80830b1303e7dc02a0f84305f2126b12b3259cd3060c3092424aef722560e86c63ab0749c0b7424f42006613e402e16e133c0adb44a1997d18e98bb00a708373729acbecafc095527a5a17a2575ff4c66fd110c39fb6d6a13d9bb34a01e580fe20ff5a7ecd774b1d6217ff5a86a6c88b67c651c0187d046f67d75ce45decf3166abc00e7e3859ae2aca81261bef58b624d7abab3eaa53311c47a49fdc7a6e8f0f2d8df573c0efa0ae46c68673476849bc5f59bc16d5207e5f7218d85d7f367801277f0195d3e0d782464fa198191e2a39e06228fcf1b38ab66a423bd790e0be7ba8f26f3e6747bdf9ea4d08f841f96deaab0925689ae1f0a2ada58509f57d28653aca7b5cc1a60b165dc41ddc16063e195178ce21104b11e4dcc276fa2e9db210f9166c9ed6878cb6c5ed41fe1c20ed512d4f8990ac0668f4bd505399fb29c7bb8d34453ad8348e2fd30410c5bfbcf6b8a5e9917ddca50d222d2ea0bb7ecd5c26f89dfb7d72ea7524d6dadd82dbcbbe78323ba77d11df70831d2ccff99e84ba816b23b61ba73c7de1e447765a689ac0c42e70b3630fe198b6086428f1ab4b8221e8695c2b63aa434ced3b8cf065e8462fffd9c22732b4f37c2f63d34e3c710eb7c6ae82c297898cbfd615d797fd10a1b213b8263b1e6c5983f0abf4d99b443f617d10fcb9d7ac47335ed642dc6e90098e6f1e2e018008bbec682333c3f9af3585ea5dc1bf63c354ac72148bffd44ecb3187e6b533d624a15e17d5ec9003794985daa79a2b60cde09ceef6727f21091468f42c027d00fe4c245267749407d6522d47e6a91e21b29f5fd70523b83694a3d093653b2c61380be0cff9d5ac754d72e0e7212f1fffd9cbccc8304943fa9dcd5b702c42a271d4c66ceec0e2b6e8ff419b725f1d69f1bd91fbf75075ea1522acdbf423bdbb2243192a616b33357e2f27436410b84d45577fe123de3fd75d22e5db0528008b4585d5be4f3ce210aa1e39e603d7748a088ffce37aaa92cb889aea3209e3ce1ef78abb71797a2c937fb9fdaaaf30d03cbf7ef449e2c755a05e3fb057ecc173a4b06934a9899b8ec1f536aa0a6c7ab5fdcf584aaf640886fa3760dcf0cd472ad4dbcdc5bdc9ccc57889e9e80322341201e55d46bde8ba1b2ba9b4d5867ece5d8c62080c6077135d631421f2d92106407aacbfb649c00be31f451b8b20ba25fb156f498bc0fecb13f96ff3980d8a1dd96abe4cfb185f0e0f9f6e1f11157ef5c4d28bfb3c599f71e5aa801144673907e4b872e96707ca6fc2c584ae60942edc5f984eb293407304c1ea11df6840f521af650728e912808f040b1aabb45105064829fce2c73ba5e51f2e610da2f6a0c959b9444ad6037c694190b50e2d20cac0eec1591a7623eca6c8d8303ab7d55118470338ae32eb7cb09bd848be7b4f35edc9d76b6a7c68a0ad4155555119e00a1ecbc3a438790eb75b35c48762cc18a5c767acda412958d07142046dea3a4922baa6bb2c67a89da4f2eda085afd76b95dd017401b74e2a78dc2b8b2fb243c75bc2f5cca1b51f060065623bc3550a16440ec05609bb238eb4b9e9a21eb59ed2197cdad48b2ea61aa66a5eea1d2013aa2b43c2e86550c2c84e37341bb77e1a587724836bfb90ef5530cff2e74c2ed77f10ff6a1e075dcc3fc45455d61e2660e465177816e47b0381f328ba0d73a52f6d2388ca0611e2da159316c0ae4b4ab19e8b13a6eb3d157dbb4bae11757a115c60cec4c8d2e2d38f03c1691a7032d423d5853ae6063c8d4df8eca75890beb5f76bfbbf09d2ff3bd51aaa6c2c84b2232e50c975dc9aec026a020194f3c7ac11c24a4f724a0553cce05658cf5e0ca825493a13c9685b1ebcde0e692ebcba016a9d8e49c81b7e8aba44ea0eaf3f1bce81e61fa9df933d7617786f280cb43fc8d4baf1dfce99581e642d218ec7aa3c303eaf74919b79196670738f1a39bf142b38d6c539372c258d923826109bdcaa171a7a0514adfa3134924003acc77a60a4fc4cff14aa5d19f965d6e27ad3ad5a9a719b0fb76ca5ca1d02e439ce17e161c00c1ac8dd85146b70ee7e2dfa78506bf574dd45d37148523f4e5eee2e63a2747bab51d0ad21c01dbcbe2213a6daa61c3a42ec6cc9a5796a0d4ef3ca8714659516e528cb387ef8e9631ccc6c3ebf54eab54378496a4738dcec96480ee0d280bc58a9f3fc0d3284fe63ab42169c495a8ba19164273074ea8c89d032642774b23ac0e01fa27c950af24e297a4fd8952a86b49db2d75e499cc7f82c9efb557497fcd09e4b2e87046fa507b8aec46fab409dab2d4645fd26bc6bbe4dfd7935e05fb7cbefd8c68ca9bd16cb73f7390275e7af34b981ce9753cf1a2c00f0a7c8d7768ec482373437310b63022834976cac265f61368990d39cf5dacd3469955a450b0b205b665ccb9c48de9b8815e2ce6262cb1a362f78a8fd1c1a56a09241ffc0380256c6de966e7dae70f7c409738f09302045cf3353eb83bcb6b8616f151256393d1b5128ab160abf0b616cf7d62ab307bfa19f2fa1452a5a89c865e82e6be947742d123876d1355f9095df04b2ffa8f50be825c32a26bcd9d67c5842fd74d4a11c1e79809d3e9062ba588182805d8caea57cf7a391b368457a1e591eacd8bf3abd3965b738b95b659b359d6eb120b99eb56e8a295331fef77ead10587a09a3819281e2b4b1393c7afada3f531fbe36c147a678e3e31d19e31ba8dacb1d7b5a714182e2d3054916427b218db256e6d5c04d95f92caccfcbc2b2b3a6564cc9fcfb763ea49e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
