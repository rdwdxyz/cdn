<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ea36d7f8429722aad7802e7a8a3ab2ed3aafee5f14f5c349712818ee3b894324d9bd7aca541df9ef06c9a078b7062d3e0f2b819f1699a46bbe67986a0d81e7b0734136caa37ff89b944cdf99dc27f29f8dbdf910f55882dec152a9e19a7847d6930ab224d04e026b3af40273b0f67d47b720356a5ae04cc118a9af8dd9e5b450eb4e4694c9b6b36acd52b0c78c796cb11df216bb6e66f4c5c7dee2bd4fb9d06055c20e5efe888840fc667e976a2d1e5087ab30e4b8efb16cf46fedb3e827c345c2a52a865611853023a72ef6595d144cc60332e429ab26c43a5ff287d72cad352628d5c4052f752bb45371da0530460192aa598372a8ca8e8969cd35415afaa28e77f85fe28e25955cf97cf3a8594c08eaefc09ce540905d12b376a5c60c79c38202e454d002dcdd396fc612d21ee62e732c575ccf6918e471cf1fad35957d89a46961aeb4eb37e2e1df2c23960afe6a1e3e664e50a66630a95ff309b633e1272b2f1cd9a96c1562569c8de5f3bcb22592f077c6f9541a2341758adf808ba9d3ec920bb2e5259160386a44c1cb5fbfe753122660a42fec0443f9931ee5f546ea11bfb980f0bf59ec7f3a081b80a4553914ab94d752526459d9afb37a3dc4a69f20ce1557542c824aa332e3ad168e8f8d56fffcb741c136933345122cc731899187c102807d0a9b30dd11b12057ac822f34a6361cb05d587a996c4fa86fc03258064dbb7b41728ebf880c8ae04fe32c7e6a4c51b4c08533a06f291fa85b49fdf0997c1d4c2fb4e93d03ff56c58cff0663be1bc55420cb58b236c5daa3d151bb36c10a8feb66319b20173c121dd7e732a16684dfc43d5890e488cff4e9321cb7b7ec1f8da475aedfafeecf8d963680242429b0fc64ddabd01c75ed7c427dc03351b219d07843555d9db55bd0d7c993fa6276caf46072cb20953f188c2e8634b50bf2e739d2780c59ad2ca559c67370f463f60b674efdc4669b8b0107cbaaa8dd572213d3afa1410e7b7258754544f5351a04399fefc2f37dc0c96aa3078ed6ba39fdc2906494164320960b38d3fc6f005cdaafcdf2bc197ecfd15ae1a7ed5ba1438b3151f819ec565ae9fecdd4cd7ee084bfc9f4dba414ed4af48a13e1d86925cc7f81de674a072df8b8eed91c0b3c313d00f5819ca8981541e46a329943110c2125fbf2df4c29b51b63f151da16429c8cd64971585902de16bb6bbcdb9592b85a71b457e1fdfad4c856d8075586b7ed953f459b41ccf6b797156c6af1454016f25408c7a933c41bd4a648c6f870cb40de8205c53a37d2a83604cfe16575cbde176defae34cb99687fe33c4bda32445febd39924b10d5c969a6f801179ee3eaacdf54cdef84666b0676e6b092b6a8e36cf8e76e6224af626d21a098ae3838738bbb2571f283f9cf2462a4bb354ac5b0fe09c885ddd38d8ab4c5e1e6453c4653946825321f00a8d496c6937559802b2189c211fb3ec4546de0351cd3072bc856ed04353d0e6b3b6cf975cabe1a76f3fda1b3623b36be427fc02c0302cd51f35b9bfaf0a2bb5edcbded8055f7370df91f39cd53089330c323c2a3673172e5e90b528c6a049c5c62be0d4ce9d76a7bd175c5cd6952d390d515ee2a643fdd8e36177b757efb706f51aa741f8e904bef610a6d2381d679ba9cceb23928febbe603aee67d739503cd6efa4eaf8b49f3a82133cd4136985d5149b69cd36d7958217424aeb5f1709670b1c41c4eaf4d6bc1eb7fcaeb71f2c5996a6bf8be5fb4ef09a0e1b48b26552fccea570d7f779dc1cdfd0266e79e6030608ffaa34537ef6cf826a9f7fc2396a0db242cbb5f2a29c834d3fe42cb1a6b2015657553f0acc58ecf1e5b16fe360eb7ae2e57f350e8b753e314bb57386ca4438587d86b6156ce7b5db97abe8d8a78f303a2e8e3cc44a75a7738182543f985188d3eb9c57fe724f5baed16c28c4c961d118c24c19cad3e246d1450413a79ab4be962d908ab19c2aca031c2dbb13701c8b6984582f2e461a53d77ce806c228bc275a18c718f29522ad612c63ecc8b1deabef81ec54a3d203af27cd070e9ef6103a167551a14a832b67cf5e43c949b3a7ef573c1439d8970e7f17887f74963e7e3fcaedc723323e0616efc910528c4eb01d0f4ab6966a714d530819898e1676f9ddfeb2dea8b8220f4ac03ba919c2acc7e0b025b308a751cfee502cf063eacbd899d3a46985332cc721c45b80e5b42bf973374e8cdcaebe38d8370f9ae6497d84d267f114e518cc330950ad8dd7c3c91fa78b658e37b9ec6dd552f7de772d603a4790f820c6c2b2bd0b5fd79678eab07df46fffcc6b65a467d6843ee75d4c01c791e00b89f604e500a3c352cac429871c656c396a22708436b70a9e6dfd164b2b2421d740b87f5e845fc879af062c05f3fb207f69ead7b6804f2b4af239341713a15efbf2619b6bde8d9f465281a3de7b3cebdc2e4fd9073b5e5eede306f27e59833da4bb3cf5d719d89a9aace4e00d5a164914af44dc84cf0aafeeac62e9be389622cbb9a59f10dc9331fbe76afe74aca999c597cf2fd0e8e4eb83e28b9fe317b0254420dbfcbfc0596336d06a26ae7345a593f87360d55af3146d2bbee596c5103278a8fc2ba3769f64109de5b962abddbcea5f9e3f2456ccb27546650b533c48b69956736aef5fa29c36b1a79d79ef381690ca949a8b8d88112f1b7f451541dfbb75e77a7c16d6f09c5f47c3f65f3ebf1270ad7b76075d01c52ee1e41ee59942e16ac915311b1e23095b7f84de12123a81b3466c435c583a5713401ef73cdf964194ba790f549ebff051f0828582511e8b085a4d67bffbec2dc247eaf25fa1df8b2632906a9784c9e8204b9161b866b1e03484c2dcc561313a94c10adaa574e3086030ccfc7cebfb477400db21bc3f19446b93ea5901901ee4b7d56cb00bd094115524141d00b8bb37b9c0cf4df54a3929701e7bdeea53ecf16c413cda72aeeb8701baaaa3f360ce29523a5f7407e53aeb32087098d7bac4aa2e87b29fc74f91f646fb328174d2ea10e28bbbe2d42b37c3887b4c7d5f6a4956ceba28e7fa5633707708790673c863967b267e7aacdf9d6e13f4f2bb38b195c2a81bedcd523f8a0693748fcf4638768852920ccf5e0827488f451bacf5fe95816ac3df300e59cde497cdd0cdca9f1e8ce7de6007ba897dd0e0f8f64625588c73061faf9acb0810b28aeaf27af4b6e2ed6d7bd6bcd990ce4f1e6370d49bf4c8db6156d31497e71ee799456ba2e5d067faa84b85e7bd256e107bae3e174caaf99fd64eb675d47dd3da1a1afb8e301c765e40a4037c0c7df914a8deb33e92663557a2614fab271c54cb6e8d528486a7817ed3831a6f52f8a4d2f9cb4fab64605df7521e32f31a901418197eb393e470d7e89640e65d93e50dd6281293a042a5d5866499c0e04ace878c878f921155773addc022f5ec5687dfcaabd5b28279e5c0de9f88a96b4032b9364256700f41af77d6f7d94061fbf03269e0c22ec4fa4c0e593dcb4f6598aa7b0e6c9df3654d69ab644f79fb43d7898f8141e58a5f8c54c08675fa254d0329cdc8f670511cf51fa20712d6fe9608183baddee0aca6351eb5648a95bf7f0ffaee4d652515af80842b38f3b46b338f13f5fe8513e12d9c897ee839c9a8b6ec3fb9d535f100ccd624b01a5ebf7c55af55a3fecbe474531dc075a6d853d2ed7fc1dd5b6111ef5b344a0b283e5a4ce863ac1389c084f23948d46f2cbd09a95a1b5e83d455f0f3305b3fd5fd22151fef22b164eed06ec486b69a208de79da189ede1ce9697ded99f9900c11d25cfb4be6c5e2794e226c486d2ed423551894f3896384074394545380659ed0fb31fc768954ccb870c9c1278efa25cfc5ddb647ec98a317a1896924f15b884a0e59c8aab6d8662e50c5821a4201f08fa3287783a7cab4a944056c00db4a93fe4d5ad96a1ef41640f7b51b2ed6b7084070ef3a45b50a8ba5e945f37d5a10adfe84a3af1d698690099c2cf2030745f35b9cfa8e508b449f4dc19aab197e7d419d895a2359d2d1317e5a93476493f270234d77cbe99600d6069e9f856ead709c114ff4e2f617a2f3de8ae8635c16de803eb2bcb709885a67c96e8309cdcf6f103fa22fd4f7e7394f7d75215cf05702180ba77da25642c473f0f4a67815be60bb2ad8a79dbdedd40fa0649a3edd5cd8b7a155bd15568aeefa74dde92c552f9db8425f11bf832050ba4559fad8afc366cfcd72a79c87343c3bfcf07ef5cb89e014ac5494125816a9a3926c3ac1ae66176c046c370a264df58fbb50295ce895eac55b6a25a50c1621c83c1e7b14aa1a0e3babca1e1589e9ba75fa3bef9ea4b479df5815efc3596be06c3e321b0ec9b3d6acd2678c1cdebf5ae3a218da2d2c88304e578e9c5430f6f562c9229d0b17e8c6d9187d7e944c42f9e954772236e08d4d6610557d1366243995fcc46dfa1826dcabb4fc9364c911ffb7251f3c7f68a2bce209127601ababc78291d256a1abd4823aec7a5a872dc2d44068589e69ad781640f76e956379afa31032d7bb7ab0bf0f04ada4f8a9978791eba5c00e62afc2cd908953461d8f25dbb44b1d4189ae1db3bcda2392464c07ef8e5fd4e3b8c9df9425cb9500cdf1e499e63bc4caa8ceb58d1a0d35a0dcc12ee6d7f7b91512f15943cd59638d8f21ed198692ff4fb5c0e7bdd4386f8511be720a070b20164f593b8733b40fad9229f0d1a987f19cef0b31e6a07b14b160346a84190fce8f199db24703c1769e0260f95baa1150bdf6acb66a8436391a04964b1ca010b941c6ab20568e30fdcbdc34c7850cfac0ff726d6d568e558354af9d11fe1913ddeb738c47f2feb3f14e6e26d722c73d7d3bf69b605ec39fa45f12ab6e7d8602602551fd640a518b8c2341b96efb36cec79c0e6b355707d72a3e0496c3bc5a451bd61421232e23e1ff1ab52dc4ee42bcdf4952e6ece3c2a3aa368394ad7bb9940dc0fa26caf1c9fbce24b6414a0d49e24b7023490a1f35be2e88024f8dd2bbf3a4dd6d5d884aa4cb4e0e7058822789602c1d28791d9c74e9c28f95758163acefa4ff3223e7ac11c18a9cf893cea150b756215866d85487c2684ed461e888f845f7da362e7bcca354df77ab9c55b9be78a76c7d3f5386938d578e25a579461e96e39917348a389092d7295c501be321e1faf2b790779d7ede522df282210fb1866554e73fbc38f47efaf008b1ee393a7a1fd64fab6e4e61ab91e15829ab34cde7909474e3240f2e316486c4bf2fb049f9cbddb975f8ba03acb5d9a4fd1283dd080d07aec6fce839a6a20a4161445df281c42e4fecb25a7c3d2fb9af050b5e6d6364c5656146b1906e78135dd7ccccf0a1d155a4bc62f84eb4c103a72499cd2f18775a8f48e9ded9f6bd0d5b0e62bd2433d1a35e6df3fcdb655bdabddbfbbb10728764354fa6ced1e09a0593280b093c840cc3e2c0c65cab195056132d4561500c43d7e1d8a312cab646de0094594a55a016b250958bd15fface7469f64f0a2c0e967a0d3b8b5d90d66021d53363147da7f4084c24fe6f91ca0472184ecba72c81bd8cb2260c1beafc2d32ff2f5f9cf8e2bd26340a3b688bdee7dfc44792697df0197ebf366ae29e88138329115979b21037a430b10b633bf0a1c1966530c1f4b9ed55cebb1fa24cfb5ba50914fef07fa52b0baef56816e3e49047bc26e03751d3f9907bdd9eac56e284acafeebc09fe555491e7a30b6b9b52562d80a9ff50233bf1c032ff662f749bc32fca2f8fb21bf3dcf6ea6ed10c1d3d831d7d6a6058d1242103bc057629e790de313ed4a5619ef8cbdc8b189165e8924c4fd4fc30d1f8f16564d4b290ee903fb7a278c0f2787843757744b708d921579408e333a411030df6f999af23c5ac27eb5ea244297e62aabaac6944038d1491421fd7e25b6e4a3cffdbaa4a064194de354c9c16f20cd85c44581b6f19b74d97ecc3961d01732c696526c763df1e153dbba5868439bb524066afb44c12cac81e46b1803a65a69cf4da8f3a73500bce0b1d5801fc7b5bce1654ecc99f655c0a5fb6fd7980a9ffee3ebd62d9b1e7c2cdb78fc27b2d7b7cf8b693319675667f185929e6a5854603baae5005d323ed51c84fe895bd38025af21d35ec97e25685e6fc697e0dd26be6fe589a9130c8b60b089c5860ac3fd72e920f126f30d7f33888a086dbfdb7263d7c40a95a381305744a7c706bd177a53558f29f8672a7aec7a9ad5e38654bc3d0d2f070b93c927a04fc903c4fa5b0f6a35f3086c3516e7f425455a9625d4634146d0ebbd05558e1603bed6fa56c5dae90d405d75cd609a3284573cefc11fe0256ae3c7a4bad1d0b90b9b223f4054bb2b40cfcbdbcf0fefc1857f56680284694d22743ed040b642877763102a4cd1bd6e61697c3e55a242ad69624b1801a2c5ff7c11e40246d93f051d46a5714f7f887f9fe7aa0a92dd592020134d0ca4e557cd4ba75724d8f84fc1716f28e9fea58a95f2857f6084f67d108f2df951b826e3d0f6f8d1cd4982512cfc83311d2627e0cb77b19d1d2664b8deb2bebb4b6354567f4568be8a591c2967ad1a23f29ef0f4877a8f95a12eeb863348889186eba24afe46f9f6a0dee2741b7ce63a2889d3e0d6e049ce11746c260986a79cfc3e6696b7c618fc6e92a5e428c3f4053262835ab35d32885fbd6846fe4b1fc8045408582acd17507eb82fc35d7a6e16b334ced7d05b4128854216e3e71a60312b030a38cd0e46259aa78e2e37c802f22961e542257465fd1c43a8e33f5a5d38e29bf3b6a8d8a1a33165974af2a005c50596c4b544b91e0be7569a30d8ad070f0c55577922e242b5d78df5762e5532d34560973ade79bc06f910a06a353efbdbc0f14ce3274f868dc0c87e278cbc97623c52b07d77c51263d14cf5f0341ba690529d7e9fff626193a6d5a1149b392f5e37337969bc332aa0047873199aa7fa2111252024482e402f2b50c3835cc1c39b2009ad96f9b13ab387d3d4981cc04241d94a4ecb02299ce4c0b2190f4c52678e3b4de2bd7581652d7d3d6e216e5fa968d826b4be0a3f29eaa0fd376ebfe1689e9b57e83310d5e475d352f9c3f89e69939966eb6df9f2d947ed2f4ce0db9130c73929d019aea53625a405be4c105df164e34d18631bb96896be24304dd059cbecd6d801b126788dea4c4776c3e4e343547bfccf00d2bba3fb3ab16d95e63ced30d73731711fc38b6ea2560b032eae316d4e221f752cc155c6ee044da6d6521e23e8d15ecec92c3abbcd6bdf1b031a0450e4e76af10711aeeb47f81ae2d97ed8ca8533057cd1fb78a32122822dbf13e0d7ce621b22b2d0883658fea35bc2a6acdc87ed519af8651d0c5b8638b4c681a941c3068115174abd7e4cb3b4ee9df95aea6084e9c23e1d36e70f528907abe841db1bf21cb1075581a021705b010721e5c7350548d77be7423a876038b5a4e3adad1f968bb53823ccaf02540a90c56fe1b7cc4b4b47ff354b9d30f66502b80dfaf23d1ae584bee0f410967148966ac2023e5d331e149df100833bc49e81f08032ef455e800bc6a9529324c26344e9e21277032c42a1044bcbb2b40bbe49add3d2601845272bbe2e209585dd78419b6071f27a9ccc89a9d8b5dcca530d294b761a9857bb96b1bec8dfeb6285e8a4eac146928b8a351d6d5e550f836af5d793e05ad0e09f754fe77be8661e1b4bc44a0f51c2f73d30196d3180aa8ffd9f975cb177f8e77c8672535790d419fd9a6684832191a9fba01477f6f565152d3eff87353f5c8bd6ab67b2b19f5596e974680235e422144cb00e9d1cc956f8da775108bd73116e8b5d2f602b2a24e70e72aa4c16ca671fc4cc7da6d7f1336b80419a8fac59ee5d1e736678fc9f343104cd497789cfbb01a32f76a12914f4ee8f454f7292e9bada40c5b42470a5258fba4aa89572683c7093c77c98a83a0c30cf3885de9e223742c4437a7b06ea00614c764d891c122da66108341671ebc31da26bd1c93b1efbf70a79ee0fcf2d0dde83e8b2dd0bb991582a1322a4d74895add6c72a99c113046aa782267fafe0d181ee328e86249c2d4601f265c9fe9cfc8ed25c7cf2116a61784b88441cb03511e88a55159c647946126491f9da1cdae773059ba4cd96502c0719bd7aec4cc105a234b5d0cbab41ad3b0b48ae694b27820f384f462168eadc99dfc17722bc63906e3708a42d29f56c18e25eaf98cc68a8d7c2e1a0f33cb9af33365d189557ce87ff9498d3e7a2737c62345a6441d915db3f17857dd569fb4d02d10f8ccc4001afd069ccb41ee794f62934de9c50b81dcf51602864c63689b2d6d364df71aef1aac97aeaa48251b79e0cfd960006abdd2260f8aa28e7043ca8f95a6f237490eae5c6eae165f755e6e45750a573dc8ba010d3c0c2c27a66c73f3a8de6e799f52415d7ea703086e9e7c668a7443acf0e32676382004e916d77c71a78cfc4c5489df70a86ae19a65c0b7e5e1cfae7a4abf19186250e35bc8406ab6053e91c4055cd936f35c540cc7d43717c288cdeb924173f152fb75fddf101b4b133539c72c0f4dc05cffbf9cc3fdf6a8fae91fb565c82e15410d037d189a17d12437c236cabcb2b364b2276a06bb61129d54732a8075998393bcc492b290f0ce93179ec164fc860b79404955ccc0b604f4fada93e9423a5811707e714f57e2a5407b50706da2104189f858bc66d076c5fa579278265269c9b6b2362a75fdbdafc8c6d281ee940a6fe9df53c3a1f0dc43dfd9258ff6fcd101fa33416b16e470864555d33b16a11704daa31ddf43ad05cef8bdd81873e4ddf15048a9332600ce0666b9131c007f9548fe009383eb03203fee77289e974bd1b73f1f7af409f0fc193c172fb617a5154118fcbe902093325b262841d84822e599e8dfb4f416de9017cf345f8e92c13d34ce7b4638a9c4650963f7547fd1be41b6a600ac39add442f58a5698862defcbfa5bc188f0a4d1950470d136e1109cb6ea90ca07ba98d37c9ae987e96d95640dba763e90818be33795cbf4d54e4f6c8f8aba711793602fae843d701492e890c76d0663d500eddc46318a691580c801bab95b77581660a3f736c1c9c598eb6e7d84f0d18ca5a7002b998458d9dc673dc94ff56f33bcc8ffae9ad99a087f41dec7bf54311b84d3f348c6aa2aad77be7bd233d03a797edf1ffef80185cfe59d340c1255cef6e2e3a93ad856ec16fb994d613d57a851016e0cd35b036023231fab9aa64ec91a523ab8d407fe4d13ac1676f912080af53c168cfb954fe666b4882f18d66c57595237f290ae07547861088e48d11d741c47457b9b67e7014d866aebdb7d012ee211a114119de16987d389ae2e68983a0ae1e1bebbcf70af40e3d9909d0bab3890dc8f8b8cf535ee32e8fa97747656f47507c7ae5db6e87135f9b7f2b7df6a27d43edf803760d82e750f92be5e0ca42a9e0914f35c473a9a4a00d894bd1b5ade66e1abbf394426620526f3202f8f43f4ea308c5cc8b41529656a00e65cb00cd65b838506443da5bfb33e88976402cfa021246bbc387382dc7d2c82198afc02fc512b22f5a10649631f4f73a7ff760d1cea2ecee253dbc191ee366b5413ca3d100aea8f7d0b2e9f6edc4c4a38db624fcd9ad31f220b429ae5f5a3304f60992d346f7e0ea2b45afc995cb7eb4b36c75dcfe38d3d212fd655036c0c3608b9ae9def7766dc586e43c97fec2c19f25baaa8645d840d7fa6233b4b09efad7c138c1f35bc59217d658d2a795918916fe0ec65502f6bbac572081dad896edf8115ba763fe66fc7c3db5b0322176be09ae1728d9f95c507776766d0d4fb1472846c4df5bbc09f6756383bc2c62cc13a9b3a3511ed0d5997197b5d7ca90349f3c3efe74daadb3b3d6432c407ccafa61b086f2141f549f48c2b294af3ee867df47bdaba3e47b8cc8de9e9667fd1ef431af26b81ed5a3bcc29cc1243d98db03428331a8e61d3ec16c749616f8d6f0972f8fc98ba40335d9e6d62663c0e131355bb9061a4b788da944d9404acd1987f69cf4a2adcfd7d547834dddee34f2539e0a40af60bdf063cc1cf44e8594580b180e34e8d70cd3937b100ab0a36a9633bee33322a78aafa760c1a451f0c7234654adb00c59b123b4c24c2518e8055dc4e55745914e1cd68548ad20697d977c075b4ea0f0877a450c6240ee21fe14c2b39590d788eabea50d166e4162105e44286402d855cc8e5f063846b328915a167c1967240e82abe4cec1191ac105f49684294445e3516cd04a0ca5abd56303733d268cc2e1840bca3c4b35ebbea26abefb25e58b0fae5be5c4a5196aa12ea8f4024f98e5e807758e175e45b1d419602c732d65e4f5200e975505998b69e0644447eb0128136c910d06f5df089f17108273276c3f929241df744f0ad31d34234e25b1c4013ea4f0f7359351f6491323ba41099dbd9adf9c8471b083691b0de0208a8ae616042598039c71d119afebdbac51be1415f198e49a9650edf6d9a7afd741f9b673d402e18cfedb0e12c38b8909f4c9968010487d76934ba1ffde8fbd926dd3133fa5032959f0899d9e0b53fda7b36229bb9cd09c458f091071c15d6d9ffa7f78130c5191c058598a437354f65e9e825a1b5e65dcc8ae5e63de8d1959443417b168475fce0c15c8d77f8eb1a4b2cccf050a203f4a857e64bad66b5642dffb99c805b2604738158e12a27b205d92726f6f537e108de23b4cf44435cc4925fb33623f1af550a431e8c96dd3a447881baac6f124eddd9fb073b19390ae18ff25740397ddaf5f31a1ee8928f1050473aa6ee5d681f4c3e6fcbb6f4911323aacd701103a3f1fe60f8fb567a8c64c6b09a900956d34c34ba258162cd9e6360f4423f8f8fddc679623cf50bf40664e29aa521ec53a581a7df8b86ff6666a56d0936c54b44bb6964b68c6a924941645b8c434b16f8dd9dbe1b986d8fd352ffdb08ed672eca8d1db306063f57a54c2b114bee41a26cb893dbbe1d6d17ed09e4132f42653102465ea502835accc33257cb36a3161e231290fa948109b6931c1a52b2f82004ded55010c2506518699618199f6fc9e038f2cf7b7634800c7af2456e8f1424704b741f595c83b88345d7d2e064cd854ec34b0fbd28845b005ceb2176d73f1eb258a87523354c5808e3b7413e23154225b0a488e06a5cbb06765411e1a3047621cef7a929e2816886a111c1dd7c4fc732d15883e6b69a60ec14ce33a65ae1fcafc933b899427485c61bbef221f92beafc50dc2a92db693ca2f877da12f0d78d52329fe63da663c5f43d627e0284e6ce5f51f9799f8f3ac231f409317d900916dab722dbc6e8235d6547c9d8ad6f50da49f62fd90d5118357a40a3e3712030b4f6378cf69c05e49e18dfdd8358fc8d6f02f722f4accb65a0b90b9d56b6b188fe5aea16d1aeeed8c98a447f4dd041c8f999d17f26277f2d79206e2434d30c7258857c2c510a13d5992c5fcb735257f45fc22988346e2b41ce40a6cd6e87970bde01b70ea24bd09258ddf4e3f06ea80296638c024a0518cc42c64d6630474e67053e6f36e388be063ac148a63c7026a171c4da74c1ddf71b0524e4fdaaf2677e1b6629548609418ecef69dfbbf6f43726a71a69badec768ecc460d1296e20cf72ea6a27a2ea1b108aebd584feafff85d010cefdd3a930f77eb700a3c03802c8a02381a7fb74b1c9bbe8dfda70361ef661057784445597db52804cc83cb680927ab91d1bc90564e9878029ec4a24a5f369324f5f5e4fed4e1d08a29d283bad43b0a4557ffb4bd3e955fd794ed53840453806e341c816f9d9d4a0dae70ea328fbd198b4b52d064dae2313e2e8a5fcd2597d679634c23a6a36da53fa765c083a488e537a85a26cd02b80c65aba9bca4a1c8b5cfd5dcf9b8821ad30c20229016c65b667d5a8b4d92a66ad0cf64319dfb9eb9dc23c29933e2ce166ecc119b2a9204a910f8b05aa55e5cc43a608fec4b728475eb1e430abde8e75fb8bc131fccf74174131d95abdd1d30360ae1a216fbbceb4c654fb80dbf0cbd6fba60a4477f2632f43076f7dca42721e9eb85400e49c2a80e6892976196157b5e40358a18510cf6923f4f93f73c2022ae41fb4fb2d6e6119b12212020d6bcf9e2910d0c325b1a322b70551f56d2fcbb976178f65795ce58b2cc174eaeb21c72a26a262a7f8d2c0232c166d1ed7491ecc72beb81a9ededd4ecb1038dcd6c65664ea300a70d8faeefd1e9822e478bb2f30bae1da3d38450022428f9b841e0974f95dbfb9eaebb3e92ba292e931a1163a90c1697690be9c0e3d902ff35e06224a35c57260d4d6d1123c997a149eabe0a72cd5139534e2975c9ac14d3d8986dc7e593214d965cc23f4716c72f271610780dbb8011586cd40b9d90b12f8f845b97bd55607593eb006d79537725228e03bb76350c9b0f94e464333d0f36df943a1e2161d92a7b9e7a9ba1e061ecb02d3ae7b62974a62526064dabd6142eca2a21383d7876e81b3085f304c8500a193759960794e37c9630fc6f7a47b7c835eaf3ea08fb7804d6997dee3ec690a323330787857cf7ff5cb92ef5b1d8ac83b3b326b0e6aa80c5baf9b54150b1482527e7f205bb38772a4a8d4868903ae641b2be5d9df8cd6c9cf55c938cf5ab9cb8ce0f099400af2b57954ea9b06d812074cff7f8f566d65b8283fd02937041392be81d84f78475ca3613bb3ed2175d3770b7da95c7c11bf09695e2e920f68987fefb97f835ec5029d3698f0a79ad29874e86a94018d43540e434c0d8bf8ff86ef6f2adebffb505d798d2ecee3c29c3c547a4a2a94b063d0227c81cadcd6569d108040d8cf56ca7d25a7383d890028484f68efec1cc1cbf2f0d9780ef06b6b7cab734b24b6c0703070d0bec90a13bbdbcf9c10e3f58495223e016e0da1efb2a5ecbde7b03247c80af7f523508b209e4d8055789065d8bac3337df9f1182c47d2c7abc8e77a7c1142aeb00a37845d2ea4fd18fe5444350f07fe19541ba59370f04e00017cb4ba4d691bda6f05ddda532a1646bb363797fe95b1f303f1e6bde8e712d5108038f3305dbaffcbd4c362dad36e5f4b2cd441a873d7192bdaae23833c9dd8ba176b84e9f91777d76b746c46f6772fcce068e55f832970860c5dc03f2b4626c66a88f58d9c4ce594d15a7a208a08a0084ed5606b9737bc4b7f9bcafa79064bdcbdfd331c36a05d6bfb799653175d509478155525127c8a9809295602a730cf85f4db5614178fdd754dce7747f0b64993b5128f8a50e7242ed64b6a0d7610b1b0314ab6969af9de38b17a7ed68d5bbcddf424761d36ce749cd8817b3df6bc203fb7ebb8bfbc4f5982aa07242d7dbc9fb8e7efa61fc9bb0b8d919973f81fdad2d35a4671e8df580f8edfb21d6a71e19a3e46651fe45de4bbee8eb85fac51c2973dfe3e544e65ba5ebc54034966078385fdc381548205aeaa4c6a4730a21f122027a5cb596d0b9faf77aace49e72126ae457e571e37d1155a73799c76d7a566248dc128b7af6fdf2eb3e6d2eb6ecee7938367c72831504605369471e334b7a1b309714669ebd0c1128d60e527a1480a6dc8b8ab88c8899ef89a1a1d39952f8ad30bb83ed4aff8f89f791710192418209092c90e9bb6f8cbc3381d84647b34c5e220ec56954cdfa6d31041e6d133855efbe9e7f43296a2e08e58e9bde9ce6d4a3b1be1b317b215565d7b535177e62f90545ea3deb077cb74897a97d05a7dffbca47dda0a314c41ea9c4b242c5ba9d1e94aeabdba271c966cfb9a576289079d03a03fd8970ecb637b748a797a2d6e67a219328d0ca4e189dfee5d10c6c3438ad1df1362e37981d6491e0990bfbad6a1495a584d227c918650a6d60904c0aa77dda80a24b0a314396d3174532413274fc7eb76a7c025dfb765725668c1173bb16ab34f5e04e76e4d6d0738dc18c7aa6b4fd253d145d2c9d608f5216f9c2f6596780931d3630e86d061904248c9facc5b476aeaecb2556b6366d1c931b7932536278f1cc2307078203db0674ce4d0c95508649712f724f69cd5df42a0ac58f637fa75dc40920f4578d7b0bb4d867c2119ef853ede82dca6171d1e3db52be7dd5aeab79c040693e9847c94dfad29968c9c43e295d15a5020929561ba03db8bff50923b15ebd5bb62d0257b1f39b4ac2ecf62cb1e2ad7be8a159df51656143e0ddced4e1df9332c553ee5923fc580d78a7d8d570157e3a9a11df9d4a621f955b06eaf62b2cb74f0c47d3de420726ea20545bcb566a386d3e3661012f248588ff54c97c297647a57875b79d734afe698908690f348a20b089aa6a608b6a11997b888db6bc7a72b1718d8f9ee18cd3f1b921c5e7eaa6bb2604f27118397b2a6372a380fc8ce3ec0fa9ac91adf575b96921727950d210dd9a00416f39b03fdcf72dcb6b113119ef7f518041a6e71d35e39b4af5621c3ee56f5a89a924037afcc39c24b8f57e551ec93c9c1ddd83ecaf124e142af9b54623a750d468b46a1c024aff1007ab30b716c3713a9eb213d2ce1595212d236a8faab5b9cd03c62b9731836b83b6eb69256f4e99a12601ebd6b91e5ff2bfcf27802e1eaa06f9a18b3ace22b0a2a32765437f52beebae3f309b251e5a7e3667c6fe119e0101d90cc2765e83b27c455c59390adedeb98bcd046ffa4fc994230dc19877bd0efc96db77dfaec32edb42a98769a26cfc532df343bb86c83f76134300a5cab5d67103dc186c35c6becfcd23abb223ed9afbc01d9ce088c8fba0850c7da64c9d5187c456e7005b35e7bf4f2f09def3220cd3c5c343fec6ede511fae26e0a4c651847c82df46a1868f0a55357df5025bd5dd9b1cb4ed5082d268ffff34bd95057eef9236047478060256517239b72a438bd97981a6c8d01dc4ffec4a10cced59bd0b140c0f6c491801f3435075ed8d3ba3b7afc443041331528b9c4bd24bcd90eeff72286e3325182f61d26edd4fb3ff268741c7259dadc9238d8874f3f1ed56ea3eeddc96c367ebd65063bba1391981ae3e6758f4fb94b4015b8385dbdb869c3ab4b8eb4b56bd7375262a1ab063ef582f233acbde562ccf96bfe822580de3e237dcd9d3d1a0c8af044891750fa1715ec69fabf0e213a41fc9d97c174343c9ca096af419344d05d505b1f16c90ad1e9169553ac4ca7733b7c43bf18e0899c35cb097a704b08ee65c028bdd815eb436a740d39ba925072fb0b2aa82a773627ce4246abac3d75412c1652f8aef48dee246f9a0ede1fd6fadb25f5612178d4aeebe0f246c35e3bcfad6c118298d090a282701a2db88ccf07a1946ed57dbc367f5177512be8dc323407827d3726693a97f7f28121bea9855ad311abbecf159e2aa698499ac3ef529b2b0988fdbf1ed100f89b18add03b22b7bc7d3a8626140f61296cc5176142aefed12e93b29acd9b1ca6e3f0ae97756a325169075d108decc6dcbe214a3cdf270a20dce58bf00d703933587d4990b9863b942d0ac15dbe7d93afec1dd64fcf63b5e026e7ce13d49eab17c6bc4c57c3092e01a8cd7130ef273b33c39576c8a461bbe67eae07c2147e178c7ded8bd67b6f3f4120e7045944f732082d1e38da674ece17b7e127a372b1f0752cfec7be95636bbd5c35ab8d48bc55af92d9cdf74fe18e0e26656c50fba667dfaa9159a050ab08de5d08229503f4a39824a89afdb1a7b8dedde8087a17419b793e05a4bcc097c480f02c7c77b42aae6e19466d63bf336890f246df174e9f9a82703b35379cb288f2e18ddf8affaf89e749e4cf91275989c59b3a76192211949e74e4647fe6de397fe91473398b9ceed5aff8679a6ad6501a952cbd9b6ad016592f42c064fd01e1679e304563c80d68af21368d49190fa3000f0cd75610ace3e186b2d913e784c593597b95c7509426a00dadb792b7266ebd93c5be668305ed009096437fa5877f5c99f62bc461db54441e78e30374be2f2d17d937fc451f81ad9e3433bd413659d67e1ca64c9dc80f93edc87eb62115db9d4b3b66b9543ea867f45bfab0763659c27bd5d8435ebe9854c99fef35a35fef600a75e0de0a858fea3d158a6cb5bed8e284ebcfda4c6b70f65f1d47d8d0ed23805f9d401d5a206ab50f3c220878850b827bf120e0cf4ee565072dec3a9ee4c61b92fd2266e8227df69aecf2a9d5a12488a88f020fba8f4222625241af6bf067ad8cf774c4a8de8c4ea89165ab22fa66a19a5aad1a83c0c99874da808830b641ad3d88d91e842cc03891d91504a37e7f8d1e9ff3c1beddaa1aa83a3647d0815e8a01975eb8af49084c36cb1d9e29fd152f5514caae98851c86775ac4af7278a0ad77a9371d9a3160afa6590a8757531e866dafb20d4ca69abb364fa03af8cd7bdc4dfbf983ed5714aef1894d1bacce78be76c2d8ecffd43b0d7cc6b2df024db1a6cbcefa1ab130823e2b94fcf7f705bacca883b9e0391e2a5ca55a547daeaa459e6ddb7ab7030d2baf95d0bb943d08f96a7002519be341de90336773ac355bef64fba21659c3761d7415a48b70bf7604cc05bc77dbd202721e68390a2727a4a81d12f572fc67e9bed6b92a79136acdb8f682abe83b766659243f103feaa428305d3fc1c0d3a2285deabf88a3793682b2f46e6275a60439441d60fa12302b6d8223cdc27917d7dd12eb8ed1862f8de39eecc72b8190d9747bf4927a4fa859b90ed7ea984011e9c983ff3c16819fd0557eef320c40025cc5d80c8bb967254498f0073268f7b32a937681d8de2c022fe2f46d67241fbb54d54f1ccfa98d694566dd74e2f188e0e628441b4604acf21e31a796f5639efc66d302e34c2b7aa73f06d969fbc0304e8f3e18e93437e037b806f3a699f26077fba96b6840194e5d15322aa9ff788135d43811cbd0b14ecf0433607e720ba10137b7ed8cc95ea0c5c3b48649380b39b00a94518893948216678743236c2333ae82f33bb740937274dc41da9a103d55d40e0acd30e5061446b4cf28077255368b646ddcfb7e734b193c0373d5ca1c54e208f4745d8e585c07a002a8e4c758fd0cdd2dae8ec1bad81aaca780bf3ee266601f6397ad547b8f004366294bdef8f96c93e55db2994c135749d2aa9a2717d1ca4d0920d36522ffcc5c173465f3919d9d8e9e2350579955c8cc14979fb40746de47d5557d811532e8cb86f89986662165e044ce6f66d767ffb684965e1cc7a84ffacc1e7201d3608db009802df9bcdf60b7771b4db14bd5d38a241551ef50684b783988246f89780c1f18ffac22fdb4e5eb0c9c81b3130c663a0f1a305a252ea2019c1d0db0e341002f207d2256f658942ae19d5c22ca71076d5e04e1c26626bac1df80d5abb7699d2bc654e83ad4d14f8fd4c4fe9493ae8a7a9ca893f8506836c1901336ec6ffb25b22fe94a38650bbb7d801fc2f13b84ea50924d8f2df04429466117fc546719b509135f3f92edff30705e3be2f8d2b797cfcb371ed62d8f4018765c0322577b8855c7919c5a393fdeae96a6158cfa96418cc944899c6f73d6cb3fc76b7f25a0fd976c59b8133e55b17df715ddde54a2d265913bbbb88a878a7bd2f9afb256a3d30cd150e743d8e6aca5d927e0d28f934c2ed738197800ba25cde7c4125eca20e7e3b5b4e220f3c17637986706dcf03195b2f424134191e1f1faf267980f48821736d8f8e9ce9be6b2907814802e5dd6a3e7cfca3e291190a871397e6fde6af6a17a740861fb9fe3c258e89408cdade523a444d73ff1ad6c94c5554282175702f3357e88e78b53df7a3a417fee69a72997babf1862f7bfb2f7e89d5d32d32ab16120652c794698805ef0b1413f4005ddf5e60e096b11271926e5f3b38036bdf577373cc9a793fc8a326623d58bac0d96b4bfe2b2be14b6bc1c86a1b0f279ab65be61a63b7c8a98f31eabdd4a202d546fcb2183103864c90dd9dee80ee84898d127ef697ea9453c5daacbf85109377a7eb85e82412af997906d0f87c716032548c50a2568604e9fbfd059deafd65d534caf0363cacf0a7ef59c32c8e4604d769efa9ee835714546b0d0e525a48871a1919a72808a66060bc86d81a7f8ed4ac6253b7407876aa7431c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
