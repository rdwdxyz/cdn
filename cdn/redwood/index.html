<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f8da600ecd93986298fa2e8c69aae4b4a4a235f7c379ba6af911271879fef7b595bd39fa005b549c44da7326809250975dc8ff971d04214f40c64029143e35df197fd6d05ad44c923a942408bbc803f6355fd6429ac3fe58f32b40b917f9d47a5a1ae9fdd13b12de90d1b4d8003ab44563daab2b3cc31587f5117729326af5d8cd85ba8ff6218b020f6534dd837c438cfb39cda4bcc55bebe2fb77427d55e4fd67e324261ac9b17e6d853a36157cc9f008d7fadf24a04d94fec1d16623b82c344a536e53bce7fb0807749d53d9866b01b5fdcb7ebdcf70016106cbe8898c7ddd418f034f2b2061789ef4c79220d5c00af4469cbdfbd21f3fc1b87dd9f4dd97f9d000179f7d592a3f33db7e883c1a17dd6e5254eb7519b08f6055f5a236d324be8380087af9d576dae9e6e9d293ab9b66bbf952ddcb33881023c9a5c3fb1f07a3f30a9393d499d745a57d2f103730f580b33566df39590f072ce3570e4fbf8066245126f58a491828e697c7b0888fb7c6a85363e2310c737220b80af785b2d50a5840451522b5b06c8a198a0ff767b547b3da3b3d69b6416f5ddd1ae3453312d30f16a5952bc8fd9ed248cdf98f91276463c14201a49effe4257b7973b1cdb1bed66829fc79445f56216d2b46899f91f05b7efb37e92333f843e123580b004f19d4565122129484e9eb978e782ba493d7e46c491ffb31ba822277c92dbadbe924781544bf964177a48bec7bc52f461e7cef58a577f786f0e8d923334641d13f5d16d644c95eaa54c04bb12763326517addb71886324a50cd3285b2c84d9882b2bb0f3270436df66f3356036a65b29dbb379427ef13b85220a43cccf5d9bb0c795dacb7c7eebb787eedded44e2b4314b073934efa20f8e9d3778b46319239e74443c30fcb7963fe29d7a130c8440841d0b1985d49f52b37bc470393733b9ef51964f9bc57a37949994056c1ca968735beae4a0e273fa113c5362eaaf3ecc75b87ebc8bea6a0d2f8ac778da0e3c80d9aecf0707951c6af4181940f11b2d45ff9f2566069d97a050e1957c477ea7362aa3e5ac0e6fb6eda30e68536f7fa1114148c6bb2f00af78980bd511bdea8fbd7875d991996733a1f9ba32bfd80817b9c6f8524e37ef32ba315d5598f4ab1d75dd0b502dd519bef3c1c40186c7398c8e58800e50aafce1c85317f02f8d5dd0314c1ff58175d199a1791f926b9f31b4245c0e04e93c7522805ecfa864b8cf12d708259ebfe08e56dfc42a687e28a4875c2a7f1f4c272d901df11ab0377daca120c7a9fa43fbffcba2661b4cc0c194f90d71af2b02e59435feb7df0e5ca76e42743bf65a3c325820071f519af451f8e33596223a8451f42cdf03cb4e48a6f60f2310de142ae66c3f2fe98cbb804d6582cbd9422dbd2e663cd4613179fd3c846df44427e75b31b00c8c19ffac53265c170dc51ad1680c8ef231ea9f12a518a0b5a2fa0ac2bf4c408bb605d26538b564bb67d41442606f6ff042bfb00d67150c4713ab8dff694d5dd8c146228b53e52c523b44552d3e7b33451dffe2802dcb4cb8f57804faae8ba521b978ee970525c56215d38378c4d37cc3ab316cd634e40ed3356673e0a297ddcf7fd463079a7658360bbfba6096db1e98af0fa303d9b697c516a57cc0ff837fdecd3bd51bf847a114d7a49032313d66977674f1524ddb78c64c66f01a8f8dc70fd81e9439103556f9ca94b76de250c11e6eaa332ee9fd04381d892822a9aa9ecc34a81d7ac9636dab5b411c527a610c4e0926b441fc5da86aa5eb2447864ada79b118ebd9d70131502e1dace2be644a4c38aeddbe25db5a80d05e03f97e668b31198fa2d155275dd7907727b49de82c22531b1e87ca3d9f71ad1ecb5a1b2c744c5c22e2488d3b990fa7bd9398244513fbcf314af75ec3e553866ee0160eb02b3456280dd06901fc63edbc0b8527c1a4fca7e5baa43309670a1a72ca05dbb476734184a48c56af7b53ee17caa37d5e4ec64a4859498e2852c5e2421b0c185b7e9df42228f0a3f6ff6372a9c98991523bbf15cbacec666899ce61ae47ef80edb81bacfb883596f0d922b7330080839993cf535553463d83f4e7b7e485bcc69e425cbf4576d612b4d82835d9e191a61ab3e74175e55567b2e67080a2e2578c780428801c7791021a96932e092325ac3ff02aa2f88dc22c73708ac521c027dd1a061d305739f0f9bc14f1d94686a46e53fa7e8b0f4a74925b4d66567c45631578532843110bc8d3a8654bdd6d16dc721d48b071a90874b62582a099563552051b9d31873c51a6ba47bc9ce6d5d1a9f752af3258714db65628e208f235b0b0b80ef093819a0af06ff31d2bb8eb190964bd974ed0531e6f10b83941b994f7dae1b6c646e445244b7654105ca985d8a5cd8b301d1cfc2b2a34231e419035a6619f48538b87614c42429323119a829be81c273da3d2e6bc2c08b0fd59364ad4579bf5b79220cadd07f2356e29f81d33ebd5df19ffd24c73379407cced7750084e7a066e4933b008f9d196d183d6dc5e23faa85145902f6a4394172fe557a01cd933eefda37910b7e69bf558fac8ccc418c6b6ad3f34384a353b7b987c8df79f083e6b76c500e0e3b82010621861b9b9591908ed5752e4d32eaa2dde23467f494569205cadf37ffec0ffe10bec33f23e69c52490cb9d4430bc71f1ba8de18252e059ad359ac3b74d38152775e2e51c85be73746376685d99a7f29aaf0dcd349d292a0a5f5a21d7fd5c38bcfc6b4ff378e90b6b6002caab9ea512dde37fcde462ee98bacb11edd699ed4baf750d67f94fabd6048099f22413b37f4ca4c29301e25f9d8e5336af61a1651004cbd3bf0b6cdf7e0bc4d9aba72cb2b6a200d726328b6dab4d93c71954868a7543d927eb62e89f7603b382b27dc75cad773790c9d43722538994f6c796eb3407f7de05ae4323e2f8f2676e4373c7a9ea937a20e93be1f14363ceb787ceb4154cd4631e3667cb8b0a2822b6a8b60d26900652f4ce5c8976f56664e7eda865cd63bf9ff4601305b0a889f777a57fd170f4aa99a2046571df9ec9f4ea7b31150ba4ab4d95a2c274fd4b8bf1cfdc52dbd727a660b2b748e869480c7fb64e789397664aa49a08b72de31a66119f6ab2c2491fd66b75384f9d8efa7f4d90ebc369a7d215c95b09fd62611909601a4a1939c119de4174b45ba3838ff8740d05191c2ec529f92f0e9de3aad3eb14092d94bc93e32df60513ea04bba995254c8d9dcb72786fa3f61eb0a97ee60436ea37ec7ee1515a672cd03cc4a4e6576dfd9657fee3e9ea7240c22e5d525032326f4c991c1dcd9ea69f81fb91538e1da3e1b9ef842218b640ab531d55aa4e30b7c9be368bf1a0645c64303da1bc8bcb184cebd67edcb82aabaaacf08310427394697e568b0360dbe5ec948e742eafaa1cc22c40274b190ed448d59cd552d011b5d48b7f00a06f5bc9a34140de21720b7055118322a7da2c7e82ade09e51b86347bf2151e889718e7ede075f4754bedd61b76c97ef983f06383f0835a38932c764160532325a52b78fe5bad1d54d2f828f7d7b57e080ce9247a65bda88450f418fce02fceeafcd36578647fd06630b53a64cf45d00b43b48a6c050d4f73b548c52487af73cd92f4467352d5cc1784b53edba6416e154b285b03a31286c303d8e1f9be4d12f9dc68935b1e7cb3720cc83f210d11badc04a301a8e5fd42a64ecade68375d795375f4fb9f31f4accc9f15a7117ff190c5ab15f5c24276d6ab5360d8da2798db9a67f9817c2956384519351d61dcb1b5aa54288425ae5a1f33c3497c78941024ed2c193c386eb178e3a42b8ad30af058ed7cfa610cdeb17344fd262ca45fe422638f1a7c2a8a964b3376209f196c8c7c65b040c2c49f63559fef7004acb11ecd3b5438ff35b236ea34180668f2e009ef079d3b3170ab082ee815402ee5f93466bfb09b6190090e1c6b8c278be439af318e334bd77d19122d48f4aa0eb4f30b4305d5ec8bdf3712b41dcbaacd9604a081f4d7317af0f0a15b95227cd4d96f1bcb05c07a6b8af289a99706c620b6ed71c4c15ebc89e62897313c0a81592ad272b20c2c1078fc1008b65efcfdaeb35672d34d07cbc2db57f1ad551c4b107edd0d67f0a37b09804f7da9a194f4a18019584ee37f30d09cd826f794912e75d8615df283996667234403643d118279b8b9a9fd4a83e096000ace876f88eccb56d8802be9233bd13c84b02cf0007c1cd90d73045107327435109ccef29b0ce80d24e114244460f7ab93b1ca3a2fd45be7d7727ec68596a9fdc2ec5c47f129bbb1cfb70c13922fab6e1e954a29fc8264a0a8bc6d43c50595aca948d4d7c0dcada59ebeac4ce0397871ddf6fb1c07b62e65acb9ded5ef99f7b9a85aebf04666f9950ed66ac173a11bf1add455ea116a8fc8d0596c173937943c95fb36d176086d35237e995e5bc62ba3c5728fa368c9388f8d0e9a01980c03cee0bdea6f17e371dbe90ac2bd9e5d9ffa5fbaa619ce13e5ad08b9107881b165ccc6b56566e694fac7be9254c406902dfdabf94f937bf1b5c61bb5a29340bbda4c1cc63f01672d792ab5b7614cca0e43b9fb13f707fffa75e1b9d3e0279b2c96e2c333697cac51aed7d9b6e74b0093ca42dce970e4b6c13b2ab5f5674f8ed05cd4d246b2d5f6e48459ea6262f10a3edc4a3cf9b89f5cd494436769f4a6e7770da2307a12478f4966ef1b32a17a2a1f0dda3be2979d805e63c8f45eba81af7063efc739de0689e7485e831e3c3201d92c36684d667c8d1345b018ef5bf72cdb02938b8056cabd116f6c830f0efe056c4b2ea159b49e29cb281c2aa6d19bacd4baecbaca20399b9367ac027b882103ee676357dd954ff1ac8641df28979aa14e095b8a9e7adf14d4f86210651b63dc3868cbbde16e241c1c8dfedabfe41c3fe6635ad3fb10318fb5ac8ba0af6d7c14e7bdd7cbbc740589c6f2711876df71d02bdca6072a0510969ea762e7a98b7aac64849debe84bbb6c61c4c5ca834bedf648c6842153ca23268211ff743c71461c53202ea82164d64d912ff336602c6295a6386f2219d2177cfa45f24cfba8133d1306ce2cac8c7612d28137b3c2b89f039b54087c604ef9156e53bb42760f72d0c12404ed8135498c24feee69d52d9b41b8cc7b36b4fdcdd006e0270fbce152863f5d6c3f3f0883b4115d89d2ed85ba294510daa9f914ad4b31150a7d85894436e5356085b3875dc3fb5ff52776aa163436a3cdf4f91ed8f1852381046d0dea447cf7f356174676a959e7cdc83954e418b364598f3fe761e2929dc7aaeac2b3414c5985bda0fce62dfd9a204e28ee2083290502c484ea0dcf77aca8a560d035379a33170b49a80494102230d843fa7ad997fc16bc86735374d0f55cd2f044d780cea8223f24ba1a2c083474aabdf69e8668b6fb4a376f1aa891bc02da595e46a49ac67ae7d244f427fbf3575d6e4cfb3ebdedc6f7de35c11bc13d6175f642562552af316abc789b91fe00df579d6baf8ce32d23f13cd3a7be7f5880cc494dc0c9575b75b71971c1cca0af723072a1d0d7980c686b66cc96fbdae9941cb464c1651d7fdc79189561b757c8f6c3205beba4ce34c12592e84ba20924cf6931af26208c8d5ed9fe0ef71b9a7234822aca4181dbf3f725b1ade9d266eeb4deff964cc06d170a993219b638d44534eb62addcb055b3af093b212de52e2465c30b72c16678362dd5b603f3b6de0818c2a7fbefeb663e5516c1e2f3dfd00a7b77efff34402a894c33e62a7a5f05c73e7e047fd3522c1f1e6b3cd9bf1c8c698c892171514e6ffae616e67b081f2a4ec976dc4a967106316bbbdef343665b374ca1294d4d2902edbfa81249440b086d66be772d1d4745330946a99fdba16e73566a2ea1360ead90d98dfce2be8459d94ae4edab40dd8190247ac3e2779501f4867e5be4979d0db769fa676bc31a1ee5b65500e2f7616cfae367350f0e4fb0c9bd19ef75794bee617096478241750ea0aa1939240e0d3240a5911956368035e8b13409e08f3b9d784441a2c42667c003a99cb0233cac6f3409d8f297cc92698dfbaeb566961c6dbcfa8878d4310fcbbc487a797c39b72bcabd3259b41d9c30f1bcc46922363b16067596062c6bcc3d6ba15ffdd46f58b23911ad1ffd4b31f0dd8544d14e6c6e71f8127c171494fe13c1b8f46a728535e6ee11c4971a036ca2e98bbbc35297cc505c29614e103c02207c752b508fb68aaf189e16f089e0a30238b68e94cd3b079c1467da464baffe95d3f0442c7391feb6247396b8a19facbe4b53a87181375bef6c7313dc773e566e1adbd7f85acb67198cf9eb80f6a59e57a2ab79914d507104b07fb49672d9a934bf3ec878058b01f1622e4327a9abc6b2b48c93f777290d1dba63ab32d2a7aaba7af7fffa5e0276db206aac7b0bcf6c27fa86cfda1655d9c7839758bd9e710b10c09c07689ddeb156c14d3b62d9e90bff42afd47494d81f33fb939cdb00db45fe47818ce3615e332ba68430666a79c52db0138de6e4f8362dcd9ca12e5dd0d5fc2225b609a9234022fb2ae30be356fbd9f6dcd542414fee41a2d3607112fcff01c587e58b2a4e2da2e895b781340c3abfcf70194dff1e0f569453300f2c248aa5fd1308525e1bf64b9a0413b6275828a92b7e1b09f40986ff51546ca2c4604a748519e151c318e4af4f9067d83b5ba1f482443d972ff87bcc1316bcfbdbe6028e6e54098d2551aa41023bc64bcff2dd3ff2ba82ef50fd6def3a814506ea55d3b10a0c08598d888da1426f06de8381592d080b89f28a1f6030bb11f3011cb4e87d45824b14d8d031f8d29b0efe7e290ab7ad26152759fabe31a86db14b8a59202805166990e29556b2e91e0f4ae317b0f872c6d04e3072dfb7c8dfeeae2b56010718edbfc8e625c588e405d6d912ef226402347db59b3b07973959a34bf9e9db6054d03339e5c896689b74b5bf23da89f3fe3a1d62e51c43fbcb59c97266cece7f9b015d125693fd0100fe4eb6b3d6158f98d513d1f9cc2a959eb341864a1792986d3c49390cf549eb4b9e5d624c98201dc1374709e43b15d24a00d14240570265fb0344ca4ea99c485fd031634573d9ca9241a7a6ccff439ae65c83d7caee126173b126cd35a7ed9cb39523c818ffc43896071dfeff6af04923c3e96f6e0dc07e8f206b95762607b37d312d4fbde82c75a81687ec7d30b5998b88e405fee60e06416cce2fd07049c723e8a108ea4fc6595f00adcac6f731893f008659600ff578109ff14898f6a639b951a53f6d2d7dcadf1150f7dc1f4ad04099e293ca5fdd05254d8243afbf9c0a2e72b1bedd3d484af36ae64eba37062b344c9d2512a8b66fbdf081962cbc23c67098b35815169fde50f5c796e3b781a3595cd5a68b95e2d4c32dd22dcbdf61fbc2bd1427bc4f295909f1e4fadb20ef3c595f3e330d764ad393bd6e60389fcb6bad6a274be7d4fe708f4b2efa253120f0cfc75844ab7fd4bd81c87b6e0f5820404002936f9d482453e4bae8f28913ac5272c7e0fb90baa6fee002870f39ad9b7c434418e271a2b01348e85a837f97ac030c77c551b0a64d4bb352d7b9ec5c884886fc48df114bb532052d1be734c59926b64779ab953c96cff84f65605f8543f0a9f1b1869597d989548f187aca36403b22c6b12fbd96db71d55dca7f9d71914dada20625485fa431a831410f2eacd30053729a21f5cd909257411be1b908a25934cee6f6cb2434a2c87598a288ba4511be6a131efbde5430c118c31e9248fc127814580636d376fb00a67347b21bc51aa98992344e1abbadbf2560d5ff38ac2785e3dbb8ab828602caa9d17e65bd1a84f12c2d029b90cc92090cda5acbfdc50a3d3174c95e649738611a0296288e592479f16aab9a7a02f8c8198b4819d1ca646175dbf5ec706e11fe2c01b4bf1e6f7bd20f7b6750b1c84b46de31c4d1ab7540ea4ba97a7562c7c374533cbb69a7710e7c42a9a9a3d86cd8ee39adfdd2c54030e12efe7db036f2da4bbe670f084de7b1a2f981065505c13b52fb51cf86fbde79153045047c3767b93cc64ea8351e463442796e4a8d02ae1d8d7e06a5cb7cdbb648fadb9b0e76e938eae3f1cbf4747ae035f8f17880307ea35f50f2af655a16cb1c87cd5ee3ecf941c53f57e6f0bcb1dc3a143fc893dc129117b1ec011f6885ba68350cfc143e9e13c084848ceeb55ef1b31448652bb115bbc510586205647cc54b287f898fe91ffea33453d62662c8c38555570aab36ab3ea7717fe553fe0dee23771368cda282e680c6134e383f8cceb644eb8019e1ab2bff9ad98619293a98910b2a1dc649e026be0c86bc8db01bc19831c8d7c983e2f1c05192e494e2ca5597ac268be7bd2ef8bdc75b86425377a1630b41a99c93033272470f2de96695f34b6d172bee29f3a052aea3feb7997109b0e813c0af9ab44bb6e32085967bc9fa8e2ab7b6e2bde54ae552c1ae7a68a6c29fb4de281e5318c87ce267f111e0aa9c6c06c131b7e3f1106f2834e8f2821ce3bd8ad4b876d7daf80060d8d6fd72c5a33285be424aaa21b3411560e59e278aec5f6d8ce54c4f842c1347edfd84924bf6a57a96ce6ac8087776f915ae677d0746be0b88dcdc35a8f5516800abf616f6b3e61543f52c5fcbcc49f87d807bbf598e4381642c2964a88c1cb0900c78628acba68794fb612d32910b42dc35a9e0e7ecad0c42b909c1dd6e9695cbdb89d84300e8d6dcabfc181a2b6d74a8c64ab68d68998dff13bad2fc043266f40c00d9cdf3a0a9947c7d33d3278812523d1ef52f8cc830d93ad5d30a651fd4dd840a2e58f17be00b42e9b063dab19b45066c9ad499a0c602aea660b272dd8bf8f23a25186604b54b4ea62a2873062605de4c3a2156eed7e070f1797f16ec128ac7576dd05df6e379e3d886487986f59cbb7658369c83e7e9a0acb365c9e1be1c545f808d3a4dbc4d9dc0c3d14a95d9f031d75703af41c73f40b886d4592c82e682461bf3327c8efd4b401e85e79b85e078396ceed15ce95cf89d1e8bdc7c0cb13f24bc226f373c4da7ac30441b479cb2254a312f27f5b508571c5829f7b96d41a2d7bdddd53fc90653f60e76acd6c1a048a4658562f1016ed3dcbf1affa80b42956a018b8e2c97c167cd8dbfa92b047acd2df080b41fec666221974c8922c2a6b15c9a9c741abce16c6b379f97be85df17d1843ad8f042444cd234faafa3c54fce33ef0d1e6b48489951d89bdf3bbba046e93f38d285c4c7eb1fa991ef9a78c5ea9fb147c02b293267119c090a3c176e4dd2a1845995f182481aa0ccdfaf9dc2c4a8f6d8fe55486383c863c7a6c3a765c8ff527e6df30af3362b31658f4d4e98e21b39f3d5470f00e7efac3860f73e51eadc3edf73248628e7cc61ae2cff9acda2323b7c20f93637012d28bc7987f8b5b694cde0680493be59b408317dbe48ffd856c4f16a570b14c6de6e8bb8f1dfeec9ad856660d229f9659934472b899b78bf97c6212dcf14493ac8ad1930f3a73118defa00306540ac36b6b42bb560997faedba8f1a2b4f2ccaa656500109d2ec867bcedd04dde522dd6a2518c24b0ff0f93a4b81ffd40202cde46a0c40c4fe900b5fd781242e0f3ea0bb67c0f2af68f54f766b12a5bdb9fb448500124eaedbf16ed35187b169623cf7c22e6376f2ce298ffb89be49ea7e735b522a20a9a4a03bf01b9db57a896c86dc04bdac18de7b6d7414999f8cb0a7fc011295d9b55015ca03cabdd3c323dfaa75a2817682ee08e07af0d52206c9cc05db3a3098f0d12aa300bd46618fdbfabb6c8992875f94b61eb81b77e712e6e0f0262f006d6d5a7ec98057919258f344987b9e5a35a4e1078868ace4eaf5a5ecbac789fe08bae861510bad460381d3497e3245a2dcc59f468639cf801fa22618ec3398bbf5576fbcab6d4243cb61097e5bcf1c9cac5cfef35f95cf77a726042203d253b77eb500533c530cb2f421b420400e233922c01dde6ae81301172c6647ef9bf0bcc7b2959511a66cdb5b134fbca85a54087b1c192f249a04d7f17d697108d16a634a0ed80ac893f85b3391594d589715fe07dd5297606516ac292e04f2e395eabbd63050eaacc8f4cf15e4d29bbd9ab49c80eaf8975dce22c3aafbe33bfe156c173aaec8abcb70cc740aef3b13f6bde3d0a50a035c4628f528052f12a2a10189bd967111958dc09537811aebb9debc074079368695c5de45465a69dc7160ad0f922ab37653a9bb0c21efcfa51683fdaef2f5789110b8e2c1e53b16d2f76b74216889fc4b8eef6758eee8bf52797eec27226ec9acc0ea3a9450ce5b5f10e476b81ed0b4e64594e9eb0a9761eb32877f77c5b167355bca5dd81224ad5ab11ec3533b479773a07b13780d4703763ac4390ad118995018ed9dfb25040b759db116bb026b30d6acb4dc420f566bf14e7ee3a5524ff5599369a9df21e580247dd2282fa3f4bd8c9c7b297ba0f368fc5e15ad4cb56b21c5ef2500ef208fdc7c37d78a82ec37f1acdff4d1b871d27daf8a5c0a08920ffae6cf9b2cfe0dc48d09eb417b8dd73a0c963dccb5c30c112fbd4954c9b8d8723a78741ae1cfdf3d25940f5e9a363b15f2fe2d64e6c55c3309e458d1aa1f9d8a42933dd375caac2e478d59534613347837ec2d6b3668279a2cafecb9ebbe6e40d0cef86980f0c1c09562be6e6187c6118b619387f613a7141d5b149fe24cf2c8ffc4371ffff44d2083fec7ac3d69bfe006b0376c0d7bdf6f36134cccb7265037406c8fe076c5fc376a99f1793bb69eef3a6e4b1e505c5290ab610f63728f76060f850745670b337061fbcfcd9d6684e7aeaa18dd4d27a036b634ee9b3fb853df9daf6d135d8fae24f631b9aa8635d92cc115019f0d1f8ae07895f8f4a669c94b5f3216c214137de3b96cc0765ab6155dc42398a9eb98c773f9d93d1a2418589b23d098fc42685a2ea8b5cac6b3a63fdb9ed5fa07ccfd8e02d3fa95bdcc3f22cf96cbadd600e4ddf26c066d5923e9393b7a5404d9dd3192e84f3e58eba0ba830dbd0672b43add0faa096cf4613f9ac326674e9ba0170d774b389f3763cc2c6a5d25bcfa20a54f4a9351f801b18166d1835898e6d33f8cb91a1398156a38017f5c4c4a2b45359d9a20a13117a86a6940669f87f4137114b5b83b52e78ddafae5b375482212c8f21eb2efad21ad43dd6e322d6c9eef7bc00cad1313723ac88c9e99361aa617c86cc44ca6de8a740568001081092cc3e190ff1a0f41c218984d6893b1224a3d95f50fa4a22020f581ead1aadff74c8813c43e3d89d5700a00fda3d401e577901e30f978975deb6f239ff17de525cda319b790d677842dbc19a8a4d1c9c3bfef744182f7ce87bd1c8bf4216083008be141003a8bd3f87c0d1a3d64a5a81cd99aa41c70a84be74e80b9e6652ae2a0cf4b26c43ab03ad483fd3b7b0dedfbbe011076a5db3fcd6dbe1518b5884a6ea149a7129ca2797cd3fe3f26d0abfab0a41304fb25fba8874b76d409bcb8d4add5d840857c9c4720e6d11fa120b7cf012342cb594d54d681271ed9d4e06e50933728185813375d6942fe70ce3efcef4a926810c6f90b7cf2f6816e0cfe8a1aa673fc396157c41e52ff295a1e1c5dbd5c873bc8ca64c8e62ab9ef71817b495e1939d1c4c48065da5a4e85b67fed7509bfb046b799b3df84869d9c76dbde96c93c718ad5cd5e50215d65d6f65203af61ba994c4f33534f05be1a093ef75ab1827e2d7c50dcf7b6515e9b6d75dbde997eae30a64ac6d03cad246b78683885c0a83a3deb4552726257101b918d820e1e27357c4cb375c49edaf55fde5a33241a5c4e8e91e27a034329f67f31da7a1585c7b3635cd655e12c07acd34b8ce1813a3f10cd1b48b87122d21e55940433137c995a71983ae3df77418404957cfe2b9ed1940d16a614cc3f9b11710a59286f45094b252148957036dd01ee62619d074a9e584820addb47536d5079deead4308a77d3f72bb277e7ba9f945702d0214e7951e6a34b7321a22e419161d3eb0a1f1741a036fdd0c52cba0f3030c715553c43b0ba14a1e7d729eef0f6115547849b23b23d4420aef6b89c8f6f87701811058ef9c5662248b32053a5a396133f7fa4f8c284c3208029516ab7cfd9439c8e3f38399550b10d1b3f77195e0b6c79022470eb6fb664910574085b0cad387c117cc23014c234017c222fd2c97df283477e4c9678cbf0a58938b9fb7574200f8e6da28a1a0a74a15b7bfc1fd23b540df35edd23edeb1cfce35474c330a9a58d31157483ef1b680bbf26d3274e347b186bb23e905a6a64f1b14f2b77df1bd985a7bb37c2fde1efdd62abac4c6500b68b4fd5b2d1cd535207308de5f80659795824e29a3385d208c8b92bdbdf6af21bcd13738d7daeb714edac829f35cef69ea565445f92a8ea6a6d44936b44c781e2c7210daa7cf6a00b2f0ec1cb67e9dcd72bc0b106fd56174200f4a2cee5e529dd7f371021b871b524e03e3ecbc1303f5de8870b181c531085d2aac71a09e4bcd45c0e52ee111d7b4543fdfbaf2b76313692de06beaf15b18e3db5b038f04b9c7b21b9466f4c771e5562d1f3a6ad702480976ce16e598f89e1964aaed6fa9903a0274e8cb8e20338880bb7e0cd3b1688fb70730ca90ffd9f2ba5f1528cd423768a2efa1b0652cafd34c408ae32cea2a114c97d824df91e9cc56741200d12d71c637d625d3b329dbfd9dd87379b6f06648bb8b9a36b7afebd058d7b906add393a5c009f08545176802872d0526930ac583f8681befcc84daa61787e7a18d03b615bf47a72985a7c9e7173e1fa91922010c7d1d6a631cd1a128d3562c20487c08d8da360ac7e03ab637091fdf753dc4917179a966b3cb2aa5ee6e4f47d41fdde37473670c0fcc646382f090351c8530967dbd76edef99359f4013bdad7efb6ec190a79941bf101b1e390b1bb2c95f57d6811244961866dbe32a12a601a4b6a60d7c23de41d8a7c5e652c417a4264a6f0c09fb922c85c5c1fb78ab3089024133b2d392e7b97267b62f5d157b5cea3000d563cf861db8f5a23be5d5ff35fbd7deff0ecbeb2438036bcad6fe5f077afa360c4c4f825bfb975903f2d1131998038cb6607adf3e52f2c2201836388aeac5ffa8b670082fa74afee6cee3f84fbfaa9db0814b9604f0d2bb9810ebe8daae3c77e8bfe4721ca934d374f0cd928773531bda00af92126a2243d868755392ab4df9f93a1ac56c02e39255d664b74c1c48b6916077292d8caab1693bcbde04b7a4bf5cbebb4f824481e0a7b000a07a87f8544819f86a6dc86171a5246a78867c784ace48bede11954714dc6a3f9464c636504074d43b560785721b808165a254bbd674b18880d33cd329d8fe69f2243e84fe94e079745e3a88b4649d3329cb3fad478d68af3f315178a0956c6c004f866dac8cbf25fe5a36afcb31a5ee71c54d9285e26868164308f78e2727bba6cdc0c8198ce8e0191a8cc6f90014c45256762f6a9fcd04f2a29ed18c285be231c0a7b2e905d730719953d2b4a1375527426ffabf40f310ffb5ba4bed6b27d51c9502af4993de195ec8320c5efd499383bd07da9251190e675afccfacd4c119738bafc139d7a86fd1d0abad9a64e75c41e2fc9b8f4b11107524903675e0e0d8da7ab551a7f967d4dee95e391aede121c46a9252e9cafd20c068b1ab6ff57c7a189d5d1c2014267cd53c7e849bb741c7239b4ddec38cdf25fb95a809a257124ec8abbf68523b0f6c0bca41b55d00c8242f11b8d08f8d626a4997f9f3d8697942bacfbd093a56ff434cabe6a4847ce41b3cc1998e41eb3595a7588e97dd19647606503392ad2ef43ed3ad0b6f9703d019e1a89205e2418cbc01ea744d187e36f07c261ba400ad40cfd1d66a42864919dc23b2a54d280fd375f3d4ee05b5f65f628c2d099840a26d6d92263d9b5ee608a4105398c2961c7aee0f70c212b94c3e850f1822edb0e9653e66949da4109b1e5b411636c22e382081d12989e49d55b29f473e897fb68ae95770b481e2f007de3b34053f950eff761eaa72a3132d2969e427c0dc1f9b85d65edfcaeb9b7440ca7453dc7ec6f0fee05236a2e0dc2e353996b628a4fe329f465176d8241b28ce21aeaa22f280f2c872f513d84fa010521ee72f8f96b2450f4402212f06ec8ba9fb7f070bb35af2026a173feb062b560aca57445a83624ca71dde053717c96ef6a70d23b71542b140a2d653f178078111cfba480e2b2ffefcf0e9932be54f68834843a0cd8eda3f5d51435792f143907e07769793a167adb0259bf1e6f1099bc5ff123e31e01e6067da6ba850c3218cba0ddcc387947ba0ac120314efa9f45c592b67fd8bc8107be2b5f12d95fd48ac209a8f0807ee088d25bdf2af4a25055939d9ac9e420d33a7e383c262a26434b87d79ce90cdd535d0685349f58f842f5ddad7d934d02f493f4c31eb5c9e8234da920699535cdfe904b844a8e98112d9aab1de7b75bb3a15548a2d808864f5e227a535a57036545c45949b2331815a52169f3bab4d72e09d4e782b9a71bc99710af522b7c030e6f023a4e6c951a987173c732be2fa2b0395c4224bebc210b31587cbdd7022395a81480324750190851102a02adbd16a0e5a758a56d2aedd6a836e48c974b6a1300ca7eccef98d6aa0f078aae514855efb2c83e5863cdcb14db53037c45e5716931973cf1afdf1e678ffa69501b3d3aa336cc2266b296ea7d2a5f29d0662ffc3e7e0967442db6627cab248a10c3a09127d25ca0f749c39b6705347620e479c19073c10901ca4a36ad46b0a6aba8bff37250250817ce64f7b64b5b3d4ab0aa577974a73976069da5a8ecbb25b6282a091b6f0fea2e4962f881dc86153c51e7c7796ccf2cdfdf630f176b6079790f80ae01451dfef177243cae1dec0f574a233d526fd896c519dceaa1efac4e44def0002a16a9bb8e1223078571eac437dda20986bff9281ba929fb6f345356eaad483fbb537d62c10e650494671658deeb476981d6554421c594b1e9b66ce1641953023601ad925e81c04cf2832da528467fb36221dbe15ac3e16eb297ca8a0467b6e697317091bb5040d6fe40d5bd4a9f9518e6e89afa481186a71805d356470f39cde5448bed21df0a329ac8c8b08aa729c320c232776ed2ee4f8cacbe4901377b8bfb9445ad9ef550b28a2b052a39512c8f288dbc6ef9d8e7b533894f7173c6c0e177f91f8b43e7e7d44cfa845d0a88aa34bf875b736e2a15337ee995a256055a6ab3253c281e150bf213c227d01cdd831a160c9f56c0675253530fef2456c67ab1a881671b5dc0466ef6c2d6b4bd10bebf3371fe1d8c0b617323184664ee6ea6ddc2c770cc36f120d846776d54b2061dcf6ddaf542f998ae39df18f7b196d0d95bc77ab18ce75444465704162a73f0f90967a5aa33f8b8a3df971aac569a715234a33247d3e57ec93e8ff80225d7e9d66d71e7543c1fd2d4be9f59cc5082b22c8677d66b40ad30c3070af8becc9c9462fdd9b00018b3cd2255da0d8d25e6b1764e247f2fa6a1b181cb09035baf15743afa018f44995cd6fd6c170437884e78163e461c60332a44729b1d91d09da00cb2bbc4381917e21d5b79fefea190f2a4935435a34fc26f8acd641a05dde977bd585da2d81c5b869337626148bcf3dcee1c5d449faeff89340f9c92320c6774d3e0f326140541038ee2b2818bfdf7187fcb55cf650a59c16c459e67eb76346958f1eb330722c1256a25d5379f890fb4aec4687e52c3a6ab8de7f739cf0b912ddffa13246a4584b759b4d16b03f118c6fcda376c04d71243604e814fda4a3ee30a74884c47b0864c5e67a01431d6f404ef686d06aee1898b71473d8f7555b0064107f67b2571877b9eead000446b630c1aeb3f61e5cfad69e9366a221d6718e157ed4539b6febe02e13b5bdee314b6c40abf8cee21351d303166518aa602cc9b64612dfbb59edd0f7530c9bc0268834b0fe3c06f6be2b04dbc34389262bebcf063f5d07001e96f73df38cc9b154902a2f8786b2feeb52ba2651d1bbd5b4c33bbf0c171daf5772522ec09c64243d0461e8144fb536aa3175e174bb2fb667ba28df8d3969b8a54b4dfe31a9f0a58cfb104a083124a0ca9b4dd1f9881b0ee4380e568fc7abc6d05b45f92dd9d1990e0d8b72d23948460e0cf9e93a5b56f31d4bf32e0168d3d119d1caaf7317950e00070c9eed272550811d7a90e5e9eeeae0af720c14967fd3baf0a8fe7a05254db17912b213aa7b5174988245fbed244d3707cf7e8b49dc405689a5936680024f02bcdc1ff14ee1fff83dfc77fd66d1efdcd7f23018d9fb62f2d7d1ba66376f4da4569257fd8afc779079d189c45585e1b8c37609ed92ea8943a8ac768e915b6f366f55eb68fb8bef543abe8fc6ac40613183b8be8c1b8b2502a9f6f85f955c9cf09b28e61bbe01673babd999f16d77dfd4834f2eaf6340193eceeee65d2897c4836a9281069fb98f72d09bf7427ab42a6a52adbabeece7562092a02f69e2a5a1c790a9427334346b94dd11873774a903a3f8aac79ef19059ffffdef363ff216ca41a11b78f3e634ecd2f413d78458e8f57c1211ea09bb3e49ac58bdb828fc75e3aaadb6e8d88dae9d1914a3e4002792cf4e3f624f2522312a38234ac19c07810705b8f42272ee13124b95854816f9c4da8c62a2c887d0323b33b93df133b73cd493d7b3eb56adc7078e58c0c6d87477bd794520faa13a217a66ef1b832ed7c90ad89aac634b6b938e997594ef03e47c9718bf52b482a6148dc28ae66081a72fb6cb8577a1be6f1d89f9f891749c75ce5cbbc536963b3ec815bd9c00c13fb9aed3c9a7f8da00467c243a6f0b3dfa9485c25cf6f8ea5b2543814e71fe5fadeb7fa80780f32fc8baf8d44946d2d3e8d3c447c58c4287a390e0f2a45925d648992ea8157e505a306b72ab5503efaadd8f0d42af6a0a6fd296c754f172637847360c60650d06602f9e64f75ebc909a30385ec0be74c9dcfa77c4db5d320eb3f9a823504568ed4ee35dcffc053319f96b5121d0a1d0b67ab45a934f3c1a0b6221294c90095aedcb2d7c73744f5bdff749170438d8712d1e183949f8771e5d2409fc8882c1ae98fc1517edec9d6ed64e6ae4a5dfb868c74de0ac7bf8ba40c3317c9c31de011d42b8c5387a77fc14b283deaf5857a1076b96ff86496b53714a6e2c718626721bbf52add440f2b953ee555a86e4b27e087ed29da3f5de5e44475a60ff1684c1dc304a6c01f162c79a2b6c7d7652a07092c8955f5cd4ce0fd903a194ff4cf31bd954e1c626dc11498906cb2101e1e1cc6b06e9e8f5086ca691f6c735df8745541eb0f8b7e86f03fd4311f948a842acb6d2deccbc45d0e7efabc7318d12484dadeedb6f2c20fb5ddd2e621ec687699410e7fbd4e57bf573cb06930e8f151590543189768ca2ca26d39a6f172d451065a8f8fe4571bae08762ffda6681f2c7dd161b951c9d5ad75d847897ac2fff407160d55f46eaa20ae1e81d9804dd95a31716a8df6f1699972ce107acfe90f31495ba707236e9fdade0c7c2bf945c38715e8bea8e899891e0888dee8d529526a0d55ed1749ec567bb19cf4b603e3b409b7725bb621f1cd6513b51d42ddbeff7271c0afaa555557dc57b57b7de06aca026b2cfd56d05a947a56d17dc875c25c9d8754a0101b9877de5506f5cef778cbe4e13af2296516f2edd85f6f972b05d1ac3bd806dd125beda6803fa6d3f28b6365e38a8dfeebcfc559f7ecbf4d23415a4c2104ccea506c312fce7c4ab24ecf3f9dc2d1e16c11c4d67362c93466d63b93d72e4f90a30862729d69781f28f1dcff9d2f265ce417383cf8ea1a4c8caf8efa1e9c1d8ac09953d6072d6517276b2e5ab6808eccc1cab8691a3f59cb2d2b77c2df588578c6315a2bd1bad6c180b47842c6101d003b5971fe4d9fe7ffb065768cdd6b0207c6c5fca63bc332326b3548b9b978128e7a8131ec4b755cda218b37d5f855378e08a1df12bf7ba486e03dd8d7959f9d63a919f4a1a351fe7d666f5bf360e8cad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
