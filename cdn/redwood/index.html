<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f9b13ce9238a625397dd068f0d3c307e0acee88c223c46c316ce227106ce06bc7b4246a0de1ebdaea88ed38642563f87d1debaf98f204ce638f6c45d3f0ff04b563fd69805ff8655fdcd679516915f7dd3daebe901f83180d2962ddf48c4afa89e79f3e59d04045d1312ddd289dcb71a18be44841cee2d9aa1a09fd4c6cddb2dc44dce4abc1bbf346cc4ce9065e9c5ee1d1d92f2db93c348fdfbb2a87abb76d1673cf0a408f0c487428e3962ad584c937691333abc843c645a5220e44a939bffb01bb4ab5fc12fed9208936c85a405971e0d874952d71300829efa1331f07891c7e5b154512b3a52857badfe65032bb1181dc6924aac73ec8c9b2931435c89a94dce73ae88541bcd22ed943906ed6a023ce2e26f433a59106b2c8c13ab90986c1fa694b7ad265c108aaa4e52896bd959c47eaabaf69a500029c2ac8d0e7db91d62dcdc14a8cf5441d1ef33ce3364889a06f7969d0ea717effcae595a84509e8bb85bbd13766993fc070057594078b970f5d672b45517290ea1fbd5cbaa8cbfc58e722b778321f86759475733d0033c4945e874d5a06b2248bf21f677a9f8577fb10119afbb685fa436f8129c8fe038407a1c350917adef24d64e5c00c6980123fd77923c3e7a81845b7925533c445cb0dbb4e1e80857ade2deaa8ae409d8eac113307651c9f422f37e630ef8552955c82ee52083c60b624e1417d832cf2a0c73f7929cdf5e494dbeb6ef02996c287b5bb940d9682e10112c6fa3755327d0098f73a756c3e21012b2f90e0d910a5aa301a688de13cf48b8db47e92c58f31f9e799593d22ae34bde94f2cec6da060bef29e8ddea2eb2dec1f702888f964cc092e63671ab20cf53b22a4a540ce0d5fc4dd61de4295de929dd6b40d05174e1e9e784c33f8af9e1151030057b49636cc650a5afe0394b02b3d5b4f2198669d3c2fb75425978039e47a7bcb77d73c52d5b912ed8319b61fe6ddce0a05c39e2315941a0dc1f17d9370d0724fa9e00453e5e0e5936a8481b3fe9b6df9b532043e1fb3496f5b4c69a95a6b3e8e05cbc356041fce7d401d0a1103e400ceb24057aaae1fc9f74c62dd946177d00439efa2be9a773ae00b657fd58c14322f36d9ae82c9f4dd5935c9d94ef1ef3f3322aa51f69cad3f29af6d5ed742e6343322572175fb424275360d004a0603e93b5fb7bda93d17a4722ab219dac7716ce3c4a7c50e9ff7d11685a7f7ec75d6ac00986f5edb05418947ff5c24ff2592ae056ee59d1dc3ae710512ac73e905173e3516d1e387a58292da778192390431edcc60f64d925503d73552094b507a36fa4d3faac9fa2fce939302750a328586bdeee8bb69ba9ae1b5576c06948f5e4256a8762f9ba933798a8bf566384d2387589260412833f5367ae0386701a8ea3b815bb6db7a2cbb52b1e490def2124bdb3d2a1b0994364e4fa2940259e099f640bbe568227c8467dff7a65a2959d107510f6e74ad520fa857330a61718b5db9d741c2acf2fe9d50e03991e796475687790d30c6e239e8e09c6dec5fc5f3a61f8dadc76c86b0512477cd26830374067c4187f248b8e861d0c91db59e8b835d4d5edcdb6448e8c8c993d9e1575441b7228dccf4ee53260f936c9499c6d8fd75bd7c360d965a7843aa23ed6d2e669edc84455297e928d53b6d519be8baae3f25de60fee86bccac68a90ac9440923d4b1144f64d36e365562052caaa243be6869f97aaf831df9fcd5b4671d4c7fa3dcc0526d7c92249653dfb030c489efe9759b2ea123b74e060f851971ae5a54058b548b3bf713ebecbed6588f089f6dd8ce65a143fab2ee812996328feb5be85b34e7bb4dcb79970e8f7ccfb6cd424a44dd0eb2431da1262d0a773f2051fbda2af6822f2d335f12229e3b2675137c75d3ee5bc752fd6e3f4c629e5901e0c14e6f6e9c38bd42ccc4fe3b908c93b3f8e4d27130e0b2eae3ef87c76f31df6b69313a122ebfa4a0c770639e82c7f9fa2a7aaa6d711f0d5a4c6d21590e9b6d2ada8fb07047b89ab45e3ff7121801e26b2480bda9cd441430ef28bd0981da99d065c1048438834d2b7853b9897984531bbe1f17e540d0b12e82171a54b6ee1b5851ffe3bade5163152940c13940234d3c1bea2ab4ece6f35858970c3fe05aa2877e8b90763d4fc5c8cc57d4a19dbdac7d677ac4c7d08fae14190645cf717d2f2fce0bd2e84b155c5002110c7d398a4e414f2a8efd3758302f8f0de4d51ef2250e622853b0707bbd648f98a322d2b4148e2e4322e42ab7870f0392708bbf35eb6dd4986e375642e47075f80177be6275d3b4c287cc8f0f20e142a4de974c86d4bfa4a70aee05c3ce11b207c0f89d415ed5dcb8644dad1af255d124edcfe55d582cc6ec365bf2fb0f9af7a319d9bc1ce4b2e0bdabd7c164e163bf737d768e4cc7a0cac76bca1dfa2b9a685220d4cf0ed22c34a8bb3c7e4529f95623cb0cdd45ebe227029c0e24a014e06fc8bcd1572b134ee2c6eda26f895e3a1b04996d0ebe85d158736771032f96f2e2182f624520f4da61356aeef2542016814260dd72c59a843f49aa6d2929af8c89676e5027f558cf6e499de812a1af812e545dd7fab59fc4e12ba6a08c323285148b5bcee89f05824d99dbd47403dde5b7aa746e687909251f4f271c0240242660399447e4717001038055ae0dda87dcd7cb1e809f5fad7ea8e23905bbac8e73b334f0ff62f84c522c5d7eb75ef364e5182e956f7609345f0d4fde76edababb4a61f639b3ba7ed6cb702564c5326c9bffeab1f0c183230d506aeef047c8d367d07b9c6fa28b2191c984b39406d1423977b3561c1179cf23a45e0982be9b201f2c7c57bbaf6e9b51a7e876f6bf101855b840de027acd3a2ac39438c3f968d7377b986509b4e6ad6e1b28c22fc3314044a5e6196286c7e274dee9dc6f6566e69e83e641bd1760447c91c6b1c60c67ee41c2af820b1b363644ce36a0c4d40e010677d93b79102b2bf6e5d193094740b391e945d0b766231c033537a9cb69eb6d163f2df6c712f5b9d1d3a1acce3220d7b790c213e0249ade8f45a05e59e904c88b2e4042d2373ab1a9a8f1f0a6286948fef5231ce8341b8c3b7b04016c51efce00e9710018bfdc5984f638429b280c3fb72917426e4fc5681b12e1536769e1dc796aec00926cb0ce0204e3f059b5fd845686d224205f79ddbf1322b2e3e43449b292408d661dabd51f762fef2d6973546954ea6d9ceafa6e96fb51b966f03cf48de6c16ce5178dcd4235da6e0617391dbcae723a99f312db48b197e523f19cb6f9c35bd3eb89040a447deeb0fc03e834f43c877737d4a79923eb6186e69db39ace51b0723fae2bca505a07a565f89c0ebd5aa837c9baa5394790ee7cf904bec6884925c7142c13cd08a7ae987d3bcba5b6f219d7a695c3fdcbfec2586037bb0f521425c098f1ea6dd43ea229add698868900fb5bc8e2b791ba30ee0f673e922e363bccd786e48a8fda47eee4a71a54a67867ad6a27680abe5df7d6167f6a1137fa231ace8ec9eb5c98ecf6654e44aa26cfb8f45496eaa0dd758f4322a3e15c76caf5a9a5cd2a6cae7ae3facf825b338e7637fc0b3c8172bd34ff6ce9a44129c0b1c6ef7ceb049c31dc4a8dd105c3c3c607da94dc6c2bb2130fad4d7ae642f7d76cd453ff9a9bb78e5b48d96c54a4170811bdc0bbe297863fb1bc5affbbaf6cb02c807c3bdb01ebbc4d3d80df757dea36476e9de9e310098e8b9c33f756ca1b3f9809695b0a5a1f067b04b52a1d2056e864775b1cad9964e1476d84e20fc4f800e369ee8655b3d8f4d17ce89136eb11d2c368aca0a980f8b08eebc323f2b81365c9dd4b640905022e31259f6f4725ad458177c4789f259293ec04b96c61ed601361d0672a690d8733ee70ca9e004fe3bc1f0d3647cdf0dffd080ca054461805c80897019b54a84aaf7f533c973f0d0f5709b34a886c880b6ab4870f7c23beef0b23c6250cbbc36d68ba3d672c0fccc088e1ab84340b12a72a0670e93298a9d3f101be86fa8eb2d4f016a731d6eaa71a5ff6cc734eefddcaa04998b5606949f5db34f2b1cc9ec5c5b1893c78322673c483e7724ce2caaa30388992a50f3015b536b89e02c703e69bb1ee2468751719b9c4713a5498f472f0a2a04224310185f025d7c1d8b9beb0fbcd7c4258ac89a86cdc1b04378559a197c6af5b52c1d63a227820da5cdc804e92066ea385fa3f89fc95c5c544a62bf3e5b33ea20c3c411e1ba1b22e3a2fa5a15f75bc813d7dda0743e0f37d7f876f7937e01845bf31c43746e91b1f6a3bcc5e32dd2ce7cfb1403a8f408aebb561e9a7ecc25067fbe8dd6378069074cdd32a6580d3b34aea1faf9afd72a1441b472fd8f558e28ea83a95570ef6651fcd51cc1833118dacdd30f2d405f4ff5e74a341e70b811fe3296a97ac436f10c37feb79cdb83c64e624c9500adfd778de421e1a140ad874a6aa536c7134744f74de7f1375cb1a97987e5a17e44e5ed150e1c9a57eed8263e3e585d20401fa518df865a085bbeae27008307ccb3942940e48042d6e4cbf93ecd7fa92d8fe35be89e0455b650e3db38efb9490e6e360628c9e9bbbc62601acaf0ba9f98c73c3425db0815c6d098b30f1321c783b88049dcdcca59865e9373a0778ab00c3807886e22de1bc1af4e161175f2e4a5822581aa913a0d397266c51d5f0b8f8c4622d03bf1d70a8c85edcaaac7a0fdb3efdb345413f1a0e41d1ea84d12c592afd52ccc632fddefc4a97ed1f95608fea140a3404e9a46130873535940b035b202bd3e558587c029850e17c4e1d92776655cb43b6bc8509c57ea1d758e0c52602d87960397b08ae4f70fc58cf7ede9289658c14fd7bc8b32649891af538ce25b4017f188a7a3a7165ddc138d882324312cb7a8f7ff2dc82e32e60452d7b41bfa787f4039c1afd955e8fe148e02ac3cfc94adde8eb0eb02143280458393e0f9d40459616ffd534bd3f45b7227465a88e666ea422fa434338d2b18ff3efa81ab3ba00ae9f61e1e63b06f53211e13cc1a870d436c97885bfd7fdc0d582910b9c44d1981c06d839eace86fca62b1cb0c8284d3713ba8b814df36f7ee93f3dc5775aa82d2db56fcb9b345cb18f9e6b178f2548972483004b9b596873f8ea596457b06dd913f6801e2fb05e1e99c3f12f805882efcbfbab8b7a5460335b70de187f9ae5526be9e32e06cefc5c8eafb0bff99ca4639e68d6fc968fa95ea7e266ff0fc2eee6464e307676ed8eb8c1d9fe47258b8aaf553b92266593e4ddfed7cd7136d4893bf456ea393743939781b0522416eb713227533363009f2dd75e339b19610171babc43b76decaa89c1af41a970596684496ecc40a79acd365e33a375c79ddbed84aa210c7cbe58fb68bb7c680cd1da82c03dfa2779e13c53875c818a0a3c1c9478d7da6a81cca4e96c08281a669bc83f641a7cd82023715a503e20c421fc585c66cfa8b95e564711d48afeb80e42c8baeac2d8230704f872b8ba1f4741bf767c916c3cb19ee7c88419618353a3c29bc1dc6b3a6d8397a2a0e15965ef1970cd9ff06591b5589dd13e3842e338f4358a7a64ce7ec87910d77192b488f43f4e49bcab71488b3191a9f5afbe8e0fc4e849466ceee6606a3816b529f420e99cae922f1cbad14570708f51d12ec7413d20cc8d2fd4e2fc39879782696483fa2aad1c71435c8b256133cb358809837d0918d9132df60822768da767421c88939ec01b9c7dad450bcdbe24caf35ed644790f492172c9e4d865d3daffb0c5e3079a5aaaccfeafec54e5f321e501a38d0796ad84cc32fb2abcf4640df434fbc28413108759d3907efc55f094d515db1dc359ae33c5d00e2020f835dff1a234c3f5c03717cabf770f877a615f5625beb48cf552ea0d3aeeb09fc16f5b681930ca5cfebc48faa7e74817548959d9f932405ebc0c71bd5262c861f482107b3b4dc20e4ce3a25061fc34492e88fe91e53d4bbc198cd393961435f685da3f42c410423022a9396afdc732ecca9aedede4d89fdc80e391c9467743af971f3b1db93030dd7cc032b53ee1389fe4cab7af64f61b3d1f083ee9a3206eff670318abe128ca47cf721e17ec26ab8611567253f87ae703d77e7bbf86fd60720284b03168f3e8551e7ecc1365f351079d6e59c2b6de17618464e28070c60f6a7feb027b2e2aa6a34cea32c270bdc28f371dc7a21c1735da3c4b07163b63ad80744f6adb96aadf73a538940f17ac71786432501ef55ba60ad41a924811946a7eb1804daec5310c9ce9977b98668d1981baf65148aabfb65538f845d9e4c0964fb4724cede65a5a18eca2d38ddec7e0508b3ea63a64fead34f832c2155b66976f6cfafadbde4f2e12ef50ff3f9a870e159a9f2aa2e13ff194c24f324e7c7de74183bf3f937af2a5d17aec164fda271c9fea128813d054f9227b950a0e3771a99b32dfb2763a75d5291eb8aeb143bc0c43fde1439534a69e22a898cb701dbcd4aad9a5868e6a0245c79850908211c43e7addc08e62c1a6376aaf8c15902c20c407c796f67243b8c50d852d8fd358acb0c8fd9f28231301b4ef87668c75a2ef4a35ee5a5a2371c7d1f769bc40749a99d33a4ea88533894f28bdf5b9daffae6508f66e6b2b371ca3777b805770f9f215f5482e2c0ed05712f3e8601d2789b800610810687c1bd9df556ee38948ef3e1c711f58b7c6726f45f8a843df3c68e13472dc1970779a5b976843efd92c3f3a76b927d003de2a9c50683585215419f326d4c13034c6e58c7b4ac8eb0d0831a35d49f20a80c76e019403a0eaed259ddb7da88c775d4fb6fe68228fcd7b446b01f3492f2ef709569af227ec95930ad882d24fba369bf32c26ca0d405261c4a9cb3941bcac5362be91cb43b9d2c4227380d4d36dee86d56ef3d309424d7fa7a1660025cbc7110289c200094808ba89914bee5b399e8aa9c3e3ec3170fd9b840863727105b7e86452865f70deee3b0baa563fbb386762ff77c107a1bb5adfe593312f9d56fe6d54399712db1e24f2cd94483a8c6be4b8460abc15e2fb5148130ff86a8d22e7a3cc04e1878ae550fb23f7efd9094f38d6e7763d97aa8368f1aa4433e12ad03c98dae1791c98d52e62892499364f5f503eeff2ee657b70d678ab553a94134c1318c5d1f3e78897d79b4e5d43e585cc837bc6086d4d79589f66acf9bf31d338d90f04b5addac21f4fe9444068f11deebd71d46e3031be0b33460671647c16ab089df7cfca2d48b3c518577704b7c7f5124d76af6b1929e5a768b1bdde989e036fd1fb859c5bbeff70ba56c578fba8539db085c0845c11d13a162a35577470917af8dbeb70505862c9e27134cd1609993028d11a20a98c3691f91887203175e843c315d20594dce9a2f0e1a4fa5c0898661bf7f90f50395dcda0348c516a800ab553a60c91a7b52674b71a45874d38a9b836dac81400105d0340c1e2f2b943dd69918cfd108d2eaf41b168824df6af71c6c7f41c88f23204cb8d23f3ef0d67b655ac86f7e49225af000e27630569b667c9cfa57a11f0bb10ab618feb3e5146a3ff2792db7e03c6cf6cf85ea18509882ad052d2d77526f0b6dccee796375f6b6ace8884fb44e037b5ed602a342465c70cd2671195725da6571671b5344d67e544d23af938663ace93e0aeca194f1ef159465939102d493b49e54f196df12b095ab691ac55b48f23f8b91eba22f3a2a3cd579ae4c5bb0f6be1ad7eb6faaaac7fe473945b9cd1b21364b7912bad3d3b47a38a9b2b62008a9ce8c28306d84e0f7c36fbf1ce579f2f1a4f7e2e1f2ae9e0761ceb4c7536725c34293182da436c8ee3efb5aeb1657111433a6e0591309c5ce4faaed0675711de96169e266b89451f3cf47dcce96a85e83ea726d7b90294b176f450113553fe92d50a89b98e3a749449c5f435b30bc97dba0f1a8fe98a26c8f0ebecec1b86f24ab5cf233fdca5b531dad3c599bd2722e8fc8f887d8707afd53b8cc74ad74872775a4b730664da28b33917be593f5a5987f8764b209b00e0410fe4a2f8fd349efb65eea9496890c3f357d1df1099dca8c964c5453ec3b7a8482156bc4f8a39c77d7a951bd712bbe3dbedd686452c1cbf69e01749c17f9614519ae294ed616225f8c76cd3517afc57ef3151c6b318969c98c6b6e97097bedcb95feaf8558e0c6f98424d8d14deaf0326f0449e9b8b8a8820f26daf5858705e6ecfdf191a9a6821d1a5449bb2e3269bfe37e3f58d70bc4f36e0673150a1691495fdc668ddc7e45c42efe678bb2b953d94b2360bf037dcc363e61f3d31f30082b75b668661f22297269b634e8d5bcefc678f345ef9e325f48eb97db3b4e31597a6a46cf3b587db1c9433e8a0cd37219a89695769b288efd2757ba8cc24c9288522060374734fe9fb48cac862893eea98d07f23bf338e32b659db894d1e8ee6a690eddc181fc2629b279fbf38df39c37c243a96ecd48292b2e70456f2533901f1a10443cbb12a7b539c2be122b71c51df9771cf427254d8d29f6516dd0f36f793d670484dcacb7a76775c07f3d7f286732b38a16776154c6e0382010343a7fefeae825a83fa8c8361c98d7c8129691abd99911fd6a07be36bf1bdbc15c933a741c2e7f8bb69355cf3bbdf633173f275dee4a9a262f93c55186889a16d03201cbf79eeb156bad81f352eb01cd284d9f4cad12acd6995016ea8866d85407e8b9815f6eafc7deda460f5af19421619e7e1f9186b3a2cc9d6a71bcb2373e2f57f5eb61a5aa366b0ccc23f5013dd30190926c2b09fefc90a4ab4175dedc2e28e30b7c681290afbc6447af72f6dbffb763e3d60e5b1cc9afd67e5ecf138f381632e50ca5075e5a8113e85775d9f2749a6251abb11ca22cdc17c59cd900de376930e38145bcf56286cc10268b31b764dbded9a747884fdf815b477dd43c6eed54e41ef7588b883aba7e49bf3b3c65553de442278ff4a5b58bd64850af2d54c31d1a56c99b42f85ffd30d844f18db7357f7f6e466e10e85cc297ea3b85d29fdc087ad1d20215dd948b2afe76ea08e024578a9176be71d30e261c07501e65087196776773975826dfd7d648067844f55cfb7151090102588490918efad6c18df680311d9fcb021be06075cbba6d89b7205acae3efc7474ab6b3a28b1cc20b2f04d1f2766fa8f086ee5380e28dffa9e389e36211e5db5a5eddd6dda5803aba72c6f8ef80de2b928c534ccf370148fe43ca78bf4f09e549cfe8817ea02614950fd464910469aec0779ecf3ae63d62893e617a4cc02c052b79e4056d2883b0d7aea65f768b001de9be291d8f4cf6b544ac09141587cd75884f4dd233101312f8525ff647d58e5675005263c711ece9abcc36a4312dbdb05474b59bf615fbecf7ccc0a7deb4b10bd10dbb7c21b39d2fb841d4b7483380064cafaf2b18d85103465d3d6e13b76a9244a63b37960ae4b6cf23738353fa4dbb172c42dd4df9348d8fe9a0c16f41eb872fce10e5c63a61a48b2ee7b4220e4b188068bd965184c796cc283143f16f073c75d70decadc00ba232a65ff6dd87d23ddcc490b1c888cb7ced6def67b5d6575da1261120c67999d00c390cef7a6c2922ff917d0be4dec3408f8fb777a3661800e5a388c1cd58e69b6fb68bb62a07e0fbb6bce2d8ebdee70293f7dfdc6c22677382905bd1768fdb1b9d1a9256b3400a139fca6c5968a93fed401ce041d0578562cd9706e16178cfa25eceef096e40ddf54b72fc23d0f853159d7efaa7dc7c5d87a5eb0e3ec02d9102d592fa90939eb95fe421e9b71a676eb62ef968ee94c0f1860b64c6af37200b2ec547f5c435a983689940c48842fdd08acb5b53da78b5d9a5958dd9b6c8d7c1cb758e46301e285e5eb6e4e33d6d59c9de622d6dce96cb356eb09516b6594a269cf3c0b8b478db68c6d81c687315c2be47c7182b0f12bc755ee93db84cc160a11af2b61b6395e9228258654d760c008b9e22f12515eb2ff25268b09b5b81ad7d93f065ee7f10290c73421de36947141321a5d167979b18571b433d82a30afba9d8d0184bad0f3d7cc05796be71c2a36b7e80bd9f9d17498910d950505cdfb6698c1dc0e1b730352a3850b8e532b618432fd094b0e88a7e8d6ac944871bb0ab5e50a04eec88a42b20a4685b29742b486da6116b0ed391bd35f963b83543ce58581ed990f120dba997553feeb527049c0414923f641cb91754e0b35852b919161c9f48279006df1613612b1040ea9a22a8f657eb3451326bf9bb7e085ee40249eda2ee2bfe5b38172ab0f8f95c7aafcaa99e4c18f8a48bd65af89713d70662f8240df3309b28e9b36941611f1775b23051ecc9ecfc96c4075dd338fbd4ba6d28f16e46b1f6ea1280223ced007453d35b57411833c2f9ddf732498ddd646574df43fc761a83714b25dd787d6c4d9202c17484b44ca846be104e8a4a53a297d13dcbe3d5f0a0f85582dd6d5194786c72d5de7491a7f52c00c305ac33c422c1f36d9fe62553173a0499019a563d77c9ca3653c6d8aa4ccdf787ed1f79e354b78234878da0261039da646fc626cba6c744d130e876342083553ce84290d096ddd81e17087b85ad60e82d896c8d343c514ac8befe7d213894556c7b58abe84359613a371d054905258656f57cfdeb73d87c22b08949b30074ef767969ebcf59a127d30568dbca0d0af876e54637c069eb230570b9bdca3dd800eebcfd90168c4c65239a0f32ae9ab3a0aec10656b6958ee756d3e84aa1f3ccfbf139e18a03469d5e15d35d5c91d8b2c956f42204ae15d651589af7ad91a817e7052f9b04820c20435a890576a5b320dc289d17b83408a670dc3111bd844b1a53137000ec4ab5b85cd5d0e8283bbe5b93ba14eb7337331cc143bcbfc798f2a608e0750831968176ff585d45dd6f89de01a16dfb73cc848df26e5caba4f3e4f1a25c06db785ca18bf0d128b4b1167f6764a5f5204bc562f89826a9b5ef8b2acc0d0b6da0d78b02ee02d8d12eecec65c9f30863614e234de054aec6e0fd60bbd2b861d40db45c3a6210992d04be3792b95847148cc9054295cc9df1009050d518fde9ce29129157bf3069844b7a4aaa9b16df160bf759588f1c1863cfee3fce02e202e25c8b9df639c51d7a777761414b39b5d06705b395a710099944db2154e6f1afb46770de980bf65fb338244683d3662e921cc283d25db628af9e049298beb29c0837833c284a32f8ce222f0421d5703e5dd1daa9e31755ddd3c6e206f4585e75fd605d88249574ce94af2b80f67afef6b0c9e7ae04501f82fa725cf52a80fe2f4ad1d2eaef46c649dac2c2ebe375622719bea118c5f96f9343d6113acb3345413cff2ec276ab928770fb4b92239462b3121145a040d41fc689ee9756cdec6371619f42707dbe44600fc81e60fe8a79cdc227c3dc5a949af9d2977741db0cbfb7447b87d839d5709faf9a30b391ab530602bceee34f54e32238e9ecb2d6fe6a81d0422abae198b490df9a8e0873eee46436ae7d97933589ef01f750ece8f86b3f25fd8470956132e2f472cc779a4717188645f3e0fb1be8c375bc5698841a1b8a93a851e9e89bf2f040a668edc6b10deb7016e387ed022633e47ecb9e892362341835fc29c4148404730d8cc15ebdada4d82bbdb483f2cc89564e485769a9f76217438a7a57a5ccb8240bd81f0b373113918b8406127816893ad36620f03ef2b59b48684a44f039fe0653b7de662cbb701d877d320acf5707c0a964b2503f1ba5b1365a0cfdfc0455529309e8ff15c417336c36d6a2188cabe23a43df9c7f3cf69653677de9a1d01d859dcc12edbdff7c3d5f20ae197ed094289219b71be7fcfaa3b51d9279a43b29828b058319bcb97247326993840a291940bb7594324321fda78825c180bc0de8383e1791717461b64d25b4b72ed5ab78930c9cff52b0b1e130be899e9284ec5046cea23f01377e66d8f5d05fcf4e911ba19c27315768f88037212cfee4c6cb2b589b55f7767849479ec96efaa4ef44a9b8225ead15929789cbff9f443f9eb108849ec749100acc148c1cdfaeb2d655837b31204263bd434463488a6e0a81cf49c70697432f4b46002b2464a94e05ba53af7ab9fae88892c5a6f1f23ffad4817197ed0f83a424b0c4c99a5982f26440f6d265f7e1274f79f4668691be12a77122df30863503a068ac5ee284c6b860d83a75659ec771854977b5ef3818f7c6c25fdd30f0742e2cab19f2507c67deb273101bc83c245e5410d539a9421d4da5d9ad0797753b55503db87297575fe7b662e01f67758cb62bd2087e8e9869a12998196b1a8173de1d38a96292763610ce559e367df6e02a029ae1c7023a0e753890e38e5a4e6936df1d083f88f8ead48a3db4c2e4fd9bccd83b42de8af0a7cedd4bc31c4a9481ffb7ebd49dcd078edbab48435158eabc5f12195e3bf0ddbabbdf8c5a1332ed8dbd24138574feb3443200ee9999fd2ca35088058dc379eae1bdcfa1bae3cdad8f20a0ab6bc842bd06c80f9b2c4287444f04bb048268ab33f8e56daffa15b088e70914d97b7d1a1c6566a0f104859b53b3644f6d80122408aaedf850e8f46904664e1df3d111f32cd45ca7303600c6196ede56a672f9e23380ede3ebe2529e60a7afd7ef42d54cb2c8dc08b5beddb95dea59b6d2bb23ad5befbba74563769fff81d5d9e1813467c92e263b926ec5aa5ecaa394ecd3b305510ec6b75c185d3864d627e7e8065c0431c99e6ac55a701d64e53a30800fb1b8f797dddb426c3c64eca79fa13ef19e0c0821d47857b8e882352ae181017f32975643e6682d31543488144f0d87c4e9824d982dad4e2b156543edf409e5980780f01fda2517ac5ae948f308119863898cd2c56621785f1b601fd47b7de6738963f6f650920b7125d67f2893939dbfe8e587d7e304257891fe64bb5dc04ecabc72f6f16219c6401fe467b7febce6356662c08f8d0ebe44a8f48fec47bb69fcd12c0d9fe03536be94493927d0fbf198b07bb2008bbab573c6a8404f9e3ef9b1acc2d0edeed26286286177be3a40afe618a0b66fa1aaec85e3785ab6aa3dc6b710fcc1a788525c49c4afafd807eb5805c05ebacc59993dbae46d5559f1fe3432e20ae28340fa1afc265decb63908c553f747cf3c3f902888f97850188fef04bc561f6752d868ef9cf6a25ed0796d7c83cf9ddb828d43ce78d60f8a29ee061def5ddc26503befb4e8ab89cee2b28b30bfddac76795d836f4b7a69f3dc0e2b39bf204b585604121769eef0593332dee650ee0be4a2c9380a0bc3bb16b4b07835605adaa03a0bb59446072986e0c3b7d76ed3e5e18aad65a54d24d6b7a1ba3da54d25d9ccff310ad106b9d7875059d75b1ef5af0f38e06df36c789e77ca17e500915796e4062132931678091d45df8a55035cbed5ffc5e276fdfc03afbb9c9cfc330410e0f1b3469ecadf0e9bd4e7c09e0d10e519e286b8329ad23376ec382c10f446c834cf731d4b0ef87e68cac8e259a327af427a0fa549901c39703401fc25ad46e5f736423b74af893b5643310dacfed3172ad80e2b003aaccfc7e5f2582ace88e9114fc080f7cfddb7a5c32d50e57f8092ee6dd659aad35fa7bdd42b69bcf3eeb6df2d8471feb6ae20aa4525d08b3dcaa45a0134017b2f7e072fedbbc6c97fbfbe9f2257bf5f91055665289a33f3ada6881e29a0b99c7432f1153da0bc84518d6075ea62139ffb202ad9d7e1045a14509723b3c0dddf9ce32693357858722302209a7d8a8ba4d7f6a5abffb888dfd2f68c4857f4abe5f02661959194f85c875e45de4c2e02042bda0ed985e70d8c3413fde56bb9c579b36f477c98a61f19af4955076408c5db52f12c270b94a896e5d96eea2d219b3d089af3df0dda00c374caffb1f506acf135913c68c64243f67bba65c8aea1ac7f8b9be6e0f5f0169021391e5015291eeeaf06184e1922765ac1e68658dfde7e009ccdf2e6cec50b97c6c6d1596d0c7294da4e1cb8fa3a6089f212cbba949592c88f29a173f25ba1751851f7935dc7288ab441b9ec5ee51cf44b51983b5e96067c2a82a624a7985f5a1bdedaf717bcc7fc02d6044bd091a3a38d996c4269ad443f14f092a1d518646fc8b2eb7ccd86f537f7c0c71a093ee277886462bf0a1dc6809fef4f4921fe82afadc4820ec26bc882d5199966f372b7a8b4d78eff570d46e9b538ff49cec0b581f5d80d51d934eb01a47e517c057eb439e1b2871e4d17817f81b62c17c6c1892676cb8ce2161f6b83988c4c1f252a61346b887c5e0596556510f194d8232137ce79436d5a2cec82be49b476951fbe81c13c4c47c2d5e96cee1b77eabe07ab3524309ec25f95b0a35358000abb50d633bf1cce31e0e1e818edb3b7c594f2b15344fac2b8eca1a10444590371bf4e05e3ad90c29c7060154aa6c3e50ebfa40ebbe5a5cfa43124dd26e36aab71c366619dad8179fc59ad2e71350040298013b300652af310be054d8fcfd1bcac21f699d7ab8845e82c16f0b745fc22acb691ef9ce5855c61b72b47d197565a178afce39884987591cf76b14aadb291f348afdb64704273feaca749bb6a5c8990c531abb8523940b02672cdc42025f17008992cfdc477ebbc4962ee88414afd6b23033950aff774021d0798fa615b9dec174da1a7e2236f3634a5675df23555c02ff90e3750ecf5eb03f788771a62a777927e08da71f3ec1526d2976c036b154d601d7f3aac8cffe3bad46f989fad84bb39e48c5942688b113a3f4b38de4835ffdab5924876bcfe1327e16f9e57071dd2d7fdeed9d0aef8ebc48a798aab2244b34a93e1de3ae317398be155ba3a0a077bffd52c5a8f1c1c09265102468443c863a45e9daff2c49eb00d738c876c1e2596eb4a75136f38fd593a821a6b9e85ab803da00eac4be7d6582601e6c98c0466ca9dafe4d03c57cf185f0897c079bbe7b1f172c9b5d2c248251cba2ba1331631d10ce1746271bc656707ff4e2cd050fb88bf807640bb7fd9ca84bab57ac492a2f91b457cb03a90eaaca1ee43254e3d94182dec07c38103b0d1a6345f42a5bced3614d8579941328bdbab891e85df8ac3ea1f53bcd2c68a816650a600b79622f794b54e4faa3729cb3682cd57edb4dad6f6a158eaf7602913d9b7e0bb07e275b9a84c9d25","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
