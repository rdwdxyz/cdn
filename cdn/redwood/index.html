<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1018d6297bb4be971fc5ca134085efe57ed68f37e5f2b0233ee06bca6a9223f7dd13b1426d2fbd1d56ace125169b327dc9a1404b387ea02a06d4da5360de93a1172c6745446fc4bcb6ad24bde7b09f2c8fe609cefadc9b3f47c50c8ed5bc595d8817361297ec6455a47e54a90f8cb5b606de60614696d98fec1183108fa10095b3087cb9106713c3319e8b2825ba7370566ea60dc6a8a1b353e6b7c55711f4def65d307230e6355163925b8697e4f7a0e6331ab030fdc899e07f070b557025cee83f7ea9675080f638abcc09c9034ac3bdd0c2e62942cf85d58534ec93c79fae5ba7670ba7c71aeaade96fa9cc3cfc9b60836a935c143879d8ea3a5995def2bf289581ac2129d50bbc2910b6b27792b2366f85d38d83113bd252a5c21da32abfe8078b106fb9b67ee0f819ecc5d15181b4628b7c02d6f629337023a3b3b68c0d5f5dfaaf9e33e7a1e97eea512c63340145cfb89d907077235227a127cdfe89af72a169b475207921076e344993a282cedf4eb7b19fcd34bb5f91e92bcd1af980adf893ef575dc8c9badc3b912b716fa5264f113b944e9cefb983c0ae9b47c467f3cd6e12e65b6ac9f17c95101a34f324b0c6595c3ebcab78506237082f26b1d6efb3cdcd05986bf3f7cf2bd01687cf20ecae94cc6eadfb102004831f66c2c827fc0412cc8b3989c0ba14c63394f69a72aff596bd49ddd94c2485efbf42e47e42af97ad094cf90152cd04f4ddc7e57fa8015a4d0297aca00e800b338cf055a84d8dc67743de5088ed41ca99c527b6446e203d87ff0a9f21375d812ddee8cbf5514f5b1fea9fadff743186693760ff378e2dbe1382add54900e16139ff61c08c90d70851db716f24c85dd1c0803446712835052aad1632ad33da14d368e7008ed7061daf890331beccaf968c1723f06dd4df08f72d861406fdcc401ab8e3b4db6625bfab9c233ae470507609118eb4daec3e14279730efd3e3291a7ab2ea97bbedfaac8eeed0ae9dd17a1cd822fa0f02b221c0bcdca7205e49242fbfd2afd04e0a2d541144950822091bc166be0d9d7d7c6454e6ac7fa02198873f879d2526525ff45b52effe99d48d17598422298f9e9e0267cf262817d89fc8fa7d56ad659c891d60f51d97d1bd0a369c89cbea36ec451420fc7aee851373a70c6a54a86342c7eadc2f290e7e1a51d308d4e68aaa1c3bb4f6f5ce99b3905dd04886148e0a005bb6cd4950685d139fb1580dc965d67f80bbdf80dad5e6cc625ae5797c766175fb1ac9ff53dff199355c74ea3477a3b9a7f45a6323ea968fb817dbaf9d948b69a37dbb81193463607239725a6569aa5f316931335813f769811f20862abf5b9cece9f8e0b957d424ad28268cdbd3742f2f96d14c013164a75ebe4440d2b9bdffb17aea13384d6d411d9dfa79a5d954219f79b420c181447f56bc8d64474b51b892d1665f3b14b4b53914512868b5fd6452d0aed378f9c8b786706e73994ed8eedd5e6a0c25e956c446d36c265169d60b51dad1251e69a961a988838777ba5fb225bfa6821c4b62c597c355dc35f30b5c8ab0768a3195694130c36619d0c2f7db27c8c3acb1af0ef724befc2b644c48a4c2d75096ddd7da2213a7c613b48b36bb982d9d24a0ad49e17e695567ad6415f1516c814278f095a7bf5349b418c40f8150b85bbf9e5f93dd21b62bd76a1eccd4fb072a779fd69e263b1e0d3c80f55454af4db2c930b27a9f2111c9299011f7853e041196c9d5d2c91cec5f7987ee12574af9843feaba297c1457fbfcf67a72f2cd241bcc40faaf19fb2e551813cc3c0621033b4f5e371b3e092017e56f7d55b4e2d9ce15b409b7b5e3a0b7c240646302b87211ca4abbd78dd35b9b571f7cb410476fe7d9e0c53f6196befb7155475e5f63a0a0ff65c52b327e8ff17b32f8242e2ee21f6023597bb3a2e79c48c2a52de516e35886b2755c1425e940b3a728a1ad47e1e846e695e99ba57e6f1e145fb867db0ad907a858e01da95e6de665aa6fa671af7936f7fe7c3f7ed8af0d853c1328a63d1b20f6f5809800ce76b8b369785269ef9d19d529d0da5c9ae76dfc993f2812202e746de1881104c4cff94be5669e518c25253fdd6e9e8036e2bb5272ca7c4e479b6bc7ea0e0b18644361a993f095a71b8b27f6345830d4542df1c7cf8e11595a5feced20c3e82efc20b62dbd76071c4b399c4589e4d1ce979dd276100594cb1c0fa40ebb404f60479adf086bcce7f9cc2d29af43b2b4c724dec85eb7d5acd6ca93ec1abebd4f92f886ba3cd49f0682f31113a182b7b0a24bf6c86a2d7dfb0cede98dc1880f3057901c422cf09366c0ec1e93e54dca9f29574bf4ce6b4cdb57e5634981cead61a53e2c3c6a0d5b12ceb0aa654dd3571c20dcdef019e5952366c51c6c2a0fca9e87f08af7fcaae8079cc87e2688eb12450121c4a39c561d070de4bcfd88a5d3310af90bde88c5b7dc165680e63e155f4b66a326e33c912c41408164d62a1f0af481ca83bfd80d39e88b3cc7a853be1662dafa9f144605a49a90886ad805eaefa2cbfa4edaa9cdd2761b1fea6ffffeb20ab554466e69b9e8f726975a08ed3e6a80d8c7079f32756311ef6381f533e01b8b6a2730a065669d673b8efa0d932e54253a20181e5d20504b6c8d96c31055375ba6f67fecaf5def1e17a3d45505d62b5e9cbd71ebe2aac62506ffe05e5f7eb615b71384ef23a7a73ab043051d0ca2e6f8e2db88169219640e5770d37efc411a8dc5c0b4c93a71163951715156f7532d080df2691393013eaac7dd3ff3fd7c8f67cc3517832d80a0126d3537204983207d1d3dbc2556c162048777452d65db244694467d0a82576812125cbc704e77215e522321f7b80aa6f575fcc20680427eca40b8427dae8e8be8a81fb10f1ec7a7b5fb643c789546cdca6bc3a2759e5aad4a10f770f0e2ca9dfe6633cbda7158ee3efe2f2c1494c1dae3a0812c41369531c710dbb1f77b8cecede773dfd5921c41d0b48cc847e721517706653eaf08bed0bdf83060b5f9a47aef8fd75d2466a087df49c54d6ef62dc48dafbcd54e57e4b1e3d774486c2ef968de1b0d90ca525c770247a831e72b0d58f25d73346352b5ea22b5027d2db884a35fad78fd722cbe8ffbf4dad324f390cfbc1c41355208d3d5c72b0dc0975ee49cb14d947fd715fd0d15eb68bf7f5f55222c1e6b33bd9c7ae592443def474ffbb875da47af68e9e2323aa994a448510a96fe72b23d715cd0b2da0d276f203efd259314eeae770960971b12cd94e1e4aed8c692f1b1d4aa65afe78bc3d15554adfa4c0a2de1629bd192d4380da84b398e844e382016a5bf3047640e3e09e6c6bf7588e84e83ccd87d4921aef28faad15c47942aae490e7d5b7ef4bd546f5f2b2d3cf5359c80cc426b4b45ca55096a8b694684f66c0847d4acea320f46b86babfaab1591d8a6ac10ceeabfbe5ae85590ffca1d833be25c717477caff77435aebef836e4cd8c425ac13ed74c73ad2007c0b6d0652cdcbfe7e98bfd0de7b4c7ae092b0c8a0319e3b41fea1e9181a51e65ee8e46378ebb1afc687744283873929b4661ed41c3f04df5dc16b3bed4408ccbea1ec59b83823fa2651ce2f3b0cdab007b9494782e410be23107a50e902bbfe29d0d680cf7670dcd55466228dd40c91af380850d9c2725298e091ec81bf360e77a395281ee05c9ca8233c282150c89330614fb885af44ce2011be30e73fc3eec6b505496abbd7ebf806bb50900ac480b1eca2aa29c2af5d89efdcb705448c6e5d1f3399da64543f710e1a4567d7a4bec53e150085fad76fc6832e4cf7359d7df81ff01d88f48702cbdedf3b7089b5a2f70d13b5901c4a7cf089f3785f6c44d9db7af718930e053935e52535035341bca6ad08d0c6ca8358ad7a22921b02d4bb0f4c7882608113d27688dedc0dc4d577bfa4e42e27a7f6e9a73924d9675b5835a55d8331b93d928c3b63d7c813e06f3250c2d72a7f61686c3cc9c4cc7b716a8ec1c9c8778d98c6c6ce2d13a5cd0ec578e8bd4e1464b33495f9e38dac03d5fc786102305c70cbfe9e6076846474ad4357f23e225a38e82fac13fdd942d5620030d00be4ae62bfae4e92ba1f119a0b989030b1c5afea6030787631328fdf5652499a547bd41c2a199570422c0e9e856c6b25c1fb103ac891c88484b17c96025add2cc70a9d26285c22346cabec62537a21a2fbc143347170c78a621516840336cada7ff6434c7a3a4b435e1d2655024e930c89ffc208482f1ae8e2ae7eb47860fcf298c8eaf4fbfe2ae37c1bb84eaf0724ed97e1570e86d2c5a039a37f7dbca0422a3f4b2c3ef59c9092a271aa4fad2cd0e1920d9c2f76544c304562f40806c5f6567033837de1a3504d7e75022d0d2782ba8c09b9e250faf02f6cd556e0cadafb1059c97e5e2dbf167897884348b6838c37314814a12b00969495939d6801274a208019ecb33a5b39b622377b85c73e660610532c75256eac5146d90d413359c93881b0876f9c66140684a1f27eb49bfb8278a7ea62980147af0ad0c3cca6afdfbdf3a05a789b163bac832eebad9774810580d7e92ed34b59fc8c42e3079314140c019d915ac5d8669b01200a4cb33f52d0a9c3decdc2e7c809bf1349e259a082ac1202a33c8d3cf27bec91aebe0288e92e15fb364120070e41388d81857bcc0355cf361413b5a62fdbac23dff3f79aab02ba11f6aacc693bba98151d3874c21f804c324851eb7957ada4df93f457a7f6873fa5fd82b62fd6dc7ed840d18ef3df33ea82043aae69b40d4f77375b0694df998d968295c5eff46e637e48033da42cbddd12b84c623ecf9c68cd7b1c747db047bfbf8f76a303fed340e5126c3f15df04b1a0e5afb7a4c9ce1144baadd83534fcf4dd04162b3ef9d00fb8e07c84a29461315f99b4643e886f0cbd85f50eb87c6b7a1ed2269ba224ddafaf8c18f1a7d732a9a05686d48db83834e84d55900d2f336f84c678fe46df5e9a0a1300e0a3153bc6ed82be12844e1eb0ca7a9ffebb0c30754f212988bcd5bdc25c35439ebc013c342915fd4d1420e6d10b7c8b5168e8bcdaf3d9cf8063ca875364573a40e005eeaa1c006d3da88ae4be0502df1c1b9305939ccc5f4354602859fa34991bdd8058f16b1a7c2af78d8ce93cbd490e0056b810bf5b62737d43136bd16e36bf0e0bfe57ba73f9843f9fbab5d83735f863c43b4e4dad7e6084361fa075367417856eee79c680bfa476e57642bf028a48695af243e72666743f1263cd7218a22d2bc92961a007b1b6a4a78ef9c9450b21b69ae6cd7e201f44f3f51ad92e03005d817c81ebe35fd3ed49f5b9defb7b1df8255a2c6f420d568ef72eedd89b39f27437007edd59f61d8f9e7fa0d9192b88eb685a78027f6a148a6520f671f0e2e883bf4560af078f0c1cb44a23f7b2a6f485b9a964b8824b2310fefb4cf0b65341695186acd50a05f8a39c856d41e6ae1f44e73e0b216fa92a56906cbe1892836764704d02b09acbcdc07e97fc8547a6d889ccd561eb8370501f371c5f2ea24317232eda8a40317112141eb2c995e280ad691262a7026ea22d08f1e3c14c7d816e538361a45a6e24ec21c4a1009e5c75509779e7c085e005a1d6c06dbc20159c9a2a8702283a06e8ed80e31203102af5a8adc8382e8ceda553444d75743fbd9e9903560a1782a1df3e6d841a0b2a4c52bb2a132eafcac58af3124d82f51ec4a9034db41e6440291a2ad3775fa498cec2677485d678d31d2c9e5981e235288147ae67265abd910dddf20f490896af221d844618bc5de050bd8e9353b2e16e5012750b8cae32b733c6ddef75f990c507e4b909f6750093a8332c35e5f6e7bf42ae34c6e8de45ef39676b721bf9b22b57d52b4225d3cc3a2f16aa57d6f3acee9a4add949f1865c34d35c727d2588b7a51b9f2152869c34341051064abe86507a56bd3fd050493aed8ecb9228f8ecad19bb2cc828714e92eec4b44c3ab28f4816d038134744343353d8588239c3ae8acc687030e8d685653ca07f735635e18b3733888d6ffef7d6061974d945c58a208d1385969a3ce488796df67b44e2428e6a755b490fd48610c10d1ba6fadaccffcdb2c352be966e25a1439c05d61bfd06cdc1e2ae96302ec71eadf065c3fc880334b273a1babf60b6fef374df0baa698ea24ec214f67cfe062b6e1000a87feb7c2e5b9460f009eb3f11c53427c8b3a740c1e41bac59b58f2183133c97fa574e790cdc4709cf1bca14f68723c02515f08bd0a58f2b37bebfc2781807eeb82153e5bd69c12b87356eb32c0a93349f24ca066348232b8f095099d7f6689e0c964aa2ae511ecdf9b829875132d3f73aec32863cfcae919373930ae722430d31df718827549cd988e3850900e86a97708985887b5ef013f74bac85c240839dc3f0f477e0630e478b662125caab95f67f58f63a7b76c0e89345add238b3cec0bce7635b38e2b007ea1ed36de9f79fd4fa6c8f0bb0cdf951c2b97c7f52520a795aa746e665cb2c9ad83a97bda9487d88d79346cdde4e2db5074439034ba7b1b007921120a9fb9023ff2cdce0c0252acd5639caca7b56cd50d15bba0d2e9631ba7b281d482f866d5ccc1a64bb13339b0676ba71e8804af1ae3c0613d3f2ce6e64c7a304f3dec5da9220248ea7a85b40554b951c35988d8990a146509de6f3c57ca641e0da40586f32491fa847daa9be7529abc72f39b77ef2add384843500fa493dc96307b9f411e8aab1aa5d1c3339ec4cd60ebed66ae04bfecb80f6a66382da4b8d36df362124caf183bf37f7b43439c4cc9a46928f195f45f951467e37182f56d0948d38cf8f875d50452f6dd8da5e985e0ce5802fcce7449a72cf27fc79cbabead585da7575cb6b5ae203d6911b4a1e3fe61e5b13c4a96dc02dee2c30b5fabbbdc0859ecee9063ed34e3fb35f453b9b50cdc2a1f3ddbfe68f734eb8de2425d373561f156ac503d7367c646ac34f3af70069ad309bfa5437e73101d1988234d5fa184f26868fe441defffba30ea8880e6ca90b9f2e40fcd5e67b5fb29fbc7dde8160bcce489e8efceabc334a52c0984344065000383e937672a1e05b915ae09c44bcdfc29b0ac713029b91cd5084f1c408d19c11402d71a93fe0901b5c7bcce4247a5a16c5d0c08ee6321c077699eec5297afbdb86d9a62baf2837c12cf7d43202207fdbda3b5ac569a4cd9e79b10e097c28735fd8f0016def55dd3e0efb59e90ecccf37fbb654b743fdaf84c850d4cd0203ddb5420fbeac47295933522992a7965bb38aa8377e4aafc2ddf196d74ac98327460b88022a05f6aea3c1f94194bfbca810b6286f3ec742307556ad4ff562d243784a7253c1fab354e76751241db759b9a84f72e3ec9908e1237dd35dcfc0d202f76c2e8e12d39f4494f93c3e43167e2b21c1aec0cdb97ce4743ba6e17c0d10ab35a3eb8490e814db49f00f89c515040e11bb6ac95a1d0b0c94a3ee3f525b415f7764f72c4e1b56c3f1c1f0e8e10b37acc24b823577bd4ff428e88dbef4262fffb94a2a07dc5863f52c28b62cab380627f4ec2f358a0a1c489a94a4e779a930f8304a69533bff385249af927ec1c7057fa95d5a6d8878888ab4704d0f758b8db824e046afd18d866f1346ecb071b34df9d118f16f114160de3fdeffcdf2a147d65ea902ad2263ceef33c31265728350944082006b4657c6029d82fd7a58fa7914375597391254a7a459d273ac162ca2c334c92cb3cc817928be7564803ba85b03d1cccb05e5ec7b3c82b3b18e2841fefedac788354b4cd1f377a0802b34a7a32ee767da0830ea8494b733fcf8b30c460455f539bb928b486fde214e744dfa03ceda8a193805b208d9caddaff59267af74b580455a544cba47cca80be02d7f472404df1da77dbb46202274dbcc9aa10a4ed50a88e25ca26c873ce7e9183b58f19497766c29e2fc70abfcc0df2caf945007b2a8522e5fbe51f1932c6a11bdbc9e7f13dd1efa93f33935a61636c113a7c3aaffbc6f4f6117a3e1b1d7c23d79b108729c6a193274eeba2cf111172bf3f22da5eb4b531911410a8effffe755306ba965850b51b6b846faeba3355a87b4dc0f5397c1cc261420616a94e34f766b7b186457d57264775eb30f08684894d610ee9175fb72af5bce299f2e8c736d63f092ac79d8958deacfe7baa87cb9644d95a1f91486c54f3b09d0ff3493bebe25f43c539069bf20851fb1027ed68bed2045881fa0e1238483a1ceb35a5c584c4a60cd89e8e704d1e983f06df5f5ad6c5524a3ade74133d2945bb82e038a833dc58506d636df01a8ddc78510b9f576096c953e9e04b74d4db78d37dddb6f1c8877ff5417d5da0c3ac536936d5c589c6684d6c9b8a33296e8f1f7b7ef95ff8e6e94646039c058c6b2cb1384914f3bed2da263dfe4c4176de4151d43740d25fdecf5d9e6bc81b8b1ccf2436ccbebb8f30da1649d72f60bcf54ddc0172888e2d3d872baf9f068b886d55e59e9daddec461487221cbbefbda9a5c3ad4a596cd1fba1e9b31d5d514d837d10ebdb583225ac5525e76a81cfc4265259b3b398282512ec45f1673a806af8e950c7e0999ca139ee091297127d984fdfe8301abe227a034648024a10105a382783b5f50ba692690321ac8a1c474a0f2f0df6da5617fba0aaf217717ce17ab0fd83fc2872e406b022bfac7ef611ea6cbbb67286a34c98a28373c4d5d4b070c8996462d83c7368abb5da167b08842bcb0e7a120c43bf707f7dc9d4aeedf8b5b1744cefd9bb14d18fa1cc88035b9fb09816830ac451b1476e16cae785a9b1050c8e34b5c4866618270c93a4f614f3c6a9ce431dd76ccdc7f61b600e9a4f105a759576b3631de49823a728df853ca15e9e7c6760008193e2e8e1072ddb9b5e3e7b74e54eefd372c2ff99b506b09f253989b5908524f95d607fd5db6f2f322cb0d98d54c7efc24b4d999990b8631805887931df13daad70657ca82f38e4f10e7e5cd00675ae0c137b0247de2dfa17179f708ac1f6685002562e5487bac1a2eaeba7915852a690ac876e187d4d49e23431b16517cd29d1a22bcd9f678bedd8bb3cba4557f34de30fa5813a5139b51b9661ac92c9bb466bff6233b2912dab749b32535d09e2928ea1f748991054e80d339cc121764453d5f56e9a539e9b3b8d7dca7908cfc4220f33ffb4a09eceadc4974269030db7e7a0445e2020685004016f4a417d9825520a093f6976800b198e1295f5aad1649cbd79c4e21440aecba33f0dba7c7588a30bcd6d3d9cd7f79059b808b7d0d16030e3e2e7b5cfb4524b419d28185a929ccf3343c22437ea6a3bb94d6b91e0039243981a5aa86c9c2ca3f276b3b0c9d390650b7f79096b1f81ba147293ada2ea49405fdb900bf227a39bb949d8f73ac9383eae4ac04cbe874a93d49c00df0a05bec70a996b2738c68e4d39d1ddef71488c773e094597c24b563685b34f4dfe743c6f960d4d75127ee5fdb5616657e7c3840341853985cbe9122342e95af98be23d7e34d0a53087fd144b7fdc11f57233ec7ef6c062487ace24fb91a8aff8e82317a90830cfadcbdc2c5d012cf1f3abd52687d46906228598d93ccad6754f575c3b73bfa648d8e00f437e8e28882fcea09115d491f28b77f9aee2d0902f142eac961e56d62edec42fa314f9745b6f7967c9a67a3369ae200829f031b456e124cd3a47844779940a73dc8fe22ee4531f6ae945b63bd57971b3b9e7da3d663bdb264254f0913fef5646ec41d1ebf6479ddee787e87c012869ceae589331abebfa3adfb0fc4df2658091d22d861ccb903e72424a1a9d0e0ef19c200e96c533679806cb7ea09eca7dfa1f64018b40c9105d184ea928b36789230f2ace91012b5ac70426accd9acc8057a32a5560ea562b0d5a3b08b7d958c9d2fc45c5dfdf31c14197c0fc595bb6e01f409c227d24a43303ed2a0d6fb640fe8285dff61cf1cac23339c0a7e5b4fee8c3f3b6f41924ee628c7ad2ee0d7b34518cb955d8341d19479c73f776202da297c9dce6cc064c30ed8f82351ea7e6f4c10677a4854eae415a29cf78334f5acbe40759c09bb888558d0a7e81f7a64be1df3f57fed95aa120bf9906f505ab40a06309f26934795ee0060c0729f94618179f163a32765e1265d0a0a1841d385cb4e76b83127f11c2d7346919bcc7931b608a815a437966f5f8b422d14313dab090c1176b70cf2800af54daeff201a8be243330a1755ca1993f9dad46aa8727d45ae062256ece0c8e0262b433a6bac944694771f3341f08161a25ad87ba6a65bbb42400c4445b49961e499851d8542f651d345392c62bea56c7b5ef74077f3ba42030bd1ca282d8d064c2969f5d64624b463d590e0ef727e68c1291dd41ec2cd2a7b750cfe717062e6409eac37c5fd1397f2aa09241e1bf60e12bf4b7164bb5cfd8074d02a149e8c12ce41dfbe9707e521fd66eefe54d6b9a5ea0a3e56853682320a2a6594f815e0412cd4d451b623ab63cce233938e4d431c33e9ff4034e6c084ef950ff3ceb5dedb6720f890ab0d60180ee883ab3283c06886264123e1d2c1b79d4add7ff7dafa5eb2ec71002dfaddbf70d73cbf501d634e79ffd225a0e12c639b52d2dc9417520c0bf05b3962a6938334fd48b536190cd496906d9e37e1ac8e15579076ecfb7c3c53ead9bc5769817821cf5bd66b82ad493e8c0f0101d1ab826ad28c1eec64063ca76ff8e4caa391a74503de757aac93d23594ce8366dc721ce7c1cceacf7cb51f2b97d46307aa049faaef5243990d577d3f05c720156a22da00058a4a5fb363cac4ee025c64a9f4594ce8cc5fd265dda57a1e292b84deb5b68e33193189890b9c4b730310cda1182991605d307e37371eba2b0abbecf91f534fc3299920678bf3a19720a16dbbcb5e38ea5a5e785a7057f0fcc4ea8a43fbf3a3e58dfda1d600cea9828b8055d87d3414f8ad1162a0a66d034e4eb6174174de8a5ece0306b7cc3b353251ab4341d82025f4645716b2069a119b8fb067828480497e657617091d921425c537105c07c1a7ac2382f02864cbeeb7fddf93b82ab037579cc872a0deef9b4e23c1b68c917d7b243672ab8418c59434fb601c3c8f9a5fa831a1e66ddebd10e2b140f0f8bb65c5386bbb5dda585add76cf9fb05adccf9796abe27bfdf4b31b3b8e98e9b4b19280545ee5f288c4366793c4082c1eb20f533f7e29b190d4d3605e692c541e679b25356b821a3d265e976591f404514b2c38cfc95f07267a47bab124529979e2ec29470a0a9c4813bf61ef7115eecd1a8b8c96dc0fb86a49985b0eeac666fc40a31afeea1548caa8216c5e8157b3295859463d075c3f04c9f6468985fe8e4e128bb9ea548c0c151dfdd30197350df3b6861841531d563b1cde726c16df3bd9596e87fa071044ea399ca26987c65d154a964ef039c94a09879347ea22288086952bd45835d66742f887c99a2aeaf74ec8ae80d672120d98086189d4fb3a3913b90d200a996c51b51fb66fb5d9f53d52b3942eff914eb9a479013e3eb8c3e1b190e304864946eecdca049ab3b705eccfc80cc3dbffdfb97cc56d6a8de49e6aec0d286c24015d108cc1b78adeaedd1d499d3279957fb1f5baee1902f7eeef94f4a642f3868787814b39d066b261df19aed13d815d5a950469f94ee2d8d5751d2bff007aadfcb7a447f099874eedbd04a31e104093ad8d597d1dcc90f3aa2ee5958b0025449a3c35bafe56f28e5b374ee7c9c6f130d0a445ff174655f9c48095f5285111d3579c7a528739d84c736fe4d486f56e8d30ebf612e8eee9a303092a2be6c695e2dab3af6e1f72e6f92c2ac315c18ec31b08cdb55b6795c3da6e781c422671c6f51db0992bbd062a87e728c737f5c81cc09290f9a456888d5a0a28a3b33930b8ddab07b3b32a6fbb32b67fbb2181247cb4814a16df318853db43464722069e6b01be44083eefebedad74849537830f69d09c7d511e30faa4d6396033d0acc9ac88914d9d7facbf948849176fb533afe1b450ddfab85074f5dc1321f975de1cf4bdba7cf1fe117104846c3a81b78d7c0cda2a5b6d92daf88a15569c8378d61f05bd73a67710921511f61d1bb238140d8dc1894247170dc8f0bd6659aa38a4206dc724f0dfd3b4efcd2093cebd9c4f7a7761c8c159eafb2b021a8709c5f437c663d67bf614a051f13465bd803eecab4e1af0a244dbd380880f14b291336b25cc10a48b2a93be6321bec26a8755bbf846677e30c27db526f8372ab45f15214dff5598bbd31663c821a4a3f35913dcbf80632fbb5f97ca07fbe786c6ca1d8de5ac8c80f4a2628e3b8db388414d505a1866063d11c23397cd3c4ab0d5b0d40df681ca1032c2eac115626b0c0e943c7348ba84cfebd898650abb33e60ceb86ab6dfd5fb9569bdb51a640d4828f2962985f030b3f1cfb03e36808236130f03a482d7edd1d5c0abc31aa909457dc5882dd00d87b4fb4f922cfc9c53d980e17eb169a9d4f0f3c347f03ed376e89488e26ce4310a882e0443c1db0198e1357d101bde889d9ada8e250c1a11abf2add92d2dba01e7ff182139e7a7501f47b12b93931f029edd8f307b2a5fc31cf403a41cf3fb4934992d7dde5e13b3b4dd1d925b1fcb36984613685717a90cd9115555141803109e15c819f515d351467302d29f90dee842d165791435cf4e5cbd2589c1ef8fef9c732d0d9957963bfc0b54a4ba72c64bdc986a6f2af0f741d0e2cd3961fad6850af9947b96c50e498cef0e6ed213fdf513aab610673300b09701dc3fbf247b084441b53772057c63d90edb34df87053849b3ea80b60ba483774d01009d8cfa7235dd0c6791c95c694c20eb68f9b0232ec0439c27f7bdb2165c67dcd82ed8f339c8ee4e554d306f3a878be611c4bcbfb837af27bc4e2fa1f5016d245710847b799618adf3eda9fd8fb3a859cf3e73dd008485949fa4ab1e26f3bef4ac7ce0bd814f7715bf8db6ae901abd3129e3ccae954a63b050300648978c621c61955624b87cd5b21010378320eec8b1456f93f9f23f80b7ae29d80f12917ce7903c00f5d138ce07c07131c3bef23f5f93d9fd776aac6188ff3b8d7c848dd6838d73f29ad72f913189d806e0396b80c89cc4fc72c40e6d1a9a4371411283632e8214e59abfa8bb7e66dcb0c0ffd25b88e5a1f1a996b2ddfefb0484bdeb526dac00088139d508d1e826467481375a312047d3be2811d54bafe4ec8049080a1074082d28946964a4a0fd1ae0e54ebef514efbc90a3fffd9555e681147f7e3af8d16a92d69c8133a31efb07659b3ee26cfc7fd47ab07c911785467f59308e00e5386c33d5dd79d48ddc72d838824892dcfca4d809af0c8b7a6152b0f11bd80ae24bb0dce6ff978464c9c3c8fde725d964d9584b28edc5453c572a8879617c69560f641e7190d61dadd5502907f22cf6f7233bd00cfda093eb1cfa3031b98c247b98081a9e03fdef5dae817531b28c7cc429346e9bf5e24d538c125ff4f32fc705d76c2203beaa2da04305309869e2f4df9e81f3e35b5af46eafe014a144b07255ec6ab15415a1e4486698cd541fcf981c20ecf37fb5b7e4ffad071bf8287a2ff3bf419c0c0dec7348dd424a92e2b5299501aee49af7800a54cf67af78de48a6bdb81f05e5919d92e918d8f3faf098df889769636a9a50cc21ba817f1eff6eba5e37df9bd9b408b25c4d9ad9fb2c6818490d6270cf56bbc9bdcfa01b2aef90b0a636fe30f6a2e8c5e92c254977ef56c79fcc0c083f9853a72ebc3cf89a7863ef3bb423553879974a4834363978b1da1df8d3b9d5e7ddb51aa54313b4e4e793a90ddfa492f1ad8ba044df9708d6a306366722a5d32cbf49a5d6beec942973e7a901fb73a2d72656399504c08455e1bdf4107136ede0715091553de26a6d7c1c0d931550f4a67c58bf4f5e334f3ef7f51f9045712e215e395e8af47cd1ebe0aa92aab11e059034a0e76e73a07efa06c685e7fd2e7ef803529854f942f6264dfd89ce3460d0ecf8117eaf478003e675cccfed2b890e646d1f589de655744be73c0388afaa1dd62dc37997a7179fa75a32b4b508ba5ac3f5c2967b70d9d3b49d38b6e5b9de37f37120726a7a09d13111149b732802da98fc31d4b74b303e86358279304fb4bad4cc10be35876df92cec68237463b663ad5364b9970a1d9e693eb1ac62d0b46698e151b5061c48c5d38a2eec3b1bbb21f72bd24ce6cf9591cdb02b8e34c9243b7b4b6528f81c0d3f6f9151d4721c6d51b0d7635255ba39deca1284e09bd84fe495d24ff515eb90c4a649d9161237b7dcb9577f36dfeeef4d51a7665f0e8745df052889cd370a933cd0d5f15c06f930519b1f64b32ec863984d63cee16c279f95ca755457f4b1abdba084490d111f90d169d20eea49fa3a8273f7af65ceedb4398caa5aaca1cd5c2f08d608268e4b9a44e90ac34fd39c366c2d7140529fec328968b2e0762871850f30307dac7f536f1e19275d9f7a565934e62b92ac478f7e956e630ad75bff36b33b44f260e133c0caf2cf64df6193c1065cabfe7d7da97a60bf2810d5f93ece0a4aad4a22abfffb93963adcc85d7cf6f931f0f1a0617ae26051fac7f81f5d7ff1f6552a0a871b67217681b5e3a6f6cf4ac5bfd0f2e2d5369e4aee666234999f8f035fd01c3a54c79884138f8f14a4cceb3fcbd3841866c124cca60f372260dbaf8ee9e6a777d680e64e3b497a05d8dbd09e772f4baedbee0255b55da97496af3bdf8c82411914ec89e9202e8250a94e843bd802ec5eadc2dc449f17a9e6c3fbf339ce2964bb27524926d99d084f26c64ee2c7746b43c4203a544b2ecee6e9ac52fbbaa9a8e0f2968e061eb48bcb5d786bd4a54221c6412ff2c00f5fe02a129d4a31eaf02dd03a0c5258933e5ca6306d8cd4f815085457dae90cf50433253a3b1621e6aab7baea6f77d161a79f82e2ee382b6f68fa781c7dfe40b0175281d6382a86511db6b4f195598d961be5942d15f0833e7c3c8e14ecd230bcfd8fd1eb64690db9963a77d79b1b103aff2710b2ba03ecd9050a2e1079c6dfe0d713bc7c24f0feb8145ef13c68ac30a33ee44e2710253d86fda4cb1894e049103e4eb04466a1c4d3ff2400d9fe8452f31d85f371ef33363f9e3757cc3beeb77a4798a6d85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
