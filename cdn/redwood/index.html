<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed94222196227163a32d571239cd19f4b3a0082ecd486c6618eabc0c94d4758ebab1b6c8030756c6fa59512903257da6bc34de37b05b3f086e0fb92e7ed2b95df944b18828325be67f66bafa2829189619ec8914960fdd713709e8b72b2c00d62a25988da6e9c927ae44589eb5b80a42267bfc63d40d1b7540e71ad362dcf4d14df2d10cae236fe21c1a7fe641d62543684fb5deca0c24872b756ae58eeaf7a1ec2a01df1d487bd48addba73dd0665d713b661be1a5bb97498d6f7106ab8af83829ae7487ced11b6cb7dc52b7975a0090852985c78051c2d519f54eb88a83792a4abee24b5b59ce01e8dc8845c912d5c453059c2bf4c8dec41c27611a451c890741f9547c738cd4c9cff5a5c62b67915328c888b83dbeaca626680752a79f61e1974f24a965195054fdac227c515e3340f600152dc7c02c5b8d58ac97ee4b0ebb5edd1b5fd8c2ea544b9d42a1a8854c609a6ccd39024cbe0fbd7b7abce22afef7daa4778e775739c560b5446e586e12b87594d9ed8a02619eb32aaf72f3c2cdc9275d310d531b982b7efcddf1ad5fe66ea944d50aa7c85459af663b1f49040b1d576c4c39f87777209750154afe3f89452e3dee363a19c21f894534f03d07a33dbca5ed1ce956d17b6cc7f58431f5b5fc219858cdec6ac8df28a3f3775b989472ea785f7667f5744de4730c7347db458d7e2d73797b0f3840a1579a77bdcd74ad53602ee2c352aa873bfbdb625639f42c7585ac275ca51caa274e29fa853b0dc436979b0bf359962ca6f7e7a5e6801b72dd57a3e09af83f9b3c03bf282701f648d8e8478814191555d7a180acf78b5d1c3505b1dfe52fa6354912c6862a5d8dee416744308fc69080edd5e488317076d3953b849cc0565d17f252c8076e82002be2c8c3a2b4c4f79de097b43204f0839c20eee2873e29c908d861a424e83aa429aaba6edd514b5cd570342ac5a744bd98dcdfaa948672b08f6fb5bcbd865d38bf2adb2852e23577d3b1c7a6dc138838fa7316769c19449e6d364005cc2e1f4c5c9df2793f854d869a45d421f08e7ab6ab1848a4061ac16cf2f0e7c741759eacc6a5bba264efb96b888f752ca2460ad4373b9a81b3c6961bda4e9926df2d08ea982b12fc2283b0b5e81c5bb49ff6fb0ffc2cdb52c79d8fd23bbb8df3ccecdb2ba1e36a9b40bfc4c61518d741c2c0bdc0144cfdbe4d935514f137b823f75ebf1354ae409bbe4c41203296dbaabd492fcb22f281feb28fcf852602975f0d717937500879b5cf7b02bc1770d1a5eb5cd0700f3584ce2ea790c85f8529717a7d5aeb0b227417d57b080096ba87b7b26b27490aae6e0c88d42642ba511747b0ccbceee1665fcd183efa550ee3f0738ff8b3bca7504c60d743ebdd0100a2a4955f42f2414e73cccd56598d9aa75a0fb3ac833eb702a6fb1939eab8235b7e0c304348c3cd9ba21dc2331b0363f45bb5491073501d9a97e23c39e179d37a12a7946932526d9e3de3ca7b4e36b2c8de81cae67133beb1d777c25b3c6491d367bb75e07674d595cc27c83f09aaccf864b45be7e90407f3dfed08d77894b833e4aa14c4d85c074413eb8ea3d0660719438b28409f1288cc370d03c85af5ec9f9e909aa6de20b7447b3d38c20d262034804f056a6eac9d4401848df33799741367a0a0c5ce1d121482fbb2956d91bb0b5455d39442b45dfa6c676a61114d35b77c32006fea29a495faafee344f7b5576ba1abb71c4ac14bfc36a103e45688a4649ad5e4277271ab9f24d79c80a6323b406a3460de35dc6767f92389d7d98cdce88f5628745e3c60682a79e08e33336a32f75f976c54a05a9dc7d3728ed03464e8b50ec9ac0e8adb96d06b16188305c76d55f9c9ceecaf997158c6a92f405c4b5abe605904b227827c014aa533f1123b4f1eaad067778be33eb98ebc9620bdaacf712075388180d05b6105aa34ea5bac06ba10a754d9c32eb4b4d436ebf255d8cd29f20573aa9cd1a199b5eba0dd0d0fced5075c08b355b90a6f6965aaf0c72abff8d36ab12283ec7c51029ec7a663b832dbc5af0ea60a6a0bac716775f57f4dc52cdce0ed229e0e4bc86986df0234bc7dafdb8d7bdee59c18ed01954b68453bbf127c0b4bd83909344a2303c0e46d198d189d9f672ae992e6c35e446c0a8ad78b15b925fbfefba4776ee53d64361c9a7e04a058505a91d50d2c735966a5377ddbff5ccc87cfdb5e4d4f6f36547860441800e1745956d65fad6c97e86c4f77c8d70b2fdf0448ba985faac5d3ffab3c53dfe92aca22090d0fcf40c8a2d610f787e01187bcbbb8ae3f115875e6c8d7fbfaf1064de1eec0e738b07ba5bde47e07b3f9209002581b60f752cea9b5e10b8ad9fbbe0a2d2400193624cc8c636346b0a49000055f8c6cdd1168f2a6216b34b18185a6da3161723f5c3c4b383177eee2c914cfa7dd947e6749597a2bea99eaf8c66833628b3a2010f286c3e3a70224459d699cb12a1fc8a942d26967a9d5248876fad8991c090ae9588dac69d85a2b8e241a947af9508101406d4d212b8f5749e72bbf2c53b55f750b354f2c23f95876202ecf0b454a52eabc8d5bafee2835c817b6c0d40e2efbf9adf8dc19a32f9c36e3b21a37dd0e47e6783bd9f1f82ee4c21528380974968e3b2a4f2c95da6b77faeb98bc1fb5bf9ca89582e834d61cfad65c8b6baf865126f08c979cca6dfcf6ebe4fe9ca10ed74cc6bf0852746379ee4a8dfaee812cabb1b81623fd786de575188f66ec067aa9adf5540f419e3bca0424b629d446caed71533ad8e098f9059420c8ee77e7acc5c0c2f1ffe6a1a3fcacd9b1189beec2128a5b33fcde2feec29096ba9c91be0728ca6ceb7985c1511daf043418b5bdf8d62ce1ae38acdc3738abdf824b088107096db4972995cca84e5c9820c172ace706889cb89101f4c4a615a0f55b131af2fc149c6c428387637843e8b3416a9febf03608eeacf440e5c85b026faf53f6a381da45ee9d12f2c6ad5c75cf3b30f0258c0711862f9a0dc17cb7e9b0f788a853cb825d98f2a8736a58291ab5275c4893849ff51b428768eca9df0baec8b29d36e5822d0e0df7b13a1472bc4734379ff281a50dea4b972c74fe364eb6aec213146e30f86297ad042f152384f67b21d713fd8edf77b1639eac185ae6548239b01d34ba9481ff7bdc33681294a701199e9e44740099f4061117aad0a1ed8093a8c2ba4444b765cf3de90208376369abc36ad9ca6d9bbf00e28808bd3e1ad4961b10855233a56b54fda1126a1ceac8901db7e34293a24718c4c1be73b9cff395329d3bf128ed134e09dd731ca0ff1fe71722b20aa35ef847eed46c62ae560d8a954c5e0c4ffa5db225b2274478285ac60af212c3ffafd7376fff700f9ea7b62d16db6e6e0adb1e5e3339b95365f4f639fc3432278d2db936563a871c7d397aa34e88428e1687cc7fa6d569f530a2010529e4a70fdd9fa0a7d43b6744df58602e6bd569ec16a150875e9000e42a5aed7647a00739f3bd61174d5e6dc2c9654417492deea7af676541f46b03f94c57bff4ea207182ca8eaed862db44e39462c3a10abc263febaaa639e83c7964225aed8092c30bd8f5b299c43c61aca5d530bc1bd86fc94515c405cf070dd50c1e0e3fe6b99981c128c9b4ff1bab133fc766aba044ce23774b570101fc80dae3f0666cd7a7a1a2a2082f9a950ef0489bee7a18c8b1d61065b55ac3f2644884a3511641ea808d63667b96ae22fa411345858f5dcca41a82251d9263429b64f5e31a6dd5d255dde654c95a13dc2fe63a89f3493a0933b04807d9e74b3b31fcca4325156ddce9233eaa75e47e1704b3c56cd8f5e0894a29405ecabcb3b852b033e3569a0047bdb6c4f35a182971cf7e9ea165a006c6eca74363d314e19294a05abcdf98925e56c30bc888d5ec9d9a62a39fb06e660d84dfacef0f1665173119975b1e37ca90660ff14ccce2f10c9e3d9157790a2693da48a47a6baf95f66d1842f476cc6e3e20e1d27c5c91f40883f4aa35292d98f2e08d3c8d2cb96f288d7112d40c9d38e7ce8f29806a9b3acd60bf6d2b9da1d79d7bd5bf6f7e9d9e3f064aed16120f20bad1537e0b9617bd78e4b10d136dfc39a7f7b3ef9079fbb6877da15bd85085341746290c9c1976bbbe36eafe48578c53eef036b158184a1f2f157a7707c30022f5cd76198256366cd16447b0ab86ba937a6f940695f90d40a339059cd07b6fce8ed0372d7643153b0ed43d85c78fc4fe82b4e02c59fe7d111d99d76f0225fa5e3938549dceff5220ef9ad7a6a8bbd80563b7acfbf85192d55a9f08ea235f99fcc2f79368f1df63228a9f91e64d9739bb794d440b10eddc551bffa49f82e4ffcb634f35185d9d3e8c0aecab0574e1e20c9bf921b6efb8b0b5800b2ce9a6e34fc179f2acb13b03807f0bc4d45d40d8f85dabc7afac00d67cc1a790ec6788015529417dd3919bb3eadba7138c1b7ebb6b55e13cf898f812381235c9b13163b067498635db79409d1cc24940f8ca90e61f58d384aa77b7aa469c33bb07899fc9acfa784d9f2c02055e7d70f6ea7696298daf5b77340ad74e3f996e670125276edad37a9a4517415e88734fa99fdd165d5d20aea8b6f00b28b051350a9cf22c71ac88dc026e2db3a7b7b98b25bdd373d0d1174f9d930492a54c6784726cec69abc31b879c073265ab4efcd58ffe358f2f82910ae72392ebb73c99eff6839254d42c1761ec1c0e870577c5e3ffd5fc13eb479b15f16a846ab3cffa9259424524fb9fecaf3a8b3aba2812cd483ecb8865708a91e1e20a42791b186a18c6b222898982eacabf4c9c4940f2ef589c0590897f8b482015a35f184c95a7ebefeb7bb0b2cfb9e9b2009aaa8d59f9db4d449256d92390c72a80623b64558ea296680e0b368a1143f4cd8ca2b79b173a513efe14d198f4775368ba24407efb3061ac6eecaf78f1a3bf952bc253812da7765b565211307fd4580d3ad464c95ab27b694889633a203beada423e6b1aaff58e28c0b12b8617cabb2b9ab1fe5959409fe5abcf151e90c8cb85394539122900a9d8177082592c021ea24e85b01b190f37366f1f4ad622b4e1e846e1527845a1f26767a710a34b3d15628a7c141b982bdfd0b0d077a56f1aaf280cf7a74e823ff290017fa17ef5501f3b68f18c523b4c25b426656a1e18fb1ea62e76d2fa16f4a7e1f19a631655243029bfb65da9535e8f06df783641c891841c12c2bf4276653714860b00efc439ef0554773f3fcf2784138801c1add8ab608fe51e0b39e3fb7a00b6cee3de49708a33090fd47979996d27c2d3e09f26a26085ee9cf86933e864ca1d29dba33c374e7b7f1894ee25a3d3d540082c4866bb19d8ffbdfc5e5c0e51fa32d62c133a615815e1c4e1bd6161d5dc4f52122d089d79232615ffd4ee0c2e6b5d752ad751fcf0854b30a05b77a5c9908a44352f15f4af6176188adf7a47209027a83a74b0034e7062d65526a03146277c430271f59a8b55f8c35a6f61e2b0127e6afe175f6ce0d3db0736edd364ff0ac9228d63f788e3de905d02d0dae52cbe613385deced8c5eaec2c3c82352d7744b1dfbee00e8f5f11db796af709228448170da8b4586524f33d6817ad66d77e1a4bee4bb8d4281e32c190216bb6bf769482b14a834e771e8d3eb1bdfbca5bc17f6fd6f1033f071516b35130aebccd2899fdb46de5b9fb6d585f8991c32d376e8198a0477c19fd8095a0d624be0b6c53553c77dd2395b00cbc4d9cf1ff95603df7f15447cbf3120eea71744c885abe09524009cdaf4b83d120a61f6b93a195f4acb60ab4a25fb5a49dc464b0635bb9dbe87b2aea0fae78f49b8e164f8f2128ab60fc02d0442af5edfc26c00edd14468d4232946e377756ceb87ea6a05ad91f3ef104192dad8fbf156830a8f8ead6d63174b02066269d9f5f99058196e57a7400545088b49ddad21fcd44fa36b8a0d196c4e43997631022314ebc617e2b7e74666053909b358b724871010308171c7d742fe2eeda336922138a02ee5667ad8a1c6164c3a8966b2e8095e6f30676f8c044a95e04a9c25b034202560dc9606fcf3d7da12340c31e8ee74823c65c9528f8f1965c6b602b1f85d19ca874248bbb0ab8ba0238de076c0bfd15ae50bf945996e7994c6e7abef28d7c83f84827875a9cc1784b16885a9a2ebc61441edff37395a7c848a3f9c714ca97ecaeeafd345065617e45fafda892ae6ee8d7f772e0db8f56f9d3a18f1fd13ea76d71ca5d6e44a38d7e3e70a7bc26863b824027d264df4fcaf05370c496ce7b15d77d1715ad128226413146c29d5ea62cf4a4275e51853f591b53701a93f9f10f4c8e57cc5e58e5f6ca042fd2fdb410697d482661d081778a546604c8f3a885c7d828917e81d95f812592a0d0666d37366482be01b2f90104754b3b61166e598c1d0b1aa66168bf8793fe8374dec2da23ee6b9b718fab867688619f9facf344808b3f38c0d2fbacbb2eab28b4d8a628011b1decbcfad1981a4d8976d09cbc746c67d984cbd02406213b1cb100778bea98541bdeb4ec787d18a4d1bbb3cdd3c1e8b2466559c6e23cca5601355a9e43d1cf760aff9d60fb1a534884f0bed521b97bbc579de8ec21c07a7a630d99aa485587c0fdf03eae194a57a48a22f8ecc96faaa9e2c082e658a4b2db4bff777b8ca5719bc351cdd223d00004b6261e899c60de264d19c7ccadf6958364b44a262fb6f4b39d57591226bdab1a854dedeec4a7f999fa06c760719cff346076bbfa32e54c4c0920332339cd3454ec2d92003973c15ee8c860179565fa15438c87b1259008da1382c67989dcf371d8d02710677c7a268c5e2748b327ebb62559d8714228f5c542d7d68eb5d7bd73fd7137b01545e6961da58c52330e0e665d34b3dc3c66467fa48f23c6d4d34f96353aabe74642b00fe8aa23bd7880e9e2e85149fe3f836fcc552b24fbd3a8c47f6bb6ba595127da7593f50201e0ad3cb0c478d63f767bd4e3bc02cbe149db3d3ef22f049dad857bda465a719436dda65b3300adca498fd0507bc28fc98858fa15ae8ecd5e8020807b53309c928288d322cbcf960f860904388a03ba39a3dd72d8741d3e80d03159b18a52afd9c1c366c7e7c2fd359297c09d6a3c697516390db7fc98952c17498eca6ea3bc84d193ed8238f75da9a1bfacdb42d9e6860006295282403d84567dc6cd11e2b1021c66caa39f0c505226444c8767eeaabcdd224b52f89a5e408b92f4c9e5ce865a0555b7e64c40bbcc9aead292cde62afb039a212832e1fc7687bc604701467a633f4cb78e39073c71335e5116368a949baf47a132f9c30f8ae1370d3a138ad731756798875769f6975a723472b698cc3d99fe7866068af7e40fb1db0a7ec8734cc1aac894ad79c650adbc3d3c32d87f81ea804cf9385e0ad6f757f2167447ebf585bde15f186596844a0581a04a8aa68b590a97359ce17705ecfea65e8deef0361310f878cf8b8eacf7b78a83c69a06bc7dba38afc7cc64e730c9d0a5a64a459d87a81f803fd9f2180e69ef44d6fa2af36705acac2068c2e41afa72763baa489653ec5d82201ec5c751b1faf6399322e7a65f6323b5f95653576b40aa81673cdf0b44f36b07c7c0ec0bb054b4a4107df34da7d004c98ffd56996e86d58c7ab494899adb926dd56079631dd83bafe3a43b7d2512ecb065350f6ad1d13c5eff76ae4976795ada5fcb58f3754f6d3bed976aed1aebf451160f197f16f863844f6104f69c670240729a98b26701a0905ff0ad6ed416092bf8da9c411e326a47c3bc127544364546a7e058e3176fbe664c6b9f0c7aa9b0bd342210e4f1cadbe57eb7a7a93d1e852fc3531e635161441cab133e836975bc9bea5b9dd533908c4b3fcfb358115fa23f897b9c1158f9fc9673bbf72709eaf7d4e40e71674e05654792407a4a7453b6dd60c8e5e30a82411fba780f66c206cb059e9bd8a2b9989f49dd16854cedf779a425b97c32e4be1ecdb8932eb4f4bda201130bdb3c1d7f1034e1e05c7d7585dfcc508f515aa3e03d9ff1669e452e972560716b95d47091aeeb8a2a6cbe9795f736c7ef99fdf076a5b3cf80c8359820e6e6bd000eb1ee0f3119c861bdeb344d2e0d6fdf6eb9f138c4f0cf7806be3098767d19bfa3f5430eac5129c841060b39f86593d6fc50ef893ecf94a4c821437183c85b1c29b68ba4ee0cd3971044561168ca6db87935bbcc7927fca43972ad5951dd2298790cfe1d7f075e3431b8257e4cf8b4239a8aecd070e1b543b51efe3589880005df2168d51a10b0488ffe177ff2c1f04356de394e50dbceb80a3a9193854cca6855dd88c0fd20ab68dadc4385ab163e8578d5cc7dabc6d563545327d33b39c488a8983db9edda51925b113b24478694b88035d1d76951dfc857de91a406297b5c6f06cfe87b774bda11870c4eea70e862552f7d645e61ac99fcb202c55b6a0b6c16776b3d4c179c747804d9f2d69b20480336d7469d2df0b864c9b95520808f13bf216265ffd709ea9db18365dafa7283cac3cb5b915ea69ae8c7fcc0fc301f79924b7ff24dd2677861e4e7baa5f47334c0369e38db9f5bee5b349ee5c68cec0b738858aff174b1436853c5b48344dcbc35def026c16c3806b66cbecb63e8a8c337bebc7abce1728cacee7672411fb33a36d93e43ee8ac16d466efcc0587f05fbf4b5bf51f43f9ab8b795d5dcfedddb7aebfda501c7a95ed1803bb7215c6c9305caebf280b1407b5349b4603ca060a36ecd04cfa92e95a2fdcafd871f31de8235f8b1f737ac8288e6d7e92e52d212390675a09b1bb99311a2ba5368668dd60599f918431339695ad95068dafc9fe30b0c85287d545dc665c6c0818f098bbfd2d03b5c949efbac3d1447d8f7f44f273fbc24e3d13335817a414ae441a7c6a1390d6f527c73f7bc58bf07bb2b52b923e076c50ea67c8532eb517491ea460f43e36ffa477004f726b67da7cd253ef7a9218406d847cc1031d96c11312442a17e4ea1c0d7123b081ffebfebf2f9c89fc6ae3d1e9666849db1989f4c4ea42b2b26a00b25b95df16bf83bf2b9696c29f0fe0c585f69789f1536f0b8f3bf7a1d343d516bd0b862e3397196e35d1c5d8755e8b641f54deed0fbdb7bc2882e624034d7be3701b0efbbbbf2a4ffaea64322b5e4fc3e1713221479976b73bf2372d0c6a8510e410c88cc077909766d3e96105bfccb1e13d33ca648711c32a572843ed87b7ec09babcde218f22a92985e0c96722137ad2f70576c0c7e2eb087f0d521a4dc395dbb73791e6e6b876e58211ed947e9308c3efa1469f453f76b1e357a9501864062eb9f2bae7bdb2914d362fef6ad4052cb6b3333664800578278f48b833b003d6a9cd6278c01f3ae9a012dc46d1f1f15285e2dc8c2dd7a6a664b5dcf4f50817d7a3e5cf062a87b283203019215d2a0a19777e271761ffe2265dab535adda82dd021474a699e8d18a86a591e0d828a3585ac92c0d827243bd490dca78fba1ad7779ca702442da706a78dde19b5bbe2445cadb4fcc8f7ab28e60d4510c80d7bb1ffc55e267696c2c6e44594e29c5c6fbb80631c01b721d6fbe24e4a8b55d37a170d2e546faa197b8e89ee8caee92e616f29f5c23d3e441a232387edf59e57d6b1cd478994fa21f7a3e87481d58b83de31fe35244ab6b6fbca71b1abb24fbada2eab636a6fac2daacc6f22c1e36d59eb3a203153eeeb6c6f19301098424d7272fe52e677ac40723bcdfd964119e18badcaf4d28d889dff6b9c0e5a84b6d9430557f63ba03f3caf874f4b70046decfffad1310ce50834a23c411d4854f61cad81a8e61042944dba9109c916b44171ca858fc6661915c55a41958f6e9b2c7f1c0fe560b8d112283a8823d29d758f35b472b18384d8e9f59ab8a946ad3906a30e6e99119fe2747151fac856ee5872f45d27054f25886550ba4548e3f58cec3e248f7f9d64a71beb0e6c5bf7b564f4ce673d019723a2045a7ba9c4e4f42d2103fd55496889e8ae8b043eb73b075ec4d7a1082e93ba98e45ed038a9ed20b478b48d00747997e39799ea2a87835090031caa8316b730a1126c8a004561e0ec3b348947761b9d36f057be5898c34b2c86b2ddc159fad14a20eeb0a52c19578d217678017321a09ddfede6825768cfb6f3e8fefe1169dd92fc2d67b6dd4639ea4ee448c65e54cec7e8d206a0f203c063c0ed5679b91aab2fac6b9e113589aeceb2474904e4bd19c85c0a10eb71d5e0badaaadf6d60f4e5adc4fb262084421a8d74a0ef1f6cc266cb3446c321eefc3fde4a86470e1fdbd387a2188f591373017b04ace670b473a7a80e89e1b0d72b5d643790658f6161af906a0521cfdef32a25ee4445c56ccb5017b7b18ce45fb4a6e6c1976097f9733f1358b037dfb5be8a242b70ef70ace212fce7b93ac635d6b866436179cbe9fbf7217395458099698c6c9a8e9baec340aaae0eda753b3ed288c1e6bde7326f2cbee40e82c7d3cc78b00ac21fe6b77134a3c3d6ea17c09dabf575a1a63c678398306f85fb2fb8546ff995697080e73615010a87c62dba2b111bf7884cdcdfc54c64957512d3b524dd657b97e259216e1912c33025188265b4a0efdf0ee1c0b539f8e57a5f6eb60da25d8091b00b056af175f58049b8d7e67e97eb15b6f4ab8d8235dfe1739e70b3d45bc495083af70397302303f0a34c4bbfcc17aa885f8facb55df52d617a902b2c97b8c8c987776078289ba4b7d3e41550bbc6a55e714c4ecb7447af68f735a78e71cc3cece9385907b5bb88d723c6749c7f964c7c6554cf3c7b4c31512427de74390f0faee32a64cd5b6e7f7bff655ddf328da5e4c1bfc34b041ed36a1ca5d1df3fd2c73c26fc3e7bab8d5f7eb8f4257265505be2a0cf76e6b7c4177abd5dce005f85c548a7d6351bd0c27d0bc0107cdb7465c21a6d1b5bc99cef1a8f9ca4dc46a03268d8459c64980d3b86a2e8353018cf7fc6bcf71a15933a698cd38b12fdfabf62370b0210de839529e2db14403f2a6c859da1e2bdacd31ffa51782d640eb1ad2eb93ab148c594bbc1f3d40ba359ae4e293d3dbe251653cbba842ef4c8644bfb39f988941ee981c64e8f0c50171652aa06b038dc471112c721966884ad114cfa4ff8cac629cca82bf1e184bef9ca09996d413915f7a3170c8339e2b3af3cb7c1e219996a33423d3b598155562cc26256cc85f13e7c6cb06f47553fa52418169fa788e3381aac55cd846d309a4f02f49b11c50d431fd1a41e9e8b6bf3080909b9583dace1c81634530161566fa453e675b5a6a3bb69fd95570160df64ed560664add055fb4ee0825a39cc94bebc950170c4d42bccbc58f56530102359232472219c01c8f091ec0af91eca7ad5196b7418cb5fad09e48358498690658d42435d588187dec1a86bc4abbbbbf7cf6fe6be9ff5d616a05b576ac2dda927e5b068fc365b45aa03276919d0121917de50550307943a580b64b1dd7d098bc339b77d588838b8d3c5814a3e92baed40e5a3df0a41d561e3d3153b0721e71d43bb1160772115c03e500ac77b595ad24d4714e3021b00f46c4f4a6c0ddd7237d9537e18be9ee55cac4ec87e0c0eec0da943bd9d03368a09da605c1aa07b18dd0fd7f43989c4fc18e72cb89aadb362e5eb4dfa708e92788a92df15979fc7d0ab86b721e07e4c20684b1b570e8f710b906d0a9cf665eafe222c6bbb424309b0092f44d64e65d2c88d196f4576eb3f6c7adc2fcbda74b2fafc7b40e2e22b90b2b828dcdd6d55c7348ea5aabae25ef97faa6d62e5fddc192e92826cee14be99be394d5bf16a8e64079446e6ce0163e37965793038f4c52f03e4980fd9b31eb2b90f8d77708c9edd0f909b7cb51d7552a9b2bccd597d9942a8fad2789830a3d6374a2e88283ff04c926abe9053cbffc7d064462dc183255ff2b294cf59d95034fb450070b7abbbaf277c129ca84a0e0d6449ffa207bf4bbe3976be735cad3b73fa65184fabea15c9969a9ba6507a0e537aee01149f1580e1341720d173026ede68a0218eeb3c7bd2742644b0565b6fcb6c527d49d774bcd1ff31e0a56b2901b075cccf3fca2ace648ee630bdc4e88a253b88aa324a08fb4cfd44d3ffc793770bbc8e92487f391b4d8afcf136e5bb7e2bc316f624aeed88c3e48a4bb7545c4332649d238e218c15cf6bdfe29c67c1581e29173aa6433e157d6086b002b0c755a270f99f7d73353d101cc155bcdc1a83102c0019cc02546fb9a9aa77663e01928126a8246e99579d2a626a39e777076622f6388f0e29a3e47d7a8ebccded27e3a0138a8b9b1749b83abd4cc8f7486d7ff69e3dbe4c47a23eeae71833770dbdec726b13afd5b88ad0372b4dcab5b04765aee807b298cf9fc35c1c4990efcd0d8ca6326d51876e31ec80c7bd805c1043efbed1a10c7b8b214f86f8a7c4b6b01afcc82d4e2911e75ca7d35472b92f57099fb8f03fbe2f6be254bb80ae9339c10cc9849ab59a4554a60ecc0d8c33821ac47b603bb678056334bcbba38c6fa98ae2ec23fc3c8aaa040963ab256f8e12b1d75e42df453b7f693f987435c5d4ba7d5742be2114e5accba4c72dff2d724a3d04af366d71b86569e2f9a90d88cc6d26e985304f0526b58ecac221faaadfa16221ca09c834cbd0cc504d89bd7bd0d3cdbbc3b58ac3eaa3127ac858da8f846da37ee9025fb837bd309291804d5c105a0e4101c33dc32eace99079a992dd38faaf3ff111c7d2019594a928b3fa3338f836f05ec45a551af451e8f0224d266beedec689282e790dbb11c07ea8a17bf8eccce65f1cbcb3bc409357d5155cafac85e7fbc6774de799d26152140028395e8bb6d4385ee81848f5a8601e6961b14efbc0973cd21debeac63cd9039ce00f71f4f82c5e0d7a9b055a20ca44d47fc84236148e8255e0c37228b41223b2c856eb94dc8630aafc7d20636825fb5a164b713fd7587ea85027be76e43f0c158d7adc76fd1e45083fecc5ce5d8d80efe55227bf0a1e99f75992102f923c1328bfdf5bd988e7e91e09501635091b390e790d5e37952442c1e6b83bdc68efe1f02ee583bc68dda560dff466c20ebc1c982421867e665ea831857de884ac7e1b255a8d23a7cf81b81d6abb84d5765191da8f893057b44c3b4552843011b70ce2f8c47155f76f2f498999c9d57d0d4bfdfd3412822eb34c6f7c5c18659aaba05b00edd24516c60ecaccef3794a162fe27a441931b929a01e2a8e15a92832898cdc8acd3821479a3a745b588ac7927d595032b4f4aa3d9de314b9b74efe1eb48680399d6eec9d40fd1bb7702c2f5c3ef55bebf20973d50f3721fa24bd9da1d0ec56353f8d945c1a8f3eb6b50faf9da0ae4300bd117515af85f1d3159d572fa6fb2c861f4bcd0738b7c0fe5fbd3061648aff3d7672c6c246a75b60e53d85ce6c0d85f2172aa48f978b49cbe4b6557310fc187e87ae728ba4896204dfe4e27d629c2f25fa1a494697ad626a4987f29b639af8994751d645fea1b7d68bc543048cd51209d04e9b0ae1000df728c9c522c6896924a484b032e86d5fbc0ebf6c22d38fb011dc5734066f69603caa876fbcfb1b5fa08b52fbd686ae5188bdcb9ade327bf3633c8e7de742e7b870f74949e20e4167f7bfd26167a110d7303c9d36191e421f2a3cbade3d32228b1bcc5d60ef13520002813f4d7b7275e8c5a697b20f68772c4e0791559e1830a60577b64ef34f2cda9b984e070fa48c5f7d60e1054ff0994521fb1ed024736b8c0996664dba93f0fde2d92ff952a2038dd6c32878444b6d83168e6d2ecf4d02bd2469f22747530df573d9de900455d9e4cbe36bc476160694b4a6c503899089143b708a253b4bbbef081c6fc265fd670ac813a329fb35bdf405b46900cfa86b2c59ab5ee527d6e5481a6347074887807d90ebee9aa0c19c78c6a57fb4a727e13db344eabca129a77d733b972d16029364615e4d23b294d3cda4554e3c692284d3e4fc01982e3ab79c6c003c4a30e72bc4b3aa8d86ec63f0810d4c9c1ca6ff61f3f8b66fcaa426baa772aa3a2be4bb2866d7e7dc8a571c38929a03f75903ddc775eff615c8dba2b777a3e7663c9bf3192c91f9711e735f3985891404d0fdace260b67b5eb01f3a3cd98d2ffa7fee0f7e6bca81522918c29866f6ae83ead6be3df07ff3903acd314c1d8a23d03f8ea3758b2b70dbe3c7f22d5a61ff83a4e83865612db17f282a62af6b6e6c25bb0b432c661030c41f84ce03e82a7628b16e4eebdcd4badfc28fd50efc4a880542560a590ba3aba92e80d062e675edcfefee39409a2bfb215cb9c835e1002e29cb52fda4481afd2888a26eef099974551ed2e71b537f2ac26d203e9f170a3fa6403b1a9502651c6252332a25e200d250b73ac27ed40885bee6c551027784f1b2e8074d50d4095b54306afe7d6d4f78f5492de480a4dec6df1e7d30b51e1ec69ced4d48604705763574709815d126c21b83795de2052bb01e5a07496c5d1aaf49b82b550be375d5fb7d1d6c7f87e4f56cfff96617b89515048d4364e13fa9335e8a89f29e10b3160db508a314bc20690676abbd316e2762c94dc7510494b268d553832af7d491d343502a1c5e38cf61841b999fa97b99154118f8df7c8cab5fff0391c324e0594f9e5104bf744d34e9c5ac964e36272caf9786f674146f476de94990989bead92fb5b4d53f5d239964d4bab2568e4d5eb344493abe77c33cab66b0ae0b27a4d25aed670750edbf5d8404e2b21bbbf3a740c234e37c2099fc311445ea3d50137317b51bd25096ef007bb932efcd1adceb1959b7d98a6b0f9768f22d6430035fb6f3c4294056b90217fce9a5412714bd443283d7b52d4db58b76728bbc28de80f3b67655d408dbedb2972ad6ac293889b170e0f4358941b08bdec99b5e2016d452c85a52aabc180001946cff205c2223c1d1e9655e78d1b5ecc0223d396bd3265a42daae67ced3a296e673e117d47f1e6d319d9cb9ef6931ac70219fe46dfc63073de55268eb0c5574caec74b47f2271e51fc0436f814fcc5687b1b4721cb74a006b40565d5bf38625b61d8322edc22ecf5a72e731b6455f9a096af7c877cdbd3b455d91571f65c5c93dddbfad596e1a2da151c5c0b24b0db3b20ec922fa4d5b403b221cb5871f0cdb1e88cfd7090adb7eff5f629a8887fe930acde0425c05b6612aad975840ad7b352f52a44bb8d487bc970b6ba52cf24bf45c85a4c93d1c57649a3c0b0dd256e585dae9c6e06b11ae5314f07d80bd97e445a5dd131d6ecc15259b34b3650b73990a757b3e51072431d463a02d46cea82353466cabe0229cefc73971bcd905faa8bcc1737bf3e52fb2bb1db2ebbdada7e0282f464feb63e4cb1bdd018b0a604b07b1d92682510ed4eb981d81b6dd46f42eaa8149f3cc75efc2ea835a0909fb81bed36facef03973891a1c9f69f54a5b81c53fd41d071cbe73efa919b58e78fc14240a9c7992881c8febc86a02bc173181c03e0115680cba4b1c6c9ad389eb21a7a4a48f422b35cf76b22724e8739504058a79a4781b432715cd155894a95a32e012de22679891f89ef1463a2aec73bbdd3a803918756af1d877cfdc54c93155e8409dc9f94824e66b2cc037440019fa113ad5c40cca058f7b82c9a725ee6c8d7a29bea70c817f7d1b77c574b4ab1c3df1bcd2e7b026b228fb770666aa5cb910bd4c2671aa1f9f69887f5c805699f0b1b1e3af335e4dc1393a073562acfa8c6468d475347b3d892b16ea20c84900b928ec662e3b2fab99b99ea9a60e157cd3aef3ce6098b3c0ebffc633ba0c1c296d2fb3a1ff02ba8f4789a468213da6fd986bdde56145ee6263eb076d675854723ca8de2bd1407c5fe4dba04d1ae8f0bb4326a20e3f44dbf0790adf488efa1781c34d7108a48699c92f117b18f7f2af09d86a1128afc8c952e3db38908b506de60b658ff3be76aac7ff38a90e47bea864abf739e4f5f19e43cacd102919a14d2054c5b31a2aa89d23d010ae59614a05ab4598ea048e1591bbdf341f5c6d07765e8bfe0e4d9a657abdfa98fed558faa1449cbf631cc5594b4ed225a46342c34cb679da135eb4d038137739d6f997c65e93a42d8694cfc376e6accebe600c85f22870793aefee33893a44d7937ad9dca18a23ca2d84f167a97465c72ee97c207574e7c775706dcd5266b0dd27d6995fbfff50b5fb3b878a263df35f478946ff5ac5133b7b5dbb8234d7f6e70eb85b54b26724cec119c5fb7667b6d5b667af9f68fc720771cfdd87c9c104935fa23c267042f88ebfe2c99a33a944e71d40dce5af9c08256a0a8a445d488be71d95b901f317dea6f885005227dadfbeb820bf2a19507008933407b35c7bb5429ae80087c668ea606c949528530e2907b939a2bd873d322af71c1219bb2ab24f09085e87846a80fbc6508904fe8082eb4a8a8018c9ef8f03b0f2e09a7f245e6a4634373265aa9cc047eebe5c555ed2f7a9d300157da58c407bd586379577d254f78730f3fcd07ae1b89d8e8c41cf074644a80690220ae906118a52d7ef3a94e2f7abdb0f2a75d62a6d7e1aaac3cf1388b1327712a674a5f84c638955a118749e1b0562f62975367f345e275163978d684911bd9e00740b36a447f70b082a034ce1a1b411a51cfd4b95cba898b754b3bded6d61538dd8fd39c8c950bfa206598ed5f980c22aebc57df84ffaf02e8c1fff401ad155954e52ccb0e8314e5acb5ecfff97d15291c4b7d0fb4a3bd209e0915b8a4d8488ba0f60a4a4e8f4a7608063159a16a75b45455bec0210c535bf13dae142124d3a548f4906ff290fccd59069405a30403f5b887ff88b0282984fcf9d0ce35859f9dc3b6e501e0b015ec49bbfbee6e4b44e232b5b3ee77b46ac56c2f25e578f2839ecfe73bff5f32be9f7abc7520e633553fca9e75c4d3bb08c7e8974e9ed158e94c61f7c85fe0b622b8ea8dc0621467fd3bd9d71074bd15488f49bedfafa1ad6977b930e7b22e5f93a21465623ccfb0fd885351b6c18967116a38764a19b23cab27332a68d2195b69c4dcd4bbfedf10531b5d2d7b7bbb484f303af87a18b81130aa950f752f9fd74764bd07cdb25b7b8aef473b66a9105cc9631f4ba47c428647b4e5619016aad52b7de303c66b6a66daf48978a76f53551ec327a6baf9adcbfb311a2ef62569f34a0f1f90fb415f3b235ece4fc14471fa31d8c7652db6030ddd65b16e28cc4f6520b61bcbbe25a375a3d2f44f932bb133106adb463000cba87dc26c3e89012638785873d78a6815c32476348d268fa0d020f753ae82c2583a4670bb9e88fa5ae8f9035bcea2659d97dd244a3089adee4c42f63fb62f513d20ebcaadc2d4a1cbd336561d26835b3e1fc038734d64d3a22712f5e717ced969e2d3705e03f6b5bda9d919ffb1b17c99c19a9a597a8fe838f6034e95c35bf4289335ba146b738797d9e6c0d52df9818ea3c0235a9e0a79c3ff1a703314f138faa36ebd1afbdc4dbc4931ba71220d73eae2dd17255c5810aa53d734d0ee136b2c8aeabe2a7d04ba830cc07b93667c14f32c8cdc4c7eff51ad4d97d1152b9eed305049f0851bbe8e362e26a3c490f0c3d90515d86e1d36e5c7dcc9fef7c6d58b7e953fd6401474d0b9dbeb6650cbad66bef71d46cbceb89a08b482a2a07bd6d1185bd59990abc98c50f9cc9341843caaaa64cb7f71eda0b1d1d5797e568e105d8457362580f78f9d5939d72236cbaa12ae2bb5e041dad5269d505ff04da5dc43aba80b3e1384edc4e841ad68bc7a4734603d687c88f298fe3fc4f771c12aef8de0362695b1152a214d11b3dba1ebd813aad7c24417ce7291ab94e42c8d50098a18229006430a3fefbd1f83744639d6b623dfff2223f2e8a837b098a5e095b866d1288d175a1a70d41f8fe39ef55b0ae1f90c8f4d7f7cb029a224d75226c9b91991226eb6395e1fe48a726390ace6f4a6c3b9ae8dbea592f18f00317f66f1f17d98aea8d6998dd88fab8630d16ce98db3e7033a39ff7b27489af29f5dd824646d9627b9e6de701138f86311745a6f5b8b3301614e15da28ba9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
