<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1e6d91009f4e9aab378593768ac4e5994ca8eab165585e04881c3b08812377bcb7194744b8d0d8fb331c9280c53d76c7d8f26d18d23f4842670e0af329d92e39c2e92d56ba4611e2c1dd8f748f31ff827598818ab9c67a50ab8167a4d04b4f2658a55599ae5374469bf9bfb874d37232e4b3ec42c4642527499426512749fbe0857d8c490e9d1fa7db7a8e99d032ff477b5d23bea83bf93db7b2457252ec5ed6a94d606c204105bc1edebfbd7ccea8ec2b2d6878ec62aa6863d45dd4a039bca6b871ee3b92eefe459bf7255e56b3370973267646880aef99db4d9e0fd619fa5d8ae4f41d782233785f57754219d264fca4f87345652ca1217c7049aaadacae253e72cec818703e71c60954dea982e6fb694612f48faeb0337a0d91d47b3c011ab55cce963f5cba058a878e598d298825d992b2b228a4393ea2b391ce4c0fd38ff6b391716c5bd486bc3becde126a339e6b702b19fd5ccd649511b884412e75a3ef210c8deae301bab3069055e9a66703b124df247179be5b0f8b644257605098a8519037134cf327cb155014db8cfbc8de6885697a1973887fea0b8c4d532aba57a41ea1be50019939d82a3206e8a8d403f0e80ab4a3f5b5c10f5ffeb558eac2c69c4e7f4ea554b818cde01940f7601e1e766944f105714f11e3cc0bd88552ccb5a7ad7e4874ee4546d1887394eab80b1197fd40b1cd79ff81700b98b96289b799aab63c1a65c7385788556ecc97667ada0524a9f734077dc08b3c03fcee18e9e4b37d1dd2b6b329b63277a578973af6a5a5671efd095a2de5351df473b7bced2be71396dbf322f9622abe84201b5963a57fadae32bdab49a703752705129960bf34a744d6bc1bfe6a3210e7b5297f44303c047f6b5400f5ffdc562404324ca9bfd2c16dfcf5a161ffd5ecb8ef597f99c262b42704ef44f5e8323e9d9d33afa4354fa9193f23b63a9d2a9c35ec323249cf5f983f3ebf28fffc1d8bca0022a9ecf90906ff855a2544f52e4d0b6d5b268adf7b29c3defbbd45687f05ee51f39c7af1aca43a826de2ce2aeebbd6f4d67d9c1482d756db619c5cc092523899b4e21e2e171b291f34a3894943d767563d8e717a1e783ad0e538b304e49b583f6e2f49d9d4e099125d56928b708e28039e40028827c81adb8d6cf17b6011a4fb3ec644d14711692ff6333415f79658ce831d706651a353760ff7353a81a113b0fa550334a8144e07a16329de1cfada921a1b573b5db6155ef66e210f5bd25b749d241992c20313ae271ff0849e66f99a7d35ece19f5a6827566995ee5370a176aa66db6f37761e1f1ed1c60cd36b5cbe780c48c9d99a2fbdb5a72f6dcf9331fb709fd3aefb3856c742c1c0d633c3532f89f1bba352b11f3704ab95d87000e1539d86b7341902d98a68b9c5bb524a59cbc5bc605eb12eedbf64b09f3c59e0d3aedc5a8f5c6aa3f9a6030f2486461f2e0bee02bbe4ec2c1c229acafa67fc18eb36c52826f7c7dd46d4ef62dd731c68342b11ded785348d49c5cb5d45c1786babb2e741aa444fa1b4d3e5aa2be9b0ac9266248d823b18b49ffdda12d0c67e246d18f4cfd4b8cc95dbd86b0c05ac52950568843c4292ad9e8d4b96177a7889d70d8f12258494f96284864eaf7e7427ca6a0883ada5b00e5f9eee7ab1e2b508348a96e1bbac80b2922f9026ef06ed8b73bc2f75b1c29beae662c0e7a394a02908ea205f09cbe02bb8522927e4b60f14d5c488279f834ad807238c493f65c1825e9973d2f3117a99a99165b4a0c8723ddab56b29097166d736b0f30c22195fdc350f2ccd92b585970e3c5cc5b4d088984f90515c3bb96c0bd71a51cf4108839a02ea921da05ca6a12593235a0df39dc24015ff41adbd9c7077d2a95788dfa7a04a67f4dbc169a52b060c2b0ab01085d9f96a6c412e6fadca11bfa2d80cf39fcdc978ecbc416e3e7bd8266f2bada324e14eca67f887db96b6aeef56da755080dee3cd350209e6bed7d9b8c01be4ae537713582af0cb07f42039565b7a08c117f0f999bb715550c90bf2dda766bdc44340e0db730c7bb07396dcb72f56d83d06c6e61046753817f5f1243f4b4981a5f468d1b0ee0ecb3d3ba51f51904d7b24c4d2a015f439403933a777ba193330c35ad86a1f13e40cf0554ab1101fa1ab45a46c9f4201c0c4a84d64782ba1f0e51d2f174f08e0ee12b142383acbd50bcb28edee78644dae2ea624bc32af44f567a22719fac044be0d16afe853c87a5c76cf7c2c15e918c2e02e44ccb623d1df72544b1b7de71fba1fc981ef1c8dc3120d1b4045bdb916286392e48fe7d9f31f6ac4f380aadb58431fb9db4468452fda1ae8dd205b4cc9da3a575093c9c8d4482a7812e8d4e169313e990bbe39004de40beaef3e401aab87397f678f512f344b963061517868c358e27e8e7ae7fbb44a0f76872c478e08b27e2d3d2d3d38c9ea00ff136f6d3d9eda683942ae98cf8d8ddb9e93f8a5c1d03178f03b417adb584e37b47a96fca5e38f5aa124d37850400ec0a8fe8775c2c02718a19a5e26f1b937c0cdbd0eb04a66427544329de2955105826536e95723409598df3740e38461b1964bddce353b75f07f658023b39850206f6bddeb4dc4656f7ffe3d4e05bf82862cc07a51932e6e2f50de8869937cab60e9ca0636bb590beae65f2e21aade947215701ea7775075cf138b511e699d9bee3998580ba39918f261cc57103cf0b9c534b1e6fe64c0fe1d3d02e537a74503ce3e63d3311a4b80d70fc43ce32a794cda73d44b83d6e059e111a6087e429487325e5eae7bb6b06220213dd1bff8eee33b639c82e7782e207dc261d64e20a0e0af1f2039dc565ea5a97f14bcc8fd837ec3bfb36d2532651119e7d4611d88c8178cd8f54a2eb29763b7f5ce772602b24e4a7aa5d04ca4fa53b820086093179bb9056a3b917d7636490bbeb8e42078b5019545a3c956626d7b70ef189f02990cb33eb23e27c11abdcde296df1fe7ad34459270f994546e2e723c5445142ad8afc19055a18eccf73ab7651c5dcb63e8cd37b973433e5bad04578d65e8d646e083aeeb155e658335fcee79c019dc1935847ab4134aeb910be564603507e578638b55658c534d3ea472e8fae43b11f2e58ee361c144e9485817d3e08675693e6b02a1b64f7c450ab47249bb8376000bfeecbbac82fc3974bc58f7d6c21180e37f43c587be208a2031be9b626a2edb564ed4e38016c67687b6b4861f00622bb0b4356390bbe03c11d45847022cf97a840698245e1675cf6abff9f1677e843a71725cfde9259f561e45d5a7dcff91bbc2565d18c6918759d8ca187d740188a8460344158bab3d8247b00489b8523e4c4cff1f38574e35b04677dc19b717a8f238092ffb945b6b314b1bb8d8f08e52eebdbbf5caa54063bab809e3014af70b9d6762a339d82080d57c70a16a22bee563f08a898a00e5a651fc1781f6b370548bbd6f00658dc2c35b4426b74dbbc8ba791c7bb4fe1cdc16ee8d8f35688324470f8c25b54b38985a1f871662599c79bfe1ca373fa2793930cefa8a30cfe2d33a7cb540d9d93ccd53435746e6e500543aba2dd0f82673920084df66a64c7bc1bfe03f90d2aff8b1e8fd1574be72afb334bd8244e879b6929f810f054a7e5935857dfddc62b833b1decfc11d2223ccd6418f8e392df6a6a06937735765e600fef5636c8f07d782d6aef0da55737ba55681bbf802e9005d1c07296b36980e1bc4c2c8d95e915b6eb53bcae7036bd0e820f3badcc23779e12225e31e262545b006c2e44455ef3f435f95c2dcf0af45c087d48f81bfb75f429ceb49683e83f4c4e5c5c13a64acadb74db388c4d845c6323e5cc582b9b6ec11252fa490c729ca752f99bab7c042427d69f84351b27545f1fb5e6edeff66c17f4e5e715c1972601eb7813eb3f65c8abb28831dce5f770b45517f2a720a21b12de29c6b6138c431be6a3b642e530b08bd68606631cf2fc290f632ad03d807ef7b78cb964ee67d7867d615636552d3621a82d96d3f36aed0357fc63fe0a7880c826cd733a08e53b966da4b1977a25c3edcf68dcf8e0b31ad5a1886785d40d5b2e408700170b96d17a949c662ac3677dc1571d56a5e1d0f12dc755f350bf8d89a4e9f56287066e1b3da4abf48d418d04ec8e65f18e0e9036d091532ae176668b6bf1325033e493738c3b8b89ea799fca2f960ba3a7c6fd0292cd4e713cb7f9abef646fb398ac3988e760f91943db22c83cf8890f23cf577867437a35e437a6b5a323b3f8a914c8614ebe04d85679491d6e10813503304fbc2111a45c8fbde07eb577438046c86cc497a2842026ec174c6aab03bcc895d4e9b4b3529ebe9616180c377c42c92b138bcad9cea503e41df22c363f3f40e18227afbdf9d7fbee7ca7bc40782162fd846c4e9f59b16c4250ad3ecb00a6c2195a58bc2210234812026bd7ebc23ecbdf5b666532d81fc4e1044e49556c4d60c0b9a7d598157335f17fcfd362ca8ef777ce07c9d22377eb8808036a925a7448e001562cbc48b80dd04f80076efcbb296c57c6ea6cfab987bdaf2ddff6511e82dbfbf9c8f586da4bd43ea87f84a64bd9c6ba88ce2f57925b41516c3873eadc2d68f72372d59d55aa37e18065ae1196733d01a77221c095c44962ad99d83f52366d81e5413c6a25098a18bfb2ff01c443531df33fd611a9d47f189f741efa3786c31e88ad091e61dbf2f16f9d1be23982d0a5d0dca85587d003de5f8a4940f71b54cb21a17854754908526328ffa4a3e68e95278fa0d731aec73184dcb7c06141cc6fe207d412bf9e7097271bd4b451cd9e625d3a018176db6bd74ed67c5f11b2604e944038d0be7befc450a45870f33fd9bad96fedea64a9d8556169a5fb29da936ac43df7a4dd16ddb4f5cda69678bf1dddc2df06b00e3ea55535c2fbde589aa1c463223159df9bcf5648ffd650cdbe120c19cc612b9cdc383f3c6c77819e41b07f2f38aded0b7a802eef1bfb1384d935a1c8fcfdfa267da2756de5435421a9e1d3e85e83fbf76a543e24722c0d99e676c68451c4a4a9458d1abb32398f3339e26ef087792a8496ee38bac9b632aedeca680b5b099b956472329ddcf4a513ab0744436099eb919dcef8d41f00d1d8ebb67058aecac57fbe9249e87d9fe22ca0c519509e5783683c12430a4ec38f8b97b04e17d865a66b3c1ed012386b41451a8ff5c0bf99f20bfcdc5a24153f87710cf9f459c3b32459deabfa41b9bffb3f58ad477d52159c5a6bf9ef2a878f2407663ad78245a989940eb20383751108649849d4c974422349d7655d926dcba4db0cc486be13fdc8b8546615427aff1132d503ffa746efea61caee463436068cc94d798b7807db0ee8f8060550f85dabec33dc16c0bf1ca59f99f860f2b75969b36597318b922a43a21acf5144a5d975fac18034ff772039e331cc19f86a5316c74568addaa94ea1aabaaa447e1c76a4d35fb5b4103136629385736cd94912e7273fb0d5d1e46b2c20ded08655d23665e364559c83024c6f3fb40071987e649e34d937cd4039c1132b754c304086300e2662d34af0e1c42659c35c3862a2cbc7b60c6cfdc4d9f8a7b9aaa326952690cd0d2312d93d00d922a41b5a7c0623d44314ff1ee1e7c8a54e46e2f37564a4a50bf98743c8526ea5fa73408d68fd3c4dbf3726fe987de2744e5fd7ef064ded67abc52b27dba646d3e4553ed128503caf6ed90318453e65045b80fd028deb3c7166683623e9386472e964d4513ef5c5d3ce64f8dccf98d3f42b891523a8ce93cd99b0c6a2231b928cdacd7ea37ecf59419463d33211f5f7d63e4ced05881cd2a284a13c83ebd78c7678b19509698ccbae73bd8613c9825485437a78747c9100f836db5caadaeda81a55e1bca167b398980c56267c92c55991c54e1d7ecee7ffe4fac936f9a783a52dd99ecb7821d95620e724fad6378e832dc5563b7b52c80a9b22067b11dad498913f46b4dd7205f1508c8e41765fb991c227f01b47b602772df6d2dacd17072fb014915871ba88b132c6986cc965207b3543b065003c1bfb0d6d947dd488fe0eca05e778ed6c49a53565e178736e3ccb1628ffd0787339d4a4e431c41b97c863e26c2ff90b3ee31c510360a48bde4c1937590c39833ec020c5b72868873d43d21a78f5155ae0161a297c8f7365371c6667f8c2eb3ff5e128e449e2161601c5ae7cf35fe4bb471a08862b4ffdcaad3d9d6dddd711b69d8aaf3cd11c2a75a2c4f13eb670c737df3a8eb4f05a870ac260fe80a17128b6803d62d4ae27fc5192bf07544b57ea083e561ea54d2db4ed0215301a7db1ebc2e1376a3d8f71e7380a7f07464e18aaae66ccf2c5f1d5902c355ed0f000df7165be317bc31a049e58632dcaefb7589e4edf93fe89ab343270f3021b4c7e4b5885b1bd28f3e0dadc7ecbfe28483f9d4e5004f9d08d3eae8029992c20276b65f1da62596314a0100506a2dcd027d4cb2fa0bc551c02ac741a2eb7b30251b270432205181eadcb1d2624701f98d47a391b08c2a56bfd7d9144c6738a9875f8fb18b5e49f89f462c816044bd1a3273268a4ea4fb93369a19b6bbab519207c6c8c2103e2469c803d4373da55bb24c706a5041314169b4411dc176e6fef8f0816e2f680e3a1ffe33b31a9de491fe0ee0cde92869d2b95515627c44f17853c0e1efa636082831fe3ad95812697092520803b84a7fe5d571881c8ed609d09b8e4718260c525decba891a3392fd3304228fd1c9c5c1e7368593943dd796ee31745e266ce3e62830efa31e2211fb32dd1c3e9fd637b7680300c784916ccb157b703ef762523517a929d761985e33be8c348607934c931309af8b86d514685c57654af7a92fc8e92d7b43594a60962244cf47a53f77933800667da706b9532a2e43f26b13e3f1af2cd2a983a2d45b941e8ec6cb738edcc14225dac24dd01e327899f8e80b3a550929d29fd7f83c58a4cca411d3f2ceda8763cb2d1316f4c6f7cdd8791ceadb1492fc66390ac4696bfd5c4bd6deec7d2d3885e3b05e69f25a591f2535de1b289099a7b601dd080e653a94766c07fbea2e15c8531406ca166aade5796ad7a03aca7b258464e5c7ee430c5f090d7391473363c8efc0f50c81ec29fbda91930953db62f1199b8abcdcc39b3f90bd3838500eba7a0110f33de7a027818ec13c3c5029039d3ead5eed2ea7390d48012a531e11594698e28fc684b3bf0e4909d1f7d9e19d7528d58948ceba8749ec00f2cd7a0d7001c2a9d7168c21f6fa59792aeaacbc0dfac00909378aeae52f52a8a36bace13f2fc4a5390fdb47486022019ee64d8dc187d45b6dddd9b170e65ea9385d471231d5e74c97373df954986f74c7aa3833358e4eb3084cb03341fd4c7cbd6e248631b072d9178a977b4a7a6d9afa7e7c02cf0b29cee51812360ee9377d3f83a7498e2f90157c142973da3d9058f207e2f0aa867ea97a395539b62e43a10b67a1981676f7041c47e5dcbe8d112b828bd4f8e325daaf70df5b390d85e095768acd77a096e98df813fa3a54e7a5b3f6ae0df327b3d587e210511a0b1ff40072b912324a6520f2af37014b5d27173ffd4c9b77f3c4fdbb8767e697d31c97db998778c86754c5480d460931388d892fef18d10438d7e12a2382dff48f589f2d551be018f0cef263d43c20cc78738ed5356e215b7ac7b4516549973090d2da4ddec6f3b4d4719671f4b17f977f538182993dce2c784f971a3e8b91284d0fccd24196575353aa524e94a2bfb6766889b6197ba62f596f44281417f75efa28379b9bdff4e0b661d78f03bcdeef6d61de23faf5b52b7658c9cc66396f88f468f815ff22edaa84197b6feb2602d162d9911aa877e62317757a4fa1621aeb43f498354c0fbb79f9c88b18b8de77396f43304567059a4fb3090e5d11da88123104f2926197f0d734cbcc6eff1de20763f8c3ac15d518cef8b4963be955e383474861574346637e49aa4818c963bdf0d6051881d8b31aa4fc1c8f25b1dc0cea6dcb42851a61df3db385a9c16c329f4cce6f69c7439de003edbfbe085705b5cb65f4bf3ec733ba737b35781289a8e0bea27e11660b9fa0820ca390514a05aa0a41e1a527ab038f41d9fbf9585e808de012fcc1214e3884d28181bb261050151ff45b559526661ade74dd3dd874976f652e0c4fcd274ea50939bbf79666fdf75323a48880b83af2003f06df6505e8da761e25746311c893eb73c522d532dde1e513b05a1bf9b94096f9fbfc4576300583a9f7eb6f9cf09871a05cec7160093ef72b7b2310524ab9921443ba810c241a1afc1ce1378e630ad6a9e433519d23627385bed1a701f1ba2d0c8c199bb4c67a794330b4a3700e95fa439dbddcf978c4ac94bb1d2e71323638d784c15db442ec1afcd2be20c30b68f660353343923d330abeabcec5525cef769ea1bcddf2b763a709e52f4ce32fb24ad93a31626a74229b3616a68ee9fb086f32308eb301011e017288412a070314a7e3dd1c64970405b52418f668067cfb9c9e343cacd01e88d77689dceb8605208bbc8e6b1e9f229898d4d0868f86b179eaff1478a6f51f84b6cc1fa41846793c18713a8143fbeeafc9950f9eb5f69a772ac61803e34beae495a346b2447e536ef438ea5b32d599340cc86e8774197d9543a6f980bfa644239312f597ce3cecc6a88dbfa475ff79284d846640c08ca7a362309ac3ef95d3a196c50e1abf866bde32f794fce80ba2c4b92d2ebc973ac3070df66937b2938fc498e033e6f1135ec94b4cb0b8c5901cad1d0918c005952ece4012016940d0705ae5e798474b25ed591c8fc70a2679079e716d026374baba9d44eef0e77dde47f11ab7cdb4c3f89292d2357091c4c54d8f98176f8c4acff1cf22282c1a2d52c9fc40918686098d9568c855832abe2254cb465de753c99b97e3af78ccc8412369811347fdcc7ae371992ae83d7cb4a4f1f7350b24cc6c47c1b24a7bb29e636d2bad813342ab50db733b729d7a45ade71fde00c9156eded965ea65a94c737dccd3bc06cab2a5bc7dc08a9c8837b82e31abc95574b4ffe9c607b1a1a31604a193f6cac6a29567e5b4de4ab4c369f9a0ba39cb0a02ced81e71bb1d254aeaa392a318e72996104206d54c830a1f3906c1e9c791fc24215514ee5d76dbf7c894001f9b42ef546efb0378886882a622426a8bd7ecdf5a3a445330367e957d6775173784cbf96ff2bc761a85ded10f3fb8e098a8513c11b4012fdc8e2387b00b096e682f8ce7a334be1c52212df6cab97aa6648716dabf9938785341e24f5c53cdc687bc80332c2050c437cd8aae6ae8841b2c1f15e5b6b794bfa75e9381de3169300e64e5b85487c49beb7c757e7582958b8f67ee3650c95f63189f5e04d66e366ba1adf0900490561399597b5b7ee30791060a14170b762f59aa094255d3fb9e53c070a01cc35f87f021762e4c44b3f0f6aded6763960b28185983e88e6a0abcd83e4e9e2d26a0f49280d34e35f6d6ba6df4650bfe8f5ed751d3778a003cfa67e382eb303a95c32f88aacc10a7e9cf0b9512852dd6f75e9aa1e63de5aecba2e74eedba0c923c96ad99a8972de0b486fc3236a3c19f5f0ab602fe56461e6b76a2b03e54eab535af88ca3eeed9d4fe55bceefc6b07023014a79d5a4bbd49f8ffaca0cbf6f499aecd196b36485df1997c0bfaf14c5a803d5d72fe20f07d4131d85e9761f3df9b65982f92062b378296d430633e3516a5e6c80594c26e0011b611b8bf874031df8ace78e09aab075ce55228bb16165b252575200db375ff8c07d78e0cb6c08015df740614efd87d626300ce5f1dd79ff12eaa63b352abf2cbcb1c64152a1f1cc746fcbed797244e4296cf300c1e50cb18c3b244b5ae2a9be353f790dc65c89f0c5a6e251593daa58ea2ad58085a55e168221826f4b231e40783cdc30d0ec99b179288b3a7fbb090bdc0fe5d4676920080fda0f385c83417f281e7131b7231bae5ceb1b2b84c3535672ad5c5de8d113c9e33fb20218287b5fa458d22b9c605c60a4f650ec8b2159c26ab4b44f9603ae661ba404729214ceec247e5bd36d734dd7a8603065d5c84af41fc99234982ecc7fdda7594789fea26cdc577dfb26849f8c41faab4ea7dfb97e07e7ed41bbb3bb26e49bf273050f5faa04ab2498a05a5daa686bb642e49a44160cbabe453fe17a029fe3e23989e47700171e886545f548a645dc8f3856c2d8431aba58786fa9231cc7b1021ca2e0dbff681f37d1ad7fc824b94ae0050a30f9cc7ddb56fb9fe411fe172b19eb6ff6b21436a119b16815bc6aae1a9d381a8d0cc757048b640c11022e5f656d91855c9ec74addd994c812e860056faf0c97dea68ed69f912e59bfd01a21081bf5ee00e764b93a4ebd98d6b98dadae878f469e8d50b9bc2438826828776f7fa4c6a0db4d5c1c9a0435aa68979f26affd8110adfd84578ed38fa542ad72b00eba4be0ea0bae6ba5f1581efd6cf6525f2bbd3573c548707edebd6feb1bc7799fc8baf934cdc57e25756120b907604ad861772a7c51e35c28108edec1430fe3d321770905848e8f19d0781702ebd8420199c54982c3243c54936d11693b64d5dc832df728896ad037803125f116033fb9b5cbd8969907a4465875e571f8dab51ca96baec69cdc60272c474bdc6a12c722cd1e1f2a27caf9c8c0781804711c84d29982c48050a142fa4874eb6c23b224c3923e52289aa3177f06d84c020f1b8085771298151a2070ee3b81f1bba6839302f8382ea210ac14af1e355b5c92f051ae50e9fc444d6550b30b9ec22fb98b55e11d02e7a346b381e30c48f988c1b4bd2e502a6aee4ebe1e2e6a56b2ac6b92de9cc3be18be3be631736d1893e17fc8155f7b9406c263093a70c2ebb338bc044ccff2586cef02e30caac11c3931a2474e99c3f81e6630015a2dc8028069d7d15f009f4dcd969a72d382d1f9d4b833eb0557e9764fc565b2b6de6679328370e96ed4d7da3988562370a0fb7cef048dfc38af9e3e7cd641734fd65faf22bed23c3971fcd33d95a27cd5184b524966fd34c7e4e94d7e82c6ec28b04ac91e94afa8beb2b166f8228a0d1ebe502935868b3fa1d21350014a9952e8897f4a21eae5ba53d80c8bd481e985ec7a2b9f0708441878c85459a2d4853eea4d6fbea1997888ca97d28f04cd10f78cfae7baa97f6935a2bbf1bea7cd42f7d15479b5f44334c0ea6d081d515c6a71bde354723665ebfb6bafb4ece743260190f563432cfcf230daf23dc792e4f36d913399f25cc2b7e801dfce6cc36e1a64e66b045b120cf41f2d523f3156d186f22aa2c974ba9751500e620988fa3c13a0d6a1ef37ab2c154ec3316e095fc71ea12e88dc5c3256e8938da9cdcfdf4be5e76c9c23ac6efc23cbfa95ca6e0d3b09a0cb39253eba26b8f42bd05a988bed5c3b71129a10e7cfdb961b8034700fe295d8f6e4420ad2e3825497d976ce703c9ac583123aeba7b057cd1f2c77e657249057691d67433616bfe865e885c9f49ba7c224b31185370dc63101e5e6edf90f070fb754e859bbf775372015986a9d3a3a7492c384b78fdeb3756dbf4c8fb562b52f9c1ef37f50ae46ef602f0cb3734235ee53dc8de46ae6f1ed531fed93dc2201220f8295ac286f92506c85771921eccdcea0707c6997a20d08b812311c5e4efeb02d2214865c07e51f429a04f91e8b084ad1f9bbf303bc75b6d9ed667afa2dd88c8cdb3cf1b9f921f9961b1ca47f41df9f7ff353929f5355e0d3bbbb5dd715a94a6e4b507b3b87a625c7277880872970a87e170dbfe0d064e71c7d5a6f4ea3ddccc2e6d452b68d4c1d6be341da562dbf8fa6e2dcee6a01507fc0d511e2e7ace55b82670856de2251c0073ba5fc607d6dfa49807a7222e8213ab0e3137c8503b51dfbb35249ee4c8588e9de3a9e9febe9d85419c16af0597d25aba81e6e3b95222f4b249e4cb25cb5b053c7ce3d462a840542fae960e2edad403f7e41b1557b48262f4e71b09d188583540d88448168ba26576c3f999473ac0e8bbaef3c62fceaaef8ed85f22f78b9336df17e0ff7eafb6aade7e9b93f06ed8f250de154d93ec7f9b44951b78b5a77e810115fb9e46ea90fc15863293fa3df1eadbbd2aa1d18b309e0393879672b03025d3dece26b0fcb7ba8e9dbc1465db517d49ff00ef18d4798d1a0e1585779aad9fc5c61786d252c654fb8df2c186f9e35ce64f394efd1e6bd88c240ee0851876cecf75d4d7965b94ff80c2d53b42ef9e1a59b03ff767f0db32f066d5fecb10417c9a74488a6c0f03d2b5a1395ac13426ae62c7d5cf3755e91bad7457f0b5846ec7a129f3420b84b8c3ae2ae1079d2ec54a2221dc062fc93b008a4604ccdc2d644d02b08529dae7abf4d12e646018c62eeff780a6693f1f263e8ba20257b01d162376f5c7bfc78ecd884dd7cb4dff15a45bf1cd6f8421a8bbd5674b5404e5ddf67de29b6c85157a3ee6e86dc2c982c94077138389f52cd284b2e6b16519d18f4d2a2f16ba49c415c8ddcb64e0d32a337d7d0477f3b17a3354951cb7082d41a53a6468586e2ee9f3620de7a57d790f725d1bceb9f44940f2ca77d9e9b49325ba1efd1a8ae234ca07f63c74e72e96df0c3f765707366f6559e3d7623120b4748a3637a3df638a5dc0f01a263f146e1a0254e41f1747c5ca71c23396609b1227cd2596a7a27d39c4da857a828bdf94ad169689f9327bf14279eb6970c6693e06db4a2b02a63bde80edca1e5367c86f621c96e64e6bffe0b2c32a2cdcd0d6fee8b83a5c2100a7689a21ba506b17a894b4614b741b3caf6b49f71f8042c9f2ae951cbe3b86f6c819b373868e0a85c03f40533828fc8b9ea3934078089d40d9c43dc3179e93746f438fd329fcb999feb1729e37d3fa2da36e0461a7f7355e2fffc4fa0fecb02dbd1a9534b8b8342a3cf5ab6373b07087a647689d717ddb50abad62ac21aa891e1434f317722122a92c82680907f0e362f086dc45fd82d2be842b1959525b39a1811cd0d7cfbdc5740a176140d42f2f92b732f156e045b25c78614afbb2812e0d59b1d8d2695f961ee4ac6e1a60df9ab31b10d8a33f50fcb68a27c95f2e9e9e98cd18edb152cc533d55d47ecc8ff9c159214989aa7c5968368ea2ed2b942a4653e1cdc33136374b756ef7ddb4446863eefd0d550f6da53ccacd4268cc1a9c9c3c38dac7d311613404f0acf1535419a2da8ba9b582077b224046928522e8fbec25d4dcea7ded1dcb278429e3fa254fb7e45d63e278f3191818ad17ae4732484bd93695dd2667e3b119d7139cac7b72b38cf9ea40e3235fce4d20fa748ff44cc27913a2704c438070777885f2556dc537589247369efd7cb9935b652b767b4c4718dd430b61e9dd99a628b485aac2ddd95739c3e163d751c9063c191fe6007520295eceecf2d83116baf057b9f820aec3d174b42cb0a46a25e5e750789e8a2b609be30c3bd5dc13259b881567558f6ca8cb031099c97449b3ef0043cbbd76bece8dbe275b9e3f7740a419d2134a197cef52a7aba09f99678e80b9288ca6d64d0822d63519a754d0c191a969938353f5269f0ea59896fbce0cf0ceb8b4c370899e194ab7339d11cd0c81db2460bcd8b8f5e9f8c9fe1f1c0daf59951ba8260bb824ed9d153300af46cb7380fb3858a76b48a290b83daf66333f136d8a777840c4ceb14e7d2eb8a040bac5c02368cea09d3c0218612e694b41aa681585e56095b4e0f55b316e8544b7a37c5bb8327b86a8370fa02d45662478465de74acf4c36b46079d2b1b3790bb911fc66c13b7335d106cdd47ec1da0d7fce13fe8dd82a4dd6e2e2cb5e0637c375d23032a0e9b6cff1c7f7d1acfc2310b9d11e772ca4a352bab52999405f3e533b7e6e09bd6247187dace90a3107380805aa573ebd79ecba5a7b99214907112ec69f5f403524b7fcb0e040df4efe6a817bf338fceab1208c1afb7cebeb61ca88d4f72e5fb5dc6d60876886dd999aebcc0036243f74913851fc713b5541cf7dd122c14084f4589a106781ec287a33a2943a7ba5b8dc4f8b31ea2c21a02dd925794da826081e5e04b777a634d00fa0c53857ef1ca86ea1340d12dc7a57efa856265adde73cc2fb0b89811f4aa6fbe8148aefb53dc583acd9b6e19a072f441f7fca91a3f3e6ff57e77e6d0c8764f48b134f4bb98acf8f247565b128e2ea3ff052e407fd6fc79c7ab67f03494579202b2c10a9f8206997c04dcdd905870796a8c97da2175ab5494e0f2324c97bddcc14e6652d04109a6ff135409223b9ce06b9f5d56b1d4cad51c5415cb993e855e657cb5d3bddd626067b519f1ec70fe61b0eb378cd56ed3f37a917befbbc518f37b38fa51f84d7da3a2a961f22f65e662b1ac7477038352f2cae77dd194ca19993598e691ffc237f0125c63da1b83417e2deb70234f8fbde036aec3152538c2f1ef421364bc64b0c1877d1048486fdb9e7e820c98b714dce134e2bfcd41628aef9ebaf4b608b14cf774362540a1b0304a31951e53fed3c612647116a5abe23bd8571dbf5128714364e195dbcc16b9c88c6d0fe91f78ba2d5cfa534e350e04d54386429851c3ca85962bc7724dbf5884ff92026f74e44cab8d45d16ae32d4f6e4b8a16840f49086e8cc4b1c748ec45b0dd024908cc3fcd39a9569f024ffb59cce8f1df7cff0f8df8792c34d8fec8ffaa81e4874c551da13c37b5268fc5c8e0edb56fa138e2151fef3fc46042b6f7d487ee079608d4cd0fc49c0e6e782ea56c21e901358b15e92bf1b140b3a992273fdea415e71c1f20ed81a559c86b5accd76b6c084bb21baab216e2d2c4004e382be7510be3c00e41eed11e49c2409991cdbce00fa4e3aea332ac2c0aa2b03c32ea546956e5d00ee77428b60efdb1f5f393f9f79aa10ef4424f8225e64df9e9f7f5cbd4039090e6a97b0b505d8db99c04b3e2579c3b1317d0e0fa999cf930310150bacc633b208ed9b217afbf7e8b50659f792583dbcdff1a008b4aeaa3e17b4bfca311094afa3dcfd5fa2739297382ccfae762988ec74ab8b6f96a7574e7a8da525f53f03a223ce48b33d31d09d3cf91130db5d69af1ca077e9b3aa27f5922e6cbd603d399ac60ab37722a9ffedb7ec3f8c9a53514fd6a4624ac44702ef2cf3eaeb82e486","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
