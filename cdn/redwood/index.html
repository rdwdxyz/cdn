<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d9fb3e06d5c49962c20ef97f78e80430b20325b462714319b10fd4f4756e79cc6e20f847c84c24537491921ce7393815ff4fc426374968abbaecfb16227e9a6ddcb427ac9ea4cbf7b1e353ddcc9f97eb9af8bc646f81b710bfd21bde7214597302d9191124bb0b16ba017ab945af3b608fb893c2893bc307cf3f0e38970f9bc808e4a6f9a738bcf89402f841f588887781767d099d3bfd5dd063bc9183e1982e1cfd8ca3558a6e3ff231ff943f043e8e2d6168d753c372d8ff52377804b7a1b2c4c2e312e7e449e90e7dbd2ddf088e25ce8bd01cc192ca4464575ac40d1185c4277d067f776433b9186496226744c154fae31c79e0b724286ea15e36e87b4e55ab42e2941c2b271fb4b88beeef4e898030e014c8c510efe766497c404844d3405fb9327383a0a65c6046d77351244f1555ed090671c0dc44226241f6c4998138f4bc353d249f4d61031fe2b7414acc5c39d9abd3efe27999ddc1931d704c6807f5ed242dc5c2993342ded020ec2a3f0104abd27aab54c343ea4daa5ced8e26b71ffc66bf9afd018961f211e717b9a7ec714d4223e737228d6561b95902720df588fbec41353e158b808bec6ff34fc2c2ae639aa3407a5e71b281f90b2ca8a306e2a09964af4887d88a7179429d397cce0dd496f0b8ca201007cd0afc8b8a58b29ccae0a24acaba74ee83dccd6d119f978ba7aa70366ea432f8eb606a437600b23ea132bb96789fde38caa467e09d2fd9e72b2408ed2a327d9cbb2fdd1d00811167c3eeb77fedecd1d1b6a39f4cf59671f84535b9d1cd5dfd73e43dd74ece651c59a493e14236be55f997fc7718ab4aa4374ef51b9c37b3eda7744acb6eb269f317e32ca0a77a6d25ccd51070123cb6d338bf67283a1b488bee1a3ab8c6b420e5128878ab670283f7b2b5fb62961bd17020c0f1c4c4e182c6b687b2036dec3e9727ff87c1caad4fa9f28190cb41dbf8bcd57566b7cbfd5840da1937b2ded737c1e0f8091e0e802e18b3ca729d4ef7dfd909073bd4c5dac455df006e066300cad13f769b17fe3adbf11a8677b45a01a12ac2851886dc09e139b818d999dcb1dccca65d46eb9f6c643bc87f80fc8fa8419893bf12a87ede8a89c0f393b65017899faa9b80a14fe9d1d2a8c3a0a3d46776a12e63bb5223f58962faa1a2e5e00a77a80954a225c36302f63c033b409c0c93db5f6eeb283339d07fa72733bcd3c104a5b3bd6c3e10b2f2703d8391397522d4ffd28d20b707f64933998268335c029fab4caa74c944e31853f81be2cf9fe65610046576e9372e96993f279685865d16b6346372f4f300c005d7c1316bf1323c2e09d78bf7da4185329168861081daed14cb5261f723568c7b238cfb853ef79aaeac2ee4263405aaf0f3316213557dec918551668c332cbf5ec35cd37c3c2637c766bacc01011dd6fd4e716a50d70e3cc457395017a56904c762db65941e1fa664b993d7b4158ab946876684e3c32c7597bb79ad7e3f71da6f296a2914731c213bcdf3e536a28f6c1e69b08a72071e3f3c19ab0696174920e500813aa7b9dcc6fbb2ed62c722aa6448da43885170b4a5a3b4ed6e1ee788439d7d3b7d8818782ed657cf9ba4c4eba9cae9d762e92fde0fc00084f32ac2bff3ba389487d64c76337a34b8606032e32fc45d2a21e6e574a9bf30e514c0fe832003fcd576bf8d40142c8579b249fc1e015fd2a2f3f3fd1f499ecc85236899a7af7d46eeef5db1e3974648cce5f79bb8996b47048578cf492d39000c1ca64ed87907f759de623357d4ea4c1e6cf70e6c0d49c3982f11a80dcf86bc1894ba9aa5b7ef3748b905bd15628e4a1e1889c4667fbaccf41aeab97b9a2589b3fa1225c0497d3691b61c747051c92d8abffbd56e9fd45ca3343e0b3e21042df7b9a87f7968c184597b9c90421e67cda5bd548725fc086521b8037083a9eda694c005d0ffd6a867b4be8051c8c7db47d8d2beca038b74aec6288230086c890ff0c090197dcb9f0cfdafe1f9e51dd4497a1f883a6bf323543c0771ced2922fd25737837d6b61f74a20dfee02f33fb072c5adc02a137686ac2296ec0a7e03b436ae5821380fc32a1b099764d3cffa6ac41eb5966db67b17a3ed7c135efa5becd4d37d612fee172bf587a6d4c6d5da14a2d08c2cb43c47f5a049788223e6d890759c04669642250f85620b0453ed68dcb59123151640cbb678b9a250627abb274f3ab53a3988d21bea5019b725a84e96bac38c406b010c97f4e267899b5e6ca13e3e393a0704e53694c58769068b5307a7d5deeead05af155525c344d4f923edfbeb17d7bbcfcc7887869f30c556e0ee37c2c4889049f171039eb3eba273793b0a9154d48a20a324cc17749ccb2c37529d7ceb3b5e0de56ef9a140371df5ea9a731504119798b72ce930bffaf632e1cb2413b75f1973eaa95ce6934aeeaf4211277068db24800dfbf6f548e8711436746f352f0b1852910441a0d406995c945d4ec023bfd0cd4bca7fc7a07774c65f48bc2efbcbf6a3c27ad92dcaa26e13713a3b8691481e4cc57522dca683adfdf46cb05f1c4e4945e49a4cad4d4a004925bdd159e679fd70dfba955a4ce95c023c862b4d65c3cc1e24a7c12b75e6347d24ce536f7cc84dd586f014103053b27d30b04d77ec12afebe4f5bdcca544b12298aa5fa4c04bff2a7db76873a60a2f544d76f4e25fc4cb7b36e2b3d51a126b9999466020e7edc3bec471647e0c5c55e3c2e15ab3d39124b8fbf223d5b2946c3c50a684c05fa576bb3e24d5d897440a346876fca38484fffecce972312ba0dffa0b63159175140015ff531484167ed6c2df21e8fd9bde63a71282a507aad02f3eb615148fa8c7654b612d36d588c32a4c5c321eb023294374e54fdbdbd42eaec067cb66a57eafd27c62726202f1840df6076bd400adaa6fa94384ca73d6d00e0812728d4f8e2318f4bcf31a44aceae00503994ee846d63ddc4f80dcbd8967d3c0043d8164391f2e8526526134f67ece6085322caed9cfd80dff495119a14212d4d2565fbe15b15831ba6732f34284f39b60cb2122b4d88d1b2969321c3f676de7d10f2277ce215ae4dea0a0141d09a1de5943858cfddebf0b3ad57e54694fd9172a6b7b79b0bbaddc3e85532bee854fe054441bc4b3ea89859cd33f428a3192399aa93aa5ce40393f60529663bf34e7392d6d6fb266ef13e8b8a90f9fa421a8b389b6c3185a3f42195708646244de3ff0d813b5a2b89975e427db8728e0f1cdddcc1754fa235cb2b0653067a9a32a0e59190d58be51a819bb2f06014722150679aba7585229fc114c9f77f635ca555acfdc52fb8e83276d782716a96375f65beeb56dface2743440a663df8667481433a67253087a856085a6b8fef631c40e9af3ff9ecc11acb388b681deab5fd9f6a5c1648d073b7a36910c0598a2096bcaca6a7087d6e42d93fc662e47366601a01a6b42156c950bc7546bb9df07ee208336931cae939390f45b7ce5ef1509331d07fe9585856ee78f01c0afe35041a6c6b579427f2a55563847573174a3e6df807cacda1ba7be008a815dc15bc623621ae07cd04e4798387417d8bb4a6ab3279402f535b408dec48dc0238170352a4e6a38e8d5af8b170ec7cea9268f67e630a64d349dd60a8c75f0d620882b8c4797e6b8452f4449cf60747d0e22959ebc4f9fa13a47e347ed3b5ed9ddbb56a3ef5eba64fb0832a4bf82ff5837426573290d20a2a8e41c3d4d93a55f0bfb8ab3518b7640507a89ab70b0adb4ed02ceeff17f8343d8dccb3abd21f59ef9a5f83a2f1d9f6bc3cba8f7dcbe9cb23e71ad8692c7002de83d13a6ed4e8f0371db4fe4d01e43b154cc0ff4d3c0dc45981220b88582ef6c9106ff023776e16678f75491dfd8090fce9294c8393c3fc6435c23abcc81792483a6673510805081c58fb5adf69b9c5fb4de2869f4a2d53a158ec60069d91d11d915b2bb526208f0428fb44ade15a0206e257f994d374314b6f407c86c786f7daa8cc9e39c7f9b85b4e11073d5f4b45ef959d2ca53278944769b4c46f3f9e130537c4ff9a5886ec24ec09a6efda591142ab2652a66cf8dbfa9d4657605dfc8f1e2a215c3f02c6f57160b34b977bdafc5e3927745dfbd2f089e9b0f79b0729b460ab1ef550039c5f749765658a8cfeeabdec289ece320af90379f2fb1123f4513b41996743872ee472909d1172040e5bb59238b55a05d7f68d28f7def08f8fd4667223bad34a719ffd81143b9644772f9fb96e075d6383c6264a110787a720334ec5df97380f277e201a9659b628a5d55fd1b3642d1871d0788816a8887cff7c9f4a8839a5a349833a22ad6a30bd00f5e7792774d4db5592faa0cf4bcba854ac1cd46828dc66990a58b4a70eea55b9e741b4116ab850dd8ef528ca27a07b2786ceb4e7dd025936880c45d72210fa24cce6c602785caa95911b360e77d12b1975535f309842865ca1d8b480fcce54bca39213266034b76d645a91c56caea2501e4de85df5ad27f26b08eea6dabaacbd8dab64a7a5903316f57efa35cd2b9fcfeae11634ec8934f3f7d5c3de600253d305bc1863905cf697de96452240e9a2476fb38d45c0ba0565843335a470eab34b21e0186ad4b76e47e384240592a47203d3693918d4970d574b5f8af23914997a0111edddf717ea8a55539b4af0abae51b3f74a500d2325467f5605b2d5c50b002272a1059f810b1f22cbe29f676fba7b0ee7df82d3e3ea46e94c6e8fb5fa706dad999a542eae4c3e7aa2a45f7ba0c68e5ada3a1fb3abd4e5a44ed694c677d361a35c71a251d255a9f1ca72b3f194d54b738f93bfe96ef31bb36bd03b346ae20b0ee6d7befd9a721a7014ee320d13af334290a3a395d8c62b82095a0a9fe87ae8e5d363c550f2b909f64bd023d9f75a4dd71c7cb36010431bcfaca1322f9e0b2124f1e86c5efc57377ff25591e347fe0775d0000bff3a8b180d4f4950a30247493fd56dae27e4ef01389dabca4a25c6266641f71a360f56985cb2785d657e8b6e7cb352e1773b757fb188f89e5cc82285645b7ec23d6ee9cb26460837f49f4c4a36363852c88f359f53cc86271755153360793eaad65048fa9a2788fa3ec99384172d348e7fe19a8ced3b677b4c10ffda4cf66fc02c345bf7407693576c277eafb2649246bb31a6bf91653899114d9ede37341d6f4a004a70c3a85877ad7a1797f60f4ef462c9fd8c4a0382551084354d72e2b065bfc75d32327c4d2107821bfeb77aa28e29e34847e68481c75b9987590fcc241696d06f92bdeca40c945eef3c9136b767fe2bb3cdc325624990d33ae72f440eb0d1cdd9ec7a84cd3f3185575bdee4cf1c5fb67b62bc6925233a7e3a596c260115b9566eb437942d19dce6287fb10d0436a0c671d2f544ff1a2eeb13bfe0ebe65288cbff88d2b37958d38e00bb93054c3fdf8dc753e892558b66b7cae62138144ff5ce41e8cf48c512b4a973f49e08b3e24655a19ba865b61ca86f8f9f151ea73c2c1fd802158dc941eace2dab8d70af0b0cecceff58ef446af0d122365443d6ee634c96d55537facbb5b33f96609fcf7fba30e30b9df8d78d86fa5c6bc5fe948a7db3262b9e99fabf1eb43adfbc0ef02c260e8bad6646e5a1be6411ad242d26dd62eb296b649d4f2d510d26cf787492659ebe262557439ce9bfed8c6f6f9ed0e78701cfab7c2c401b84820f6f3ec85a2d7d8f08980a1d7db7949d8540164282d009bb44306452e6f443dda6a14b7f6f87b8912948247284ef88bf4d99033ab24f7247ad4f0773ee922fdf96c6bab50a3b9aa438cabfe16d2f6f2624b6b9de4d6525024a864ac2ff68f07c42701eae1ff5185fd5a5ec3a7e3188afa989826a1f212fc3ff00928803fcdb6ff54857545767d4bea525e3ead488cbc842dade27588e4a2bc3f68cc33c1a9e2c744274e125b5a89f6139737e4cc442e6728dcd9075c0fc2214aed90ce68efd771e88a0381a047175265944d008d6dc3ad6e8fd05ac4012f0f558678486740e70577405372e1a392747e4ecc26e5d0a1146b193f6103dbfd98c58e743be13038560c0ea7e8a963ce713acf630ae8810a839b1e7fadef166196d209c27310500eb71000717b67507b998e2f24c469a3a1b3d1114aef5cdf0cfb99ba807f67ee6fcc6c43c3df5121768a97fe019239770b616378700d1d5590e3b7225884951167d1f28b9b9301f93b47300cae9394547f4518a5b8620b70bad45545a82c7a86a9a4d9198cda47c6f14022ec6c4211eabacb07f9edd486dfd6aa0a83f220a823547014968b4acdc833536ace0ea3d5e84fdb1c29013f3784152d6340305dc7ab14b673bc832413bc79e3d10a6344396559b5ada7c48a88e67d4e45e8690cdae7dddc6ca76d104dae2b6afcfd5244c3092bb73c988c15cb00f00da1658cd4cf18a0afde86a7bfc5c2b98203e2fd3ca3fc8f1baefd7698bcecd3777c2383731912450512dab628efc5d38a6621bdb8cd64761004bf4e5ee22e7fa05e3c2b8122a908619398c64097ba799ecc1dec8de6e3caebfefd20a96bbf3562fc43271b4ab5e38192b935845d4652f6924f62ea1d77df9e3374dc9a4cd75073b4c87b3084965454d8dfb966d9b341bf8cd6c1948076c6b08a101ada7109a82cf50b140be9d3cdbe6f9dd41a175715bee2853eb20057bca8efd4b25c6848e74b0969257445bc6dde5cb0d4ea831527bdce740c458495755326092c222bc7e0c6e118ca2eeb7d01daf7933783ef9152c0c0dce67aaf98d597512973ba4b9d3ed8c92c967fcda77c02888033b68f6e2a7d947ded07c0bd700750eadb4a1ae05b11c715e47c3cab17220b6054a59141ddd0178dd0c78948f561496996c9a824f8fe546d8a8a41044a537d114b81b856abb48cd203cc654896d3197354ffe6f0e90bae3fa4161a773428028ce6110d934460aacca1d7073c5f80e1f537000a1b6a609d2164ada60d9829f75e001a57d3aa2a4f3322793258ced22571a494b6a5c1c8e10e07bf6e561cfbb50dc204acee464f697c2a74296922ed96e39a74e306bc18351ff27b3cb56f3b344d663fc73d7cb914e766fbffc7808f393f3deedb68c77bbf67788f9dc4027242b6de650fd68d1ca4e3ca2e4d29cbe9cfb4d19014d72abdbb4da0b63c6140679382b6e781896dabfc56b563ed5e5c2ecf2b4d15ceb30432942e00c8e3566969f10cade650f98356088ab54df0c170f13f634918944e12af14a8cc906b88e56ef2253157b1cba5957c158bff204aa01698c3d2bdccef72dfc46f15f3d3b9312f6b044259f916bb213daf6e0c6029d8d6654345ad176f47fef5cdffed3d1ffb7d4b9250c96558098e61c4b0e3d319eb435f9075d7161932028ff9f165306d28eb850bb04713a1eafdee1eb97cf1380707f392abe47678357ff937ed7573a864b08dc1dea15083c31ffd7f43a1f1d2f6b437fd1050274844b02ea8c0190bce09132098015083e0c7978997c23a8f2e2033522baa413456f9e472ffef9cba42784f4657cc0f34d8e53569447f6c49299c91267d16a6f7333aa487df8653e5125d83a51cd102e222587802042246b3de2d610cd9a27a4b53a59943494339c5dada25075750d6973e624797fd88492ef6eccda2428897dba498ab97e486125634a25c1464e5e96056440b3fa0fe3437bd8e25685bb0e81f7b6a88424f8fddc949b56e5c6d47efd279caca5e7537f385cf577edc587ba240bfe9ec6b5cfcb5d9575333538f7569a709647030e063327b335834208868a5de000123f1137307482fc9b04a6d5450783ea49611d9f3376818f132c22f81b5f6abd87b8e140cbad9bda597d738d6271bcfdf309bfd3a5e3d77e8a1ad2b979db78bb0fee5275fe48772802b9ff20c6c9805f3363cd63ee447a9de6d1c7bf88d26db5893019aa1e1b7340b171291061c703bbf838d3748f647f725a0c8ce902c00c2b80607e2b232bcc21816d150586d4fee05041078af844467149ee757d9840f2d65fdd40b55647b040b386ff13e591c19abfacd40bed5aef70930031ac2f67fecf62684c537e3db4f286a2ab810a7613e08dacbd6d69e753dc6fb5c52e517389c076bbf641f7c4cc30f7823f662ea953c4811156e9925599275dc6a213d23030472d389fac668cc9431c0499d46f985f462a14537cd202a1a3ed0e05495a7b70a95765aca4ebd7a565d8cb0d0c311210bda78daf0c9cbafa85073b7290fbb44a2409c8573a31b99175cb1b4f3ef057f18be0a8b860ec65f40b1f76e67470186d848f4fe9750052e9ffffb56cb884af802c7224a4a5ad4623accd0867c9b5ffee86e72c1f4619e87bdeda67f90de705f5c28329534fb76e3f6e21efa112981191e4df890b2a37e899c80dea3daee4fced87b223fc72a1adfc2b4f4e1a097e1e3be9d93b7bed7e2d6ac0ed90d9efc62228084ce239db4271014e9fc97b7eaa0b829ae85a4f5e8289ab9bdcdd6104a0b4829db4a6f925e8ecb171b8e4f14fdcefb93c7cabd1f1046ff86dc45db0c0c34cf90d9001e3c4fb1ac4edd1cc12b5d9a323d94cbe6ce64c4ad836c510703b2d89d69e4ef21b158fc57de0012112818ba9585f2b0ad4706ba55f26c3f528be360fc5aab6c85175e543ac59b7382b3b68a7c68b050c3c5553cda4bc37d17f5d4af0c5cd1a634f2a89ea25cf93e7576240102916e58ac0fa4586a509c603fa08ec4b3534b3c9abab32adcdb802e568cf6fac5d00e8e646690c221996f6180b05b7e1b3ca72bb54ce0cac47d47d89ad6770a9bbb766b7be11922b6acc0a7fc247bcdd5ce44708f61ab4712b44f638a2e56f2fed8fe5cb8cb9aae40bb0bb43a4cf023a1dc02ddeb9c32f949b710e15ae9cbec62d3d7c90da1f5309d03aeb0361e464aa11bdcdda9279b956d8908121ce8d1ce8cc6131c1f3ad65daa1f8c3397ce6571cd5df0793095c41da3941efd5466b71c623e26eb7f40aa0beac85e1771c34da2b03f30bca5ad97d8364f6abab76419e190b5ce4e41b7968959e9f0695e802a77837b54ae519370246c814cbb79f14f42054136b44de7f8d678c363d477f43f946bad5bae1b971b9f21e7ceedf0c18ddb12938e4dfa0acb4d3486dc8294dbe2d3166994a9126ff4bf3a5950f6a2e3d3834a23f17f831096c7cd397d813bb327327fb2cf98928eedc12f93bf6cdaef7233fed882175c62889c2aa4a4633733edf252fc3ea10c9c923dbd55a423eca19110770b0669f8d74ace0fd2fe8ff80f3bb2a071ff3044bdde8bcfbbd3eaa9968f38edf7372269790cb97a2b782b308b186eb05df0f3183ff02b836feb001a740e8e723d1dcd758ff663781b226f2f21e7d3f9049dccbc75c606e480b4ae8b1d2649af67505382424fb955177bfcb6bbc1560cd55ad54148e5e06939758482d3aa19412c310860d013d190a44534af550c1fe15b3635a3c23ec8ada08d689dc12d0c53cea407d4a111d3ce624f94cd6c8a39508ac1d9fe413caeb27d3462926372a4bb79e74bafe2006b2433c0cd3d38e6d775fbb6b82accb227c7ca4d6404e2de6fe123f53149c4455032667edd99ad2f4907a9ea88d95deb14be91e29c278724b8d2b64a8fe019e01785ef7f614f81f02292f192b92c5e425489b6b1cb24f11355315130078a0c9f9bb1df50d558ea447eab9b60f77b870325b767b038eb7f3f6a2edd26a5ae5672ae5756941178b04bdf476d76c85de20dce7f585036cfdc2a2b752c6be0ad744fabbb0132dbbdbe85f79076d817c891e93c8e6802279c56e8e179b74039d480575abc42e46f2e9f2117997953649d52e4182e3779540899304791c27727c0a233328461f00e6d6514d29a1b81361ee8316e6438130af1b6a2fc6f968848d04e002f112aea11ed1447cd60e7b86aa1d199d0fd45fb4c3ed439dee176ddf308a08793c1e5cc8689cc52f29fc0fae9e7c6e7b4e8ecafdc4976a410ad0e72ac2d24f0e2ce84ed7b83d5288c3b89e3708c8e8555884ca8830d623b81f2df8a19a75c3e17dd2484a42189cc762b3d602a25d45386b07806556bf9c28234b2d22629b47540c81812f384ee527f8d36f4f89b417c30292976290c33ca39e7beb6b50a95e57e28b0d4b869de637b820a00b959b2c611ad0d2a6fe3f849cad7833b4030060220ae2bcb6a929d61a0cc3b49ea47c897a3197cacdeb79f2deb2feeadb5accacd691861498e5250ae44c2ccae6fa3622260a5fb6b28be757f72149e288bf782fa8676e6c1da54bd4897a9d854e81b331e94a6bba9943e2128fcdf8ee97bee592dfb7a1f49c26b32e24afdec9cc9836970efa8cb24301ff06d898561d704f252566ab631a7cd099342e7f0f2579e1593d809a6ddedfa947faa39612de8596b4b4d77d85ef4789f8003b352c6968ba8828c129cf468d19e44b980adfb093750c9d3e2f89933669659ae57b9380a48481ce5606374f015da772fe564b687d920d3c330b72689c76b3128b99f3617475fbf7bbc553412b2dcd17e134d399d64e0dc2dd48dffb1f2b0f9c0d585eb77ba3f504dd9a6034352b040200db110699d591d7885b2a73ab7eddc46db9cf344ebb134a7f5e5e831a3f2e000326cf1ab081c22ef8c0b127faa85dd45cb2fe35d1b8d3e7c51ea8fd2acd67c6b527a6b7a878605099e0ce81b157b80aafee7d1499102dd867e07c36e30205b2de200d25f01e70988c666484f6549cfcf8b81eb5e9486fd83491ee78136585875c8b7266b84d68c9eaf6a3bcbdf1dd0712f054d78083a8ff9daf0cad0c9eab5891f785335f9bf0df1f3ffa389c7d74cbaf74c2c68fa035f7aa7b66104614860ed0d0b661779bf1f45371dc77a452dddfc54626f714f72e0058121c1c73d787b16c37c2a77605ba17375573fb895d72711a924ae1523150611c1f34981a4744cf7655666b7b4b56be6f5728296c580c4863e7271ebc9c50b41cf87cf04b810991182459983d924c834f44d9b777569c1aa6f60fff107c661e3fe0972146f5b83ffc71fba94553604d1e15139fb558093ff0b2e12a62a844ddd5e82562234a2509f3e32af6b5b2c8f24959e8303b6a2ac47305895cadec27d5004b3c79a49a73c75020e5f04c38b50781f422c25d4eb65fc436fccf37dfd81b8fb8d608d8a9e34285a22569076675a026a2b6397dbfd3c408df8ef59737f1aaaacf22638e1be779957de0d590993ace4e36f25dabc5a45abef4476209ff92c354aa61bda7cf05e0d0257a5199bb107a92df21a39b66801c6ef4d465911f64f8a6e9b7298d1483426a2132dcf86b3004152d9a2cb3e33449b11013d50530cea41851f5674fd017e9ad52b03091cd038ed5474b43431a8fc88a7ad5f1ebad8389d6f190ee72e353affa76014fffd3b4d8b5af0cd7bab1365c4832c55d8cd45762e586b1f6993112e564900e67ef86a9b02dfb75c72c08b807be80b2611d714dc42d7f993886fd64382b37e8705fa6d0c76679ef7b81b2a93ad945ed0f90b55310f371cf4aa024da45b1d8c8f6c95f9b901e616b719641f3269aeb17255e69b52adaa94bc941fed6259220e09fc81e17cb3c7ea7d510f2b7fa1c398af882e26ab47aa6df1e87fc655f8c3fde68d4f3466f3d859b2c156b45eaf7d425e24803f9be0c72f2fd382c253c1bb79175d030300a420cddc851205d470ec61078f2d48d12c6e05044e847ac022f65c6acc4ae74ab71fc720899206a7e6bc9a81a58cfb7975f4fac777cd13acbd86ec048933bdede751273cfdefe63a04027ce43016721cbffa579096ecb54fd8fa2b62d58df649a7df636a74bb8e02744e64d9e20b394b257a16938e208dab9112449f54e99911cc883fa4d7a891c3d244eef08c5f6084b9d6b501211033d0450ad80ff5f3d39fa87f869b61a43593218bf4c12338f74093165b6995757c2afd9659b330d930a598d899904117514e039018b605c95b94d963f3ce2f97c35a821b161f72f9499adda8018fcea76a99219fc76e635136b38799f5219b640fec73a449c732e2617e5f3345778959e23211594646d5a8d9cb420aebcd640c0df1187ba029f37d48f2ced6f09269b10ff795186753b3aa447ee0fbbe74535b558ca58218c6687b5caf6a71b59142321f479504e91b73d88c53a8aebe0df487f59f0ca23f37666c9886e85dc0eec4208083eeca4fd05ebf66da5c526ae516e3cced509605f307529222f9ea2b88e5ebd078e8a683b4a3b30f573ceada1a5836097a36eccb149161c4e38f2f93a2454367a20fd1cf91609e746a0a6bbcfe40aa94e56051d43273a3707e5ce59f8072feec5898d94950997150635210c93f507167cd5dff291d87e5ccbade8ef5a1de47877c2f4485e5c8883e31b924f5584279565a7084c76e962714a961c53bff067f41196a8ececd7e6992a8c560422504d30d87aa364ac746169f5d6ab8b97a94e3e456db435c5fffc3eafec475ed0a608e6e83321988ea152bb43f4b442278650db0ff1fa13bfe9f2e9296177f2f995e9f629d6475b6e187e893401982adde7b12eeda43349aebe4c39c2e4d57f4d3f60ca2ebbb12400fec3f7aea03faec388e3f69af266d15a2e4b2513bb2cea5cda174ae205b3a82fed4aa6cc74cb567b65324ad0df57ef9bb57a0a683db853f596ba86dbd380186b6b7ae32f55aa10c048ed2cee95fec898a8d0e144af9198af6f7b8f4ee172d48cdf20917217bf0e00f8e62cfc39e87fda98e274c0726bdc3a896a0bce494de17487eb274c3cea3a830fb0109c3c13b595a6879163eaf42d2aa728bd2efc7dcb42e735edbe8744cdccafbb8bf728ce754bff989c1446a51320cddc9328ee0b340c94451bad4b137b6206e180d37ca859aa9dd756cea343630c213f50221be20ee8b988f186cbc511f21fa7fc6895fe719cba033437c03c94fcc910f99a26c605924dd369d0a798fe23f73c4105201844a301a2bd2fdced7486244d21e4b2cf7838bb96a206beea0e0002d8787f947e9cb0a04d8f3909efde49abfd9baf4ba4c11f222a46e73cf4f3efa7d4d2438afda8c78679cca0923b3ea82704603c6443c514ed6c1033d400b56b4fbb0cfcb673c15f796b6b8f80ee21e98ed3cd865e0826c539cfbc1a989b416c793d95eb0929238a6dc0e5abc4be41e504f446897891223666f40ade5be5bfbeae7524531e1e531832180371f6eb2f63fcdf99a443689eed51347fe389cfedf029485edcb67d129cb076683a48ea1feb50fb255152d28503b6d64c349c47a5b4e35df14fd1936c3f7afb1f5b6131ca7fa37b9c48d71c3ec22066834c8190a98a2e040766d8d0fe4638afdb8dc55d15cf9cbd8b5938b1898fb0f37a1b4663220375a7dfb22459026295edbfed51c64bb02e640dc0576c27f131cac3d358b9a67daa98cb201d49ccb6cd7d6adf5985739c9723bb8d9d48e5d937752646f936ca0bbfc5f5158b9f60c2f3c075a2e182c708145b338ebc3910046ab3e0cad435039c21623cf6bb8512949243b6548978bd993befa8e7298b58631afb7cab6c8aa9cc0476daaa231babffb69c6989f107b76e90a34fda5061fac5655dfda497ded545a71bc1614fdb00bfe756e6760df78ea60ec57c2f1df544a01189f3f6058a6e2a17ec22f9b9dd64e579c0023ea58bc6e7f6f41148a7e72ef7878bcc1e8cf866397d54609e25003c4f01af3d2d5c326c551a81f35467eab99daa7520772d5f4c0abf5160b0f980c21aa73e9840c3e86693e0fa0296f3782ec7864366f528b731e78fc4d524f690c74c5057b55cd32e16bbbee6e1eea7d67965166eff7ff05d1822a1e014aae5a5cb5124a776483d11a11714c72e786b7d820b32e5dd9e3705ec2d4cd60286724572c275dffd4c7f4ef2d61a212a2ddb27642d58a5ca386cfb7039fbbf6d738c5d55fe25b2144cdfe5f85cef4851f6efe37b1b1495340159da142f9855db930d71b8bce3107a9d4b3726ac32c95ee9292e7351a74c6fa7ee387a2e2216d9ada132f3a5d003353a63a676e78d0911e8bc05b5ba12cb7e97f854ffc4fafeaf1991505b8321fd55d688d2b62ae452a58132fa41014d50123b9b5adaeded3eb0413086c5b75ed1b0daf928f03cf4b385b3d78b847c8151059c18c1d5e232893bafd25cc19170c3febfb224a2720fbae17173dee191432528876ab42b0acf2583fb9ebf63a5d7f640d6f21ce5249243cbee76c1b5a057576a83159dec9cebc21adf81e0d6b1e3ae3b2723889ab15e2ba7333b5d1ce072276d23664b5607b3152f044d06ddfd7759d79eb6ae70cfc794003039ac1447fa96d92f1c555916a5992ae69dc7eb31b4ec56e98768a22b8b20cbf3306bd72cf72b963bdb9837743bafb88d79402b63438d7ea88bae44ec58e6f7d4198a2b3e47d2608bd1ca7827ce27af3597ad5673d28d52484b073d075d9e2a2a91fc74493d4d60d43f0b01dd594640fa9a356f16bbd3412216f753fead74182e69715f257dae6a987c5295bd07085b9556361511cb2581278b65e5805fc4c97d701345784635f23020bc9d54031c812d959b30e1f69672b3657f6fa81838369f4fe0fd900a7c701e9f8d2c41372d66f14fd7c7843dcbc24e86776110b1aa3e7480f516c04ab7f9f7ef09432777fd675ebe35bf1968407c80e692b67de2ecf742c4138f84c10893aef4d4fee373d470699c8097c2626c001ef4a104b7eeb8f3419c2d27282c1816d39e40a7e17c8d0ae91a80d977feae8e20d3f9aa1864273b89df636041672d7576cea900d34a7792ea97a0f06b352394274d59269c46bfeca4df9cb9065d27dbd22a580674bd7d2616c9786038d2809c794dd2cf6986caa4074c538edd18025e7e49a8453efdebd911e39745bfa7262f18de1c88e8f96d5fa0bcc1208f75d0dc67f7dcbf2c8bb54e9095235a4a7165aca85e50aa353d4254040d1d66feb6ac9a4c4724af4c274f31535e612bc51c2e0a1d7482affeec99358cecd8ea4da115d34d2be70801646dcfd570ba68a3fa059a3a298b94a5217f9f8d24068923ee43433438859fb120397633576fb64a265d641a0ac4ca19959ba9b55ee1cc7818ff9d69b91a3cbd58ff579cfd148a750abca77b9a83b77593329bfd085e733ff87500ca85222a8a6c52e7306a315e85199e49300a3cfefd3ab8bfeed543bee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
