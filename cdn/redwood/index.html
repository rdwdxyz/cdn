<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ddac629424506bb573df5ae6f4da4b7fa914f66697f1fca89653d87ef350a828ea392f6e7262bab629f226829f7924d41b833771b061f9efc3f264e3ce8ee177ccb3541641f2a5c56bf375d392a20bf19e04b5c2ee894616f0958371d33fd2e27ad0ace16d2e5b45a338a7877085770330e159befc17480a04aef729a78e2f7b36bf37b9de731554aa19d9641381e84e02db302babdcb8fcf3a29b0dafde081df4648f8c24edf6da12605af452417dba76d11eac46e99dce258bc6b5f5c7a88670e97d659132e682ea5e1df1fdff7956b8205d87e3ee2d2b5b05db6b6a35df5d45174a5833f09d14042530df3aac4aefe41b47c7842b433cccae01429633f97adaffb01c8489af7cc1d75d08fe0125c8808df97d73eb9bd691542dd4c2e67285edb99843cefefc4cd9a54d6a5197e22388208c1b5e480667aae057810343e90b4cbe5d71c4615de626854390b4603d00462236abe621423d682a1616575abeb38756e2c2a369dd02819602622ebf9fbd8d401a0344810b27b803942ea963657ab943668253c1144627394e9aec07495a6ab68b93a77269d21a0965f3dde1dfe7f2742af79e31526c18354e0dce99ab15c4bcbe35b50ec3bf4ca749f361be9468bb334b9c1d636a3bab0fd5dba5ec35daaf274097821c55481a0cdac550ce474e46671e60a63b5bca8017e9518087e25c6a9b9894398dab6368105f85147f21ca05055db48093273bea394aec653a0b09933b1bfc618831d11c5856411b876ebdd118ab440aebfd60ab37e1ab3bdd85a73e65c6d434f828d7a35bc7335985286067ae6927ba314c05d7430e07ac241e219bda2f082571f62f2c0d0ede30e8e1ec115d23a42c56cc0161fe96e8e7bb43fc151c9a9009d424c38c89fcc4f0213df359a1a1c8a7a3f5cd6997127bf474540d0bedc8ce6a4617a6d4143cec7d096eec64455697842179f86603d5bcf7d7a1f805d04941a8a23f5af781caeb7f8092d4fba506f6b065cb348f2acf6b101030bf77c9d10cc134c8aae9ad35b9bb4dbb9be38179e3d09a57d15a96d8e594c3821664c8dbbd71416f60240f0f976fd7a8982e39dbb98e5f5b7174408577f2ad0754843fd9dc7044b52bc9c60fc9956f3933586dec77e056374d6207f1ced24206f646672dcd9406bd43bb328232a7e7daf66fbafc6223e14dfae6e7bc6d9d0e1b31ee9b340ba9cacf8156a03298c2d247feba649bbbc8bd11e05ef4f08baaf6d56807b32dc518269feb419cfbc7cf88486127c0c1eb1ce1f99160e76ae51a242348020c4b2824521e6250cd1d337a5740340f69e98ca2860a2db729765df7d90c4ffc81a2e5793e854ddfca72dae5ed26cbcd99eaa1dc1b3c1e358a8e039bbc30e2c49bfa4dd6012e604debee226349836ed67ca5a4e89f7ef6086ab0d4d238d118b12f5ba6382679211755db63d8ab0fe5833614ca4cce67df1548a23df72a45b7e411c9cf74aa7dd3a0fc36ebc86b6c7a8c943b2bea7d4606591d35e88e989885165005b215035c3cb6190e5eaa7359a570d21658f61c147c29726f6e4a93cba52c548592246528629b35341a9c3269d23f73e1d1ee8b85027945e87d42bb32ff57604762168e56ac8400dec906cf7296f775cab6666b463a2349ac14cf274c60152608ca93824b96ad3025e7ba582c3878c4a681122d86b3d507eaa9938a221202de5d9f5ff3dff305eadc1c851874971e7946b95bfac4ce5d60b38d25890e9511fd0559f6ba5a5f297376f3b95e58aba46519bc423a923abb6524087f50f9468d57b968d998939a0c17d3f4154626320e98ecb8664c8a2526ea9508b7f69d64071ba55536cf23c58315be33f0990296a29c8cc8c5021744b1417c72beb39aa0e1f994423cf0aedadf84eb34838b3598472e20d53883f4c20bbef6a9e6ee6c3816712df3940cc63dd6546f96e02c3b36d7fde1d64a36f2bb01db3def3be6674c17c47a4016e351c88b67e147d4e6c648afe2ee5363ca18a0bfe3c4133c2f18adbfc7178982bd7421ccf7cadfb9d701e6e719cd66855dab3f9cee07836d240d23ad47e0b41ca1d047fec834d9493fca5f5b147b7aa55c6f3c86736d46c54439b7b58dd8ce772ec17a394cec57644eba403f8a79848b5a4d02df30ccd7c487f2a896b6c3ed3bcfd32f0e6fbe049dab8ae75c01238baffab80e8c918de21a31f07a6896443aabe80bd2139cb5d2efe480d3411bcbd6e999a32ee9714fa5d3914e0e7c2be732ae804045628bd0ad09e0ee4168f9f42616e6cb7489a5cb0a2bd0914c8f40f11045fdb99739be47af9949b9dc8ff11ebe4dbe5f0e618a503014ab41ce30986e5c5f80ba8045087a249222ffb405639e2350a8a07bebaa316fd58ec84bb6e4525c3c7467023ebb44125e7845711c9991b92dfe2b0a50076f78f40090ccceb9e386bf7e077e1ec883613b6b156056c1eb2fb8bdf70fa85dcc0fbe5a40b2beb69cb604fd77d8fa8671c9a56a982e4d3997bca4c6c07d9428a7a0cf15e554f6d221f67db0296b9f4be0386beefce73d96aa82ac55fe535c6e1e80de58eeb5d923b6e417e74c675835112458bf65b99f6c4a962c438e3d087d61ee75f9336a1c3b5acf22d40ed706d5e541ca9f5f5c7d016592b8eb328e962848c83518781dc686776c4afca1514d821fe58a8650ce371ca6bbb34a7f2bad3084de287e032eb64adce7d4f025b325df09bc27af1eed1fe1dffd80c3ef0222727bf644a2469a2e061ee57ce20d8d87cb4ef17245cff218735f9e5dcabe6e66e05f9d3715fccdfaf8f8a4b75200b93fda972761b1de53a69901d5cc0f8aff0a52dc9661a92219d052ccc3ee762aa8930807746b6f68150f980ffb1c4f646b991a2c7206d7ee317453047b22c37649fe1a749a54f09cb733e9dea63ffbe9aee8a4ce5ceb8e89d1e8bffcf77e6a3ce081986ecfdce2777b7115feea4ddd46caa1909c2a76e26688c0d30c657662d3330961eb86dba2a9ec6361a5703ab3d27edf8fe7d3c81ab9e6321b222fc2663a0e4099d529264546361b701b95a52d6fcac117394db6aa63e55f5f3b8f01493abe199fc3bf745e4b1a1159279b9f174d7e6e45eb7631fbce46f14cba9654bb2c886b7cd20d3e84c699e98f5458c3f2522d079dca0d760de8a4b490b2e9dad1a6217e82c660980de24f67c76af509c012c37edda600a000cc5841640058148df8594575a684963725c3d0e9c9d960025ed6d7a51c203aff597d8158b70f3347438f298bc4a4d1bbe642bfc89a71451736af82b2b8c6113e252eb698650e48f85e4c4f4fffc5f33859dfe6b6af86f1a756903d749bc4d92d4a96e7799368f39d54ef1d4b395810879ea1cfbae75fe223847abac7825651559e2a0141983f6fce1c1ae1cc88961a4c4065508bf9527f5de6970e222b95e940a91fc37363b18659ec3f84903973ff3d1345b958645329a0ed06528b40515d167d6974e8404e03b607b6bebc6ae9bcf38cd6ac1370e4993685eca5c68ea58a0745f6b7bc9cde47dfdaa25a5277f33f15ddd55e173f3b19b6d370f77b1c41ed9aae026b8f23c91619d232f5d89c291b530a9f78c3d2f9b8aebc937d2fb005f616c4ec8350445120df67a888f85123a8d6f61d88da32795c7aa896ef57a1c57ec311b0993e8ffa614a744498dd2b66aab84f8b5713fe7a45b29df8170331d02158c7bc956c41f812b66e8ed515c97f2a7a4026b94f3a291428239c53d2baffeff2609c5c49204adecacab1a76e5d2ceeefe82a9e79bc4c5bfdc6e4eae96f2c22c8e1ceb6af800459abd2c3f2fe69b7da1c3459e09e5636958e899c05daa9f3748a878f65603c9e30a89f29511e41811131a614756f268f7f857fb3e8fc8f612ec4c24fef0a97c747b67619c32ea2f98cefa544b65d92fe18db9cc445c5e9f3f745399f74272292be07d992800d6b22295a0c7c65c5215680899964ba4983d26f7f14f696474adbae7df55eeb98642cdbdff2d0ef26696674e2b3a161b58902e43803c622d51e38938d218d06da99e72751e565881a2ff86642c88c39615d3f338f7bc6b98e32163cc8abe1b5d707364ea2ff3ce8230f73146b745bb326a9e24dd693f418ece9d8dfb58f1bca0bf6f28772cee921caa2aa5e4b8bed8fc1d3ce33340f7084871a79ccd6b7fef00e96a4aa6c87c01edaab15d6c2b62f1894aa3e6a6d41f3f162a88f6edf45355704003ade1b883ea26132bfba4c06d6a7884cae0a90b804b127f283d259333c8d3f4ae7eff77b3116f8f222bac957a5224bc6814ffcc8a771a38b2cbe4b3eda4a6fcddd69bcd61bf95fbad4ca5355690e4ba6359bf2c51e9904190f58a54d85e2641fc56c7fc250adffb2d05c7009b9128eea53bae8c2cd63f7f0b3899dc6b947c61466f902157d0a71222b44da15842f0da8b724d5773605f5909ed8591b7d7835099767893a39266666fb665011d5507dc3bb56f7c9e0472b909c0530529c326b6ea50b390d9694af02e98511d7b2754874e1484389a2939a2a81e002237234b6e310bf9b5e6d2f6aa1fd9a6d6105d3f6c5dd0b5456ee27e28140fb6c7364901095eeb4854f2b855514f4b9dca621fa4141f03c21061ca03ad9c406d81dfee3731adeb472d184b853edfd18b1c9275aeaf84c1221710306c6b32a43428b91c833ff94d91351ca5589dd65ae86ade8acb21b035d0d6e7473f26f5fdb98a77da2740d06eb669a926321c4683fe0e2e2ebd2bec8fffd36e21385ec35ad93dfbdf3cd781193d15bb08cfb7e70038794ed57475c8e1aafd0b52d1fef3b476f18e6e5309320ec4d627eccce96d1b677da49b5904cb4a7d7befa481d5b135fd3bd106836d824273c219a90f485de71f38cf428e06166f449989d9009b305a5cf5a7881a962991cdc6eb57e9c580c95c61b80c66cea440778f4992fa14e2f70bfce0566cb45b998ed387341d7b3c2c475b27afd7beab22410d6c3e8a81af6b82a105930dd7e510dba3c16acf319175142e9393a7a8d362e9912e33398fa4dd613ef43a0b6cb762fc63b3d0270671e8a83cbf71ec1ea1a9cc4b5978d00ad025477118490e2204337eb8489a9bac8c96a6006c068e1cf69be374c3050cab79763b165bd9b2f720e03e76d12b1f79e902cceb4e91149c76c9a521886be1a9ecfc54462d5939ef927f158e8780592656f1dccaf8e975a9010138bbbc3c4c4c2e9640b9955889a3b9450d0c37bb35532d0e593203e614a6877b8c55201363986636c21a5a5b061dd58cd3160f0ba46a10820f3844e688b80855fa2db53214a214862044352824a456e98abbc333d002873daf42f61433c9dd37c90f2e26b2009b0f0d7c22f466dba086df38d329b0cd938f1d8255da04f707c7dfc84803c951e3f024d985491a00840c689f8278d9c7fd4fe4d20a1bcc906fcaeeff672f8db9e26106f5caf8b5a9c2f5b515b79bf96142c8e332c7f38e1ef5b399e8fff5bbfec72ad6cbdb15750f17a6be564bb95fa6b782f38756e1e52f48be4059de25185d9ed3a293319cf355f4de3cdeefe441b15f2274504456df3b11038a3fa19e966e0e555d940170b29313cc30ae78ab2f8c83ef93ddabcaf8c79b850cfcb8995a4411021fded9afad3d1bd34bbe6b9f293f67786a50af9996fce7376a60ef0ae3ac63299f0b8d3bf5b9d0ade755366c69d9b8da155ed485acf671a854ba2c73a0579a8ea122388d939cd370137d6c6f173c08eb47460d9d3eb0e664fa88a7fdd6a712d3e716f3e9de7f5e2330599af294d3e454014903b808b00228d15834e579a65b4ddb44a50f71ce7b168578148da832d7d6e97c5de2bc4992b59042a7e6ae06ebc5aec2319107a80855363ba826a7e2cd9dbc7d7ba9ec75830ab1d8b8a622d31e9e72397348f7c912df243a5f554314db347ed5ae8da733a0763ddb1abc519ed27f35c00bc3ceb91aa6c13d987c37ba2f944b4202fe7d4badd2dc58d5382a0189f8f5293b0d2c686f3eaed533fdc360a50932270cfa3169d442feed11a76d2e4dd2386fb655fd6e04e5e1e02a893e34bebd38887d2cef916fdff4c09fabe60a18edb5682c9e5c3dd547c727da997d9af901645f14c3dea1ff439f238d33ebc120af17d336be53db215ad3e96dfe01b6aa8d920ced269073829663a2fb37b8933ef0acb7f043c6436364a00ac14c8b414c239500092b16d425d45d11ced7dac9f0616e71d6317988cf0183660e98e0300df2da7fe26ab1fceca35bd00e54e3bfb8b08a055d88a7b38b13c79751545770f8622fb0adf29501a426405c3ea2ca789aeb6b7df1e5effbcae26ce019de3758a88c7f1a888b8fd1c6a095c4f4a009d89ad60719f7dc5bdc5b93aea7eacf17632abc685c8234a6e6887c511d8d9aba7aceeb000c0b17bf43c09a2d6b0cd803cfed3b7b6e85e310da37539eacb9be3ebdb58d85413f9bbc2870b019bbaf603034a5af013cad3c88ee638cf8299aba1897f3efcd70a9e3a3df0600b2bd0d43a1865caca2d26faaaec466dfdc4613347dc9d6ee2df3a98e0dd489c0d5ab04eef0651fc1014c8be36c615fe6dbfc742fcdda4873b3a77448ed003cae49da116a4ecfa343ec2da282549879b695f971202d83fe0be2f4635bc2e7b8325e8204509addaf3720f6e1dd89663c01032e6fbf10f8d765895dc249b82bf655fa796a941609aaed65949c15290b36581dd10164ed19bb37f9a6a2acb47db0cf86826e122c57551a56a55a9521994f19425e6c5396b06d3fe3e7ed80ae7a549c11ace9745f23181bf9c72fe42101b5448e6eb52c268f4b836cc4042cf89ea8ee0d67f20e18a31280599d51b569f35e2e6e8dd7fae9d340049f27c6e01cb33258e7b3fe2da21f5c57ec5d9d32efdf249ac25212b6d72f804df11aec081111c7992f9a96a089edd8627d560faf12ba2b8f08f7be4302ac0985534b5e8c9dc054615b1b2df6737ffdcbdc63f2f0f233054be1f6a5e55ee646a38b85e2c866063a7776b8b01574c49baa5f288dd35c1bf9b1b0d43fbd7877dc8291906c060804fa92e049db09c9d38dd8f78d6e7023e7b87aeb1fd78914604e198b768c7d0368d54a0146492962b6f0c641b6c257e846811d32b59d608aa90d44ee54c685b6e63875c4bc0a64ee79ed1a0d2470651c1fd189aa5d07427d0725a4a663fc93a3b62e0bc2c54a054b08902fc328c557bbc9501cea55ea85303c43d0f3a1005d160d0b3053523b29a04a2aba6360e1c0381b378b6b5c4546d3644396bb4364c33644644bb50682ec29a45bcf0ec427ddfad97f2dc5324fbcf7399ffa40639e0a04b1542277b6506875891c365337c9bd82cbaa092cbf078f332653066ec3a2a3217ef484d886030b15874c57fa9247f994a4504942d31a95ddd526cc007f7d5611f1c7ab0d83c5c313d36a01cb196d9d811b7f7edb9cdd4c57e65444d9b2ef27f18dc5ced5bab0284db00daa83b78ee0aa67411d45a0c4efeef68091c3e2ef720999c0749a02200c98c8c13535c6af0c3edf906b88146e1d6329bfc111d67d48e121fbab9ea9a05b54aa8d5280a524896b45976295da7c9131bed00b714ec5670601820464555a7a68745a05a751ab09505baa67ef561a31622180731d7af0ad270a60cf237f692c015368e710663c10108319a01f7eb285b93299503cd9b3a7baa5ad46320da1ab2cd7df4e15bb5b7e6ebeca3eadfc706878b3c9b1b08052d949dcd12a45ec4ad7dc3aaa91fb3a66421daa080f82866259c686f882870639088d809ec00fb34e087742dbeaf59a8963e287439055131e7208b71add67d6d32cf686a1534a1d8f424831b9756d0b968c4da0b03e5391243bde373f3ae744108cb25446f44df9d4c947de1d74b9c7b719f1963fa1ad36cd12c3197155dc7ac22b2da80e6549079d79bcfee39b4f35e12974508339e0a0643de33c27c6d9f3f13417975cde8ae01d30978e4473bcbd72f091615fdd64e03f1a73eba638a5383ca985dfd1af43329d22d0a9499dfbcd372e446db004b7f0bcdfe0ea73145d4f4824bcd550cff5785304f30d5365c9f0c7c3d8348ba0cfffaacce7be73dad209e301227dca133c4f9e07d17c64bbeb71db690efeb4478859d0d288d668eb8d7bec0f1d8a956788f41ca94bfce0d00243814103d5e28accdd002fba9403ed95f1d5575ced32278e6e38e2f46a711b61d75bf16b41fa87329a884e53abcab918c2d54346338aad6f8caa1d1b10c50945a0bec981b449862c9ba8a10a0a70c961306abc8cb5e51d4c77102d3f0338846372dd5c1c8f12daac13841ebf1fa2158fdc3f9de8a763145e1c570881c0d5fba40ddcb94362a9722b24df38d588082792f02d9c13f1e77fe48652f83efbff7d3cd8dba859412b28e7a0c581582aca1f5ae62d235acc31719d2e40ff17a26edcdcc245f122a6dabfc71c921505673f72d3540982e19418ae29ade6bfca53da46019577b3e8df39e7a755dc4d5883bb3010a0452fb398a3b7b0bbe971bc54d4f384bacee7c538a8081183c050f34b373f9bf0b601cbf6556d7e16be32e00ca22f1b97bb165993235f2fe07d25334ab63ab39d466e74d771ccd1d2df4c46c93c0a8383ffcbde42cff264c5ef462f3e69dbcc64dca4df3a1eb11f31e044ee3a299117cc0732c41f20d27bb03e331052843c8b72286db85e96243105265b7b3da187e3a2820f920326bf88d9f2e80afe2f75550ff047ae3ecc2b41b340550f52e58aa99ad7b378761b170b60b8e27d84b8c48996c7d098a7450450504ba10c5760e547cce829aa2b0eb11a4b722872f271ca73bcaeb9d758a880058429fecd58e16c52c2f2f2a6157983b17dcc453bbc88357df98267f036c2b1c98e63a60245abaca4bcb7308b96f61fd8aef872d19f9cd81003cb4edbe232faa1e161a21ca5a0ab498700eb953860e6b5bc09952cc204be3a693f6b27d4f3c1c45df50a9dd0b753bb5b57f52fc75702a9a35f042784ae9d4bfc4d9ad1ff1b7fc1a9374d414ebf6c2b73f2cd77f87889c1a4b1fc5cdab72a79b120e36d505c1741d4d4bc1d807f0602c4313d94c5195ed802f165f8ab5a6b7e0dcc5882669e67a0df94742240350de678482aba121c78f077283e9efa48f5702a4824810197af40cf0214d7ff586f9d181d1d8ebe18d3114d6cf0d28d00b315cc229e9a37b0583e2679c1e746caf85127ee2d29691721904b5630524e1ed00df876531234c99eab1f34d0f47054e1c9e1e5ac5f398cc496352c465a25c648f99cd9305e34c270cd2522bbb11d2d491225102a4ff21d16d053199a95ba83b9cb3e4ffbf104c42fbeedefbeb9b393ef1f25057ed420bd716d16c66916fdf2716e97fe59f83555effc920304c6e8de0b99ccdaad3fe02aecce8f65e8bb777825c5d4842874accd9df4df8dc76c84560c94dfdf13f36c96a7b233fe4e734cea73cff766c7b4a7978d55cc79a4363886e818bcc56a8ed4bc4a59ea327248c2cf3d791dde0ade3e53443d9225c8445bf77ded4bd321628ec15665b94e82fbc5e9c8f0c326a6a9e9350ee270c330aa4ef0e51a7899ba65d4bc1323394db3a0a0897a5dc633bceaf38b7862624443ab19c6bceff451919e23f20f9816a1f57924fb3f01a09d190a87a2d378a19f841edf3e2c3474e68203ac6b57613c2cdcf06ee6ac1a083bb5bef36e113ff247312a013fd63f29acc517dfc1f25bd26a1fc09a3468a51c0c895b232c99de85bef6bf6bceb220332a7a06bf81186991ccef2e6de09cf06cc2b6fa62e24f1c566f0f8b95d49561c70845a07c9287829e8b0ae166e82a45f18d2f90a71ff4ce006368efed285b283ab9b34b78ca377982ef4af63f2a70fb0e2e7819ab58f29ff60c1b6359d2977265d83ab677c1653f47c9c82594f5ede36d8f974b11a004e03a96f05bcbe179f426cb9c8044f3ba140c64d2006092f161d92705b4bcf60ad6e5272323bbd750d395384d67550a0e418b33e9ef8033804fb5bdc28e61f7f0d5cf20fd9e46dc32f54c84ce6b64f4eb436db205cfa6ff0753c332a54d4e8381b9f708903e7a731f5e72d0645b39dd8ac4c11e3a0823cbd1748637807a4a89acd8210b96204a9c61f48dc66f62a82724fba80d941c54ac5e63fc2aded6b0ae69c1ee44ed815f0fb9cbc274a316318c019a3f15f93f3c27a6731f4de3661b77f71e76d1239780082acbfa600433b10845826b7135aa3d653be1771a85d311b47f1fd4f0e41e59ce33e23b147d4cf19c48e06eca80e2d2de0cd3a15dce305614cf76b28e9aafb9766b6a07548e627a2dda28b2f7bf3cd40ce9b848b6ce7805ba715092f256f8cfd2724a2c2e7bef9008668dca2a66cb51eee2f03c45f19c4a2f83c33a93148cd25a9e6f3a3d18216eb4b32f1ae16ad9898de6007445cb63039d833836510bbc260b8bee4a24eca16d75384791ad6be79d38d884b7c550cb274996ec9c1a07c30dad8539fa82debe2eea33900cb987f8590ec24408c717b2dd003fd231590345cdccdaa55f7b75048cb5590721c047673d6066e690b9fe40676cf1be1a2f2b1a52045ea2c0469e1f36b8fc059494853f2784a28a23dc74e33b34b2caca4319013264c9c4db5364c554bd0bdf3d4f0270b0faea314a122ef3e7ae54fac691e449c28c690fea39a58f53d4c7176be0d17c62a99997443ee5ff84b3c8034c934b3e6e5c6506b3d49095cf1960f7cb980d17ddb46875ecba436868b13c3aa4ebf73d046fc209a290100da102e8235e993f0d95f10e7c068e9841e30e81a0eb2c2cda2ffeb3e4b018c4c8cef9d3dfe80a9bedc46eaaef97d78736ca6b964b78c6a61a833bed384d27cee53e16b6a315f07544545625aa0ecd68e3150c2434786727f83666abaa7957c9bb13cb2bd89dff84392750f92ca972e410283375a68e5268241c464be6964c49067fe1ec1dad0b9da361e30340f13dfa19183e444420b229fc6b626f406607f04be5b13b86c3d3a5382d8ce7ded88a2823880a28e8ffcff18ee04cf21d70dffe5d2c9d29b91e6d632f3aeac428d47c5845e6813d30f1f3b1f2d0477186c3492b0fc64199fbaebf351641a4ca50459b5c762961638f3b4df1186434fce7b153f1a6d90a720653cddeafa5d813f2ebeed1aa63bc0e9efe7f032b4b2f740f977e116779af9174a21e43241a4fd5ada936f4cb982a9d93f283f5e9801388072b8f5bed7bf0a155893c01b5ca607f5d29b54b7f6de80f2f943c67c2f70aeebfbfdc42e65cbad1eb7327f1e2f895497a9efe08e39250b0cac9d691df30bbc629d276ebf87e5e1757cefee85a7d3a762953c859276e4878bf42e68c3672075f928444fc95f5381453e3cc020402c76684d9dcd146c6f1e5066e975b13d87442b7aa832d72b8c448ab93b8efdd556a05be09ea5e10dc03efee2037f0a0d53dffc5d940d1b687fd4e5aae3a23b9b192068c9bf2c78a21b6002e5a992200ddc9f3d7cbdc0b760b14f4d85a149dc6541a32c265f19cd1b3f956ded3d1f7813dbf7fcb31348e547a9a160fe38160872438320cc534caf9ffb079e965bb35969a6f80297fe06566c1cd5622e1beba53e7fe8ff24a56309eaa5aa2412bc4cf2fb1113ad7d42fd8b107e0c6ad5fef017ebe532f446d3ea11baf9e8cf5769311297434b0a736e415d13439ddf67e3605f644e82e8fd8bb8d53f0b6a4b7369c5f073230849f39d361ae2d7bea379743194c6fdc85ef3f5a9b98c395b70b775683ce40ee2ac3d0e7a29df57daf6fea4f1005e12e7c7fa2ec2717634f952fd90de15a5785205db69e6845126df2710fb7bfa3b825c1598d5cc634dabe7c55b55427db1140902e7b0187993c3c16d547c6ae34a1214c832f9360052c131c49fa1b9f360fb6dcd6141f0edb146940e7a702844ed8a5422b00526a35e45de66cc6c893df54e012592e73a0bba81920a5adce424bf6f23bfbfdd78432ec9aa51f7243073538c9e57fbc95b4c008a02fb569eee61464aa0bb00d5389d096f47b99bbba834eccfc03b0737c34fba6a9314e83768d8c25faf9ac5db74aab85c05a8a1134d53c968de52682c7267c502d58b2a189ba79b022f288b31dcdc6c6eb688b738a14b0cb1ca92f34d40276a0c58f4265a5942a7b62cbd0ea57fb7242ec2a3dd130051bf245f5f1fdf699deb07ece24422501b1ac082fcb47f72a5a7fe697aadfc383345915c1238af90d14159a496e66990b3fae5e9b2c5146164c9893981bb2c4beb650ad021055f58aa0efb6186d24ce7c0b63598081e8e0ab5ed871f718807b7f4bdf828088f19ad1fe15b57e2aea2dc08139c013e9d319a65361804fbdb73e5a06ef710ef71db117d82002f633aaad354b94e879bf1c15c500709ced4e26886750baad8a0c2180921327a72826bd7912206f6643cd17e044c4f27cc9d767633123c1fc646051d54dfcac0a2e6c2f7bcb7617451d592c92722aec56717817b1937ff1201b661e527b68fcb350f29460daac45cffde1fdfd26fc1f82b8c0595cc3ed67604b8f8f331b234861cab5de03844b9fd66a949f805afbfc67b2ec8f8844e08cf02e896a64a2bbf2f17385d6878828978b015a0fe484c5d1bf46f732207050a712b3defdbf409d2a37f80528f53179d1af24201b2fb265609a3f04c6ea341537e37dc1479439455db25fc98ec534a077344a27aea1daef4c50f7261bdde8a74708a8166bd1362b9ae63ea7f0f50c28129b09c74b0d699d48741cc141f62d3b6ff0d06e50450024d5603c4149f7a8b111a5c819b1bd7ce87cce70a2dad1bd8ada7fb6b6e680c85562dea7d7472a8301ab47f53f7232042d77857908edb989770cedd86f6c2e9fd0b42e541dc53b8e4094b216120a240b8a6c86930b2c65058c3bcb429f9207354a283b832860e1c0be4019f5a9cec82acc1a7044b8eb96f69711d06963f923ae550c00d6edccd59fbfb0c6b9d8fe0d94034193b5eb0cc50cca06e350d3aabda4acd6691c39e5bf492c5bde0c31dae724d0d123c91e36986ddc0c8ecc30d65d2d05fd08ae404df92033fac3fa75aab7430c37eeb07664cc939e7444b71fce8712f28b665af0f008b882b065b4287c665bd32c7448599be4e8bd1e12f020a5a8e37ec98fbf0d714fdfb956314fb5a26390d1e00947d61301c4f6645bf22e91eb497b0415c8f4051b0754f04d4acc5ddd442ac9f630ee760777c461dc09d09317cb591b91f666c36609b4dd1d5e10fc45e3da57d7023aca561e2abc07fa8feabd6245516ea9b3d9bbc88beb82f671993962cad9e86357ce00067cb92c326ee2bb4dc13982aef667e564afe7bd3f4083c6ddcd8a33ae1e50a039877d934adaa1b6126536ebf4cf5cf57a2d2d5c4250c4b3afb92d2df3288a0556d4fa530c084ac1ff357ff90fb45ef7bf6aa218ed69676b54072fd9e9c81a8707ff5ee07aaaf8c5df7c85e185adcecf58e010d55f62376a63c6dd730bab356d1012f6de82168a0f10183ce3a41301696e633165b36111956d58e0900f53a57f0be8da46a46d792baed06ac922f8768430345ebd46027b93f263aefff1e36052076e6e34fb3cde2a1449a14c38f35df71f615778eff39bfe84c4cdf7c36fb892a058aaa13c5a61f749980b3162551cbd57eaa4e794a24842183ecad3f9693947670b78a58b159c6b742faf235872f3e68d3f1187cc33c7d0675ded2f8a38cbe58531d7159701df2d8b5928a4f1c1158f472bae21b2fbabd5632fa9eb7475b1dc9643ca6aba85d7e11bc3960602514768f609d06638cc3119652e15228c8eca3ab804509f7bb9dca9523ba964f529be76a61830b8c74e5340020c14cf41bc516edab8bd048542283708d0d33cdb5ac383a83bf9a340f01b577141cafe015efe4bb34544db55142abd01f8d1f1e612791c5d8c6b91daf7b2ba5e4c462a5bff1ded86656ef20b07a59ac8138ae83b99e775427de89b17f3ad1b52294188634e1438627cba48b46bad5493a00953d0af9f0910bb6a172a6d12234c0d8adcdcc8707db8881429c873ec0510fcd43f06a5aed01817c52a28702554c7c863a1f3ac44231484d4923d597724fb4edc92948e082bd05f1e0a51585375879f3683ebb0a5789d66cf077fc44b6506c76fba9523251cd46fec4f166e10e22e97320c406d6703c83a81a65c925f1677cc2a20dff3c1b695e611b7da3c4c3dbca42ec977095d17f43ae52eb7bcbfb8fabfc96896f1c607bbb04cc0da0e36c0b17f77333cf0364fa91794a26b10de77d0ec3f226f7f4edd775e1bd68363dfb56c1a695c825dfafd95ca7227db9f7a418b977d6a73df5026e90a6622a00511238f4fac4b1a6ca600280db588e5efbd2c17f310be311dd0be778baede2725b944a6bda94ac56b301969cf783e943e1a5095e42879ddd0aebcdefb0d874bb8d9743d0bdec748c312d83ae51ad99bc727566407eaae00453624606f21a266402c827f35d9596e2df2213cdd9cfe9e353bb6e7cc2c340a182f4a8a4203cb41fee534dd9f82e77ca6a81af76a5f5c93211d5c380ff29a690a50e6471da5b32c40e13ea8c46caf2c81fd0f1d4bc50a368c4a842c8301a53146ae6541bc77d54acf8a86ed57d35d7377c6f34671ff82e19c18807589066bb16efb1c0ec9a0d3815ab3774e03b7b0cfe751e7a877cce113987a58f7335ea85c9508e2ea2f5a7f94de49af6a0eff4bf4d3340e42666f80785b6a665f06032ff6298014eb9beea194be1e0e297584d36a4b719c81b1ef68d0c631d83ff02e15c76ffc2a58cdc8ba4c38bd5ad4e1428d6ffd042fbd73a8072001c16a1bfee2ec281f64103c3299f7399820e1f2153d8ae704b9e3e4e55e6890655f4a858bca766e0df4048f2abaf69880bf20a7ee757563f926af28af55a295cb70edc53ab5cf4804e9ec381bf46b6134e2a39c15aebcf2801a6eb62d4f212a60b76385b9242eec043f534fcc92f67857ecdea822cfacc54dd1b2c5f98309d94b6bfca5e208a6af13b95b90d364801ec835c700ca1d5f7e143fcffcf9cb30abce24f71c8409ad5c8e797278a59145c0def622825441e23a6663c72649e4e4bc4b8f1ce044fb1fe400791dbba69582aece21ebc579f8d606569e35a6c098cab507b9f63778c9d238221de88285e342c1bc9356a5953ba304e2409129f0f97827388d222eadcfc9b25a5050996621071f7a647c119efb8d9674460c57275f1f9620a5cc804942128354bb2fadf14eb8b5e4f56f923d8471c68a3898a00c0c5125ae78cc3c1cbe09819f8cb6376b1ad9169c3792911ad6d448e78ed3d6fa238f28d2b33e2fd7464c8b89fd41b63f794dfba9647480127538e2a24a06aedafb82bdc9771be390b5ea0893685fed06231de99b8101b50987f9edafbfb7c68936875e4248f1d5ebac385e86fcd91528578f1f51c286d08e37ad88b28f4f08655309d83529c5d77146b0157c072d126c9951afbc36386944554325c4eaa0b4cfad38778c982065bb69dd8cad1c1f81c47ed657d9f7b8fc0c271ec3f46b04a6265b6258f298daa37f1cfd957ce7fbe722d4a4aa398ef77d3400505f4708b064678120fea1c6f8e6a9f253e09e863b3e6cd8325aff5ccfae9b2bdc3d2a2890d738fecb95f36a85ce127dfa0f2aae9cd72b754352a3127b0b9e94017e50cfadbfbfb3785dc88a1f5f4b143b1638b181e7cdd507f11eb63e56464cb7c4adbbd3465f8c07ff3a4f0cdc14fb15cae639ce5d59f7925650c2baf60821d7e57b564c4ad0df2978bbd803ea62fe41e84b93b4ab38fec6420cb7ed8c82b820fb1faf9e47a3b4fe37697133b8e41b07d69458b40d531fa31ca79fa83c2497963cd194bd125f11080d039112c50c16e896fec495bd6a2d1075c7d3811e9256b19b4b26ea249d8dcab253df569d2af4fecc90951da8391fd42f15e8cc5985c25958d125044bcaf5e7059ee4c7eda3f5a70de68382e73da157d4bd2be015eb5517cd32566691d4ffde1750c0b83e4cb328a3c1ecf423438cfca1849054e929934ec922568e132cc33312b096b7b5072841e1707f4ff937b2da0ee9c986eabf3b8a6ec8d52593a353e7ec25c5e9a2d7f7c223eaeb4c60a007b1e9c0cf1d65744859d0bb5c6358ea6c05ff75317d55894f9b28d8222f3fad3fee4bb462d21516dd896dcbadb34781ae618319108eb468a1deaa8b73b7a068972d340b5f9df65625c3698350f708598b1eeed3e2f7f62a289cb9218a1c6879a683fc97eb1b39e10c992f1a94ab268cc3399a48a4a87be7774201bd55ce98504503d4e406ee6ccffc020054854c77df8a943f2069a0465a469e19039f1e20569b00e5ee31ca4e60570944e40844a9fbf75a1a76c439e2aa1b69951204feb3e3be1e5a714fe321f20f62a6f5109eb932ee140360c1a7a1f639c974dc1c79962a854d7b849a7a4e1132f2e18fd3983552a96c802c1facbe7e3b1d11ba9c5571b6dcec3710ca4e21af15b69b8ced189b9a9996c306bead0522cafea8c251794622a07ec281c4a25767e4f4124e740ce70c7883f9e701acea61eff7be2367d8a17098ca32fadb491cfb3a542b1affa97ece2836a1dafb7cbf90f8ad8854520fce76db0e789dcff6d3bc8e1de9fddfa29c350df1b02067ff61abce8c9d780343c6de0376f11ee998c0a9c4431673d1f6f3b2d52496bbe651eae1a5a83f7d070b0ca2b74f6695351266ba5d232627e99b3073ac48094ecfbd08a17ce02d8b3dda048144ed5e5639b4d8c7e3874031f4dd5b24ba827278cadbcf8c59d3aae97df88fcb9a2ca3cda3b1aaa0333bb331683313e520de3e142d4179cf1dcdddbcdec92e08ad2d078c8b60f9c583b36cb4023b8743db21c152ec3e944bbdf87b414a2a320f04919cabf37d1e5022ac01190afd3f60c294b97ea7d54719bf40293c0b3b961700f2ef3a94b9053ba82a43f72276c293fb2226f8d76e976926e81728517a05a8e006d938799409799f12a0cd6c9402fe3b164d9580b6aa4eda62ebddb1b42c14395f4ce47dafbd07595aa9769c75b0c8318254df63160b2fd80c4c00c2991c1b8702a6870d298c0a45498fac0327b197a8c3a2c40ba2f4b72d18f9ec1bee26e93a2e913b99a7fc97928ac5a9ef77d550ad8da6d6edba5a6cb6274ef2aec5b17d4ae3891ae850ed2de187e1a571377c45b45a0b47d552f3b5fc9861c63d161a0f62eae76bebfe4f5ee7ec867213a402c82e2209aa9c3443dc59096f9f7faf101439d4991d6787cdc99bb54e2527921c352aac5da01a30d72ded29bc93521d1a786ff6c9fa08487101f6f3ec7ab673287336a5023d538cf28a990655ac6d2891339782fa4d46d8f8ef181ed14049e17641ba085dbbfe9278161838dea1aca44112e11059f3609fd5f01eafc2d5f4249508534d98e279eb77b7c5d32155381e62e3d4f960658e749c395257e9cefd0364b14b58f7f283739c9743563027ae1bfecb43f827b920a32f5c97f937f4f5b12fcbc4d6b361b9fa7ed418aae035742e975f338c5ddd463ab1c60d1ff51f066833250a2d7dec2bdeb3c753c40642d0e8385fc43ac23bfb128e72bca8dba2084fa439ddb8f3e5de7df3337f2ded4a01d6d5465f312240beb17c3ca0d277ef6490a259bcfc6c74cde38b3d45c2869e454e664304807679a942e89418d7559ca8a95118d83f7edccfa9cb0913e0992d58e9a8719ebece3e7ca437cbcd7fbec86ba62574ff454b823a60d86d5125a7a2b279f9098406bc8bb1d46f2fbe11c3cf8b1db49aa0398a50e81a0a43e5f8cdddc0ef1bd6e73837ff750208aa3c0f1f8c2866b1defb24ba8a831ae958ac4bbfa5d256bc2d645c719ec1ece25da7d54ebfa018087520a909419e09c1ea2d31c4b15a421ce988b07b781cdd22c43c50570efec39333b5c9f942d9e7e7c6864d7ad629db6d46486d3b3449f99483a0a5cb9ef48855d8532edb13fcdb39a8fd432f0759f6666d3c054a5efef7b1376fa930e52aa2e12d5925b077aed380ca072732db18ccba19ff3eaa40bd4df0b71726e46650abc58bdd80fa2c2f8feb51b89532b59b1522581dab385b7f220f7e528c76be33c103589fce3330f36f435e49bf8f18acc0925a6bf490813143e94b288b60660de4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
