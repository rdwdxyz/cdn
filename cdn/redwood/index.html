<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69b7a3300b4f471afb53ef326179d4c8ca00415a89810ad6993c02384b950173781b5753a670b583f083533947ec8bb7baf929b27adf26f5e206539b27213a6497579732c13cabdb5f439c3c6249de12c4f5c96292a193e0718edd33a459a3c370f0d29511d3c6d54b73d6dbc36632bbfc97d975b5b4feb457cb5dcd6126fa787a7e4b66ea6b4d734a9820db2b4df002ff425a3508c1cf98a9a57a86a5c97e20688c757980a9c0dd5573a174e9a3d7cf0de4fbbc110616ab518f12479de2c1560c19c388288ee544a961a80768137712ae1bbb7ada5c5e654abfae78d37c3db8e1ceb5294314b4f569b1ec139567818ff64e0fece8301f08aa8ca4722efebd816ddca2850bc03b5362e6c28d2f1db2d7105e8edf1a7f7bf59aa03d2248abe9e0d2a63d17b96519bb1bcff2f4eed06ee1085c42b67d8fc962a867b01c1e672a78a8b2e1754de233275a9a4140f27d9839f4d2535e4552899bc773d8d1b15c56f14538b04ca37b7ca9452ff6688e95121a3b0eaafe16bcfff26463a98754ac0049852cb4f055de3da6f45057147a322f79c59fde1a4a6ebfbcd04cce6b9dd02cdc3942beffdc1a3eb31f9355e780ad373165c2c3b79256432b4d605ebcd06e09100a5e336b1f94416185a51d6c10d83aefc0b5e7920214fc66472ddec2227f45ec9852d22de6e3fa9b80d01a8ec930907da52be4cae61a6b70a5f922cdefed0ef8c2d559c3cf0e8ec639ae9f64ecd96389aaaa51833d13849dc4e001896f530ac9a209592ec2b31a0e54d70022f1f31993f2cb32b5f832a307297cd2b882726734fcfd27754342f8506caa8353e77d0b885ede3986829dba6fa49f7492a3be72ca8e2d89bee4f24c18f05e879b4dedd592f3b04dcbe581ba4c80a0141fb1c2a920ca7fcfe5881422a095644ce8270fd73e21692fe07bc17fd6807abd8b51f1864fd3b356a3c4eb8350cdb19eb51fd8247dadc4ddcdc7a90d2e215053173c06db863d6c81a8df48f85032d1429cda4b6e7767dc1b4e86a19f2f6cc6da8aa88a22e4496b8fa2f57bd9d97cb6e002807e833297185c8a5357bb15539b0f8960f22429f6214716b9419bf1ba4e012b015786e79dbd5d44c94b66e854b93eed04034e0efa64be84574f6b875828919f731b17ce0c7261b23ab63b3a49ae93bc90d821148bee2c929940cd73e8d2cb3de285d9a03643ee5ed11aaf7b7f559e77108790ced8f00dee3b5950e88ad0982dc39f662616730d4183ee509faa637dde3bdc1e69f25ede5796e6512e668a82b72260663b5b6a38c616b6531910f8d89c7c8e8cc68db003d763a5e7d97db1d4a07e2b99142d04c5ecd968d3868592f02b9efaf536b8a1f04702bde8ac857184da0f7a7ddf31669c2f761bcb6f01a582fe68bd179b8dd3e4940a74c24117202a87b77f9548e72ae2f37f2689a715e8a4519f4190bdee50b9fc03f589a54a3d51e526df65a6a6dc549761fd5028cbe9e4ce1180877590b0ab53c82f5fd8366f7fa6cfac29e856fa936b1a7bc9071b085dd5dac23f18834ae3bfc82462c5abd276a95132c0de4557778769fbe1e70d131ce8d74d6fcec1226085f8189925993566ff8ebdb4a55256382b31c927f577e66246c6c862dbd3668d9414b2a9cd05dc748e83b46e965a5d04ed336fa4a739799994fb361547239930ad8205bdc65621542f7d4d748e9d5bbe2f50f4324463e4b42493a43314d04aa3610b8e038a5541347b341ab767d32aeb68072046589da08dca3ad7d3616fa5fd68a862ca9765c1503eb941040338b1ca9d3679f501cd3ada7a969c0f7a67b8c32f22f3666ab25476614cb7c8f18c85182c2cc4738dbf7af7cd88e4604dea278e4a4c3d2b50618bdb947e7a8a42c545372402250b26648b2b0db71afbc749ff2917e2f4fc21c9779b1b34cc97d83f7cf40639c09848cd191f4900bab5dd62cc2893a402100455322deea2c61b201cfae9f43cc5d99c6bd214d77630b6f6d11326c893b957ee6dd7c124c91ceb754df4112cd29fa75962f90f9eef86cd6501f660b6c66db6376706e15ac8b7d590ce81c2c7586721f056aa17f2d3f1c031b00a142962b9dff5ae1ee570ea46f327c0fc525f9b051029e88dcbd340dd7a133fda00b6cb932eefbf8d79d89c0ab54f9b3c27a4d22520535c77b39bacdbbad8eefae7e097e8b1dea9ca746a2e808d6de2b5bf1feb098bd59bea807e15dc6b81c46e6dfdd5e9d502b1f702adb8565589b70b0bf1804acda577afcb6b092009d6c28fe5459e79ca3878b2327e19332850cff8d9fe7e9ea26f0b4a7d29742821ef32491a8defca9087da36c3769e96cf743747765b7fcdcbc15960aa5c1aa8aae3a1314739e0e05eaf943c17e6306bb49c57d9e724ca57bd710e441f02550695718452d3aa518e81c0ed4979c132bb86917ede54bd224f885c381b4f0510bb1d6a1fd4ce64155ed8967344a452ab10f3265b24eb63ec03796562beb134f886cab648a980ec0e50cff8e3ab134a11857a293746220cdcbfa35c329c57a0e69fe72c9abafc654695aca143011b0618ccdfd1ca6a7a40d070545acd87cd4b97108034b7e2e10c92a385f05a5ccaf79b3179e6b8ed7836be98f96a86ae17d4b757f9a453f3c2610514130035ee5b6c49fc55b8c8d03a3ddede53fee54d2fbd75a9d330b565530212b3b90508ff9ca842f8742058a291bbc6abb3c91f42943498cde9eeac413bc77fa92a2e439751bdf4fda0faa9be2bb5fa776de32c067a489c3145cc8e82cc9aaa369c856eb6b6693c8373843a76c2222ae7617a01c51185984a40c17e832888bcddd112b5da16c4f312b258aed7e1f3e3099ebb4e2831dadf44b13c09b92d56387ed30ff8444c67f3e893dc768ba95b0c2d2df14465f4bfa9d93466e95cd6b7987dea5ad64dd33f47396d6ecc6c8f5d094c004e2155a1030e397aab2006104a32773a23b1ddbebf1ef1d3b2be83eeaa9cae73dab76feb7e802e77c766296e1691dd1924997ea303c011822f1b6d9104fa50004dbb84b523cecfb8538d67f882c1aad25419b8b59868e8d1d060595a9757ee3a45cf595000678dc06a0fa82e9714f9f873434712cc8c22944d24ea5f1c25626314e06c5f7dc4e567caae2eb3c889dbf64d50d1a0edaa0d1ed56ff96a607b4460239f4cb0822764969142d8d7f64269f181b2545cda601c3dfd7f0f43de9cbc79889f40ac37b57c8ced5d721602bb26db847328d2bdce6b1e15aa83f46c23628acfa95a959543ea3a3720f50bf8bcc4bab37364f1ea0fce57f1b72b84ea84cb122fa05940fcb0c27870c5a0d1b0466280bb6a835b1e8fcde58e69f7d62fbd76e49afdf60cae4d543ff9d2be1ed4c43896b2cc3a35e9ad026b1dffb0e5036562f8bb421d52df904a488fe25f39bef1996ea9131e88d0229a61fb461258f576a7bc6a7c69a31f192729379088eddcb118337e11fd7a8c2af0297f63c944dcddc17fdd17fab613b1869f1d309b77c5eb30047f93ae8a54306b31ff5e6b5821bb1cf649a4703ece980082b6c6889f6bfaf6b1d7e1cffa1b862b118be7a4592ec7f861ce23b2ae154caa3f4a9b8ac379e250b189dc48f22558024513f557230e79281a431e45c7de17009f40c53f78890ce72d496598a730ef6a57e2a1a1fd313574f24e55c1a62cb1fd11b40edf689e918df43445e31ec664895c0630e1b75cda410d1fc43c15d12c38cac5eb90f7d4dfc0b6994c2f8daeccfb4fd9e431d57f28327e0df34e6e375617b6d16cc5000dba84ddaab771f408848821021317d00062f3168600058d3abb75952d4b043324aaa6a66537398fe3a8b50871fcf4f27be84c96845bb9fd89bd168d0b8cad04e85aef1a9e65901b4be2415e4974f5be64b00b58a357a952c742b3f9a002522e107dc3b6ae44d013ef92fb9ee42a4b10173e9b4fd364fdea65c7e99a840f31038d3faf268b79e102c98e8e2dd7c8d3e6cca1762f12219042575363f64a458c21f8f1133ea5ba68f0f2b2d96ff901cde754f55e8685834eb8c04f80e0afddcff291e58877e2ac76dd40cfd6bd740e253e24721658d9dfa7f8eca20d86048fc032639877ef166e867a9f8fcbf8fca008be24321a88cb0aa738302237f269656d3e3164e003c01d7c56323d397282e8be61bb055521b22564e0bfacab95699a105f6a151aec72663402a5588539cdeb92bded4238226fb695c2573be8987c8d7283e0989881b049ca932ca9d25d79bf4fdade6cfe44d7a30afcbc94ae3c5f97ca990559a496923a1997525e3f5db5ce482db2e9a71f1d5d02e60714621161567f7bf37bf0e950dd1da7f4169a2bae1ba7867d5212780db7901b47b077b8a2869231120a8d338e8bc4dd3728bf1fcb373d835f0e17bed84c63025b143a315f9c6c6a6d4b3ec89527915b9c96b4851f9f116a9e184cdf918683940778f31615ac22f635bdd4dcf552a2ccfca72c9fc347f74d57fba2e6061a470016bfdfb0df6b97d55af23cd9988b2b05209b5aaaaceaafa955e7bac2a0daf3f23c55a307b3184334ec49e3f66cb3bb19da5046331b3fcb60fb2526aae3ccf39e8fa5ac10ac05e84852bf71e36f8b32df1c943b052d34eeac0fe86cba465f5cf5694dfdbdc1b39a04e0dab4ca91635f2c2d27a93dd8685b164b8030a2bb9b1c01f47810392970e681791cb73ce99af1d482212ae04e455d42b5c989769715fab4c60c1a855193927a188c5e3c32bab82a5dac314ad85be04d33416fe7e3870fd92b7da2a606d6e43ceb648e5bdc3f7fc4c94c1193319eeb664fbe222413beb75ff0484656e0df48e2e8a999434b6d98565b59a973abce18d2e730e1a9ca97dfc6b508e9a0c2c069bf966cafd0855d9cf1a8696853ef7be4fadc7a28fbe2d1f3004771358d2b3dd632cebef89083ffe2f66c91538a6e2dac006d4e90b85a5f82afaf8b6fdbadd55c532f47e3873430bc427b687b8e3233c39559d35067e724f924c9ae9b205c5e5740abdf0cef2317c3a12e00ec9965120da2db143afe4693fbd992271d7e2e74c1861d59381fbe2cd0c8fb824808955ad28b7574d8f4aa7a406e2c0cbb3b882e75bf47e9499be695502ad935b7150b3b8d0818ed655a1e340bed7d074f988f163c32b1416da11e7da3bd19f70fe450fd835a287c5516900a4e236dbf60bd7e0165d53b98b25a5c92f4ae260aedad5693eb146c1f0f8a52e0f1289592eafb7665ea09f449406c6112d3ed1a7b5aa9c055a62a1d2c3ca34560c1ed915c2900a171a5c5142974837b995dbe0b81bb0b2aeb9ac3b5d61fef1ed6dcc1427d52578ab9824e6601449a1fbafd7a9d294508127e8e7fdcd9f4f03226da84d1d872312f5c16513f2b7e055771dc8a3b8a640b332f7f7f11799c010a8c386bf1bad9ce7fd1b3ad27c3eaf9019f873b6e6073aa085d85107d97ea1d26ba070bb730ffc86e9129bf5afbb39203d5097dca4ac1592e94dceb3e472b90d4aa8a56685e1ebc8af7d872a3e536c4e1b94dcfcf45c0a69aff2122e9affd2d8a5d95299dfa80564ecdda3fcfae124be612d0b802f6a1919988f6f8869af2a50faedf5beda31234cdbe765d6c6a9de2098bcfe06d27669ca7d82c22dc07af925221b09657406091f3c145b1d516b5c5a36a9d40efb356370f3e5d58dc746abbb9199348dcb7c7d18b9b178094bd193aad1cbf60821a73fadcf1667628bd268ad562f1ffa0cf8251082125a4e051cc5d6671cbcdeee9acce0778f32a6d98445b9abdc5c5465086ff1a806596903e2be320c86ef6acc2827df0aa91c2f3ef87e947e327647698171cfde1b9026c0eb9404d0908635ad375fe3317c1c6706a90c1a9bbddfa174ab7d9738454ef0300ad78f7760e260bd9b851f55facb042b53e954df037d54661dc1fd107aa5bb74189469b3cad19b9209ec3bcf71a22a5625605e93c61fe17cb30124c9787b7b6c3b2e18ff8af36f39adf5d2c9b29f771e69feb239b90610aa5f34659c731d157d2c91889b3faaf05942802cfde3d56aa5fab894efe42024a819566d1e601a5c9b8502bab935103cc24f1bbabee050c86d33e269460b830b13bd0a7faf7d789054b1dea17bfec10ff5ae0073e89767115cc485561d7a0cb3f163280412bb7ed31f9e08f3bc7496766ecc683bd0015715d182f9bfa48bc43de7cbe7f430dc574a51c99d07d84b95cdbc80fe23c0074861fa3eb6a0ac516ce352949b1602e8c4fd9435707411e8b19cf69331fc31106049a41ae272d9bd624d2b2e3b9e57989b17203e047887b552e0f1515d918c0ef4f1264cb4c9d2cf476ad276af9b30b9f1a1f1739088b8d9936cbf19a9f88979d8ba17a5a8d0dad2b41bbe396fb990403e9147b68391e573decdb486ca4fdcaa5fc9a4f15fa7d6198c995282107a147b31512892c08afd7ae86d826333ac2df16cf2e52aef500844afbc4e6b6e2ce1e08af4d15fe56f04ed3baccaef8cd0ee5549440f4de4c34738938b9036ad2e5b7a9bf456118ae854a58a5615799808c7f4bf4e67d1ee2e0d53af95a6d472d27e33692fe6632fef6252499fb25b97cf87700815530e2f743e99424e9ffc98fa2795ba6a72d0eba32f971e73b093fe0f2f1aca2aee1015f46abdd43d68b7ccb5c26734abbc66dcf0cdc22e002846402a730fb58e044a8e93d6c94cf9775c244281841cc0233ea572b7b60a1b11ae0f8e4aad0f17533a3f6a8dc9ba6c3643d6fd15d104ad68a55e886f751d1f92e3b63ea28742c6b49411f99d47e1b830262fc0fd35191e97a07cefd55223ee803f16756bb176be4e8e240842d2d65ea68cd7fcd32dd7c4ea4925dd1a3baaab134680f62ba819505e744f9f6878b5acb4e557f35b3fe4bde8f72066d6d1bc077fadeff072451d8ac736bf0e841e643e365a8553de7f50bd3bb1aa2ce796c5b4c2bcc7d20b2dc4f47f3e1545a4b0b519b1b9fe536ec379506af8c7f3f79e204f40d791da094a5d2adb912d43a5148da6eac5e5b97048e6695f6c8e0dbddf7c7ec6381db23493fe493a5eff2d55436956c52afd96de8fbf3188c3c7c1dd61ea7c6e5b50a672b49513f7cf6932fc7e5e5c998318f92c84af9ca601a7d0136bbe1f80c7650b080d5bbaf3b535e7fb40c89e5a260f7b3485b93c630535f873c404b75df6586bd927c7489f3ad63ed6eba40a7362028b11e0eff5e0ffad988e4ed865ed2d6d420727e973e7e110a40ed238f4487b06533dcff16a76842e8e087bbea2801555337858060b9e0903c165aaefc807b108e3580b98d36035c76a21f7417aeee1f682a380babed69c2c646fb2dcc134206072006a8105dedacfcec59c4a51fecb7e24a14fef137cd76b5c60d03c1dc9413e0a64055582d5e1c3b1d896f7c9c5104b36d98d425f6b5391f8d57d3a0244b0f745849e6717df528fd208dd4dfe712ce4440d0f2374e4780cc88432478245ea0936da1272ac7299a6bb3f923d8a8a5f4573b8e6d2f8785586726691f48da557d3b275460c00d70bdc1cc6b3bca66ea06bab8ed4b157bee90518e14394da32ae7d9b9f902fb931018800475dfc06d29a41f7f8d42a90498151aedf5dfb430d070a9185b2f46f9e64c17c8f13fb561bda9dbb87105c48c858eb93042759914569465c0507a35d8947b644f0e4586d4dcdda07eb4b567d5f920cc85202b2147fe29f48304dca8f536e21823a5a7fde51a93c9bb3be2943200ab8126a4225f45f4231c2fa0e0496c7ccf6560702e81ceff3afc9669a65ba47d8ce3fa55d9c09a419f91e4f43661e657931d22241955d141ff9efc3a10a7f1773e5b795e08ecf0c7789105577f276b73b1df17cc91eaa0baf17a672dfd34a507d061afdfb9b98137ad3f3e3309a13f48177b772c91b648666b485ad8cc1e28690b9b5546f4fa4b145c9b149d7bc49eae126e1398870e1cd38b32692e4b241a3095d07d03950bfc9c2c28ea5872c23dc051e94a6d9105eda3403ede0f25d2a92b76cc0904ab614104601afed5ac2ad8c381334de1f7c9ac899575f6530772a39568aa8bcb6759be093115a362ec0ba36c7ac2385c1c9d6b212eb28b9d01290645f6fc342f994fdd82116e3154b235e92f709f9ebf9b6e1fc43998f9ce02bf5968bfb542f9e5dea8c5cde00916c67e277163e9b7cebc0cf655744f475911886a19eed8be2cfbcacda399b960e4f3657872cef34c162007fc0a22dae68f161998444e3eb4b1e853520415314015c8a021499e923c88030314fb0f326b55a5c467620a2f39add8424e584c903cf909cf6d18d5967f4ade0354fc6984087bc6268f0cda46a771b99a4a651406f6266f2aeb27d38de796429a260846e4102c58baecc0075469066fe679ad4d0023fcb76848a47527c7e798afb5b6238f2b66fa61b7f175115046c5f6d47a9c71e4c046c097ef75edd035bc8fa58e958b1a48765fb98a5bb9408cc2eedbff2d67ca77470ce47d5a637f62aedcb616c6c3e01b6bca069b5adc746f1526978bf5ff993380e8994180fe9237aaef9ef604351567691f95c2558065742a10f2fa312965c4ab5dcc2a19ff17a01d5f48bddf23df16b22ec98994860443b70475057c3d9a41d580888bea904b6c5bc1580093b99ed21cbf4d4b5ee682ec8fd80d0ad31556dac1d77f1d116057c38cb216217308b7a87eae60e4a076d49e7b867f7e7a0d3a346aba495bb1f59c1952d1e68a41483307267a0823713b412fd108c7934ebecb823f472f91cf05080b10dc9556959bcf6e22267928f00062ba67585427105443602cf7db33d46996975e06378f955acde91672450be3c40718d4cee61d06f4a1531e84585cb6e871ff873318c168a32bc4878ce39282d655cd40c7f9c0994a261f4b6b7b3c13f1c4f71b3f800297ae68cbccf154259dc4a993531674688e69c6ad2de945f871657edc39e6799a938f3748770e82db78fe9146bb580238b2bf8d1c91febd0d9d5d7b5cdce7fc53dbbfbf931f9f989e5bb792dd28663d94b73fc90319cdd960efe8ed57102e22e06583616c83e1473d85400f0697a9055c68aed615c535ca3c172795d5ccd46ad69551764642b4deceaa62ae77003c01a0204ba6723e3a107bdff64becdb3b18dab8a2f5c9cc325e5ede8c6a7223ac455e05b72f7ffb194d52eb71e8e314b52c1248a2692a914bcc9306635cffe3bc0213027c8feb3525f89a2a1b70ace6711bcee38645eb08050e0deac5d96043fc2c778d6af358e5994034bb8ed91be871f2b5cd461e5a80af282dd9eaf786413ac71d8ff8898bc6549aa170971bce94a2283f85703571ec075da41806f1e154425d9710575635ae8e4b374d3f6643ba201d07a3f95f7eb6f0fc6d49c8bd5d07ee3faa66622e94e86ecf04b04b94fefd8d6aff6ab220293ba31e2cf9c1a2c6c53281d7b456f76db85ba6a1a1848d7418c1fac7c249080723bfb6a683fb7745f60446b24b42708e693fd26ea0b5a8194703d75721015ccf6cf1151e97aa4c0d6d33b885ff17701a1e00f279d5203571e40d535f2268fa50b0fcda7b095098c793097c62977a6afde9d2cae58640f5348b27046b5f9c4eaa10ddbd516899b4c4aa911bab4dbe8ed467c862eaf7ddbea52da6112c044d38c30ba2ae274113ee77929b26b24bfe8228e4baaaa050cb8d7d2f0f901d9df6f02d6cf87df2b538cf211ac76b4124d0db539a984743d9d0a2b30dee5d7eedac548d0c8a834e4c74b0196999e888dec245fdc94c3dba274cd1d336f34c6aec7561993885c4b0aa8f2b0da206a9750f0d024e287c2684c22201036aa02141d111c11cf7d29e4f6e5cf92b9902fd99cec914c6d707b9225dfa0c979e44126be07269d551ef0945b5ee6279efba4fc638f480046cf3ebb976d9838c2662344a70c04967ddf6ad5259220335a50fa3ca62f451054e78963bfce8b738a536b4f9da9094b0ea97a093539a8f38a823f0d8f6f7a386bed2574d04773110d14ab6269030df09bccb9dc3286629a29096c1a40c207a08c878d01001c3fef28dd629209740c13c2975d6a22c9e90b38fad2932b318e90bfeaa4aeee43c84afe173ce9ad477c47b8b6c42797b625006566d8f83d8d029f2d2bb869bfdede4cb026aacc2483354d1812815493237aa5d4d2baa0aeb8f438e61bed434f8d04b4ffa11d47f3d2845bf7c7c81669991e9595e23a983ed12c88861a5c2109a66ae12e08741d36bfe4728980987901154defa84952cc8c809cb4b06ea785194fc733f5e4317732fcf4f85cfbcba60e6da0ce261c2df9394eab0a3fc260b0efbb6718ab047b7649958d5a0878f2b64b7d5fa2bad62ab8df5f93c2e95329cfdbba65ece3ff9b4999302ed2f64b6d9267f99ba846f886d3e9bb7007fa3bd979578fb183913d4955040c6317cab5da7db0068b117f4a8dc5ec8b84fad90d48e62da26610632c3b16c0fa6512bc87f2ac826c79250bb22042877b0f07d1a187622ebaf4fd6d1c45f003c8fff731481b2f45141affe256a9adab01b1f42fb8e2dd663b15c0b13c96d26d5d7abbbe31d7da48df1106c9c1de08589937b6219cf690ab143ab3f2d8c4036c457e332221933f5844e8bacb9723e9fb6aa23a1be300d8c9bb36941159c089f1fa612cd9263dc5e9aa1c359da4811256c2dd3f58239019e3d173b516d9e8daba7d1f34058b85b582afdb4bfa45a054b037a8785ee4347294e81f80cede2b7146fe33d3ff211905d3872947a3f76c6160b2d36f74faef25a94c25837245ca6716df188fba00f4e3e5370ee1c67672ece0affa555955649045d41c7f8be78c2a18bb101086034242610e15319af76f498f6806d75b946beaee68108c29bf5ea15c2d1eb699a74af9ca777811a00f6eb8d7093d3483a863f60fee5c5b792e2699079800d9f4402df1d0633dc91861494a54947d472bfa5bebe92dc64e3b91aabf54a7bc25bccd66f988ac80fb83dd08a0f344e04a3980f1503c27e192e9ed378d2f671191b75e6560d29840b9d8ca05f446076a9677fc92e27a3463865f37a3e8f51efa6e23ee3dd17d1d37591723fd08fe79472b5fb84c1f294d94cf1f7ca4d41152d3d110ed8e315be65b058524e03c457ce7c3f2c109d3e5bc0dda2cd7d6dad923600bf50e02ce43f4c29bb5928094b61f2f473c6d5267c1764a6cd93ccc80f5e3dd8415841c323111451fda61539daa2f105fcae49e70ca1fae8451aadedc44c9e25751360a4b24ae33b48ec5d49a27d561698a6e0aef45756394485d90548a00343d368585c8f06c59b7991b04c41d002d56707df4dde4a67bcd596b6a90faf6f4adb7d3fba7f606c9dd56809d98485504e937dd993e5468b58ba41a701c205590cc73f307456b6ad04e6e341b6b9415dc93d42a9cb1110b90767d1fbc4558cbe89ce551ceb690aec213f385cfd040b4b30be7b8b0521e85fc012b5926c6e1e7cfda08141e58c13dd0c83b5f44070e01f680025e50d19d6ff2d432a6f6f3bb1570c323abec7189381e994d4a0c98f3a4c80b3bbcb63d0467eed6c4613da13a024cc8ae2a10ce5bcfc728df08be6d67fab63cf0a5ab01e2b5b2af40c4d5d8058cabe51043678e6c9f97a80f61cabb52bb1444a67820b639bcef3a081e7a4b3e9722610557ab4245bdd2d77b6ae06d5afeed937b4b72a7234de052f8f7970fb62c200537f86c491f4e926fa81b56fc29e4c55d7ab306a41125511757a38ee7c99ab66d1a2951cbf69831c5f1dd7dd05bdaaf5f5cbc0c87bb59bbe843aa81f0b1dba15804a6c2901b7e989d750649126af59b6606133952c935ecd86f9ef6c5b78b3566d094fa4fac4f6d0541ff899e842b06af955901bcc5a94dcddb45d786a78c6a158499831b47416a3829c009122d92ede825b7ebb7855982bcfa59b6eddff51f0d0bd6c04c487c3c932a05446fe662bff88246772a36cdcc119e3ad4e0e803826996aacc04418228a70469f275ed2e4f311ef63c8232ec58c416e9ccaec7328130f0d7eacbc592071b5f6431f4f2d26a6b2c13052f39701808222e64fc55553f3a482f6559118d4566c3f04b54769c81ec4e0124663428bf8c54ed6f013c053f522fa58cbd168ffdbcc8ced4de3fd06e274ef6d3bc5810c2de6ff4229f19da9ad76ab23cb7762c03c4b95be4281b8a9793a029080725911f38195cbd04fc4527c0de256b1d9bb0cdadb1fca955629718caf212ae569a39b24ef2a78fbc644efc715a11ad8f581759f44c7b1f922513e25ed8d600e9ad7360046fd74e627a16be60cdcc158b0750c3d26f0614b175ea7761c66f92ba093c4c5bd8f436f81f2cbace2bbe198b5076451bd3d33e99cfcacda7b3955dcd40e27efe7b87c3b406299b5ad04ba49c1e848719ac800336a2ad4093d568d6a6f7026d385947377e98bc700ac288c4b089c1f8a789e802d562b8750247e906b2dfaed31f9d9f16d1636f5f78b998dd47ceb0b8c445901a5e2d604f879088c7bfcde976eeed240e0ab3ff1f2fe46d0daf17d0c77d61edc81bebe42c7ec5dffaab90f07a136c724fdce3b21926bb878c6f5f0b955d412f6823f6852f64cca78af3d47501f007103f932f8b1c5cba306b0e33183d3be0e4f98bd8c80eb6e011fb03236b48f0de30d73e3d80665b74962509dc814fce9b286dc91a79d0a67e70f484cfcee317d2d5f9a237b3f3c2b978c4e36a16412ca1bb20dbd5c7a92563659aac2c3ee588cfb136eca8d5227b40f2f9a3e68885c94add22b56e45f2c231d5a066a30e2a6078011c7b841dd2ca1d2fbe3e08ba6679ae6850b7674969f9394513d12cc87a9d8de3a55a1f8b0994eae11458cc37057decfa8cc1868a29612cc06a65b7bdc12ac3f319773fb996998e6009faac3b9b14c88d5f1a85b04a37f7012d9f5be721b9f0d503947d404b5bd35628fca58bdd4e6de92bcf3524f76bda31cb12df54183403f5c0de6a10af6832c45bb5481d37cee8cc9ad37b5ae25910c7e5be0ae637bea32d7262fb42989b22d6a2f6ffc4083558c1b1314d04eb1dc30d8b1bf222253aec80b8f1303c2424e21c8c61e6caa22db3a0e931cc0a4cdf67ac17bfa0f4238b4c598aeb2045606b3fcae0559464f381731093fcd9e9d80004f46a412944b0661aadc1f68c98868e88db59510382b934d8d67f32f13ad6972a4c0b1b0cde172aad35b2a880dccfd429579ee25fe6de53c0278659bba31de4336146d972387f3444dc4161658d72928fa2408d4c96db72914e4b41fd9120c22d03d3f0e25351805eac404e66ecf5395c73fe02980245c2194ad70319e12a64d44063ad1a91f2a137079bb49d530e67a95f43e443194fb86eea26c580f059e1be018d0fe82af7ff9328c6c4f427d9f44e35bbf3d1240130f90f39fb2995a0a16fa0cb77fa810c9dd1772e6b293fb1467fe85a00e4b3d1b95629adc5f9f8343abfe5d24e43a5c2e42604d0b9a44277d5adc12c3634511228149e69d82ff507e18bf5eef8c56fad56adf6e8ff07ff242246a5794eeb59940ce83aa2df0ee71f971b1c227af3caa877bd118e7342706395b8531d098056c7026a3bc498d0359cc2992c4014c7a60f13271def0f91f8aea64a815f7712adcae61c83e472f423685746058387f6f7df015c53b4dc26ade735a4c127bb42fc0167d21666f57f5a7e7ece27f393c2f0ee2b1664ce3109b7f81b9b89234a1407983c8bd584c44ee0e0cde40f1b48a61de91f3a0542430def94dcc7c6ce4304f182cc9948675afb7d74453305f01beba4854acd76ba4da8c58154f9d02a5aa314c80335783be124f8c8a4c283d5cd7b22f7e8414c15a1508c581d74b26f705c2ed8a25857ab73cd973aa17853c1082a526362a183d52248e6b4bef2d484c376be38bc3aeb4a30b1a1d80cb0bade18c57ce032695517184e5aed560357f879a37f1c4fba2f380d7dc8c3f1de14b8d774819a73ba5fb5e802069d79f71b2d48d9e2228fd11f17b5d50253bba83aadd045df67c67b5de1bdff63a5d4c7efdf354474cb3a0405ab38ac38d57a1e2793377fcc7281bbeff21fa3694cd971ab1fd5f0fb5e5bc8f8430bf2d2328d5461c5a0993099c696537eedb49121083f669375acf6a7e304e386377b0fc94dc5ee688a33f50fe403612a878043cbeda7b1f80f7bff1ed6379c83fbdcfa3f0f40fe57bd128d2cba3729914b4e43fb88d7d63bed94749a1a12f3531333f0c8e2e0a100146ce5e7ce75df8ded0220c35f7c3607c60f80a340ba38a35df53e67812eba3eae307fcd71c26c22b5896aef2b5bd5ed7e9a6db251631ea23b9923bb30bac6c64847d0dcfc2d6a968abdb956f1b71abf578e13fe36f8191645433e25ec7adb23fa2fe4062ddfa1b6058c378d63806791a147de18939e49a9e6d1e7a8f5b29822ddd6d270c318482df9845a1967ee550b4c85898074e1736970f4f8395c196a3071cd51fd5ca99ac0831db622896bd2da188c9bc7a9cb527ce667d5ba3197ef2d9df4cee1700752b91d1e16082d3e26abe4afc63182db681bf96a95984b5a746e234f0626c6373c734f5677e23747c93045534b3f564aa1590d5e8a97c15c6d1de7582488e0ad0825334528bf3ac0ffe8feea62f006def47d4e6105421e55503e4dc01b5c5715b252ea56cce8bbd15fd2f5d2ab486b07a709e9f9838c61b2bb42acddb5aff491a9ac07b068972496c8e482df588923fbb74d340629f13f3b09165e6278750c821ca75052d290a81b8be0a26fe0025ae8bb0d6642f8a2c674d268413a305c2a5407fd636a4485ca04b584e06564b10f7bc45d01739610fd99ca2bc2696a7d4f4c43227547eb1a2928a16c547a3ea8af79d6ae749abcceeab84c14e5e7c9e9f9310377fbcecaaf165ebde975a752eceeb7d2c722d93e9b79747163eafde0839b520592c6bd53bf29b39d340f0912ca01cfe42228ac2aec6730ed1462b9274b8a513c4b6ae0d18013d38c6fbc16c3448676ce38aae0774cea8d0605c0107db7da5593e38f09dc1f150dbd6bbc5a59d8bed67a04bdce0d608fb3a35890df544fb9acda46599616340961a9f58525f4f887f465d24454efbebe7149f4acc3f41e4d0c44c80781b4b273663fa3a0fe4131593c8f09838ef0a6d522ee786d20dcb1e33b5392943dd4c1bbd826da79786602938f5215042ea3a4d703b5e4717841d942cd0f12ea5a3237ba13604a3847464feeda0c270f24981fa5968a0779e82bd4005e36b8a61dc2a9108d049142d454d3500a859dfda859472b6d346f306a702a55461565c94471bc8bfaeabf9c786e4dec048baf5c8b56e26028734e12b5ea6c953d79379caea5fbf0aa31d11887bdc2feb67dd1c94f3893de22543f07d53ca2dfc0dae0e0b213e2c2fb9bb7d2c7158b795ab8cca7928a94a0d8c59906e6c047a2d75b2a465bf75bd432b08fe4404c6dcb56403d07507e5f47e3454cf33e322461b25fafc793f4e9137b82bed93f72867042f76bb19babe055218edaf0983c6d0385b387136c18e5213b5303dcd478e08ab8ca778b7765221696a2d39c490b35f75ccbbf1463f6587687f01efe31a8ce8cad4084f2e11d88ab5a1c0d0bd083dfe54e5f6ef8e02cdff12b19b182315bd54130327fa50bc13a0557e07a64adbe1d8a5a2aed376321c9b064a2db5edb11535c47104c23cf71b95824fae22e963939f341e42b32f63a6c138a885d82ef8d5c156263b925732bc06e89a709525a0d7fbfe6263191796c3df965dd980d53f43c1ebcc5d8cf6b6624878f2d5bbd6690664c9c35b70bfe75801d92dd3754c0a4ac00577bdf51df756056751692007cc0c828e01f0c415e07c2fcd0278c19dba38f974bb60c47c8ce3bb8bf4e4175757ed66a0cc180376021ce86423427ca8218e9ede264d9bd89dfb4e4c4646c78764e159da6655b16db2deb136335b8e89dd7ee87c43454728fe7581d74ae667e99cffa4f739657bbeaf59793af9c8e72218a54ac93ca1f91688c1ffb5ba517f6c8fdca5f947b8e9c4945d288608e4ec68985b5291048fbde472f86ddaa7ea71fe7161065789dfa1d14b30664e618ed0225039f7b4d9d5dd6d90c905e139223b7e0be2c528c06c03194f98ec38b7aeacd5fb0bc6cbc70d45cb68ad3d971231280621e7f44ac4109d12f03f06f10e038c21425eb6795c5a267428ec58838b4ffc3d63d67dd37cd49f16cbc1a1d3b13b660c6eb58b2be75d2c1d46c42ed01b2bb122dc5fc347652f541f3ce7bb79509e437755b2ce2309e8f35d2a94d8868748adb237357737d8c2852ecc715afdcd26166c03bc953a7593bb8c33581b289dcea2bede6982132077c6f42647ed7ccf295c6f4345e0ae881bdca59605fb27264ff6e2da9cffb0e98a4c93a34391eb630b8ec4250387fffa19ff13333a02c0b842ffc4bc827b4f00dcda165e6be49e0fa6195aeb10f1228944a4ddfb1755f15c0f149faca3379fb9d8ec7eefb5e73b2af16932f503d01aecf2f87487e9ec849313d25791d03e68fb360e272b2173b4d2695b238532cd0a2cf7f5689a0929114dc6d8c4ed63d56d6d7052bb58af52467da51328a9591a96bd2fc8f2a9fee1721a6615926946e794a5045ab33cb9f658f9c36e79cc198f8023b126a69ce92d936e4a3145490d5d7e7609ad0fdde946fce5b96623c516b81094053e551cb7c0d8b48c2f7956482871e75252bdbf8f9965c9501e33657ca01df0547f7b59005eb3a9ea5513d19a140d0da0a193a7de4e5e1255890c552b3b6b1bce433d1729b8a11ce656cb64b3b41f901ce057fa843d1bb13b8c795d82ecc37092bd59230f5d4b26fad051781277a3324717776bf4c7de3168077ad295b5920b14b25313b1c4b023afb5d8a36cd178a20a4828728e373e26b4f1eade9ccdf74d847890f1333e2eccc3edfb76656c6755dd21c893292d34af760df487eb880361d0421563bdee45636d11a2bdf54c042bb7f3cfc1924494ea2afa634d760b26dddcdf43a64177df909ebb5e448309eba7d225f9485dc37736049d94cc9f6c37e1c839387b82a82e91817de261aed9d042c4281c2761d5b961355361d1e9da976deac71e88f586a90f739b9d5318179017224344914160c736bf07098228251ddf8fc0a9071d25d17bc8ed08927c205bfe8e904fb9e7f1533d1f8d90eadd3d6dd593b81e215fcc6625b9bdc39cda2a7766e10d8f636065d9ae7ebd52506b8a33a5c3849c4c5084d5adde8f330c36b30b18d63881113a67c7bf2f943c0b9c6938314f8d32052892b7ae960b679054f8adfaf63f1bc7a1cf13f313e37eb73654c2b9a09696f6e9e50937689cd5b096aa164bb112b82915d8df30dd95281c3f10011879967ebc25bffec459f0fe9f895db97b9ef3d681408074ce5229b5d19e85227621817db4417bb6efb33a24a49a9074706561ee5f3ec7092e5a74011e4a2a8e7b0c5c478180231425777aa83e129544fce727b44352054a9b9dd481ff2f0a5f23d3c8b1d1fec8fafe7bd23eba425adbf3e9f4cdd6420de7507e97b55fc7a0964541bac155ba0507ba4de7b94c11a97bbfc6831829b5f5ba64e1148c3389bc48212d6fad5d026e0a575c384699ada19f520f3a3114a7e957ecc1a55f9f0901033ce1a6886767cbe92d490a4495af3f995d5a97899e91775e9668687dc0828edfe9a0617dcb77f23bc9bef36e3d2c5902c702d37cd0c0f2accf3fc2aedbe1d9a13e300960b883993c0ae08b344260e00b391054afe805c1f249fb8e4aa4990c6bce98f22d6c5ee110e9973e206a21f3dfe4b41c05f7478f3eb050574d1a1d40e6bbc7a2eefa6061ceb9d338d52b53f770fe430aec61995a687c10344c4b342a233ca57beffab8667623ef39f2250671dd61bb4ff357f4d158398c48c9c9a69ee2c5c1a18b86e4894672fbb6d7cf5aa6e2260ee2b439e3b1ca88d310a61ea636e8119990acc6049da33b5d1ecef5890dab378b194d2808aeeca7a419f7db55f4dd6c9c31917ca85ec8e74949ebbdcb70bec295f321428581b975cc9235210d73be2149e7864dfe70d02f74bb1071d37a8f128cd19b009e18d85682829ea394db165cf0523f0b0e9340a2e8e907172ad96f5ebb57a81e5d0a73be726694a1e6229577ccdec831bd15","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
