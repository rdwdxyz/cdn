<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c60d868665146f5d50e043c746feb4db7527bc445c592059019b43ee953ef536af56a087e4b5dc486bd7367f15b9fd65b63c9e971ebd23342aa6f5edd7b3789e08dcc7f6083b5ab10e92d7a3f969dd1bf2fbb1c3ec7794785bd2a4fa99ed1df22e2ce9dcd8a1cc0b677a1d000f8ce283b1f2c2ada10762da860e3d9cf97a0b41eefcfe86c3e5c11bed3a928da8546fec38b8a4a328c0d93810a6ab56e884880d34008d0b251c4058b87f03dd652ae8ceaa48b80379f7a9519f3617c79c94b9bd66746b385ccfed16d11cf7da4c83a3dacd0f55733599e97323727de8b06b7bf9e1ae1e94a436ac0e7d350443b90f4cf132673007639490453115890f1b4f40917625b70bd9bfbc756d72ca658eaf5f3795dc2f82b1439d9709751434c802ef08098bfc5dc86c723e80105c1fb3884a9642077306e5422e47d6dd94c8787827292438cd8afee6f2ab4aef5c26208de3d833ec6ae87c4b8970b85e4150a4babbd99455f894213a7cc0797f299986e16e63074a678b9e6e318c36db6b3c78ed07640f1bdc40e88bdc27e634889cb7677e6c7c580d1fb115762e7ab53c8b128bc63519647aaf9d3cf491fcd6c6cb9aaf5fb8df5cf8f8cb3563cd6ddad7b2840393c851002b6db830868495ae9f95dbb5b5e07a77c252ccd18daf1630d568c94be941fe04c9acb89901031d4a0bdb441a371b4125318892b83dec4aecb4a96f48fccee683eee8fb81b415f699467e6d4f094f9ddda4108588b1a61da6c31792869ca25d0c1e2be8086236f509edb37eb6199071761fd918cd3463ada672a6a8c5f9d6fea8827f90a17373b6d71704fd7297827faa2c117988f053138fbce8d22c7e2d25752ddc410555bd09fe5c3114e4c79e4206268be437210eca848b9b56c2c911a29afe764908f8e1ff5767b14029c5b4c55100f39299cdb04e4b3ccf7b81359f10f0722bf6abd6b92b3b9cc5f00ffc2dcdf1c2959b7a91d97260ab5bacde493e90dd1e067d163eead295c154d78364ecbba81cd4ca13b9449e1923fb96f8b42c051ee095879e4f053cb98eb1689c91b7cb50d73a15240d28a9f5646fa2c706d5b9d3b53eeaa12b74e8522367b266197c183f412367f17d7dd8d3500b9875655803d3db6eae3974dd883c0ad78110ff2b00761a4575832454920dd685b749335cfb2aeebbe78bbc29b45bbe06848f45c809de409de8ea034d2a059c6ab07e7b71c7031281a8d87a5ea6dca104a57f05a42331fb15ade10924ff022b3d8b7161fffffdf343142d5f0e51454c296cd4eb9b9c70d0a0abb7428e7a9bea1929717d592ecdae5a6bf7e3af70262cf7a2a0568860da864f60e5b5d5d54e694ce45d02c4dece06b523e01368ec0222526665c366a607434ae7bdcce85a0718ea5708db35356afb5067aabaeb34c499cbef3be582542bce431b1d3061ad45899f88d9d92fc09b6a5569e38a494b98122aee398172832ac747f60526b7316f0ace4be9478beb1f64ec4308ed0d30e0c426af623415c6719c224c36fa5e0807986de45cbf2e9dffe3bda387e65feaa0b732d250521fb50d0c5601b4f077d8d89bc66f3895408b20741721b3929a532ab0365799eb8351a779fc3f7aaba70b7503ab439a7680586e3421e8b75c5e51319b66e4e15cbae869a32637e32b77f55b7ff344f6f228c3ac653c73d451182ff0ab6a51f664792adca57772ae8c3b907e0a3355e157bb2286bf71b045acab78f43638169cb79b0900956f9d47dcaa8e7a6aa6dc507c28be6c3e45e824fe62935c4995f6e3bb9c3e8210553f6cd3c70d9aa119acbe9a4266c19166ea3e29af557aa7c73dfd18a9670e90016225b4e56ceea007ecb01b59662c858b3cf7cb230065e491fc00a62523ec3c06a3eaa0c0ae1bd82b0a4affc9df53fa026d0fd350cd45edac3c62fee30b8ee8bdb4222bd589af7ec1a88ec80e677b0dc585f01330caec1f83b20a219a435acd7a7b199f2c983c0b02bf176d473a5e5bf97bb32b48d64c4572dc1c2514188de49fe62dea1ae7dc2aed3faf18f4b21d0a0dc10431e1c52f79775d0665355fdc22ce2fab9535800d7f4f870855ce3ad33204d09e1186485284ebb92f94c9737bb28e690a2ca6b8d612e7b2ac04b5628556f1db0963e71f05605cba1e50c11cc32ccdcb2e5562c1362c688449efc6af974906863cfd5018bd0726ecb1b18f841d096864391bd6fac2106031f2ac45194fa544a06ea9efbd20d3ba72ba19f072ebc9cda0a7b41cdd3980a96db565619832f694823d00a5f87bb99e989773b4a4b24a81d495655b65e752a28eb660504576639096d680e55559dc9ac9c913e65d50900b8a290a9792556c1cc61a0f12c56418c9d481f11b09d377ee9b7568834f2cd7f253de9dc79bc97785ec82f4e541fc8b4a360682aa66beb17ea86e67468cee9de071b4489cc313a55ea01a6b4c3463a8b9e19139ddaf385de12863c3d53ec3f845fa74dae2c14e985d5353a270b66c1f8db241b0aa19beef7a93fe5641f8b516c7f044f60ac0113737acd4f5bbb7ac9759494db833a8c765ef318f769c1a7da65e46c2fa078963f975084a0ad51cb67853a0636313c0b9dae0db23b2cfa103b33b249b9c32c2f92e1585c149325e9ad10c05f862c3264b525616eb89645a8783e0b4bc1bdf198763aa5126fb43296e7c89312ad1055ed010bbccbf160b8ff31798a1b5a63da4a2c2bed8300b520185af966b3211081af4f40abcea8094916c819959deb6225fa700a5ca8ddd72feec956ef2b3bccbff8badbdf60ccff5609cc8fefcaac69ba09ded99fa18d8219dc23fd4e47b5da807d21d6af52ae1efca49b9b10d9411e157c1e659d18e237e40aef659b2e1e04698af98768c39aad032d6100fa0b9976bbeee3b3596f489005ed4527892fa344d4a23a27db55df7167d2a06bf80f71c2257964ba52fc3e5b68fa0c954b43fb00bb65870561acfa6402660461d83696e4107fccfe2d606c2a6650c79e1df5f247304b4804725e3ebf3d38afb07547347e52b13f597738237f6c09ff994839be7efb48182ff06318331c9de59a39cd63aafd35284f0b5fcb86190da4354c7cd183892d9a9a37da9dc63cb5799c691d8f0cbb13bbe4736db96039eaa56967d2a106f8c1a914d0e405c16d2442ef5cfa9ae1bb52d83fbea8840623bada42e16fd2af1a9685231205c77cf201da956037379c1f3623a3eea905cf68b449d2ed9d3d1d26fd7466a8c2bf079352b765089715b7803d13a60f6e7dcdb4f1f28e65fd759ee786b55f38555ea8e506bce4445a494f777a920b94c2b4149dab35a5d3d51dc9ce347c6802380c8df84c605de0124e62b68e2c926f217a70b89d44942fba6964815cea816154e90fa78dd8d971bbdc2e69616c107e4de9a4e631fb7656169789073d109057a7610c33d8d2da95083567194833003273adfaad9b115564472fe0cdbe3c8473ccb5fa72ac1cd285c31570781fb137f30459344e51e586b66cb5aee2403553763137b880b395abd70da6778118f605c4e1f42b976f6e3f9b046a0374ded318e0c96a0fbc64e7b43af425f5481d268e8218b4f90c80a63c338407382af789f4db786df70dbc1fe0cc4d54db576f00f84a7b6f7d8321e1691208685b923ad2fe83e3f1ded4044fece8c9aa2fda8ca6fd12ff26bb96fb9aaf9ba71e068d5369fc56bf5e22d610118a9a7d1bf61f1e2db295232187977c4aaad10fb6a0b7042016d2212ed055cd232e94fbdf3f1cee513eedd435b2aaa2b7bd6cc4ab8f0425916e232bd6d62b5e8989174e114b10f6a8e05a481c3d3fa0e48efed7c26944064e018814a2f6346b537da3e49d2b3f7b8dace4230e4e13d43c4aba729b7dfc27ed885db9f19c7b3fbfb53a7251128e1c9fdf06cce23d7668321b3b29177d6f213edcf753b4a5fde5e267164014131851074537b5abe7f55bf71e18a73a994abf796b4bcf0b392f5228914f0dde7b9ba733aa552f3268c507945c527fec186974f5befbd7234983257cba740a5b1db08cc3f9e217ae154aac5514e94e1fcd82c0da29023f248ccedb7ac86ba4fb1b90be3c99bd11e4964f5981af48a64958a791b58107b24c61555e024ef1ac0f90460be798abc24f95aa22a394e61dbca63ade851666e12393e67f62add16f06918fe318bc443c22aa3bfba94941a244cc99bc0e45050ade4df4e8d70523acd8ca780cfa1335a8f6b87d0d3d5bada2fcc3c73870008f533d1b516b43b50157936daabb7b79302868009350a65ee12f7e32fa9c52d18868063b2c0ede63f83a2dc976da969dbb2c02f55da304aa581c17d412a6df0516bb91df2f9203824a38806f83326e763816966e5fc47a256033f671b06d41368699bb4e8cb4b37fa3d91e79a9703939d7a50514aa3e2c444208314963c2092db7c669c35ccdf411e8fc78105424d9199e62306dac19e48e7add0e3dddcb7a361bfea8014587936c614c57599e8408af5c1eb9b369f87e29b927bf8fcc4ac71441e61c2336ae8d016c6cbf8f5fc2f3d5093763636fc3150f7426f647e6fc0db383e72c4660eea7058af50067cc3be66367e817e8d9b260f3071bc17b19b5405269acb4db103fb2b78497e9e29ee23d77b3b9c3a14c59946b0adfa812ddde6139d41b420211bfd651a2f4fc468d2ce4f583736421942c4bd7027d4aaa667f7eaf9539360cd8a67c05ca1260b6a4fe02d44c9528157c4a15a28a8e4ecf581fad51b1c282309b8f000bcbfa02bbb8c4f5d47f6497dd31efde29a99a0c999439d06d77d6990272e587c161f63985f00a285231b096a512cce9d0b54042468cc77c83b871e7a328239dd4dd133cd4215aece5f693b6e36e9b03d115035bbd006fd6e04fa80e93bb0107280b04160d03a62645836b36f17857e7920397a289898c42dd278b409934f9cffe02c9da8b28bf1d1bacd23a33c41cf00ac8b12499b6ce7baaaddb3424761dab4eb695516091dac2d118b171ec9db736895d27bc68a6500bbb091841939c38749500948eaf51d1f5a3801e56024979128c5ea5c6cf3bc4519bf1eaf50ac463c944e22ec74613db29ce5f7d456207dfdd5cf638d30cfc5160f13a1d9b86d7f2420c4467e38dfe477453491895a54e2785d0df02b07cea89f58297d4b796785f0fdbfde7cbd2db9ef69c05f32890e4c7cf33d4ed895d182ffa67084783b4dc797b71ed92418972e42dabf418beca3a34236eecbbeb3aa6c020c372b7028fe390abf376fccb7c17eb853d4fe9c1d818214864bbe8d9a32dbab1c6c60cfc3b178c1b485249a8a3078d2662ca82990286163172e701ce5d0644298c2a4aff2c50499c14af894c29ad114f306d8283ced3808e10a3dfd34410ab4b0bb6ba4de7777582823c6399847d854734fae489e0c8cfe86d98403510182be4243ec458a002451a5fd3caa64627dd5d771f2972ef08e893d28b7fe549060c679cfbdfd2c0fa7385b009570a4a6b68099e18c4a6a23335b7ce788a7879d2e67abdd239bf9d6899b7b8a2c7562628548f90de86bd8a51f158d699c0f0860bf0a7493c329dbdecf7d9c453783b3542304849f2be1e23488a7b0d35ce2e9cb77317ed922559b8b5f4b44f752c8f5eebc9fbbe8613d6a871dd1ddc3991060c37a25f6dd52774fddbf7c0185aa5e786dd7453b3749ee6dc9aa34233fc3a1b88ea8371621e30347da62646e102cb35a06f833a12d260c25faaa5a1758c5466eea4980463db5a91f3fa747a2a98918838cda54fc0da26c445ee35c337880cfe38dd5d80d3a468d8fbd3f60f389a6a07e9a980a228c56678d37f9d4622ea7aba2c7cd270b9585d1647f075a6d90f1de23cc555cc949810ae0b3201de3dd0d4d07a2347aa740ba5100eb948db43acaafca61d5327ca292ea0d153410628e74c23c9bea9ab0e65690e1d9eed15df96f25121f57cc9f59ec268257cff91267c258d8a56f53a168c05428f8b01efa9aceffecb661198152f9b4f8b99a1a0c5e97b98827add1b2e0fe44dac0f2fb466af4da5fb7e983c34bd609ecf11a40fbef83028098d109b831a67339811fd01219d98ab2fc92335866235660ba57a06624fdf4bb18b657b7a1294e6b9e2b43dcc6c1fde6c320d5c3d69357c2f9501d671aae0ad183192abc105825a526bc8f2efef1297956f3340a69c6b185ab82b9621c7b797a8da954f4ad82b1c6435591ce8a50b95572d576205d787e5d1a76190a1e038623b22356b5b18a01cbce5050134515a298ad37609a531625b4727e559ac0f798959b77579b674e9c52d658b7c810ed4de3f82baa282d2e61d1f2b2478e8cc691274130114290d2fe7c61d337f094dc2625925c1c76ae2283ee59d4f2fce060a1993f7090b5b8d7abef60d8e674ef6e0d70b7018e4602a745e4dfeb34df956d0f08086477a80489d49a66f9dc0f692fc095faa3e77c626956b9de892451a3f4850a9a06cd4cdb0024e728951d862380cc3e36030bf8d91be3e1b31f9575c72e62072dee3471bc8cd38564c51ef7e935741efc78a18dfc98a284978f02391f32dafedd1d7caf0c62aa04eaa5cd0cd0086d5d6ce99f2cdb90c8ae69478e2d5e41e86277370867f95e5515a12ee05dc75bd604d8aea529df7f740cec3b10f0521bbf62b46efa211ffd24a010a9d0e4b4629298bb8c05ecfd630c1ff3fcec5f85e5cdff430ef078e5ab0e81f7387a7b1ae36f50c4e3421a76b56b599e9b9071a9cccf27830aa24e967b20b98e99f8dee72a54dfea7f46e65a393725d021cbf219fa0d22cf84dec260414a84b366629477eb95508eb6e77ae06084f34b94c3b2887a394705f95bdf0e3d9ef8c9ae5cd6a5a57b7663577f9ff8981beb7d93d036310804bc67c0b4463e8c4705c0fa3f01477eb892da72ef8ead4d74f02b4f15ca6b325cfac771af06e3fca51132efe424bb12e94b00d4827372207a18d975097585cbc332387e48a789823f6d5cc6bd23b70aae1be0cad2e418dbdb2f6633b2f13ed02f6539dc2b16bfa05d4e4b945ddfd5ee6858e4ca8aae7b03b2b90dd0a5e07eef3e56de04d27484ff9bbbe111094f54e7ccb59366f4478ddaa955a3058545800e76c190c5c1e2b2d2e5a522212527d4278f6d5007f4a6916a1e7f9bffa8561387a4b5146bca8c6a0c1379f6d231736f1444204c6ca5d24b51a62797bfcd8ad4c43510bffe3aa74410458cef42085ce4fc22e5b29c35b628b496b77e6eda8e1343ab757539dcf1963872e94d5b6d94e2451bfcfff4339d05b6552c42572bbd781e09755cb585d93dbeb95a069e84588456337a3af4ad0db02957febae1405f10d9cedef8728807acc34c3224034cda3b91e31024703daff8376af36be94cee9e3b8134eade3b0677f13bf095b7421ce288088415203bb23ae78d4fc1c20a6e453d3c1bddebdf3975e1e5c35d06ad9e33399a2853eb590de7b10f2d053b443e45f916575d756c8245946d4808efcd7d9e94c54ae90db54628f213dd277fd245839c7b21f771b737db29cec793c271248b0ec73e1fcf02109cdb3ffdf2e24ca7c762e86b1410122151c48286fc86a9067a0e9bb0dffa8f5d5dc88fd95e6348942c6b42a77062d3a075356410f699ccab23d224b17ca4e03909713e89d3274a05a629f442b97a463adbe5f8d696d3740874c3b9078686a4cff14141128bdb13a9e429c92790d9d120241000b013265b23ef89349b5bd0fe9246e819aae75e2997647c8c4674ed793a80d912202d2ab47bbc347bed777a09d8d0379dd477f0041cfd53ab96d91351dd4a8154cb7c4a9b33f707b9035e3f9ceb37e7e9153936807651876f715b593c0b1863555573da2dec038d73a36610d4a8b99de377c7256a35cb1fa8d8e255541b163c83ad7091d45dd7a1d9ff8d410600e4ae38f172ee83a3cd9700fd2f4e5336478541a4997703489905c4be8ada7c27acf2c3efaf9312ac44f31d81dd7f34922e6ba209e75c2eed63d873c1c2578f5a24aa5ad72ec821f014dab8085914a7d4da820484af9f6efbad4bf95fe022683ba2e6a7d72c7f14822543c24ab7d3a9aa101244787dc954fa06b29848709cbcd4ffd4b672869b53bc2cfc2fa2c3c9745a8e9f389dcc9c5350d2d77f364d33ceff2b90a5f80d0dfe1e97113006485e34367d20b9ec76dc3be9a73c68fa5e648a263f74c844b1f202543fd177a355497a641bfeb3404ae339ab4df4d22ab1890f6bcc64145f15f58edead0f0c602861c69d69ac1e37512b4d19b261dd533dc5ccfa9ca055f1ff5813635d7fd308104b2c0612ffb7c45f71bc31f4ed3e17f1d5bb6913da56795ff8d2727c92afe01fe63f3a0047bbea3f35da4e25b6765c1921bff0d49d7e96ff006584eaa1ec318e37ddc16b3a74044fe16739c9c6a21052a5716f141506e47fd19394060570932eceb7eb662991afcb7939a5c4be7d3725bbac2b80abd1fc34b7746f35345e93a86727c35e273eecb5b4c1f35495370bb0dba45649470c5dad511f178ab4b0e5d9dfe5f8c0f0ab6958bf8d9d4c25093b6de4577ea9b2cd64ebe3646f433aca6d73ef41f4ce6b34d11d6c45bd24663d0d8e8466f5ac42314cf693b4f62da869eb565530b9d62564134e0ff9da81c48e0b3c875eb2a24bbbeb3c44facff4608d35a6ea7f970df76832a41d51e1d823aeed0309bb5578c08d97220c11bb4f0438e203a315a883eb6fca41ed4238e14cd074b42d561160571127c9813d6c8f32261645e16697036ed29135ca72e0fd1c6d30142cb7edb3ab9f871f4d53c58d15d0f61f4d5e1458067bc483f073552ad909a9ce48bebc970d84203ba5b7f8340cc1e3fb264850254447e2072de5a28caf876ffd53f782fbd6d79146b54e1e74bb70f47249ab5f9a9b14294924c3eae6cdf0ab01249061cd7264ad2268c94a11ee750728817a44a1e1343c8399531645c80a872df6a9cc2912206e56eab077551d4aa8939267bd05cf0ddc0657f52603de23e76a5c8ce20c4700bac92370230ebcf0a5b8e05c6f070d89ebff79985fe954509169070f4e0be83831c0fc36bd831a54d5b0049953084af249d2942ba6a5fbfe9adc8579a0b5e5d154380638a1a81d18c9161a87f5c6c1eefb595ba135cdcde22e4c476dd87d03f736edaeb4d6d5c23613e2c8e7837618a38f2b84673d6efe33c9e6ad3cd293bbe7cf89fb6f7ef0ae794060318122aeb02551dfe4153f42e2e8d2797939359663eb65c2548958d666b07ff7e960473828aa976af40a0abda0b77d24ee5f0ff42bb75da6e9b10fd55beef72abbbb362b441aaa6d8150f82ab3d8051aa77a3a9997e51e3c2c0405907e6180d3453bf89990e30c33ec2c063aa1f81a442f10bc74a35bfd60d540bdd957c9f0cc60bb44f254e9ce88a4d709caf8f999a5b87c28528338a8a4d761e71e69dd658d5586d6b5f3ef0adbc2b449cbf85ee7ed20bd239c0bc49dd80dbdb23a29363d387f12afcd7c0fe1f7de6eb07c0ea825f09f605481c4a1a09b96ba07a781a3a3cd9c43e57f8e839708d5dc70f20ca324b80adf2f02203dc7917dc0152cbfdc8af6d4f4e23cd13091ccd0d0cf2139f6fc232364f300145e077cf8db6196ad0b5850bcd5226970d8326e77a06a901da547bc516a977567de9e5b80b57614e856640ea7dd72fd0594dd0ea5adb54a0cc348b9bcbb43e0bc53bfc1ca0d96126e135e6d9c0729b9da16304dfc116e1c32080b622677e6069a1966afbf532526dceff55dbee41af30d286ab18388bc805cf8285da9f15b475794d7a122994dac8b4ab46dfb397f17d3264f52f7838fa313341fc429421c1a2f7126677806b588df745d9d101dcf2621f3f5bf27bff90312d55a4e09a65cea66e0c364e005d5f027dfd78efe7b973e557f0828d7cdb08717e4379c670027e69b0254f64961bc75ae2f1ef3d4724f9aaee2cf68063075e8274fffe21f384803f8e14503f5b0528ce68e2af3f87b9f60e05957e15f5c58fbdb4e309ea1e2563a9c2e7c8728e6ada0c311c10dbb3d6fb27e35498c9214b217f2b30cf4b12edf46140295a399a610d73a5c918c8587eecd431297d73b4ce148bd1119557a8bad349b22c1616c3a70705707811530b76d0de25e31e78a39bcae7c25179efcb75dd96056b66a2ab51dcebcc60e4d0af693648dc18a0bd38b9a2561d79c8f4a3ea69c12d912c2c4f27df853d92577faf2b3a01bd36d338815d80dcb6912ed25d331767258b9f71d5fc8dd066fe16d66866228a2dafd1416b46c70b2f4f74b192052083c7be45fb66f815edbcc6f929f0e5b16b6c96ed034a4439765951b380e0e43250960b1ac482da39de971522dc745b9f3b1824ca73767cb3084a330c0e5d726634aaa6721615c33dd8277ba1e9135619f26d93f47db11a2fc2df998ffffd1c565e77941831ffbbd2a874246d60667c3f783a8586789603e445e8089ed3f632ddcd0e199d1612c58814badd588b569988a9f63ed640c33c0f99f23820257765116029c5f9a5a7bca39748949f8c165f00d9f1db14b93b7e65dc793f303885745cbbe921717f292a2026f2ac92dfc7477abd06b0e2bfada23d01347a102e58fd648316b92a876b391d8d6a024c032042db355e197bc3f52ddf34586aaf1890468992583dba4127d4b0652a03987c431efaa541ee3af098b1091b8a1db7c605093144f62f0ac8fba465517bf862d6a5931f1b7a903816a7cc118962c229b70013a98d99707c68a3e99f8eb5659cc083663a922de982c43f40f44cfb00598497150d34a22ba7471cbc66b9dcef200f7ff196fc12d725f64ebf8d57b573946a994cbd3e087b1bb8c4431aa8c9bb3c8cae19bc75a9dd61a8c287c7bc91af2032a34fd3661fd24e1d27241c9ffb2b2827c03351dc7e9b4bf379d0b69e91dbd1d595e5fb414414efc29c44b5ff21ab682043bd30853e8c8a7106644954a03f82f8af2fea6e11d6bff71ad7857ec9661f232240c73284018e62f282d628cd6dc25b98460a226709438c8daef787b512aae24f2fd0c69db40607f709c0f955b78b4f2e30c46a97fae3572f193a2baa37ca16c104214c8ac1c2d60e959c15ab5e78d420b2f3dcc9df44d7132451c60700aa4011517e56f2a6ac0d18700ee811737c60fd2f229aee6b97f01e1feb78cc66c0a7397c1d58952994f2cc3850fcd1fa644e879d15218ec4c10ecee0c8a971f995cb8e617457b957d6ef6724251412148dbe14fc782caa23c2fdec6742275422b769ca4894d57f4e1501dbc10ffc255302eb489277a3fa1cd3abe54b8d2ca3c25289178a9b81110ec0cb88db7ce75ea7a64924e0e8d2f36a9f84e2327c3f24afcb5932c7878ebe5c2ed3e1a4ec63e251765a88c5569675f177088d698142aa57cf2a137d14dc01bc3293fea8a3b2f049117614b10070a00936e9e688b637cecd521689da95b07e9987171f7bf83353e74463b23919aa91a570db3cd86987413e14b8d1823a97df7cc9587fd207ab6b4313278a4b6adb6b7fbcac816c8543110b1a80c74bec2fc74812426023e3a0db3ccfec51b062b8081051f5e19c3cd9b67091dea21c5f08c8384797c517f7428c1459a1ca92a3be31623ee1c0aa5a2e4822772d3ea6b47e8475a2e58c07cb88b33e472e0078604fcd73078bf806e0db99ef7569392fd2dfc6bad588534f61e972bbb26259c57ed998ba52482a63a7f3357ae4fd14dc0f512ada7e2b4dc8fe01f12947076f3f1c1610c84661ca849201b86b11d93546e98093b471963f32a5a90b0102ade11976085bbd49439fe54e66089d8f871d9a5e8bcebf32436ec81935c26f4e29f4057e250fdfc0ba402771d7b76b9d8b9d37319af1c7658ede3033ad069d0e3ebd34379852025fbff9917110e57050caa3a717816b17fa2d8820c07ad878a18f1f1066736f22856d5bb9026f62a1331783e8928232e174ed10f9990a834b0208d6c63994a74d210c8d6eb2716cb2a65f2566a9986e6e2171ed1d7d051bf505d6c11ed2d47aff86d2d4ce001a7e988426dc2beb10426ff608a971a4554a6a6ca359e85781999c811ccd0736d5127791cbebc1bc4ce17c46c99129277329516f008083a691086b1f7f9a7abb142396c949ea1e4b0f91e9925bf6400685bb7c22e93d2042d37c9de48c4230fd076720149f7245155af122674f3625c10f56bc4426e8daf545e474e9202a3d27d2ce18a1b445db2bed89ffc1e0317485062c60b1f2c272eadaf35b44b943c6062871e5c821894a82ae35d9639a46b77a236089543794c1e05c43ac23de02044a2da4578dae51b5ccd702abd5808c3cdaea0b57b48703325d01bd430659717be14e05135bc290a39571baf6fc3270846b3a3cc990ff9e51e7169a79ef37aff97caa75ce49fb5acda1839f1b88e379de7ee6c2ff8cb85a0a015ced7041c152e02cb3c1dc6acd187eed26aa3a3e826fe7ff261c4dd18301eada05105f7af16b8432d14121ef6e811edb9bb30a18cffbb5c7b4c0d79f0804adff7e9fab2b0a7ce08daac1a7e5f3d6d357e9d8a7f49c8e702d59045dfc7f686869ced405202a0530ddc6720275b216e44b582f8b2bbc1527fb5694b2f6d493ac163e803f96e612ed8ebedaa4220787e0e26c407716d652cb60ab5a34ffcb32011708d4637a82a9a6d76dd98bcb4d4e5d30e892d9bd910aecdb7c47dc50d4f20012e4e3eff536615e968e1c331d83f64a8471a32ecb675edb015aa547bbefca6a8f47bd3fff7ea0305c7291eda5280450f1b0ef40859ab0e07e765e7527085adc3640a23f3af67e7df596a620684ee04367bd0b4a8d41cb428403dabfd72a29cb3fb0a7d0a33a0b6c49ede7e7855ea7dd219130081ce83a70f57e57f47e586567d283df931952bbbb7e489a796bc67049cbefc395f2c2ef6f289dddd692418607c9b3d9cd5dddc93ca749a877b8432480a221462735a0a5dbba8c6a026042bcec2b86155b80215acafcd64946c7346ee39c0bcd031b50b698c1995538c0bba0c782089bc585a6dca3554e22aed996fd1324f5a9b55971a2d9298122d5f006ae06287dc8ce03367763310ef3bd6a395286c05c1b00a432fa7c3c74a92740a854ac0052a9e346c89e6807737e602655cbafc3337396e65be08126ceddb727777e31d3b29f8081676de9d52827f5b4e935b82238bfd2613c0363fe8aad150ffb53f2c60e7f181a3bfd4f8abfce4a7158d90764015ddc43aec6c9e6e8d5616d0ab7875c6fa44506225c4532694a9460faff3227690c6757191f13f70b5156a8e5c10b2ecc3423d68d3515d25d9cc9be93cf21feef0cd72322968667c24424273d6660f9960af3d6dc3fed5769ddcb5f8144f1f1c8d123d9efe6b54ae4aeeaec5918d57de15bae0beb77e66379e7ded0b71a60faa71a73fc829a44abb01864fa33ca2c8b689fa560b858966d4136b751ebf79328d27691bcb81cbc3b880910f087753d81ae28b7d8590c04b50c13b1e2ded0e7904c61e8cfda06868a6f139f864eb87dd6ae7751f5d3b7f5f144cf69c1dc2a31314ebd58ef007a0df28b81f845b717da591d0902fc379416190da80aa6cc69c2dcab6ed2be778652d5975762c63e531c03a5a416572c5979598068c6bd5e34924594d3a827eb36f1f8cfd6d6dfcd65947020482cbe8accd676cc715d33cf99ad5d4a01db76cdb89f050bb3da01c4f377871e673ea39af43cade741204dff6c6c7aa6820957bc30cd0144ebd5c731f9598ffde7419823b47fd133f42fae14ce812dd128eede163c6852ff6b6d88f29270f1663d78970a0513d67801358355e4af54792c8127aec0b26e4422e2fbbb408bb6a97734eb56658ef1e806fda9efb131f1b2838756d70dbdb51a8d93f6198e45234e5b07f0a07e42549442ffd02550cf05ca7ba2679b464f6ef484a873d1b7b22337d2b76651f4b5fdb011297206677883803d49330183fdbe519d06533c13dda540ae7e8622efa9f41820a10545243f67c8ca6ae40f12ee54a13336caf77802b7eb7dba4a276485bc8f3158a4bdb5b4e50a3bca92ffea35b76c47016cf4ffeb978d9d8110d3bae9de4266541dfe7b6fc9c8e48c7eb8b7bb0791cd8975ca9b18377910050436491bcfc7c3a33b394466fd2fff61fba2597252b551bb03ed9ff3442dcc69eeaf625b30fa9d10efdcd38d5e452485f717269af2997d336ba41548e0c6855a1fa744ec00bcde613be2813d5f1f0fda1d188663699a428b76ff05cbfb231e5b6df05ccdb95f1c8972148b415d3820f0a974b8f11ce291458deee19084354df6ad3d2813d2e501a773356dece272dbc89504c8b7b9da7f04c0761852a7496522b403b2315f8fa17b9dc2a484eee1330ad088f59e3d982926906a292eb4fd56a2e0272d0eeedead126e37a675252420d4094b999b822b71357d8ece40023aed94d1055bdc233e8ad646acd532b6f4da5e90d66bf15ef9f9a2cbc51f984ab881cfc0f3231636ecfa7034836e261ed26b2f5d3381f424a25b00d8cba91f019bfafcafb6e656b72cfa6cd6243262d60cdc093a7eebcccd8940f7cd8824f2f21617cb55348f288d181d1e21ec89f984ea6562467c5bfbd8551c720f738dace1fdaa3c1ed8eaac26c99776e3b8ed70bb7799030b44905755028a994dce2170554a6f0d33a2456c4ec309140fdcd5d90a9bac4acebf93a40794a7d9cd3c3becb30d0d313607a349f79523c88695f0fe8db044acc479cfd9465a72d6d42ec76b64f0eda13548dca6d9130a0ed18d6ced9495ec0735208c3fd8ca0c2db57d46bb8452fbfb2ebc3e8718b5b2ce62b40a15b55c7ec8ab3421823837ad21306854c96c6decbfaa9b45e5c83d54eee32c8e03174f09e9f24a587deedcd862ee59074bdaa5a3e10f8f528885a1fb356efddf9e8f410e424ae22e1f3c8b16b9ce1084ddc76d8ecd5e416f16e941e759eb79c4804a9da0366fc07f1ac69f6b2375b804f34d5e980b5a10f7a0081d28bad80a238832b6f7f181f35efe30e64f646b515260b5d0bd0139783262fecd31b700bf0f43f9925038269923e4493e23608736dc85b037464dbb2070ae1a4b7788c35687149c3a7d9d2e47e11e62d33b7a429187b5cc40c369b68f43d2c58b5021b763660c591a3a32b0835bcb28d961a9ea910284083fe1acbbaaebfcdf729086434ade86bcc26fad213","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
