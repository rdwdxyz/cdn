<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"53382931340e64eb56ed510605bb402e0a5319ab0f20b489cabd5549f879ef25012db9c540d3de61085e2c67e45bee127d2f995db1bb06e12b159322e57e963a3f95df6336e1fb5920ff1a2517d0f5494fec2221df686a8bd9c1bb0bf4b25c031dbd45b5fed13f01d28949b82025a58f1ed80eed9d6a39a1d7d772e535dd394551e051a1311b87d68693615d32416fe72d1976116bc6f38f1adbdfff0761e1ae219382dde22c62f8a363378a5f98ffa47f7dfabd87ae6f12d50c5952a0e179fd86485f9b0d17012252fa853c1bcc44a87f49a0b0dfa2173e6ac2cab8d40194740fe03db6037edd5b84af9e16a601a3e572aaa20cd78de78c20e807c27069a89edff83e9d20d63113a0be3cfc3b2296a65518db23376e05cc0210a75ead82c4c04b06d64df17085580df63d6de3a3e0e58ca0997cd6bfb2aa51e7250b67794e3078017e5734c9011b5457ac2b9e5d1dc4fc29d6f864ad56a1c74e53e75bb0cd1ab5d30a3e1a0abbc3c64e9b28a95c2619a37e4360935021bef6baf217f94a4f21ab288b758dbeadbd0767ef38c2dfed812b214f5407b12f81925c3e092253fd3c8c66a2c27f6b1b347da9e5a920bc3043bd65cb035e57984750901863a819e02ba17cf9e82d4da6a2cd63f86c2e39d0beb3d70898d1655f633d875798a0815f7e53633ed0ca0168b7127d0f830a29eadcad52bb78afc57d0abd2f7d0b6970720ad05ca1cac334913b57423565b7a64b465e5fdd359c4c95599a8ecd0449d6bf0d3627df57ef45a47cd6f2229da6c21eeccee9938304d4280f0619fee4bc413c3a83cef77782a65797e434ae660f417137e84e7f1a26a8e9db60e79c92b99cd9dbbf224db4c816e2b1c1a7347a4f2111e85a944774c66bf6396b33785f73fabd6cea901017be1f58ba41a2e168f782fb48124dcbaea29c2294b50aae1e064db9e8d65c66a1336f44eae4435f5fe8dc6c5f96c088556aac13f3869e7d74ec67ed5dbd03e7563dbb82a407c977f258884cf7110acc8b56d3fad702966f311c918074e58330c60484658823d5edc00ace25d78e50aec8ac1976628b9c636449659f1b2535e5daf8a921b78788ff1d1f17ccd0002bfef6dbf102961b109fe66ca8a2a5bcfaffb719984972743f7d84d190f929c6f4fc20939160b5c942555adf21fac75430e44c866eb92015888460eb39931a76e0fcd1f05c49a32535221524f0fb93e99a387e991778a03a022767f630e5d9c0022c274ea30b84cd4d9f9a6df4d9d9527e4574185bbc05bb3e17a6f6d06be92c3bbfdd9e7ef374fd08afb4066b86144c1a5039ee8d84135355ad06c4e08ab675e94b06567b5e932aba0f4d97f8c25049fe20aa316e640ba61d4f2adc788110d2ad2ebd8804304ee2cff3d7ade7a5108778c4b91c2bf043bca2cb418ba03b44dcad6225900904be23f29f5ea760bd3c17cc354183d19fb318148f99666e9043ddbd74c8c582d3473e54783d0a26a63e43928de4890352ac51c83f241966ab36807ea34b604fe4fcf71f75e186fdfc62fbf3abb0186fd922ba9d3a80163da9f571317ca53ce5c0d1d8687eb4046d72c193b4342328179d1eb4e6b16edbda4c913052445e60d2b2e7e2fed2fc2477b65dc4c36ddd5ef2053d2321859dd632565e35a2995b3fda54424732efa65ea9dfba567ba48db9060a101fd42a0a5f6e2ba7e72600474308638ce043703b5f95a5aac2374e7115241f5dd1843627395ac4feaeef8ff5b7e4be205dfd8de2aff4c1450bd53a16ba96c0185d262f21aa3c9f934518dfeb6d6cffa67f340e4f2cc5f91a40c52acfe60c799f068b04e5e800fe39bb75c9b8e19cbce91b4e350dbdc5ecfd57ce5c0ef29fc8e2f3e055bed07f4c78b35839f6ddbf99d6cc001a34ec0b5738261adc4eedd937c85f2e2e224cedaed73691ed1f4ccd20757c4cc703ca1a2749aebbac39d1c46b887736f904a1e5b13f611469075a6092dc072dffff84d1063cf7e909c54e56a4f3e43a457c5dbf3417dfadc83fe30e246f4c9dc240ac8040f008f2d313a03c1631a63df8b1d504f285dda9e86d43d39dbec0674435a294028ccdc0782d326d163e56301233b03e4a6e25771f68fe095817cd9a288b405d7322d72c1124c68a8a5ec4e597ecc625edb1dc7d61c711be3dbb736c95fc2f347dfb121ea8c13c5bec8d7fbe3bc127672b5e9111f2646fc95b443a7a87c05b9a5e595a7426f99700aa7b170165256aad98a3cade8d4017bbf03b5d2873e1307ee3d1013f4f165f1b2ea1265fceea6e05bbfff388236a320f8031a9cddd4cc79916a7a332f00b477c0f9c7421695881f63eddc77df9f3b5bad60cdca3729022928d12ddf545adf0c84d3840b0d3d435ff84af962728fbd036884f1aa73dbb28f441a9eea92563c52888ae389932d8a1c06e891f23960d184bc88bde0a6fdde6ba6b27e12934935acd2616800d5e16d6e32239eed8fcec76f14018dcae50dca6e6a9fa5aac0196685fad8f413abb497fed3d51ad765d0f0e9edec89d089e12fad689d1cada360995a3df36730936a916d60bbdad1e8308d64fdf1ad68604409b6a5695119e717f357287eab43e8bc4680f0cccfe30b43b8e5edaa3c35e4cc373a137a7ff092240c36c6ee68f061f35e14bdaa8a7781c1661878d74007b2e6ef5e6f3708dff5d171652b5d66ef1dde27429e3a7e8a8e20b6bed482ed507ca151459f104a4070602568bf63b8aae647e757e22fb46fe227066f034382fd99512787a3d3d76eebf91981e703e0f8690cc1629d967c309808654c67e56718b4380f45435e896f431f3b9e8fd28fe204f9b93abfcb9379cd71855f7002e77c4045ae762b088497854229256ccd9e4581d1cc64b6e03fdccaa0e36d695455f02b70dbaf5d5082a759d4a699eefadaddd8d502b433a51d47e193c09e737ad9466528f8232d5d1104272b40b1f9a3be5dede559ef7e225cfa664dafaea1a04a9f3f98c69f2dfaec20220b2eb6fcf0450fb97caeba67b1bd9a8e2af56961d5a422fc25af592d853534428195075b084dca102a0ca580afccb815888b785a55c5d7277d119796080337b255191d4e74f2827611ee5b97b8cbd5c068600b0b2266fb3dfc3a5327b54e73ef30ff4318429c8ca4eac15ffe11378ac8e1d82a900c458e7dc3c02f2b269a8454f36902189c0ab5a7b965f657c455dfe89eb810fa03185c1e8cb74dfa38c37e424fd8cb4058055759fa47ee477d51b1cfc78595d90cf27b13bfc0d0ec0866a402bb42326eacfe14292721c6a5ada7e9ac97e443df575a1764944d69ac2bc1364d2600a3cf8032b8f6ed82888bfa5dcc450d2f3957ccc4135ef2a11a6ffb6cae807e6f1f6a7da66fc748a17abb100deac203634e69198be0ea0232b81084ef00ca56b3c2716c60c0826928ccf5e90ea1f38dda8027d1118cf9ee4b605a9d26d128c87dc5565cf015b46d66399019dbc9c57927a727d0811abce58bdcaba63b2b6eb25140a692b3620303d725f03fa8931242bee6219839267c175f6a79c415aaca78138592c9e1929e759ab2068c03c347421cc9bbcde771a12dd3a9e81827e3efe8592060db8aef5a6da365a6544843d79939bfb23c880ff10ab8f5288754034cd7e3b4c970988a546d96155a20b3e4ff75d93547a2f6f59212253b0ca397a0d6b1074562b7a856aa3633f3aa20589ab3d894a0a33efad0d6e7dcbaf4be3fa364b03574673ac328b78f89990ac6e63398ce8d594522aa6f583b4ee92be82a4685ab2228eb5eabcbe34300da2fb686e9c07b9c1a30a05cb6affb97699071e4ad06ccd43e48e168893797b45e46ea841ecccd2a0f2fa60086bfdea4f98e7c6b014691dc5c83aae7850185f3fbfa29940b20a8e5e1606c5738184ce59acf9166be29cbacba976efd7f6de4036675474852136e851b23f110a4c20f8855f881a6b51a605edc1c61c29e67ebb3698c3a2fbb0774b431a2ca3c7c2735520586273544ef37854f1dcb8282eb85c5d951db882c89672c4336e8e647d54602615766143cef07aedd34f85e78c856ff6d61d1c118e8b5333a81d137ace85b0b8815151a806e304ae8358ae6ed8925febe51a8a3fe383632006436c32445b87e0c45355d5fedad3d6c0debd47aa002aa86f107b7a66f17d58330fa8296f27e96acf41f3bc7d8e434dc96941180c0009bad0629bd2519630414756de25546eed4c8ef3ca704eb19a8344582c36815ac96e2293ce3092991fe7bca004c8b7400a561003b560adc6d2ec3ed6ccec6c47dd0135f1719abc5b91042ab753b295a5f38be537c65ab99805bce3a0e2c32cabb4b082ca35c56235e4aaa169122f91c06e54945bd448b12585bfd4850718bf55364f0732721523720e92fef9003a10fea85d349cbc048f112d21fa89598f8b3bc4f4fec6ea4cca270c22382f8831302078dfdfa9145f9f08385aefb20551f125d2f0e1d5b063ff1b1926d781bb87d787032ac12636269254efa691dfc18c38186aa7c0c0ad5efff558a4db512dd3cb84fac25affbbe7b4452fcc9cd233aef4aea3d7716d42cc43705ed1253beb45ded06a642c9f55474a3809bd19f98eeaf5e10192598b3a16b74544f8ebed8e8d0e8e658a9c9489cff9475d2be7cbf57c007ec8b98d4ecbefd28839a85396183ff60247f9a3d7c3a1034d17ae9d493196c638cb62849fdd4c70258706321ac3ada041e91ee28f232909da42545d2e385855dd15fd55829ae820affbd7436daf574f776cb9e0d4e2802ab3c48673b4c71cab0ce5aad6905c9208d6299289f66f551b9fe7dca81ce1294b295e91e0426f2c06d9e6b6387b7798a3619070168b6d220c74667c00f2cf6bacd2786e5eb72a5f9cf2b4dabe15ba0f00c84d88feb8eabfb407b58fb566ad92875be1014420ffa56cc0dafd76345f812fde88faa419321d3d1e4f26a5b73ffa0358ce8c95995b6970e29c0c23cc1c6599bec17b0ec7fd53a11b9b91922877386a563287e767d42204178162090ba33ffebd821d865dcbf57d2d80b508cbba654a155d04e721cef5634b7d045f4a4fdf5e91a7ec927823f917db5a39b708681841adfd03617aea0c196e38618aff9087ed7be9fce1a3cec5a1c8a2864b29d018952972776b767fd04140945903145df3200769c82b9c31224c648cf99a035cca42456ac2f8c0e5a3e00e3996942653260e6ea38ee8446f4491cf5a6e35433a8732fc00ebd35c1b403ae1197b070c86fa6bf7e6f2ad1fa03c4b9edfee6ad9daadfd5f23ee55a7a51486f28a66bbe6ee6d73dfc340eacd23801a16ce2243d762aa522813b6c7c3eb0a749fbf621750f3d5f65b1424097711cd5d2ca5e4dce7ad3c2f86f457bc1c6939166109be399bc33721f4567964ff823386eb971249eb2d1fc2b766f5aae8fcae9c6fe386fb6656975cac6e1cae1db9900decd1a6b660e8fff31353aa1f3070f810f2804802d42bf6061fbce4a5432f239b154a9a337423ec1d0a59d009faa8647e905499bf76a070dd581f0c3adc3920fa6749fc2e3d77e607c63eaa63285bbf468d9f44ca0289b6740ee0c48b5a76d8af464f7baccbeada6c737abe550305a61cbd1e6ddd1b642f8635660ad5368c1995348be6514e98d0c1a5776b5a211740ebc576edad204d25464539550f2d919c743cad0bc9c34675d733af6f676820587f4d2071be5da02fc1d24b4fb0170458eca888533ad149c778dda9ea835a2b82b33992d1cc0687520ab3534265ff58b832d3302e991f775905d3ddbf7ef581f19e5eb95681e7abdd8bd6dedd448f069dea52ee66095b1f865d5fdaf2da72913135c948d7b49096beeb7c3630469e0f3b3983a0ec8631ef8ca4d2810eb30d2590ccc7a767818d530a168e7c6000ba95679f507439d09f30d8453c7b6ab1b076cc95eb538bec2c42a67514cae3f8b6e43e6bb04f7b764bbf5d39b37e00f9ec767f86df215e736865698ec8e9c1f3f046157a589edeec176d6f8d7307899cb43f16b2da61d3dbe09f2e20d8c89967561523cbf33272eec372419d5df25686cb861b990741486afff8acba9e90c79a01abf9b3f56291d720caaa14b2baeae8d8b1ea3fd9569b56791553d40b7c85c236aff6ba585846fbba73f21bb93da55ff3c47456f5aee8c06aea362378d9a9a859cadbc03eec2ae0710f80bbec1959b899fc1ca890dc4956bfe061c5c56aa8dd72a3356ed3bf1688af293e04941d6dc8ab0bd42f15174be40ff303708f20f4c2f3398c34466743eb548103434b225329a2168a0d82200e7ca02073e9505518f17cdb6531fa7f7f434fd8457317c1cc5ac379eb96e31d81b64dac2deea08c13323bfe5af393dce4845b1d3641239eb7cb8233f544ea8154e1e16fa630702637e648407b9c255723f5e4409257f9c14b399807714d3ebd325e2f0e5ea1abeef29d6cf846474d0d3deaa152c3755fe578f0b5a4f71855d20cc3b4f3d2ca3f4a19bc0e3895273cf4c6c4238ef128de86c1336d13a95eaedbcfaf54f01914760e32a0ce6c756ce99f2c9a28b1b65e9643e6835bef36333e2a651aa48434d9a273e312fc0a7d0deef926398e3c37afdc9d1a284019f3684b437c034b9e35ad328c37929f6a7229f42c3251965f99f180422727d05f927c75f733a0325d5c01697d67f980592894ab87cc65e998d189e30551bcd1eaaabb9f28a3614254c916179de2e6e8eeb9d182aca535ef7a8b0cf0c772bb3eaca8a54952c61980cdc22200cb042743c685ec3f3e681938cfbfb9232720cc7026a251ccb940740bde8840111c590a459b98cebabd903a3199380ad2b4c631dd6d108cf3f7fcefe047482e10fc3ad33363c7d548b901a16d289e48ca57b165538dc4ea5f3de88d6d2d9bc7f35cb38a274dc80c06e385614eecae15bfb2a0ce9ba1fd2d4494e0e77b9ff7eea906547b22d3aabdb0e9ba8606968774c0370852f4f46c07abec69528f67f9afe503796cf8167b754b3a0b6be8541398503137030477e011d95755ca98aa3e5db297355e30198102f67eca2f7fbab98c4997754a17c9784c73b020d583d47fc78193efe83787aac11d08f6ddbb8a83bc80044472f40a1e5b6ad39439a36dd154f6b45ac5d38f90e5a6ebad3519a63eefe7f80e6eaff14cbc2b6fea4c0a5257d70cb3f018f55c15b4f68ec6aba7b9343bdd5f42a2e8864772ed16dc21a142afa6be80560814acba8cc9d22afbec6a54bc8e64388710b9b4cf53dba321c7d348cc5de2f189796305152a020be3a6508f268511ecf29c96bb1261fe05a82cf56cf99aeb33cd6f5bf655e66f2ed71282c4315ab2fe36a75847bdb4db8a9395489d5d65f0462a3e7ea84d43fa05c84ad1ddefc3e9a1b06ca3c06a98040acfd11dab2d5f7e30dc175f67b6eb786bf26ba03e4ebb2ac41c29b132c7dd004fc777fbb9381db54154ad0129198b57f66b52a530061a753dc30261e8d82350dfc2e2ab69e0f455b676f2de50546e998fd83a5968a0245833201b7693cf489d7cc1161c9295a032b8c3e014edb3adbac10190111d303c33f8448c4aaa312bc52b181b5a5864848c44f529c84512489e2a14b68a1ad18f3fde79417d4b6ed90000500004ec18b50a708a786e40d2099e1f15b04deea590c35e5334568cf11b7434c60d2ed0dd2e77eab064d11c7f01a1ccbc4ebe8637b75730cf7ea5cb9194432e3ffb9c3dbacb39029bbb776c0f6f4a4595a48ab52c7b275d685da8323df7582123cdb23d43d59e142fcae1fcf7fc37a7718cd8ab1ba2761daba484c0c33e4807fe5c655bd6ea2032ea20dc40da77a5b0b470d229b208376bfa23de8c20fedd2a578dd3cd66db5827eb0ffaab6649e912e32bd166f1ad66c436f6319ecd1551f0dfff84f7b29c117949fbd37a705cfeb2cfa79b819c93542552e2e146359d7927503425d5d220e39670e86fd6ef949392ec4221457e65f570bf061ed4a89074ab06694373fb7db40db2f241b8626c87d57ddb493571fdbe9a420dc8695e6d0803a9d2c7b822429e5b997a199483617859707397cefab8623a0d9b0b0be9cddbd24e723ac749679d59f752bf7b459a9180925c15acabac9f0fa88aa469d80828ed0d885900042446bbf5fc733a6d9a18dc2094423e993bc8b325ac1ddc5f903b62185b21058003aa69c66206bfe1fa1106de5416186c1796b665a7928e5aa6618e824fde224d9b67d10926223fc359941fc26d5eb8c9ff22a3407e5294ac90f9bf99c77bab1d6a5fdcca5a5b725a4dacdead871a980baf16d5c35266fab12aee867a0a17d86a403bcf2dc4ed9fcfb93980f4f1a2bae0a67580e92a1719e7b857238c0b4636fc5d2b66653d2e8114974180893cbec5281b011590e1726597502dffe4e6bcec863a29fc1deebb32b2c0fc95b09b343925a834a571b50cdc3b5e5a3fbe98abe6f57ea88008a1d043e1c135aee10c938b94b0a1c41966847251d7e4947475e83f4960de9611f3a46b46a806928c4ac56803d15219aeff371d9a835d650fa1002f48f2046a4f680073502eed6277cb80b33ac3fb2d29b8a47b2bc678167001f97855ad9c4fb6cd70e03ae46c31c185fb789cc788248ae4c43bbd1e8dceba85d6248391db94475cb335cf9ccd73088d39420da40d1eb229147a3d6bcd043054ebc2a88faef8bcd5a9de686c07203017b4963a4333b716776a1128f58d8ed105483cea1c3cbdf00486b3efc7c2dc362415c683bc48b74dd1edc1473290c385c4ab85fa8dcd516feed6505cd67f0436c66a110cd1e10af95fbd53aa98606128ebc10cffd9ba952c2683fe837d9c4ca42bc8ecb831219ba8eec8d6c44a12810bfd7ef4663b26cca3d53226a6d35070ab112c0af1b1c3d3bf8ef7178c00a440a43c08a826c7520b443217ba4d3a351bf912a562600a172496a21c65b6516fdb590613201e27ff1ff757741e7fbc2eacc5abaeda2640a9851e2bc284bf0b78e352068dc12e895420834386990cf8532efbb8d6e7f495826e58939cf6e70a3b5dc6a8aca13c1a4e6621a8f122df59289d01a52923322c5aaf18cb57a5da1de66e3e637ed3ab090051dc5900a4632c84c29f1d60f6541f0728862a217e799d1784586e5e7f9b09fd2de8dd0bfce76ea77af1ae00dd83aee1b052633186b0e832b373c6f4db13e42f9345530353a8a338170aefed0cf9a002ee7c7d1a5cbe38b0138560e7edd56b29a93d1e6f15c493abb66c392f8dc1cbb608783ba3149298966ab0ddd885c67f58a19def1f8d60fd23d2a58016e2929cd4e9f6388bce9ec034789b9f0fd1019260a5553ced2a912d8a2fdbb31d373c6a2cae966498bb837223d640ed6acefa31a7e8ef1bb25fa51942bbcbf2e4fe232087ccd4df0ea754b20752aef3eff8ae4bee7e482ab9f8943118c6db61961d8cad3c437fed7fcbf9dd25e0165177890db68899f82c3609a1cd7f795ac8a380c0c9533aacc5a7b001e189be06881f2dfc4660d413c84608d405b37954599ba3786de1f216bcdb9cb322d2214aeaf3d84d99f51b05abef257c9385d7f5a2a2b5d6bce02ca318674f24797c23a1530a8a0bbffd411f78a7059c7da00324bb99da2f5a92480eeb169f557ddda9203749c9352cae99384547128948454ead2ad8c50fa1b5cc51cbf7da8ff9a5ddced65e7cc0ef0ee2a71acceaaa2befadd9570691ec734c1eb5fe4ae33b19ea23d01c6935b1b21cdda0118676085915600aefbe6c5e98838e0ac1b7236b95198b429d903d829b080d4c5352e5e23d01cda01e43b1abaff0136c6319e29cf3f011f005d99fd285a35fee3fb43fa4e1182f8c7c82441c2da4eae3e85841279b41f584b1fdb0db93f64f8121e1c07145c67f04e9e9304f2f36009f6923e0ea6d6417fd19d09a687ea704ac91a437af9166ddecdd2cdae217c64f22d40f9790eb03bb5b506571c41fd3f64bc36a9b5f66a9c6ab8fc4b2503c8845cd4a24d3e589a4f8a7b8b1e2e8b1849b433cdeb85f93dd806cdf97374ea69c6bc30d1f8886268f2899a86133401599af32a95d4c9bcf1a6900e18ac361dada69cc868667234a3031f0e476ae6e315a3573703a1fed7a8432538869ecacbc2a2f4372a4e179f4ec7d61e776e19717e90f136faf36da7cd3f7762973cdce5e167a88e57e0693410cdd47fc60f7f1da1053fdcc1ee489342730cfdf1dd53df0d4111338d71c324b716c22532964eee646a8d7b950c055fee4f6ba2c3b32e959cf2b0209d854d92d6c5a92a2bae81671cf7e150a9201cfe34a99d4bdb8a4ad9fdb731840d1881e4c20d6f8c76a354973c37ebc6a4980f4aa32e7e69e38227073c4e687ed5b3db10d1dfbee2f29b985da25f381ef3245fede0ec31e3ff320ac77633d4e4c85ca39409c3365b41cf5c6c572377c10551e020539414a579cc90d6b859602b3a3e1b5913c091edf0e5467039c66bafd5586fa73bfdee961d13fafb908d119573de526ce3877c4ace7e4e32bbff78cb2cbbefd48f8e76396b4866d830e86a05ddc5e668275d07d65619a8f74e7662e915dbfc91efcbb4a40b68ec245eb680a23d36a948a045c8fa1961c53b9046174bb857c14b66e49a0e4362aaa4a4280b646dc0275820e4a0f29670f48f6ffaa67eb5895480d61eaef6c6ed03b80fd322f07daf21f822a44685606e35babad0d747f7213b11c8a0e2b4ddf4cd926cf89d26d67a5bcd1060ff5cf238e4bc0a8a8fa2a377a91994801ab1c4d3d001e6b67201f77fd79a16e6e7077767b74bbc24877f6600781e2dc1b08e4d3fa78878f86cda1abc639ff1bd280dca78eadb9bce3bdc9eac9e777c58f38ce9635b9c3351a3ed249af1abafdb0b50f1a18b2265a8431417b05a010eda0cafa349405e760f7f42693cfc63fadd699ef1dd817e3134adb79d77e2f1b0718730680c143d6f64b5ddae9a4018f88b68538bf359081669c7e8f20dd7d32ad559d06c235e3aa1013724ea2d33e0b65b828bda85488e2f701dec49ab5e8662466269169228d8f3e1f493304236405879255b710ea2a649334550adaa84963a225cca943628140244515f47218b32701737442cc1c917918260d03cbb28a53fa52600e1db4faa4345f9615886ef5f870d7696d11d24ce1f7cc0393ea5f65a3633fa69b122a7b21389d7b64aebb870f21ef21a682fb4992835b18b006789b80216e6d62b0150bdc53fa1fec871a02feb0a9871253afa933fb404cfd0f6cc1cd1631020335f0a18845309249633f5ac11b0e34ee6e12ff32a0d371dd1730817700c50f832d05c1aaca8d89c2bcd9e0587dda157652b524e59197cb2c986ef36cd9a5740024b889aeb908d180a264b3479c29398f746f941b64cf93e6e97a5c8077654ef6c03c5b4cebb24951359c10a4ae2b675f6d45a2ba77f149fa7b49acda81afae12d4edd0f415d56737eeaebe05e2c62abda6b08d0094725c498d540b65aa842c5521057cc17d2a67dc94270315cad87b9455ed11994812b843d21319f774e672a25236f671f95a8609c71427dea865d1b64c63f07f2a3cc3a409fc6cb563318dd2f519025b6dd7f1ed2f0cf5fd4660fa7fc42265f1ad9655db1285ae386ed97912adae7bfe505e5c80df498d0af4f5ef3e01f6709673a87d923a1e33c239339796a8421669a70b0b933f3ddb816599383d112b0ef439ac021c07159d2a20ec606b6f963154c8013ec5222ee691f3a81f5c2d3c7ea553937bbc95d480a9dddfa4e59781bcabf83efc4a87d8ccd46998d06fb621d2ae3a711c3a0bf32939b38ea97eb7abc3bc0b47a530f99ba5681adfb10dcb3a6e90d937b5194f75aac8e501622604621bc3df15c92f082e348149071eeb09920a22fca1a4ef931726ac544e1a500835671d9d2af60ceec82d7dcbdd1c80439eb4f828bf6bb795393caf8849c3c460e36f268f233fcbec6079b41cad3345b53be68ec13b33faea864ecf1b3fe28bdbed7984e8c1181c089903fc36d7d77d912606064dfc82541fcf3d291d1d7d09f3d73e6af25f1db4d0c5b95849be4c8b9967723c7882e84d2b85416d231d094797659980d870fcac8c39c93039a95798e35f0f9ecebcc5bb4940e6806b0a46d85e734d9554b9862d581d066baa082a1b4788f867f0b295426c49419d7e26b59f8f40b1a7076040556a35617616b639ce697765b8fdcfde12f2ce465fbf4fb7eb73dd60e73d387bb1e68431e74f20d17f85ebce206001b1013520982f676a0fb263da6ae26fadd49af284fcccdd818029ce10a4046848643aeef55f0d89f745f95654603828199c3a4e4c83601e609de6ce4f30672af78d007250b3a8495b75e31d3e3c078b36047105377bce14bac4814fd463c5dc0a8b0edd5518c4b4086b437b18d44fdea946730c663928fe0fdca8f00fff33ea2784049ec08a7f9a54983d120eac8308c0b7d10dd946a2190d1c8beb2dc6fb677a57b7fdf628c878fed875759c7ea66a912f2c4f052053cf9d65c19209c5021d4853c1173a08cef3a2a9be3d0aa7f0762956abe281a009166987eb47f2c879c3b9f3105302d581debac9f74ea3b4e3629cbe25f8923c73d4503dc6a9e1a00b4540c9494c80631b417b0ce0b93ec4d254ef146918bc31c94851de0f99909a8790223a826cd9722b2378bdc484a6ab3b9e14c11a62c6ac3a0239bad000a6b9e96ca2c35218ba376493179c54d124309656bf9f36cb5acc7d41bb2e77e77f68940a3a0dd7d5f63ff4fa39e28bb327ac948629f58abf9d5e474402ca252e5a5696d0de6247aae3c94dea3fdfff600c923a8609ff65084bee578a173ab411e94cc8a41919ac5d7b7cf98d018012867130ce342d5443d2b6ee9453defe0924c4851c64b0efc5de15d7b82c31ef1d0e748144d2bf60ca4536071b35ac5e0042da92927f17a22d7e1ee739de23c855ba02cc265eabf286a15f3f1a6824c7c7be9e8b0d8f31de87300f4f83e899dbef840c1d417f599da00d1ed6037808f974be06ade4e5095017179fb2f47cbe7a6c1c875f8eae57adc7d8ad1f330744b8791834d769522d30b4097c4409c6479280023bb291efa0cd5b69356033a4233c0ce3800656715f746ccefde45bf97e697f5ebb5662fcfb808f720c93656c1bb2caed555c44ee28762a44d7417df76f331b0187b714fcbbb60e3818fb6710987bdce19fc83b828d6239203cdcc4a473f07dbb57d4d4d0916dcf42f3ad65e60d3d14efdaf2f72d3200920cb41f6eb584db2af0e3a11ec4e75878e401314f0cfdd7f874b7e1d8d3102f1ac1084c0ab274fffebda43869cfcd429b9829c951f5c14615ee216f2f2566b96456bba18d566773afff76b8d16a2231521e608e88e83d0eeb712d1ba62bbbcf70076c8d1e1aaf7f4acc5c3576d57a9d0a89319980b8942d3a7c3e440f61a9c8720226f5680834f0fb46c7088778d0128bb67a6eab225cc4f424950cfac19af3d45cc32f2b40ccd01baaf29f9da0a73de1def4beb1a7cdb957f3d9fedde6d56ea5aa280a331e5af129e7f699811312baece3cfeed423cd9f6abbc21820492569d8170930fb39a93438126e23ebabd33589e4ae40b2f12981bf4ca4269c0399b05c926c484d835551e58542f2588448e7950206d0dfa2d7ccb0b8546e1bc33f1394f5adc8bd1d8505ec2f0f64e3672ae67643854bf8e9de4fbd324b593fcfb8adc474201d9e37fd0ca7064a1800c08d67cc5a78ee00b2c86b2dd75dbcc1c6455a64a08b27ae5414bf4cada56dfaadfb89d325d5cd9df55e3880cf2d2ca9c3f99bcf77e28ce266742d5dc1b4cc5ce877e10239e2cfe0d55915df4381af3a9a41d2fc9483e17e29fa4cb07f5f67f937c856f12bb27b9a16f3b2b609c5a15166ecf5a793c47fc840d6734f7fc3d71cb876569f3ecf77c166788c10bbbc8e91ce452c6d7e588c1e54552532e6a217d49e66a6d7b5ccce6dda555c722d32df9ebc897cd2bccbb3be82a00c3e3b28eeba3b2b8da2c663e74b00aafdb07315426a438ee050d8a3496fe901061715ce46642885d266469dc2d9489caa9b514fff50af0c0f2c1f3947bd54b87023703018cad1598c6c6e610184f6d9737770d197d78b23f497df68dfcfce7faf9cc92d36c764dbd93cf4ee6ec068ea35aff4e1b31477bc41814a83f706503cf95a2cac301ac9eda938944c4901cc6c77ff252fe39bfba797cfbc6520440382097d380e6078da0972a51bd18856d30cd23cec48bfdce6f5fa27cfd8009e61dad3e4d96326e862968ce5939a583dcf0de3bce2db52607dfba53c15a487f7f04ea918263856e8fe87d4684aa8260b8f8a23c869bd2f978c22e8adf5a14634491e14d3ffea544616a09b44bb3676c8a43b9edd21c1b6a21f0a69e826d3ee17265ae9cd93ec81bd36cd32ec4751453f6de6544b8a056ea1e664377a74a649d7fbcc16f14f6262fd4a1171b89ebc7fd1eb97842dd655e7a40a0b9242d760333a92b19ebbbfe24a12b5b90dd972a0e1e2a6504cbf85f863f622d8d3505a58817dcd80e852ecf387edcc956a2cb92b024e09e8d521f5ca6f8fe9a04a85e0e8965e3415125e7212c379d55df9dd7361d150c4839d54926376ec50facdb0a2cad43b53c1041625ec9fa86be30a4c396db558efc2f371414520830d53ddbf7d7b66972c2f64bc72f9367c95623defb2857deb45a0a687c4b451304a447c4cf1c1f9b658fee808a702d968d9e4ae87cc971ad7abc3030142b4410edc6a683759fb330e986c9aa0f0c79939249c7584d14844670c6c02066e3930abdfe170c61569694c2a04c08eda02b33379a16e23fad6dd3aa8fb281a80056ae71ca003bd3e53537b74afc0d1d7530812e51914275a1f83b2288c115d45b362b5d8e8419cf36ad1cacdb0d04c831446ce663f7bdee74695a5d9778657734ba517ef656898ecd068deedb8567ca4fa05c2e19d0dbb095b15ce646affec990a703b187a6bb2bc96f5bb8cf695ad16dd4499d6ad4bd0a8111e86a99c72f8471c4d0de03087f07474efae1e8c7b0838c899e94ca6ba112636a9e08830934ed6d781a65cc785afb851122e2dcac7f46e5a7246390fa532e08c65c0089806f258b4ddac8b2d8290e606a113898aa05778dab3aafce16ccf4bf8260116c3dd9e8229261621a08e8f4eb9966b0fefd81885472ab1ac142f483b38a01fa33bc85cda059232b17dabd70792e2389360a30b1d69d763279320489d9136e13f44c566d06d6d8aabfd04e02b3613ee47a76e6fbeff4e94fbbd02afa49ad3ec32308fecc94347de12762af4b55c8d587b5ddd8287c0cfaf60f11deded6c123117924aa88a1ded4b63c0cdd7db0179d14e503586cc944e20aca921dc15d430aec201d11bfae47501e18e475dda40d68a1cf0425cc9521f950d1f9cf1865cb9d7e27d2b0bfa09aa74587d80f35e87ef8dc265bd0a610fcb06863ec3c3328d5c8131564798c2adde960d8e4a42f4f1e35eb1a290d8feaaa5052440952ca4d03294b65d305d881fbc69399cfbaf14f470d07459e157581ee3cb2672bf40ff9cd4588a43692eb210c9401edb79293a2b673cc98e9a054a2527f2c1642e66f6274e98ead6fd808263182f45f9128d6d563791f00558dfeed2286d7ff47dc16d13e72263aea162093d58a58f6045cfce5d1069fbd8aaac5f23046a5a5cf5e5a6371e57cd83ab1d27544afc004d0f214c6f185e64c205b0c81c16606692b7d2effdefdeb8c1924eca0d5aea8c259bfcd28affa51f9f4f3bc379ed0566428ab7b90956b0328164d6885c12f954eabadf40aa30b4dff10564ba0190ec8f59f8aff6b14180e65fb8bbb8fcbb907e650246e6d5e4c69090910c4de8f902a50382647f508ddd3a3622951de5155d579d77c40681944bd45335b618cf8c1302560cb97f34d51c12f272fdd456e1b86809f7086564d86ec99dbc8a4c1ecef6bd6534327e643bae7336e34152e825b929443c523c3d372c2cab995ef909ac80133dfb056205ed0fcc871ef341cda27f73d93d0f7b0c9f2357ac0ebbf96b88ce1892762de542fce063e67727f9730ae5f9c45ae3d30a18c09ea0ce9dfa48ba266ba1615f9dd7a15d947ce2c7c63f24a5d07d61e0ff4b9415c01970c7843d1b47b1980e59e742b3c78001830539b67af4f2e92b29e9de08b2814549f01041821da8f6cf40adaea4c60058e6e7524e438c9e8166af900d405fcbc84f8d915a418346145c6a3c3f0a7d3afd3613514838b9a433b8ed270c58ea63b8f6a199e27641da4475b533d1d1affc88be7cc9a997736818baf089409fdec4134acbe7ba86ba9adcb5faf9ccfa30c1e99b89141eaf85e0c1fc48a412e2cd34daa37985a7c5b426e2cc58d49cb01bb563cf98c626bf5d882e9699493cb27b4a4f4f8fe57afdc8cf062ffd2e9ee6f07048bd8e20341ad19b2d8aba1d6046c79a56b83a8d947a71b2e9223338d7e007891536bf7d5bd6955c255a46dbd3007fbdb3e32276199e31b66203acc51f043b063262c3cb157ce52a5e5bb646e12a9815ff7a029ba7f60a069ca457682bdc374573c219f996ffbff56350deccd13318de500c82466878e3dfb09bdac1f429e4d43783761bdd48057f8d393c77256b372b1c8d163a847386b34ce10cc804bc0b41773ba12fe5aef9b0604a37a19c1d018af35b02d04b57742f59ad077acb3945a09ad7c439e215ba0148e356bc45958fe4260b1ca1f42aaf22b1d687fc4a14103b2168dbeab1cc57a68e0b04eeb5a358bed6a550a895e586a9f89531e3f462d3e5cc25cb0be2633d9ad2fffdc9afc5757d6c75578c90ed0317cef998456196534600ad9df6a5e7d234d2c5da4a91f3f0dcd1c73de3560019b3d1d7d17c6b2182d7f454010def866568495e1419a173110d1e2ebb3b56a4b10a0979e4bed120a3633b8db98a60338d7fa620d947ea1cde95a0aa6331a7572a69e145ba44138cbd3f47c3823c7588423602950d1d9bde44895033ce57cc4234ba3370dd92c759c68524bee6f6ec25e5b737fe02ab41080135a9c8b012c38b1f1ef9aeba966ff45e570b59a79a9df21c753b042fc66ca242b61a9794f8f39943ed47298c5e4b960296d892c8556fac4b521ca955ea8e0856e7a875f14a14c491b0c08943241662ac12cde507a28b90a46a3bd54c6da912e64a39417f52e37888cb8ebb8a20337d4afecd40ae5567ae652dd59d6fa966dbead0220f0fc659e8ad1d4f523092f1c6e7fc51795b9b91d122534adf32c0c041004c3745a61e916e0db9837682ce338ab48acd2e9db1ed6e461d332705b14f4dc6bc684189acfb4dd294870a33698691cdb48b5a1ab0b4f3a990424cb80928007dab63e8786c950297a4c1060f2cd79e7df549be9587e3437b3766eeee09c6728baa2ac7e16ce6866e35c0690e2ff2d5a2cef589d37e8a64b4feead0d3e597566aa45046dcbe4352d2073682dae1c32b602ecdfb35e4033693724347cf7912653e2ac85ff333c8c1f33975e0d1c55be84d1a74effbefbfd6f7bffe03cec7e325d7a23699638b5ada71cde70fb91b1ebbc1dbc4f7d0a3d7f9852f9a0481705e6a1e80948ea838b0f4f9a0f53766dba404b7cd40605a96a336d9ca8ee1fb626ad14f9d8243e637c179ee1eb62073b074cdd24b05d45799f44040a371ed804f6353d24d55f02a6fa0b6d76814e6f9132790eb9f1bd0a212e1894761a72bd2617781695b7c64bd8ec3b1a87bb147bfaa9ea6f7bac22bfed0c372695af0cbb62f5c03260a65d577070222530f53bb746c7e26b38119c72cba2b145c8a65af08cd327cbc8113cc23bbb4944950066109c522023a01cc2e1dd266f6e59d3ea7b895c2b6f0d6f9c1827e0f0e235edae4c44a3ce15079b007a85493846f12b0850ef965d236b508548a1790db615e24d38fe0c629d85419e4382928eeca72a9f91bbfc0b510767b51db598a3f394bf390a98bcd946761bb48d792be22ff6441ef26be0bab4cf94c488bd95bf154f75302220ab59c09587525680732033bc44303498d5395a2c2e3d90f75bd8621d2f342d13f8987c2ba5137f4af32ed7a7cc805242609233fa4380815feb624ef40483370930e184fb6fed5e98a426ad281a5f6c642de5785d7152de27e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
