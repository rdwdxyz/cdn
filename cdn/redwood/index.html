<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e34d0ec688c180b6b249c1335c52f0248cc58cf42b8b254535f97fa97f47bd7fbbe4c3058581c523213c5938aaa554d9e7c0e1ef97ddc042a42d6a2c2dcb420e3bf21ec5922e5d19befc68489eec3bcaaef40674ea497c9b5fa64f2ac242d289b5d5dc053fead44e82f961b679d8abf6e568968883ff13432b32b9d8b2703b3eb51c9f3062b849583a24cd2f96bc8c21083a4c1427ea90829d1e7cf21f0afb8efe50da288fdbc3d5e1eeb3a553ee26a86a0dc94af491446eedc68298981e64fde048f393dbfa6d06ac5200aa10fe6da92d77eef834e3e86ff0bd4c5e40194cd6b4d3baded1f69dba1cf3752ba1b79d7b224c8b048be4a179d6209eb85f54bb8d3963023ad961072003362979b534061c5b8e8e7a76fc1fa722b08c2b9a4c74e447b496d464a7804990dcaddc7574f3e9bd0552f13b2e0a5ccefc31c53eea508b091fd065ce6c270a015c089392aef4e8654a9fe6339472f96a5187cde7ad3f8d17c153769e4644c2011a6339e34c437a6cb3a88d70bfe485a09125c277f7e5335a6c0599c3d125f8a2e263f7dcac60f4714f9b689c9c9f985726e131deda57fe1e87a68c2ca11618711fdb10da67e87eefe9fd61e0abe2b5a8a01ec88b9f23f44d61c5e2f7baedd96cac8757ff1aa1d877c404189ef44707e187218e5d4c51a704b5311373841c0620e35bd31aeaca0884d3f7b3c69485d282d58824b8ab4cf1e58f490c40b3fc2ad5b6435ea4c4dbedc6e5b093e12e29ed36fd038706351b11ee36386bdb5074bc72fdb80899fd3c52300e107f512f873d050b90b136c78dabb77c2a5f1533dfbf7018459b805f615afd93289154f5adace4a9cfcb1f6c71e76a8f01aa70c3b653323b6552e52c427cdcb55acb773fffb68a02adb60f3922674ecc1712f02cf051964787c988bc27609d98e966de0782825441ea7e56a16008ad2a30631b5318c72d888e01f3b8d0d2f8b75dcdb7a391de9a096d60a6175f6b925e9e07e2b919c869a062a0d335f546445232317d802e8d88c0e2ad8eef294b6df3f9243eae57a9475c1f663ba377266a513d44ffdacf355afa508b6b1b77010280283c1192a7655b1a6eb5523e550df65419f5c6a3d2aa22b2a61d662e5db11dd9e9f8ac24913e23052ab88af30202280686e0c078f8c147f2dcf63cb3697f9908fdd21973c753522658183701ef36acc92529d10851501f87be93768230800160b6a8c2541584ab35c623795f2ea9447d57facffcd748cf64adee3197bc9b9c2d346eee28704fd674c51a9f29c4832b70057a6dfc4b1b987abe26df1e7cf3cc3e2d10b3ed2c08419cce3fbbc57f761a87c04a1942ea01402f59511a030e2f19599896ad5df954fa92b5f663f0b18f11ed06bf6c44dfe95b8ba09897201ff258595faf01dea3a1e4bbe7d4304360e0a97b0bd77f6ea15bbbd5c3ff6752baf7da16bd101887adc440d5602fe14d6633071c0c0e0786e4d28851eecc52700f4f23c331f45cef4b64546ff1facb09d12927ae38feb2e79fa6d0cb6904ad2c42231676233057de279d78fe998e10ce5893d07128943d93475f9fa78df87adc625a17e8598d63d52938f55e89517d828a6c25e0089cbb79caf2d0b83107f831dd37f6d932b37253aa336a089d07dd4dc934b0cec1534552927fc35c52a0ac111ff753d53ab8629446f2ced2b8271809d29e4055b5acb339b06882171253af68f87a8bae891a85f0a1a86b6347b5c382fa19eef74c05664c76a747d5279377ae180aace4f3f1941dd710de464ccd73066bfba7647dda718ee80b0755e9e9304c8e67f6476843aa4d7dd01f63e01f2a17b86ffcbbefc7d421a2444dfdf13f59ef0f3e3bb82b8ad0f003236433a7135a0f7e460ef2b5bfa3530a2e61281352228da87be18bd1a826bf7c96fd50358f731b478de9425289f65df4c3b0956986a2e20312eed153c412db6f5c812dc764ba4ceed8ebcd326f0fd9f10e5a78d16f9b95626d484bafdea023cd0f86e716ed2ce2892998e380ebf09b2e9ded693abbdea3d5743a5dd4344557c1ec76f1fd60ed13398a41259f37fe1a52af5c0862b59fac3a1843c2d66650d5989362dcb330d5bf87d7e7267e343ac033d84bd413f6c8b5232426bbb8a7c4fd35c9a7ea8f1101efc9bd0021860b1441af70db0e95214fdac490ba755b5dd0d572e401f78d97262e6b04516ffbaf7a659bb02da6903af9d06aa37ff2cc385ad062701e8464d8e0b02bce43056bba9cd567c0ee229fae1b6d3c95cbcf3f4cdce903b626d129a61b2df39a0a4b15f6db94b4599293742992f9e4be0798f4e8484dfc56359376f4e8b2faee8528af6e9804762312d7a18bb389418cc4b1aa6c0d5f8891570c8caeffbb7bfa326007aa91900ab06f26ac09b3e73a7e27823cabcec835c5c0455139007918a1e5cab096a7aefb220f819948d5f85bc07be2912a68acc20f02b4b40c97d3428aed16209e598898f37894593f31f84ca12a6f68154d3b0849f1adda3e477784632c92b3934e1dc5793b9c2e103bf2565096a87bf7593888aae635d174b7da9ff2dd149bc394a73c74d36bd5843beb6ab7343ec16d93a889539113ff46080da314e13036fdf5135d0fc65df814444e9d1d7ee84bc4237840e8b8e2a9dbeaf53fe3fbe4f424ec153866aba538e458fc1169c250a8b2b34460384dacd6cd808e761c78d3d5a65b27e4a55778b367308ae47ff2c8142ceaecfb1e1ad04de6faef2945ae2917ed2a84dba1878cbe4df079dc0b5351f7bca9b1c3389bc3c2142dc89e8f722c906beb2059a5e80a00d2d27c113decdb2251ed38b260ad76beb206630d697e3e3d36f8e3aaeec489419c201394e3a3abe438b7b499a8ade19544bb30876f81eea6a32b9b96f79e9e51f4176d5d9161d1502a192f9a4e8d0834809941d00380dd889bbff08f62a6fa8cabdab803b14a19d87473426d9b1f905dbd210f7661c235317e9281faa6f3cb33fa494364166c85a53aafd28f8a1d301cb1c1e95731cf9bbc270cab915a940e0a965c5a9415cfa69b55a2922d40dec408648f14a2701704ef26e92e341d4b477f12632b3f1bd6d9940c05addc9e6d0792676f734c73341c1401f8c5f74f56b62bf95992b8e88be3a41baa21f2aa71d0f62962b4e91b8e12148460778a3db9c3ac2371a8217b95088de09be5f80ca5616af2de54a24041299d9f53eaa8b8095b08bb3ae9e23e97b87f234e73411ae9ff961805f21ff4305fadb20f037be106934c3b9ab9f0ad209dd95c956d5ca37c193ea05eee841a2d0350bb1ecc353a567244f943fad65981ed017eb628cd88ead1ccf2b2ee3cbb6d468506fe068decbd2fc64fe348f7818c46aaa3108c3ffecfcf080465b81b50f83af5b4a0f885a72b3d2d6d75b2dba3f9b49de426dc532256d8166e21ef4878001879d7fbd043b19d67382b0f1163ecfafb1d97fb7e1e7ff8e6fc40359b190e851017b588e981210812ede0102de95f064ce43c49012e7054f0a143e59121bd88ce0f3cc6fec4ac64c9075b961b94e8b25e3fe668e30a1dfec78f28fd7ff233328ec05b83337f7c8f437b6711e4dfb836497fa5ed138c42a95d600829ee4139c900b46536a96318b920f43fbe479574c57b2219debc9b68f49d1512856ca488c6292f36ff464f992ad94e5b8e301d3b34763b289fa1a811c8181cb07f3d4e58ec00660d0017b28e3330a936f8acf4ce21705fd00a58f91097ea0f77ae667374adca68f8176ae3ab705746a945d98180dc11b304a96009b06da9fae472e65a5354490f2cacfc35606aaee291b40f2ef50100edf2e4ca09decd86432018be6b6474c437d87da70287385424c04b0cacbdd6abe2a1f2a7c186bbaa80c62115725dadf4d38bd7f7a4b9246ff2caee5b67adba24cd428a38ce481ba08605bb73c107815b968278542d9c545f28fad079a6f54895bd8c33d66ea6b9aa1600cc577e03da39b7a0a10fd6a3d37397bff721e3a01f17274ff68b33976f06c3d22ce1fb3507923c3a05e0f368c02f8491e661307a9212b30224627233e7ac50c72df1664e905308545e8f090b767bbad11288dc6dc971de6ed6ab293236a53c52fcbbab8af87c0689457d7fc6f774d4859a65efacb073d809691e1f2d72b2dad2fae501a34f588c95f57fcec4821ecdaee61e466e420ffe7277db8117088cdd775c4ef0af8528e25c8e7b7a802d4b7924f1f1636ed4afef175a83c23c23bb6d9b10caa248cb6241467d69731caec45e374525a7f97f130874ca04755d0d84da418a8b162f50e380cba10e3475ae8129547dd4e4810d9c8058fc62318ea2e15f714fc7d4eea3976508babc2d917f7f2fdeb5db3111eb06d6f6ef64d81b6cb4148409777a224c33266f8411f309eeff07e8591e6a517c212ce4be1818afca1d5eeec3ce5c79d5d67904c6b94f392e5d360e6292b35c4df63dc802b53dbb0f50e90cc5ddfc4a9bd0519ae5bf9eb4942626f4de4238a7cb08c76fdbff98e13847557b654d153c98befd517459b47a4d7571dd8933b08e459f879cc359d1e9ff1c709ffab11005548f3a4285643d2c0d586c2ea411080cb617d7ed3c6ff4fcc61712178d0521802ed4e890646d13b881f07d98c8698d38162bb46a2c74a4d4d3947633c89e851af0a0fa51d53012ef88ba7fadc295cf9e5fb25d9ab6ae702e586cc5d1f47a7ce3661f37d7fbc66dad5dc7beb5edf4ba6c4ac23109fefc3ff4d6a97fc80806b7356db99203bc9f501a40396c6b7f6f8acd40bb8f3b621fbdfd52d8530b8085608d1e4319843f05769ddc68a64a4b56a2d83a46a085f84edf9db2830482d5f8edd635a3931e491d4d595697533f6e1f84748f888c9ce2bac857f00837439b24b833e927f8f5286627520b05475c134d3cbac1c5508b21d55a8606b398716bc8d3d50be2cdba8d234235edfd848d00578dd535471152ef84724f19f3e3fbe41359537c9837c10b3de4c2d5e9ce07869319adf8a7687f9226f565fab11f2f453438b951747b45826d304e606dba5c7b891169f583dd5323eaa97d9b2fb4885822312ed005568eab72331c55d4f9b14004e5c137ab47128847f943542899c137827e0dd9eb141fcd3af054211b7e08cf475f5cdf26008c74e873972778a72ffee3ad2cec7325a2d362220e6b6bfe18862107e3daeb965c9385671ec1abf263019000378ec48b5a770ace1293bd7b271746450898ccaf098ede31ee399dbaf19450f269109dc0097e4a4676e441ccb877704208039e1933307c7257df16c52e5e32b7fa87739d1d2735f9f44d6d885c0ead7739d868ef4cdce6c58573a0278944e74db3b8fde5925c2bb75adc54a0a9363629fab450d20687156674f885a2e3f78ab952c388482ac7349277a87d0e577b14e2d864d4dd22a8bee73862ce647c73022ae9504e2d21853e128d170265a94e1279ad8e14e733c26cfa479fd2ec18e92724b61718e83b4d06ccdbd1164e109e26d9f5c18bfa092f06361bba8b360f8427f4e64168e1d9436c1f7f17a3bc85511e154e38f2c4fbac527ac882424d82b78c29141704a8b62db9ec21e9e625416408a67b67b9e5145e959cc69e3a50c87458b06348661ec9e62a0cf1a9efc8651ab9f347d5176daff52efddabad345a01cc852798035033d849f8becfcdafe8059f8cacfdfe6000004aa08aff1f632d8b4ecf9c26e1ef24aa8d0338b4ceb77e91f31716e286452d53591d3238274726da06918962f5c5705701374afcc757fe92431862149ff20ab430f391ef3918363abc8e44a7fa9a45036abef9a25f7a90e1720dd06a3e35c0fb35b241b3ee9d211516f7d41ce0ff0489af70d3e5a7a75d61eafbe43f17068be0d81e47c8d20dd8dfb171aaf1b5f32a6ba31c9cab057ee7262df6265e15a9ebe544265b52cf84c9a0583f6b7d4e9580577ce00462928b9a2c1df5f9489d5c3c6a980a7d927fe30d901de81220592d2acaa19ccf0069703fca7caa0b503d26912f4e75e1acab82632ccd12bf8f57a4b20dd1aa6e13323e2e29def7fd13ec064b0f0d580391e6dbbcc30bbbca7bf8d3f96f10a76f152631bd86bf78c697390e6461ea12b1a3ef76867b7cdff27d80369118088014e33ee5b7ac6f6c2dc83fc93d7d550b41f27ffc6a34fdc314f1970c6581f587318316a2b004a09a87673498cac89795ece2bd086f0f09d6fdf2349ad4a3946b2e405ac517ae13de21795880e695cf232b03f7280d0e3ab705329f6e6b5695da9b1b948ec3754933ff6109ab52f6ce0635bad96c964f83371724c50dbb4a5c0b1efc96453535b1bdd5b001e5914712ed2cc309d4d42d76be143448595c6dfbbef05ad68d42ecbd456eaf80ce75ee23d283f12f98eef32d2f5e87802176674b2a1fe084612d54d67eb5bded808bc06afcf1aee5142eb91f3419cfb97322effb8bcb8e8558532e99ba6556c32c039a566a45f53ac1ecae3f96935883c96028417f36ce0739cc237e6c75a447519929c7ea04b82981cafecffe8dc09d6def1658d96d2d189f1a75a48a9d8314255928312b0d202eb86a51f90a9dfd54acf90fd22b1c8f7ef6b2cc7f2411331c67fc6690ebf4cb5ddd63e07d543c7d44992d1c0df697d9d75b0ac1e17ed9cfbeb62c8ac33946e6e5e2cdc27bd9af488e4fd39631ea6f6bca7f47e5de1dc6066bf8ea567bbd74d1b6de0e454e07dc71ea039d91f3579891d6bb8fc9d024808efc8727e02e86a0dd1b43faa139bd998fa1dc6afaa026d77f9a03c10141682f1334476fb0fe92bb36e9e0cdcc39bbf49b4d975b68f3b08a5d12da2051529c55f981717e638e3bb89fb5469400c527f3ccdfc3a3855dc2f21a457d6fa436d0fda2ba3e59bf0a2d265c1f27c3a0b0a869af2b69a66316e99666726a9df38d5b38973b5b7c83eabbc4a8778a8eaeb34c6955292fe73703174ebe7c52d7eb7e87b2bca215e6e26919b76ab9e3e75c2be4cbf9efaa2c8f9b5123229ce284f449283c74f332967e4c3b4758d73919296f88498919cd9c7867f8173578576e204cb79faa3e1cdbf4cda84bb71c2b80331aa83749318ad2040c77b6d5994f09f1162754d6d31d2f9d429681d00ac326c3ae1341a21aa86493c9355647410a56caa06c7c88d896e61f35d37e85bdf334ef9c0d1bad71185cbf77e26903e41615b0763a90d58874fcc1b4293c43c55ee729944788cd6d4d6fb42acd7c0ed2aa5dad720f162e1d07d0dff19ea36a361763359ea17df1d02fdcec8050398f9e87462e4c20408558a0a1225d02c4186cdeec877e68a4a32f2e6c7cf1eb0cca4e1b5e4334b51309dc5024c1d5d1f4032f389f90ec1793ba07a6d7c684073efda6f82f6bed04614a464ec5085405eb132e0a8d159e5e3f99760e972822ccb5f8292e84be16e1dea8ba905a661a1ee80889d1a3990c34843649138ee7618bf6cb721a97c1962bbc96289c37bc5c99876ff14e228219e167baa01733ca73b6d2fdb097cc752ce4a447141a4e35f5e62e7bf3cd76e1f8a8030730e2562237247d91a9f4ff69d69a68bbd9f90bf0f4e5b72027e79539ad1b459d6b69e1b2eea17313ff8ec10ae0d80de79887471ff636247672b4cbbdc3b87fe1012f06916b5c6b8cba84aa9e1e7f04a50995935f8a9ac7c5f38580b208c2d51825d42ef5bf7516fd38e14505760347f21df1f026e08e168351716142134c763c65deffd8e76925e494e135f87a123b17c28da2e6f2b2a9e9b72a10b9111a053a1b8d1bb59aebc683632f8836a3314ccbfa0c4a57d2bd8c660bf10ba34599448543b28dcbbfb105cacc22ca1ffad7d4280d440891be92a126c18993a5c06b7172e7165faa2138debe0bce46ac6e06d6a58e861964f0b792c32eafb6b7a1493d3b37939276ed96d53b5bcc674d8376ae2285262f53baae8be7b1a22fb1a57b45ee59416b0943e6eda8b754f5802b98fe7456adc6625ad15885a814896fe83667b2cd6e771ac2411a809c16d2363d38a7753a03f5e94f41c930b3e8a805bc43ebdf09a6e40cc510cbbb3f8ef3d36006ce88c0760566deaa838f8dd606893bd285d04674c1d8b613a8e2676719fa65e4804f49f9558fe3bf7c85045f62d0566aaf332d6ede6fe03adb8ccfe1a3d89194ca98becc53d66b550662613b6c6e9dff53d099383cb4739a5648700a5a499420b3bed41e8ab1e490551f58d7fb4d91b10115ebcb28e4d1b8c4e7a3fe87d9cc309663ac77b99c559031dcd2bfa0535771221e97cd2f97058cc788cfd4cafffe2974877de5dd2977f27c028a88207f97ff358cd3601a16f6107852fd38a512e0fb46b6accd04c5c084aad96493ae901c510e6750aba082fa73979629e8dddc48dc2160f62cfdc043676d8e8d6384a006d170b8d2f6ccd6fe3e87bece233a0bf19b4b8014ea784112d6de7a10412e7bdad6fead487ac1749063e7edd21dca09261a6776124dd393319a7ab6498a39a501757e9ab655166ace9d53205656f8e8d536fe35b5d0005228f4ac03cbd10bb3e2b6c815ca9000139dcc266c052dc90a6d94e97b8d17ec8163aa4e6640993204872e988ed88c8172ab74faba5a9ee7559e52281b854f75d9b0d6aca921a6ce90cea977c6ae8556c7b12ee95f2270d764b4c68d50cb3d5c3651ca012e2a6a2477c969d6b63cd02a02a34f9441b3905f890159ded16bf35b604815dfebab6bed78a8a0f6514fd0d12da668226c3d952f67367ae645761a0720b59901e6bc258c8128f69438bac49bb5ccb90313f2da0592fb516202de78b2ae68476aa0e36ffbd9c48f4f3798c403a9db97e5af7bd8f76c4e8e4a241fe6277bde32a75fcad2b89551132f97105c6b892259c7d443b7a00d01c8dfc7da86893eeced79b841bb5d0354d70ba7f117183f5ce6dcc7021043ad99ab35a73ff5511d1eb1a2c35e5190b915b907c27d849b707f3c363c0c23218f5168edfad0ee9b566d7840f26755e6950deefa093a71cc62d2680e1342ed51b8ca491ceedc17f5cf00c75870195ac51e32ed0595de97527c37abc248e77f11f57a4890d54501b630326c1fc390a1f6a1f10cc8c229137cf62cb4513bd044f72f24f2ed759924471fd33c98e046e04c5f694ace210354b25482793173605eb4ed94a520b117badcca2890f0433478b920ef77c5ef01d3c7b55122fb13ab097dd29d980a8dc98c74a878e4806f2afa0fb4718360b2ac46ead19fe236190a57c10c0f04bada7f4f563a55302f791cb4a8677e9d4cbb9852cf2cd969037ffbfe223644c93b8d4eb6b14e1e2a7c6382b964de6693d6754b80184ae0651df69e7f290471553ec608ac3f60c91f5b9bd49259d75d32682f3c682c4b4f8b430c62ac3cc08e51117b9ff0844dc700d41ad2bf35ec5cd1addc41351a197f497418da96e7b1592d25d11c46681404a86506501af21fd38ca7d3717147bde76d799c082e8e28a88df8f17665d6e9f1517f16a19ff5161d34a0e11efe3fdd5833a4bee24b1ee1f6eea7a703a65cbc40ab246fbf9704fc35536be9a2d4fa53e44a4cca5e8a1d96a81b4adb03c70e680ed37d1fce093a353917f4a95178db563ed5666a2a312262553974b835f0f15ab8465ca0a4a9c01c4ec9f40aeb233a0f7b1a579af5404cff842c9b18edb7b30420d29ebb650cbfd4b140323bc43bf8b04d85d7373777047c06c3fe572c65cd70f4590260af9eeb47f79a9c1dde52a4ec48a7bfc092974b9709a5c5cf2daa460feb35d9dc72aa910c06209cfffe57215ca0e98868b8b84db8c0eeea9cf34818e183a54109b26e1ee16b83f29a397f01b6cfc82145c92dce2783cbadd703cbf1fbebe91948c34d8d92bf8c21cbf94f64502ae6d0c4ac291fe49a538afba833d26339a210f4fee8bb56b2041335c5e9ad4c52952d0d4742991597d6f1a8c491d2af83458270b9726f167a4e62c39fd706b4e0804231456cbb7af7631b5a669f0478c5ffca22dfcbe11ef4ffc5e3c6acb196a42de8cd764ff59965336b09c1c496f637c2d026b4b0f5029c2697f1d5d0271bee3534714995a3deb8d876b80f39dc6573634d6210cd8efd4e72db46b0fa7843e5da0c068af8eb4cd074e9e35a54da043ebab1d388cc8b595c781bd3c934345afc51040fffc5b8272b7eca546c90406c67342d27cc06eeb677ee5e56522294995f177ed94d7a0b32ddbc00c29b31911d0a983ef54ab9db33d09b26672dd307366b4bd3306612185dee47f94a8461302b4447d0e3db30f59b5d56be735dff5ac3a077041348c616e127a4a94e03849e1fba4156248b26f52c3a39da9573a355e62dea4e282aec3c9d1dc6230de7c2ba15038af5412e53f48b83f1983552fd3066d373aa1f9a77960de118679d399a01c4427ab04c20ebe49c81a4ce595f70403ad0b788bdf7dfdce92519d42287ba5515768a4ccae83c0a8f19ad16d085eae28ba83aa58515f9e073589488124750e7897c26a4624da5fab469de274cae8dcfd60aacea2a10c65a04a1e8ad8c22d0e89cbffbc98ff93d4b81c70034ca5a2924fa8c2635dc98ffdbe2cccd0923a69098e234f3928d98d6c442e73e0aeab25f279a6ce75728438763d6d4acb5a7880aaa58322fe98d9c5f90234e36472050c0728e73bcc9367cfef9ddd6424f8898f157928f2d39e8fe89cc21cb57746f3f08045a9749b2dff73f5ab8182973cb13517db884531e1e454ce918b979cdb13fd4fcdd9766d6a90ea62b9bf691fb89fc446ac983697acc45e9b9f34eb9eff6c8d2daed6c85f1cfddf88d31693686911bcc993d61dabde35794a83f3e564cac6bf4f2a56135c048cc317c83f36087170d4d13b0bd6095a8e87345b3581081b9f97eca6ddca0d77936e036e0d53dea3dea126adc900223c48c1383e44d5284d10b245df054f94fbb5df8193636e8f9e8a8183bf1b718699a652e4dc5621e2715cf27bf991c320a7203129309f29f92a3dc37a4a06c250928d348b56c064a63b871356d3e3c2d0d84fd632f7d9fcfdf0c0e3f4b17438b3f6969eaafafc54c6275fb1d8837e49295abace8cb41a3b0e47b1ba4620ead2b9520cb5b3dd3b888026900bcd766144474223b891a2312d1ceb99f4c328d9a270fc18a2816281eadc7b7586cfec308f55b29dc2c304f6905f2c2d6e97d87a358f83921b6ce90fe4f07ba3f9bd2c8f0dad2bac8e129c7e55dd80a4b95f2009348aa3056461d8e8ce65bc19f4a58ade9bc97c029bd389ad7e86e060262114dd2e0cfb18f927f5533173636dc61705f469c220c66328205ff389fd56c5fbfd590b7f38b3fa13899a1d30797de3cfae51e3b1200b8bf2858a2ab7ea88f654ffaef0d99dff7d424f5a2b11baae1fac0239276e4f451e81b9b692c38abada2862ce649491a67b6079dcdb631b70d491a32b2842078184dc5498b56c1c253147f3b5f120334239570c88818a876ca2ae9c4444c7103dee57b297814bf763cd6b28e5ac53f2c0e5e84326a22877233ca9d7007ad9228440479ea6ac8fbd577d0267168f1022361134d5c430147eb943dfca4473a59799f37e2f78bd0e9de337778ee704080b5728efb5b92b0cefd010b15572602cd99c21b61cd837621bf955bc7f4de50251a18aa501469f328e9ef935cd23caedab93b5c894ac6d2f6c2414c7bd6d8359283200d4e5c96ddc4f04b7ff8a38a2d0a05fbb54b433a8def768c0ee52c15cd15b2da6da190941a55e902b6f1b1a44a91e4915f0db90500c4232a7cd25f78b0ed64074c3f74de761f1603f5c5b9d7a5883cfc9f6c785c90bdc0b652a37fccee363653c7e99b27cee680b0d992701b2b4cbaafbb1ba94dfa20be6fd4e8313b5b0dfca30a0688a210d19dcb2bbc0f5abfbb6f1125c94f8390a397c46642dae26342b79f809a9268be93c06f3822f07ae1d4ff356586985e2929fe76ab170161db207df6015df09ff5e8941973a9a30f6939e074a73a1db704f922906cfae3d01eeb7ad27c1cebc180a1efe1deab9d2c911bf87962a5d2224687cb8e785c033dc09096b527e7041dd8d670ae2a5002b182a240cde9a63786db6f8436fc710de315c9a3731e6b525b72fbd695341dee0f17e147eecd6bc41c15cb8a43e6ae7729f6353b5a7fc7e547c934559f4583c2836fff551df6ea7912e0354a5623280d3a70150ae5d12d24f119a4f134710885c8f9f7b3b36ec1c99bc6735fa644f449ba0c35b9c641ff80392ea80f402f169c3378b910c7cd538d3fc437773b719e55fee00d3eb79851f9e4b0a8480d1bbf9b646b551d834fc79af236e8c3eca115e24ee575ee136010fa2fa46cf3e2a88d350b2bceb3c5b76126387cb5c08442ae6fb058a29749e9321e8b4cfbe69c040c93f655fd94b9b84798320aec8989888aa6f1a8a8d9c41f4660912ccc2544e4d01a6a631ca5e06fc4eb7c212c5cef4b215fb8192c243f2d87ae68dbe6f309c5cdac49e66cc508b4dbba2e121c917e9c558149f1d576945a4b1e36102ebc689683e0c0abcf012e06d4bbbbb1a80dfbe19c0572c4e233620aab86fe39390c9c8787854ecfc4b8a706561a7f3785b45e3491558186cb64e2d836524c3b3c67db76062eb62977adb136a2b731ba3c0df7ed31be99da2554e99931680a1d1da4fbca431b02aaf324aeb2b72e0bf63de379c66b964cd3cecc7bb3ccc67072e8a6c2eea2e3d777fbaa9599cf71d1eb8e25bba90d36d19ffecf583237323e5558e020925e81a6ca5bc9bf638b314babc581097044dcace163ca5896151c7bcc17c29556a9f1049afa3cbf425befc4d6d91575e4a3d08418b8dc217e82e0288855759f8e7a84509ae01645e95abe34cf71676a403be050cf1c0bc2c34e85f5b15c01d12ade1698fd01f0d1ddc79c437fd8d833d59cea55fea95cc796c38133a27414d10b2b3160bdacb561e823026f5a470192f132bd57879f048077a694cecfa0f299f5270c5bdaf78c356adcbc155146d375deb3cae9ab02eb8b06cb331549cd8b6ad0a3e7a7bf0feea0a6bef3dcac778f91257e878f0bf881c7f553201d99221e9c77b74756e98480605d53d0b36c0b501a8ec0f9337958e71aa3b0fb1d258b49ecf885061846b4f9436d11baf67fd3c52e4d8a616664c5a8def38c6112468aa366fad430ef2d22f7ea5c69f17872ad72874645b61939fcadf991a15e0c77d3ab3005842c34329f1c3638cc09c861b4c5486542744504b803b4510ed1f9acfac6b783c164c07070faed37ce7a38eb786bb35f923a69d062a7cad2b66eaeac28fb5ddf306e2fa81be548f17d3c72e2a868d198e7fadf7b746f9c7a88bb4610321fba06575683b9c1a177d13bf86113cbdab59898f2fd9dff21514b1d36dc5672026758f916a911716bc8a021da6caa7c3c2e85ad316ec9f5ee02ad40357fbdab3c2b9970c330d309a250766df1e6e6d8aac169bd85a1e38aa505b391f01de71edc3bafbd9a1f15c13b208077452cc99a3ef889f1f63ffc08bd5949b3bf18446fd528909bd1bd2101b7c163c8d0a35a5a1befbe72e22ebe1241575cfbedef868db4dadff92b0d85c0b17d9d104e07806da6bd88b7f5075c1f03c7bcf457a83020cce0dd038938d5ae464a74416926f5dea9cd61a4133a85a803631fcf388124da30817e02046cb0af0e1f13997b6e71e03ca3e52663a68c347cc4b37a2171b35a8ab0e5ca3d00394436ab8fba61889d233584aa38fc498b17982816f6be24053994001a8b3d73e173f811ed404c5bc3ed7beec0179a729d42018f87a3cc00727f76b0e550ff5f093a61dbb53051f2172e4dc3802802eca62bd05e03f4a9045c4b52319e7580d57501f2e09192b864961dbce07ec64e7eb78e07364b54c28e352aefbc6aade52a9c5e0703b6ec9b8fe1ef20a8b97ffde475cef2c64e0af400fd6849a69625b521eac84bed038c1da682d54e65898dbb2eb883dbdac46d84b57587cf86b606d146edb6903680f5a88769e1d590b9df02f59ef219621c343d58fc966e6057ea658413e08120133160953e0927844a8508ee5636e213262b8b052311981b2f63e8570caff936e3070c8b55784172266ede70c0997d87f293823928977536cfece65c669af801ed08f30a880f50e9e0025903cd3dede00c2b107e5d4a8c86f61423c0f5c54647f913d304a0e1dcd76d7b21783426decbf88f7211262eae50350d53dd92b2398af3adaebed4af505ea0593bf088fca4ccc3ee514950e24df142f7faa50831228fbc48b9bab484299793fd22aaff7e87f54e5f8a258600152f2d06a0b1a39c671ffeeaa214a856c143f76982f7745e7f5558a04e9c2c77e9f7f940bcc96c504781afe125ba80a8127351109ba17f516b25211bdeeedaec606e0c1559af2667e807a0e7fd27f4e64e324fc413c58f008981a7dee0c683b40019cf91e9d191c0e18336efb123db49c2532106bbe1601de52f7104d0be1c15205f8547af6e9bd8edcb91d03b7e92a6f770db993e4c4427c30e719f3ea1bde3454c69edca740618b2abf7429b2ec104392924c8309d12982da216d98b4417a413d06c42e88ca34ba480b89d16390ddec4318dec704cd2302cf27b35553d4db48066196d6e821e0814ef0ece96e1a36c5eff8d6d931d986df693040bd204b843e24702703f4f877e94473926984592a66e7fd227944a61b3704240f349e470be0fed6e1d595275f37adf698f84950a6f1771b5579b77537548da5707f984a290062950f031ce3c0411823e4c586f9e7840e6106961752b453de8f03118285608651f78fcdd464aa67a48a7793e975fe831157757e0d649bfecee5af25a306d0bda68ed9a9322447adb81d5f552a54bf324e6728db65ae3533ec2549a7a454fbd48058d92b84dc4fe61800e7b1b5d7487578568197a074695b29fe805476752cf14b487575c1debdf140b734313bdea3d3a80d9f9542b0a490630f5dcd879cc9746bdba1caec2f70569ec319711f9936ed5c262c5cd203aac67777f07875afb88ada4c006631b5bf85270b82666b8639f53efbf8eda3ce1a69ce684d71e3954bb00f76480786735f8ec1d23ddb4e9612a9d1f620ccfe39ae1b94202072dd7a1158875de7ffb27cfbdba23b7ab44285d5b1cd386bc269a2e23bf6efedf62a124a201c2d857fbc14ee39310dc9cad2289dc867d7374fd1dd1ab528e2e93245d57999745546238189d986d57c4afc96a81d571c39120e0faffc316d1887a7b42aa8fd2fe0c33317acf5ff4513a98553c9375360084ce981571f3d8ad0c5ee8d1a3e4fe8d0d062635a6d665ebbb002dc81c1cfa1ba97c82e4d5eb8670c62b00f05e5e339db39132c8ad2ce15fe4cd9779084165686731301712233f9998d0273cd8b986cc5b201f7ca9f5f3e65e44bdcf9f924795d3b879e0f39a07a26a6d36f9d5f293ba57aa54e9889477307d2cfc9208d4ae0602a8109aabc880eb464eb3d9270036a9f1266c04f4c16008ca5889d9d4d97fb281c524d5a2fe411dfd8f189058c950f414d453c3d5c5ae698d454376a3bd9d155a79bb267a2494a8072d6f9c69ae04606276749a244e29684d0fc29b7fbbe4c73bc9faab2be7ce3b069726ed73847e96f9a6a52f780b658bedb9b77860f5a586a0755342830a816b6ed8122f43169644ec53e3c0f22e5424fb658fa6f6243e0b4b2a8f242bd974f69a7fd50a5c3fc6ee78aa88fa6e902b894f9d6d8bb6b57b19668e9de814d9823d0c9c9229228220138735b385c68835ab4584c8b6bcdf135668f55e877dfff2c1c67cb2ddc3b5b02287123fceef1d797855daae1cc783f19be0cfd37f98faae070ed02a40e246c4d3f0bb0f88c6ad546846efbd73a3753b64f14d8575a0dae477b20363d15b37815e7f28ecadf7f03e99366243bef8f2b3a1a99d5317cfd9f187b4e62f648ebd4a35bd6135c71f40679aec0e902bf1c09a61b2530722240344f7fbe7dc45d2917524130bceed9444968360d5ecd8a38aaeeb281752647e0eed164a344425b5fcf2085eca3394adac1a3f1231ca6dd9a23bab4172c07829d7651c26c51ef6c02f8434dfafa11cd23aa8c4193a39a5a207ee98c501786aff89071cb73d9fa7c3f7ba2d236dc43ebbb46f9a437bca6f25afda8757a1730fb23d69c6c8b3236111c5b5bd64a1653f589d2502d70b30ec07d38b6b6510ea4a9d2c5fdfaaef8524df3065e3e217c2873e8811456c1ec91cca8d0a33221d041156ddb10d1b94a969be6bf30377d8d65a5909d165a203fc9773ba178d2e8cf057aee910f4f866ca03b03e771da1a4c285d89adf1fb9915a005c8e2228014966ed03a18c27510487f71a43a4cf45ea6a3f9c5601d5078413ef5698e01987b88009a6d808ef0a45e28f3f2e335e965b83e2b4493addd9269f7e19438213bc29d1f26849936ea24996b2c0b67f146611d93fe375dcf1f9a4e76180a33723921bd4acd0168aad57e67e19618c1fce82364b6a7e341a3049ec22617aa7452b0c0cc5281f2d24c66462b62f9d56a7a146141874f547b624171733256269dc3b650734f35de86df5a963a47db2ef186d601c7d1440a5bbecd9a74dfa84579ffcce208617eabf023259c46160e99ed1bfdf34a158a915a5506b7782a4e8482c1ccf3735e841820cd01104883b6870019e6e5bb0dcc731b8d6b918f0f7252f825d1074234de351de6b819ad0f748a5f4a19a0f194b5983cafc473fbf9daf0202b991b6f6474f67d67421453b03ad4167b515266b10d02b3daeaa01c1b54b383eb387db4f04d5a862de9826ac015a57df2b21c6950580e4416d686d637e3066a267070d5d0d7d37c58b23ead5b4b5100ccecfe60cf4d52cd77a6317f3a216a697fe339eed412ca344e485bb27cf36d3d14c591ee57818c69df49ea6f7090574b00ac9f7e3d042c6d8fde34447e6997dc247c0587e25de7c367f97c6a568f140cdaf51a4c3d1ab1eafb5e7a7fed5356bee8861073a12e57385adb5b000918d3c3265a5210d0a4cb2516b6a5714185872a52412046767a238b00d630fe19c974e44969303f9cf1e34b0d00d178e1e383e7972ec3d5ea0142d2dc357af8b1354508611680c298a0d387de39bcb01aae9ebb3f3f55bb85ee42ec2704691536fba119961078c41e2648ba1c94dfb18b760d2f56f1addaf7f54b794cbfbeb12f6abfd6be3174975913042db707682849817599f08f749fd7311d6f9fc9909ff165f274eab3178ae0465d36383aaff20119ed353404b03b083a58f3cf968169593dba5dab13041aed0f7e4e437934a1368434585ae1fb374509abb140b54f76d95e7cb22c14f449be436a8eefdcf6fa7ef918201437834858b017e15e20b1397aab4aff833da58cb6f0e36583c91e0de47031b272fe296ad1dfe3c44afdf1664ffb63229ba9a3631bf632e8002150a7164e599df8b636646f555468bf622818d35c701cd1a10de86b0ca68973ec9d8714c3f2a3fc2065074c21e173a22bd13fe04ee5522c1ed19937013a17db8f55b4540a935ada9ed4dda2e2213e0c638c491822a78832e9ab71faa23fc357b52b4f8573f88ef0c4c9c69ec2817a42888d9ee3ef84735268dddff16e1111bee2481909d092529172ab59479aa25d908c5eeb426f6d80941b462c8483966764952ee1a84997a9675133ee4e30ccccc16d7abfd9956be3d51e4bfa926624324cb1cdeb9d550745cbb318d9b39224963244bad48c82b2eb8cfae1d9d5ab75c6672717f9c9d316ee2638e7bcace4becfa589d2f10811c622d66b56d3de382ce9e90e483e48f25d19ff78c21e9b9511e8114ccd64d8893780f354a139a2049dd5cfa114cd76ec7927e9f0b49ce13f6a2f7fdab568ca81db5f9f41817febd98eb52d4c6d3c2b29bd5cd2525ed07550423405bdcefbce61b65398c2e6532b82beca3e9268e83466bcde17ced8fd0ffefadd37cd8b35190fdc1654dbc17c5192615fae4cb0bf6a35f32059f31502f7cdba24ac3b33fd4100f1d8fcbc500e28e6b6308f0e27d4ae3cd6e68dcae30f9df70499d18c63de680221a924107bdf3f0437bfeaa0c79895f92433c6ec29d8e90ce94ea58c3b329ff8864a8280adfb6d048b98a2c3b310549be6289f5e055b9978aa639cc7bd2fb2e7a737","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
