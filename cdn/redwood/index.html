<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df3f5e917fca5a44ae9dd946d3325c6da7c61450fdb46da07813f89da74237095edddb301ec6b41626cf213e0202d9a1173dd7920121ea99ccb09f7fb35ccf3a5b226bbfd0fc6c250fddec8665bdca33dff781adb635f5dc13de3a2ce1e5371d438974d05591fb46be960788868bab1c16faf04a8edec165d8153784b42f77316e0305ab7daa810f7d279950e3598b418d5c409bc0ff49b8d10d6dd873c38fe7c25154dfa9ff76759fd006f85ee826d4290003706b36834e4a922ae62e8e6c0a2a0b6eba8adfa0773dcab444a653d0f00eff24e06a67a2082223484e4bfaf192344a9fefe95a439460c1d1142b5074987c50d1afcbf1a0e0c27fb87786ecf174a8fdd465f878770f01a8b2a6f379b77d9a575a74dd12ccac64575302ed2b6610448f9bd6efd9bc7bb7d86c628fbf5eb1d9290070380167b208c6ca0fcdf2b053333e8f1098bf5dcc6a673fb8f12f94cb31ce6413317e8a83bb218bbcbb23c21166b9ed3b4abf78d08496259e30230c2b8ef3f899565d287bc6e3f258405997510192e9c2d19c524b18bfadfe12ad4b92c857921ff1f317b62e2349d422c137fc3cf1340594a8b2db39ea4ae19413e5d0265a3f663b619388c176782b093e4c5e706f0a5d7642275da4328eeaeaa19c54440d42d9acd682eb7a21a4eda60841a281eff272759e13791c7b873fb2678357f016e44614abd6f901fe361e092ff3f786c6a858ae615344d568cce28c45a731d12abdb544d1b5c86733b3a5ab9d7f1dc5db65c06e4d6805e265235aa535db7de063e719974d398dd66703d9898a8c595ba6a5d136158d075c57a86948e283a9240038d1342be354a12e0c57520d737b241bbff24c1f9eac2c7ceb7730fc91f441911d3da0d89a1fb7195fee136ccf888f1118d3e973c5d1c97ae39439839fd43deac3cdd7b0cc7133b7940b855d3f040cfae64b9c1ee2b6e2dad3bf89e6e5316c8d39fa80733dad48876f329fcdd43be857a037556a0ba8561329b5ef113634fb63724796d64f6d4543c5e4fa310968a6c6202cdc86b9af61c4c777bd3b000c26b87b6fc62dbd68d946069c6f8179652154620add714a0bd5f725cbe3114cfe4bbc57764f8f08756040090039fc9d6401a52caafc384451a89acb24a42e28f3cef5185da67d8bbd6c2a62414009a33564ba778977fe9e01d3bcf995363e2560019baabb8054846e5734f0c8cca0c3c9d3a2e5d5d84335778bcdea1eac36660e7a230f33a56c2c28692278b5f265b2dfbacac00f4df58ac622fd4dbd69bb6e8736b54cae26a4d0db0da47df42a13820aed0c556869fdbcdb496186fa23ac2a5ee42c49d6c3cb3b2454259ca33e8d2d9b7ea4e573f6e85f342506996555883def68559401a6cba77558435a4fa18db4948f9be578348af6245ab91ac4b08ba1e94ba8d4d219ca97cae258d8559395833bde437bf893918a98c61378b9f71ea5ecf742252a7f08b01fcb93695bab2acba07b0afb18a788e79c9735a3bcfc2c0b76950dd664cae7c891846394711debfb83ea0b51023af015ae4369b146b2393114cc72aa23a475501e94220d59d25f15d23d9a1bcc862f6ca581de1cfdc30daea15a2ec2cea2508b65a2fbe2978af29b5e4f66c61f40df6207a00bcb827081d0d7c844f9e91cb9a4f18759def3ee645724cae8cbc51af7ed59cbd0f8f67c1673f4f373f51d633d618b2a7780dd4b3e02550d81d7c7ec700e7f1227b6650d64191babeeb1dd6083aa81f2d4dd3903a428d871cd5e77bbdc2f2f35950c0379e60f19630b67ea61da415c05baaf960636f9e62b77c6355231927139da4938a5d8ce9cf79c5686c39abf233396f516112f6782d1b63fa3243343244986a0fd048f51baf5a4756593b197cbaafebf8aa8d5c351b113bb6ce7782b6f47442c70a77e565c57990df4e5e2e9fe47ec1f3adf8d019a63f0ce7aeb8618d88c3f6c90ca62a4cae1ad39b34d1abce7d736c8d7eef90bf85dd0baefabff69ca558a4ff000a1852e5655bf63ec9a0e2e59b28465fa50d2e9c24bfbda4bd6f85e0bc8e491e85b0e78481de742212b71bc324114520fceb8488378d5ec7d1d4c74ed46467d6262849df5165d1d8c8bb9b2a8f1229872c2b3d8ef8ffbf2d232de8d7b7d5f9e818f764d28eb9754c22cd6787246992df54baddd680bc2ecb0ddf31353be16d792520ebffd9e4cef468b000e0d924fa521aee667e8cde956a756b6a473fa2e7888410e5be9e1c189cf1b05632af25586eeee5d99d710b0a876a1888263ee3385de28234d4c4c4f949e92dea55242df62d998dbddd78a08c394009d4d1844b511e159ea2d42ad268be653f542f90e25dad4c76e0d429d2e83c2166358a3c9e04b9253ba620ecbb40ab904ac1a2fca54ff4d150607f7e38078f694ee7c0bfa7cdc4ae20dfe39737f383adcf7c07244b7c0261c38ed525c876b3d91cb4bc66476d40239558fa99bafea54fc3c0ebfb476075354667624535c01d9209c8465f9e7d6c1d27a1713abfa5fb4c7c0bc21fa99a1fd3677df6599b8a94db0e84247a3baf6b8d8511ac843a4f63e254fbb175bec87513e62191d4825ffb38dedca52032fc008d228df4de019dbeb28eafe0bf956fb6626201008d6c9fd8551f87b3b6094663309d3e6c9a99fa52d03ed8ffcac7adf240e727d52f2fbf80c658c6cfbbfb937948d4e3ab63a27f1f96d4074561a7353e810d61325551bcdb71f44ec21b9ce4a26dd127e6e1ef685146b94c661ed3b37888b1be9c8c1176f10e8745330ff6102db121b2613ee500a381c60c69b11fa5b240bb39856b8a92de97926f0ae8dfaa75eef7e54023b7f783be654e35933776e73495e626baa2a34f8130af1f91022b0fe2bf496057dbeb56048c09db0ffd2baa275bc123d60b7658fd581b65ba04c4fb1ee53ba27d8a14f2232da219a98df28c700179ccd7194c4f2c969024547bf4fdc564fdff71c25d711c017a61c831efee2812ae1a4d4f237acfb000b467ca75bd28523e547f42616455a40d12de07bcd942299334a3bc7cdecdfeee6f55b9839cb0be8993f433b52194cba8ee22e078da40afc15205213d51902d9aae10788346897043652301baf0b897c44a7e9e6e27e68cee9237d9963967b440a3ba8d350296326de2f063a2b7c64e02cea099e36d53838fe6c747fff9eaf5bdd461489b4ee81b32da34c89f7f9d6c8ac013eb5bc38bab9a1798b447ba40c9e50304f700aa894a91377e31b77920a8ab35eb5a44434c5109a9b9ac2bc073a0b748e46780ba68c3e437ff5979b4ba1332a39f9b66f0efc7cd24638e8a1cd3ee0f5bdfaba2de57e1b121e4307af34955de0ad14a69868abd48e0d81e0683651e692902d3de97224275a8f5a6616248bb1a8baf2c33ab18d8d62ead98aa4e12910863af75ac271c1dad88087e4df678409915ea9d63ef1962a8993569534027a848fe2abe5159cff896fb1e260137bd645bbec432345548f227fb16205bd0728f74c51f81aa6f8ad03e702076919992785c9d32aa501d65df5616416353891463dcfa9edcd040ea4c3443ddecede4d092b4d7b64647b5c2b28b396595bbd9119b8d62b23f8780a7ac73fb8a298e022f872b09a50d60fd0b68a65e85cc6b6c0a0bea1eef0a4585dc697a90325c9c33caf847faa5f0364837d50ae4e3a735f4dcd4b13541f5022ffcf33b0fd7a33df9fa78a5e27ea99b04249ca65a7d5d430c888a8c251195939dd6ff81286491fe60ebce79859297e208c32841b49d6b19fb1d065e581f986504332a941c16d7b7bf57b10a67b535bcc7be1d57cb8cafffe0f613ae820736e72f4e8ae0c768e5b619754bde9dd689a5ba4b17b8e63ff740c7363f774847f3baecdac8ae76bbc48a0d6662cd0fea4b8ec6216c9e3117e1b5bf4062606bd29d5043cf49a42b64fcb7a939bdb9b3dbe1ae23b7d5495e0387fb2d8d53473959aa05ee763674b0d28da27edc326e461effe946cb9f7e739d4f1eaeb7744620e565e8ef6509223a52805238b083babaff58f571b1616d9c8a4a7fa7f8faa33bc139f6a360f5b5fac9c26777f3147396a08a0f4555ca12da3c322fe1da2296cf39d3a8e78c7f7b7235edb208619de3c105750a3c3c9a114a49959646bb7297cc34b4519dfa471782824325de02be47599851d94c8be1c7956dafdd3c89bdcc158fbe668fd392155f591889a7c77f78175939091c1b6e612974ae1bcb50a75a0af06bca13b95a80a0f3f7eef4faf61b860ce892babb4ea73df634dc8201c9ea8566584b9f93daf5297f5760aa66893e6f2c257e5de6a85ded411c1fc167f4c56a64d06865a4a5538d090cd05a37c2fc08953dbc208c6eef7c8ac19d91b8a6936a0c18479e6b3ea426ec41b807e5b98b42aaf6876b6588bf8f91d2fa110bfceae0160fd4b6bb67fb6922bcabaf65f80434757f90e24c07334bc09935315ab93ada17a7b9fabdfc27fc21acbbff00071f8d22258625182d911381a5d91df7dbc7e9d2d9d83e3e31bdeac30b1f26320ea022a2015d6db673c779f4c6dc3283d6644623036f147f2d57544c05e17091d5fbef75addc07503109a4084076c55e8a72bc59f2aaffe4a87911e9929d50737c2419e329f4ccaa03b43a1c96c02e3de96cbfbb62f7149ad13aaab2ec718611b70dde68042dd224ab1373b67c8067cfb2119bc0f01553375020bf61cd49b59f209048b726514bb9f420473701ce740c1eed04a0ee92593ac9f4ad3a90ff5084f0a496ddaa8917ffcf9f2080847a15ba390ee95fe128a1c175805a23ad0eaf098f76a9e430e20a8d9986700d655a442e75bca829f3852f0c405079b4289c43758228a6e1dd97da321460a3d30f2289c4f240cdbb31b233f27dcbe0013cf357b157efde0e9953f58aaad60460c35ec6cc1b54c63768285e755ca8953f14ea630ed6ad2665f18a2d03ca6571aedaf2bed835f63f3c9c0a4ecd69af78a2b07b80ddaf0c8b4ceea416f99614d48edacc7981d37ee242a51abe19318270bde0811dfc6c944b9a7220b5358aa2bbd4aedc2459706fd68bd6528a3f9b07555b013585dbc1fcd25502865e70274e59d816138272ef8aaa8e5e942e3541035a44f8f1388fb22cad1b7f847b38c16eb8df991217ad0f705e5e64b40681f310fd011a0807085d1b2b71bec1a4dd7085e2b17aa26b43aa049d0717b1ccce8ad34c014304e537af7afcd66f8032d9238a412522d839f8f3ba2187c559a4196f3f08a0f18b4cd54b7b2e71bf20ac2d85df33e2cd24b68b79035b9b526d4d3a3a595ab456a7b33122257ddda7785f2e311237265b8070015f2886f43a904caa7b7e4cbdca83ede815cbd7a5e1e6053b88e836d965bff38b4a6b966c036b1ff69875b3cce373f4384892d6c5059472590ad74284aee854f430c63dfae8f8a96b81bbdc8ca20850d676b99b9ffe028e72dea930d0c18146568a0af156ece7a21f437547429bbc8a12b74aaa7a100ff732724b4c055d8fdb5041db275752b87f7bd0b2df3c8ba4d10585540a0a35e3b8da181caa347247d150e34e3f82d64f8c10c47ac228b3f760861c2386e433fad92ebb0501d0a5764d095463f8c9ef048b41a00419ea0b359051486e40e2032faac2d95efc153ff77636116fe8d0e302068aec8de530f11a107538e3299fb218d1a071fa0eab50ce250204cce48b835e28b4f5d67aa462f440a49d75af5fe5bf00ef4af8fc337ae65cf2d2ececee404e9c0e323a381e90710e374964681dbbce72e2d8e8b956a33786550ecbcb485414d90232363008e28e794617bcca827a5f9ce2886bf5260b9d90c9ca9fb9788bd9354552f1ff83219921929204eee93cd8bfd406bd458f5f90795b86d3d9544aa911dc404984810f2165f9cb7950aef1aa83b36a0366d2226e9c9df45504184ed21411303656a3213e54d0cc26dc92a36975a81617360a967bdbc1e8f38979bb2b8a07f8250b404b18f15e02c3caf8aff11385777fee208e57de07c5c1bb2885f2e6d7c07786a725bc6fb4543c920ddf5f17e016f445e7e60fca16fe983060f2377cdcaa9c5354c8f046d449a2e3bfe927a62b0c1e0660a6a9b9c55452f3b9b883b46e0d3e6baec917e5ef79a73f2ece14f827878db2a46d7e48a8a5337fe00e93738c43b6e72e353742c4305e167a80ad657ec34bf58f23eaf32ec1fe1161c1dac620a98103a0845243c791cfa91fca128a62097f894a9c49fc021208bb5b01cdbb32c597af92917863774b4e1eaddba59751df1e7a8d29bd8e88271d859264edaed009960b6017b7831da239ab57fc2140232163cc3df05ee9bfcb0d3f8181a00da2db449235736719a71358c932fd8f62594783cc65b57c0cb505b15febb53369778750a87ab4b93a5639e2be8ae8e8af4b2b2daee98081cbdb6c8869f6da42f12b06c565a447df5ea0eae38654aa88c9098cace700507e3b1a403b4d7965fdd94aa06176577190baf73d0bc954c58e1bc56520d2306368d6c0061101ed52417debcf4097a0de0860a2494c61a1e430361cfa7029280db5cf1976769bcbe41b06608d059913c607f773776fd5f964960656e7e05154b782dbf84f41d5b6f77abf714cc61104c0684bf668da80e41a679649c17254d3cb41d5abdd2761fe84c38e93b42d0fed35ee924e9c8b977aa5b69389988d89aa71c554fc8d683c4197f13f003cb09f14889960a808f76c54db5e3ca0e170df09f020ee2bf53767cde195ec10794836698d85942acc22f6e1336d094665fd3cb3f379fe62f02b18d49292e7d426e8cc79228bd957f086ec41884d979077c04730567e4a8ee5d550a6c33b82ab6ae63d43a91e3d1787242774f21130be5d5f4ba3bfe69e3866f109951f033eda2bcfbcd58ce29af0e3216f3bad88b9b5497d5fdadd7597ef286f148c1c9285bec0aa36532b83ac70027004def427dd447f92c05e42054d782360bf550c959e5781eed0f160125237703cf78d3994bb39ccaec03ab431b5ca63ed813ac51e2b82d5c2b304aae0483bd4fbf34100db36457c40229d8d41dd1564e1bdea9513d29f50e7083c110d12973ad435518cc3fa934bbade4f2b533664b16cc5364ea459022c01c07f81054112d38dfa9997173ee21cc5548f8f0592a894c936ff19345cb2c24cd23a0faf4beda197564e62c32aadfaf2990eabf1d9e545b89a4a9b33e19a992d0483f6cb30f37962cc8c412c19904380e9504dfb090a52e49125c29a698c2d7d0cfa6e591b815f2cabe62c7f7a3015f8244c8e852a6e3224809788c7f793985a85aed4e587aa3289ec1da537d8d380c359375a323a7dd110f09d6226ebca4a7850eeaf10756cafe69676138b2e06340f876df21895b636e407649c3513acbbca1de2fbf87ac3d9f0389b4719ced3fbd8624d318ace03bdf64e6a276a23d5026e8b008ca021c1c53a59ed02e8e5ae95c49926158f05baaccaeb38cf118485d4e24aa7af94791b3071e9b11a7e1967b5fe761ac1ef01630f78968666318e535ff0b0080be4a5bcdc7b64ed405997e4937df89ae922f09c5c26ee6f832d5311769a23181fcfabaacb2e4c6cecb590e20a464bd57b0b5933850fdb81a9b0075d1c95f2d4c1194c4f9c34f248a589e81f1f72496b1b861ec0db85f01da4e1a7defb95bfc274e2f44cbc5eed54dae9a6042eef78d964aa676d59a1ca48fbe44d7ca7e4817795aaac87d357f8f61a31eda0a26c653b1576f4b6da0e47edbb00e275a5003a4343da6c597d84ecf3a6f4afcc26fa54e91bbd3b3ca5bd37a1b627f893c044867fdd1957686fb1a8f33a1d03260afbfa64d18ee7191f801cb652f5143c66ae79e0b108878ef8b5cd8e5df36f4b91a738aec32014cb88ca54e2a359a2091418361d6787c38dd3409b89d8dfbf74d296353e32dc77c3f5675d926193d9996eb6e4788cf72fb3e8a9c7dff840336622a5352923299fd98263070b203535a2ccd715bbb1fe4d46114ff10c49920a93e76f483512826796cd3eefc203afa0c25531c9b0bb50f5d58f5103415bb94c41147ec25826563866d9236f21618973b3705ea5f39819baaebd270163a0f384fef76e3e5abade9649734c4e7f8c2664ab542c3f1a8d70d767657e97368c4d7abcb1ac67404dc8b420d5a57a31d04c86ced8475b253a2d7c722a2606647a0ed46ce644368be7d1d6dad36689baa188746ad16cb3aa1b5d2b2018e4f48ddc749740866b6f31d38566d7ac315e870b178f68eb90e04e9f15898da264be773efb878891d246c6520ec9ccdde1b5f5bec484c89ec61a395ca5427c7933e7527f42aae66d4e733bf366ecaf664f0ffc3672854ddd31f9b63585c18a27fddc56dc9facf123eb86b6db043f46ecc065d24b7cb3ef03a19b042caf1e893b6dd3f4d032e1a7c0786e886d87453a4a48a5cfa97c9813c6f620e704417482b9e3d30785e25ef5e64a871c66a1f4fc62ae83f452ed4b2c3656ad6c4a8042fe43f09548db3c5132e2896f8c08131cfc5ffcfa96fe0bbcd9fb946e313226a3a95c7516f3ed7a8eacad3ef4e917c20b68501195dff3f2088044d730b66a9630a28374874e12bb44ab2310e531d249ba01da234ddd02eccf7fa3242e46b4088ae9d125ae42f160b7b752c808f8a783b5c13ddea9f18dc6823cba2012f742ec9c8d7a3106340504bf6a953f93b7e9021502f992cd4bb044fac2ee6e24f9683a7954a3599645b8edd14bae0cf15b0d9d7e98d25ac064aae1f913783d58a1a5a6f35ad2e2390f7b8ab575c834505243fe157ef5e5afe27053ffb5bdedcb3251c7d818045c7212ab912f1edfcbd3e2719baa99ae981affc9932d0b5824a16c8d4a96eb3571dd5651fcb1efb27620d4c38e4c9a6470ebed89eec0370ef52732541290dddd51f482ccd5bc0428cf998ef4cf7d828c8866f6a7843ba194c3d0c781ececd59b3c2e8f05abf86b7b659590835029f3137f3d0b1c9804f6c16b5f0bfe3bb7031c9730e161d5b0e99711c3ec6bf43a702c007ddb0f49ba35ff1c08554dee1e4a630a34ae3e40275ed1ce97ba72358d3e32650d7a18e173f79ba0e95ef51cbd7b771e69e194589c2b5ae2a36a9ccfd52fc61f88762c34273921c92581b4f40a6703ac260249cd205d5765cd2759287b010c8eb6f77e327073d272ed3f8d959665baf5000847f97515b18d7b65507a57e0fe8ae90405fd803fba49c3186d2e76786497b3c405e93a75900b3caddfa2fea8675b4ddf5b66295babc1f12c5167df3e9961564495d33071e6194324442cd1fbf3d279f51a0f27362b96eca031c1104fe9de61995922ed8b5725ec58e0f79ec9839ff3df647a60ada3ae6a3a25fff09d01c44d0733e3a14d3a1c0d07c861f879d58f87936fb9e1eee593933a9cb080822a398d6e1954f60f97cce31f4c1debbbd65730138d5c155a668ee91a333df5fc3f1a15f75dbd05c89e8da82cdbcc1c6c0fd27e6d8290f9f68806f90118a1556c1c800d061c125086ebdae5469cf68ef7c6461fa2f81fc418e9077da2eabf18970f2fc4fc6cc672656ed5c7860bb6c744acfe014e41822cd068885057510ede302a2c564196246df72a343c7b6d80e64404f715b608491cddaac0dccd19f994555f92aee03baefd5f0c1537e4d682f5bf77e09e1d095ef21a396fc86c477338389dc3c370f3e0be688ae5800e4c1696ec658e184a8806335f5d7e2429f326b06b28b5eaeb3c24420a4bd5bdb8c0ae984143643dda758c39067d907c0c64c65f7425d04fffa4941b65f299249bb7d6306c4d533f9e6c316b23c02a61adccda4993aaaef36ddc1ffd74cacd0a746938149713c66795f762c149fc3e25ae58e62ce3c2da6863c400072f3da5e9c4fc69bbe26e5fb72ed90db6186d5919524721f2f7fa6e948c0ad1b30151e2f1ea7a38d0a16526701f4e9d9f3a468fc27966db8fe96b0be31da0bb8f6fcd4fc74d93237719b7fe2a113b892e119846b7d72e61a222c4a2e07b0ceb266d5b48b9e8aeaa00e457358df86fe447faa9d780488c8c796d9f3aa90b99738b72f2d93b1f32cab865fce177e70cebd02827801151c919f5e5c162d58abb7683d1bc4b958cefa08c1e26c5321390e8f594dde87d750be0ba28f6a0aa1640a25924a542408d59d51d263d37ebdf280169e0d3452ffb80e6d20b2b8829f80f3a0335c3c27ad412a41f0fe6fbba73fb940b1c23dd097260fb8d5efd3763b779609c5411e5e995a333246fa0a3f4b46ee8e6fa5f9d921742daa1504b0103002d6e46b60e3ea4b15780c3a03ee0ddcc18cfe10b3f268629dc0e209fb389675a267cecda24cef25cd78280fcd02b95e1cc51949c58c0bb41d84e9cfa581ba218b709eee79f481b10a03ab3391a8ced1dea74018321253908b10d8daa7a17628c619fd6c04c5be79046779ff17084a5bb1dd865c8f0217eabba1699f1ab0e14a052a73c61c56a25e7093ec9dd819a3205cffdbe5cf89a2bab0cf1cc95fb5146f30c6c248d95cbd2a490ffaa54053b22248d253fc85939c8bc56fa18e95f40104cedc2710c0f7d0dfc628f923e14342d7ab2d2282f2685707fa1bcbd16e2735903a205aa615e2a2533be668cd061d60e9e1cfdae3b5fd5f903ad0e5cb0ade28a9f4f85c1d25bae0a9a8b15675ed595485cd16401f7ef690e2aa5c22078ec4dc17c2a72dbc1f85371ad1b5cac66ef0106a0164e4df9cd6fbeb72883de17e39ec1d5e644248307d577561015890f7eafea466fca3eb3364c0c883bb1f0bf452e9b5686f8f74bf86e4948a0b645e86ec734f9bbb819872d0aaa6d43bacdcf273c0e818e5e341e28eafb283d2583047a565deced6169e7b025a2311e870d81c122ae24e72be1b1753e3c5b3d9ec02b22989cb91a91a8ee31056e121ba2c1a60ae5db34c39d58e3a39c48ca15b038c238a3d6b461a87b372652437a8449d5d23b58f25db60907a1a3dbc6f62770e73a21ee3bbce40f64a201409fa1c58b5b7cd4d7b55ab9d6856dc5b3ac15c30b45d11a9c432741c890250aed6636da940483942c66ea6225ace19485e9025e3d0164cf91cab171d778fa341fb2812a1ae8e365fbcc128d5e06d6b4759cc034ecdf3d0ede44742a8a7ac463094469d5a08c217b1365b4b2783e0656604e4f21572718d521f11fb00eb0bf70e489f59ce866aedd2833da65252cd8dc83b209b876c7086bf145ef4669069ba53bc453cdc019a1400ee601441ab6cc85b5992ed233b9f95267c3039e9f485cf5326fa45ad6651f934fb7c2d9202102db25b243eb96fba00d957a4aa5b3dd333926c536518efc58934487048b3eaa6d2cf654b0e3765c352bd2768e2dff48475a9d0b84f735661be39b464279ee7a9658ee06594d3a8caa25b592faa8ea0ebf28605fcaaa2add84d3434f8882be8ae635f0e54ec1c49a58ffa2db130681b7bdd198831bb726062122e5451d420fe5a3cc41755613541b14ca03183a4a3340753d49a416e2c38ce258cef5ee7167130b4d3af3b3304aa79b71b729ca5c6309a07310a68346617075f9a2b926f85e13ad7cecf5449275cf55ac128c74ebbd856322e59baaef5deda65f490cc20c2807bf3594426b2db291665fe85266658417aec98884860c8aa2fdae40e530a15f97c39e9b32162d84f5677f209a5e7e1a2a8ec8dba6992cf4c2fe7f16ce3d825a5336b7c562c2410a3377b4c5eaf92155242d92a17b543d857b977bc94c59151568acff81ad05bce2f3c5e7062f0fc6c776b3f8cfd24037a4ac1c46aa1a0bc61e1cbf409890f5d8c0d7561077ce1a7edc414bd8d8c8185ddb6028e6b92be1dc33a8e6bf0ac73acd90f7ba42f0e73c2d6bf571a7f0cc24963eecc8412f9707ab4be28985f3cbecf6883fe39fa8ce4735f0235fb2db2bffc3e1cb7bad04ff58029fbc7c9663fcc0b3c859d80a5db5906317208ec2f33c76b14aaadbfea4104e2c2f0190cb18c5c41f440de29ece3f073a77be9c5150d6d4bb2db273e9abff95246180bf69536b9f3b072284d74c0f9bd952a9da16db9248f76f530c4820bb01553aab3092ab18a264eae67ffa13051552e2d5e86425e0c5bf2a1020f41fa7dd0e6bdb0b57dfdc42ab4371e32bd10813f447f17a92968784a38b8df6c823297b7f80b93ffdb390b4727269c2c01827a236c81a911311e7828bef2970c4e90adff03cf3234925eb7acc0a678f65c0a46f5014b0b96e26f1fe4451f611c7806684f8cbb0a5947c6a528057730fc12e9b54dd7a5eb290bb841fa3864bb15ef1e1975b13adfa336fc0664d8210279b3e40b13e52df705397790f2ba02c6a4209b3bb8dc6bfca7ce0af9176db04b691b890f3696e1d30354e4e9ddd5eea2759894964c6f5b3202a612398df0bf1b74b907c91c731508b9e18b16b1d4c305449b9a79c8c94dd92b6ad7038878423ff2b331e47644a183ab112fbc0819a9fbf0b42bed9e81c592ddf4b4e36fd923f699bb1cf05aa9f85fd4e9c520cff2c9626b2dc59a94261551a1ed575966605c77891a62c7411494cebfb9c3aebc68954997d21769772d6ede7c950f73e5d583bd4075c2e34130f7410f4c5eb581a066392bec70ccdb9b18aa10c179b0ee0c504b1fd27cade35ce4c6ca64882926c09c2559c1475553c4dc99f5a02e084ca33430266ace487c5cfe4124b1a7ef47aa6b2cb9b6ccf94801489e1d65eeb2204e19074fac32ed783fc21de4b73cd219202bf97d7111d8ac3eeb5e0cf55425c0244db837fed0c48728e353cbc381e8ab67024f1df2729372128043baa402a6c7cd6f29404340016480c7625b605c39bf63139331a8e5b7679826b8b45d6c8cde3d5d0a884ea2741873785c9abca553692291e7a877b65f17356efea6c781da33df1a9bd49c65d58db3bb711296f9cf9c83b12917d411231f2c036b0fc3b2267bfb6a6e71132dc7c321219e161e731eacdafb8e20c4486e7f344c6ed31a88203586ce5b16014946c09a0bce28d8eaf9c00709103f900763740db76d69e8034d656851f0c14e4c7c596547748c85857e3e13c992cfe20bc0bfadb8d9ccb57cb1981cd2e74a79f8937afe42bb60a656fb843868e6022376218be0c1be464b1e75f64020d6d6ff95a6586b777e82602243b5881fe43bead0e60ead343efd6e12c4752bef1e72be6e3872de4e292eff24763fed2e3d77648c74604ffef61899d2d159c2665741ab7eb4393350fbb828fbbd7713dbf75be7b1d3ba8134564345a13531e71f2eee67316971c6191e94811e100595a355bba601f610d766ae16bfdf0fbaddced11f630c4ae5b709675c254d7c162f665569626e267c6f5e1fd96bd45421ce3b63a587dcbc0ac3035984c716d6e54694edad4752a7516e2d2c3068e8f0435dd1eaf8e6a814fd98702fdbc6c91545ee517662f5276ff384eeefd7e80ff6795c23a76fedc3a20098f77e3378f32eca5917e4e87803a209bc7b4e8302f04160dd0205e6d35eb7c5adc2df39b859863ad9bb78bbc78260e0e4bc3a50dfbd8428b2fb5349d25c2f511349f91c833eff736f178c6746b3057e956236b4b8dbf3fd4d9d7681a1356f025e015eefa9affeb871b949c90d8794794d22c6c948a34c78a5e2827b263833e7e4219933e951d07306ead7ae281bf85acf3eb07fae7faef1733afbedf4f68a2fa8668a136f1a16e6fdfc8f968a82efd00a7f4b5d98a13e79be45b3ba911ca3a5fb8c33e01c2c358b2a18509a34f4cb365379d620b55888005d740b0cdf379e149c4385727d821ca6de9ddb50c7e1cbf1c6a7b48a5c934c8db5a9ae5db1ba96fc02c4b26c8d5e3329d9f2a96b188c389ada4cbb36691f1ed97ca4da1e191d457d1526dbe3aa866bedae829fbce44dfee57348f061233398806e4a16f15c9ca3de5cd926189e44692e99e6808fe122d598ca1a5a36d4eff887fab46ec3269d6c990dfca3339c1d6f032b3cb2f4744a14598a63b52f74887fbaa19319596f58989157b89d3903016de65ce22541c6cfea8b306f2dff379b465e1e3a9f3e6108484910592b506e8dc43338254d5fdcaf87799ccd5123df0347ea43aa356e6e95e53c530f95d50dbe5a0ea19eab62b03f319a3112efa21cc7a757c0756012a1567bef2ee9ed18422c90a851666197b729fcdd3c43f196b029d9c375338a332f3142aa16e412dacc1bfd7eafe20c7328a3cee33de051aed0655142ef15b6fa39366804a66253ec006568c39d35716a6aaa3df440f1087180a370d8be3025c64d9788388bfeb08ed19e02d1b1f6d27fe5bbf9d9db95cc4a834c2ec7be77d0f42225eb9a0951aa6f082a4c601af37f73267cddd46f0e1f313b4a04945b09f8b0335a88a00372806f43e5269a7526f65620631fb7fe341c270dec6abfc73742887de522803cef3480cc6a89cede51d9c5b7f336f8f13bcc89235dbf4b827ce427f51c68466ebfea9a86ef86ab0c6417b8b15d2ba6c9e23756e30f6eeefc99101bd672adec948ce0945eca87bc26e9edec023c2d64407ecac68e7ee21717f4e659105c577d19390de38065aead723cb910118f784e2c3f5ee63721e38e5dc4444d0e760387dae65230526803d5b3ff4bd3c4c1e8ef8a400e876fc1fe7114e3e0365483be990b8c3e90ebb1f6f69f9d0764b7b5b52267e0115eeec2aed10a9e25a0bcc2d76fcd5cae5d70e032237efa7008ac165cafac1678dfcadc5327475fc06d4a76eab6cd0ec79104119b3018cc12c7f72eaaae741310a1d1b17d6fbcb3fe4e69def40cedca430741d17c762887082acbd1cc59f91d590d1b5a99fd7a77c4140bd546a5f085234a577b2c1ddbc0d1c81d08a0c51e0a039c837b38fde042720cdc156bb6cc587c5b205ae7a3c2720f67ac2f240b824e4e3fa138a5d41c3b081739b9c7943a7f4591418bc0c9b45e4571659b8ea8b9e80ac703e521e9213671279dbbc8ade262b50b0c7ae9b9d1362679cfce56cc1605bf3ddb78660df547f6b36bdd42c75363c3d7a162bcaff0cb43916f4dd83e59d8b8b82de65b8ffe61cc788b4db208a2e831fac2e548f6eb24632c76fda57670026ab8b462786b6bd59358827ff06e887387d8c47e633b22e1b05680bc1b5b51c9b1b8e10a9680e62c5dcb1adf06487a767958f3ff00d7736f97de3c8dceaa789f09c29363995cace835d065c37b70a75c0e3995122b594edb9c4a7bc5834be1b0b00c26f988763ba69d732a58c1481d94430f90bb7aab83a2afa709e2761e48a75f99de45cc0fd10c3d017b5b3bf0f41b76745cbc0f745130e7fb963904f351e58a33092d7546f493a9661f9e441ae860a8db152c9b117b13bb89391627ab50a91db8c7889feedeaa428ef443ad43c486516be1464652712d473fe309c4415efc28b020a0b5bfe3cf1994d7751134531f7d07fe5062106f0e55085e0b074be7d3d99eb9428e710443596b6de0c848b893980ff5fb825b362b0e999a3967c863ea67751ae0c5a2dfe9ef219a8e9ebc2780db4e0adc84fd2a1311c46c22aa8cc3294749e93ab3b5212a6cd480d0e802c763969b70297c3864537c1d218ae842e3589039a60ac9168aceff9ea7d5309bb0322374174fb840e3dd26482a7f58471359234430f70202cfe46959ea19e55534e21a6d5f93f15971af770750461ba31270c76733ed0e064c34326b713e8197ad22e6722410343a185536f37241ba7413263b3c3742df7d306d6d4a1dacac332b88ec43ce4d929178580ee7900694e7a93c6b25663c2291f897461c97c1004fb0e07dae0da270313317ad65a06071e061a70c3a5f354e6d951cfa6968f55ab6101622552b45438b0fe0cb28651e82e7116d827e4ab629b082f2bdf68d841fbc698316f456e4bffd50b900f2881aac69706b7434243a9fa72192d8a07fa6effb3150df4faea6252bcb5d8bd4fca43f0786a1aa81ebc1441490890114437fd81dc4155ab1dc77ca88148a213dfbee5895d3db9268f2f4cdb4782e117801c7fe5b5c778816542828696ec1b6de708f4563f9ad02787f9528138a60a61f3f6bb542de7e6c2bd8a0e53307b17203501db3a6d25f2e37df18f1da53059f83712aef67b07f9516cf750ee8e4dc23eee826eb8000c70bd645c359548f7576d45d3b3d77edb6976e78a5e4012f0585fe6545251822c80d71b9dd932e790f14ae85627e82fa531bb5180d0f7c4c00977e7a6ff2005739281f3c58e96fe3969c94160923d3bf9d7ff1f6563f03a82a07c2ff12a6efdb2c19a6489275a7388a5c266559b902367f5da15cc15859537b67ebb927e234434b1fcc6e8a483be0cb958b51f49b0a157436223d873639904a29cc0338530b15aa6591271ba4c98d6626676e70e9ee7b548a3e78ab0f770b1c3d001a2e3a17ba350bbac1a80b675dd4715b4cdb542fdd641351f7add420fb6ec2fa84aee1ab0222dfca3f27f9a1da6f4aab464f13c3d640ef40fb67aafbb4a2f3f659d9e5cb0e192081bf0b9cf78634ff6f8b378061f04625592d8c2cd05d8713e747fdd40503e8c4ec11fc72e20960c7efe159a5b01cdec62115dd6aeda53c56d3ee6a6f2560d36388298bfc2dd0b339929d15ed3027cb20319317b90c36f022558ef853dda8a7a58263edbc7d7401285b67e7784c4d0525a9effea14f9b4ebbae1ae4f0e480494c9ff35bf49f59fbc133c7d1335700abf4bd070e5de0b6feee673f7d711b73ba6f810c1b9d92a76dc6db155c61ce3629d9bb2dca2842ba86db76c7cddeacf7c0c4ee67cfeecb1f84d671e651496b7e2c2a76ce497cfaf3abe5a056d41ba4fde35658aeeeda1b1b877d0d28a522ae33608f4993ae084bf9a9114afc213b3547fe290ad913daaab631ede15845e4116871d08fb8b585c21ec073328a37f277f709f70502e74fd356dfdbce2594a36ee08582c19443a4f3d0c3ca05f696ffc04dc45c03ea148b6470670d013dedb0babe60a19c4ee9c8bea7e67d6b736ef17f1a3c660aa85eacae2677937dacc211f446b2b9b78a7daacb3092aa8d5b79a4b936a908645336353fb2ad948f70742c5d7f9b2e11b608a5d7ca287697e60062259c7f373c99b070b0fa891010a67fd43b6afbcfe24c7b7d2f34a18a37c470eee71c6f68988fe891361741abd9cc28e643359605dd87dd5e69058398d57624d07600200b67dda522b9672a91981796438d95ce37eae402a3343b80e0f8779c3923664bb38da1ce46be2363a095fb734f53a6812eaa3b6fe0858b67944d8e220ebdd168d223d467e2ee61204210079dd388b6eb5c74c4b1c1af686b9b3f840b84925a520c877974fc18612deae9ff49b6d184bd757efddb7b2e770a44871d2bcd751b4768865b7393700c9cf20ff9a785494f6ac892b4cbbf63174772f4f31d07a8696128fab29a668d48c930172e2637c4ec40432fbfb1ee30b1d928aff148aad8a03956adbbab9d078d6fcb33241dc220ed985109224f04f013ee2d8794dfc3588b3f0ec0151149039470f11204e298eabc9fe5de90889fd5d55093f91cc74b822963f23bac224aa3cdd667631a091965906c5926a6379faa636aa7a48f7d657f75785964093ff4f0cdb7d6a7cc1d461cdc04adc8b6cb46bbab294c195409d753ddeaae9689f5a4b957ebdcc3ac4e1e4732b545fe304fb4bcc1363e15ae3b115e8795d07ccff5c537a8722ababad6e86b0f138234150bdd2a158969b66ae4396b4228406884815fc1a58fdd50492ae2a05d83026b085d1213d9f62de66435ad50a18f92f177bb4c464dbb94ab4debec7c406beebbfde2c5efbef77e360a3e895e7bc80cbb4a9d06043fd87a66c8e50132386f914630de490dd9c4732576aea5d5242ce7856a12986901bc6e3284b844d76d3a8cc2eb9769f8ef0bce73e5f0c8ab342a133d3a1c1dc108abc936abe675b2d0cb12f9ddfe7d4a2912b3a604cc39ae21fe1c8b96dfbeb016b8f60150f1676dbb3087f5db30c65825c24c48fab0632eb2aa4a93b59f128b02a122a30b9cb0f8c47ef67d2c1ed70b2fc01f7dc7520fb5c5ffcef9e81cfe923b1ae6eb6e300b4639abb76a2b2bbad5d8ab094a051d10c9b78ebeff487a790309bc18b72d984d69429af4d0fa0a5cc0db84cc670fee5b4453ce9de55622","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
