<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa6009088befbc92a27521c9d453c70202671c6076f0af763abd19e708904a43c1665765828b09b64ea96f6ad761a90b0a48fbc94588667c91ed9bb0fea2dfff3028b6e42084613b093d2817e5d5d8d79dbaada94171f49f9dc88068274e37e520089140a085c20f444d86fe4c20d5dccb3b76c04d473471a7122c372b25aa44f06b4ade37bedad84b93fefb4db89c86d957fdd0cefccb7baa692df160e4a5165baa14e52a99312e5e1f0bdc3a80f4b55b43367cf2317d24c5914917974a762653e525b7580f9fb21f4c60d18b811a1325840830da102d08f45c2c2a65f08dda556f7ad931ba7c6ce35e29c2140af8902cf3ac164a6043a834a5a2ac9786bbf6afda218e1e90a5ed2b1c8d1131ffd2dfac002162f4dfa5c07edadacc736fa4f7c298bb78e4e6549114e1f33e61b8d08a03654bfdcb0e86d06580e7c93b8be64f2607e467b887b02cfde0bee928e0b5d2434ae3883ceb9cc090e592bcd1db7fc035843ae8957820905f913d5bfc4fd05687a10f7fc633e546fc43e3574d6e6f0de16195c5a0a60b995d6bdd88c55b08fe5af84a46301e206eff40558308328478763bccccd16b7517fa9b0d8eecf1de56cc57deede4c7bd72c2ef9ac6ac575a2c31da233737dbb69969928f8f27cca47b67da6bc21af1207656fd2c8b5ab6658689b224662f8fec7cdbe1dfaeba3163dee908cd6b741ad69ef6381dbf8c22ce3d489d9c938615dc9b6638b1323ecccfbf2a09fbf3a23000659d0fd23360cc43c6c183cbea05c3d9f822575d758c63da88ee0663c494945a8c6a07f841d95a58791d2f41aa9d9f80439a84d147f366b08f3479e054870d91603c3d0476bb703aaa6c60439ae269615b107c9056f5008e1c429cc4c86e7fcfc219a9e3e04ad5683bc9b7de7103ef2d6959727c1f5e0abb4d3de7f0599dbb29a8f81344367d60440878021d9056900f6c04b2590d1229da85b6c2aa17a409dfb3923424e4580e99b9bb71d1271e8f1b64f2a659eff18d8abf5253bfe010e6861ad9b697d9bb92b4d406c34a579b6d3e33de3788cff35581c7ddf57b9a7dcd115a0346aedd77e09554420288e52944ceea877a3b527ac25c54640cb7ceb960ca915e0d51c1e23643cc6a9e066100b716cbfa5ac52d506c872da044c3f446e6bb40da3447349acab5b33ac096c674fc79c54bfb79a3631f8a8e02248aadda16958ad9e1913847aaa6ba10b6069ae195b5e511fe599f5d9c010003dcd0c9e98e94feba9c1aa81d80d4a1e2f071b229aa90d1f9aae0117865b7af116924e2283e1e4a9197ccda82592c71d81078326065bf6b8cad8500a336091e98373adc427ad90d7d9cb1fc546b58e1bed64617687fb36b4814e1a2befccb3937b76a99805a5576281323cb002c55109d18d81d761677dbe5e8505c9f0fd3ff9e94c695c789eb03795d9491525b56ee790eddc123e2196a6c18759237bce69338f99f286524c9bc5f3ddad371a94717c9f3e210d730be10185b0c76c5b04daea5d1108f501e80ccce4312851863ffe7f19d87bef1086da71fdce565828bcac67182ea0e5e505f00774c7b56d44ec3a4452519c29596e331e61d677bf66989b2adc21350161f9412e1154a710981e242bdc389f7fb34b763db71a95d23d0a0140da6df39fcf0425e059eff2a479c705adc5422c4e8ab341b18140ebe8dead2922c916a1f9a0636cf507f3e0945f9bc23ab80df2a3c583e1f3212ac60315e98634ba8db59054b94ec0d685e75121cc7ec794ce530ef653e65cddbf862233ffdaf45a3e51ee7165ab770b0075b5825e3d147e5bb2fd98fea32b62c7d8edb13464092bf3e236ba62e3a751b15284eeb49ff0f42ef4761eea920b3a033a248a4fa7b8bed99263d06a35b6599e32e4e4fdf0713f2c1371a17f1b6a7a9d0d83c8f6fc73e9d367617dba08ef4fc590e1d59da73f5c49556c9b5bcb9a9acad3adf1b433c0cc346f77f40dcb6ba3aff869b9740d135b6932b90edf241d3655f5078386dfc1070582c190853294a842f1d4c9e086c3e368e4a12d002b31d1ff9653ce42c140999d89606c716f044e8c57a61a70ebb1001847e4497f409daa3483f336f4d1521c34d9577f9643cfcf5123a5e3b6978ba87605534e4eea624c736a32f035d947777d5b617fd4a536dec1f41276d7e6131fb2acfea7f81c0fa312e9f01897a8dca252ec4abc509aa4f0471ed487638202f2e60a85a2daf03471d72e22166310bac2804cedd8bac8450825aaf06c9cd18e252769d6fd7ade06c64f1c1e0a57aa654af756ee7175327dbc3981411643fa934e2b85798a1c15d9e569059ece649f33f2614d645ae687d3452a44b15b52cde2064ab381e87a7ffcf45fd8c55636d08d724598e52f83595f59cd90199251e3bfa42286ef6fdb61607d5d3e7c37c8cf8830a81e83ed6391bfebbc8701e77c821a896e6a6f86c759d267a65773c4550c2f47cbf58d82528c43846b2f14fa6cb842a48e611b540d4df1150ffd1edd7d0d6b4a49a16635bf5657365a940513895de896edf09480891b84f5f0908b305f515051192cbe757ac346604f048f975050f08cdb56fa7745db0765543c1981111b3ba1b20a80e4c657fe5551c512b55620a12edcdf53d44ec38a83e2bc653a4421bc76898aead527ec14d4c12b2a084ffde4ab3d266dcd9eddd59e30fe91a826734e88e9dbfcfab6eb3eabedbfa68f5e43dce77d3696572a494be9c98e14683fd0e36caa0bef9f0a6b45f85c9f9acad74dde44566d6e62ea0a50c4a2d797247c40cd36e668fe53ddcc1f4683c211d2abb9c6350cb0a82d84af06fe40b3e3eb653fa1216e2c104a237170ab575d1f23b4aec0d4cf07e5496648befeae53d2d2e1ce84bcdefc06e124ab1bf8379e8a7c1214af9c1214600a705721651239991ba9b1e927d59fe7fda3d315b57e866132970397ec45418046d6da2025119ef204b0f67f84b203615661d6fde102d68308710bb517d090665cc55b07f6a63cf14f58ecae8d136e4348cd7eff49590ab4b600783d8818c6c6864cb375a652284ea4ca94d610686e1cd0b10da2e16eb9ca050157c18cdcbcb13f4de70cd31c35a2349b57aaec54456283fd020cd5cdb400eab96424f8328dc4d0fe072babc7afcbcba0f07b375bedab5306a1dbfd48889503ee3e16fcd678842455ab39fba98ec9edcc1ae65da264f46a1c97a2810880e2be9029b5522ca879c8839705f041983340af0db86a436c3476f9031d0684edd72a0f53d67d0b3751d160b3aa21a4a08c467f6793d77a45f9a463e80a6b4d6830231d05c0778d53f771053f7efb22e2c103a4edc2809e073744fadf55a010b36c19d18edaeda8bc7521746a18f855c1d7b212016b6acbd59021d5b094fb0296ef167375f1710872c90f7c54691b78399e5020f43da1b688e2657ebcadafe5f5fe84cccc1936fc1f184dbb14181fa4fa4340bf89100d12b6e02ef146a2796874238a423ddaff6996be9498c305d34deec2c538733529eef332cee5e1b4fa1baf0a5de2f35954ae8b603d290ead5c333e0ea8017ef84d0fae4404ce54f1b2f964895d92ebec1f7f703c96ed9ed9545d51e062185f3e12d318439414f20c01194ec336813b4d75f4cbeb21e3eba2373598f058a505dd3fbd18523941ee64a18ec7f03810c9552a4b6d8ae9cfed01d67b32ca6c97049840fb3840ed458c72ed2a287de644c6f8110ecb84699642b120670016c2e424f586077f9f39fcac0f789460f87c1ddcc6ba8ec9aab52478456a344443748779b475ee7dfea5c10a181a1c640775e00b819fd94f5135eb19b34471129621b31a4d9967b3b92224fc6a16139353dc21d8343858a866b038b409dbc460f3b5c44e1a4f61ef19af7b0e1d4fd484e70488074c1f9b772d5f6c4fa0aa3200f6f772aa1d48b64f163c341f09fafe30917399b71cd9dd0845ab1e586da665d1633e274b02ab1589a891ccb41869a1e18b7bc3b5db1de9de0b686739edd1f5fa2953b9f4b96e7f0f42512b1f89f500e1cad2ba2181da148beb251b846729274ed0d3815ade6863997e6cb57511b7f5862857a97e192cefd2fb72b02eb13515e74620bd84440a5bd752f1fd748821e6ee102f98f3fd7b1ccac509949ca59e75d6fcf27e0acd9d702d0a49e5d0452b69da2c5fa110d672ff50515a80a3147365e3ae64d2a43d063a404f92f9fef12555108c2e44980b6c8d3b8d3745d08853c7edb5a99041bcb9d1d98ab4c66031ff71836f698adad0adeb8f032c4dfdbc51c2e1af7e3656be329ecde847eedd1e2e66ba9cb7345cb59b673d0c13cc72968db07e0ada2b9d92e29fd1bf07baa8c60e1eb9e89167131980e9099dd87aef017de3c17d8964c73a90007a55e1c513efd2e3557e53164b619a1ff707877abcb197a9dc20e66d33d48033790a9530d4a2b322c34f5d785b267c318d4917c691d3ed5b3d61145e174e1ba4389ceef02e56a382fa4f45a8327543345896ccdd028477c36cba90467b01bab62a0387c9aef89f73e6e19ea7aeef76be85e026ff3301886f9facfb9b5e5a15d583a77f4b143bcd49d1cebf5a900822e82465cc7536c823fb886d5558978d09c4adace89e4d0a4e2cf0c0482b4c4fc885173a6bab78bb879a8ea6fbe410ee07382bc16b94ef35ff41d4ca2cf5929b030e324c650a4aabed42012bf7b5abc55baecec7c8a217b1e9ed909256481500d6ab4649cdd010980fe3b3182c3b0c44898217275533519c6961862193840a5b23345d15ab352ee25c30f7aa3848d8da4d147df97493f819f21a1f755b72437a7dc5cd19e5fa0d2af0fb197d6027650e78e7efad5ed4db3412b41a0ada7c84304e15105f9c59a2015ed3a7f08bf96442128832aa48505b6c223d8537657dcdc5b94c770f0de5410539d1527eb1e90eaa621bb6e6e0b587f82bbc162ec2f1c7b500c0822fca1821555cc7ad4c1451e56abe807e5a88701f8e03bdc5433c065b155898f6137506f9d0ebdb5111b7cd4e9743c7830a71a77ffa2e7f0100bb1b2998d40dfd7f332054a1e126d7010b540fd93366888084d9f4078f265b128acbdeb3fe9371ac326260b9b0eee01e7b9409de7d478050d78945f49200bd6d65fb7d009cc046caeadfda40dcb190f4d28687fc18ba9c8c03315f3af4310289cdaa5d45cacc35984f3ed9d9cc4e6d4ff635d4f77c080495b3b3f94d8fe0f7da2d5697dccda854bb8f6b2211a744e0c1d1504624b154b2e143374c50c30367312bf05330867aa225a2aa953c252aeb90a65302c56e1f8926b63c082e208ad2e5f32310d62cc8fc769242c3e23b2fdfd12a146fa995a74da149657a4aa3e7a5ee63cd9923c7c5086460f0a261d7a925aba3c0800102cd91d5f4927e1a1ba664864e839c9e3d8c9300d17f84867a62345d35ed818add3c63401fda7c2978901b09aa61a84933456ca3e29b59c704fa8b75ec3817e36f7bea7f8f2a47de4d05006b44296be6d7aadff68e045ace67ff080cc246c8ebb5c4b9e37e701e97aa6bdcb7914ad5587c526ed430711217d44a820e13962f97b8a08c92125f95b9392aedd1402ba1fbdd4de2281b28c604c1d30f1ac46638c4ccda1bc67509bcbd0fe6785e52890622d1c53b012d8c2cab228909959e3f68b4505fb03fe673d900611cea91989fcc4dd52e2cc30f599b55110d5d811760fe48c6de97545c796d4aebd587dc0e507f825c4dd864565337cfa158aba45b1a53c9d4f7d01c0d2b974135d7b12ab5351a0b567dc06e0431d02e42474d1a124ca00bd94a9f24039c6d376803d0360fcd1efd1366b2066f21667501aaa6baa9da8004021f7e3752bbc47c702eefb1000a00b4d19cf0157f52966df395af12f8e0c32220f95b3aac4f54deb84a5f6974f169a5a2ca5213aa04c18ce584eb0e391c85fc297c311961eacb162ec585850e8fed961db5ef6d5105457b57a53a9dae2d0b0903d8aca1cb3941147f6ce4e8c9914bc0838d4d293fc9fb65e5cb712e4b5d03c0d4563936584855b320c7dcb2ae99c1e34479ba8080db7abcdb64254dc6f69110d7ee49314c8f6b3fd9deb53dc0a1753c54a46b7e1a179040a594c5e37576023e2260c1ba33e24d71ffdbe2194c583f61d62312b2dc0b7d2fc17bc15bc0411070b70898d9595dc88b9cb1e04e4f64cbe984d9a88413d32207d51136603de7a356781950aff4bd52cf9c243a4c59960427a326925586bcd4817e77846a3b1eb62014fe8805f6e5c8ea7c3ac2d76cfa16b79c61c16c170db6ea65c36e5d6a11b41a5ec6d4a65998e3292b04f5a53351f084f7c6a1b4e7263b13f26b192a7ea4e9e8f75443bb65d61209cff54f175db474904a6b3ab8e41981ed0e363da695ad23d856b8ca92a9a52a7b406681240f3d6d991a8c37a9166932cd6102d29ed09a2663cdc290b72b8995796a49a0131bbb76c398f0a50ba5b4ed592bab52183fb36001a5fc4b82485d837b8cd5a93bfee2906fbe74c7fe53f11cbe77eb2e5e6726a7d490f93645f62679ac6ddb7561c8725ba1851e8aee92331123bb0d8cc4b74effd88015458baa9df3cdfc4d69b4222f35adb3081b0df707dbf64ca1fd51621c94b49f26d3773f3e8b12687fcb086972645b4dcece65690ed63f9ec950ad9fdc92191d338f6f64dcc823a292242b1e19160f21299ee0870ffc0136a86926a2d1d51ab10d64538fddc20df2b61ca6095d7421a993bad3dd45f490779ab9af8242fb641290d910449505d76bb744e755aa01d171eaca8759210704fcf0fe3909428f79d58b87ef0d27fbb05607a04729f6163f4f22c09523daf2916ddd5c6403253325c8f6d6474667e507ec3292a44c498744aab4148c5e3c41270fdeae974769a17827463179e613bf8b2f839eeb1f3ffcbfc997be3e7c07d28f5b857bec8386f812b4a80d993601e59fb0c0ab3cd8f9f5b3c58e57f220e6722039e4c18324a01c0c8a1fa6a4780fe7f0c44c95c085c0f4c9c60962a024cf59653be3113463e5c24633b1fee476e25c2cf140c701608f50a46d26a28c7011987069666582ede92213c14df943a59f2dd2925ff5ff6674a5f59d9a845e9aa7f6aca8eabd8ead4cf4a0eb2da3e56c39ac0e7be6be474141c8c075a0d9c84293f6aa4039e7dbc3281ba72d23c9143dd5fa32fa2d03cd01c246f405855eff7c2bfa7432c6cc2f26d198196ded17abab98fb222d19757d7302200fb678448163072b100c65782ca631e1d9bd83f68cc875529cfa1427c42b9a3e0842b9028969de052b72d531f9244e07446d46e19b4464d09c65aeb108e54a103c51b0fc71d8fba655c3e388f78c888a690571aa8e729b05e6c48f815ecd431bc8c4a545203f6a94d1cd0fe14c9f30465cf471ca9e78b67f630afcaf493be58d8315ef689b9ede97fa400ea8ceb5fe24f0e5c35610303a000416bb3ce1483b231027cfad2d72e1ed018db9da77aa3c6e1560869963db954bd054fbf791c7845a420c76574ed8e0c4d9352cb76db4c2b4a9598b4e0b0bb201d4593e990651f95a37b7a800d3f470f68022c78ce13570fcd14d64710605bb33b28459576b14ed5815ff0c61e5640880c62f100d4b4f356fea7a74c6c5eff41562b4d41dd8b8d6436b855ca5d2b04cb94875b738b26b54b98716aa654d37fea485e4ed823c9db178649df07cee3cf58a7581f9117ad88166b7a29fcb830b3eded240ba07c7cd1b7821aec1d4d7d2b0e315298dc3691232bd1c8642eb6c1a3a57979dc790237dc8842df5b251e652e91656662e7b1244bd8f4601c6d02e90071bef9a08bcedbf6e331a52c14f85a3b71e175bdb47be2a823b3298e0073f386ba41e9daceb13742e8c8491c061b93252bc3b26e60e64eb02de4d180df536a9a0227c44b1fc79b0a56b9ccaed04d729a2adad9147a3979c2464cafaf76bab213d62179435ae0a97f8e2991a85fca00d07e7aaba3c87fb0eada2443ce9262af2445e9b1d69ef9dd0fbb870de65c8a6a341c36cd27b09978bffaca24110b00627b9d2fc8b3dc0eb54eb400bdbce3db5cff4dfba996f4752a1ee264c581a48472fbb00fa5c418c931a42a5e5a663a10b16b23f4783200c93786a774f26ef5587b5ef12cf5ae47a9a63fb8702fde3e67fd66dcc1946b7d46f1193291ce0633da2e68e7456ab44228b91fb7706d3e15bedbaa9a25da92c3380126cf8a8d817b1c62c6bcb0ac163e0fa843c1f5ad5a7b2ec4b1b652d8868927cd6acc84fb1d1abbc402cd052fe150c9ec4de935dc30a094cecda74a386b60cce7032fc46d231815e97931ec7eef9fe17f9b92becc7eaadef9786305a67d7a7d12acd2824d07e2df756a330aa722a587450aadb23c726e6cff24b95cf43b039738cad5cd2cb985ed06e80252777889bdd69073e5043bcd219966eaa010b9c178c2b22994822dbb950074bc635fbf80b6d898035466ba8403c927db688de990eb8ae9cdf79f61a6ce924be49312888bc61ccf0bda579daa5c702c7d631d968d1777b3474b5681356883e6cecbba0fe8fa5a0abf36ac8a785311e73100342d1c9ba33d7093fc3c728e335b2e405b1f5121805f459e45f5a91e175aa70fc9aa3be100cab5341a17fc6a70dcb6cd693058057daf21426113589ee023064e8ee0c8c3363004caea11589a217b749d4b038c699b5e20e04d0cf60ccd54889b73f518367a92d1a7030a60653136f2c5571dfe9f7850873ca62c7d22da8f7b34c23e5bf63070467d06503552768262fa5ada5a86f8ab417f432712a03401b5e323a02010203219c3fed70e5e4c90fa6b4011537035f673d8b99b0e98ec4e5281f3d44eebb07b955710a308496a85aac87cca57baca7e38576ed49c6b64e00f988de2a9087305825ad78854c3a931bfe33f9e9592e689aec9b0432958d6528c1eac26702a52d5f6b12c552a9773d8bd2cc8a418dc040ecaf109f37a7eafd6d01d96ab580994e1fb4de41b71175548305bca248137c78e6ed6bb7073bdd7116c349e758cd2018805a4816e621c125e63907d88d60c1e5b7a17595d4dbdaafefaf890d07bc28298d9f20b3bdeee43cb62f3f1c4ef60b82821599fba47852afb124fbd7021314a4b350749fba88dca2ac889b4c3b205bf29f0135ba7b782fcc2f1b994f837e3f70998852b5f2e0b891b84ea95bd9aecb937c6b85d2e84885c7542deaf2af8edb8fee3457c7a1be6117be2fa590cb18c88895cd685518c2a1046befd8cc4b4c9548a627364e39c8a9ba70814a7b11eeb0f940e297453314b4614223a473be034ec009d7f448f7ee767193e5bb2405d46c4b34f99060e960eeeec64a25213187d35563697387f7c35c8c2393e8ace5cce38c6fc144b48e9094f38d1df52964c5c88e549ca72cb87ce41399c6d14ca4117418611a1718d9e18264a7da7d3c84f9af8d5fa8d160066e75c128a0c992fdb3bb2e421d958eae2039f3cbf968d9d2046e2bb1ee363281ac63027e2bb2e59f94a325b20812d8d57cb4933f0a096cffd2528438eef7d8a1608cb50e0cdadd73bee48123d04b451931c0f54a45599767fb57bcba70bc6d6c46a145ed52dc888831703e72eefc7af2da9a593e4cc4c5291d42ffcf8bd6f7ec71c5157bb5c0bd902f04b30d47e3fe29ce93e8a21712bc0c73ef899f676caa0e98ca6fe84fca77ebc5a96407f3b90ba21a5268bd953034d8dcc775eb03b6ec948f5de9ba5a4757539b31bd5eb974ab2cea8bea22c4e3702b7eadc3868729faa41bd04f8a65f221b41c2a846dcad57833e2a4472499cd7de342f9f01fcf525d2b4ea34607d5ecb00e482dc64e7580c4f70f01a23193934c455db6a4acb61c1648b6970b511bc78d4866cd90f8505df0c33283e7f9507f365f0a794d8204d1ed1b13a0792821107d5abc65fcba782c42b5cd6b0c6cf95864afeddb00958b58e051c525c02ca2bf7ef6bb8da72af74f7b72d1ee16c92019484b72e11a1066e44eea7e8550f193b4d6cd47fe957833f6cf8a4b10e5dcf4d4568ac3047bbc0fb87985e7099d5a5ca9d92ff29b6213fc323af148268de2c873d9c5dae9c3f3478644de11effda986c0c3062f1764dbd1300fb5b218a5aaba3409185bdcfbad4915317ee4f68681e9e70755a17c5fb160458e61598061961e666ffaf822bd22e0d9d9dc9a599167b57289e89133d979af597e7a877e90cc433baf32f18605963e273e559b5c648980c297e08a8154f6d576b7295faff6ab1a7db1300492aeb1a8ba7f4f545e8d98b2fd3118f7daf353536ed7e07386559f33d37ec0cd81dc9fa43cc9e55c0a30d27d69f593d8a6d793dec5e04d5f1211a5dead8bef413977d375b46e5df350c260331803d2355f587d5fbbf79548d8d4fa0dda541e728c54a0eabf3e83fa091fc85f5bb4849d45e2f43f6f222dbaaad4acab91a62ac84c514a4232e375e1a3023aff4ea3e7f1bb976253c52ea38e4a439c61be6c5fc71885fef9bc41970a7f38726c7cc184c2f4d91f02394119bfe083530590f37b210d2e2ced39fa508bcab2a29aef6da4b44ac236b0959d84d961dbc801765693bd6b6365d13de4a699ec7f7ee85cdaa409310295f07db5e3932d705bf4f4ab06c2999f5dd31a3a6128b2595d35dd33a6596b2d869293e6828171c775183705e76c95d7e398a78a15201303724d08ad90d5f1f008ad9bcefcaa9cfd25afcac155abc3abeecbaf06883981db1c2ec8f126e5762214ddc6f0ecf1247099792486e8d6268efc7f5fa1a5f71287d40056598bfa7237208ee0ec994f7c4fbd22c60ea07cbf48553b9cf955273eedc032fe8685229aed392739f95b582dd466b56f632a26478c5c8bf11df0fd428410f6624c344c0d2d070c897819e09d43d721c795d5077b1c55018ea209703650392f59be84ba9ed695616662296b8faa42f896bb422d5ffb25b200da80745316d66f296def2938e44d449ddaa8c93bc4b2fdd61d8acbc39f70357ddbdb9006d9c76660ef9f41567511c6833734524f76a960b94805c5567caf921c59cb3fc9c1923ee43c90898a73a1ba1a857117d9ca0c9fc78fad42990ad72186b1fe0d614e21d20d9a7184ffe71c348f074a1eeb496b4337aa95857dba729220fc176fea732cd10ef3cb1ab4e4b500832f28ebd660ea1762a37ae7883ddaa4a4c7a358d335f1e1a9f04030a14d83befb5d0da19bf568d0363b915a8f136fcce949fe90e509aa6b171549e1b80f4ffb00f244242963a07f7bd95b608dc516a55d56c24078191a5bc648fbb8fef9504971575a31b0c42e9a96ce1df3d07ad511d3c90622df11bf01d58231066cada6fac8809961fae1ae739312a0fd63779af2faf7f77c68392c29a9011cea755d4c71c096258373d0e6d7a5deee67424c8bd21c78291e0731e1bae125ed2205d7579329a0d8b6e5c02836b8e3de82ea2928c05e4705e73d8de1d410b18b06616901aaa89a6a5d9b1a1f59d96998a048fe7628b50654deb323cd840b8593af7df8d46d1f782a715a506ee3180703e98406aa913734e83d717a25365437d73dbb4f38b4090ec8ca6263bf611b2d8f3c1cd0dd03909da77efe27505a76e08f91f130b7c934b4f67afdda611774b83a1b17f288ffc1ae6339363b5ce11900d023f67501242ed21535a55b9bbb80393368735af83d4455a3d66baccb02e435d99e667b8de0b2cb4b7b082932c77e88677ca94d6d59f707abb75ecd80d85b2a6d8c40ec79d38708cac0a54f40b78f7cf4fea41d5feb61825d3bda5b6ceebdbfde24acb22373020a3f259910139e9f12273bde0001a797cc5379d82b28c7cae92aa1c694846f6f00158900af5319bdb1a4b4a2c1590896773074fc2ac0ee9b9d9144a487e05e5a24f9626b9b08e038c8f60184110ccd76c775225466dd64aab72a0855e593b9a6aa3ed21ba801ab052271273fd3e309c60350bad1b13fb371ebb836107cea43d3175e7253efa67b18014906225300c5a791984d5009ea6b54ff443f225dcbb77b0e1a19ee7832bf974508d219f3bca7fbd25c85e08dfcc6d719e3b7bbb80510d89b8200b7c62b8066f0a390011f9bb3194830fc1282207d31c2192bd40e776a8a489752eeb2bf48a959dae557739fbcf4086a9b7a9a6c925f53f1c59f998123837a7107840cc8fb7887f3129b3af48d3288154a37789db5142f42c52fcbff92924e85ddd51d52a6dcdb9d4fd88bf7c8cb8d609c31c6d8c25937d2761dd5b675150593ca2c500bcb1301f2b5af0c4d0171b4fbeacd57f23f5777629cea05594522e90c2ced10f6349c194ecdb8a5694848397df98e0d744ce23389fab3c4426fbf302a07baa1e0ffd2cc05dd73eade7db455055ecd995ca4302772baa7fc39041bd9490a28e2079d50b905710d91b161b1767f81672985a7fdf5c09abd4aea992d61941a60a06d87d87008ba9c39bd6f43763e901a399bc54514d8f2ba7c23f69a598f5d57a75b9b40f08c0b72e06add85ae14202ef4aa1ccb4d0f694d794583c2d63a5f5d350b2452ed028936671657ed461e13f8c253b32473cbdc48a92013c0469b3911eca16aa5f1161132094bc4de8577ad89f157a07a8228d8f38c8f8d3466b57bd73023d4821b17a4711f3797b01f1ca236aae475740b6fea5e790142d7af1ea8f4e118ab9a6f35f2a85ce35dbfe6ec417913d47f46e7d335f58f9dacb3e79a8be3a985aa64aeab99af1055d35b4fc2b75c0d0b86c72a5b4d141f170fbb1d37d77624de248012a57fed0ced35ffd3afcb6937c3e478d5abe03ad40a05d6d37a73a4d16c3d3367e8531ba7af1fba7a9892d7a90ffe6c26ecc81bc19500c808ea4fabf772b01c13dd23c3438f91ca420b10bc383106a08e179aca8b780d7c405ca6aa0f5f3d8265ad119267cc395cc7128c1b6517e1d124afd6751cd745d81bbbbf6d80c2be52b9fdc9a4ba8378d2278c5849fb22696cedfb05cacf30fa84cc3854373d9bdd9c03b18e8348beb2f7a4c269b2fefa8017455f289074bc2cd55c8160a636b4b494c4533f0b9c9f1b34f4881afdd0c218a196ff53b3898281f4cee3a55946953225a1818e3e9114258754d8b8beea1c3f04aeedff6824b2efa30fea2cb88f2c779e16d3a1ecfd5ebf6a72a121685534f40b6f2d925b2f6abf461e268ff5959429b66be015a077776f71df3df2bee299f4a6f8a15d50f7d270fcc4a4dd84996120763823909344807671eb979d046b59a6a4a653400bf888de0918ce96872bf6007aabd584c628005fea39bca5f71a6da77a4d62903ec6ed0b686d5d850409398494d62dbd02b9b5ff576116d7e9b209499392cc43568541144e8d4a48c9e1f145456fcdfbfd8fa4fa0dd6d38976133c913560a0e9cd1a6a7d4c2bb76603fced2996e9300edd29f7bdb52ce8a38725296055184196597898937d5c03ae743ec99afb71ef11912a7ec49d0d03310bb437c5872172f2da16a7b479d90ffb15795a4cfb1e803b946be5eff44c0ebb8e067e1125ff9810492c7de106814cfad6b2d35335a1c72a4ac5bcb52c4a7a53de7c39588c2a6ac08e661ce3b98c6e9b76dba3dfc85b41a60216a5f0e95ed68a59a09d54899bde614b537d737a44992e062f3d681a86a539c67802436044d478e1b3903299c7c0647fcf18e6075c59c318a85a568b6b1844ba7af05ace4d23b4d7112ba299d1fbb633e568c20e53a0a5b2ad83dfb41da15c95928fddf7043de5281015d0fc7009d0ee7d4fc0763cd26cbcb7f9c693c53c95cbcb4e703d06aba46300fc91a3a73da50bbb2d34ab9bc52081fe7619630f13ac96b07e579c65d97ffcad2a4d77e30f60f98f42b8295cd7c62c8654a65f8d70c5864871e5816e7964e71fd9a8bbb2d42795650194ea05aa869182cce5bec1ac8034b56134f2edfb1ba5ff299ec7cec3ac33056b97d1eaf297e4c1e1238e3d35c5ee4e3f46d42437c7b3c5a69571bcba65a4981182f0fc5cc74d353b31f4ed30d513327be7c019c5dee34748ad63dfb1af01a78474dd43cd1a0e9e00ab8292b65ca192e3a0a3b9fcbce25ad66da02cc1d885ffe5817b5b1104905fba523efb7eaa6118f332f86483e46bac95e98707522a1e2a1adeac674db41bac51fccb22f7e5f686222849c1fa06389db7449c3be661b8b1541e6a87b4803285f4a6af655b8559b3735d0c6dbfc3f6c1cbf64cb9d3d77d65fa98aa905f0ca02755fb6f4313fc70d619768e57c22107b11ec661c295a7e4f96aac70ea083c10e45b59ea989e1fee09f924801363d3139f660922128ed418bcd89f9636752e9c2e02a76add119198fa904378201bc52cad7a54bf012cc8a813e6a16383aa4a108ae235adeb48f8187b1e884edc10b030d68ece7bdaceb6854d2750f9ac00c5470d14c2a9f33d9dec7367bc985171ada6e8e785e3fa8bab6e0ff2eba2b184e605426e4b9af8363c687727af6dbf542f2e04ba3d9578dce946ff02e78ed433f6981b45faadfcfe12c7ad7cbea9bfca1118cb7724db650cb138f6cc423339f3f87e7570608db503ba4bc822354335417fd7f8aef9a4c86a378a3fc763c9fe89a5946eae1773a60088b8f882de1e927a3d98e1a35848145863d46ebd88209a94af013b1b6cd181c4a6171ccb93974d2704e20af0df5ce7431dc6514f6018b2199f722262e7cd1f19a1d82cd84ebb98f6a84335efc48fe603274a5b0d93d82526cc38dbe12e00845a940bc01168a90611d417f058466c1fdebaae4df7ba34cf52f09d11d027955a51b80d330c78fd490118795288baf9346a1ed76104bab10b764b4fdc3b58a55db5e217f6908db210c3e08c2fa29ffeb893818104893ce1bde4b47ad887d3406251feb8645def668aaa8713ec3874066fb7cd72ee7d520caa38abbc695390f3f55f9043eeda611ccb077e25c67ee4170a0940c956ff4c9c4950a14632d22c482bb0d3ee8e0e8dd05c3ab7c95b634b6d0f8930c2a7eb3171ee9984b158d792400ac7f0d738ec147aa3a6015e45041be949193836f4e32596aa64fe6c1bd40730cd13caa73cdccc610368dbc76be659e7e47e54e6e6c35b05a24ca9761ad97ef366de4cff6d99a68b933939da6b14cc57a7f67d2ce73f535805e3ce8789a34d053547416aabe8a8bac89c4fa2e77356a35e556138a8535e31efef2559d0129a40aa4685047f6a898338575422cfef57652cec8d1a8560e8fe369ef7198d95541ea7a7d4f1b6a43f21218b7126a06080327f3b76da8995efb87d6af0c31524b257d2dd3ed666c48cc70e44a33c320abe82221c49cfd01a220386b48783974d1aab950ee3dcdc831759ddd7c607eb98d2ab847a497890a8f71ee93e34527db8cf928e1ff4889bfe3f66cbe65ac866b3f545b140ac520e64fb0b32be36e89026173e8ad27503648c0881c1fe1d935fd17f6102daac8fa336e62f2e9881addd4bbd428537bd064039004b6d2182bc24bc7f52af21099274628f7097870871efe2445bffb0daf1c8f23fd39ead6e8f7e8dbcb53ebaa1e2a83aed8b4efb94a9bdd9314b08dc32d1766b5b8823ff3ae593122021465808c3bc9abf1ff28eec52f6d6f481229a5cde971cd1e49c392f8dcf45ba5354d8ec4da904a4c6cda6f6754ac074a5e385d1df2491def42d18fb005903b412907feceb02a65027ed458827e2afd3d9e6cab03456bf96a8e9e46f5909b62275c1827a78a334fe277c8a7c386bbf9d03452f26fe96636d4e742bc5f9303b23ec12a5c101d90a6c348ecb6837dd570d83db90b1b8365aa555d3ff395b2ff61f4b4bd5f0f302cc4a343aa912697d4a10d2460ba510e0f470d2cc86634dc32c25ea5c2fcc7bfe592f326a891bf21ae00b9efb412c205937fbe23c39b7e892c5f67a2228e5a51b399655255ab92f90059e638983c9821bc23d688c2611c7a9936ff3e9dcb5b7032f1c7ec3306aa81fabbc9cc29508c013b54c77c44e049dcacb2210f2a14f4d4ee503eb8c6e2bf6caf547cc6e0b79d96a70f9d0a475393d906bba51ae33f7e7b6b980265ef48c98797e51ec58263226d3717f7299cd8d1f474b4b19180d53a9fa4dffdd7897d8279fcc9c91c9d0ff80f4cd8e544b9565f9a35f7b747d1bc4efaf45c03c64fdff260895485fee7ce9cec84b8ccac87c31b6ee07f9cb5a3d8e5e9fbc2b89ad928071e8712d76c6117bce022bc658122490506602905ac4e759a1b2a0d63ecdd596b0817451411b934f5d46dfd457279dfd795ffffc3cec8cc954edd1d05cd8e3afc6def10223ba2f1a2062f6521f9f39a86bf53af13fdb85eee1c26454f336fc29140078cd104ff584b353014713d22b27fdfcea88eb058de5960726b209c1896e4b79e3bcb2b66c7e59d2b6d5fcaefd18f9a8db7032a12b115356f302eea670b1b181b1e1ca3faf11cdb57f5684590127d3e97380a348b1b1330d916dbd8069340a8a54e923f4fd827baf0d3bcf895625ffb5ad9bfb5d1cc96dfd2a7bd76b240f8afb84d029ceb13127c9d6ec34def560e09b7a53dffd3b678e1e73290ccc8db5d6742e159dd97ade22269f7096dd21bb2a6a216c0cef5989889b90b20ed70ddaf21c7c366a9903e46afa7bc4a7bec62b85452c06c4c4ab5496b43ee5c57c3db59180f6027e5a8d4475bc59cac8e891a875692ff7db38fb4bd9c2818b8fafd4565b875d50a50d157b04ac29b2c6bdce6bdb6afb5dcf224a95a0ba68716d593dc6130ea32a643f2f8403b4c925fd9a5bca8225bfe21e68773a00e394405eb29462a0583b0e8865782124cc88658fc06ba9c8945b11b8030cc05c5332ebe6de1da87819417ee1628ae5c80a966332f12828a6213faadb75e0f4a632fed8e4913d9b6bd98e34ae7c73a8803b0ac1b41264b0f2ee079e8c8d8957e78cecebc8b0560f481458eb0061d5d478c00e0e5bf0d9e88ab73738494d7583df88f208988265bc29d5f0aecca36b452cca4020d82c103d5236a9a1dfe328788cd7e0e2c45e202e191fff909d17312a8d4282df6df389ab1154d63e9c76239093afb183bb6c4ee461d2300307b2a667a41171d7d46290486f5cfa08da418ae0ccaa2fde3a31754f7edcdbf53a7d13d6becd2097ecef987c0cd8f1429e374794c60dfe527259e487d1b05b90d7d05777e3b5bc1d549ce6db234179ed1cd88830986d20e50ac3709900609e801d1cba5f53d848af6527749bb113c3ab9aafab1ca1d1afb996e01b4d6c8cc8a9fe29d05b4769ec5ead24af8b95afa8f46cfe689ef076cbf885934a3965fb700fe5e57813ab91d5d395da408c35f23f0aa85db6f6a11acd3c07420839df36ff0bbc90479e607d4e6595c548990dc1602e33c8e0b85e4a473d87810885e94c3259810bac06053413f603c1702b873f5abeb9e7374179e0a81cbad04ff404855e90203dbfb7ca366343b849888ab01631b98074f51df52b30a3e8b97074fe8d2a82005180a35fe3dac08b45c0fe195432cd988f8b5d44c7e543dc4b31a0b50a906d1c3a21dd0fa4659784921e1810c639973bb5667da8ed0b3689a6e1844e1cfa71bafa8707a25903159f86e850a626b48fd7709406df66c9ac0a9e532e60bfb4a095772fa76de74446484425df6c463e2ca019a170dc6e90159400b4cd566b0398808a52bc875ede87b7e63cb77456d9ccac6897a5bb4807354167884377e425e042e13b0690d19b42781dbfbe9ce9e8b92443658de85b0289a25fcd9e35390f0d45bbb08dc8396c9774e1a5928c5d1c466ad80e0689a229d6eacff8fff83f9bd290e859003af7fe562bb7b0e344b289cb2a5b8373cf4075af287e5a40c8475a33fe4725a6633e6e9ac2d96e61fb26ce017d3ec5b09f91761eca00639717ce1c44a9502c89a4281bc7a60e495f54b85ccd84c0cfb44b0dbd7f6ede63507509969be58be004bb842b18d0b5d9e7709a1fbbfb834e4fd502ddcac34e92c7851d4459ba87a4fd01d54b20e31dea065782bb72b8c24232d843a2624d07cf5a71e77f907b6650787fadf7041f4915ec723cd805df7938dfb61be94abdd35ec75caba727bc019eb8e4003ba456228e4ad43a02863afd9b91c9d4d7c5f6caadc0474660793b34a3c6f2368411cb17be02a0890e63ed6e532a5dd91ff99","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
