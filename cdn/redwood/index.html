<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ffe8289b884d0521901c6b18e6ef22d072d88272d2dc385455bc3f249c0bde79252034d41af194d02b02d9471f982f57c574ffa6ef8c423980ee1946dcb800980545acd2f20ee6e33234d4f7d2d94ef74b8de534d7afb86966ed422f626f813843a52d3a451c1614fd374887ed181fea5a47e66400060e51d144e0c88af97a5875aed383d66687c99559ffb43d388426f7049c02eaaad2bc4300faedf78ad955614c63401b8cb10c0d3547bf5e93b83109af41eaaec6f42e9a12312d29e92dd41fce2f7bb470af5a96c500a7964bc10d29dc4077ef74e5815205c8d9895233f6f21e9593a115cd09f3fe01dae0a4c7dd419f92bd7bd5def490c6161b44574d09ca0f8ecfa9613a9a97283b805c00c977706ab5ca874bd0a8445f4a04a4b3f0bd8043f31b3dcb963c027bf7569122ace3abaf22a135b4521b68e3cfc063bf243e605f922f9dac2b1eb03aa4fdb3cf0231e063aacd17b734fdb91fa9013a76f5305f11515bf20296ae8e32b88eaab03fc75fceffbae5403a286e69fcd05b74aea93d7420169589ae3c3a1ca5ed8fe5cf9f6e9e18eaa62b466b6dea584cff1a1fd6665f162f45046bca0d352fa0706f65a57a34263f09fde45df64c0ae1a5dda28cb57bfaab10c51304ce06be172a48002ddab635404d8df2dc5929a1382bb8832e69830daa4417dca0b282950eb01f4eed4411ed9060c60eb017ea1f247edb3e9bb5859a99ec92ed27f4b99adf196976dcbdc052bbea153925617e43a1cf060f5bdfa498890edf8eb76681f82d9b4290d70a810b49d19ea325787c8c9565b57a3a3c394d12f22e0711788920cd65f665718b6955ef1ed41cc070eb718b1a5316e4896bfb088cba54da62f06a4504474008f77343015e498f0b0ac5207e53d8f827d4939ebe04a8ad573622cf04629edbf5c803070a1ee35c32b89d5fedbf019d61ce01663f9484d88d788317988902609f12bab6f62f55c479d039cc8c3d30c4dd04e12191648a1bfcb40521d76916b060c796e9399d34270c162bb3e795623b85ae211deaca9e949336629f1ac0650e3fefb1476e42df003af6f9cdaaa4ed749edca185ef908452be64be1b34b042ac3234cd7fe50f097b443b7e4abd9b422022ecae82736a03cb31ed63288aa30bdd4da9303cd994e8679ebd0ba4c8c31a58d6342cf81b90658cd79a99de8f3cb2563b9ecd8cc8b8847e19ac6a90dc4cc0b2be6857ec377a135adbe40a55a8531831c609642e60ca68bf7ddf7b71a0bb962aacd8a44f5663d80f3f4241670c079aef358b9c493474ddd4426325b7b81241898e2aa6d627fdfaf6ace60ba2dfdbc01ec75deaeb8a5c48f7a155a1beb69d138043e6a9de33cd6edc8a641ab0f43e7c094dd5121b2088ec054cd36f18e52c46696eef108ddebf1c36717b799f645f98855ae1d46a68a713c803b41ff3c1c40425194f299c4bf87db4b7887bdfa854dbc825ffdff2a019758f3abaac9ae42c791eaa0ba8792b7de6cf081d117ea80cce80e79d6153ff2c1e13b04eac18846988e836b0fefb41d7e0bf8b4e5a9933c5e1eaa791127b6a8a671b3c6f0f1d35d5f0d152483689b2beb1d19e4b19f77161c76f42ef32d2c9b7867094da135bdc813fae2ca6617af7ba42c80304dc4c592ed0c85ab3a70acec784276d93e1c539343e639a7448cb94948af11e47f8c86fc4804908fe7c8c21e37b00b0e2fff9fa980526f3e11bfab7d39e8528c25455982aab20f4a9fb5e6121e6cf9ddc7f6931a52ac226796b6203c8bf4dacbff820e1f0ae6af46d0c37ad84c38ca7cd9b7be0debd430e0d2806646405da92e0ef3a42537f3e05ad8506e0eac36afb823eed556c32202a6b23769973d3ff338095fd071b5c0cf51d736551a96c157225ff8bff539e6e8be012458f6c93d9344c6809d3d6c4d51e7e83343c4b4bbdd8483e66bacc85558cc729db8b884c2194d3aef4e1b7b351d83934cabc3b9b41c4043fa12da1d956440386e9c21494095eb0add79494dbf43db0df4e29ada09a280fc438056f603d58647742d91c2d21a8272cf5abd9f80071993d05a2af119436c7f47c327171d6b7a37be27151b5d10b60d9c905919410dec32e2083f390ddf2fae77e74d8b8769fc4d6028f00dfea9cb5e277423bfba1f5374de0e1c399a1bb097f6e213496ec39edef51286789536ac111c41eab0565a3c7e4fc29a68268ae50600784a744080c28f4ab901687362dc6103222c16594ed6e0676874f7c33400f2d74faaeb1ddb57be94ee3615cb649f0b0be2aede35740b49e8833e78239eafd16cca411c9a394e8a7ea3279dcf81c435ba58a79e34c4e27291e0b0823e6ac34778bdf070087bb62a7c2485e4199475307ab14a56963969efc09afd29a0c40af0ef83d8791252af43fcd58f2b165e265f3a5b1ddf4553b6394dec5da79a795500c1b20c92ffc541e3884dd4dd3a2a1b784140febe75204edb78cc0e7ae5a4530a85689339d8bf53e7f4d22ee42ffef70266d64543b204128679a1c84dbf8ca6693e035797c66b4bb90a343a1561bbece9732db43d6f38aebb4b4e2e556671fcaef43035e275404c137164da1771572e7d06143489a4f902c712d9a608c02637d7dcb90b8552c684f0818e8b0725b878ea386d0d106d984e9e1f832aec2541ecbe184e60fe0af011a14954eabd1173703acd6980286d5ea08cd59cabd5d7417de87b629abe78c0d43158187b47a1d8765119b5cc2842083c41a6dcd23e03b9205d873d0d437d4ca0838001f60306d012cec21b704ec9a6b579a5b6d62bd0c36ffa2c2c8600b852eb9f257aecfb4a7cf05eceaa3070cad6e93edcdf2676611c3a8421c81e3161735d41fd0cb8308924f0caae8b9dd655c4b5696b21f53b72cb1c3fe0ba22000c3a160188cbe427686d475439a11aac4f8d01d9ce1ec3ce010c1c9555f6e4e44cffa3b6e66c738cd6c4e4124ac6aefbcc5eb98550d7b88b9d8d43bd9921f0a4af7fd13bab4690cbd7fab995883959bece1b816bb37e0d2abc2ae1127544e3f4cb5fbc00822f0622ecc1cf956ff444ab71d53a8eeb8e83c658a16598b05b5ffd6586b29bb375ad8fb80663bee35f1fb3945b06eb0f9f0e0f1199499aa601095c36b495d66124a3a42d3e0cd5cd6cd96126e34e1feb3665440907ce32e7c3fec2042b03fa099922916d43a209d3d0113a916e9867374a155c338a0441526e507daf9c65fcb809559f6314ff5862a4bc5b5d2a03e8c001cfa7785f5ba52294f8e2fa6e5e20720879cfdd0d2d79b5c210bc4085a06e3f3058d590eb411843f736e55095d52b8c8e263be3e64b1a5bb8a1453e09b5887d4dcc2c4d4d93a8ce9e2f6b232c2d2feb4dc5f1d33e3051c329dedb62b13ef8048ef44e45831489d116a0b1d98848232c49302407c59a7156e198db74a2ff44d57962a6c61b8f5fffc3c634154a21543fa34805cc6a91d299618e1b32626343c28ecf30a5596d9e329d927f7885e936b45dce640e3ba7d64ddaf77639a4b6eab419acbce1ff8db5b47e3351f76da1e1f6076284f93b1030b7e4a76438991ec1342092796db34f847f55d8c8baf7733b4c6f4236b2a998469435c8c86c207dbbf047d3baad9557b539edc57b77d4d600885609336e4b5f25ad966a0ed654a5b11cbe99d3a862e75d022d5aadd9fe317f4f5a3b8473c8e888ce9159945b5eb6114a2e42fd01ee815dcf527c07ea41e20b7e6411bf89345556074f8b82cf0e7ca0edfb9c6d5f4892bcf452ef93d6b416af34a3e6dcd10aac29c3e0b7d697e04a231941d61f2e6680bf5c89141666bdb63057a6915cd05aa682798f0d3f10ecdcf7b47e65e9751865b6f6fb228ab9f1be2606e3c8840e7886199b0b7ffc7c8b0e9de918dce862eb4507cbdd5e850b62c55d8fc199310147722f1724521af0ef9ba116b5fbe2e42fa9f5888d45046ec8698aaa4a534401ee661225b5b1e74646f3c3b4d0b9b6d72edd6b1713c60bea9d60d8acf7d959c4ccbbb679247f43f430d3df7623232d8b42efe6e5ccb51268083c0c2893abccac809f095dd35fdf61a4eef61bff4d250b567ac892fe7361ed7af243d1478c94eef70522bc9a9b2472e1f4ad5d1b2a0a0b2e38d9eb3cbd36104985564d2ad029c1676dd83db6a66840e0b8ba07a0a5fbe493f273219d86b066cb133c2297dc5c71c7370ba9ee9bea31e7839bce907b4a587a7206b8a0982e12c58baacb6b8324d1190e50a261e4d5f52b996c4428c6ed0f224dd7464273027109047ab13166e506244edea24e217e91abc6d4be476a85c4447dbd67430f982bebf618304f1e6f5e31370a763a67b4b660fe17da5daf146cdf85379ef07e26e2c2fb8c4339d2b493d1064d6d3fd9f37203bb002a994f85d02844f2f692fc1b0768748fa8919732b8b29b73feed72097a4f4a4f991e30fa58dc68c4ad2c441527dd48fcb5d569da5972efea3b06aa477efcdadf547987ae96f3c34b68c96874b1064fcee224e7c25b6294ea2c4573b038f2c2bff6e5f0a68a7702f7efedea0816f670bcfecee7d8a41eda609e067f4a3fda490c537f41b3ff52f5b75c56e6e7753483d362978f65ae09f9f8fc932695dba86f14cde359bc7402a404fb4ea0b0dcf95878eeeedee7ed8ee5117bcc766c36a8910d40cdd3ad3db66a5214a37987e2e6602c91d22638fa2fbc1e6fdb6364d8f48672d4eb2dde80a1e9a891fbd97d5cf7b3393241f088b4c7f01b32a2d42c9ce5430901c3fcb90f45f03f792e08fbdb4e0f8a5bee10f18565ad0c3226ba131c3495174ecee7f404bca3a2aba01710c4b2cd3075c610305f37d6a741b97684a82260a36fd8c3a7df11ed65b16c74503c3431c0980f6e424791c0c794066629b03c02febd8c82159dc7edc605ea2baa4752105c71f4543d9d0f53dff486d275f566af5eef79a7c54dbe58020dd78765b761303e548de3500be7185a9a6e46c851059019f377a3e2f9ca2a247ebe915f67a87b765b1a7a9435c3827aa7c1d51175f7d290ea8cf00cd63a3f3882075e795108f560eafff3202d303ba9ec4f909213f17f86e296c65395e99e8a6c17414f001ecc5ea0b59e62167eabc98cf8e701b2aea2f59b5667e708e71a5c4bd8a7271f9c5774f0c60f63ce6ef3b75a8374881a277916bc82207abf6721c42fdfb3091c5a9008d21851240564a7de38a15e44514ad12ee40a16664251b10ec261f60046f9884c4d29753fb26656149c6ff861c62fd80460906b5436fbd8930115830089d8bd330e2baebcfb8f1f23ce318af0a531bdbcf9e33274f61e99b92157c9251f1f9791262c7bac24a3fd0802a68cec20f4cd814b25318a84947fd0cd9607f06c1fe5ccc4540d94bb2aab603316802a3a32ccb1d0cf460ea428048135f1e342cd90c9adf456d8f24835a8ce50ea08a8a7e7a51bb4b401a7a278623533357e5fadebb4db52a87de9cb68958af0400e64a08131aa83c8297c1b5ada9cc369df236f9d1003d4605a898fe9d97397d4bb429da9e3497cf2ec2c1350b985fa5f79f2d60edf6f99831deb2f0c4f772d5e8dd14ea674753b9b4d25948fe0c1bee623071a7b828c1ebcc8c046a9691e38217515005634473cb9f15ef9116b0dc23be72eb1ac2552ce14885ea92cee56980e82634ff6f04d950b77d7cddcbf804f3a7bc743df35dff66d7617ed99b1dbda128d46a9575894b358c7c1ea77c51175913a2237c518d7fdf18f6e6a96951dfce4884a05ca74cf39e40c62fc2f70d874ba1b66af23db7dc8b8e658eca336d322205923f8afad054433ad6f13c0872095997e0e0152abdad0558c3180b8d90d18d5baafa5108c7bd44f8392ecef613fc00febae12fb37430446c99f74b5ed7d5a51504447ad95721b3980178bf83a65b27009de9cc3ecf9383538607aa2e28d05f189bba4b2951a85a7159188cad60a655d39c355e378527be96daf6532074996b4a375124ca4e6e0015f4f9523815842b13fbebc0e2db039e793eac04b4fdf6e4d0bae7e385f6cb7d86dd894747def29d4a763188c7138f2dfe90e26d79b7f151f40927e6c6d55eefb7eade1d40829157c8eca178f305a69ee9df23d3f0c168e6851e56b8605c6f5840ab85c42b6549323f3ba54fbe4a3e68f8b19e6737e1cd83d32ba454e2f1755db3c526c162921b17af3604594c15f3140bd7d010e9c6b3dbbc33816c5272cca9bc69b476e2f154bd06bb89e95f01901fdf65ef7b2696e40a7c8bcf7e15399c43673a8ab10bec64a12ba60f01db06679cc5b49c2f18691336893541bcae738b3927599cbe899c2a77a433d966f9e0cc8d6fbe77d1fb7c2ca37c0b974a92710d63fe2499576e5d5861267723dc65273102a2caf30586b6223fb1dccf6d6bf00d76f76fd1612b889d0b10d5faf20328a6875e69e5d0104610d78fbd58f6af5ce6c8d6ae327d739155e20d4892a84ed0301a337ca5ac67b2e0a55e28bbbc52aaaf9aac1ce899f360927bde6c09671eabb06713daf9f602f275c47ad375885ebb0c2cbb951c9f52f44bbd4122e56beb7aa9d9582df5299c2b8cdae8bab2aa773c1a2c84f42f535d355e45b825e3599d3aabc76992caf6e4f2bc5146461c13a559eed48019e2b7c9cfd5717e1196deef078498c6ba21ebb296cf716d22a968d04d30ba2f7933a73d912a5f829f68f415b36f44748c4d3f5eea411a1eaf6ce5d487c57fd8c714f9d55b3d4996fc99b0348a581097807ac94df8a09f1470be029edaf1b22fc498151598a4ea8ea933196a33f638b5f9fdccd8af3fc020983bdff9d6c6ad7d50eb89d0f73e7b1b46350c5edf59cbfeef90cbe47a9fe6e626a376f481c813eeaa15141a9faaca5cd485bd62093043a821dfa8d1c0f317c3a1742bfd1058e2daaad2c03f0c6c9d090830f1efbda546400c6ba70ada99a68a2605cfcaa268932eaadf10726a19ac237b1f8fcb447bdff121881f56749d3fc90a3d6ad51222ec6432a117e78ba0bbefd949fa8d3a44ecd9c07e299b4320d383813f548a9b6b78e8911021a2b05a1b7c76750c8e93094932ebcd807c124851af66e5bbe589b575d4745f6e73a3724cb0b76499ecac07778ac0f8aff6eb1a3547fa0c28e9a406ec6f48b5660ec9bc491284d53c92e433cf273490f8c91b019d83ca5025d040585b4a873d31f028c308ad7ea915ee07e335c44996f91a2bde6062a0726416c580b7c7e003954dde0987ca118c4fdf1c1dc44168bdb3ae3629ebc669b7321b67df76e0ba658f6b94306e26c04a7716ee412d2fc2059d70144f5a1e097734557dc1afb1e4338a0070a7333281217a63c40661db4503b55b941767d44150c58567b6fceb2fec73647456b294fb1581174e9fc91fa0ef4afa98e2e8174cf463e1b655553ee79511a64b8ed3e7f92da71efe1f1e2dbe66bf1837f6c7dc8416401127a22e64e494adf580e45b52e61f21130592dea489a587fcf9c37ed69df5fb932ba7f2c71bc63f8a66db2ec6548eae355a138eaf366ead4cdfce8e02f6ca647d972b5d7925c2912989253d1384ea56ba1176024c957085b0935d8817495cf29f6010bf4fc8f24539128174108c3b1f1cd30ec6f8eedef25d83dc70054287df5b9cbdf285be4f519d69bb4fd6d182a70385b88b8e5859d7bff08410f75eb620730aa6fb4c7375bed3c66ec2f831643c206939ba3c33ec761b8daccd90443e0638a4d8672b101aecd0ab0cf8dfcb765b25714660af53f95541b57ab62bb549f727004fee4a767d9bd38c4b14f5e01bb91d9c51311d144830cae0f68bf3d1275ba86d97a5385edca3f03c4dd40edede673f055082fb69c7caf3f5cab3496c8951b2221c1aacb9ada5a8e433e628ca7ed2cfd8b71a852ac1fdabce022ab2a61d055097946951c2249fb543617064163d9b376fa03aad161fb467897e4a923f6dd2467a2800895c76c114d5a175958710facca80a646e9c6c8b2d6e8b20082f1649befb93c7699df1675d42959276f16ef0c683acdccd955c230f22c41db07afd406e1c67aea799afc143682f6e7087876bc59b4535f4d7ab8a8c41d5904f1dfda6337d503029589098f05dd232134be6848aecdce9375965d0f81bd957c15435441d762c136afc0a2e505e168cece9aad637cad7862fe3e10a6b2c06c149b617bd3e705dab2a0aa52e9bd5574e2eca950260880f213c1be034189ddd352651037bbaf1800f7f344c7ac66618f17efc82984ccfc706d6bf80525bcb127c41b0689c0a3e01be52b12111e42f7f1714c56e142355302a8d2f08d2029d9dbebcb9524efacc58f04b526aa471dffbf1ceaa06a1a5dc307f1b3bef88aa31f1a8572d057bdfe5e6c4c44a62515c7f7b15c1bacd267ce16f134b933149dcd9c7ac12f339fa4fb9c2ac850a89ef6e8b8893b2cbceb9009562a570be62f83e78e096639694d781bfd75572236fcfb5ac823800d91956e9a209374f1e01a5dea71427539995ea159a315bb99e52c017fe01b3618f86d0ad2f1913c8edd8efed81562eca12ae65b0794d5e6092cc92de71869bfcb7830f25d1d81591ece5ffb563dedb3fae559650b918cabf9d0b0155e751ddfb87a56d2f92914ef24f42ec041e797e954f8d4759d0d80b51c3fb767b990e6001e36c2453fbaa2799d06933351cc275f697476abdd69579df2da0f8cb0deb762a4da4cbbb605fa11d3a6f7439bec6f1b306903674a2919c5183fd7941e9cb785c0b8c9a23f7a46732699b8ec928afb6500769a9acfd6f2e0a9f139caa4bf5660ae27c1204ad62c5c731a6612baeeff50e6b3626c5a8905ac45a82293b42bc17af1d8eb58b6115f415428e5c4b454333f08494e4a4779541a54c592a4784bafb6b0da9bceefa1c77e18cb68d1350ea801d8cea60347770695a5bc6720c75eff3eb9828bae740324618a895722a104d2106cf41cb9aca8eaa60000403500becd6d6c818e46692428e6bf877690206830647b53e1c46518abc96505a511038e000db5005fa46b706896db13acc3b4d24d5c1af689ab9bcc3c18948a05b43da019349ce0c21fe2d95e0ba4301b563a993795f05c06b7e5eadf37f4ca142cb03372d0a247a59c142d0cda8dfbc295817f705e28a867c6f0fc19a4ebb03849c214dd3bc8be7da3a034660592810a36212f0f344089f68900be4c37ad89b33c0f71ee1ef5729d0790bfe8c50c27c7892e0822de6921c808da0f225f0820d754d376bd207d2da5c3d8bbe29a5eecd9054a10c0faf9e136c7ae7adc772bfdbd939bce7055070b23f52f4073553521bda5544834d64979435e7254111a780df782209103d993a56a359399b751bf875774a5f09bc30d52721652efed15aa9c4bcba576a28e6cbaa57bc3405f501f78f3cd20e7e76b30cd9aa2ec8e8f154cf5c81cd67a3a332f27b4e8f9b32443b8083090fb33a15eb88e0005ac548866d64ac74075d0d4f58340e1b3079cfe675661d1b660bfe7ccd0b5faea8d6b4c9f74fbb22195e275e0d8a0d308a50855f0ef28408c8e8167a8f0a00a40c78e1e4876b9f514340871ac0a0cb3481fcbed87c5fee433f3dc22baf09641aa5fc1b4f3293eb42f73dfc030af19108622beb6b3d62abdacadcf3a65a5dc68d42aadecb7de1ae3ffc3ed1fdc4001a7e1b7f40f514010ecef67ce91cdd89c66428edf8c2a9171c49bdef348c7f6faafa8724a3a49dd83d3f476d7c1b26502a5f1fb373c93b02bf60412a8915b5e2238de80d232c20929ec818769f7db9a1095c7002d292f73f61635ddbce2c66ef8536c692f610961527eeb28021797676694cb133f2d1d9da1e6d29d8c2b72ff5c18b0dea5a307ff9acf47477c32ca4b9502459ef4739f6f46f65c094ac48edbebf9f549fab2af085721a58911b8cd4da4ccbaed693c111b924bdd226350f49e0044d86cef0d63015071062887a11bfbd568b5a5588937a1a560b5a10445dc03db1ca04bacabdfc2e99bad9d3fc6b9951bbb10950962a243e5324ce82bc1dd4ae7b95ff0a11da09b8e57903ba482fcf94fc54dde653cd70a04d8ee701997c04a11182ee66f8210c874f15c78579061955146d2eb4926ed8384e47e8adefc24177a9d2e17a0b21676f7d55b300951f9deae85c5afbec400f5fa489acfe0e0f76551d146f32d94263bfd97b663207f587c5cb0a8b5ff2133e51045507659d10711c6add450f1aac91f80d454dfd638f0e97831553b117a30bcda8e69ac12f5c7b8e60698ca73155c55c1c9f998ca67c0e787dfc3f11aa99e5ea8cb34af2df2aced4c527bc2fe9f1051c814d88cd906ed14da937af35906e9c93c3dfab4891457652068474830e75d7132eb7e90dbc1a0466137f04e430a67b72700945abeb102547067eacaa77ff28e65f02979bc13717bbda3c296b5b0f39ded2cf7c30c229e99ea426ea71c4267db0b264fbbd35b7854a3ce9ff5fb647d2ef9fa40e0338feb83100409a3534960dbdbc00e8f3d599a28177ea9d7387b21702aa66991694f03a7cb5a3dfec1d191ade9c0e947fc57ad118e73b58859961a661b9ed3481052493824d7cbb5bb506877dc8e88bcd4a73683bdcf411ce638c8da21fa451219ffdbfbd72e9ea2f9750b34e2c8b05c373511eefb10e83abdea7ec3cfc5e8f4f034a8160cd763f2ff39057898fe0dbd99faa914457fc2b3cd3e9b2094f9d908f21f513515141de69fc2616a80d29f29de647c9b08786e92d4fbeb9ff3b5678d715fb034f00f42413ef2ba8a0c011e02e98205ff81731957804626d945194cfce5a6588e588c022f8dee153b9ed906c44a70e605efa9f5cf13009d8256086c632dd40f181704ceb9a751b03331baab8880c69c0f7ff21f5cb256eff3b3cb1026ba1ba17457efb766c430aa831b29c707399106eb61eea4a82a8c196685eaed6cc812c520b6ef5646638ec0454928c37174161b1d6aacc1e98a307ce6d4dd64a0ca1e7e025507a498aeb60228749fce016c872b4eec2c0d2123f2505b330ccd83d107f8020925eb344c99835ea87b8f6f6145f8d2bd3b7e830daadccda052429d851d18efd26a5205da05dc59ca7ba25dd49a588dfb7bd5bddc094ef52816a08755f9848bb5ba3566756195b72c6fd299dda82ef952c8658a34cf4c67a7a85f7f8a242e1650f5a3357cc7545230b404336b004f96abfc349a38f06e860fe39e36de822db3fdc7d5c4b5a34177c017ca4f1f3b97d27352bdf79cf43fbeb032fc6886185a80e93011c8b5e150b182814e989ef5fdcafc8ddb8262e14a996af5fca01583a218ee5f6469cbf171e1fde9793199b5f788da96c0fd978a50ac170c17efb60f46ec4ac6ef1c2f145bdd65dea1ea3f5096b4f4c34ae24130a70beb0267172aeb6496a3a82297d3e19c16cf6aca226242e52dd3d350b274e00bedf0b5979f373cfa47a4ba2bb2761cbb67bfceeda0b862d1d13700376408217628864da754cc5e26f0f77cbc793a88bca811f9c3a3e06652ec848c5b7913c35761dad47f15b1493a904c6f1045a0583c4b4ceb60ae32fcdefd286b5d9b9f4b45bb7a27943b0dcc16f6bdfb2bcd19113180c2663af53ece68e122be979907f5473aa1c1f4d29612275fd23b41c3ff998bce2c9908be8ca8994c32438fd58738aad9e0a13657b70b9cd9cee2f98d0f6678b61c5f586227f0115ff6fa343e66a56074e6e05910df3e17f705cdb30588e4004fc2bbb55c5d83f01f92da2de79097b276364fd26c261c678404cff98ad8156200a2461fad4737ee668439f21f206ae64516fccdf15eb0959e8a8050df08b265370d1832d77025a14bca4c7d0641a8d3f3e3a741d58b4f2453c69a1c583adcdcde2eca326c0a56817ab4644594f9f95432c05d925b230ca63eff8ea698a2128392a0b11256689f65e1e9c3ed8ce734cce73be833c14233f75172b60d71c74482d06c267cd4fea8dfeed4036dcdc3f8234f8f286fd6fdd37c0d016701391e4a169b9af51ab5f010adee0816b523436a185d7942b4348732d83936a5df8bae806d0b3eddeec84486103448c2a9dcaa0e71aae5ab8acc0602b0fbcd1276e98dc843f7f98ef2c1b2d5e7097c870f02c3e6fb532ead28068031fb9143d87dbcbf72a096070122e5f4365a5c328bb8bb43d9ffff2b51b3ddb6ca0d2582fc6aa7814ded6f35a42d2c0777b15ab631f5ea44e9fa1d8a7ffd98cc394ae27423e87a92db3a012dd477d52290be0e0f917e56cd044b832cecf27b65f13961c06160be759f6ee06bf234a4a13ab18ba1fef387da3a84e6e598d6258e95025e178c4a9628db3274b87849809edc02aa8a24a2b654f1c7982ff3b134bc0c6d53e611f0c57ce27044c236a4872944d3d0966100e7fee61f770f39511f9a9b7f4c2035fe9e54071669a34cab00c7c1803b91f1f2f4c50a10b36fcc7bd095ebadf6a1267a89419d8f43b17d67168d7aa439d102d82e194a21674693c4052cfce724712d6c2469fc8c47deb0a60328990aa5967c9946528e87e55bd52b42a1d5094f27c42f49644cf38c513891de78f2f77be5301ca60f002ae64004bbe32ec537574fae26325c5885fc6517bd38d4e7a770424e15fac4fcb14d091b12c1ba833c3e962ebae02b4bd418cc5f0267edcc9e99ad3407684d8c458e678ea6e4a5a1205f800c4bdc381da1ced08f5065298c6f3f075ff04d317e9ccf44b06485aef91778a7991b2e2679d723a1f8e83a6711005a13ea21b463104397cfc1e16e23f2ea52a5de340d3d61a03b78a141dff0f9a855f830398795925e37bebcc30d47c5cb5ea9c48915f1566343d78a0422c4e36d3881dd4ee4905e671bb85f317b425d8f308260700cd4ead8c4e8e2aa790ecf04e892a64c730429dfff6c8c39b0bd5d1ec93de11622b764a97da3814dc2cea26611434be2a5f4406f23191ffcea0e463128950d45cbc27a7b090457d67c2b4abfcbc33cf6e4301df5ad461f9ed95133ff6f04e84e8860e764fe07a4a2d21b2d74abdf57fd6cd23ae4383409a561c97486b2a794810cf0227fa5903b82c55c6a28149d4bf4c328ee5625511c59d3367ccd14a46a6405055422c50488b01328d0310c591f7034d1d0043c5c40e1c2de75c6cdb2809b5680db803dae04d3ebbc91dd652bdce76e109fd73919d0f2f3449c78573290f79502f7cb9e2253f1753657ce5963749c3205d9449e17141f1ceefb2f02df5c391d2be539631c01cfcc1b66de652c2ccf1841caca31c46c364f3393a5859a7e55708477c10c44ab62b97ccdd20caea23e1084ef5b98d9c99c21ae1ce93279aad2db7d64fdc88b46fe143a55c08476eab2da6f1a5c682b7b3fa38bdf99c577ed92a73d2df6dc4b5f29dd8877016bda623444ed91e30304bd8bd34e5b2121b26da5d3545397185b75a19e225555914985516536aa631d0e8f6b6d3204ea7b90f179b7b6d793766f4b47273d9ad00d0614f41cacb58bc24368d8e00a0e9084f0f83369ac5b97d31304738ff80a27bd91680cf96195fbe028ea002f19981cdf560536ae3ee95109a80c28b7a7863081636cd0b5dba14852e5570e8bfb516668b432c63ac34c1cde50a8f6fe00cd1a7d790b83e8c17f52939872f9c249f19f2f4e51489a9bb4b3611bf8b16256bcd2727b08d4e8c5afea15b6de949f5136294c4fa50f5dae6a6e2e2da30fb8b92ffbfc72dec4aedae03570497c7e69bedb5b0d1add91377f36f0055c93008c03d7c1624bf68d7ef7d7650d661ab11a9c44ac11852b64b820ee858b55cb29a7b0b9cab8d7cad40374c3469c0ef28aba94206978ffd1ad00c8720c705ab26da711b3fcbc76bd2e629646a352b51c6a7bc9371841baaff870f0728475684e71ae60d3308bcfe340ff8540e90bba83988580221ea0c20c2cea25b69879664cf2963789ce159b8cc79c42e9a20de42c17e546001cf03c0ea6d9ee9655bdf83d67aa1a8c1038115d85bbd7fea25f12d729223f2dccdff21576a9ea79b37cf5e06107bff62a6f9ba25e679c5cf630aa0f4497f1513108fca8a542e216d2298a4f72a007971287968276a81a49a04719ef050bc9e9ed6a61fe00a834ca5a4c3aed5d69ff3b97654d1858eb504a14b1188a943ffa24be31f125aec4ea9101bf14c5ab00fcd86753dbe11a5d8c4f8f631cb82a75e3324a5a088371c05f6640a962545290c299176a5f4f0284bf92b4843de66339078a47de822e94121b9bcc3482a3e5c863ef6492931b5c838407199417492ab92f97e63042617c9edfe46ceb9afd3de9b5359f0fc5d762a8e6e1e91acda965ca8f9e2f19f6c20c6f635b6f77435432848351b21e1f93bf859d395efc857987c3a2bec19abed6042ed899fb0f1c01e75a47b89e9ede322abb44dc7085e5c4575bd70b4b4e5f00274278bf85014e327380faecea2e8ab50ab1a1f3e5fd6bd387e3804a7356b378183c87a6992de95f383375bc2f8fca58d9b34b576f8670dc2ca882972cb1dec6e1e6226cc9ccd57b036284b22398136de0ed7ed48efc4ce93e7592d0cfba1fabe3a7fb9f7eb3fddf695f3e90d435214a37c62b6ddd2d3e06c21fc91fda64ddad301758fdbdeded861e992ad2d2c30926d8e1d34556bc2f4e99abca40793d4e604e93d8c0ee0ea89e12a8b6c86378d1a0e2b26b00587003efcc16af95f54f242fb3f3d01a30ff34b28157909f35cc1916c0fa1c54dcdfbc9b9f94215b2a4f22251cf14a52e141e26fe8120f174146bad6174d44c1c5e3b89d34c54d1481c845490854d49944eb8bb8504dbb97b5ec245f9b9c6ca6b10e86707cb3b8ca3eef803864d6d09bfcdd4cfc4b65ee6ce9b509ed98e3a44cce88f18176d9258e6fe168a74c7ff9ab10dc28bf69e701f0acd90bc4b018e460e24b0721114847a353cbb2fdeb60efd7442a4d1ba4e73e3f45a84b1fe446f1f4b6f3f7200fa7a1cd468b7b2d5e34415108881ecbd2c8d28d25ef010ab30ebd95125aa83342102538d186a71993d5858f19835c40e90bfd9c4c16456bd0292cc5603e152a73f74b5ae60a9789f3ab596f78ec947d1223c3af8d054ca55f2ad5a0eb62c6b18f3c69993521ad745a91c80583511835e821d01b5f236b151ed92151ebe843e37b2395fbaf6cb0d4d23ec286742a99d1e28f99ce297ad037899757f126fa82eedcf916f2df66361247f8e6bf636619067fe54a8d92cb6261351fb753e578dcf6a6bd29b0dc4ab703e93fb9f6b765647d45af5010326ee7fe8933af18cd9c3b10abda5d0297a3f684cc43cb5dcc71367a0c101464cdcd4ee3cea5171d4a4fad3c8838affc477e5d43a071859b9eca588585ca8084b6ff3a1bfbb5d9cfaea3857995ea673662a11ad4e2ec4c42eca988bf4868aaf737a08758242224cb595f81977a00b59ee072b4835632768cc1269688c342263477a58eaa0ec953df6d70b7731c87b1c082337c47ad88eb0c9a70e24ea909b860e137cb5c2a29e1625e8fcc0e2f1a6a8bb49edf30518e54cc355d1810792a21595ef19881d9d5a54fa741b5772b4102221a3e6623a20135f52cc56133cf46e159fd4524e9c9685e4947a7933a6129deb813d59d9c5d187fefcb7f8b478fc352c70d3f5c0ab491dd72e7c6339f7250d055f538aa71ee130d2211c08ca7b96be9e02c9aa555e69b4a095d947547d8be68f5857b9256abda4454be78507df14e69cdda124e022477ed6d87b6baffad3d7d81b3f20f16377b902749701bf4cc2a028ed71ee533b9d03303ec1914e17109b2bc5b419135436f14f8cdb5a0334a4e930d444c6246730d6b5d5092b4b9ae4c6646aa445a9c2df7368c966ad3ea7bfb3a021acbd617eedfbec2e8935100477eeeee81f1ce9bad5ed6811529638668b4cc45d3fb850ce57bb7e5c51012f36805c25ebaed116e4381ba7ca720ca0f54b85b576f36d389c906dac1ebef5f6cbef6b7e48970d0f12513f7f376ff6b2b7c6c7dc16020e4dd67cf56d9cc5a07377ba5fdb98303016a4d962e8127516a2afe452ef61d62c02ffa33cc7be3a91c2571f16f92a39a10db82df9da619489e2ed46c48e2709cd23a7558e807ea497eda8a0c9113a60f3a035ca220ce6509232a0616d901c1af2ca495e0283c75b797ee920afb8b824de98e5bec0f610891a43f7d3188f5fdb6f529e189441d4206f45b15e85d03a26cf4891f57df8da4dbbaaa83cd112c0ac43fbbd8988de81bd09e7f703e735b9b79b4dec1628b04c97d37667057cb462ab0960a1d634cffdb917a1c9caf4a4a7c6aa89c3251c83c2d2ae45ecf9035e1c3fe4c5efab06c0fa703c5ea4fbdb4440d519a2e262ef429958300cf119eb8aeb841f4304b973ace6c0289e5d15a0e08591b1a10b778deca6f9df09c70143910f7eeb0dda3c9ff1a17c3732e52d128bdf8a34a81e3b5c9220b34413ed0f55230ebf01ccc386343e2549c85ab626daac51dc87caad932a843b9a858e05793842b9a66e35772ce5e3eb606c175cfe6b63623d23d12afa1d76d7c633db82c09aa8368c852f7dfa05e06231b8dd4bf1495d16e7cf1135d3a34749b213b56d1e7d95fefc597aea5c20dbc8d83d76eafc8632e342192ea384992b9f7a6ff4b98eb6b495b78dfc97c61f76558e771760beefed6c8f94bb9874857fd4eb7d9547b5548e75061cabbf974a9d120ef151e3d789e5b59370dda0003fe48b9e37074c28cf89ef69a89dd5e4c5adb5f7f18df3e10e171515037037570d57ab33fe605c505d217d2a29c030334b6a639e707199fe890b30fced7c13112388c0b53c65d0c48b465bf313a1335b8b892eb40b8fe4a9545407ead1e3df2326af98a031516c6a66d8f11d39b7d8a65bea6e0e837b999f1d5930e7905048378f3030a77ac541b39043d157d9ae4ffe62f193ad2ef7f55dae8295bbe4c327418195f3e5fff09a1a3509c4cb78f5e2702276d8a43feb33ac6d2a883278898774d5f7ad51cbfedde6c25edeaeb66c1f44b1d3d2fc05896d397a3b5c0b35dcfdc8a16f0a7973d0ea82decd2f1ffe76e4b5bd5ed69b944917d70f09f4c8f9532b41f1cbd9979285dc4990de9278e1ee810a68bdea7e93a375c0120bda1d5bb31128cc51690b5e71c75c7c2bbcd54bedd3c02ae2a8d59fa925a87facd5d38e420add305166dc3e491cebf68ecbdafe2034a79d9cc2f2e5b5db1e6a03dd1c6334fb8fb1ac8ceceed9836f36c86fbe0716052da14147b974afb7fde95cbffda1965111e0894899616434cec2c9370dd351adc319692c881787eb864750cea9181b1da03346605c7679047d0eca93a80c3e407d59f21f36d0f038e0f113ff1290587c7f35642c80fa6d6ead08ebe6b17badf9f047f866b1aad7d536cc2225ffeecd6546a1e98175a33a8eccc44f6798d41505fc6c1f2431109282844a978c5e971424faa10026047f25e46b077e59dc493f673a73e9e3b0e01557947c37bc9f8dc3ff581ac7b1fccb1a174f0803bfe7223ee6f5078fcc6ed5a27107cb183453c6c08c3d4144f8f31da75b1b602f3865fe0359fad10187e0d78d7f90cba164ffbeb0287c4f2fe719d48cc8ab391419f2a8cda252e86340dc6e54fcd0f41c8b76f621c2e55ee929c36ae479b3abaab8c1433f73dac4e01b3e2c99a9b67f54165a3750b1faa10afd323876beb24c27006b3aea1ee633eca81e7ddabda3a612c6427b839ede1dd3fc575e1e519390b1f9455c5e6916287e08fe6df73b3723cb49d922d13e8e3e1ac9d355dc55058035840a38ddb48b2654a434f3993c6fc83efa85625581c2d8c6b0c4843271bf9b84b5e69fcbedce23ed7ab29ae7e51a5c48f452507f98d68c5e12bd741fa1e3864495eadd0ad97d90aecc4840f142fdf10739ff14aa9a9b50edc8cdb9e2285c6839c8dccb723cfc6f58c894b961db6051121cccc5a224f0b4c3aa6814c23cd53ebb00de884324a62908a3c370734f8af05b795e000c616a8117181821d7e367856adcf6dedf99c936d6cade1b0eabff59eea9826a00c5b0eff6398a435178dd22fe6c43fcc95d7398ca9a3f6d9af11e9ab106950be47276e2b7b362ca95f35f5708582a0223a15314c7f278a83fef660921087bcd2b7ba0eff016321fe14600c74b3a70de999c1fffde080655de8a25cc49850f4b4030f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
