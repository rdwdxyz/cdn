<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c91aa57f8a92f992a61db819de3b9fd67c858e7ffb9909a1ca43237f1ad4d91965bd70dae02edf0499bcca981f123116f236a8c6b95791f580ba116e9f509dd69000c0e022306e77baaf269da7b16a6a9e3e9c5d5f0f51f1774f49bd1ca2125e19b4945a9e91e8b5ebcfbd385bdf781456e5825bca774deb71c4678fec9a9878495c45b2e410b4baec269c4930403bf56b32a5ed066ebe11edc7fe1291c7612cb4b11742ab3a57cea7cc4422f1ffcd93548006363b813b8e66f8fd6771a69b44c8536ba7d3ba3513b5a12278fb9acafa85f3b4a0028df7e9e67476b71c965c88bd829fb2ae46e9a861df40ac36aef33db735cd5accd40267efddda4b8404aa62b3260e46d3d69862e24021e22dbc58875908c7be024ac328b0d57a7d4dd42afec3b23de6e28d91bef723dc8844c1f5680485db5e42ccb546052bf5e19699241c1bcba568fc5e594398159e9a89851c7d8fa5410ecabc7a63a077496299e660f57719d3a9c5eda456ba88adaacc01215d3f0052d180f1ef75b35f12854a4bb338aca3df8e588e84207f9e9745d765aa8122731987c2f14d0916ba45acdb5f33afc38d98c8aa4a4fec65e5e2ee5517f1ed9ad58b8c5fe77c89aafbbbab32bdc5a67e54bc3f7b21f3450aa85cc793225ab86ca27f6c264cda307721c90ef5f79ef14fb5b1db32b204270743851cfd75121dafa79b41a4fae74270c747bced3b72594c1c4d6cbc27ba8266765ab42a135389b88c81be98b86bdef3fd88194ec87663a1f87d0a653101548dd8b7f28fa5b14ae2e8a4831afa853e264a993a6c39e153d3d148d64eb3582bca225af2ee4133a8d8823ab51418b4c3d83755cffabd868e440686f6e13934836576309942f445ae4449dbfa62c98448236c3e9e22deee446a40d15831228cf13aa6df5ba1e288b8f4072725911ef84e64e0148af61c83e272bda005702eedc3ec433a907487999c3ec8da7a058c8a3bcfe93ad12873da2b9f73b8aad46e76bad04d0b8ab72d501358f6d5d3b2d9d4d8f3d57d4c7206de0c2509d8b67d48d79ecf55a1c83e7f495a87299296e44d7d2e2d01ae85d31c5f2660c32e1eaede3399d1f76d051dc588eb42d982f47ba9170b86b63ef9bcbe35e6e42607ddbcef6885fa18363e432c96f3757755fe6e462c343b894f3e1df412f5496584d7b06c9a361b93442cbf0a75247fe1b971ed3ac474946618a5d8239b2e452a71cc55652fe194c2f547f3339e5b69eb1cb6cb778a79045de17740c75057ce178cee0a247bc66714a30733060c5d6159b857107784b1166ae4acf3d44fbf18793e171c96499070ab5d900095c592f2e356350091263101e9e7b1544ba60d4eb22b20e764038b784ca4954c0290d03985c1409ec6d99dce14ab7484632cb2057364032db7fdd09be4d546625413dc9c1881d2151544fb1ef20271ebf339dce72fc23c64e6c0f36f6eddfc5b01d9db5b46025cac5c5fb0190db3230b144d38034fae31859d0c49ebb82413ff52749a1865044a1d1cdf217b777ab5fe0f379a07b658f7eea4269fde0291a93810cdc34f8b5888fa65b383441dadc124b83a7b5265f73f6de4e512909e118a6530aa48c25e9a447c2b52f48d949e28b09a5b2b3dc0b457e92bb8951ca70937fe20839904e4edd620968ed41aae9a8451e83b89707f4a23d0f1a3e665a8b952ac8f6060baef29a6360a602bf90ab2b5299c92789787f0ddd2af229bc185ca8d78e2a74858ab505c56459796fae58ae47a04f80d3e246b7426d12f3515f6e3c5ef800d381ee7d1898296b6bcb708b552cbfb89a64fa31b997209be2b41239be754ae96d3a655a846b4f4c4b272a73122ca4f202fddf5851ff2564dc5d8baa5214bd0bb295c285c77c2362ee301fcf3b62b6905168c4a3144521f5865caa1ebaeb43f89669123dacf9dc56b28b6093b3ae7b0a5af0a64a6480c362e955f7a3de135445bf8a120baa7f4d932ae30845ed27bbf4abc152c33013c418548cac5d6a78af8269a3aa56981105d4ba8a5dfc97feab2b624f0995f9e6a7e664354caf828155e7c48183fceacb0a98b420562bb7c32e325993138a65d27aa98288eb6fcb7dc0c0d015191dfb7df0dff7889aa1e863da3bcde9d8a2f7c2d6cd9e37827a288451409d397c819cfcb33be6c9ebf093da0deb749de6ccd10c15f1adcd5057538b2cd71f1c2db7ab661c367db99ac6debb127fb085dc551c8483abe8ffcf0cdc3e1a27ba9cff7ac5c7eeb5ab8603c40cac3d31fda6b5acbd278371f5dbeb90f58a5f7d757d93ac9aca2dd9e0c4f43d0c39de321584884221508c7674d1bc6b832dc7d1dda2bc366f6f95b1a2ed42e37c1a62536bbf8749c45a41dd0711af028439b402aab7aa04c18b992f7958a135cd5c0ae39b5eec91d5fc6146b29298a605f60d4eba1e140a43adc79b342dc3094722de9403a9ba9f56ce61e5e50e4a001c174041e341eabfe39a9d9ee220bb53b02cac8d3d93c998f00a9bd97655a2b7fd9e764a2416c20f56be57b8c195c2b611753beeed6fb7638d7c24e70f76aad64397033fac4b926da1fb1152c88b3afa791dbcc635c1506fd3a33aa004ca86f3a6ba7183b6246b2f73ab7b48c80cd857a0e7cbb85759d019fce46359fe37a179681960ff38b541dff0e8115ad32805f3902c3b8389311fe63673d8ae55a5c35202e1652c1ac931ae3bdfcfaa674123d7b36316a928d543f382c4a2b7673ebd759d080fb59ee71399d8b03150e8a40d83d50317522a547a0deb97fbda8753632bf2d3b85c1d90cdd487af696b055ff1f98211a0d25a23cbcce9def8bbfb20a2960d66139f5cccd8c720a6e14ed4679cef12a7c01958de93be74bc8d7f63d8555fc8d23f562a88c535b65b544ac49c1b16cfc285b367bd6cac4a4e5d534ad30465e74df6ee58fe4b3f436e72924f81ee301774a4ed5642cd3c643e957024c22056d848849e1f3ea3b87318b468a2f832ec5b48647161b0e1a8b263db3854f9481ca0504a45a9363b694f1f243080af8bbfa18bfa3b1e4793bd47e441f66b96d03e4d3959345e46be9f9d5a60b28da3a13f4af0b834e7408ded2ad3345ac574272e420bccfa4e378cdd8cf7fbfb6f10876f70f6c894b598381fcd06f47930d1a4288177f762c54c412a2c8a2a91bf4270c623c9eec5fb998243c479d4d2edc05cb76b5b13e464ee6bfc1bf141182c7e5847503f3cb5908ba1439039620cb42122607a1081061659aecdaa24b5111400b782376595c28f2adb73054c870efce77fd66eb7417734ff0890662def5a65e9be53219224b85a1151b2a24c3273a01fdf4d9d67b77b1f952ba66fd370b232d161e361fa0179bf27b84440b132d0f701222ba605c97d3886bef9544aedbc690588bca876fd14737bad0e21322597b929b3bb4bbb8f71c4d05f9e6731c2869073857b931afa8f42cf666236c449f91483bb48adb2fa32e112699df4d0809ecfb8f629bd2aa1e922e73525ad12d3b55c639578396484c3d8f5dbcafaed6be062329a31f057afd976b0cf2545136bcdf1eb7dc052472441296e3faf0a5bcd70fbe468f5bfefd3be17b1a595f00a7581ebe43523dcaebbb2e6c9debd67d6c70f2286c389acfcaf96daa2489511d440fed8a59b14053fdbf576c9289502fd6b0ac09d5d690c69926e2701ce0059f4d4f4e5495f6058877a34186e52bf1f3f2e760209f495c0c228e93b0b7225b05b815930d31f3f30ede79444bec9e732fe3de3804d4b599aea0dfe4de89aa5774c86b2e30612f842c15194a4808c5add6de3ff8cd67f048a4f9b4041048c0d920ee05fd9af38e2932d7993163b24368f34e8d27176c71de803a3a98fbf36c38b16b17fa024211681ef4b4156e3817a983fd6c861a79c2662f251344f37dbbd2c7fd59064d716dc0d29713dc478a8039ee971057e771da71b942315e658d3ad9ba4a9599abe4ccce2cc7e341412b305c02baf3097adc208fffc1dc43622d0529882d5ae99f9ee497076cd7dcc594d9b412b2599cc22439ea15e334188298f1aead321d344c4304d91806cdc5ee113f52d0bee511265ad52a78c8213ea69ca1fae682ab549e6db62357f266818aee15c9397b0d841645bd01456f2cb8e6752228db2e83e8151b05c498a2eede780d5524a279de5e33a9f0ff30ecd9b89a420db3850af9db96f4ab150e2790b4d6e618762a45a528e977713aa70ca31e03ed118a0872ada94ef931724695f6135a820240c432277dea7248de0f5b9a55160eb2ff9fc582ab040aaf9a4801c4e849fa1c79a1f165af61479e4c2a5bc542407034efb27fe7b38438437d716746cceb7299201771617947ab40c7bb30478f67fa1878ed71ca85023e19d2ef00d9fc07b38973758631412b141c9a7387039580d93c2dbcb6b09b544d7603522dcd05502ef8a2aae1eb2d289ced7ecadfed68be37048f8392a75edc9cf38286cc5e4f2d01b94973aef337e8297641e5de1d839b4498964f445993eb48a8a9b7281b247048d8a5699cd4102643783d521a01516c90098fc14aacc1909d68f1d1a042e39727290f4f6544f44e13d84b9959cb8a6b2e12abed5f5cb14cae4e1cba9594b2ee0299016607b3481a5e7f6f42560439632162604ba888ced4d3abedafd2da171971291a9232bed751d025fee49fce8237cb4d0f0e2405442078a227bbc3c32b9c6c4db9baf758b9f1f8074771a797136db421d67fbfb051f6688f6934148d941ee85c50f34bf261d3ddf5f727cc5eee0702d2a7e4a9b3fc5dad7c9c413f851f4956194f60edcef4730ffdef6940ea8283323759458a5f56da2ea9f4559832eefb351622c30fb70dc4b5c8ff4008b52651e34f185d98d71f0a4bceebed44e5b4f6600d7647d356c666afc30bf76ec7ccf18c287310c8a7fa32da95623fcd70edb7cffc5999a74e4819f4ab11e855d3b4f82c44d177835d60b9077f1176d7649f1b04ecab54610a8475039392a66b4926fcf2757fb6de1314d2327706707ac6b9cb2b2e845dd77bbcf7b62b7060c110f4f95581fe0a8da0fb272958ccb0a51d4452011a5d83cc4091ccfa9433809fe0241da611f093cf4be4d20db6a80f5d48fe4d54fbbd96594f125afc1f688d15027060ea35949376556be579d6b899712604206fa0adb09512386bb4acdc245f8c6a1f153cc39f908eecd3389c725a2c26657024f7e1c5f7fdb6fd6dd74026654e48a040c7271d8dd080bcbfdd2942d505638376074ba15fb23a891699807c9930ee67c0dc76e64dfcec09176f0769571f3b5c1968fd2740ad675d7c23b9dcb3c5086b8844496e0e62a60102e8dbcece09618fc092d2eede098a68272c6da2f5d6e1fb7ddc79d7bf623f049f2942af8c40346b8994217301f63c40285d9c80c8b3962754ca1e2aad73abba070625e3f63158960248dfba38a77918f301ac8855b9536332312e2b11520eba220492f07895b938ccdfe2248e35e77b5e269afc078e6707fb6e7e8402b22cc3cb5b79dd74b5e3aa429c8e868793a70c4ecd40a7390e4941796108dde567442004ed7150c247755559216f30b0c42b7dce8e9b99da0ac018e1b7a6a2b93a5197898e7cf61591455221b011bfb73200b724a7283b0451a83e3e9e26c0ae05a37a9047b1bf39f7599aa271adf823bee62052fe2f4175e096e1c345b8ae1e167eaefd6c9167410eedd176487114ea128ac47a253ceadd095199e712e19d95202c16b8421d1991662646e48b352d8efbbf57a185b787d3d33382fea74b13382bcf7798d4b62b08001efafb087e723ac5ef7c9bd03650e402729d51a809a822cff40fec20daf61aa34d45239b07bde876613cbdf50e43a1f6e27333e07c785138c8a73bc02278c850daf0c2b88f183e8d414a59911067420a3b8821f2a59b32e73d44d8d88b20714601b5826611f1a4e27f0a360aa6a9e14dbe584e7afedee4166365784c58cfa01c5ab9682122c1ec9dc164c3c61a0eb590a1580b3e71b90c3a4f2c45ab8ab158470895166796a74302f918ebb01d6603d468fac6cf123fcb37a6013a0d3ea25d89c94817a45118239872f9aee5ed744c3f5376952e5605fbe6cd29ff72d6af9521383c980ad3e28f343a943111f2c4c164d47c05640c0f05ef8470fa91e197ae81d699ea99abc544b463fd120ebd5a3797d8e617389f3ef233efee832d4c0116232dfd47bd3b0df1e018a0bcd482f7fe54646c376d78369042940289ae1b6884c8709c9d799c30f1050187202dc4757caa13a2f754aad67906c703d330055a38f3e52a2bb03aca7d99cf57b08d0dbf86aa13a0312d5f1524dfcf0e3373e9e4986e6c89ce0e389b206f3a49438ce19816121fb9c3a08edfbb7549507c40baba82b4408e30b50fbb4b1734cf742c5bc299ab3b46e69a0cff0766bfda03401dbb868ddad28c831c6bec562993946b011784cd9d3c8094fcda9cf1c3721d0eb0f7fcbbb3a09ea4ca200c0bd871bca273de64937a2e64bc1d8951d1e17db7ddb6d0b20b65c7203f68f3466b812d00dbd8e0a60158709505678dc534f91d4524b93b450acee55c3c3361b9984f4b686550cf5e044bcbe6c55daba970fff20e16fdcc4b821548a32f57fd4d0c3e5248d0727511ebd1668732c6787dedb05858ecdb050015fdae6558f0f1088c766fca5715f9baaf3fc783403585271c1e5c7942a800cdfeba43bf59aec14a9af60a57a9d0a1731c696f1d57679bac734c7697cab2813ab3478d56d2f1de9b77f4115d0e8e51e4f8b14582792719e4c2d5af6ef7006a1891806dc8f265192b835914062764423a13657d2eebcefa4218abb82d08da83bc7cf47177a995a1c9b1dc63805601790fa2cb44d68b8acf89dd9046ea3f1525e7ba2b7fc9fd51f4ca3092a54908a84fb472c8da39099e68f63ee1c4b74dcad887125b75dd2461886242172dbd99ca6787a938e2f580de3f052c3899d2d689beda3dc589ffdcfcd8c3a145cb447c467955de67221ace9bcf465fd65fed2e68fa3bd8c026c4baf1dc1e36b4b508ad39c0e5025b8e121220f843e9b686e061f0a0bdc768f17f7254e284eb26c6d96ddfa68bbf0e3da0dbb01008d3e44f19abde851bbd2ca6ae88751b8f41f5a1a8d3c241004d3aa5125b0ded9bf9a53b1e7c606d35ec1587f7a0ed1018802a5a0ceda259352d5b16e9de4115a709df2322190ede6504f91f9e3a0acc642f984e424a345adada3a7228868f0f4842a00a6764b9d01b74193eff2ab363679f3eaf0f685de32710b8ebdc05fcd0a1399b583fa04e394c8e09236dd849085ebfa69fe82c563537f2175d991e11512282d69cfd23b2624c26e3c538ceefcf48c31aa5953a81a4c3d33f9e7e9b352f0eeda5cbdc1b8d22f2a0bd22523799437ecea1ae20ddb9495ebabeb200980df48c8349e3213b19b3f0453f14e2186a0d3efa13538508fbec0d8f3e324d0c2a5556e4aa1aa9e8f280386a5e5027c4b0053cc3baf24ae54dce9fce73f2c2b36a2528ba8a17e00ca0094c925c7d985609bd37289d952c09fc486eb04b8f436ca007cd32f211f198cb8f8fff288273f36d424e880f5f7c3180a994e7735cbef4d8f0baccfeea37b162e120d2ade5a40224f16f76c688a95ed78d9134faddf04408b74470a421ad5aa1ed4a35fe8038d417378cd5c57381d06eaea61f6f4f8b572806cdd575ad8f0edc32d0e6c93732d4e8ef0ecce347c5981f9027e77cc618394f36bb2dcc67781d78195e1796e7eb4c783035a502f055678fd6c8e289112f9b37a25cb2e6979b7220d0983b21ef0ff0bc5ac4adb99afbc74b43e510f92c56e89aca3dcebd7a3385dda8917097f0d3d8cd8e63cbd88856639562550e6adc5291c95a88dbc5926499dbcdc278ced6d5cb54a8e698d7e3e143f0b6b09d0957a3cf56739cc10dc03ae09797b4ce1790ccab92212d7463ec0cd1742f1c29b3dc28a9d3cbba2200c48b730d7638d0c881c861b6cfdb606c23503c68626af4099801f4afa7feebaa42504658016b434e789ff17dbeec35fe5397ce6f0973c1a8087305f593e6c2133a0c44888eb60353ba38d510f28cb26f26d01c6f59bc827d5da0b6e4ce59890ca9dbbc0662a948eaa4ff2ff5377b0b501323e0417121cca92a5c40c37e1204e9b0b70c9c7cc680355089365a58dad7e86271cbaa3e602d74c33fa932e6087445c16e90808170d2bd2c8b48c3a27aa4526f0d99f712c373a92daf0de2f1d11dedda0e55241b3528d54c51f07f7f1a811fce4c052a1f1e6aad6cb35015406f609b826b8c43bf0c9969df8ebae5288222f7067301ac1b6dc034f2b796566901cf9860a475c386ce0ecc3c83803af6206426b2e7e78f96e7f01fe08daf115776f3dfd3bb85c0d32b49681ffadcd4a84881a7ad0f2d9d0218e281e4da0ac5e29222499754b6465be8c103f7b1857c1aeb5f76a5a8af6dbdbda2a98e1cdb98d9bd96cc978ba164fba6d7fc6cfd1bf9884e6b8c7c2375b2c2512cbd79876b8a2fdd29752fe862a460409496d343217632393170e16595a7bf042f68dde76fdd0501f88e4dfa783cf834834bb3a1e367786391c0fcca52c4c48c8b65fc691edf3e25b6dbc745ff6b86659b8c882940a1fb1c26244144c4c13732cffea484d917402a4ff03d834c1960a9ba9d0cfdbc414d6a51a7c00de24c8e08796c114c28087e41d8e14ff1c06dde9617a796c53f3353024decdf56217363968fa1841395550af250c24b162ce9c45c66fca1ef7ec3af2a9ccde2af28bd9cb09fd107a5f3fc17cb0fbc039f9a78955b34388fafea4f7e4e20e16f22380d06472b50046bafdca59802efe13204318d21f70adfe3e8a1b60f9e2b539c8c03b8d42df5a8f34ca88d41e75eeae316df3030eaa878583b29904c99f9bc1852a313af4c05ce446f1d67a60833b4510aa1e9c59b81d1d198a01eafc950a71a444577b28dbd53101eba9118c4d6a5e644a39b504b4c5c846fc1b8f680472f07599112f7bc3b8b105a4bd2b978b91bc907431145302bd217e0299874f4344080445b939b749a0f68fb86aeea79e29cd5525d0d9e52b708d6a624e073c1db416882220a212f87638969d50ef871580af9e8f14adbcc8d8932feed935b65ab5eefdef424ef094a7ea3acbde3105ba2ab17f4f27e743c22d751d090a11badc7fad35904f0c1016e431f4ddb8dbc17d451d063928cc4ece786b2feb774be6fc28a5da8452e34098e6addf38f94edf49c7121d69099ecd1e2fe8ca1fdc8d75161c3532020af18635b09d4bdc31cab67c08b1529de20bb5c8e581437383908a565f96babc5a909d6a70c0c022cbb011eea28ab8b09b7654214fc4d5141326c763efd31c01813bc78aa05038f9f3ca128e32d6ba4bbbbd7f487f0bdb40a31c8232db9c0f56eab783d0d201742751d6e3a8e638031c1d5dd61d1f698ffe252b49d94bb171ceaad1625fb200f7d73f00a2db8cd86209af60c6fcbbf72a9a285aba02ae06c74ea486abb1ea68208101e06452214f88132cfa0854009c6caedadb494d139f9890b93b86bcb01dd60bcd2a24477e867577d741c9d7a94ae869785074b0d0875fe7f1c3069fca4a319fcafb30497648b34f845cd74a4ef6852acf4e9a13e9e73b4a50e5a59b84effa40b19cf57e837d6081e401a31750f4d8cb337229c9c6a3a9b835b2001e99e6e49e866b66917c0b114ca64144aee8ce62440c50c9446a7a20f269ee9b8f3ef194f995b31c362abe37155e8eedb5efebbf3fcbdc0b696705f166c37f5bd1f44a5c03ef22c9045c8cd0c86000cc2404e968f7a73a678c7992dbc65b7bd146d243199b7b436fa8f21742c8763b62ac0624cdaf8d1fb7087d757a13a96023e71b35c8129a97823c52e1329239e5da91e6aff4d8f2bb3ff8b9d53f57e58a7dcd3113baea67fdc929ce501f8d583ed8bfde3259e356cc738042b3de59b4e3ef01756ed81a4bf9cc82c20636d1bf2e510ee16251df4d1ea87f3f1192c36cbe2981c141ed2aee489389f49bd1bb57734f725988fbac42e2fbf5fd8441e12ed45ae6a1039f13cce9b63981fcd1d2c03f41af2a6c18a6e7d631fb6b5247c815f8b87bd3f47b12a4c3ccaa78e5916561cc569b7a565852394d67a29b2f0b1d95db100eb473bd80e8472767a72a6ecccbd09e3b79fbcdae908ab3f6db94aace42c86f0d67ac1487b22477b65a2a4736254236dd2bfdbba504da6a05f05fcb7921af4a8dd4aa016291e3d404019658e678b985b190357ae3a6bc85bb7d07bd8d55b12e910ce2f6383219280c213e5f3bf1bb8c129567876b4c66123777ba7504b6e51a8fa983c1821326633cd41e0ac50c1b1bb0efd61a9dd31df3270cefa20468fa479fd69a4fe88f2fe616ba98eb004d5416961021dfea50e0434372255f4fcc9b3bc3675f445c31db828109377eeba4a71349d2ad7310c745a7fce1836e89f79372314e8ab1d52f7ab7d8502960ab6377909cf7ac688314614cedac5aabb55688606d77cb2ed2ba2e8391c2d96e65204812c288066c78090381673e32840ad0520bfd06629159a3f4fb8605fe1a27c0a52a02e87ba7defbbedf8bfda16020c39829c083af986b5c354205100d020fba679fce847e148ef1696d6a5afa812d613a35983d115a468b52d02c6fac6ed03e8d67634027652aa7839c331daede2f4a63ac2f08ca6315f22ce0ad3d475e62a16b078c36d6af2901dba7a186460a8d64d096a56241ca4d56e38ee027743d6d0c5def803aaa998b1e0498955d099bfc776319496b44673167e021916c7049d71bf57e630dbbdac086f5489096ea6cd9bde237594f73936c2cbc19795d2eb51e949906ef339e579098edf715bb8788972a4d93d7a1c6cf5342421e3acac17fcbe148b22be1493fa95d81064ebfc251e9d779d50eb845aebb59c93bdb87f71586e3df10fe924df964e7fbd23e3d32e9b7184775aaad56eabdc2724580448c23cca56d828e27cb72b398253225784a416edf4c9c83f710d66176343f8df2258573d95e891f0ae61fcea7a6cad18fa49b2a98208c664243751c85e9d78d69ed43f11d34d60e7c845e0a00fed19046b913fc046465c01c0b7eaf0b24e33c938f0466fee5d36b7969bab8e680970e94a321cb2a35765451b0e03c14d6e64924b2a54283211efb07591bc9460bba766cc14cd492047bb021b8d1c770f87f9128b2422deb433f01fa34636b8a83871ae11966e749c5722bb0d1ca130e4ea5af156e38a91dd66693e1f8970c27be7015499b94979ad2fd81d750428cf24116640caa82dcc7fe789b76750655e6bbc089c02c2dc5f134adef5e434faceed0bcde737006a49eff96b3ddfc0c3d06e1c386b9a6b51795d7a340e4aa2e4448f5d89306d1bc4e5cb17bcaf0f69dea68164401059cffb0ec4baa7a47f6541b00e907c2c2e7fadace6640c511b652017c78752cfbbad45d6d093cb4db37e7517a86eae8965267327be4041c09136767dc3bce36adf32448b90127a59a6785b43ff808e814235bd7ae7e73c0ca073a2fc8cc25dde3dcd583435a8c8a36cbc7c737a6892e93de01b672744059211738f6f4ef6a81e6cd91c27e8705f9930e8cf90b4ffd087440c17632e13128bdebe7128a4ecaa68d44c5f2e87c6e9c5ddccd235a190f5095d0580fe7e852d0ef3d8a3ed24ab2c65e501a3624520aa2397e95418e1de16971e5c8c784efb5f7a809e8fa1290d3e4a9cbdafbf43ee3d5c79b32cec214716c85e4ee52f22f0723a8033e5c83f26f824660863d60dae76792665f0a8f0698e656d8bda4e1f15695e2a49b501322f168d1805baf7b28f61e977115c879eb5f3cb1a6075b89a26bf952ea61183ea5d1fc1a7d986e907df58260407e46ed6b816ded78e3a8222dab4c63bd621ab8d7685e9d498a7265daa6e7b9dc9f14e72a52248ab4f9221f6f2f8430449e125cb5a253a0070dfc4fc9fad2842bbf2a09d690bb723c0ed65ca75e324f489b4b66ed166c8377700e01e3b16da39629e8c0e160febdada6d5eadaa662c4a4947a4b38e9a591384165f06600febb4c7ad866d5d864bc8d230e14b9f48ea347b38179915b3ec9a86d9bdd8db5274deed739115297729d8a0419134a9629665e41443d502f0c96f7a0e76591d2e37229e1ca591904b4c0a746b71772b5a047cae8452f96df11322bf7ac8c43b35e1137f9e90f680968c0e6af76e8e00a7b0ff5b44c164d2b1de63a9ae0d2d67923b362ed78371e074a137f4ef7d4fce2352ff6cf3dfa7bcd410473e5e27b6b138b8e3b3534100cfe8ff6572e7b3a9a6ec59ad10544d74deae72bdbdd1abb3c7aed29f87af3ffe23696061fb281e4c2268e3f6d44045a7f22ea17d9675ef9d611743071518173b83620ec62660c4bfb499af525f5613e016f57a390993e07679c0cd1b1fe40cb3a6ece2d08f4e62f757d82899d4d126ca4225b72b9953602503498919c22243a56fa605be5156ef9a96c406d6b51bf5eadab104a8b3c4e1768aa38fb43f6462c2cd381362b8696142e5257d3f2f6a79d93dfa295b0a6f4be00e593ab23006a37e7d9cdacabd9a50056023943a38cdf39c4edf22f8cca106512af517370dc93b0135235779bc6944110099557052b6cd40ecfaf2aabf15096398f8c9591c5fb945b1a8d2ed38fc2a4b855679eef30cf008609929acbde513772d3c06a817846c0422f3913f5935c963af40e0ea0430c2b363f0bef9cb3a3a33513d17eccdaa957a0ff97503a9ef41b1e1ad010da9fd284321c356b77b2e7d6008965e28ce9e09345514fb87f2a32a38fc7be5c75bb91bb912fa50e95b6cecd63b79738091c71bd32a2056ef457eb49c7a252dda95d333da330a1d0e660ce977321e643918895f2a76df77857125631f33ba891400c9e935930362ce7561281fed80ef9bb52bb0b6e9559dd410b4a4342436583062683e81b2d78d4dad2cfef7707df7d2a02c6743f2ce358d62a5602be823bb14b2e7c5b699bdc71f88fd59cab2c405c63a6ebc57e39e1ae68997c4e6ce5e2e4c9d3cea82979016b36d278f5b65771f1b7bf3fdbea5e41eeeb9ba2a68a698d756016695bd40c10d1dd6db493ac2935a8de13cd96060832063e582dfee8dd76a01d166cba408e25d40ba924858a56353f108991e74ee0dfeaf65da2697f4b2e94dcdb727edd0154a790178233986979d35d24355a3a6c127b68ef4ccf04a73f21a7a43249fbd61a7b3b031a128d842221d22768990eeca678b7d3a44d5153e5e45541215cd1736608f61d285b8d848d99dd224ddca78d46c38ae33a2bf88e811763556b11d94095e50065cd90f2525273f505e0a826f937af74fe4caf20e925a5676c362d1f177c618842e34fdbb88970cd89996879077d28067fd453c6c9c54cb5f0752410e6f508db3886300b1d27e7fd5b853f1d84526d9c96ef967e4b44fb66bc588e5bbee20cd0dab9f0e904981576fa7cda8ed5b0c0e676d402270b6f8fa9470a28523322bbc84993581da69ff944a35f60c57b56f4527212f9643f0db99b337a784eb9b229fde6b73c898c02d176550636b017deb1a675f30e97eafb96dd6c0185e04051e670a2b89e85c343e8d5e91cb8d08541d9dd86145e6674d5428dfd488fa53e6560fc9c3652e238333f5ba253d5cd12638f1c05ca9baa4dcd452bffcb8ecc512154350060380dd2f3163ef472dab8405b5df3bcc15723e1183e14e897de303f2298e990a4d2afe71904309e6dbcf7aee76f1299326dc901a789487c622246e36f0053ed5aa14005760877b1b7f71588b90e277ec16690f26b16bba871ac0265e4a09bdcbb95c2c807c9eed13381bf9f8f1a4af66f951a31769826e7a948d1544ffa5a9825975307ba8dc3d0ceaed4c2d07f32387ce65369a8408363a2e9a72bf71068cdcdd1d7f514fc00b80c48999e3446828c0cad105c4e30bb979323bb93c32b66b39cb58f8ad15427ba32661472e9b17700e8d485f469fecf4600adbac79db5ca4bb5c87585f31ed4674c3a1eb71322a4e0774ea5f58668b8292f09f6c1642ba7e48f027d57be336a80267ebc3231e390a46411ca3fdc5910afa4907ddc197b5224e13d9f2715202a00e3a3866b0537b618194ebeeff3722784240573ef16a83cdd8cd110b541ce8507e07a83a3ef30050eff5859aa3d7e2674577bb102cf77bf59207bb142c9f05db8c7722085317aff5cd3fe4cd06b605069da14c5ff55e8ab7958b83969812d9a960c87570b3982040b3d690bae4d34df41ddc3a9d2133410d463906511d4ee77776aa96309af8ab66669737c914d733c55c89566dc89c71acd791a6fb5148a16208c18026c4d9dbfca9691f08eb2427df8ecc5fa020de98d26c9b7f8e9292d4a0b666d5363c842c47031096fe61a8a817fbd1dac8ea749b2874117854e4c16dc923598ddf7a503e32aebe9ce7340b351de886befe5fb6382e243b13ce68c18892c1121177d8c50932b9837ca88407ddec3a7e40e45899b9311aeaaadd2dbd1d08a8be65e8869bc024ac5ccc83421bf839ac6fe4fb336fbbc27941938a2af1d05f14ab8294c1da85bdeaeab4b78532a4406a9588e7204890fd406e4ca2ab9baa7b58e84a9083471316c0095703639f3eabc9a37872cdbcb3cd917ece8337bef4a7efbcfd2fcce23b7933f7bb5e81cd4a99a9330b3a200cdb527c7ac717c773d3f2cbbe009fedb40d969afec3f82bcabd801775b7a9a395b91b76987eb7075680afa32fb0e60675094ec99d48fa08986e8f28d3e47ff6142c11c82b9d95a3e6b39a51f264a6a7aab430bfdc0f15d6aa062e667ce952ac410ea67250c33640760669c0c6b58fa1c4b888900df03f7918506641e46bfa7b4a36d6749615b2c80f7399d5845a129ca679448069870f9a107409ce93b4b048b84afc7d846904376441595b1eddb77df2803a3b4ed71a969ca77b6b18e694184a571768aadc3ff0fdf4381dfa78175be942695c836b27a2e54a78d533fd2a0909971ce9ff623579694dc0fe208b2d30f3e299e40827942034cdfbd1383366842d69693ec128051ac3b3d6d16c52ebba3bdf1f1b1c004c95a92b55b41fd4ab2e174c46ca2a8c6a33b8600b66d4999a670afcd01b0835dd4e14a0235ad159236a36416ce583d748005ccf37b8bd7514a8f9eb5fff9d0cb67947de4112418751887e38dabc1a8306f5d74387dfe2be9dce7bee4204c3505e4881802b3bbd6442a2fa791c5096c280b7a57f51db025a541f0f95cdea8c20cd82389ea701e61e3acd6110f103569eea9f870d15fea68e5bf2b74372ab2a277e468348ace2424457675b575a9e932e419bc97566b33e70ff5f317e93d85033e33709d28b1fb64afc8cf09f0f2c330befee93ed111cbfc0e631b959bb660aa64ae9456863befdcebec358d3617a6da98f9ef5c202d1ce67774aebf43099ab1cbf8957f5f54791d4b0235c7a8b3490a42eda29eb14f5ed76ca199567e716bc89f20e2e5285d7091d0c1229524a924c6aa716d53eccf8e0056099d9f5ca547a5a718f62d2439bf44fec32e420f3a0cc69f288e40b1c90b53184cccec2da615c84d0873e477506dc31edafd479c2ea798166bf0fb78c03ef20dc9ab6232e3e0c9ad5de08227b3a998dc7744cc71f84287eaef9dd6eff2ede3d2f6690e8baeb70a3ccf664a10d221666348bb67b07e834a0793aae60905e7f2ccf30d4eb85c81f2e7c3bb92f4242f8e4704e1cd98ac0019ca77a07960440052659cdb6e7dc82352db7956a16d16a45e38380fe29a4023da78a38906a8e90c67330f56323a33dbf6713eedbd328d56e22809f1a2d04b7aa3c5462f720954541fc9f6e27a309a2654042ce0e7dba0cfc733a0ffad21803033e298d18cc3b31260fd6cf7e322a6969a47935e5b8663d87ee92571217820c222bd821d4089adbdf20be374a2ce8dc72f70cf37394f7283aa4a82517a2489d7ce49f1b11bf7e9ab76f8246972fb0ab43d34c5ddecc41b32e51267509a3acbac084fd8ee8f32d78e86ae5332a4b0750a168ddbb036ed22472fcf2f7d6039eda7cfd182827b878abefd698dbf7e5dd40a1d03ba6b9a365e9af569b7b0c7bf9a060dd0d6a444b3e72764381586398c71a443296a75178fc17febdd8cce93dddccfe9dad915cb080e115ab347f6a5d4e0ce84552ff35261fd5a3a953c5086be6ddc668a3b2f6101ab8a149cafe60b6ef49433736c9821adc1252cf7c37d1d10846388d4e14f52721cefccd00f8cf1e403e7b64510e5008e9a8a23082b3112af3743a6af5f7c8a6e9fb7d14785180127ef9b71b2f81ee9c3221522cb523c9bc3a6886765ce742f947e7b844042adc8a61982f6dd7959f19c0039de64dc5943bbd12efdc5e75fd918a9f679d8c9b4eecb8da0ce2ae5da879646973b2a344d1498a3560f429795a4e994b868835dec8c3e99d51239d1964a0560c887a66342d5ee9820a8a17c9015f814016b76b52c35c481752d4c6ca3efa5f168587ce1d440b10a6d593390e17cdb60a6e5984a161f46dcb34d8ac6f6fc29c2d0be72d47b8177ab33824e665df18c4eb3048cda42a2752c8974e6b243df1ac0571931ae723142e9cb1ae291752ce17b10a46e84a8c7cc5803702a96a49fa85863d11ba6fe39e5a97102fc04203d9628c0d6d04548197a72e8b4401f55a8f2bd6a9e2cf34319955f13b3973709843b5ac0d3b294164d15cfc99bc416b13d2db870e7aa6bf34915260df5e9d017fd52cb8d5f76119ac140bbb50f7feb43c4393363cf8a69c44f008f24405ab4de0cac4539aa458da6fe01b9814cb51ed0e607873b30eda71997e316c3736582297a00c9092db0468de8a14f6fc877dd62c2faca6e4d59f8b1dfefbcd6252a87cfcefcff8831bd54a97c71810d99a6040b53e3e14fe474432136f888790986cedc0bd62fddcb3577be6c505d2f45ad864ffbc583906f4d12e0383ac18516a7dc01e3f4cb74b2d73a8ba5e636550ad2f87c0fc181ce73d34e2831068a6d57cc286d42a11aace1e5d9fb473ff2299cb2574f47f8c2e686360b3ff92854f24da5819379045f864921bdddf68375af2350a6c938a2da0bdb5b96eea601b8e000d60b003a90f87f48afb91f13942b00449f1da201db20aff7437fa3d4b2bce201e4581d6b9e6b66a905307fd94da277e9cc1560fbe18b11bcaff19773e7635fb2ec2b00c5fd125c1f2a663a1a83c3a5b3c390b9c48d0de7166be9bd7f2cf4ed01685ec73f2dfe5f9992e4a4c7c47a99965ddc1bd76574acba58ab42aa610384e379ec77655777e5b5f35780edc18c2d2e01001f33babac187030167b380f3be6d7041585171ced7dad1eca22ced86cb1e62ab1586165f2b0d15c1a69e6840e71b58e5890a26d7145d8104cb422383ab1904a279b12f7fefac39296ab5e865e723972dcf60f54374d1a90614be50b1c47e5866066af6bd3590df1932280bcb35953b529e3e96e6a313d0037dc6b4460e7d33ef9cabecbc7766e5862e01d8690b983c187fa98fabab70500960623906689b1270e8a590210894cd4194e2b0d69bfe62f78af57fabec11a89725361f257d3406553abac026e880fd130b39364979692da626089641e00c8b44d35cb4cc55dddccbd43d36b12de531bbce00f5bd760cfc5104e75c6ae45bd0e30f2bf8f72df6fa7b8c102fdbd213b7251f4264d6764fa6eef171d10c858d2e1953770ba40f01a8895db5d98f9530f0e9121cd521ee02764b6f8feb868c0e3915364b0dd91deadaa6a7148e3f61837c82288b710d1a1940e25ddc9db75f51f7ffba60b363c9d4526de38d9c3b7e8b5a881e4061ba569eca3959b8333658966c15e6680ce7e83918898351022acbd1db43609983294583b3458975efc9beb7c3d0393b445530be3c9bcbc97a44bf052c89897bc03dca67086a341bec197df5da88a1db564f48e1fa1a1b60a0f5fa3b779da291ccb4b5d5020e8e6b6c1287c492fadd7e8cf6dda1844550a9ceef590eca1a173f538c1a9c13609d2e10ed10c797663bb4c2d8cad30f1636ff1a99c43eeee72fd9b0a93daa746d444990c232c454f707c54784f5b76920bf7457062c18d4db4249ff080cc1905bd17a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
