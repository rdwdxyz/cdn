<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ccf27436769583008f9a2e1392383ce10cf57839c53479f50157dbee42ac7a9ec2fc39120c949f97bf86c8eb6331c5bd3cfc30eb6f95ae883cc32d2a918810fc38462f2d8ff6e74a2f5493f71d18ff729665d917d4792d2c8679953977fe9098d63fb2d133b1a505556707212db12872a5901493a4e1a55a813db016bd079b86b5ce96e184fdf38b9e1484536f94fc2d4e8ca334637197d2430edb335fd3715dd9c8a5c02016be301fb4946a38675a024e5ece9169fcc05113faddd6239242fa61e4f7f6dd655034d61b7776fdfdfbaf86eca70ba84aba5c514132b383fe31aa3af4a93391a41c590c28f60277d79c9425e8e9014a661ef936928e2b0fe67485d817d75b9d11e527bd4becdd7cbb9c744fa50d947d2ea92fd90649513d29268cc99d1668ac082478772d4a0949f898ffe292c7e3a7fed423e91ad6ccb8dda47ba73fc02e522617c8b90f7144631731e649126c6a0957a2248a987e17ae0af9342d4c5eef83e81a541825d3815d2284c7fbcd949de8db69a4e239a391d777b933be8a5ce32065f4f3a80e89cf3e4f3f68eea1318d532244eb40a8ec92655723be4261dac833aefca72b003dc0f67be0998d3a70eebdf9d4d60184dd0c46256b76ac850f37d33db7969c16f2fd15f29403c8a4c8bbd8940c6e1c9c2acd1ee80365a250f5364b58da8a98c0fd53da41f3c7d15e500410b3a4ebdb06d7a7e713e7b6a0013a821d7c3e1ac9a3338bc3a4866a27910a32bb5292e398835e22cfe72d1f63495ed1e84cac128765e5e7bb2c921a27057da35d9ac49340b268cc7f055d8cf39e0c7086546dc66fce2d35e3d456300fb61b127cbe2006a501f7b87c822c8e98d5e8d104af42ac3b603955f692817e081174dd3be707e9637d3c27a9a668d1d1a547deac6e13112724b33f2d113f2f1f21b19b4d3e4476308699a6cb1c463d9f15cd32a510ae10bd70d93a16b2ae4cf3a4c3d707bf0d4110bac940c533f9dd0ba0027f23df214428a129c881824d9e0aa3bc29a58ba200dfc8340f4876963c627dd298c1dc644f513426899018b925eea41a2f7acec71e8f459adc25dad062e6386443f53e74bf4b041bf924123eecc0ff4048bd7d40f12c14c52d2b314b34585b69f2391cab0ae13e4411c3e2f699f6864ed6172e98fbf369fa225101adc5ae69edc5e304dc8d3c73a935c0bb0c690de438f142d373a103fb816d69312a98966902b4350bac3c34103a38052ae2b7a903b02ebbc453c379e52268e1a2259e3fffb634cecfb01bec99fe467eb922d0da76b37899bd40d7484c4ae6d241abf114dcb36299ef2c1477a1e4fe41652711819104c225c820c955d9c6273736f1fe365f1552e1ddc5d06053deb2c8b28694c7d3c447d021b7b2f21b679f678db7ec78dd9f84b949e3e81e1007c05764b96aefb0e62d5e87b77e04e1248a175889f21b6b5f7b9f14660cfe98cab929aba282ed7bc8e742b27fb03374d3d398a7d7a45b1bf6bd64745933f6f9a85bf083b75be18664fb2b5bbeba7415ba19a7600a95cf99d94d7e56f6b1d91a26197092813bd145d04acaf979f31f637ef0c548d01447634097ec0df04ff6cba1d205ae1903a5f950c2c979d56ac8e9cf90968d7077b03413391f9c602f4feda1a7d93c18b5832be7e8996e0b0019dcf9c13f5e1434d7f502474b4e5ac051ede09eaf55ed6a2148eb31d0887a7485cdea956bae809d4f26c128b7435876c690d39237f1ad9444f9a7981c105fb21e58e7295856ffc2943ddbf01dc4ac9801a0a485f46952f496a5db008aa424430ed739fce0d5e967b8c3ead28068ff27d2d1aa3ddcb7fb047329ecca069939fdc4201c92fadb062b2414957472fc5c2ee081da8b8a5c7cb8fe88b902dc74c4e1ee7ed215b8592f21b0a5aa9fad9469d633911c6c05b419d4ab3d73d0a2e8f47cf15a0bfde031bfb94afb0931c484ce81e8c0032015db5ad6b9929bc6b1c2f2ac120cff528c8d9abca28f075f5c3f7b17a942ac0dba4285d3cd5027dd1ed594bbfd3aae8e68b8923bf3a78d7bbf566b30e33f273bdbfdfeabf178f7dba7bbef8bfceb7c4c79529ff90c5aae2fc17c2bb2369559ceed6916187c01d7b6d130d0bd563a5ccc8f6ea900f4db1e957af962c4d924ddeef58b09435676156e13577828ffa1890e33bf2d4b50265d50f3c2069bc41fbc961856ac7d628e80456277e99f7960984989230d09f530b7afcaccc11d8cfa6a61c6ffea7078fd6ae3e6583bebc4aea51899254c9dde0253423b177f6a3f06386e0109342df7e4f4ee7488df17063a9de42cb53183dce4a0bb39b36c6f9318dc7dd14c8b833e85c09528063908a4afbafbd8092783b3c15b665c1d321d657c24ace6da553d920b6cd87655ef7d0995537c6c783e330da570e9eea562a3aa76a0829261170515d94371a6db67ee755ea0cc1e994e12aff9c577d12ef9d0b3e1922a854ac62c84ae7efd7724c0a97176d7ac60bee6df270c3c77e06fc82b7f32207ec2670050af9f451d00bb39b3c6f3258b5464dc23515e5ff4862af99ffddbc92bba4654ae07e9a1b4f4e24ff87ffe17bb5eead440121a393d631c3ca6c2091b4d2657d4506bc6b69ec2abdeb95d764d0bdbfc0ea4481b9e65634c300221b20648c552b4349e00fcaaadfe9014c2bb7658fc43a6d11b9cee754854c0768289f07131ba470af631596ee7928943b00b0de49adf16cca28bedf3122ef0796dc445bf5a12f83a41d4d6618b4399d3623ab70a303595198d03f97278292fd5a08fcfbf583fda9dc26a87229986b40875f53c38779c34cb4ec06d721db56284d041fa444344ad8b805c78b444dbf84ad04e9a411e17c66aecbfa924679c013c669368d504cc45764bcc22b0a293b3cf8d97f45fa267fc684f06d6f73c161ed10185930f67cb796d76f58214c80bac5fd39c0af2f73abb80cdabccdb7e3ac1bfe61380b838d4233a416e38f99537f30d39cb88c70128d349a86cdc1096c6bdcd0be8542b80c45d05e4cbaac3b59e243e953d55d230511e5a88b2a4ac77f50aa149f53391fc7bfec6a7a73af416517713b00e5c1f707706bdd6350c5c3570b80880185eb07ae49ddf43f7655f14f1a91bfd1a9d076eeab9545f355f2a2e91b88cd7b12570214d18efb3b2c7d21e8b57ad2008386ddca869686f38b83f70f2d15a542bcb1814e14b149abf84ea64e8f08d9d85759d5d73a21d02837ff23519eb7da523116bac8219a6b9785bf8a39a28af4a972e2cbb76d25726036913bba7ab627f6d46141438346752c500b42b455c1eee8af619c19c914ee870b435399000ca754e0476c2d595443da752bebfb001ec323fd04f4004aca253a9269d826812ce33921b970e0b36998207571f0cd41f5345523e7132db2ccba3a5a13ed88a0bfe21744006b4535404bab7294ac221a63ffc58b874f8a6922fbe3cde3c0304153aa45d33f8a937796a221f255769ff5f5c47f0cc5ea796f8ae5a99d02ad4949c570c960f62306593024d8fdfc776b565f718a442c62d775ba3c1b4c2971ed5525a545dd5eb99faa71273b52613858454a592c851d8883903167a4afab7f82ffb7de077169fd80796684a3492868f7aaba3fe7f965b1e25cbf16db12a772841e42fd7c967c90df6d45b8848fbd77c79ba4b17ef1b7f7825745cce260c29b7aac28c98a6369f429840e9e8c18c83c2cc8236acec7dbd1f186a2aae91dc99b30436f2fe2d9b3e2db32158d110c2abf929e3b439b081c58496a79709a922c6c8317f36465322346cd0dc7e8aa547d3e84f9ed5ddfe71aad2301705bdc366af96bbff9dd15995ea46be62b4ba98619afbe69947bb0407b20ce851908038be3f9d595e97780156da8982a3c91addd8ba84d1c52f0a86ebc7630e98bd1efd7ae682c39ddb79af1c4b61a614bccbdb227120b6704a8b809db0d6be2f9e6d1082e4d88d7de5594cec4c191ce36bf88646daf3791fb8c1779b6a2d8595337001fedf425df42c1802d0a5066f5e6104929055391289ac63d2803c2997d3fb098b9e52cfc0aae55046c7f1e36b900263d3cf91125d6b35d10d7831a16d99e753178eac59f8d713e04d370a05c337b899e3250b0339f3831021e1f0b9d637cebccf00ced2d0e0b410af985d878c3f75dd01af9a6d25e773409c2c460fdeadf7e4b7c0146edba5b50e0e08a4ab2d02037f6ddfbfb13a12d22f68bbdd746bab7ec012c9aa5ab9f9fbf0ab22c57fcfb8ef03bd8c602b3b3c82d0836686213dceea8407549f9c990c506024dbb646826910ae00a310523c67282cae7b9c374837e30db7b3a2f5b16a53d5ba12c59a717ac0351fca92916ca07b300e00ef239e7d8fe75144176a0992123446bc2ad1cac1532483f180a2c70fe0e3539cd16395913292abcd2528e17ff2becca25e133b033d0dfe3da288370baf8a40854d4d0eee2f91a92296dbf173238ae723cfc6492d64f08b6b6c32babea3008d244126c6a048bdf9b43c470f7aedb67fd131028682d41a4294c005cf9f78f69ba7284fe212d30c79595e2cac5fc5dfdf7ccdf397b2c2a8c0c7b99088c194d5aee23f9df5af070b793ed2c7144473bcc99b06a51cfb8a800316f118bcad39d19655bd1d243623da546c2c76488ee94fb76abd71c04ed56b605329a6a5c06dc6c80b7cdd6baa297171d1364c967ef0ee058344851fd84a7e095944f28c9a6be3cb69ceed0b8c75c627901b6d25e9cd793ea99913ef00a5a60286657ba1ded7197dbdd0b23f7a9e38befe3a1777b609e7d95f1df543340b9fbd13461a0cb5a7fe6672019e48d2e6c51ec9c470ffbd2c129bb3f6922ca2ce363e1c43ea4f2b4dbc4e4ca36d6265a4878f2dd31846d5ed7e793fe7720cf7d7d99c1c1f8ad42e2bcd66fbed30e70198941de96d395810d59cf83be41a695a6f389275b2db9f8462b7a8d525d6666aa41af259b52d44d4a5bf144c3c26d3ede25bfbfd935433ae4ad1610f8197767877b692eec39e18f9b1bded419d7c243002672ccf6391a62fd5ed32a5453ab8e7f4873fe5b6e33e2b32a8d6c595b861bb59f554bd8ac74a5e92cd697ff069e8a1153113b2b8ea80c2724dca3f644bd20e05da76e0af98b0dda216f620908e63ea422b632cdc17abf4530a123a73245204a3e22ad48674f70424e8801fded3d4fb86600af0f7416148233b62ad0f9e88c29d7d5da591fc0528c0880cc88bfe6f4023c4b366f75be445ebf1f5abaedb3c59ed56ab5e06f12a0f19d30f4eb685f39c35f8fc446df6a0ee9fe9df84544df499d4e3ae6098b084ab3e11afcea3fb05a532eb4c78aa92e75a455ab26ea5369e1fa62ec2863f5e5d63e0fdb31065ed29d8581189262639923c63d495e86efcd0d14b6e1511431a756c293dbb47767576d0a03f3e79a7cb0a06f09082c98f9917d6fb2337742e9449ea8fb3ef3748b522d57ad204e8f91ec2262bbd312531eefa1ac7bdc617f904d0ef7613ad9c963e81c34862c2929580a6e1c973fcb5df8f4407c683179e20308c46a204b07241ba791b0379022ae45b693dfd5a2dc535aedc0d25bd76e54ae182ca041ecc97d0c319f22e186c83c1430083556c434da08bfabfc896b466d64e73e69da16163609fe919cc031a0db560aa6d4a0feab0a89626cd065fe7ba2913c27a1000abb21c0997dc37f3658cefee135e31ea535606c71b9a4cf2bff50816cee972eb7f78d0920a06bdc1db6f6931f995132602663ec3b3144f58af7106bfec71ddf66870608411314e97db8d5e7014aea23ca6e421196e74e9df37412def55664412788951a0bc38c5e094190acc201b059e29134664556b0dea5f10b9d34524d92dbadc922b269547d7eb5a0786a10b3ce821388f79cb12c062ca95dd78469e7facd16f85e79e5cd459678c80cbba7b44c7f224f0bdbfbedb83040843692ff77d2f5760aebd1111440b500539f7b2b5379e5e28ac36a649e9b4cbf9f9c9b84435aa9de262e143de8c72d59a2baccc3f0738c2af8be8c1891af3535df8d8a1baa4ecc9650d99bb148dde1743de42838866f602ac560c38e65bb35ba17d5e66c5dbca80e0b50bc49656aa9355bdc53a549ac1a1f5d3a8d5ceec4321edb36e30d617df538d20479f125234e3048c1d26060da43af217ccf862ef714146fb7eb22c167ccd50edd52582ca185c0bc0c3d8b0765cf5a632dfdf9e7910bacffe3a6ca67090618668a2cde06ec3069b4baa6d79555d19d08c0b4e4f05f658d3c5a881d8fd289505b19bcea7bed3443302ba9ca6cb975f1caac2ca3dd60bc5423270831ae69014e3c873d7ddd95b512d8091366dd55096c49a7420db782d1f0481e328387b7880bda72b93a1b70187bd0e76dd81c83697fbf71503f30998db47ba8d085911324c78d1130f319b277b24c4aec83a2d213d461f24a084d61ec1240e1cf4717bef21cad0a6fa331f2a80909ea4ffa17fe9eb5ac3883e64186f2eff4a7c4167e3f95ce55a26ce826bf85670c0cda31270c4ed0669aee959a70a0a67874ffcc0c11cadbb7a1171299064e40660fe1b5049debe176675dff416710880f3a812bd7feac36df7b889bc8a24c580080f987ef777d08a838dce0bd81985afdb811999e1b28093086cfbe3c9b981e4af74b5e1be3fa541447d23aae8b5aa79698c169f72c2a2cf8150e5dd937f2c3bc847819d90652c9e67a3cc971ffec70dba0181341c1f74100ff4f2c35f6cd9ea8653b48b29af00fe64d1bda64b0d3338020e0e2d41915f2192d3c25bb31d9188ea0b3c3cadd0ce7af8ac37604b1aa22ed10943728cfe8e9e5e2c92a293e424de708419eb3fc0acbe3e40061f03247fba57fb633dfacc042db2db9d89d6d39d204d28c969fea639c5f50a68b617ab350de246183d1c546460c77c1e40b8435ec03169a7e8d0fc1d97250d8b9b6c5de5523cefe3d4bf395153d9e6e1c3d21f8528b3af28244f8c55a3a6919949d9f95c9bd9e4d3a05362ab0053779a06632c5dbe8d2e745f5bfe4fba1af04fe83e7788073ba831df627c87d467590c0bdcfb7b6c56e133d2810a229dd53ea7264058f6f14f663c7caebb53d6725f58d22cd30c62c9984ee3b6cf0b2214836864599962c7e08e2197e4742729db1c30f3f5f4090bcb585b1b9f0e8275a65dcbf66d496c8e4eb1c78493ff2591e097f37406f8da7f617cf8551e95307e957e61f864237589b0bc469c562c522cc1a36fef73d8b165ace7839ba2316ad5c3fa3c86d3f57383dd1a6f25212d877ad02216c6a57212388965dcf75d6b8bf9df7bdc27fc6fb0a4d32e554482fd1e9cd9788ed56aae42408afab638685f65e04c2726c8037ffa4f86a03b14955d42236367035d40d1fa6465fe7b5ce875e607095d415d5c4aaac7b4fbc181740bbc1a29e62ec33a5895848f3c390215768c213288d361fd6261d30ace8f17601d977e36c4d42150fbfc521b6cf4bdead505f80952368b32ce4f7395189c7cd62fddce4c5cdcae1c49154febc7e742342a8a617478e2a196b2d7218ced60f5e692590b864fb8d2ff7a4447517246497cb957868913698c0e47139d0cfbde386a0d59bfe212dfe81fe68a8b09632c132d22fa0d9db09cf808d1699e86d930cb5f143c11157f39253571d08570ae81e226b5dbedb1c7733a63ec4403493b590ef6599c16317d5f5b14f6b399b9280f33fae8a65a99f44c2827a5a9ee8a07f9a4f0742d74307b125ec8cc8702563efb9f36bab151249eac3b897e84e39a507db71d911f8e4acce51a36282d59702948610ee53b2a3c7f38c4ffd9634bb80f47ad7ad403b4150aa292e7020d198d223f117557385630d8df6f75b4132626e3a9cdd052caec5e028a3fc55a8615a03fcea726ee24087c195fc0563d2ef1aff6a3f9f6ffe817d181f931f6bf5ee1d05d30f6be9ecd9d77776d5525bfeb723adcaec793864908eec30b7aa068d3eeff33165284eacaa4319d2b6aa4ec8fd9b911e7a844f62acf7ed7fefe7f3931eec23698d9283c6eb6ad6c7b5951b939037a2b0de7dd66d463cf21f364af7e1546d08d4c1886f3d549ec7ec8e3d9b790e1dec4760471755a22735ebefd098f3591aceb7a624a0341098ebca164bad421a1e21c7c883c8af7c6a746859751666508975d2255ee70105244596ded183563c4193feeccf36694ac59b3430804db29f527151410563e3f1c95e83057889de1b23e2c74cb52f4b46f9d55bb890ade8da76d9bcbb06d441903e00ea9d98df136bcd95a7e1e57e282263fe188ff191cde76715be0351433258aa0568e15d1abf12582c1b7b902edead70f1ed3662955851881279dd4c7b0552ac36ba23f1c2c5e02ae0becc7842320b3cc42a3be2d9904089c1b69adbd4e3a97b52800e0e4831b533c719654745c71e9be26dbff9cd8d291157040c5fa2fd9240d435d0f4c87a81c4e5dab5ab5f1b2958e21a6b224a8f167561cf4a5c9292c66ec24bcf13f7666084cb15460e155d71f8d690b48645d87d6de2bd0e97d57e9ec4b3a3c9694191ae95a42ffc0e569cdba59efc602143d6dbcc9f1cbe76b289a6ef0cc061b0cef1612c2074192f2049232c73f52384dc95d277ecad3dc8a861f41ac6cdf27f7f8d3e51de975acdf596f79917443a5acd6fbbfd87bc1d39160f956c85ea3bb2a76950714bda7bc4e171918611759cdf1e1d987bfac436764c47b3d69ba94a5d54174af75e1de82ff570277d9836b0ec60beaa578b303243428ecdfb1f971eddf248c623f28c14d3d9462ff16988848042064988cd347d97f722cdd37b39603c1e5dfce032932ecd82f54d48b7acc3b4c7cbcff7d9fa775735c6a6811eaab2b4d3ecda28b1b2679f083268e47f71901db8deeb6d96bb8e959ed68dfb57df07bf9e8346dc721cc04c2e8747144dfb949ce56f15416544cbde00e3c1cd26c1291d12cfd45407e04e77c4bd4500773b81ae8e14983e2f44cf8711fd80a613e015a50e3a276953947f2cfc291bd55fe7f3a0d7da2bc3b4e4c8cb20076d09b6670a860b4454611b5b68023a9ebc01d70e7619d7b6370c163a92804abde34a19bc6200845e691b228a5a56068dbc7b659aa1ccf091bc1042ce907e78a264e12cd52d97785d3c2d432e34472f62844da4396bf45056198240f1cc817fa2be7ec19a6a5931ef97bbc9d4f6887914fd812503fe90872425b7f2a1e8417a60e1fe534c1f541490aa55c6464ea539183ac44d28bf7a363413ee03ff80d0b9c4383d571a6b0c123d0d64713e26cc865475b269aaa50a72c899e97a680495691031f1e6ef2752613e68a3d3d77b754832c1c4dcf53da7acdcd27634bcade894df71e3a64be330c467ae1bb0bfdb346e259629cac60b782176ee9c4df38da48b0e2ba414ed80a842f4544d0dc41dd13cc20ce1ddf61c3cdbb5fe75d1c49aed5f5d567e81fc6746591b9256d7a7705a13019cb3e95d826c84ac261b0429f24846de611129868dd7b0a73f8a160e9347fa6f5080a5bbc361c402b747f734ba04c77c9be4bb857cec325504f7622e3cc524435827ee75c91f0e7626705559ec405c7920e48d49ef5b9c98d286643cbc4c7631983b8ad0b7ac777327ae3b33f370e63b02340423987538a5a44e0011c907f7be8b2ebe60043078ca8068ff99671a321475e53aab52012ba0be8155ebea834d1e37eafc56da75329abea066aadb4f8f4e157ff0d7616838c7f2b281641ba8785075833695e53c7bfad1510209765677804faf4d483628085f49d80a099e493ec115f9835660d7f444eb4b1773be80c13ae7aec025beb301f3c449a9245f6b7ffbfdf1e6d5de41d95b7f161fdea8a813e75ec072583dd224d78cfaa590d115911595cd237822cbe45d37019e68ddaa7f417046e18687ac48a6967610cb882bf6b86fb480356d30d76de8e5d85b2f1c82ee9c58154dfdc0c34c73f3cf6f9f1e3902f8b3fee0527d8359fa92644c728c1a5685c20b51b53e9ae2d9baa9f759e6c5c9fa20deccfb9c288d21eb31659ffa699912d00ef9252dc1941d8070534acca27b9b59fb26b8520e3f14e759cea2e072f787737442aac6890e3adf8a0e6cc666f9ea1edc4241621bdec98e3f3e9dfd51a897e415e95b700613b90790ddb034ac85784e26ffa4de7f04d0abc8088c8cbe1845abcaaf3f61db4d7e56fed748d7352f7dab3456fe25a98d52def77d8adda6bf183be932aade06577d7f95f16dd990c1104ea63545f734a93b392f6a070002167be665bdbe8e497363fadf1bbb3727c156390296886e0c7e65dfe20d1745d61a3c94832709f35b2e70990481a980289b9e03671e6c3a54172db1e4c03e229be2ff5ac10f592940569a66830ba5777c1e040ad1d13180e89a5e060d4d9ce062bb1c0bf3496aec1690eb2641b36b674da497961acf1030fc93a6f8d9eede1f922a3bb877eb2a9b2a35010a82ddf1ea686aba028d096e2138c161dc57fd75e58b9ac9d9c20eca2201721c0c2adbe663e53fdb192713f33906f3ab6962ef209037a510b28fe2f233c538afe94c41c7fcfef6e942e040e8b985d6367ecf4044650182b686bc9990746bd7ff4976a5f6a014f3e45b9f750615a4c0051b6c1312f6cfdf60f4a03762f02db40988d28c7320acc944e860d8133ce5a3e233c6dda52118dbc01a652fa507556a230d0637b0d983502969d8252dad645e67fd60062ccc9945382914a6e50daf44c6592af9b36df4b0f7e7492247ab55d7a02cd52fddaa9d88b2901c65a2989ed6681ba55465cdd3b6f8cd9e24ffc08aa6a3787db161bfd45164db338ae31a82a0514ffcf9ad7584e69eec88f859c0a659ac465228c1647817b2b52703737260b6d143275ef577ddcc0e235269f398c641f05b2b2fc80f3993518f25f615ff07e8b32faaa9e2a6acb5fb78bb783ee967c462df8ad1ef5488a91afa035d68ca25890e477f4d2cd33d7860e5dafa111488cfa39ae4fb10a9db0cdb9394100be0476cd8d6b7b93c6d6f6bd76b7142cd0fb67acb2e3d2586a22507b316077f69db3fd8a33fd81fd62d066e0fdc5c0cf7326dbe64cc74d1d4f1df548fb9e11d3b173d8a3d8dafa7c58a8f62ee4d52a24a1756738d7acd8bf8d55d16e3a508a30f9f68786f84bb99e01537a5450ab2f0f4a82adb3d75a2017b1fe5fade4518003cd11741a2ffe8bb7c2bdf8900fff703f7bde756ae1d0ae15c08705ead565e64f60b276ce131c599e3d110cc86b315edec242b6fe281aaff63a958de8ea327954824b23fd471751555522a75005196b6834d251f087225dc9acbb661a5906d0c54a295cd61197d10c44c42a2158957788fd375f732a88c4db578082af163b5bd173c12c8d9ae54a81de44871baa8ced1a5139704cc5d158f56ed3984c418b320fbdd5b1110fa0eaa9844706a7d50291f905b4f36716faf2622c50afb57dcb1a104f667566775158debbc8a2ad040efef1b2125d5cf3d1f85c89be5dabb70c076867ed1d1553492537a246a9a51a271124461118ba863c030ce0305dd3ce05b01e33d550f69cd31234c0d2e3d6e9a4cc587f580a7a37ed5a69acfd76eef8536c958cd6007cdd36a0b6e237ffc7da5c54423178310471857648b5313f69e2b9348ffcf91f1d8f8a0b1e4a637a94d03b9dd0cdf8f72bc9f4586a62a20270bf14ad74670d0f905c7f61438b70bb41171fd08b8a8c1a29e7aa1d9a434f19fcfe0d523ca34bb50d9875b22137f69802bee2e4122397f4ffdbbb0c300606afaa09e0f05277128ba6b9f1b52a3c9c1f6614441cac8fbdba09ea76dc20184e4bb84a42c93d8bc9d2d066be212616b74eebd78548b67abb7049496bd94d1bfdf64cd65223c985fa219678c148644e4daa467918adaa8ff8afbc2623ad2dc5c88a000b2f05ca636498cd99bf50482662d1ef9237c10711f219951e508d8b30dc1733a69300d204f98dd9656cc560d04c3c2e4799f446a56c545733eae48c5f26e64d8f258e214dbf0101cf6e2ae1b87de8b4220f6bf28fa2ef0403a8893d178d648010bf6141af2f623e0d2ebbdf1f5e6ceed99d97911e90aee7f48a427145042616f31a121b94c46f057ba40a9d35e28a7ad9cbd6388c83f61e059139dda32b081bb8a8182d6e400c83cd226667f215aebec843e4ddb7fe8b556283ae2a678193bd0ca30fbaf9250a4dbcb96dde7d5b0e29395988bc64773b11afc3ff03d0a0c3e94f84cf87d5fb6453c2aae8b4ca48f71aaaf154f4be365310a1a396e19d373e2c39973e98c55696a71f6e1d8daab551044da3b60ef6625d81a15110f1190368c279337530e4ad21bcfb3eff9720b8fb2b8558ccae9f7ad404ad58abca0da4fb99366cad29814570797844c3de89db1821e3faf2704fadca8490a48293b89ec8a1e7acc5d8c5aba71543e58fda7ea38e9ca329b417790014b6e47b7d83fbc229789f199c2add4c21ed3201d6ad5100cab4b6e467e7aadbe46b4a449364cb165093652360eb6bcd3b746730a1e63cb6373dd587f5db34c184310870c4b0a179c7cbb1a6031ae924138258935318010b9c851fb98e3d2a75b6113707173b785430aedb9c89e1399a2e4bcefdd2b60e5afddfcc755d899aaeb7623686fa6851dd5dc5969cfdd1526cacbddee7a3d1f931fbe9d09f7d55795153796a675b0f26941662f6678b5198ad778e1adb98beb376a497e2418ff833f95e1b4259065b617fca31ba3fb4fbfe52c39ae6fa2002ec739850282a4a353301ba449c4c3c8979c5e0c073f351bdc4fd62dfb173c09f18b537063bd07d0365024461ea1bf8bd4e14f6d7f671f033bbea84523ac55f629f649a3dcbebcb06fe812038784f06203abb3b1e955e1f0f19e06061c1f7633d41ef69ff79e1067462eeb286eb15fe905946813e4d2cba7212062f0323342a793efc9f1bd50230ba0d332cda97cd9134fd87bae2b44d97f4877628f05ecab438f4ac0ec72de0a149dc218819768e6ec7736bcefb20489cd85381e3773b2eefea5200c978ba2b1923d31da85d315d4e8f3fa0864aa26f9e189e28e71cba129ca282380d81d44910ce57f73645d1fce62aabf3466005b0a5ec282872db8e32d4d0fb73062c956318af3eed7443aefe31871bec2b33eff5c2558bd65b14f54a024422cbe5de87ab62ad76c787f1561132b5320dcfb8223c740ef8d3f328e4ebb23f47ae7261703e5d79bfb1f6afd373af117ceef89ee2aeb1f8d35def1756df038fdc8b22e98702a904d070ff9f134ad623ff90de63a7eae4336c9d43957cec6da5b1791e58631b98dae43b501d2b02a22e0231df786c83e7fd598fb792ec5a0234b81eea4f2612364700910126afb056802722e2730706ad089145fed2e7dfe07dcc0d1b8403d0d66a294f17f60b20d7d49d48bb7632683c8d3afd46f723ec3d9676cd45831b4549144df6cd9e9e1faaa913049ab9dc5fcc633e417cf89c116f3f471c6304b95deb480d21955bf6a7f332c2b87fb9611ab45f31ee903f7c91b9ce1e9f78cdb70e9b4bd45e2cbd6f2e074ca774d3aa710d1f3c41eb935b1cccc9aeb7bd88b8fe61ab2f61dd4d6640d57f97ad038a8ce384883e8420fe5b73cdad88bbf37f53f57f6ea43213639e9d2004eadb7226c41b4ae769376455914e1f3ae9b848d3c384be8c57afa2afdfcb89b203702984644ae474198449162bdfda5584881d0fc36c94f61cdf9d1d332024a2115cb6f65d05c7bbff69fd7ce65d04b5fb98501470b6cf151a936a84ff8e0fb4c0d1bd9ce5125d324f25328c27ecaf6cfc6492fa615d890a5f1ac55325dc65fb780fe46f92d493c7a124b45b0478340946cbdd1f2ae073f0562764d72c4817df9e7c9abadc82437e6ac2c0878699708fa92ecf433f9ed71696b29dbf9286c03b2e4008815f208b87679124783db3921763467dc6ca580c7143efe9d8030d199f37f20f9d059178fddd34a9eb33c84913124c3374d454ed6c8ead8255cc6f3957e6e4bae3a3e62db2b668ae7d8bc72a04c5a163993e2a1ed65c31d9251fd20cadc162c26b9609d7a730b019e4b1836abd41d645d28d41012e4f19b1614c87f4a38eacf81619eb8f3ac3c88d249fbcae49b14c214926ff8fc773542055b23784b0777186e8f0acc3d7dc23e004e255b0bd24c63e736469fcda0250537e4c59f825d8611dcaf47b9e69ebf4a2803b1dcfa777b85292ce27a83307333b3e84e218c0314b0748d01ef88e01f97bb7facb42ed62c5a00a5b3d526b9f9bd2d40592a6b3db0bc6351db785fd978377d9e4140cddfcae194ca4a5577feba46cf193013acfd30aa94a1ba3e671e44547f81f145c14038d63ed31dd2d3f79d0f7f486b4b2726b8b5b08813e15f9ef00c2f52a5c3bf57158b4e4b18bcacbabab9e615e1b4eea2a1556e1d65f3b4251672c671509ce9fc87d68e3e0c08e9fd4050681195e0f9e78f1202a94adef92a7fbdb4f25fa77ccb0b69f693106e892e8edf6ddfd9ddee1c296d501773917e2a273c7791baab411b6bf2f183d49e3aae46e8053865ad2c9a9103daa06a900410a65a34e5caeb0c6dc94a639222616c1342a0151186d520a13d81e2d346f2626fe98efefadbaf39514883a2d5f14ccdc1b550269a6f0c1e512afc525a2ce99e9df1e1f55312852d014c644249334f819c11642e6d5b25beb208a3dd49afc21a45264e144cc7b122a37c7c89b5aeb03c697bf92f80b1ca7c463c42d01354e68364973d0c6b8c0fa335b616467917f46bb08cc28ea7e5103320af48787da7abea9953beeb2273a3159b5076c7de68a7b1e9454225586156e0199c08ce3fb34c025a75753d6336a273b6f1b642e33edebd64a8d827f07a79cd34f52be6dd9f17c01fcb06a1d1ea8f757fc6988d1f30d01c5fe1eb7cbcb1f8577cf09568597930b8cae1b28fe7bf0d9400a9b812bf86f4a78942d7d0cdfd9fbf76911dd6999b0910ec4e36d43acddd9840037b65cd19614aeb4aab03bc7ead808320018818e8ba785a0228e21b465f857bcc7edffae5c1c572623c74de434448bea30492f657401dbe52b9aeff919c78f5d82a3a001856d8fe40ba51abe6a3e8ae147bc3b20f9309a72e2b6ee84ad5b9977da7502afb5b569db54b53b0ccc4c14c427f1e023a3565f137510e24f8215242fff720a178f362aee2474206e587fd6ef666019ef8cfeaa4ad53009bc287d7703ff88b8915fd7f7a450dce01377783ed1aaa48ac4ea44b01b5c5bb795a23072972fd1d2f7c823479fb45e47079ae60adddf90c658742173b87ea8bbd9ec319d629472d06e4fcbb196a0e9e33f1f703a52a204f274090ce8a81e030463e03a936b0b4e98c1e2ca7c603c3345fdccfe599aba078acaafeee863957ca6fd23a3aa5aaec276e71147cb26737506de0fca30e06ef039b95f82d94526f1c0679d527d14f2f542cdcf47be523746db336ed1ee748e5fdc3ba86b232651b33cb851102cdc28977ca2fd7e361354a21e3fe91ad691468d178019d417d6009af4a21baaf76e2852aa48494ad5150457482500c759620e32e8592a4908acfb43a6ffb4dcaf8fbe96d259c790f0fddce52967036ccd3d46b32482e3902904533527edb1d2efb1144a46dd709ba401b3aed1af4f60ed435aa2f42e390c8351a3a97812b80ab2350402a9029254bfced38902f3eb4e22270a2535dfc559cb3f6d569be2332ccb27272c8a6a9c4e351c5c10311901ba16d50c203714cde41f6784f944e82b54845744f8c71455c25ed92a327c326f6892973a03df71a5badf92092305597fa31de1372bb76b88b68712442d5526ece9f4d6da27930a670e76dcf2dc5091ff8b24159361eb4dce742cc697d6880cb2ff8b134ee13904379ba505979876427937708788cb0bedea535911cda23191e09fcd3e93c01c1f0024e2b3e09857a6b0e5312fafbe34a74e151053924a86540e59b9c62c8bf61216c781bde0d9425b143ba260700ffa7c3c27363d0db98bf44405b9d10ec625a656b90e33e53645898ba62b3c0bb30ae8c565f1f9951d5eea2213ad4f74534ebcb87d0c0d6bb854c41ad71d7ed4c50b0f30baaeb8516d2d617628fc9e7758dce7435a56c18d9ca0899d966bcbbd4e469db78f8221a17b9ed278d0c049f589bb62608f5a2e2a422d76e67a66975b4722c19f358a0c5305a1e6e7cd660cac08cbbdfca6929429a9ec060934dba7be06750ea9d7869dbd6452f95dabd1dcdd28b6133e0373887de40a14b8a11887f81e206f571968bfa19d4b91e6ebf6f153ecaaa86593d69f0ac3301f796aa4614c55f163cbd4659ec8868a1f7e95baad0fda6e61dfb1328a4db8211ec406acf83046ed91de386837916254f25d1e381466796c59a0ac2fb5bd310cc1beed205ce6dc07ba836300c61272ebc1279e8510fdbb1546a4f41f28d8523c51eca55d05c5184943154db09c5227fb6b9dd52991682817d4f63a616f82597e7a91887aefd68362abf9af2884e1223489062a2f9b9eaa96fe816019255eef7a0baa387b0ee47598b813018d7cb5557d33004c74414c1033806ab08cffb80a06c25fb5384d7e3e78f53b6bf5235f2d79b9866b2290405d5ab15bcac870d6c14496bc50957ff1aba4de283491c301cadf76718d3463847ee35ed0949c8bbee4529ab9c08c5cf40b9e42563a04a4f7c0cc8ef873dec50e533f76c91027dcbea60abc38f3480a150c6253deb5eb33a28e8408eddd27c29a4fb729a3c79be88e9d0581ddad42058b42348034c92f3e4e4ac385b2d1c1fdc69ecbf987c4236ab9c21f9570cc9c448d45b53c376c5e84661bb2a2d8538c0747bbe48db1fb9e72d83b08b96648145a02884ce083c60ef9edd77bb0477933333984e75f77e41dbeb8efd1e92a34743641ee61294b72811432abacc7e6196a424c4dcb67f62a64103c4f0f65e782d8bbc42174327e887514fd24ee3e016fd88fd638e4dc4b06afc2630ae50df8240279a20f2a8726fc3dde6555f602f2931f3e91a6b3b496a5ed3ca85366d9b740882495e02352b69c81b45fedab61ca11ea41d317d96cdadbfca9bced90fce883b58bf40deff384c255c5f72afd131aa94544bcbd00669bcfaa2135f1440fd133c197a7cd2f69055a5a3147053530264ed03e40a1e1cafc6c915b024b485cac43d8882711025eea5cb85354cbab7d7ed62efffd9cc0f75eacb58732c17dc00765ff9128bfb21c8aefb37374b17cec11213e8fd7b0ca3da3ef432e1291228d59b261e28a4d4b99d92e3997b63a3b62516d6e2cbbc86013a9abe15c789b2a749d8f59c5b1c5d7529f042fb24189d56a83f37930a2e497bac90c0d409211597bc926230f4550151685acfbf28bbd6a678ce8bd2fb13b22f6e4cff46101490218ec685e151910aef367300659dc543768d3f1dd47b152cda9f53559f3319897cb65fa31ee3e3d9292e64c550512f71255167ec76b7e6426bb8c97a20c9a323dd3128c26ad2531b50e9c856979349835f054e16c55c425a4a871fbbe70c26d2119c9c8117694e193ad3bcb9146f415e67a8d8da157bfd5a306a61dbfd01c7406ee0b5b3a480ba8e3bf50b34d4b13c3a2d0f32430a7c0ac25a7e930971c34a12af5b52f91e6b945d3b1a2a9dd08cf158ce7db132e6dca2371869cac1e4eaf7e8e960a46ff7b8a29e926fd1901944af18ef44ca191fec84f7691969e2dc398f604468fe4a21d645c07d34ada367aeadf540e2a981e6fc252a1e6b0896debeaf25101d8e2a572a78ea4fa69b231d12e37edffbfc92871c5000ffbb1f3d1fc1009f4ac4ab3df49c1210e78e0d22f9d1c2becb11e3bd6917e195c5ff9544714fa34d41a169060ce756acf7b7e7b72a522a58466f0c3c3c593d7abceab609cfe09a011c9b3c33521d85b4208c693d3d8d68dc79847c95dae95328975af1a2ffa7fcdfb2ff4b771ab586d286f46fcf866c6ee875ab97359c6b8bc3e2048926932539e9b60d76311392c488db39d17644fff9517d63fc5a7b0ce5c0d6af99214c1efb9b83b5ee323e06f0b9cbd828200fe9e155d36684fd1cf5dd07be8ceeca19477c5664bf409857d49316a000bb1e0413e19193f9dadae117b221398d76be938c53d7a728906d114b69b66df9daa8f91a4cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
