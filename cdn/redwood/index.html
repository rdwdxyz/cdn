<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"827aeb84f7720f30548b473e9aeab6597a958a593a878fa3037c660307204b3004bee1cf5608480eb4410d2728c72fb5d6f10eacf71e2e963b89aeaba38f1407ebb1229b58f919ed4ef966a9cc33f6a3b5786ac819d365197a9c7f42a22d97175fb327469ecd1e527c93d3f68707ac86235d3d66227a92e917c311162097c333a8ffb621bcba0575e8c1e5ed1456ce2c78b27ec276bfb3d5bad7d0cb09f343363e2f4b3a534eeb32d3c4113314d8d5f4eed3b286dfc6fb92e6a9f061f50bec705467cdf0738b5a9efb118bd14522a6c5b3eaa471933edd4d5a33f7752862468316cc1b657fb32ec46238bc88cb0ecbc6b64b85ba9abf40192e4129caedbdfe0d088e5bdcc1ff24011f6cc73c43380c3da8b0aa9d8efaf468c60a242a62fdcbf1abe3896cd7f0b9e03e697d6b9125b2cb12e9ec2d7203fa5a647cb678b4427ef8f040f938fd8f1f252b44b55fdb1e2a05b30ab5c3ee875a373bda6a1f878b158136b2801850f581483e1fdbd5683f8170cc51d9d3956925c2126b7605368e4c2fb2ab19ba14283ec8767a481cf83fbdf5322796581229c0297d615971ea567ea7f4aa266b587e489fed7f0cf91942e11fa60ddcb1e91de95a5781cf8d6ce6ab955daf68a81faa543ae1c0b9c7018ca1ca1c4ef0b24b583baa22afb3ad444dde46914c3df45980e0214378d550e53f9f25ccde7cb141e0068bada5c0edcfb6645912fb1e04904f47e1511244d1e146167787c38f114fc107fdf74d62293e9469795e63b81ade3748bc2d2da78f5b8e19db7767ce29aed7d632e240985c0ae5d91a0c8d54e87a0b55314d1bf10c52b474c5b23704a0213fcd29fcc2470454033518f6fcd207a09088c00a8496fb5cca1f8da3bb009cba756195ff29441326f049f9ad7050349265c7ef496289bdc79c977d72f62b03a6e514cbb96c881b438445fc0e24eea16fba6e82a03ae9ffb304693f205ac5eec8ea34a086ae5ca5b4a42d6b2f8baa0f55a217d847e13ae0d857dc48bac2c3f4df273a7726db388942f1887713966e604e2c525b82095c6c26f2da4e97bbd704f575aa635a7b2214f1981ed776908e05a476e72ae996deed0062b55540bdc40992fdce488b5fd9cc17a43370c6dd29c880f3370c0bb191ba3b8879bebf7ba10fc4e253bd87b1de6ba87ac5ee8cf7e2fd022bd42f21cdeb7fc80f68336b103d1538687cb283c24a577c82a63ec3638851e8690bc9dd5d736ae896deee47e83a3ec795692bec98c08e7bb9f3a9e1714b8cc0789188274b3c83cdd1a82e9c2ede1bc43b71f3cce46af8c8fa63f1df513e9ac180b02ff94d0f86d9c9f80774daab8c568ada8cf50e2fbae5eed9624bd7f67767cd33bafa8cea06b25caf8de10cc3174ca7f31689350a338f5e3e3e79ccd1936062fe95edb6b5ff4f48ee02f2efdf0cf58d69cf405a0cf2037a9be99b67636701a68b787fd23b281d6ca65e778277fba411715aab1c05be4a50ef77e86d45d7f1e42c7fdfaf097150544da5cdf9f0fd24d2455a35723662c51ae09c3f56f04a1c8d8b89697f434c40d23808dd73d55570dfdb301aa4d98a6ba31358479d2d2ba965f5039d089c0688979757e5f5b8886bab317f5791514c4de3bfccfdfdbfa8d1fc6aa8a6975d3b49643cb0f38512373161a6301342d4d09d58f25e5aacf34ede08e7d8372d32502ee53bdadf0a572a88ab9f3f189b6db350710373374e8d0c18e2f209fe2750ad603a20779ffa9c6e26c981872f98c51d28f6f98c5abf921f5ad9940a9756d4940c494a952873ca2043d7317f78dead94ed32237839e1938fb76cac912b78b2a7e9fd21c123955e255f692e50bc646186fe55e2db4d2b272c5ed187818a540cf1664fb03979fcea5215eb13164eb3f2729ffabe6a8171217353ce99893c563832cd5c2c39d657bd81cc51f878dfc924a1948f621ff894384e46348282cd3e44fcc9d2495b6fbebc2eaee2445f89eade495a64c63466cc09cffe7248522aa6895913f887d98dd169e8aa8b36340282d541bea93ac509a4ed946f077486a0dc76cff161f9041960b84c5324572efda644b03163f193d22626aec5f2e95809802126c0c394999ce5ce7c2efc09ce1106f25710c08c95fa3c77b788ee2366e94a1f17fb694fff4c96eca043eedaea7d0f232e7461a6fd51698124415893060aca80311f6ba931820a1bf5f450b04ee034ca1e673412c02aed1c7764ba5efe780b8c66ea813e721cccadd02e43470c2a2f437a9009a3e691d45939f1dacb952c5b26c3a043da3011d65b4756ee2e5fe49d118a8aa6c759fe56c40fdb95a53b792d7d164aeb106b779dbca98c9e7b1bfff7966907d5bafab98dad3ad218322569930247ac754f9c35d712ed59a40ef0f5e474057198092969da2922093e1d72572b88155b02753bed1939135e968ad3775bb4ae5c4856efdf5db1606736fcd92c2fde274df32a14801ebb5b079e44f6061e1c451cb63fb25c3ae2d75fac6c13969ff8f9d3fc07508f409c76c0de3071853876ee1fd05b63796da3ed96489933491f05dbdaaa5ed2977bbe19d7a14594d5e36f686902a4ff75e3ace67c9c9ff667d0e07bc75cb923583be971c3435664a77164b59e553bb68180d950a9e8b2022ec2dc2202d7f617ed1de9659b4acdfff8ed877a6021a36a41f0f50c92d9cd0913bbcf715d479112217c7fe0936e44838754c795769ecd962099ab4d762503b24fd8aced4ab70d08b3deae2c0a06c68adbf78fd7f2ac1386d76f301639e53eeffe3678752b0b2c0351d3afd5b5509f6a68664e9bd3701d6b721529dd14627f526c4501d36e2d43f29c6d43f6b464028ec84c6729bb7b0b5c3fe055c9f2355df565e2cb6ff130cdc4ecf002affcc59f263824f77590e99bc8a5885c76db9fc678c4d311a3f13568795dc810d90870e41a043e0cada21df76fff6f815d8fcdea9b24cc1e13a01c41a9a72a005012bbebe83a20ac5c668dff6806a42aa33714f2567967194d69cbc6236cfde48f7a5bc10f40521cac7987efd9b3a7eee362c46e507e067c401b2b0ab506a790f86097f1b3bca0c3c62881ea75863470c5708d1bfd4c08eea409d21ed484da63c49666dc9e0bc1a6fa12af13bdd0fdc726c5aba5a37822a8dffb42eb5df6db56e26b81b5ad13f06d47b1e3298c2e122342740c446a98edb816aa14eedc66002f640bf4011ca41b1de0a15cf9975f19404ee12035c8407037262754db4523efaab056e984a26152ad5d14c4a25c5ee5f94012a88a159b2d6ffaca101639a0550665bc9f8b72458d6b9ab6a69090565124cb236a58dcb9c392694f7e1117ed10e522a824cc154395f4e4450fbd40e2fe4130c38dce574a2c5e1bc2c0a155e5d4641ac044bb2fdd9e6fd3f8b63239021b6ae1176263599e5856ac1bee8cf0f3d4cbf46529037bb944898545659cfac3d265541be196b44cd31bc2877960e43cfc6dffb3d4db1a9eba1d7e70c122ddfbb2ab1c3fcd1ad3920706e600fd60e7e85672114708b08e753253eee83144066ec6ce549514756c5e582d5f436fb644983609a65957e3095a622435a31e666e0abb555be8ad413a097f530a6394a089be9ce25baf1622a6da6b533e394c1245b951059aa99ee192723e77243fccc7bcf64fbf5b3804f0501cea3f31b4c9ec53a93a7a75d0c70df33353ab247a4e18e3d337a82f565fd070b315fe415dd808383b69ba34bc779e97e18e31c9ee6292ac12cef1e24ca95a6d66231f9cc2ff43f0429bf3826237727da438c2c173bad38b0b0c46ed8c4de47548b3ff2ad78010e08002b037347d5a44dc9303cabdfa31b53145f01906d0661fe96f07d3845fcde0f2da6efc3d19c629834199430238ba63c3b4694cba0d3bb083ddd85c10533e18b9951aa7ba9f0b8c9f6772cdbe3887af48c620f76780e072cea3bee1523c7c37b3289f825463ad9c4cf938fcfbd2e8964cce25be2be1512ee11bf9cb43177128caa7cd0324ec498d23ee9e8a899d49cc48790339f2f3530858fd5a50789205b7b0646d722da7c6ceab5fb750f864b8ada6153ab249c92e2bc2a43a055f92630cee9786887997617bde2d82a85b67cae719f2175c67a638bf24af2eab6b076a24c2ef4529189281e8a536e104260d66ddab23dfbcfbe8e125e583ca56e9847c39bff941c946bae4376b74a4f1cd9b88e8f816e7d96e5e25608e21263d22b4d8530053131f53e7b89eb64f8ba6f7cb30bb79207a3cd49548be4fe9ecb010428982b7f0a951885e49607eea89cd8c110b12c843e79d15515a1d6d83a59e9056f0301e8049e8d357a725607c2bfed9453c8da2a6f691b5f19c95415c62dfadad52d9bbbdd436f4cc8f4715f61c7b58d466aa468b492ddefb431b62b05e760e266efe6d91f67fdef99127c7ab6b6d9473f2880cb6e4d901512918232f0e14ccec2f661340db093cf7569b23410c8f687fed5c2a1aad9173d0df2fb82e3961a715d7eed1c2b2e9391a368d24d4a5d3cc2d18e2dd47e909291dbb48f4e4d087624cdd987344c9c0077062ec7be496ee23dcd7d72327921a8535851aa94e306cb72daf6bd39c238b3cbecd07890daa0660a5262b08b32b832ece79e0d2798ae6c7513327a53f1abe648925c9ee21658e03503f284eff4bab48797caa1f33f9f666f30181dc43f3d011de1f4feac09ebbf8f1937f99160324b17b6825eea6983115c892e301822d50c948a1b68ecf56b9a4a935ed79be255605bc45255cdcee86479e45defffbc846294feb0bf452cbcbff4d9f163ec72d6a03581546ca4b8098337059b73dc07b313bb1d977e8e55cf06a65dae5d16fdd8d39e9be10da9e2498b4e09377a695773dcc8ef9a4c6df9ef9eded576415fba73651fbfa067f3ee598753a16d44fc1c87eab7058dfbbcc0d6842b0f459cf4c9c4d7f0b66a7a834ce5a6428ee9567f2ab6c96b618121bde38aa047715f96d633333e159eec4d581fea911cc01dc342b4ed1e26b9979da212e75bd53e96283a15c74019f72fde5f2bd19bcd083ede1b1d30dcc21662f68bbf592951b4355244438943f003d2f2be3f02bbdb8cd63e2d76baea42287cbb4dcac03c4500a1ad373b3acb5668d7d597bf0a81017ff5295eb831725a16233dc4bafb583b03a186b6eb53563035915c3eb43952c7e892323685dcdac4a4607beaabd3333b97481acb5363dc511c5c32e2f5ea670b84119603adac61f45f217065e653b557d351e70c5dd93e63409d35b9979c1689beaa0181619ecaf2e6ba81df25f2f7815a8828abfc560bd6678fe1f103f71568b314f767200321796ca8084ca7f8b703aabb1665c0e180c61678d97e1e9a49fff902154c986fc492b16a0b984c47291bee0a0e3aef6c310e2ca67fcc8323385cd890d53ab5b8b97a73569490d88afa18122f531eec6051c4a1e85cdc02ee25d4f3598c2c59854d40cb8e17f73cc79bda6b72169d7b5413d608ecf2063faeb7cdf74aad3cf9b7292f31827ddb062350ac6341a9623608a47a620f9388603dc8598a259bc166dab2392bfcc25f5f1013d93fe01f2169d3110d2c2444ddadec21d0733e23af053a6ac223c12e68649be38ca948b1b6b17e3d037c07586b7b4482171851005c835c1151d224970b6507d3bf00827107dcbf6ebe529d2dcc6d294da081c2b3e1e8b52921be12a29bb3902d9d1fdb8f753d5a9d0799c6b1c007fcc2f80aa2e99f2f1c73fccaf1a590434ef177f92886267640f4ed0d10bac1dc6ceb049729a5f786711f7835d40f719699adb88e66f6eabc5bff7a1c79c9677a7151a18efb5ebfafb02ef6bf14d8a9188a14b879eb532f32889c18fea99c231956f88e939c2514cdd259446aa047408ffcb7305673b7749b6051d3e918bea0395478b8c1ce4ca0c808dc11e0ca447c23bf4a6bde5e0dd030436d3c490f4361a790678005a846028e01b0c83bbce19a8f50f8445a80babf84c9c5e3a2e05dc9ffef83d61fabd6cb5e7bd0b65a2f21d3eac007351664b23ed1f4cbd1c31c70519cfa433ff8ddd8454aeba2b0bdf5ec3eba7ea4e86f011ac123204a216da235c7a64587145d969dafc761f77c4733dd555b2a20bd76edddff095204fb642722dbe411251f116379ab3a02ed8a06c643717e8ae295c2a5bf29f9cee0ce8bc2e5a8ad8a52d1ada629bcf2e8eeedd8864a4092aeae18ffd33d00998d62f13dfef9da5130603885ed3aac4488af06e12f8f38a0cbcb6e101213be39878846e1459daf51c8c503a75437d31a438e4f65efb1a3207b10352461ce981f96f912f0d0eb54e94630ac3f7e86060088eca94134a066adb84c4b6f895b01ef7935183c2313952f38a65adcfaebbd190de57094adfa22b5430ba162a5e7f4888dd51acb35bee0bad62f41bf8e38b726c489d3d13807dc2b7f8641d7d163771bb2a000d0557a95de977568e8297ce19c6d82bb016d9cee00238deaf03736327483055a02e86c8cfafe6093deed1f74679497db192d16ee29b4bb73c892fef28fdbccb7305cb9c54a6dada33814fe7289a2b08e9f8c374ad705f2c24490d966603292570445578346f6621a70bface42a6f1dbb28b42eb466da72d3c7948c8203bfa9e4b16f7a1268f6934dade42350715f2f8b59cc2ed644861e9e2182a80200a49eb5b0726fafbf2e2fc3012f2959ad076b41bbda5e36e343d2a265c6baefcaaf0c16634ffd563e41ec7ccadab803a913809cfb5dfc0dcaf6c61867c8b9a8b1eb573200bd801cb6b02d42a4395e40421e649712e13d8b868d14b14f8c520685a62df3dca414f98f03810599658c9bf1dcf0493516629283d9e208099f3cc8a8fbc479ad368f868b9ed431e4c28c624a16eb4cbd392c2456f3fa760e03915196c5623dd3d7169d6eaa655ad7827c4a5628c90891ec80a7edfc55aabd1d9f82ee3560bd24563039583a22a7ca9fe21af7785d9916b8b6ca2b79be6f4b1660466b3f50d82d07e23b59de9ba7eb105fbdb18a528badd7f4927b12f833a5113b3c880002c509dca756fa4056c50423f110fe278d6025d7fc63dd7464402af2cee71c645659a030311fd85830622bbd10980363c7279f8f2f40440bbec852bdf19d8231fea96e7d15f688c3efb8f3ae04c1d7d9088107f1b607e80e4a3004c52bff555d4cbbdefffd2f6daa79e758db93128e1c4526fe6d76a94813f9b8b2855513e2c12f0418241de6a3a162f13a5f85960518685c73a10b253e283d0e4f71c314a37b3fac9e07f8641cb6995b4c83c5501ed6a545727089b0de66e1278d0a41c98ef9912539243207056f3df871daaed48459c17b11d711dee5a0d1f1aa31bb7564c3d76d03c723e0d7af40155c38865cd1ac2f149e88692bc129fcef134856550dbf818d0fb85474e04748c73fadf87839ff8d7aa1c7677974e0cd56f832d93edd75abd5f71644403c36cbde17e6d732960a1472f79d1be08f65b99eea88dee089d0fa2228cb6a1d1749534f6731a838e92a4feacccd31c973c6b2e4160e474c5fde501add13a495784447052eaaf1f05442b095d5b0fb33cc2e985a26a8df2edfdb979922a33d42c8ebbfa3b4b2cebf91b4de327d2f737147f3da449d760459d70f2c3f913a90ae2fd0e1bab28d924193abe7b340a5706a4561f8f1d96afa0de5d4ee1d133b3ba709fc688136514c1495c7a0dd4a57ef5aad325b358804af601bf5ecf81917d03666c9673d888ced6b2849d0ddb2ab4ff79c52219de31cd8bcdff2a899ee55d0dd96ea709ec91b47a217b134b692541a9d379a0e2d66419d8e20613b3a323773eeec3b857c75b7cd3fc78103028c857faaf1bbe057cd3cbb570703b1359d56436d29adbdf00e9bf0817bff5c0cc686727f76bdda23cbaa95537bd5a55754f4d1447a5fd2157e4d6dc5072ef2b9aed3cf12dffec2ad054e329ddb5632d7fc72321e7a81c662463cd1ae06277387626351480e2959daaec883402ef51f9bc1f28049e0bfaf88dfd69800164904839f99d56817e90a3c93c06ddbd36258e81a10f41d0419565ce1ffab2d0e8083bf336a291295220b5442f0e013dc508e6962a58bbf97294515ebaa1964241d19ab61cafb35be66be9d76ecea0a5261036c167be323e125b9351ec78f8809b15860cdc10d37fcba5651a3444a6b26f285f5ffd423734679447c101377276cde74fa88f3aa3ccb93746100730f3e850b2e6b4c51a8bdc2e627cfea5991f9ab827580a35fe5b12a307648b29d5ed55f13f8574c29aa3d13f6af6126a623f663609acb1d28670610345b1f0476316663f82fc9cba1b617bdfe09fe199dc5dae4e50ce1f62dece79fbf3a0f7ccdbd5ce54ea0ef9af7eb998088d6177036f9aa8f0a9d0f276eb1073b550b201bcab7d1444292f7cbfd4bda416979d33f506ec803e5c131a14c1b0352fa09a30d83e9410f40c67e9a443999db5f131faaf3dcf98d5e91b31cde4062aed619d968e2abb6695a217854e07b8c683b2dd1f1e53680777952549323dd46ced1067b50e37c3643f993c31110afb2adc085844434c2911af4baa6b0e902e68089c8faa7491b82792977b4b7b9f89fde01b86b262450cf61c2de0a45de7ea17ad1329416d4f0aedec42d78b944d7a6d811fe0189a402312d8d1e7f84e9030f5a5fbe305b72837a79d2aee27b0fb62d68438ccd689241a82e8e57007adca6434fa063b436017257eec78c42f20d37b9927f91ab835a9285efed71ff944b7eecff10fcadb6c31d9184ddb98dde3f88f6748217757df9109e9790110d5d8ba73906916528b88ee4c56c56c8dd5531235a5ffcbe91707674fe729e15bad75e16349f6c6665b03be42e30ea5715282821139060eecc6aab30504c8df289acbc3cc532dc46e2caa917d26b26827ff53ecaf1f2e74eeb75b2d954fe60efdc2ebf927a29665adfece14a420cf7e8183d96f4c707f6a7707bc582983817cb08a9be9708cc3d699b302c93e1adb087207aa6546f9b3ca6855837303163c98885ec4040360ae65011ab0b6f0eccedc8614a3cd073db94fe3a05ce1b6741ee7eef1c65dcf71473beecff1fb08e28f6d7604521c1f6c96dcef6e5c82d305e60912f1ac9bbe00e9c54389c39a8c76ad94601a483d8677bdccc3286d4c7839f53e13391d670d28058c3040b6c90b26f8136f40e424ad9f4c9c09edb8db149120a72f0edddb32ae286e1a45b48d88439bdf3520e304953a2d2f3ee5eef3d0837ab1feb05a9f2b539af71f3d37baae8c31cf36ee977f8edaf86a6e7801b22a99062321f916ba64d32ce7df126d09071bffd6a3cc2c5f4513755652bee2358e32b48173702aa11a4df2150b49c58e0da38977adc21fa122bad3e7dcc1d9a887d79b986d59d03b7ba0bb7eb2873a883e0fbe397a14bef9a140c1957bb0eb0a82d21218c1f1f103a360bba78ebe14f68c5dd2edadfd1bb55df28aad97b87ee62dccaa930aeb0cc492682a2e65bbe05989deba4750cbb9108662cc2b56644304151eb287506cd1434c39eaaf7ffcf43901a1d2b12f93b56b829258340ba7bbd6d8e02583c084e123135fd21924ed83abffe93e8157da80a661fba2676ba09a0358ad06acf8af732c10377e8b4d7c22a431a3e34846a3f1efbf316a59bf9fb9bb306c3be184bd2fe9dc594bc02c9782691a2b51ff8890a2f8757b417472a2a0136e41e2ce8e0f2323410b3012cc5d9ae3acd4d646c1d6290d216a48277810c2070906f1fcc65a5dbaa6cb63e354ee4ed79978cc33184151f1c515d8a87e67ff36e72c4b9ec6b2bff2b4c4cdc8025d3ff4e6d2878c2e7a00820ffaf948f529035b55e9cc6ccf5221ae36cbc3734140d0c3d34480bcc28748d0223c1c127cb9a946e7828a18bb6b01082562b90d7313d1c84872d191f66e61a65d0254f2834a22b8af012b2c354d43bf6aca1d7eb3e0ed2a908315c1005d2b5edbe64b9675eed1d8580a463a259b30e9c758b634d1daf6cb8f58331d725183646d3d16f993fe00d7aa77e1263d799b54965b9bfdcfe85c04d560ff7643d9d291e13c7578a2822724190dd97f5692b01769d497e8356269c9b975c7d6c9f197a2598e772e28929dae82776a7aae9e290fd91f4c9dbff041549df760406ed9e4facd46fd1fdb8d6fb48b986f904e28eb4168f55cd9157885e44c8c36a791484d76dae3b7557b7891219f223607cb586e36c5236baa07fad3158d80129b1d6eadf5dd3fb55ed957dcc06880f5688bdac2ee5fd0bdcdd2c3eb435eba95e85c7ccabb6aed73a045d0fee8b6ca9042e0e6b6f983ddb807c691a5a98669d28b699beebe5675eaa6aaa2219ebf6601d103d8ce5625dc8366e2117e07a4fb9dad9e6c9d17c7d823546a2672e3b4bdfc44f77609558314107ae708dc3cc28042800890648f3a3b9bf0601022afe5015d1359a41ac478dd229cd5bf39147119b9c91a57832a02031e44c7532d75582842db9083f22c2e28c76ce12f06561cad4adb2a2c24d0ba415546f760a431e60ee4f031ce8cdfb6201cdd9b587ff686053bd8d2dd94ba619ffa476265f53f7da4b9761a165ba3fe02d78400f9faad3884bd4c0f215f3e815aa2f02c45692f1d2fe862a50ed98fab1bdf00a665b348621596c5782a30381ec766af544327c0ee396fe5cd7dad401320356daf1fece48e1e2522822206a35678283280dfc050996a12636c215431684d919296f93ed69b43757a6707fe3aeada382dcca4016e2621a73db7cbcef867b6e2a6f497bf24bb62a8effeb2613fa8d75e070d5cd84eea64abcb8f90396f2a81d7c7e06c3fbdd3a7a3d7d3ea98e001326a89d1bc319dbee424660f7ca440e518a6de9bde8bfa944395b14bb6c7810df987047ff22835b94495165277667e041acb4ef24a47df1ba05b71cc44fdda6de3192b1be82721a8084de7db37f023024fe2ec21624be6f75c69a3ed5e352f50e03de86d05787e59bfe7177f1cb15fd0ee183cfee0d8b374d3e0619d2778e806cae30cb4e2fce5ae4bb7f2ccd5488ee21e258ebf271eefaf7223857497411e1542798aa4c1692d367653476c7bcccfb7a39c2ec35b5aa69e44cde416912bf5fc7b7ad84dde9a5f4bbb50a87753fe80d9364984821373d6e77f364b9bc410d6ee149c95093ab4792ee88a9a9752476152dabeb58053a2b3944d6f373b8bbc0471b216cd1e901fff07fdf840a9fbd22d8672bceb087f8e775c7458337d34d63b2cc3ac56343124f55752c9a1fef452eb355934d6f28a15681337e22cec5feef03ad55b1f9f796d0856630a222f2bfe04b2f6aed0fe56d06ac69442658addb405c1902e4d4ac3825f03b875e22d28430168cc24c94b96655ba48c0a61804962b16f7875c2dacf11ac4cc78e5907638e88325d7d03469a23cb9fb61be6c273536d6b38049664d7256aee18b0a1ed431599d15e7d0fd8858b99156f47c8ac0a1b2e2956a2dc0ad65f83d632fbfc45f02da7ea62147e441f980836b9e9cb30a2d08515bfc241d0f9aee1d629c951470810a109ca6b5403c00b8afa183576d1a0fad32f7782f38f6687a85ba0b629decfde4d234e666677496f2e9f46ce8afe7b366e50518d4f2ab1f3290b29d0c996fd81974ef8c8423de69ab8794c741d6ccf8f1354b13a2cdd7ce29f20ef7bcb42fdbaca6a7821c2c504136a8ed0c3842a627c3c55047b5818650292374d1b0fde79aa1c5ea3bed0268131a0294974910962c9d570e51aaf994d3a225082640e413199c00734c8e7901aa7ee597e5e09fbb4f66aa0eb55325507dc4195ae9ceef73e70505abe5f7e07da2989f3cee067ce3a76e8143305eec55dc2768612c7bb118c4a05f942292dbda0d1afe92e9472986bf57997e2d045fe3176a49cba11d35ec6ff564cc0cecb03067fa5c15a4709f19ce2224f7df98b1286e8d633380fbbb19ce5a3ae18f7307e4e1c52957b35a8210c4e14b25560c4968650aba034862c4b8998b1608fa986c07c0a327de2ef5f06b9134ee2e46723a90e432efbc748cf9db1f03c2a60258fe01270dc42707aa19a20c3cbb5d524527ccdd41f514c0d5f3d2a715324492409e4748a7e84d6e932d5bef58fdaa7379c219366b9c7164787385549b7c8ac4ae48d0549792ea624106d97ff1701678d7638abac03ce2273dc1b1067cab74291b6f5d0b74892d109f14c0ad119351341530b23db487740f0ae96cb5e934ebc9650098bd6c3b2559b16c6dd54f0c4a03d5c2d81dfa11faf0b2d389cb6bc81ffb3b270485c785d5d4a0d0b6cd947d0335df5e28e0cde39e5eb42da2cca5d2e6c07918d033c634616eac1f2183adf67787c8b7cd6300c9b7a50cd37a394cf92c5e8915f8ee0538a7a1705adcdf3711563b245e5e46cae733d06c3f474d51f4a29f344b7393f1f0c6bb0c05b25092c1544e1a3b1699235bd9efcfb6f54aab0eb5cea308ea297d559ec6c9d0162e2243cdae41f8740238c561fbfa46cd6f96a1ab4a0ba0690ed240d0a69e22fafa81f1ad2aed705df53af71b1a809b6d17f6f4db62db32ad8ee52b67b5008e6ab4841fe9b0cf2efcb08d3bffc81d5d0cb102342172b14f02574d75506c8dc4360062ded82fb2135f68c3f76705743da693f645c635ac3c061bc3cf581bd5ba090faf73fee9daff16a49fc42f91c17f4488804455aec9d44bc3971b3c82742323e3f8e643a752e8ef7d128bc784e84d99f17b1d236d0d268d24992dbdd5019a35d60cc89ff10a308b8ce72940d41d4c8e5a8a3991bd88416506ada87cf82435916e4b453a69a772304a4dd3b059615c46fab9fae9f307eb094d9a37d723292d3b01b376298f56ebd554e4b1418a295057ee187ac9d26a109fdce6a5ae35158b2a22d4e724e4452869ca7f652d8f297b5a2cb7cbd8b63f9e5d6dfa8f6b49ca96156fd9634326e58b9e95f29c73c087a08e4f21c93bf5c25972317728ef9d6905fac7e310ed8d8aef5c319e73f2e540deffa64f9c0d38a7c5ef3f2d6930e6763edc5e453cc8a0cf6c47ffdbd31f5995b9a5be53f3048e827701378d3eb32fbb883be31947f87296d8c4aa7c865af23b6c8dc276b8bed987120735204b02cc43cc660c9bea7780f3ca319af43cd60c9b4b70fc273bd8ded4efc6c5e7a1b2ba474e6704dc57937b530c50b3de4a5d4edfcc440420be1f12a5feb7830eda1a749d8b761d8f54786afbe35524910df72b0ba7f8240f69cb571241a19cdb72d38ced45e608776bcc81719f712f1b66d4ef98d2c68a00d685b057b37f981776b1ddd97d148ef3562712243b5b8f9ff3f377bb8a353930f8ac50823ab4a04bcf2819f9652e25ca9a6845555d29d545b7dc60cb762a9897071d7bbc6d4b13b84d9a19fd1f07b709715ab4539335a72d36103c27e9d5729667fe17ea5d03f9d04cac57a8cd286ff99027d2263b580a23e3613f89c9f84761c9b6d6b8e25c6cf0e740baef0fe60eed695a3c0debbfb91726041f72ee5be1a7ee57bce438511fb4217f4398961c45409bcee324831b351af4f77fc32bd8f9cade88ac66afd9b513152fe52b44b47619e889637651a325f4a387f4582549af18f2ca69a2e413c4691ecbc57a5e78332675598a4bc46e33e5efe63497405908bcb831cfd622265923db99fc06536c7f24a76427ddd0e8d92fba99c5e69230d6448c495083713c6140db3ae167fe71869e091b3b7f6b149eca2ab74f4ee73a21192639baef924b1dff98019a07ccd02a804e932c19b0d895604992ce14671ba817d35f3051ef131b9caf5f3f2888a84d1cb5f9304ea983aa590d91193b954f49720cf920648ff6f216fea37ff456fc636c98c3f825fdfd404493a68d0dca5887c5fa702dd37b8fd42060b789571d4f60873f6f07221b5921d2e70c30ff80500d3fa2ec4d2e517dc4bda775f1bedcebc6984fd9ef039888003d58e2a9dfc6e1538a155f82740f73099abfcd7a8c26dc22f03d8394835fb567d4764f97bb26d2e8d0304cf1211651e6563535c33bafe995e864361cb8037dd362a410a141bcd202ba7d92efeb1336b62a9a31480a81d8c44136187b3f6946ca7ed7478c368b2906c3ed5ea4d20a8a895170ea8bb3d4142fc043937cbc4f72c246103bebf1e61108fb546a601b992c3195332b28e79bad6fa15c7aa4a82cc8c8ca1133b6875cb259540830adc144693fe200448289c59352b97d2336e2eee7d5885befcceada30cd734d27fdec5f56879648ab12150094365746cb8cfbaac6d9ba7e16e41a810f4172cb88c8111bb78691a80d88d29b07efd3c34040d2ed3d83ffa5e8aa2d574fd27198c03869b0a7a74430bba90b9499d61ff96b8de9e0d2c2c78a0a5250378f79ccdb3226d1552f46bcecda544eeeb9e9acd2fc6a517866e5124b53314c4c36d6b6542c40793c112162aa78449e2a391b635bf30b8594c008f4e7f4b5ae55a0ccf36e023367c0f7ba1bf89b0f29c106661e0b0225171225172cd34dce82b9b828adfb628fff4a80f08ca1f7a839699180eb649f65fbba13ead40d65d6910b07dda7b829ce3c072cc812a8036eeed7f40c38a5c4ad29f722d45bc3901df2b2dd0417a842f4faea9a404f58a1cd95ccd9ac62435dadadd62497efff4bd641323f486a45d6ef5adb989df1f5127b3b7e195966216eb3dd44b37fc5212f56024e2207a768b3f44b1fd4d591875919d64403679b7548795fe1ca77d27fe7daaba5dc9d65f90536c849392e226560ba0710381771107856e31a284350c325cc3b3226b8ebe90706bf38ea1ff882f1c352df51b5e58b354eec33185a60a852ebc94cba863b87aa2a47f1c3239fce9da90906eb3d6430c94def68c8eb4f3b64f9fda356a8d9467989d57a595aa36684f563136e90459efca98e300fd3fe7e8226d33b6c04e71b3b9f925484c59d3183b9035b5a35b93a3f44a238f93e1e1a748841e4df80e2b86e9750ca60cf898bfe57a2384095c71944e5092f16a14643662170a89d51e8b229757b0d4e5599ba9a8a98250bd7969a2842fbcc642b35d28282587ab1d73be9fb5a884f82e50c381bc57a9271c9975389c1acf6b3b6fb38f5a1fbac96c6c5f785229d8bea6db198dddbba4d227a89ec9872b6e9abad358ec698b967914b120562977212e4bda67f1c4a3796984b2c3396f16b2b085b242d52ad514237dc23bd167ce2159e6e23eef1bca51df95259093148464edd57ffba57e13e067b1202d69b89a61cc9250537ce8a80a87da24f2bdd23ef5f704ef40f8b41f9bab325a61d081d0ed986fb77d75c51e3e71e63f2dd1cbf51aad3f1b9a3c315797503ff81903c10dbf87a31d9bd1da1b7e01f5763c763188c223b51f4273d6db9928d50ebca5d3373f993a7d3ceb4bd26d8aba7c60aa482d7f84b6bd5e0c1742b26510b76e4a2a4e6ff724bc36bfd8da6acbb97b808a106c07f8a82889db0f7fb1435ec033ca4268405380986cf9860fab392336a36c71d758cb5e22ccf7f8e76003f5cfdbc821f56c8deaaa2547da7087a0bd38443e8ea674e1e87e150235db1e419cd89eed5e42e9398326b72481d0fcfe59cc6895ff00fd240b40c5c02823d5816c4e0d6a608e6ffc124b4bd806983ea72b32be2107be34ba5d287f08ee706d8c136c216ef8b614c0e4dd8a8a236bf9938f962a46e22f12cdcda81c99ea5ea26a752c1f0d5526f2e3853db977dd63ed8f4da416d2f950eae9cb51bd7fbb0b442b8882585ad4971cdc2358142b08a08f77f42a75968db718fb62b4f0c65848d8ee26db65c308757067d06ed37fcdacf7220efd881f62a561711391966eef2e9f42e1bb5ae8f75be74e101607943b625c51e106062992c53b225bc7df7ce432ffa29ee6aca84abeaa44efc524b3c132f48faf70185953fd1d25a2498fbf4104edbfb703a64fa2cf6c122786a6e6b32e1a5f1c871fe09df3093fcc2f58dc78970b46a314b43bf69e7137ea5359910ad7bd142eb83189380247dab26201336fd1e96eb2b6e6189ed2c4c3efa5124f3f3ac4479b7b4ecaec88bd2e8b7f6b8623fa0eef0fceb931f7f4ede843247c69b6d8991c5ca80fb84a22b35e8910f928e45dea2ca81fe0b1df207785dbd0ccded17c22dfe80682de77298f055f209a7a1f07e8b73995f684a4fa980608abef2baa3a72933b85a11f3b5c95c374acf6f8677aafb7405d577e4a2b65c53b41649bfa256bb723b39ac8c0d47551af05ff0644d8b5020dad66cbec03dbddb176d1d2d85a76de24cb3b5b5182f06700919cc20099189740059209fad343a078014ca2272544e8547c2869111f32c9bd08ace547621648a63a27d80f9058ffc303bcdcc5fba379ee42347c3faf23fe307c92066ae975d907f0a010a817ed9b217738d42451e159e5689bc8fc21c6cafaa8476d02d27bb1214a2abcaf5ec8c15094421cd2060687cd9a71fcb12df3a957c861f5415692d1a038254fb694291b7f128923b65de1defe1cafbef2f279174cde4a71cb27f74fab30811fa2aa7caae750ebb87250bd39f9cab18b79d88562b66c020f19ca4a9f5e53bf9717eadf9a53a323e6233a91885d8f98d66ae0a4d38857282891856fa7a7b0afc6e2ffe6244edc37ae566027f869d4ab51525cdef1f8a3f792a218291d2cf4863778b471d98090c2bdc5d850fe1c3a09bc07d79b1f492a735428cfaaab28b692948993202fe926f1f63fe7b803abf722dc0173dd9430239dd2e9a10730bfff20d80b65c61955714f893b17d975898c0a23011fbb54e3f4a5fb884a994c626f1c2c58ae98c35560fbec1c3c3c4bfa18eaf29d36b848d19f753e537bf3c91230157abb9dcecbab69fb3e53f627f4bd4ccd988b71259a10e4acdf0427cc1c056dff73e36bfc34616ab3ffdc8f17a4542e827592ebc02d6798ad4613e197f119701273b6d225865f996a45da4b3bf56ae48468ca9b4e50b7a6e2ced215b81a6d8ae583633ab7875a4e26c1a3d8b0a4fb33ab588f87bedfa899bea97a74d8c53d7740010d486e28dab0a3ae3f776c87c422b23cc1bf680c57688ed64a5abd566d22a977cba6f2c4a2f8779b204a8ae1d0061a51605f1861202bacc9804c8b2a827d4a5c20023586364c8cb488a70b99375752a802e5bf6cc9e04874d1f498811ef09b9c17d33ec9dc236e61b0c812779abafa8b605a124d5e7c07535a97c4437ca47cb5f64a236c5fdcbd11c751ff046fabdc41f1db7b37d68e4f274d7ee97925332d5d69f50239d81a031276e7579d5dfb51c0c059df1cfd67c8aa099663a108a693cb16b14b29ccb06d63d2e1c2d0f45427e8cfb4f11242ca91a06f89e8f7738ca87ff4f58fff7e4e5a7ee88c0b03cb9bd96fa1043fab464e7806438a4f419ed05b06681a992e3c8ef34b31869112a03b58f5dd85bac4026136fdb12f7d10c26692566490aced35595ebd574b3eed892c83b36e1c7997af5d978a8e24c91313a5a5f59148d17633d646676d68673cfc35c36854547460ea1546d326994244c4e23ca9daf2dd9ac77754e0605e59922432f967bf994d1cfa72e1a3b74ec2365fbbd8f415456f4b0911207ba5e57fe6f52566b9a56e292e56d488a21c1f4c2ddcb8113b2548994fafae1d3fdbaf454423b2dbcf6a2c7996a59de0519f211618ba2afe5ceb65180015245f77f1a0ebd05767748c0638d0698029414d48f2bb418756a4c49d5605e5f798534a95c7ac2ba82e159704acd6af0e5b8c5e72bfbf8ab12f29b64f726620059582139ec7efebb63eebae26cc6b35837baf0604e4dcafc5270b1cb5f2509ae2a7962b8fba4224b074c735f326d4ab5b8cd8442623d4fbfdc417284320b8db9fb40202f84ef8bd41486588f32554300ed5642f048835fd402422bfce305c83d4226443ecc15f389f2c8003e3ff3c52e232013a0310ae1d18d489836b322a7b17cac98bf39aa92380df65fcd1edd438a26c1b310c521d10baaeac88eb7da36f9adaf523c676e63e4c0ba57b1940180cd4908b7b8c22feaec609cc6b329cfc99b3781e53e4c00e8b097a5ff7a22ad159072064673bdd61c15640897fb427191d7d0e2054e5d5dcee253fcd6f48d6d7e630d1547a7901724c28913c75af42e57577b712bd65f927ebd3b812679aa93e167eb46c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
