<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c039bd8354a2e633b18910ebf70e76b3d806ee8629d44aa6778f39bf84858ba0ab1415a24108d2a79e3a2c11275cff4e93df98157bda78def4ef28b3f93424beeea64d0277691c19940f66b66b81ade8b350448c8b7a16bf35f9e1d1dd39e9322744c86b6067e20e0fbaec3fe1133f46b386ad3db8be601a768708473c19b5fde3589690b8424fa1604e1d63eaea47f14160e346ba3d3fa777f88b7b1b0c86d25a7729a2250f352b5db663c567339967762e8c70e4a649442f8bb303ddfef1e4e53d63baa914d000c80d1df2cd42401e04104aabb1c573b091529b31ee55a7af8ac00e0fbdcbce5bc4b7283bffe1e1fffbbe8cecab3ef2b7239285660cabe9b26ba20bfc03f3ec9dc0e56383059c711ace85e0ffa1a354a67ff29cc32166d98cd4ca20efb869f7da16747e4eeb4c5e01e77e19fff944f0bf4186bf93e5896dfa36d5766ec26cb7707a59833bb64091b3ec8297c03d629eabf69531f5ca430ba7d4c8ac962ff4f16c49c3f727f66ba55cc9a1474e67d923cfefe028ba86e98ec24b3c64b1865ba24e76d121092223f6d82ccb5b89be98252a97e1a24a6460eb907ee63a10f5d8c36734924b72eaddaa1773366115cda2369f4110ff41fd5202286c314c50e4feb139ccaac18b4ea92fc6d1b1e441e1554617c03dfb23b6f540fb53c83aa0915342c08fba2dc406031652789060367884c1e0d1dde88447c89ee9f1fef1eac040986f3e3c3fc437c395c3b9de0a2d17be205d566fd14d98de1fa59450fa360f572ba3fae993fd4f1e8443ff3d5bd92fd12192d7e45ba4a587f9396561e7004832f292f3587c93dc2a239204f03a20b5708fe943a3af562f2e988a55302c7332285703d654be30ed447a6d02b09e42d6d8723568d94a787a7bf6950053c0d6f5a98449fc5be241d0d9a10502d33fcce4791eb0497b6bc152e652ce7df26d4f7f005a5e70e913deacf248fbeb9298d0dcc37bc08e69f48afb6a62bb7a18d3da2e208234efe12f73a2e6ffee3cb0c7bfaa86c9038daa069f3b51798f2fdc48e9ac846762dcd2a7dcad4fa2667d5837f3c7ae01b204cec0f9d10f958bd731c56bdb3c6cc274a23484de14aa13ee97e067cc029c158c3be04c5a2060507016088ba1312aef972f3f2eb839d92a3735f910d62d8c6c04c8dd3106e7063e2fe9d25b855f67fd159ef2886a8e5bed1ae40013ed773fcce003fcbcec3e7d708989c9f5464500b7c2d4982dcbb539c584f9e9a4f05c72a0f0365eae21307cd8f27e186ac08d28c872d13dfbd8c76db22823f592214fab2957fa68e0ce4d7da6daaa38c5ca664b71c28b35d7c09477970b6c4bd926d7dbdd1c88d8b59b9b104049f5707699ceb2ca6628db2108a8d018a901f537290f1dfced20eff47066e3266ccfb85976139a8b40a9594c0a3515f1a4b4d987b9a5675666a7d9b1b040031c0292643424eedbf4634ab14b69b75a67cafc8cc287dd0bd2dfcfad7e7de77ad42d678cdbff2bc18a2cfbffcd18d3b7ba62f4f987712ad966b63c5aad5d904bf1a65315791ee527471f122a78918b967532e845c062cccd6449949b9f8428d4c0bf66dfdeffe41ea73eba1fbcd6c3fba4d8fd1a26014a97e2db8cda9a28732a65fc7ccd6adcb300366e230414ee9c5cadb5c4c1c315625936887ea2fd256d48218be9622439efc25955f2628c093b403dcb2bcc6315d7625ae358360f94a4c14edd3815bf3ad156fd579ff06504a42fe0e1e878233e423350dcfaae39b76c9dd33995b4b3fa6e92afb970ea97ed5790fea592790acfdf84509c8d4b080f93d6ff350ca09eb6870a3127b34c8c7a646464f1e09a472e1d8b65a17ed14047a8d29027d6aee091c59710dcb0ae580cb09367e4626d9c8c1372b9e1b96c454d6dd78d596e0bd92bd40560116056345e48d95bf4305206598b152803eda6162ff7875466763327089f08b8c7cdff585f0e294b6639f36b099240f831bc7f2855a899e05ab9aa8f978c6e30d586ce213443823f1f81859c433e391b0023c05ece804222ce6494a3632f0985b23654334240a80abd0ceaa58eb040b92fc2ccd45e4203744ced57fb8e4968f482c020df8e240678f9c60e92f903417faa6e28d58de26b3a8934e2f035a031ad8bc13cf60c7baeaaa0a6fb08e728d78d9a77c197139611cd55cdb9083a8f6b114dbbd085843eb167113c1e3ca214b99d96eb8850236fc906a855930ea810014f6a60e35b8cd8553e4072f78377a2d16078958f86eabf4bb43e65e940fedfd5972416f676be281dcfa31c4bcae9c278670a35141c648562a33b818330f5a2ff4202b27a06f3106cc418b8d48f5edbb4f38dfc6e2ea32f0f0db5631d11f8a2b8591306f6ac25555e8993a6eaadeb221deeda52f8e8bfab296bf450475daf4e24c4a7db12cfaa10a84c644cefa79e4d01f98735d94547c183f7c1a36faac193026c62bc8654ee69f892ea4984154c48b9b901873db2d1a732f2534d1315716a84881d9c5c54893cb0ab071532a409063023912222ab728886257e8ca72157658ccbd687066265ea21685da0c2208116060c6c1108c7b669757eca21ee32111044fcc57fb75e21f493c712538fe2026841e3ac262c7014426dcbd41e2482ffb5f1862d78b5389891ad37d0a40ac0fb97f8c07f680403e754a838e8051916e6a5db1522620166eecda1c2e2758d85168dcde014429b145846404cc57e951a7e094b89336153155e5cd5ab58ee7f689701c685b0d4f72515dcf3b39fa743e21468501c1829fc5dcad4e1d619afaddedda0ef4a8574cdf9a7a81428d6dfbafad27d89a16cac3a1efb788b34b94ba9a80dc34d6f446a6ddbd2603cd2bc574e8204efe3272131280228955c896b65e1aad918b46b3ef2a2d8e230c4128ce474ac0430a73a95eb920181856e662b47923c359a7f8a6507267d4a9c8763d15bade144873d37e34feec47835e5a5fde0462ec63a62c23f21cb906560d35e59ac6086bd45216a2cf2fc9df08ca633e793a824f3c04b6dcd8a7cdf71dd91f25afcee7a687856f4f09f8889557e2dc999647aa699466e851b6548b76813237a2670078e63f2021bd122067b1df8556f3c7cd5834b9897cac1ce02097a2d957467a392a013a04c37c303aed680923b605e6a00c12763d0e43ce176a2499881763679535087f9825cb1a539a2f82dfd7b2914363631287a25c9c492d813a8b8a4a778e1257e48521ca36fb4804d06fb2e52ecef1fdc743536001f731960d078ba256c699ba825475843c09c10ac2d6a9303879ab3a36fd49c953cfde3768ea5a6be1574abce5696c2e7248a83040f8dda51f50c2bf2b762c3f2578a20c753348626871cc8321949f5f1b3dbc96eaacb476adb7af553e6514655c2a65c668a7132942d15cccce2d1e6fc6d6060e6e667d63b95691cdc07a2ab85afa456c6f31bc51b727785671e7d5d1733fb39f8b70f0921ff0b3b6295a0ad2d3632d2916e74f753db4d8f496e722996fe4e2aab2127cc7dc08c0ac3a819f224a4b0f81d9f4a94351612f57f36690b96cfb2650b9ae142e4337ff0f2f78288ef7b42c8575ccb830e76338b267896e480be7938999eb6c8359d493ea83e88480e22ec841e2b47f614ca54489c929b4f1b59ca9d23dff7659171f09bb6dc0d913962051c32405dd984c628715d91225d11e4b5f99183b61d87d57b34072f0fd2c7abc67988e8ef3a63f57562d34ccdc5a308245f7e2f0218f8f556906d4c4512087dbc05ac40fcb9b3d3ef2f1d753944687b204fd474cbf0df69b9af826e3c64a9a32c6ed96b4a7378a60cc6a2967cf81f5078d9dba4dcd2fad1c2db6621fbc93190f03a918669c6058ce65b127d42803c7748ec66b9a179cb819b1b8e725390060a810f951e7f8e2b4bff6c7c0f76da8f2248cabf9dd731d2e7b6431706130930fcf23ce539a3eb57ae9323cbfe5d1fb814c6810413a8bbba51119516d44f0ff7eaaafcdff91dc6493432f47af6a124507b9994352d2aeb0687daab4d967eb60fa2693ea6be5a878ec5a2dca2b1e149d9cccaf75f45a10d20ac9c44476cba7e66bc43e469a5afa0d0aeef921ae1c4e0dc998a7260ac416d746efd49023cae648bc6f9b05508a53166a010a892e644f5817aae80565f948e37a3a679fca0e2a742ba9e63e9c4e0e4a4b1b8a5c7443f76169959ce8a08c31ec0f9199ffe205bf386e8ee35841228d7e6c5e1a54a45cf23e8f0b5e9d1ed31aba943c8dd0d6f3bb28b57e70005f82f181236f822a82a13a5c6da51a8643db60d87bbb1f3b5b2d69638770fc7e6e44d13cd71830fd03127663e1ddb7471e7c41f988691caa7e4432cb37ca54ba78c2014deb0af884f3fd1f9b45e3120e3ed1513324a168b4181d4507024a5d416b18c267424c052aae1f69901063391fb1961d360bb40886112c183ac761e03d22e9b4c73bf5978d496c121af3b86518fb9f0f7e4583d2e80c7bc2f01d184f774e3bb519d06ac321c617877366eafb1cba16af65be9ffa4005f292a485ec926e4c763ea50f37c1671b90e460615a136b62d319344b6efa431342eb5ca9704a11ccf625c5c1bdba484e092a3c22b21adf6345028bb54be7fb615d16c40d22dd4934b3b12f926aec03fc9fe225b1d2e08aa51dc9a19f03384341f3056833829172b74477ddede3975e6b9d566116b67c37580d174d5411c926566e11a9a44593d1c8d193ef3f9ba86f6eb7c948df9318755a6ca6bbaa0cfa3b95d6fdb2a0a51ae7f06d540405af1ffaf05ce1daa56ee2c542d29ffc86ec09e0b87a81e960d5e346eb1378bc9698af9b8187a99023c5ca0cca31d5f0e77d3191befea832968bfcf9a3ba350995901f65839bd052ea35f0d229775d0c8801474dfea70f4205f6f10b95d3cbe2f27685cda7691eebb2bf4143cbe1b2bb7f0d702d6b77e29f45cac32c325369cd6f30615cbb54a7748d322b8f5fb74adca2d81eff7a4200179df5c7479b03c094040f1c8385722fc08473eeb87330fdf15956474f8a2122d61eb28dda7838bf635547c45d9b2b0474926aa170e6b411456d250375b153b8ef1b286b1ea0718c2724e4f9862d8b8bed69111c68d43b34125830e943d7966e99bc162cf562dfc869bbb836ff953a52dbcf2dca1158df1d2fe3c16ee848a7f5a9d71787b23bab3f963adf6c6b151c14311370a1820ac356dda9eff2d7d6a15f008f7248d26782ef4d9094000751b3512b8a2c4dd9e079ee8ca8698f10096aedf924561a5ba6d145ec4ad35fb7829e78c9e196b855a27600f7dc9f3fed047936e82f9d065181ce278b06227cf2f0d68552f97d6cc241057464136975009da2945208ba7e6f7e2a540aa798ab401f3898e53c0fbcfbcca0938b352e1b179a69db05cfc2ff3881ffeb0294a260efeec97c213e0389fa1e1f0012c4ff01d7c2e41b9e73245661d47b8cd024b22c1b997c85a6ef50048e8b3af1d9f12ef343ab48704f17b892b0bb64f44734caddd6c54b7a7953eac48abeeb4b4b332c67b7624b398a28792f41e60f654f40cb6bcab8022dc5d6eba1036a958165e1b3e0b3fcdabed277104ce4096cb2fa73d15b93bcbf369654c79806b8a429a22fc0a9e669c91f2fe667334265d49cbe39bf9a347c430a3940c44d5f59f40615e13dcaef74ea621ed257b7b1be0bb49e1c567a99a9e55024159d73d401495a430efd39c4efde1be040c58a3c95dca51869a47790aa08f7d678825fce0eac4a3eaf0e832230a26b85fe6415a6fc0dcc39c6bb90d691d52793961155bdfc41be5a466829a7634d28ee9489b62f4b495ac4f01ec305c65b96e49347788a0cb6577f56a0327a3c05bd329e4446f69f189b48c023e924dc46a9209493afd62c8c6b2998a8a9743c0df963947f29efd300622594c8ca9605d906cc7c0fa5311cc9a7a07f42b92c3f363e8852517b4b45259fa3c58074a7771a1c475174c282d442e07937b1ca464cc038971c4be597f5b96351678f1cb5b93ec15b9c98bfdcadf482173eaba827a7f0fd03b02c4012dcb37f635f0211a41ac108e2f5d77952051844e05a27f9c9acae9d49be2fb1e984c2279a940762d0536b9d67690581267f1ab6a1c0b4edd654ff6e6174e0ed48fa3abda087d147756a47acf0d101b8f300c8e688ab7e82a60488bb553bd829183d6b49c75292df9052577edeb4e1623b8a534aa8f8d3ab1a7d432bd7248bc33414230adaccfd3a1990c84e4851be5ad1d57562e34a75fbd2e405ad1ddc27f32a56700b781a710af12af6f1833968b6361e31d2607e05f1b1bcc00b26591e8bdf8620ae169e39684ff4876d010edcd44036b2e0a5e48f4506c19147ba8a7d95ea4b76ecb7e54d2520d56f0032123c2fe1fe480059cd0961493d9b00c197b292c79baddb1a64a715485d3842ba076042884dbdc78a06b97e7e9edc6688bb9b92ea4304946d79c201808ff6fe9343728237b241a1cf176b190c6e24afd69c4ecd581aa18424d06f3f9f7d43f1f0ae87e14f9ac38a213210c56aaa2ef71d186545c829c2c89880c230121efde88dd931da65846ab2987004407abcf112d6cf5b8a3e19c49292f47e5237fcac428ee35381cc661df4009f32ba0ac356164060c45a6f9af7764fcb0f0082bd86466a40d6bf1ff60c7e1d679dd25dfb6a44414208efad0bbd1af7bfb18ed7fcff5c2cd5c5e6529b9143414da1b85987b856567fdd9f8bd9de7d18941c6ce5dff6735e6b3e3d7ed1988082ca75bc34ae410a4abf15e0706e9bb489fc238216cc8409b6ae1af9dfcf72a092feb4fd2e4499a3c95d0a0e7caa2997f8c4cde63b82131c73fb3a99a7ed5c20331e631ffaf5717a7c9f43dfcebde6ce3c753540b48e826a4fe87cd96ec7bbbabb6e27e71ddd125bf260ccfe3cf68c68a545ba9930f23e22df90a729a7c170f3dd843578db7a0129dd0aca112ae670436ceb2ef7709ea31d3f7e583a82e8e640dd3e8aa7d0992ed577c07cb50883e0d9ef9ab1411d81711673e4b635cac214121a3a755eea6a7cb2e163277d166949cf03902401af033314c423c5cdd08fd5c425193b2b261780cb31368385bb7acfafbd4e5974131c864dcfca043e6b07bcea2b0f842d9347267d683db32da902926fe4ba20bc9b8644b19abd4047a732b97a3b40c1f94c178135245774ccb11a234c3621e4151e4db6b1e2d0dc4b294280c4daba55ed4dd2d0e61006b10ac241375ce7b6ce580055f6511cd911e68b3f5ad50f6a234137da8ae7945cbd87e4a5bf1e6c9fc95ddde03075789b6e1a3178095ee83d8d9ffb9f505c13608dc8f5d3fabb82fe353c0c7311b29963398f497f326e973830184fb50347543aeba4de02782f086b9d4d5995f3d0e159b22a2e09d9bce572060f81271d343c5b88cb641b74592f933ffeab575067bf06605f2f05ff1e388685730a1440aa63d06a54744cf07c53869e4acf2dca7a73a4bb81eb30023a35d00ba6948b385f289065dc96daa6a4c41351355928b9c7f65523d47febfecb0367f28d045b64d7b777dd59f48cd819be308f8fb5bb59b78d9ae2b1976a793d8cea01abc10e432012fe1089b8a31bb34385b77ea54f1608bfc37bad3063928dcfeac0d433419d0de9e6e6f515ab7ad542985e4bd569791a4d982537825a57d07854ff7bd02c7dc3798d5ff0472327be5ddd53da8ce94dc21b5f4646fe75323cb8007e01d965abbd09da515834a45f6e71b3104314177b0d3514e050dc6338c2e0d92d3e91fe3a767e264f79e61694d4108d54c4b6c25485f629f0964c31af32da9780350ffc082ff1fcd3e1d9565a70b010f6b634a170227fff7947744e16c77321f7a213d72935dfd4188e575cef0903a7960dfa057f947b56f971755831fcd06387cf036649cc5fca1aa0f007b39ad1099f7846b4a93f01f26a9a84698e2efb5c9e301d8c9cbea4a895f05e7da67f217d62ff775cc4886fe9e431f22f0e8b3ea694dc2b7119c6d719fb35443a13a9ac0bedc7a1f70548330b1dc1d13026532ff2b51fb5a53bc7111ebca2b951c58e8d3c79b1c9184f36dda8bf9a87df34d3825ebd806d3120df5c5178158e42b6f833d6764ee46e7ce56a06c3c4968a3184434f111ba4a6714d9f7882a2b824f34dbc8911fe58d9e402a4f93756d2eb536803418eb0f6f74564bdf76b507f8c6f22dcaa5916e663564fb80cfef3e772bcdf3d7d5d9c73f711f601ea65ddc017fb56230bb6f04ed2953d88eddf36959d43ee5b5aebb6f93a2b869ace7e96e53ef31ea9c47259f5fa666e7a5490c17132041256331221be1d7e8ce3d99ab1853ffe9d451a4120b18b1b26997bd59aa43a27c97d33e1e508a8ccaa92bedac7b9a0b8f6c0a12c1631a82418a7303f356264860cfe727ed034967e79c20057e964b4ad3d59954c07b31867beddf4a0691616fa73300ce7059adf6f8b71b7054f15571046716147e50d90ff505e1904e2852929aba777063c059725051670638996355aef83192df3c76de5773375253d0ee1fe182b39f7b42dc0a29ee2c3243fe7d76a382c3fc8a2270f6feec1d4a95e5626aad799f401986b49d0cb95f076a035dc2e3f04ab0d6c93efa93fe31e3a4d036a533731aaa1ba2c205ede96ae908fb9ff933a210d1f7e0564e908f1bfb774c4d616ce608ee5cfd05629f090de3762dc18dca517184abcfd70626555ee3b60a14b6d6debb527b74dd7f57c102ab390d0616523bade0b7f95857403643f3651bd51b44ea920343c8965973a9abd57a7a6e97b4817991f4ed900babfa0165dcc357f7e45f2d1e998986cac885cc3a3bbdf1d68d8314caa4e6b31671aca995f35c972c565002f9f62415b673c45b3bdbcb443fc6023b47bbb89779273dee0dd88daf27cdf0fdfcab6c67aa8b1bf116af02925e045f6e43258ba4e2b30d6f0148608628057979fb68a31c22559a5bdaf074beb77e3d474a27d6e43ae81422047a165498c3febc10a62813a0f2416e9aa45218f96468754543c1608f7791fb5d74553fb223e1cca963b8ff089e2ee4a0c852ece59873982d1ec482bdb84f8c99bf812dcce0fd9e5ecb7cf6ee6eeb3743fcd6e9e3a67c11526ea3cf03114140af1ae049f186e4f827da61a830743ba3fa0c6a1a701ce8233d7f88e8c748e61cc287bcb397dcb13282a13f1504d29219ea6db41fd5bd1f9e4f57862493eb6028be31b88121baac97a5eea749fe3990f6bba919d189d7c35cee5bde138b90715e6f1af782768eb51e7e768524c037068105554d5252074d79e60827185d25c99c14780094d92de27ad22a887f29a6ab228567bb5fedf2e04b8c083548c0160d8fdeeb72998eed29bf15762706e6184ff4b69312b9640dcc21f25f8f53c872ba02545e8e143d2e2ca3954817658f9fa28fe4cfc6941d5eb0e147cfec1c9c05211aebb494b66c19881bc01d677209684e130bcb7f596a8d227d480526d9ed0ad4b8ba38f58b01db53cb387b3f8f01d6a56239df30cfc816caf466004a01afc833ba84102c22bc45f1fc352e13619bf44be87c03de7a5f11c70ad594db7a9e3d3ef99744ff278ca54a3a179561920d8de5a11b36b260d01a1f38baac9217fc4af891b64e59cb837c0f40ae6e5892df60c7cb83bbd0eccab6548c3c3187b511cf462af838019aaf5a43a3593d816b4e1d31a9243dbee9bb35a6916f4069feb864a802d1f318ad6b292ec33b662a2e0703d0c3295172fcf24cb5828b33b118b1666473cbad13cf2b13f4eb901c800e698fa173a23dfb8f6fa8d67b87d43f901764ff56bd9dbdc69ff3e6eee468315ef4079e04f7b057009a564744b619c7a1b31d9fbcc0c717d93d3ad9a92e764ca5dc70e6be991dd6c1c5ca9792c816a2bb241c0c7fd37285875157bb7d8136b5f97c7f63a0db31acd4ef9f0da4d6f89e24e8cf46bfac15544f43e7a8dd38034f8f6a0c3228ca51158d18000ca91474b2fbfcc9f788fb95eda6fab68727ddb0cc791af06ef28d763e4fd8b296a5ff48b66a47c583225066ef15c543e77e20be1d93c9fd3db1ac687df45b3e67f8237fad434b66bd57c8f425484b95f027ecc0898a438d5599a72ffcd27555f035e0918940b060bd4f553727576add81246cc227680fa1aac8dd3c6d2e5b10c037e56d5dbfbb469097e6d69770fbb8e6f940ed71744beae869918b8882c283f980293caa83b44113488db73faf186c61a24cb70139fd3ebc33715b14ca7bc7bf248d962dd888f22152fba77e859b7a900d58f7a8cac20c27b65c827cff2090a5ef381b3ce231e8a55c96881dccb40ec0670ba5635517e2161241e29d9178353b6ec29157ea984994ec23824afecabff68a65d80372be06c379f94de691ccef5a38112b713987dfc4af225f5a23b658a0d86c3395546955aed243509c683a3cf1d659c0ad6e9f591afcc778ea796f0c603c4c2213156d68a951204589c2d168452b00f5f476bcf8b903287b3ff5f5207577c30af75021066e205efdeb7ef00a4a32d431d9a3769d345ebe300e61b7c203c283957e822a2c0d07dc61fac3bb4bab87ac3dd92878ecc08c829ed836c89027c1d33ff8c8886aaab8202d77f052facaf87136f3340b3c9b9825cd613cb37c9b2be0fb1bb8fd36a4b1f824e5f45eedfc112eb875564abf871302a1ceecc5a184cfceaf70756123172165c7db949af5aad1330e30a447b95b74519c7a8de57e79d19406a5d6ad000a58949dad71bea30b1696381fb68bdbf86208d06613c095f19c6962525a77a674002072e5c8b8c2f61d316edbb3c72691f499fa8492a7672a7e77c3273e2bd79f570ba6154102c452470a8d0966c8797e7ccccb5b78e1e8dd374fa008d80d4b55f4430cbc9a9896b032be8216b8b61bba18f37f208492bc01fb0a5ff24b4ec8a27f1c2d3a01f1b347d64d2d7dfed4be0f6b44832253249b6c7cabd5197896efc77363dcfdbcb6f34a8e4d243753a0630fb3b7c9630b0751599ab7b0db79d1c1816e168e8ec30479755f030a0099ff93e01bdddb1d01c4dca9e6309b38fcb1dc494b740aa1bdb11e457731d4b48f2786fee029fa0ea08f0a2318b96b5fa44ce82c97e91cc5dc37315afd770ef787ea490db5e5c59581df981fbef1d5085f9cde138bba6ed9c28c5479ba214564fde17d38301050e5d6105fd2d3ee5e41953a6eb34555d22a177061fc78dc1b9fcbee8aba09be0fdc9c8f6e290513eb34310e28aab273bbc77ae1e37666fc9c9a1092a4172cfa9f0fa828b3bf4f34024082d8a49afa45798cbecdb781cdf0f31d93ad5c7d9e2b2eee282c90f4ddbfde199285c4ec30f7bc7a4f30d4871c4006bdd72d0014d2096fc5a6acbe60240c6817d0950a74a6558f0a9cddc1491fd31f3e290fe8b25e1ad629938e07a9a84d9369091c172a50380a40204442c1bd4bf373d92e2a9e9c01d73217dafadd80a255d3d8d01b1020dc623c718efd90bff8cd8bc0333bc27681fe9052ab2c5dbeae5ba3093347509537db8db1bcff574495628d082d4a5accdf52fe73b33abe83f0f1774e438e30d45b89eecd6d701ceb684d155d2b0ba352c6ac258ca042827d99197ea8b7f0b13a0585241714b01770e528b171fda00445e7899b2fd662d59b6ab5df53fa37f7de0fcee677f0341f32bbf4080823a6aab5a668931303be96c0b4d1984187250b7594d4fb1f278ae6bff08af11a2e87dd76c4a521d85dc29b40b887a5f0239908006ab64a536e416ab3370443db98faf650af18b176842cd682b9001c09b30307b14416e601c043649f0cc1818d927cbe4d7e4af6d80c9e8c777e1ccf598f1dd1e1c68d6bd6272842eb923f8b75dd09774b02a6330544380e700a8cd28ab5b379751101791a7a5f3b708346f416467755aa709270a9458c2984239f45edd92fb275ff7bb0a13315435c31eb032a3143f46be1756435577a55f69c4be8f9a1ff3c1f62ca405d19ac6bafb73acdebd76983062b11f7337757f7a489770ba28f82c80443b14f254e78eea757dc4a3742c485da184151c68bc2a696110f36ae09303ebc81cb30cee4061dc348a3d8c9199730f9d991c553904d8694c219ae622fcb0ccddafa0d4a586604f53d615ffeed593f77de362363b333fca9c883a73c9501534cd0b55208d102e6e907eaad84d86bf64dfbddccbb4cc4bb37befcfaf5a5879b5e235c347249de207ae8e8edbc5d462e61178dd6002dfa8cef26078aa275c9c7a61470eb10417cf3be7f9173e40ebaec58163ba3cafbd8c51f315073b8f150d0ec9d1bce30a18cdcbf555cf280346103268658d35764d6ea2183a2f3cac3504f280da7801008d2f30c247d7ac1f8239bb5ea3bf06642eaabac278cbe10a45a5e485e750867da5fde4badf97241d5ab0781d243e3f0bc0f9355748fb79c009f10025f9f1a18aec4e8bc5318e763c3e3f895e6a891e7baaed404d28de37f6ee851a42366f21ab0f5d9e0da1082262cdfc4d41073ba1b3326c88111f16e521fc1f861768b72c0064a4e2733f7c145ff456633ca3729341518d522c2421e75c14f8d549923ae1a55268194743ad118a2fc37a81e720588cc69e3ff3466a7764f8b67a3aa8a56a70e31e0199aefc66a4882dfef1efd98eaec13f8739bbe512f2c92cf9293b2369e0a9f781adb8a8763183b060450428245f935096ed22bb3fea24040ef7dff498a79ddd7e3229f4edb4ad7107c6e7f7a2e4ec896ed05c9ece19a0c0f9f29ff79897c88e6309d878d437a6418bba8140aaf4bcea27bd1d8b714784fe0d596a3bd872a80b0289bcd8471beb1870369c81c5eee01491c1788bf52ac2acd17a8fe6425c127eb68c96efa646ef9cbd5767e78b275d01dfcbc81740cc28139e0c5516622242cfe5a9079c401dbec9babf251fc5d2e3298382d3b3260bad4d4d343b74d473ac9554c5c48443fe554cc13291d50138fb1e27fddff4687827c31383e9ab1480aa51e1f1529a3eef89fbd36bf35cb537c91cb67d12d68a5903851d87a64ce45c777b6bfc9bf9fbc84de21944ec616b252f126b284fd119b92da92b00529edec0b7bac662cbc9cb99f3d0a2cc8c5d22d89558e41d9023902fc3841c3da504a7c7b265650ba028853539f93c1b942645107c785d4f15f8d4cfdd5e0bd63802df6b0f0ee588c7d80f6de234f67d89715efad17ddd602eb8367f1067eadbc61c46cbf3d8014538d8425c73bc7670f15f4a70cb4b2a7d6a32d546a13e42c025ad4293f0523c41f2280778d1010b25201685b66c2d71139584ddf17f38988f5c436f682a970e587246d30add234d0197f7cd1f35a2833ccfa7346b63da37f00c3d6066f85c4247ab543f68ac6ee0a64878c858433134e07cb0884abc8d7a020a525ed7e28152dc509ee2876f10ca65ab33b2cf817bcacae16cd7af3b1f96a0c129a646fbe0420dfbd7c38da37bd32cf18006e480899c49e5732dd1630cebafe61634e61910b702f1bc187aa2416cbefb356ca7fec408f0a43aaae91a65faeda13b3b5194254b46b118fa0bd8154d01c7cd8245830e85d49c79df0ebc4a9e3fa3421599623ee29f7f54999184ba62a2e3afdc30bd12ee7823ea044f45c8b6001db4b043ccbd918e4dbb32eadfc0538c43bd079f02d99b8495eb794baae7fa4fda572759492e4566538a7b5ef785ccb56373cb6771c5bdb24d9c434ddc9f3b4eebde7c18c56b75dfee5a5b4b19394795373c18373b6eaa81d7f08b6066cef9e3fc47672f7af61804a2b93c5bedad9f56b5cb2cf6406e690d33473c12337ba9d804a8477dc1c95d0fd9a67801c74f9b70c7b6c7c9e48db671c1abc3500b4d790ed5dacdc86ee355511be3de57e7c88a8dab247a5c710ff1cccb89789cdc667e9fb413605c20c778eb94acadd9ac2f8137d39ff1b1a03d513a3df09d12e2130ff3162f3f0de8e482aa4203a58ac95ea1f8b6029d8a75240ae6d3232b29a42435bc0c1adefdbd20ef48a7757f81b1e246b4c2178f1a524d522a7808ccd9341e36443153d7cf7a8d33d588bf090703248dd9407d9a08fd724dc371984e10e2179bc9b9aceba84e58d40cb59010af0e6830c4e9a420efc0d5a982837f011f11693e84ac0b4fd7ebf6691f2d7a43176eff9460e3a2f40e0196ab6b81022812bad0fd11f6ebb3863a37a7e285396f77890a4dbce405ceee3da0e646715e8766ed5d03b5865e060911e09080f444bd58fcee2eaaa435da9ca28b3bbac30f0bbafdb73d917bc95de40b49ac4035ee4eda3b500906d910a90494509b7754dbf0e1d8a96eea0089cdfc45c26151b313162a38fc04bd7f34545b5bfd34e07546c515a5f5d66bdda6ddf0a380b66b4ae3dab6dd846deb56b8d5e2c01fdbb49ae4d8c3089e2f13bd7be363bdda9dbd31d4d491509bdb5eecb40751b63bbeeda88a3bd01b1afad6ac21f4a35d053d73234566cadff8cd8cfe285a76e344b8fd35d443c72b6eaa66bb2c159bcba264ee338dffb4f21a08af7a302ffee8d31c8bda1eef8ab10b45153067b53753f124a408b2f03cd80940c26707bb94d03caeedad3256968680cde18a46ba545494d93756a4cb6b67bf96972f045d48c5d76fa44297fee95c0e22de402ce4cb37c2c208507188c8c6acdcc67d43d22a51c90fbd5238ac68ba5eb1dcda2f7646ba66bad04dd44dceef4b0adb7d988b2a92762ef3c1211be980dba1d3f074ae6cff0100ed14969f19087927512bf62086e49a98ab5d6afe12f238f35997d3423904af40077e88e1e0a5f825eac3ee172c3b056b51f0f5bd13fd1bd4aa9881acd9944b2c89e3028b66d525fffb98b13742084cc5906863d94cc76fa16f53952265cd2b5f6a368d38abc244dd3adb0198a1c30b82d2e8d3617767e4c5e0dbd5c001b60bf62cd0b1487ba401948ab855c8d79bf3dea9981625aa373d4d87d52cc603caa25ae01ea6245d67115fdd866f23faf9018f80104e3ffb537ac9a21bad9deb5f56c4eeaa92a2c68265c670970242261cd9f40defb68dc160efbafa746647faecd094a967ab5fd90e31e86e0cdc320ca0513d1dc4c3c76b06106e56c219ed80089f1f8107fd31bd006179862b1b9b851dfd61585bcd529992ff26805a15afdfc74beac987cdad6a826a8406fddf13d0c6f6b467557b8511dcaa74208807d8ad1322ed0b31174201b26503fcea69c1c26e14cf56cb4dd6444d751abd98676deff39ec36fadaf241003dd9fa57283e944f36ae7b17af8c3f9ee185f9645d54b4caa88467a9a04622b7d4e40387d0922d38e526cf34b2525c8eaef90343cc5533b0d4b93a695caa932a70053544d687f85b56c2d66d5ebb9bced5445e77fc1d1d01a34ea8cb4819000b8c173655411ce3e73c7fa35413bd816784bb185c14d808a58cccdf6ecac7d6f2de0db02e9e4c078e446cd8123f1c5ac264c244e745459dd3163741e2cbedfa82605df70edebc36091b528633c85cff630fdc7eef8f89e6d58d0a0f04c0fcffaa50eede23d6c75fbd9d00afe99ab83b7d2dc19ff6b3343db6969345b072e593aec3a2dc33d6672d7a4c2a82261838bab85e3bac2ea99854272df10bc8b665da6e544adfa4e5c7e1527224bf2b066e8b26cfdd0b6fe1a6b5dd1f6902664e2e6e7b2abb447ba25946ddaf90897cd7741ad167f8a4d7ac3e29b23ece1e4c7d1cc55db275971d137e2bf120e4db37e315815b09bd09d563d8f0d24046b34b6accb412257aa93890b89fc65f84118551ca912e318adab667ce58a3fd0632d5c6969715e4d0f791eb8ddc7a407f59b56277f7b63ad52c440aefeb346e9b463362dbad1e4068bdc2f2cc0ba05dd478f2b1d8f3d190d0db848c5fdb8b74cd0d58bb7ba4d0397cfbe67c74ab3ee74540c5cbf618ca48804a647edd7bcf39ac64375532e327bc55052e88fb2dfb932afd063b6372f64e3424dd5025e4e99b0f228454410037d9fa72e44571d01a06fa29ab38d064c6e7955ffe4cabcd374a83db340be100be4b246549178b2c00282ca986653903ee120d38c71138a7cda4f24f2297b4c381dab4fd851e51dc61e965d328c4c66196dce10fe3770861aa84a1ecb394c1d909f4c675e93b40029be9585c41e45c8d6b1d0857b1d3155f3e2cac63379d1ac74697ceeaeeaa72f622802c0c90bc4c655709991e0668bf22d19c3b811c980639c18a00dd5347fd65864618d90c5454b4e9c97c6d091bb982fb8957114c54fc5a3fedc7db35e42fa451da5cec44ac813abf62146d946a9a06f410655b6926529b03b19cd8c10cefc9936694f91f8eb1e15bb704907fc9b41baeeec4423bdaa32b1902cf50cee48f050904e4fc9bc64399d3d3dd2edb528e8c67287f63da462eaaa729bda2f6db1321c4d7307977fa8e99ccd4d58bf532ad884115a57d3062afe8de801aa22a4edef65d7f548e09be1bc61db3cf451cc7feeee83f3122b08e7c4a970f818dab22e78c7a6dcc4e035c58f9b795e6bdbc0e46ef4417523104cf7a353fadbf79e4cee1e6966a10b41d5e6d418dc6075efadea2dc08d7d639497879c7b26cfd44cf8f68e580a1f7cf025c79b9ffce85f1b32f56108a751be1ff3ca45b176c61d4d2d9d6a1161e33dabc160c40744e83d97de4a0b2c73afd6a8eaba4f1887aa2c7082a0068e231b2b95ae976c4b8433d0365237517fc210a5c32c52fe2693ac5b5501cfb1bd3f059c5854848c8b007493a634de14841317fbd67bd5a8d7ce14f70a97071e7a88ffa7baea04370222b638b90f82131d5be7b7930c106ad6239d6da133eb669743a8bb0a9230daa5ccae5333a7af70aa3c34e50462c03293d4ba79cc264f31a28fea5e5ba02d1b69092c5be279d3b06297897f366a5862911efbb9e281a4aa1f2ef0d0a1391035950f8b6177cb84602c1a097d8d6bfa4062a7be70def28dc27ce7621da5dbf426b4e7abfe7fe9e0c1a958f19ed5760bd831e53298f645dbd36e902311d4186434153eed02ab6fefb84332cbe906d348913bd9a5fd24b3de223cae8002f034d56acdacc720c19511dc533b7fffd5d8a8ac7b557b255b5417b8e630927e6f2c737bfb03452a94826417ecc0344fe3f2723bd75d273f757e3c26368a5687fa7d93fb13ad586e39222e7c01a38efde104320d7aeb26a4489bc5f4b590899197afc90fb46716ba1ef2021ca816d368690d26277e8acd060591d871a248ee1caf7868bd1213ca74295cd770f50ce5aeebd39e5c2c54440c15a2238d60ffe084123ee913317cc045921334b0383c9575fee56e2d5b4595731a7124efbe2780779f48ef7dddac8717b398a7025fdf6bd0220cd40b0e16d39a320514e6b9ecc46951b464852ab928e04f3d094642673b52b34e6e1db87840abf00744c0b673cd1bb3114f3dd89f67dd70ede8bffe93dc3a86b27a7f4503760cc0850858cd5b07354fcaba4fd9f348678402625b3e293855ed37e7f8b8e2be41ebe91a9c60f52b991ea4c285ccc7af69e11c47edf340776d25824d250f0df0e5a7ae73ca165580bae8af714549e7be38af69455d8225ad0c62937c60e53febe5c3b9b6e51735377e3c3169131a41de3e05a6038ec8f6365260d4f2f8b45da849b4e6e0d1a53e39359c7448eaccb6faf464a10707ba8d721c75db4ea410aeabe508e440fea6d258dc8d27da69669c31cfe2e550c992c895f5038443d41ca151818300da921e18b06143635f95e4a5f369a93d0c18d551b3dff57917ae882cc9d0483c740eaea9681a16bf7255108455451cdecbabf6a68bff94bcbe2d180e044753bd54a9e1f448a74a4cf222a54a54cf7d818b387ec9d5f77eb916996c41225035c66490dd92d7fd22162756663b3e91fc95f5d7afbd75139d434be74a0c9fd6b7ce61af802e6cb13bc7d2c2766fcbe60f4189ee650f0d8d55f14095a57a13ecaca0d10f7562be06a4e0f2273783d26c3b6f477b7cab86e718224eaea4b76afa2c91be64892ac0bae9a781e75ba45742bbfe811aecb337822fcb23ce540a8bce9d65cf38bd971dc55540266ea3e70bb18bbf7c8452b5f5e86e80925c705abd4909e85932c39169138caf6bdaad710945ae07cf5beefd53e30f7421b9f63e710e36e0edb8fd0664558401619eace2406dfb144c93a1412e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
