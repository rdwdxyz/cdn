<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3427f984c021a2e5db2ff79dbf7191d40f8ff48a67a5269c0bfe42589d848a3118fc8ac6451d114ca13fac5c5092f645f7cfb55878ca8c76b65e52e3eed1a2cd70e32ebb9ee4299bb5c49c991dc1d9e07039981ca6edc2531b86a5b7cdeed3f67a047d492adabe1c39df9b71c94569f9804d9d2cada6c2b803af35553be6ffdc164f9e9f6cda4083d80eb78fdd17570545b357aff66926b4d01ad1ec9eed9d7603c6707f225b5b9c3e0867ac30cf771d750cd4ab20a76df72311776b7ad2e5d41d911f15301c76ba9274bcd2a70f7eb4a769af0a13f9fa8137b09f5a5f2330dffc9c46c420fce9a2ea161e4399f384b08e35915da6cdde97d98cf58f2d5bfa5931596f5771b2818754eb39daec3a549276e4936ac75c270e3bffa527389b3842f7fcd8db6e16e07cdfbffb6bb24db45993cefb730e187102da694e32a1ee84705de1c245d6b54f2049e416115aa48c44dde303b9aa5ecec021fb723cf8f93882b245c75ba70d3f7d490ac01c0eee1a4eab55ee46e3905b244c02ba3761cfc5adb49e0a32aca887211ad53d92b88f85f90a6907e889c9468d166c664d2ecfb9a9b418b9835e66fe49161b47e2a46d2b8711c78f1d734de88cf5e967fda9a1d68eec320a9a42eed7dcc42abce5bc15fc66f6fbd6b8d231671efa0bac27c9653056caad1195208c9e22aeaaf9812bb07198e6f0e539ff29c05c75737235999a676c63d56586d44df28aa9d64e66ef723abe61467b0eb7b122caa231bee8522caa79bff4be70845961bfb28fb9564e88f88701575db2b1e215281493947d30a89b6fabf580fbcb335c4feb3934f8b733610ab8e0f83dc349a1b651466d49648412a5f6ab1aa21e5ddbb76a371c77dd45f93ad87cbc1266d363a368ce67160a93754ab7c8d56860591aa6ff81da2ac844dd44a25cd736058f09c94167a8a6342097f0966c14afaacc164584b4bc7f5480f52a71507cf167c6bf75082b7bff0fc072755c2268d0a8247a4faeedb281cad297d6b52f2662904beb6e529a0c130d9fb7275379c1fb26d68ee67ff541542ea5cd69ac4d7dcbea225d644041d16038f657c1445b36d6816fcd21908be43d857465b40b3a7ab694fe5383730e063fc0aeabc1cb32390ce8d1dc8b47c27c0874e55b6d0405de6dae1f529fea6eb02cc0cae43a1c234348329022d2c521a70bff16522a1e37e8f39047a553606354be501a8959c1b3c5882bb354b5044ac98be31d189188e85f470feafb24922dcddc2271fa4b925f4be6ac3b2e0d7461848f714acc22edc42f7df2496ff4eb6aa0f9c4f7d4c61ae7dc94647fe80486186b8b3c036f9ab3c2dd73ecdbfef2b013f6f9d948ae8935cca2c225a5ac7d3e38eb2eb1fe5ca22a71730405b9752fbcec1c6a7448d7a0bcb6a4239af106af4f55ee6e6834bf33f67265a59b9efeda87f5d56f78ed183bb4db732d197db39fec7d8d0aea1debf9972dfa9c964802313c37fe5accd8e83ecf1a74a11960ef4324d375faccb7c673ddf209a572de606453f08087972c6d8642dc819d0f31fa1880a64ffa3e9dd1cb3fb28f9b80a0dde5bef4c03e268a11aa9c419068e5c7e039a12b889f6118450c47117b1ea466d7b51e7112e848d14c756c7d3bbe5456569a0c5cc9e723bde10d6b4e04db3e14acc2136542a1557047e91a47e257c81a42de2a5ee3eeedb000b87732db15a616234ceda57c17f2c448f6cee9a5c8ee35c9f99892dc2a875ff404674c9e6c516eb939404a4d8964618b1c6fc9f4d520183a2d0d5eb6b1fd305fd96ef787452acc26bd442005af156cc6e7390836d8b3d7fee69a7caaee69e8d9251576801d85ba0ec43e3943a09d8f95fe7c9506a47ce537372130141d28530e41d6876500c71b8884fe269388ca86fb3f4167fe13a081d2bc072f58c618e75d17405c44f56247894a51de4cb46fe50de65904af8782486fdd83613619751b780a3cf5c58a46ca4d0bc4df26039f3cdddea1fef7a957f44e0037d27011b27de8a94b255db170696fa1c696ffa2c40ace965f3a8ef93e006fc78ba7e22fc08bc411135964d5a5a89685dcbef8d0fe9efe6c8bd7590ceb10211c995da72375f82690437341f6dbe28fda2067a29e16acc75e85d777eb9dd2afff46187fe19c67d7b3b764a159f7f9c216eb9123f731e7055212692a6ef1e0b6259d2ad08ec17c54858e32b6e9c91f02e2ee550b1a157db36e2ac510827386d7b8acda198e4adedbaf09e86166684c4cac1c9ba68ef5bebcf2c05fc8877552c886eb1c99f7be251cae31a9f10ca414a01dfbc2cc66037f8400f32cbff6566d047e1dbdb2604f345e33c95a67a13a036c533bf9bd4fb4bd73cc01907f392b2a15153a5c0fb19c78fc12d660c048399f3aeb289551f906de8e5f460a3fe59b6f08b8a29af6c8074d2ed00f6d96a68633761d502d9ed15d6a0cee98f5f36778c091db4a5a2579b171662c04589b5a5b8f4417680ab3aaf300984c6d7f3aab4c6fe1b1ab173e74b01ec5da097e6ff1a0dd2d5eac4934a123c8594f9e1fb3a200dacb108acdeebcb6d13a432f59dd392ce6b3e79c9543efce5d663397c40e057af5351b5413ad8b25f5362fe04621552da04a5cc85ca59f1cd03f589abef870bdf911cea9b10c24a12049b4e31c20572faa520ace5554a8db7b4543655c7269a6219a7905a57fabd577be327264ffa5ebabce6b6238fd8d9aff48034e98106fa526e6949781d77b4c3a97f7e0f246e3fe759c4da2cf2b299f7b2f0e5f6bb178cd85365c2426811eda6503a2c676664e756a734a2c4fb7b8925ac49ae116960bfc3718450f9f4b7f04d0e95ff8f8bd459d14700573f77b70d3363d812fefa18e32af4fb6c09076ecacc78e42bf23f6a076467d3f739e41a21e8f8a78f68fcac2fae17e3e59458b0b0b0961e5c9794d25b2681217e8e74cec6912b78a8493e6fedb970dd4fb3651aef417570ccdc029be352c5dff7cae2a5c264f44d066a3f008593ec56959f63d9407ef295971849198d5722e3e2a290852de94d178f2ad7da187a6cc2b3b579e699dd4c8d19753b5876e8155e8a378b69e77ba858ed97a51b6429ff36c48c1d232aa13257072b3a486628d7a2c1088130387de4952c4b800880d94e2ee31349ec4a87a6e02b52895685d5b472451f581c30b74b745d3bbe656e2ce4e49ecf171a128b83ff1f0b97404eb67f079ac0e434b37ca2ca915ab72e0874f061b0392f5134f19a9f9a3777a9b7833865306fdeacdc21fdd52c7299aa1d04eb254465691f8a7fb3d578f5afe65a810e3036cc4957e06e836ba1e25e7735b3f69983136f952c547310249cb19f7f460b6dd6a04e1fcdf20fa33dbdf479682fa795dd53d4083b448cfd5b91c6c56e7c0c7fca751db8a8068fe638360b8baa32ebe3633cbb78e9316dacf06c5ecd7722c0386d3fc347a83c8c0162f2facdbfe0ad6d782b54d4dce7251bc4c22365688dbac99832f9293502939ff9599547957b5aeae9511a528e4f06a4565eb03fc1d6b9d0a13eff3883797de28ff8b1dde2df528161f34264bcd4040e857a32a3af2cf1f2d65e76090e93f3f32568378937363e749267be27927d91235eabe5b95b86e9d21034b2cf39979747846af29fff71ce21d8fad6ee10394be0d1bb2a33f7604ce8a98fc910339002a1734a732fa839e3b84c842cb781c2f0b12d1d50efc38308a6daec5390cc039cfbfd4eb61dd1b60dc1df05451985fba8cbca54fd282682fba3ac029f0fe97166fd9212a2903119fad2de3a651db404bb5969a7406a0ed8a2646b8fd3c4a852756812066d8d057e4a84d6d51babfe0efd172e0127d38b36093af1d7e55a762977d84d6245b73e06f5b1099ff1533da3fa9f089c658d988d6548c1f460875a884dd3005d7b53d6645d16a20acfe1520036a45152e3b1395f8b3f98bbf43a24b968a62e30073b401c0c044bd83be80544283a2ac6fb645c26242a6101802577d34f60c390b3d08491cac4dd48c76f6194893ea8ce5187bec27df874fa368fea86b7a5db86bc774df4a9ca60a3c8706e15593f40e55059da31a0a39b38ecd30a143fb726e32ca9e132c99ef3884570b658b1b7ccf8cb038bf8bc0164fdadd0a464d0cd974920a3b980ff2b65893472f6f21990a81367b68d60cdca9e80d7bce594d4e54ddbbd8659ca8bcc1ac5a487a3dc2689ead6b513b936bc8a112392c3a5dfc81fc3035156be6af96ce63edf2f381e708f61a42c2219fc41356d68aab2ba9fef44be7c1837946797a5d81585dba8d3bb0e748579d9b28d638cee20e1e5c2ae477a2f61d8abca1994f090e9a5a5c9c518e863a556f73be800a810e1a1dcd284fb82e325c86c72d091df7ffcfec117a435a58a5151f3249670ca0a8f1574ac1f70de017f65c7bb38791946a759c8038ef99ccd4ef88678fa07de267ff69e48737e846d572c69dcb00f91201b241ff2358c2fa8cc994d448830634d4624d9e569fecc59848d0c663c160047b84af3bc9c49d0db4810d6a58316a6eba17bc447f8e2659c3085ba97c947116ee14d6dca45636bf5c40b120b14eea28fe888053988317c379124a51d5bc4cba3d6b56913273685c447ff1016b672a2e22b352af49eb9234e5a3fcd327f9b055bf2dcd9bca933d919ffd398c966a3bdaf8cc3ef7621725b4dba107e0d8e41d7571ff9e88a283c50c26b5614425657ce0fcf8200a2c961acb1a245b1f0ecf34a6f033906a197f5879b8d7d5bb303a1ff750c20bac8e8f24503fa9554e2d4c93621456f6d7d9b1ca2dbff1d71a8a50fc376abdff3ef627108f34ee177d69df177f25aa5ab7bb60bed31e9cb35fa52ced8c15752f1e77c09579ed9668c9a3b736740c8a7abdd4f458ef50c5e37fdc74cf396b86acccc99c8bb588b0a9a4cdbdc60e6769ea5d69aa4cc996d55a11e5254e78b3f94b50f60f38670621896a2b1182e6b396f7832bfff30b81902d1da58f5c3eb17eba57e7b1d60ee59b816ae7a63c63bf3857020f21dcb4b7f1d6bbfd51c66683f9daf03e60cedba38cf61a1e1aaafc32d907ef01eef4be54e01324e66dc68e4f565cd5b12b9d53dd078aac6da8bfea888f6244ecb332692be523b2acd31d2ce1347a4c3081bf38ed45f0b53315d12090e5afbd342cbcc594dc52f1b040d8d4a89cf98e3663dc2834e2e0ca7102a3d37f4f7a6c07473de97262a529d150e0325e46340de6a3ff839f7d6f99f42c3092e9857d99501a5a8e71b86bb8ab9f12b7dd20ec4c56b36bf8f0816d224396ac3bb75f342102c3eaa1b7b1cd7b7b78d90bfc16bb1b5b66dedc495215d914f34c310e76555022048bbb9d8745e7f00b1f6b69969bf09126be4f770041f17b4a32044e19b94087dd9917606669cb75146266a923fdbecdb80f3aca4a8f7188029443e3a764842a2c296f8970cc20fa1e3127bbd0350ef67d345843a214541677fd9982733abfe2e0c3dd04b1cd2c5fc97a16ef148901f4e7e223cb2e181cc62b6542bdff5a643206c50cfc0f8c94afbc150fbb657f5b4466b42961fc911cd1ab814b5dd32772fb27bac06f9bc3dec0e2b4c5233c13184d3a61399d24958feb9cbfbd2948aebcf4d2263a79be9555a3d8374ddeee2d06abd3173d286277a8986013d35afdaa3595e9c3cfca791b836214824d7303c9a24c7c6ca14a0d5cc3f7d8645572211c46d1d0bbc2129eb8ac26a88ec49748e3ff99c444041a9e3ac55b71ea3bb20798c28ccab9bf0fb1c2b1eb0b6b05519b8cf61aedf3ae7677c642df6a1c0120c65a40a327b1f705052d24a95f4a6a051c62807f3d79b132ea92f487960bc9efdf77a8d324d3dcc22af82631efa8be344de4d6ad7caa401567c3de7a01fd21a871d17f5981f875168b0add9848790adf11e98b70ae861cb1fa83d60a690fce68fb6cfc39dabd9142f009a7ed7e974764bae61a324eaae49fbc521e5396fe2dcdd4b716d0f760d6de787bb323e448c09472aff432ea9bfb082543dbe10445a3f6390bc559628bf4450770e918cbde0c8601b860e19e6619c8dfd149ce821c0ccc6fab091c39e71fc3d2187c6cbd5632f2f1ece15ee5e950f0725dd5509b22f4709dbe3586405b5eaefb77c3c9f956a4d9ab394848186b9cc87b9ec4b4933cfe428e540b1617db82a1ab9ae76b74c1a5dbce68674c646bd697c28c8201f191c1a965bcf19b12facbe08b2e0786292877616c7438ab55c3d89b56978770a12deb0aa01f09a6fcd199b179d87524520df0d6d2de04062b09f16ba9ec10f2d52087e9dd57a173994690a8ba8bad22d274da5ec31d45108af34621499bfdc6148ce2d8b1f5fdb250dd025f4d8868a539bd7820445817ef91a86d6ff1e9072bca69788d9b5abc9edaaea9cda1d12d27b3747b96fd13f5f6a6c1bd9cdf858b42b690aafe7f65f1e3c496a405eb7c725b1e0842bcdad1fd79cf268d4797f010d6f6995a24b909d8d963f6365e1faff634c8ec1f309ca8934666c571bf7d46193c595ec5e70b77e52ba319cc28da1f5d904da0f8318ce390e4e48982676f52c3d5d9efebf8dd6a2c9b47c95f65acf3bbb5551ec59838bf8533ec5a9bcdc40bf363620e7c85828b25893468a439a138133406fafeac740acfe98cdc3dd38c56d57c16102be04324fbd18f00e4697197d5459ed91a78633a01ed2cf6bd9cf9226a0610de23ff4cad8b44c85851a78a4ffa44a55e8073892646aca717e71ade25d78aa8324a33a3375c76d5230d5f0b8b604f84229191b44b882f4af41e791cc32e592a55b73c3843e4c3e4c32d3c033b34bac52bbe242f1162221e7f8fd3382f2a890192740afa4ad41cc67856f6e4cb54592dbe2a5444a7f6cbc011d9f53f8cf64a49cab84d77f0da6c9360948de0c3eec3365680b53f8ba2e4ae02c6068304fa86be817a5dcbcdf2bbc8a0e19076472409965e1edef2d5ac45f6edcc0b09898058c44e12cf3bf0220610700d946581784f7231bb29e07b65fc85ba7e933edb1117d7225a159bedc48fa321aa0169a16415ea0bf32a4f98745d86b1ee6cbb76293c14aec354aaa98534809f8ade0f2972ee30a3be2db378a93a1f6cd83de36863bd026b4ae03438ee441f40cf67282d5b9631ba4940a26d26e5d4d6ce0770ba84691939f9176bb3f4707fe67bd948b3abd4e0b524f581fba1b0cf2998940172dce74bd6bc9bdb3ee5d8f61b579359898a50d34f377ac944d430ceac063f6d64d55de16b3d0f3e6d7bffdbbb60835f1026b61dbd90379f2f966ae44a9efc946a1fd9f7b80e20efe249d7ab68d74183e520d48a5e979dc1a6d9ccad2e6a8cc29a49642755d11b3c7d6ad863525ca6221955dc0ed38088536100a102ce309c8fc0cbf33e24e9e8c82a9fad4143f74289990336971bb967cae242d8e4d340d0b9110e74372068901d526765b35a25f258a809fa457713170dbf33d83f6f0ce901e2a8cd10ba3a17ccf0701d93cf08247c76314ce3fdd8040070c690e1ce198cd7c8b3bbc92fa1bf027e45db9021dc9f33f966e738674628e5de317d8425ff6983887ce016d421a543f7129885428ac07152d8566ce1b2232767b86611941d5a1505ae0b405d9f809d7689094db61075bb646ed3b16653f2c52fa40ca99a329db769051db3cd69df6caedf88685051929f4eb56f9e36bb9532f05d50b94a21e59ef2743c4ec6b3a2e3f6528dbf4b62e83222d5bc7f0bc14b618f1d3e4f0fb4f8a013f19bf5eca0068d82be7fd59d30972fbc729d0eb7fd2fdffae65b938c8990b33cb6f9925159b4cc80d2f09b9b1d7335a682596c292c4ad9cf4803a29a3cfeb0304a6d262e457c5cf767dd13c814bd1cc3c5fab61ec8d948b153cf138da3cb9a6f567133e309b8defde6319775bf2a041327e39f4ea3f3aedc978b372ebc08ee263ccaa2fc64b8cbab43d476e7ccc60c7a146403b8526a1a07780f4459d59b9ddb133921948e2d321e46deca962dd63c857520ddad922acc20707ef7a65b7c7bbc44b5ad00a60be6c38df98eb0a3cd35c47dd70cc11d550302c0ea48c7664e04ee17399b03c2981a9c45f858633cfdd798ecdc702874ec677ead7a9a4b313f27711118e5229d19574d1552bf5c22c8f942dfd4e82bddff186a40062abce5277beb9edab2badd0dad176417b82928adb895c384febab8b1317ef9834e02c67051d6b28672e57174c7ca2440eb1e74732c9e94f36878b5b1d49b3ef80655bc796a9d5ff05266ca41e3849b92db40092be1e5b5d6e27f9f6095d38162a16dd6c973b593d38671bf65869c03b07a632c3b84d37e1d55ec514da4cf76d8da1c0cec1e25f25d8c2623cb84255e9d5a16ab62e3bc024afa8e43c8e93aa4b02ed80c62ba5fc464168a4fe948b21b009bc4bda32ad431e3cf9e105740cf396eecc6d4b0df58a62b99dd213a758cc712d5654799758eef5456c9e12fc86f81c36700b6b36fb30e7498ede54b7982152b812c9fc661e93981a471cb3ea646b9bb7c66a5ae9443b8c0a5bb5a4b68deb69f5590f02ea15cfa138f570736c39514f26da9472276cbf715b4f2e405b15b88d2da846b8982ed27d113cea269fe676eb9ba6ce11e1bb3e5d121a4d91eed455eb91ec5db77d64da256a3443c3e5de3873422a921a5bc2ecc873688b5331e892a727983b7f759d52db267ef1fad3204fb8ddb95d6e7b71878ec5213d44a4e3329741e46d1c513f93a064226e9eda31695f8f6c6fae527c4ab2f2d6d7d64e22eb97a2cdf5f858fa8e541df8f4ca7db2af8e5397d7a64b1dd54d7abfb642459b7ff7922ffc00129ecdbab64eafd5ce6c7b86738938c272b0a89e9f88641f14b8f9d8067da2b48e7fb83eff5ddc044f291cf709054f0825e12a4f5a68365cb3b4c9f6362e9c270e510d1781ec20a4752e4085f14c8201953da2d532f8a4a25a8ebeb9bdd67375c4e606ddf65da624ba67ba180d45a46da2d3d21687fc67077306b8acd4e99838911845b9a4045410364065c17ae99ca7acc3f998964dfb4ec8373cd573286aa8b83aa76deafd4e67cd4c43ac2c1144b946c8816d8251f3a9b4e94cd28fe467f3f46c8c79dd85a331f82087cc3ad95f0afa0fad7a1d0a63c701e73e08966bb993c4e21c164bf50e8159b387b8333d5ba7a78036aaf7ee2164f001e3ea04ceea0b5e2a3970115c3a597a5dc790b82ff2505c256084f92b0588e6b5d0756780c7de4229cb18d4280605ea8c3f60a756fac8d7de2aa28fa5c80b988e40677dbcb275f285cd8b2088934639bcc61faf29ae8ccc219e27d75719a1925a2ae74f7bcff0061c05bd52511115ba7c9d3b802faf45fcccd53b399b189652cd9ba39c07ee4006936da90e5cd85e00fdbe4849f423e49adfeab9e75cc5caef1364ae616f937e08e2b80c59eb83ee04d5c686f48ca5c5f5a711ade9a475a055d74fee4af9877660a67b633da6cfd44ad1612f3086ebeb26fd38973e08f4cfd0de4b6469be757666af48a9c97a212bc14cdc37a16fc364086045159759e1a6284c2cf3877ca2626ea45beb62f009bf99e68522093a34c67e97383cf830029cfeb6d1e73ff1197fcf863d1e57cfb2954b634007d84adc261fe2ee2efd38a2ac99d4af3c46f757a2498512465cd34fc3bef2c48b89254ac07bc30747f26a710c283bcac266af9e9f43523d2dd63e76ffdcecdb3c5e2fae2dff40162ce86469015ae5e0c2e30479f29da706c775a5c66f344bc083f6ee504689a55b39298cdec74fea8403c5ec77535498b340c104d63555c813ea082a4eabcf479354ee68741e3b171153bf1ac5cf04521ca66fa69db90634fd6666969f1ab7104583af3c5fb6feb3e3e2e4987391117111b63758ce9c97a85272772b031b14f8c2927a79faf3338f87252516682f080508d2cf6bddc2d7b0f8d5c94f2303209b0c0431cf5b479f00d7dbcfeccae7bb10d5f9a8ab1847f789989304f712746ae954a1744d2fb0312c7c543f0938af866427249a48e68ff369612806485adb4cf25e28cbccb399962eacbd08c748bf5d9ba36a73baab9a1c479ba94aaa3d5923c48e7bdcb2e5b367bdbcc8f9a2813eb875e3212374f908b9d0c20da21fe1c215db81bd5dc6a666b7670aad5dc77f9f64de34917d216088ff4a09dbc115f65a5752f893c06756acd084b5942b791d0d5524f6e4e1fcad8d3e50a50df50e2381b2f9725f16d6c430610d6bd4a492f0a565ac2f48b751839a30a3b9ca6c13125c17f92f4f41ce60edf7666582fffca7663677407b2a0db9792155081ea0d86e754f2c995e86f126f19265d86553afcc96bb739ffc6d757acaae8346984dbb7b9fdf3f7feb9825c6e6b0238681c0ee404ce0093083447002a412514f01ce9b76722247add187d77c4be19282cefda4e908ddb78bbf21fabc5ebbc1e20c9968248a8eb2031fa94281313241e62c8a4bb2465b0005eb93bbd6d8c598c4782863029a1c23a44356298459e0e5ff50b125c1d2ab6e16c80f1e3aa8625927875f8684ad9d61667ed2eaf0b2b5766ee8fc96c586b69b7032f65c3180b603b825c14449294ede52299387c883a5edd2a4ff8d5f710872f0383b405d02f949785fb260c5179ece43f5f17b51cc4cafd71525a1178f8880850813d71bbf93b4c0c1607d5a265e2cf3c679581a6470540e03c82f283593608e38f13ac1a29e7197eebbc7dfebc9430f069aac84ca35a1dbaa703e13ab4cb84b385444989d456ed0ae6fc1f90eccf7c7c8bb426ec167d9a600d5aebde50c36b344b1682887066c3af20d79b7981bc61f5089f75c5e1e5ad605d3b5d24beaed8eb23eca1ff178fad6eea94543ee4ef7dc6c78a60c040baa42e49e0e18f8e699ace3cc289945e64a4789b1b24cc9dbab62204eeed3a1b4e17a8c99f02f72b9f62476c0d01d13e7e4108cef38c74184c98ba3d97691b3b1fe7507c9785345d1ed348ec28a39e3be40bb920b55370e2c7837e8441bc77a9d0da1480aa2fa6833bd5947d393e387b49aa7f96371a600b613707e0030a3a0f5b206bb1cdddda5e0fc2a15b951dde96a7c46834ff625abc222d6268a56d13bfebce345c6a9aa25f57594937353b339189157aa49d572290f87d4d772a057a8889d124bb88c8286ed649e73ebdaf5fe14d943bcfffb7b7704b4852cb87460aa088bb53f11a3f2aaf4983bcba3e218aeaf9a09f5718668f0bd7a474cd7986188d5d429c0c10859961bad93a58dbdc8ee8719c0f169c5c08be749e3547cc51e6d52011eb2ef4481c69aedc2e671bfcabba34f5b18b2805aee3822bd0bd9a1243ddfb0a90e85f9e1a018e8eb6b342bfa2bfe2e41e987e9fa6aeba6d1a3f991ca7fca8f835bb6504efd49cbbb603201bd4ffe69d6c8f08f9315d15a1d4a26904db1490ea9623f7f1acd61f899b0c79a28bc4bdfba10ccceb220052e4e05dd825953d7b3a0eae2a629639958cf25861d69fb4a122fce8d94a12064483a260ce532618cf5a00447e6a042d11da9528ad6b90ae2eaefd44249dd8565db6cb188c848b12102320071c9a165bb23137b7eb135cc5b93422d6f9e7870363008f088123fccbb04e7a922bc6de5ea85f9a890961691f85e54c58b3ffffd9cdd31666336c5e330eba2e9b94e3da3763d2678bd142ed4ba615566672b54001b602c40f6f10965908380cb14f1d171e3806d3d5249ad4b543ff6b4e8f0ebb665480ab8aa8a2a743eec25e369ab9a32870d62ff64b7ba7b1274c54cae95f389303ba69c5116e1e9e885753ca3475501470ccbcc4090e1bc089d42b68e3c5e7c4b35232b8a4e00a995b1bdfe83ff692e95f3aac32533a2d35e741c968e519029b2ca9075726b344e0211a62a4cc2c1d57fc1ff52482f95d1b3f6cd29557a6cc89749f425cd67ae9d8a3433ded1f402c8d9589fe6cab9b0e5bf49901f84ba4e03f3da0d8193e85e2a812263a04c707bc0b5e67acf39ad9bd463b57039a5005c433d3aeb416338143441fd5e815a41576626028f41c56820a86298107643e56a91e53575e9638893383376363398e806ddfdf3ec1f3f35ca254a54a669792492180e6ef341bf887227ab9907ca7f22b1ab251d9fbe320d87f2f4cc76e21806b22fea9f9653497de65031ed321553e987086b944611ea5d65225aac37f94ba97d346b342646aec7bd72d90566e9e3b17de7f72c0097e174f49ed0e251f84b4e396ff08fd87ee1bbcdc4f9e56ae2c00310a15a202624100a4f56317bc207e30312a71abb9aacf951b9ab27fbb9f46b4e16fd7de6527b67ac8b42bcecb2a21bcab58b144721c36779e3699c2bbb6259cd34739a48bea1dd1d669dbafc0b4d4904d82c397607528640e61003450317b9b7291a89b274d285e95ea4507adbe663a0cee5efb4242fd85743de4c432424cc5fb915bd061e5fe25925e858e1db29b1b6751e6790d147f52f15fa2b9932ac15a556a065e43e0cee4c37f439b411ecf0deb7e88e68356e28ceac679351822df92e77812e8aacecf7a068c03e0a11e958ce9d1dce8297cac1ab7579b97342abb969e17c41faaf345f1566c6ac673ae9c5b6b9c8ee55dcafa15482b501c39ff14a2300c136f33b1c6d75dad8d9d5f1c677dcd2c78b802a931b55bb25b9f2ce81a8cc90e8d42cca9ceacefa1e3ec6f2f3ffe1debdb0ba3de123a6ce1fed497309c501d79e1ac7b90f1d09fd28fcf7ec1f695eb9a7818c2d2c1298485c3a0d1489af611d5037f7fd56e6dff6699f870219924ddfafd372f049f97c28698b07b33f6af2526cf8af92a0430c08d189f0770547a2ad9d0119d66008423e3791660c9b7500937b215e5bd44c9ca2c2beccaa6109680e6e6a3ca5248b67d6b870321f5a311f8cb0a52026b951dae5822b56bfa9c4f82162e410d8a9267b8d774b6100ab38c92b677dbfb4730210950176cc3e4e7604b6f9e10c3ba31a2f89cfa2b1c349be7a9d86bcaebb5cf47b0362003d53bc6fdb62cf9cd47f33ecad99126b0413444f5529cab6cccf651ddf8ca2eb18be11ad5b2cd6a5736c76f46d53047a5dba87a07d641d4349245afb2c0c85385c923389f9eb05e9aeee247b5ddcbda3a5c47447762f563dcd61798a659e9394c097ef33da33c76e33f5c1a5a9894cdf60148b0c4ceb960e481a698c74bb828334baf9858eb739634c5f5d7dd00533898825aba7176854b6f89a5ab78fc7b44abe8655c4fabf3984bab4a5f02e6f4ed217c3246aac9d75de9ee9e6168e16ef184209f3f7ad44363428effbbade033cbb3545506eab75e96950b491cc9333fae8018db4bf330beaae391f599c6d6ca85822c65cc3eece2e5c77d075c090acd1bf3074db2f998381f9b980ae19f396c21ac08f79b5a5d92cc44a7761427dd2bdcead40c943772f65f5b22bd3ea776949badefe2799d6a446425aa22de51e6ee59f37171906ed9f99797e96a8bba12d2a3fd3f66de4529e0670260c17cca68db5c261b60137474756289a28023cededb2bc64a41d64bdd8b93ca24e8f53682ae1465e8bfe9b8497f687c2d2cfe43a690b9ac1a5f02ea26b6f0395f3b188bbda15c09c7d3d4e829a40755b7556cbc37183d6dea4c2f60f62ee07d9b1a19a3dabd73b22cbf309e4ce97611f63dd0fbf196b1e48f32ccb1b8d19afb63d46ba6c78a196fad7b3207ddf9f36331b1b686733a185034638883d71dad742cd23e8d6464afd7cb80e34f7da26d6314885beca0049681615744b3e1bcef4ceee81b6239988090c4ed8fcb837acfbef6b2a3beb4d9745f0929920eb4aad78c737c62ccb97c907acef71ae2092e6216232ae4923b83585d8f5d5db11b389dd16d776b6ea77893eae70ca0bbc352c9e9b4906cf7094184762a408d78d1e80051df645fb45414817a131fc11bbf375f394090707d5c085bfd74948c3451d737e0862d7cd4db0cd1f34835bd840a67eda200b68423ed372a8d8161e0216fe3c4d255c337951d98edf2c978ab490b3a463112fb4fa2456298892212968432920c544b28e36b44cf73ad1ca90121b69ac5291183bdca1ab8e5ba63922469622ff14da68430dcd26073bec19bec9ab2fad46476c4797dcdc34287d5012cfc40a05126c6c08391c7e297b229a07c01fabe46d4f9551b8fbc0edffb0da7bf85f4c2898f3db27262c738f56837a7c6f220f9f0e890431ceffaa8d3d0a4affc81079e941d5f18317e9768c18c9b1ef976aacea40ce62d4a0134d96a01944f957701b59c3d105cbede575990d49f05b4e6bb7c55dcacacde5dbf68417c57c33be32242a19d30381aa72c20a136948e8cb1d84635cb2f832ad6a37e1094e9777e130c72b03c415721777caec3d64226c4cabd6f523b4f3b5068c97f22479e21444d6b3d79e2da4df5ba59a7d028500525e24045984c668a4858efb29b6955a3a7f1c0161a5ef412031ebd8043e83cc7a9bcef64bee1838f06c81594403f5bee410d84fc6b12b473ca67b2ba41fe61fa6f07b3722b875866c074a70e3793d4449a87a1b1e8ea469237b7969e6cd5d711a14142d12cc29e82e7b6acbccc0fbd8e776f0aea379b047962f2468fcc30c9f0f8ed587cc6f876f3e08b9afd174f2f3eb825da611e45f20919b4ff55647cb91ec6edc1c4db20283d1c2697db6e4566be3bd46e616846c19447f162452cc2db26d369ff309cdd7e89f995c47c1dfa86bf43dc4fbd21d7e793f11a4a5c12bbe41da663e3dcc4e0f4e44c3f443ab4949cefbe9b4521ce7b5ddf7f91f7755811254d60008b490ffa09459cf6f9a0825c7edc57f5996467c1d89a0886d2272553d0603773300f6a98701cf4bff3183867c42379c3f2af6f1304eaba747c2830d3179c112effcf9cfbbdf319ce1fe82f35a55f00649eea05d3788df9958c1925aff08c0bb537ad925fb811e1ed2811fdbc44773d1f9a6b48de2740c333ef76d65cf8d7a8393eac92c171cf5317a3a666300d0057e661249ee6c5f8406d72c137d474659f2f42ec9d4c8813c54a8cafb438ee26b187caa5db1329cd6e7de7e4d5961acb6dce9e0da52b84a5868e65bb85ef8e6a13473b9c8c078c09c9ef48ab425ea348128e5369280ac9848d2292db5c722eef696a7cdf07a0977621abdd43c98b340769df1dcb36728a3c4a678e28004d6a9a5c1133984d1b37c89f2584345e546fdf2973d7af967106df9f8050e76488a88d49e39092e0cae2b6707b81880b73fa5c741bb5c7eb5f1fc1607b52991b6416b1767196ec12b366ac880ca762666f57f4254205b8c103c45ed0924458efd72defbb169e4d3ecf6ab431f5009b81f2a719b04d525b2e38fd30699f69a94b5cbdf965bbb3052c0c97df5fdb89ed5cb14fc9233e5062f4ba072578b7d0126c156e919da5a8344283f16b4c03c20a91ae0b604f0f97c0cde105dba3764ab46f33cc75a06b4a7e4a7bebd165c53d3f9317c6d0bc0933c131a4a0bc51e3dabe9673868d8dabe664f652b44e2bcb211b551c4707b3476f13b4df5103661a11c2ebc150947b39fdff0f755bc08db4c0bfca0224051f0e0e512386b99d3f15cc12610efc0479621844c50387570e7a76cdde5e35af086823de32f62a5a23d0ed3fa620435ac6dc83bcdc9e6613c1b5d916e565eceba0d0688f56781468cc4815c3eec85d670eef916e67c5e0cfb2188527f1c090e2da8b246cb2e6c169fefb295449b06e063a4ec4082eeebfbbf9520b4fa0f926e00c61d4654993c2b6cb6b904b92f62ac5bd54428316b018b97fb0c8f220389fc1a3a72c31ca9e22b54258669f653a3c4c36b79165352263a05ace48a6e9697489a455e0894094fce4dbfce42d584217a97fb6531e8e94fc999be5dd3a04a4473d805b0bd85f0c1ab9a759c45dd992b0690a9a17af337e27cc89b8fda45c05cbcca4e1d463d26b3f7ff71241bb1a67772c0e994bb56c6fc5a3071352a43624cb10007dca644496461032ff6653c0047937cbdf85a7c08aa03e910afd8ed626e5d8fbac4e12a88df83f7fccfc827cc1c7fcf03495c4bb66f74bb13e35189093392db758109ed96a88bf88acba401e6cd4a66f0366ee2b0ca5adea748fffd398abf4b1b9391b0c7c925a943b230783df2fa60a85067a75ab9eb5a638ce8106e1482f94cb346437d7f210debc7488ce775ec7fc3fbadcfc905254d4bc8f338b0da3356291a1b5d3ff817bf6040137fce712198c8809d2d571f48efdf25ffe5ef4e9694afd11a7c624653472460b362864e4caaa7850e0ac337af509ed2daeaf022f7889d7020d697c3685114afdf29f418da70d02aef3a7dead86ba5d8149e2b00a93bf5a6595345d0706266598835b20d4b8c7922bc6322f18ea5f9502f0f3d001f91de2c16c2e67a439eb122b32ff6b9953f69f6f446c9fbac588a4fa42a15826cdf4e510d6ae94c608e2e1903bc033c05fec4a13a38611d013851a3ebd89d8b884faad99fa311f7318042b528923b959716b1b2985bf5b9fcbacd6d454c0a4f6010a7f4c7cb414343cdcee1f601655327936073f53040d1b297667de46ddb319afcd92c964e9c92217a7802c470f737dc0beb51596fc6894ca5571421a0beacfe4de252678471f6ac94e7cb45b4ead38da485e5cebd5f540fbabccb50350f3bc9b93816ea05e33fa78df3ebd2741706eafe8a59eed418fb4a852c4a6f8d206d8dedbe1b899a26128c908bc14f42df09bb6d37f60a8c7dd5ca901478f25f79dd36e4b1405cd5da996e5f525589d1898df4f55eedace5362281aa28f1057533323264b65aef494c25b7a0a10636424ff2afd08cf475c625bff0ec047b1dbda212fea0f1a8fa9cd81741eaa3f1edc680d2a2699f6fba0555a1df31d530dc74adb3337da66bf11d8f1c24aa8d80b8a1bcd08b6fba35bf12bb69ee5ce5ae299169d0737bc1425da70fc8c3bb20516bdc870925078c2684cf65c08be95b9fdb27792f81dbaef3434f591193ba011a6bdd8148737078c4cea946d80d1790bb99d279e6385cb8ef68ef42ca96d119d8e33cafee8baea65022bab17be4fc85e7ac494d710ee52b9f97a7ffd81b8cf55a6396d495ea6a95c49ea5c4268dc0cccc32561581f40f0f4c724237f8addf29001db5540ad8ac9c8430b5a6b6780f3d8f4a434dc2fe462c0b093ee894353f0a0b82e7a9ecd834b4e75a656b75bf2eceb02f668433b39c97d13bf2515b5bf1b9b328e94b0fbedc340fddc4de7d52172c9b19ba9a9316ff4b77a775a349854e88cb96ec275a3083fe17abcef79258d7164b05385750798ff16045641d7d690578a55ad59842806e08364f1d05b8b53761373ecb20334462eb83b7de260ccb1a35366bb5a9b6513afd338c259e019770c36b384df97a9bc8b89a98552971ace189b5bc1b9fc08545119a2bfcd16dcc6957b9cde3d4558912e7fb72b5968d0527fbea170aa45aea51332ca76ee456f0bb3a69345124379cc432a6767dabe83489e16646469615989fabdb8f80e05e159bff687e98f87c99898fef8caeb66edbf01f45c8d727031fb0ecbf9d65f0fea9d0e902100e3d1c77c480e62de80ed66e4cf63fbad5cde70cfc72f3ece55f9119a299f3fa87b6d8a28c08002fb294aafd2076ce7fdcdb8845a23db5dd6daf0b4671aff57600c45ea8ca4037d9b3d913dacaf4ab95877d4ff93d54e91dd90aec480e976f2da6c861a559fe80f976a76a5d35f7ccf29b8e0fa96f3f34ff1a000a6b08d0cb65dc1226307714c9c99386ee4ae8eefa643cc0d21578e25d54b1fd22f034a0a814bdaec38c8448f30de6f92b9837072a38c6fe256b92ffd02cbd648c1b3812307e6cfc333d7468cbd4179c9468a3868c3daddf261e9f461ed09b325641dac5e00934a70a8e56c67793d4c038593e60a05a926b753e32160787dde53ae3d766b6f8790da6b94d9b1ce4c4cc5e01955c3b3d2d0b56751d58ecd272b633ff2f71fe424bca128b9badbbbe6a1c522a1626ff465e8e53a3f5e5dbd4034900cd18b48a0809b3c97e1fd8c5cf8351e3e97ddf1b2e38b764b1b11ebb34bafdae963e6b5ffef21bd0527ab3bc328e89277fa67748c1e3ead2312febfc40f4978431e7b0f22f989ae3f28534b03ab8c861c57ebc3e19249e9a07cbda4f80c79fd97f483a29e90619e3c6129196980","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
