<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16fd57c1a8df37394533ffeb1615f292bfdd48162211eb2e168b5973803ca649f7d29e49c3ea6a4c23f486936e41e9ca59e1150cff2da94566f8190b5b206d0bda7a969cd96665fbb161ec6c1b7a9ab2365b1209cd1d9f8908e9669445ca8da0c5335988d152b3bed7d996903a37e58fbdbf2df1b389a7d4566933ecbd197e22d29936618f374c2f507c988ea3ad4d9e9cabdc01f043a2e3853e67debb3cffd0de04cbc11fb47bef8cd7372214cdf92012941d2886d5aa420b86d30f7a3d64e965db32c6e54956b5c573697c9f18f653bfc2d61208f3cd61430b00e76d3f1087808fe8f023ba7a8176bd1657dda21e70f612278dfda99d682a2f927995acaf03ab0076c0c4f961f2a482908e60249be0b5bf0b2ff1f9fa0eb0d0a93eb9fc3a2a642bd231af9180052b3a5ff60e2908435370d8f01c861d1f64eabfb479c4d3fd3ecbf8bcb639c15f015b0914551274479a01f05deb5d26337e1e05aba619ec370602bf443756e846a382741e83aa518798b27f3eea293bdb65be7b3e5539bbb403c0ce2cef8227ad1ef0419f69322500f780c2de81d90ee485678579cbb1d4dc922bf05c92ac5f2d6c157dd7da1a1d40d992a0e515b5afd2327ffb80859bcd35662d68c927dff83071cee34a63efbc89e41575d7a92d44c5a2aed7513edd8a756a33ea54b18af32979ee8613db1fa34529e524fc6d59c739ffd7edd64dbe7341222a4f61cf771259ef051e7c2670baf2c459b1941c7aa445a1413ed6a01864bf57afb6931846d4c234d91590efa3b419b2013f443a41b7d025dc59f8dae97f2532b24027e6486a2478c9597bd94d75e4f795a57b3c18df60f8f52ba6d1e41ce2f7ed07e5cd14c969c28d5f480138ca43bd082be2cb59e8755cab3cc22ee3528247b35883745c8f7238109a16f06d93548a106b9287737bb47bc0b6934b808ec98ab0dd019510c0d5c96274dadcf0b55ebc2fc0d8f3f3bda44a881822446d9bc311110081298320fbfc31be6eb4dedd9f0bb976bc005f79c492f4d3c66727816f29880b6d3e7bec044fc9cece691ea19430e2f5b1793f5322e86b0d48e05e85954ad8b9f0a1f24d37aa4c1c630f13084906d477340910fa4f7065de92aa2a040d9d9d63cf7f336b1014ce2ebe5f0fee0f143e05ef0b2081cb373560f8a1f128bc9e80ca05da472eb50d1a99413c09b22eeb543e1f0b865ae511b8ea20957d4cae500303a36a5ec8ce6a3c09c2ceef93116638cc967184d2e685821ba51d977771f7c24c9136c42550d02c65e0f878d66b09a89c2225c7dc0293868ad6b379dd273ac5415ee01519c2e6b129a0d1ac3d7c4afc3f1c84747facdbd7ebd409e47ed2f57464eff25be189bf8c715d801066b4a51e6877fec4c2fcef27585b830f13f764f2743a4350b8f8147fb5bbb65f1acffd0a1039e77ee799d4c0c75c6c5edabae5eb71f40b7427c05951fb9518087dd99aad6353cdf6306c7e16206f13a1352a2bec971b3cebd5185eaf108ee415a511e68199d4be393d48065927f1c005a8596599a94d14430f908c75b5572941e85f6993f36b0c4efcd51cfbca606d266029d32ee106130a90d1cf6b3b3d7513cc55f9fea67200b84c26b8006f295c9f22796fb6153da38dfbd274f6655371c06a5748f9c525c3a56e4ae9b992795da78bd1fe94080ec392c1e40a78ecaf492468d3f10628cf052d5add148b049024773319daa94b43903075415a563e5c1b3569d256455460b48c38a034ebb5f2627fd460be592f5575a31566279b7b9a4771d69aaf0d89c5944f95c1cca6bbff0e78a8a207bed93df4b7f2fcedc0ddd9a6a63e77263c85aac8df4f1082098b674e5f0201776391ebd0b4b8fc175d0273dfaa173dfa59b58941787484f8d6456b18f6848f93e1d0ad455ad8addbf049aa00cc773cd71335e28250e2ffcb096ef6d0501654e610cd90b03f74ea283b1e60bd17dfb687c86b63698711dcddd7cc182a306fa1ea24af27997477d5bb3827fcdf5b059a1edbadbec40e58553564b5efe9d952891dec90577a600c42cd01bc883bd79c92aa419ffce3b0f94d8352cae3e7d8be81e041fa55b2cb96d5d120b4e63d706ff5ba83ea007294b56b64ddf4b0f69f64782e29ab6cefdfa2de76cf54f7420b84e954eccd55dd5a1c26ea100631bfbb0b66151f0d0407891d94c0b18063a2513c92fb2f52492b41d6fd6ee72d286c03b48e6c91a0e8bdd50c98660a5a9ae930d29e0bd1e60aa1223f33c47e09ed54094ed8f4ed5b431ad79aea2f467338877f4f044743cb24267df0f85dcd1fd0fbb580074f413110441d91114fb4f0ca7fb969419b165a554aa553089714765a9301922c0bdc4ad83514243c8f51893afdc7c424724adb066e06c7c6281d6b5b5ede4fd7093a467edd4d44c779216aa7678aea61caab3cd48b63f800405bbcb00788dfea6be1d69fe68942f6565fba6da21e500736fb27438afb30545c88d1e00b5a406d50b32cac53cf47b7fd2c058cecda58ac49884bba29d8c501ef719bf16c051c518bc85700b511d7b273aea65ebf98ad321f7e3817ef6a6ae473c1acaf3154a643c96e38bbbdb26cd2b8e564fc5f5791a5b05ded0bcf7213a7394d5ba46351c24ceeb2c37b091b212d5261f81319a7bbd4a6a712be97b06a29cb21014b167bcb033e7b71c5a22ff26f008ce5daf5df8af23cb4f6a4ef2f445eeed2b9ce3630a173dc5ce91989c576da73aecab59a2e0d88bd98c8eb6bcb87986973aae745980330e122841e8dccf1347f46b2cf1404efe73524993f1d667d3a1dd0f987ef21ff1b3a04933520651595c432dc7cef0c551b59dc899b25e35358fedf8067eddda129c9b5fac045f4dc6e59ab0bf85f96f0b3c0701c08988104baedfb88bc43db2ae429b9655c44dc3107221d0d7d2b7c820cf8293d532b48f3c21797ffa824fb2902f65f13eddb6198a01d22f90c8889333e75b5f91d99157f9efedf1f3bf6db09a9af9b3877d7c1b063c82a2c5eb4a7d8dfa535edb406c21ff39c0c73cef1241779fbb9df660bc8ded303855a57014c6aa12f4155751e8d36f11bdc70d552ec24a837a83d6019e88b47d1042429e54924b522acffd76ca8df0e63b5a742b7b366e0c94b407ebb1d2c35c3ad30cd61d3adcdef16143e19ce30b6616da5517e6825f5dbe390ce56f1ec3833413f7cbf41ba8dc385634659ad936c77061dc2a25753c4428223ef41850a66a631fe16ae2879ee1171db67cedb169ea3a73ef6ed0e819d6fd2862e7437d426749077ca3af10f9e9ee0fa753fe58bfe2ac0ac25a2cc2d61b2a960ade2657203f4e12772c9f82b2fe41b64097b30653dfedb573e455f73a36588e5edd114c75e3f8dee7088c6e43d0b499c6684e00b0620864bd3532c7fa5b2499f5b43b36b7295e14022f9563615bc5deab141b34d031b06fe1a413e9828a9b9f9e5369e6dd623c35ca5c7ac1fed4afc4cc9a35b111f7dd9e0c6e8744611d52b2687d83b0f815f1a95b31cbe1c263a76d1d65ad44c3f02ca5b0962192cbb58ccf642a66def57de01d88155bcaa4e6060917775409a2926447043785920ec57bdcaec139901ba20bca5750717481bcf4f4ca91b3ad41b6eb1dc3763ace6ed3a7c7e96229dda285243134aa735811815c0d8a939fa2963cbda5e7d2fc55f9309831599ff20cf9cb1edd20c71810dd14d918c0cb9e52e038b7507c4c24cba195bce58cf3204e10fcbd13b8f73d33a9d930280fee01c2cf428778d4277737d854f295cfa239eb3a7e0ed22eed51f11dc549bbe326348682927164ca1781f6d0e2f096d8ef5a6f1a0d172b37f4163cc25726a1f14b2db37fa2babb8da157e87b9ac8684fac17f840212d920f287360d70f2cf635a7bed333d9a01297ce23b3d2542d6fca707bc53bcd7201384df8a04ecd081f4225c2b12b68932044bd9a0748a86945de6574f04cfaf27d170358a9f60d9d52c3fcffe91a66f4beb34c4753a3781d7266ef1dc08f5458a306c93b7ae48b995d78b57fc3897d4019651473c00eca3214516f07174ec7dac739a528c31e66e213e853e8f05eebbcff3cee18667056fd18d846c0863df17461032b682be2ed37eef0844b855c63fc769d7bfc4e8ac77d1464e51b54b98debe4d4474255848d2cdbb183eb3647237b2d18d8d573faa68010a29ed1ea3f2ca4a68ed3807fe45933c8215a8a1e8728d2fee284ce9f6a18629a310af1d63d10134b14a07c8399f7375c635f61b80aa2a6dc896a0c0140909149f247c0e80ee7e976985199f3383df5dfdff3e447196d4066ad1f7b6106dafd070a047b841862a477e6e5494358589252b66c36695fb31e2b6957da491a62f32a918aa1c3dc6cceaa5b02af120c2c6e5cb2316b148b999c51427b9ea66f1c9aeec15e5b82844aa19bd97d9302b0f5e23940fce345b88a58e58a1c975db7407cc6be07302e88056677488354f002aae4007bf7b36f4c1af280f1473a1cecaa6488a9b82b662caa97474ec7231a7f2f38352f609433782faefa458db3849403eddb7357b4093450f1355ffa2af64b882f393e1473ead2c994384893f84f503d15647fe1df2c31a9b7358b8604381882cb5700c388f7c1fff416613ec85d029e6eff4ee9498c1d6e94e7966032d39629f9a1f09a5ad7a33b7368004f7137d791d52a0d639f6aac1869a2624a0aff17dac0d7c83d7a232d2418be69de1912ef197815e9a55ed4eb9ede32452864d93768e7cb610ac0aaf367983bb2f9ff92622e7af6b940e43c7858a222a3695a9390eb5a5b38153d764b41ae60600ca27e51970e8e64b732194798bd443084098f98ccf36abb11f5009847b7fc3abd61279ec000556b0ad5570012d25e8c44c574a30717a0ace95cc5f9742037da2506522c455a9f1c86137984e24491045a31fe8d45045a254b5c735145a6218eb64dfc26076ba698742cc525d7d8ff30c6feac5b1bdc060a50d3765e5cb4b043757c799ba625af428457c17fdaaa8a2fdd820fe8589598d1aa99f7b21142ea8aeeeb2ca97661c4db46d140f3bad99b5baaeb9fcdd51e004e695f0a8c4e6e3fe4b26a30909d45ac406e79ac56babe8c2034e2bbdf8f8e6e4e5df135687e2189f752f231ab26cd674126ec2419af9aa9509f6b105ec6f9a74d42eb6dea122959f103692b548e21dc838b9d8e2a70869dafec3f280824580c3b1e785e30f7e2a07e5fc19408473f86576f073dce584b24234c660fee0ee5a6079cb7ba3e5e36edbf84298c7d056a397cfd23c7fa92c56deae32aa7ed683f5042009c841186c8261f348df356580d6955cf03f68c067485b7d27beb0c66b8f27d987c51bb05e6ff83f8ac020f6f86fdf9c1ef909f430d86eff38c99885da1f7c5edc33f60daa980629b470c1715d8a6af4f07d4ecc4f3f0b97663a2cf03696575b615fcfcb200583ea695e0fce65e7e5bfb48c36d5345e2224fe7ecc4b215f652ca9ba44cd2909ad51ee607e9c915fb9c36612df9101cf7ae8cc267789b316144432503551a801a283c24278eea6bdea5bce506ba147bc209239cc71c29542c696a25add88c50ae3ce8ccf086de2e2d24f4590362fcb155853dee46b59bcba635d40e2675e4e697d8540c3f19e81d5a10e5d4d7e8a7aa1c6f7e3bf90112ef0ef2331cc9ce5109c2586eb69517d11b4eab34e6eba521cfe28c8d81024c027b26f5c0214fc9b8ae2b377586aeb088c431c411d96c0e6736edcabe99e6f5546fe525bd5f9d62253a19fb2f530693ea8ea1d7d9d3a8b107f1b563bf9edbd4d53465041daa547f5c21cc94268a2158c3da3eff7cf07e4f128f7dbeaab63d8366a1680c1f8c5ab9cb9105d6071e204fa0d8d330a598ef4febfbd83de2639472fa69e74fe59fc4bef01f9e4c74b200b1f278b8120d48dec5b9832d1839527b199dad9970f0b97148c190a6cc787f68c20fe7fac1f3bf6fb245239caf9495d16d276afca29ef95e90886ed26bb0b060522cfd6a59828a670909585f0c1a01580c8b3942900e103543587bb7ad2ef8dfce967418dd0de049a0a3bc6f3adedd7c2beb3b900cf79f89c2462952696220a44f6ce8613d3a13d1b99458a95693c95aba1c8d83b4a90d736fab8090ba8035e0af0a632a8b726e606a45bdcbea5f96752482d3406be61890d8b839604e8beecc1c58cc0b2e60a0839776fd519f4c1b7ec3c922c823d6f82b212c525cf640a5c03349e3faac47a9df05cb95aa3aca055dc92f96dafc556e078f1cdc3f2a4a6125e091b73d72c290b6ae111303b00a6dfb02c0d40d1158d7e2abf43560d3213d1a14a38d0006f75ecf08261d738ee9502c6f077b10ae2ae50dd2225f46b1d3f58d854fc7644398346d8640e2d746f72124653d076966613b9af3f0f44346149865c1fb67cfbc2dd8f9da6f6e77d40ef823695304685a8b5c454aad6684fab729350c28def8647a3b011a778dd1096c825da4206a39ad804d1c33cf5da9dca5651dac4b5c3f2d135c78e31106b522fc53524e2406b30ba2c8df9f283d6b7113a4aa4baa615c9ea17cd35f2f0a087130675ecdff5d2f3f5b7492b03ffa4565994dc315157f1a8f492224f7e8c3173172c514d806c04b4dbf57fcbf996b9554d28bb4a3ae96658bd6669441a88d3f50510ff1c77b8b1982761b2c67bf1a45f1a7f0bf96a2a60c9bb3b6c2d8c5119b11c5c860af9fdf9c667a48d2c7127243657bbbc2716d17b5ee67f4bd83f8602409227704044b3ae150121ffd65bf12b39126207dca1235b34fc7cec40538a75c40f6c1173db803bb1ccced33da1c5b4d5716abbe5ec2b80ae115257305c8673025035df3a757f0af9e1cc80213531db0320943ce16f6d32e3b7e63d7648e025eb35078ff7f502337d3100aa5c457b9f95834896722d2e061faf865d1b2a696cce93a7bd56c07404828d4ad8bd35c9ba475ecb8df3bd2cc0cc68f8fb8aced4540ba640ef3eb47fcc79710cdf3ed5378f85bf47948231e5a8c7ce6cae2ad682d91c275da17f98b92ff0495db8fca37ca352ae51610782f99feacdf4299168f0f63e9684a71386eee262fc242b26c5d49f54afea69be3343a71e22d9a4e9132d738e7e002cf1511ef418d9170ed770c65db4f6aa48f74586ad46450c000d8345757b6074e66c0e9ac6847029ac2a06fbf0c81b43629fb1e31088194a9df01122013858f976c8203f880902cc7d37a713c9c7b7c2c42f6d3c1b72d9cd682eebff31557e28a23145847cff9fbd89bc507a45e591ff07c01800db2ea98ea8f21fd30a633514b85ecf472b4f13a10f242877a5dd4f226454ce7477e6048e911459454a2a46a4ebb9d405d9e90e85b4316b6b5033a2394a275776401b395460918b164e68f146c271d949843ad7946af8622c7605ac6fddbe6eb103a546e0f15e30312325311455c8a6c40117cac1788b84a003aa8b0dcc6ccbdd58b4f95e443c7f8aef11affdc156490e93938214bdbbb5b8b3367a0c0c3a65a39f1d4ab72b3e03454d64fdeb02219b4e9ac6a34c32614dc46ebd9344a1c2e085e2cbd1818a7b9880a71290c986da7ba14f5bc63852fbc1dd31d1b02805e229505135fab79ed3c4aee6f410cabf818b72963ac4dd31b2c3473da4965251ac0d3f7655fd3e4db9703635aed3d0cba26476704dbe2007dc9f8330c98362f8b1cb833a4a809dc63b417c25b3969d64b1cddf97f3ecebf5b2d96f7bc25203025e02ab9644d8a10fa4640df058c55ed910831a338fb643c43c3b28611642ee83acd5193b4ab2159a145c5bdad0d2127419920232832e2bf22e3f5fb50ddcbe5fd1042401a48077a21248c25d02b5d007a15f86af9d969203112e62889bb57ea025d21ea5afe4faedeab517782b84986f225c1994168701dbc0ede3506db07bd73b6fb5be2b2bddb20e5e510b2652ac60a5f6a15e60fed8615317b77c5c9b5cd33b27830d699084fab83a97e2dea5962fb13e7c86bbff325e35142650e1fa2170805f1dfc466ced973aa9adc755f5af4022f7d115502ce656b6091ef55370a37ab875b8ed4875637cc5515e847147c59939bf65f572be264d28a35164dbda352b3e3ce36059e2d202081cd3bf83c6b81992072e5b17b518a94f8b5ba30df11bd2d0270fed39b2f611b34d973fd031645b40d37158dba24e66bf2cb4d84e79db4e8536b36222c09ea95b1f2dd1893657550acbba0e3f94a24f655f160dc4839b713ec30c8fe49d18d5bf071191921e4f0a425d88f9dda564e770ec607f562b15cb9ac08a45be729683bcb3c08d5b9a3bf100ad6f20010787e034037a6ccc078f78ca4a04ced42577940d1b8399ac475ff0b175988f39a9a0239c571129fb7e022ccf6a27dcfdda4f197407a9472cdb43fab55805f651e47f9a90c7291275495f26e154e2704b37c155a86e452f5159ff2522dad609706c640171b6363dc8593802c181a7f1286558d043e8211a98f13a4a673b341ea5d220776b8458bddaee1bde58c2da2898fbe869cdc402f60fe3f3c10482804bc7d7ed7a4e2693e4e7733661ba7b2a0804d39db51994091d69f54c8ad32fa7ef174a1abbabb86f27ebe48575cdc75d1352ec7f1b20a821efccc2ee1ec9588ac7fc3710b2419ffe10e55b301124630f708532c18add85fcf6f2b9aa8d40dfdb1eb56130e908b3b487b3d1e67f384e6fede9c4bbf3b4714dbd629e5b094c4ea241afd421bc08ac83d58d4e32de1e062ee8fe8cb0209b822f544e91ca1920c9d81e151a9d9a54dcc76bab9f5cc8ebe067cd6d4114ff816cd8a3987e9e8ff729150796803b082040dde6691f5428320d0c5289df553f8489a2912fb54d1e4244e0c0d085e4e5fdafd81a0312fe6c93fdb5529d0c42bfb4a0572aa911ff2dac66ea7da7b1260839d5bed2bc55252e09f25546e4881f410cd6865849739a5bb4257b64bc4ae40c3ad56e638c467843b66b2db0029e06498c199f6f88bfa0239b840bdb8cc5108f3d7d388355d650def1a1f31ac0998f76ac9d84ecc4b220690fd357a72173e04c296b366f71155eb2a9f191fe0bc5da685591c5453fe8cb90f8b597c1fd49093dd40f39c91b2ad07c1001a9d334fb720105dacf992ac5e23c5f49044f6714faf191b1eb40af82cfc0ce57032cf47921c0ca5364a3d76015ce4513f025bc97123ce5652ed46ac3e239841ba091725b8f2fa50390c085287bef3dd31c8daffa001d47d99edfb2c21eceb909a8efd2932eea9fe293e0dc1659f0ca41e14b0c9d3a2ad420cf8aa75af4f313510d6b3a46379a2de39f4e3662170dcb2c9ec57d761f630ea49f9fc92a64ee7fd5e3cc87605ab6ede281441ed753d239b1602c7f26b5944af5bd2545505f2b58fc434695bc5b21355f660f2d052cbdd218d1eb523856f831e4a847de98078f9226c496a3e6c1479d8c79d26b7072ad015083c576d5edc8239eaf1fd30bcd8844faa8c6bb95fd7d52c8bc7f47778b439598685a58ee7b16d13607f6c02b34be02a7d684f7c669693c3cbc32b736080f8ff6a790c319e2cc70051d00932a1bab4f2ba8408ce69c75606ceb62d885482f61f0fa67ebd278a14aefe1b8148be44406b2ecce615c3d32949c402fba0ef993750084c5c340e6cb34083d53658b246ffb33a6bcfd35089948fb7d3bd95b2dcf0ea49d35f8552ca476cfbe62ff2ff60383e2662f9fcf32d897f09e2fbbcdcef3b91ea527caa0cb2ef12ec6d1b0c5f0dc2253451bb9b5176368a5fd093b738493391b69781804c332e870ba6b84befccf2886f358845c8c5207530a5e924293c06da6f40e1a710220aff08b140deb122ec2550ed2ef7458ca1c7879711ad3fe4eaa078cde802b75a01490dc72baa6e8e0e992d1ca087ad0574f5d088331363fea780da711e686f54c3b1b8108f244fba905f00f402cfbec025e2502465b2e88df47887ccfa593ce0b0681f85f92f5d8e526d85ff1e1f6c0e4ac6d057c6fddee84645c82aef8169a33dd58d59b3748b36b4ab6b0b1eb472f2f11892585b2f326a9009949cecea1188b0ebdcaae055676613a928676e3eb8d65a89e1bb3f46f1098e5ec2deae5c4fe6b28a03c03a552b6e1677e421655b4069e84275aca443fa6d00c6c743ec8de3054118ec5c1b8c14caed8c0681c7335700def42c969ea65df2f78a838ace0bf27fc88489da7b7d0a62332e08753982a3aa62df75cb4645589aa242998d53b1f8ad680239a18a30b9f3c94829f4ff73ffb8cf75d628c41b7a29240e65bfca167858781fd00a045533b2632fe442107a64d195f2cc776d2a03e22b3722fd24ae938049b812b3abe0247345e7aec873d9b7816a0b05816baaa7b6b31e75806b2559b7f48d54e6d5d634375d986f0aa6018c5f09d69349995370511f7e73e884c9616dafa4fdd3ec25c06a909ff72b90701556bcfd2fc6de1268938ea3f21354fb05be98403983772bb8d42252c89c2caef423bd9b7e66260d824fa5ad0f3b0cc3ebcc1462f56a160ba1e3b502a6469036bdebf186c1bf97134d7d7b4f19b062033c36b01f19f3882daf48493bc222e5866fc635a3563a5b6fa16f7b252372c374f9e9dd061708bd2240dd8b49ccaa471f9f83b005636328df1109a2bed63bd674a0fd2e46f6286c64834cb689cfcdd3c88f0b5ef428315722146e3c373a1766225ea75425ef639f356c64fc275fd98af7bf37ae3441a0abc9236c75819d82756509a1655f524eff2e56e3b7be69a5bab28088855b33655c99113100ee8b5df4b75f2bd01aa0ba52b2be725c4024bcea132fbceafaeb795ef08802258a0afbc90c665cdc5b75fb0167da881fbaf0b1dc91b8371ce3c4aec997231fa4c6c7851f6f9ee062a55ff6dee25a6ee2deb3b055a6c907a85d66ac81ab2b77bb3f04fdd563a1dfd5068f17e1295efc0cfb51fc661d22604d03d6b6d901ea1c247b2bccbb8452c5890232754503039573e36878277cebd0add0ebbaa716d73eeabbdcfde037eb2a29a41b651470223d9eaa766f33a8accb38e9c8bb17583ff4c83b94afca66a62fbd43f6f793b987c5edad640d914fdcdcd30706b82d107c7f677c066a737b45d19426f4ee299fccda732374549e4f233170bcfabd77965173828b8f146a7a66203dfd2255851c8483a599962d56bdd5e516ddbb4a498b1d29237c4d2da36489cbab5900c31d62e5755ea7e046902f5c4d14dd8ded2986a6d4e8c7a57ce33ce25de3c4cdc05bc742f91e88ddc2a75c586922538c777446468b9b39f719e89228192029eeb3edcb955c7bb08c12eda7f306a90e404db32ddac49408a0186845bb40f620b793998fa2ba3c252074c58c60d5eb9710cb2f39fa1b9683714052e3f7e196e35ff7c7e5eabba4ce07947b07252330646d16b7cecb802b53f63592d4e681780153b227b0e7958cfbe196fa44b8e32136d85a1ab889c11227c3b97ec4f5818be5a32503cc5158004821772ce47a35632af5ba820ef95fea20cc621f250df3091e5fd155a86fe2fab00b78a6b64ff8468361f7b9fda3bf7e2f06d8036587f32fd0bda37f8922ddd1b4448f4cbc111a2240a95f713cb792eb46d921e5e713fb4eb11f4ef6cd006e8d6020254e500064dcb569f04a3882e8d71fe7e723c2b72cff99cf76ff86380c7bd9bb395cee94c7fb631c4bd1095d15b02e089d05f6a979a18777bbcefa014e245031131d143e50fca8364193eb5f3a1969ce5f0bb131dad639602250809237b4c394a5af34094505eb854952c8dda50e0a8bd0928dca8073b5d10b11fcdf3a329c3009a435a1369d9b6c8288e30cda7f93ebb267621e2c2e280bcfc18f458d1a5688b72fe98f3987790a737735d71f8c8ed0b920c2dd077dd455dd87c55c6c1faafadecea75cebb829d1eadfc874be18ad48a4b3029ea0a33a65c1fc214b66fae90d2347a071b7258a443c853684c22838e55bb41f930a641650936a11a542f719bdb46c9a599312d1ce46964cd9c982d75134adcc48ae3c265bc749f1f0341e9f07770732e74f574ec8980d58a0710463d3e5a1c44eece32b2a26a7a87466dfe90fec90ae8767abdb3d139f150df6ff953ed66b16edd8558431edae10056a9ebd10cc17d94331e53e7f9c20f359acbd1e34d4c68623386e6ed14fd15c542ba26c49213d3a74d17bf8ef53c1c9b6641747143b8f6d3b0836a8fb66884dbb5f3ca55781ca061df08fbe39fef5312450993e53ee133380b733679ab57ff8a6e4aed307fda822f56a76c754ba55246c1e0b9f41bd6d37701ef13d8d11c090095dd674eed271426cf75539548deae91afb93a9a9ec23b55c87c4dc1881e6875a09cd0b4db532b8c1e6e643d6b3a1ebd59d2557024818a6c5bc173a7d4fa872cd67522ac15d01e00e24d45248cad274333403fd5f932ab6cca6a10eccbcdcbe57edc903ac16d577a36a893f6f06a6ab674803de6a6f9645114fe66782f47714ee34dae186ba6f018cf3768e4c4521d009135344536d13ebbb882ccc3990c3a153f68dc68900557d25bf1896c5c69343a17826f11892802ddb9056d96ede87c5bf7e732efb578e2101163fb076518694a9b3462326a74a3f53c309f6ce3b9b02c3721cb68694f23a6edaf480e8cbf93b0940f01bb19c546a92507eff6bfb699396aa64e81e6b337d289b65a6b90f47fd7d075f6664ca663d5f2fba1829f2111293c6be77a29f657e03c9abb29b99fde98428dfdec000aad2de40a2269427c532ae3d9123aa171539f6afbf52204731a9479abfc24f04353f915e9aa1bd43615cb6ff05ad748a7dbf8ce37d7dea21d42f98b4bc2c4669bbf25899ad4e6d31488adf15020b5405537faeae79a26632a81a13494912961655666135cbe16371a23e39d93f9dfa46f8062f4e5a1b2cece5d215647852c0292cb06e7748bfc4dee81d3a78b802201c5b34460e4bb13d33ee562768b916d8f77ac3a64621bc07aec1e3ac0d1f0282ef3fc82533e7fd01cceeed71136d37a64ae0973a2e4d7d5a5f8504c3f9505d854b2ad6eb128247a33e043d104e223392c5d6b51257edfffc1c7659599a8cad72f6f1dd10d40612cb9de004ce6670461f8dd3711b0a137abe76f0c840c065ce6519f87398fbcfca7e2a42052310f7139de4e953b58e256517d7e9456693c87c12a0f3ca5986cce3b3b53240e31ad437447925a6fb9e235a92eec997f0aa77543c60107b2c8824ca7cb0bc1c61ee2c4913df80797fb6857428b43e93a6ba45dcc32e18cf03836f928fc6b6def69c7e1546675512e1fe9433d0f2e570cd274751c297ab19c2b6bb3fa7ce3c0ae97bef1dd96c0a1327fba9e1c2450672612005521909504f9097971bb5f71ff3377ee4963683b0677097eec6320c6c6d8716694348e519f34b77cd8b9902befbd742764465f7cbb2d1c088afae894b30ed16f6ef6bc747f058b9e0a9decc1b7b8230971924bae3ea23ad9b4ce1dca095002f1a73e3a8844a6fde3eddba8ed366373dc7c540040ab3e7f6fc4ad4ea8d76493cf73a3faa6c1e717f59e2fce43acae6c8e0a434e49277fd9978d6c6d37b95fdd0c16df32b496be1851b008b35b522d26505bd9f15c7304e47f71eeba0a2200c344163bd551e8969c3f4436cf902b71f2e0e83ba8856c0dd9680e70a4989c3e1f0b352599b8d14ce4a3c28b36b8cca7f98da6083ddd75f3101feae06501e0dcf0d055f2bfde2c8f300d975b050115c43cdc5d63c78c921e8a5484c04f090178a579067071e49522c12eec48aabfe0acdc5860198b533b72c83912b1483be4bf90b5e3308e1d97ee1ac08b064ca94a292b867b801e664ad227c5e88b19cb1efd5e47252e9ac56f07f0c9bb7eafafba72c7eb8fed690fcdf7bb8ff0ea2e30271a8cc5641fba77b27b0231bd9fc71eebec85caec16cc83bfdcdcebb3b1503a86e6bc6ab84bba699f75d404bd6c69e681b00a19e205978456a42342ebc1d0e08dd501bcf979b3e7cb515cab74b9a1068d6ea2a28af42725b83a81880caacf8a367efc0c66516f0cd48c4cdf55ccfeea78ad3377ebd163d24a64a6ebba4e193bee6fb7612495083b8946f39b523c39a1a5e108e7be7a093a6787e20cae98519ca50a6783da4a91789f4fc0f19d33afe38bae2a6396e45c3b81b59ac9af4ee3755bb04db59d0d84b46e20cf834ca00ef80c4c6920db74e237489e7bef97e3d1f3bd21d68a584329f89fa4e526ed3721bb4bfd43cb978ab73504c20d0009805943607f06a83e370579919343355004480a1700f93ca963866cea39de7c414dc3338d29e230ffb87744eb2ce57434319f3fc44914cbe98dccf16dfc7c35b6cd57a482e0c8d22e9e87503a188793b35ed5e792b6c4e981df9f5034e87b2b3f27b89f3152d3127c0a40b4e0907e92c4852d6b9333dd4769a93dbb1a500efd68254a87e9e827645d450ef81674e280f4277d7e78c9aa919ac617089b222364b35146f84852cbb391cf527860d5b4b3539152e4b500c0c8d38411b5a22df155ab8ba655bc2e3686657e87854fbc200b567f302806c94ab69e99cbacc93bacf31ac568599bee8643205dcbcc6d90f1398814604eb991ff2ac36a35a063406cb1e83a3cdaccf4718cee140e97c38243aa45d545375d169cb26da825b4b0bd1f637b7e1da1f7b5f27d2e0777b6d99d33f768455a0a86da78aff94afef7ff5b809a9f3fb284e2d1ddd956775e441e89c7897bc1edf9d4c1d963747ace308c9ed9685174c18d21adcbb0b006f741f334e3f3f52a534c74404b62ec3e63e502135cb887245fc31b0156f989cc99d5d596f26e0600f11a0da5d8997ae77018e07afaace4e8c6d05cac1e590c9539f8721d3d2a417eb2b369d52361ad566971954ee47df131b5e8fb3b43fe567b47693862a5a9be9801989b54561c19a05628cbb68e463e5e1897b3b4c04bb5848c8429d4835465bdc87a00d75145a19fffa144fb70d29d7a9a9f40f193c74e1ed16494b60b6c228d8d80588eb98042f68f2de0c1d12f70195faf2d32b16732c6dce942ec410f99ed834a492938493126600a1954c98f1077aba090603e5fb4932d7331573d0e344542775e22b78fe8a44071f7a89fc768e7bff7f0f137797d68424ffefd39be2310969c9ecd4701a7abdc71ae905692d85f33bd065760c3b065cf118c734fb8fce23f23e03fbeed88a19309435491b9f20bbd0d20c45ab815a24f961cdd3df15f7524d8fb4bd76cb619ebb8dc8ffa2f2bc046ef745f34e8be06ef5d0d0c47c3d1ad37277f89b06cc420c35c9cb5f37ede8b9b17914ec27e014eda7df42af91a5f4b7c4924d47ce4098876f8642e69f5c1730d85a4cec128d1c37b4c6a80d6c9ce021ec9b985e401a31afed90cd6bb5239859902f9f6e2485529c4f659bc16002c5936f5623f84ac141cf201128f4720ce897360c535b4e3f8d48a0b8700af0cc5bd2230c07c23cb326ec738fa580468f2acf1968338e6d32d08f3cc52d42e505c45bd6b29e59f926eee16b985c0ac2b413c17a1684d18f605ea140293f4cbb39433b576e78ed1534331efd526e0a3bcdc170f553f93394a26266498d7c2c6cbf8528b150ef6f46b64354992f4c79023609a8f08a26108b09a6d5bd78455fff14125632f075f5d9a34424b9231f20a90fcffa46477519fdfd5208895532127b15940c64630ab23005ecb48ee589e6ae3b7113149fb35d8467ef0ee59c1251ae68361e8b51fd115b9c81b5b0a3baf29be64ff1abef83e8bf601feb071333126286f8b432ec0332e79f40c655f0ed10cff027a148658081962c7877ce08575f8d9522301db40810d665f2db91e6a2fc03558ff2425207959d168f60626349b98dccab3f7c333f6039c97fc29dc11d648bb61aa04c8f0d5e806332c240a915cebd93bfe408bf6bee21dcbef63fc456c45af5a94ebb8f160f72e133711f8231b29d92ba85453e22a29e310f76ccb55c49c20cff3ffc84d2f6d8270b527b2eff27987910149c590374d12a589e1b1331d76245aacf2f98e43f3ff532523098f39e4b015c7ef988c0a1dccd98c28b50b739b3b9ca89a7ed466a52f2bd20ec330247e65da7e81959db69d5e9d7f58cb8d1a1db5dc6ecd97e4d6a3788e152cc9012f7eb974df0b92c6c1743aebc4dd389a74aaf5572fdffba468ce06b2eae15b2a38285488e535ef043ddc1e9ae221c05ce8623f4bc8c7f85dab7bb0c30dd08fafd4e3e090311119e4f1ab23ed428a442b3857e033b95ecfa5f978e361a5471352b900a9c805311f8b5ad1ab8135ae1366079181f4ef7d3a9f929f599140afec95e07a618d479dd3c4a6a31842332df47e13ec9b25df3aab3fecf470570ea750a1511e267be743e7fbbf0d91a6b3f284f5d1b0da6687966a4594c0bb8b788d36e229f7e6d1e2a11ac07c5d0caa8b76ce04ce572d3a357da7b931b7b0345018ad5212c9f323fd08232325ffbf5b74bbb13125d5523a86375e8754f305f46995ae613e8aa2a326b28cc1376732308ff058e07992640a0bb189828a83b2b4593b663396ebbb0dbbc9601c67e1daab422543ae66dd8082293d5a7d29925d7ca1aa641d838ba5a7ec6af1b9415762387fc1594b01ab224b405f8e57930933b56753b16adaaf5e2fac70cbdf9650864a1816838836bb10bfd150d0258b051a5c664c2664c08ab6c8c96117c06e92ca4140cdfff54292cbbe74ec0e4ea91c5b2f0271f09a1ec2214ec4aa4ed0dd22000144fd1851fd0804111e68b99fef3605f3efd41ab1cf0254450bcd31bf8cc37498dfcf191f59f8473244728a8812e7e6b8a91d880a08b9400a9f1599c587e905d1c8012d59829d5a3e043a505398ef7a7093fdbb2015a2b92f601842720a7af33f37f0e4984b3179543b7a157a9115c26befd833927b91b2f7e9329f97d41593ebea5cd3208c7746f287131e82a369cba7955974e4fca021c4590913179ccc72e71b1267022acac25e50ff40b769ae305ecce835825731d79b1b4f9c2cf2034c9598d419de7dc59c44a868705c03cfff3344b2dd271882e236a99d67eb58b8830d3f8eaaad2b2db65aaca5bd37ebe8e8d22cb43346cdbb041965967f38401d5327060a5f03f607d025ad6f47cd48eb2e2a12f336ad0ab5bfa665803ff14fe93f6810c68bd8f680a2d537b3158a296e8bc09d581a4cb29f94ee76e47a7c384b0e96291ae57317b4d17cee95c82e5487eeb86b926792fb30b791d8d11c3f39b0c49d3166e3b5704c42311a05149ef9473033fe4e82621ee6b2fec5273eac76d8231a17329cde262bdbcd85391aff0b2246e0fd85cc34dc394f1feae7e28575a9435845ede81dc97c36b798019b6d82ce86f101e14e0ddb3409c307c4aa8016418d6fc90717fd2d2e99b8420ab7146587af479ed2ee52f640c8d2c5aff401d34047b2da7b3dbe9e1c5c0bb345aae5460066a11b7d6ca84295d79d4df7df869a0770e9acd64fefb0dc27d0d80799b4da0daa3e023a8a605ebc20c989942bbac6fbb2c29ead2fabdf664cb28fa3c55dcf0427d8a31045ebe2774b543c2939eeefbb6b404e3fe60972c3ccc291c0e920ee6f03318f467769071a960178655f97b5dd8f7994a977de20b55bac4cec2c0b3bd1741f1ff2d303d486bfa4c7beceea0cdd6125a4549bd570da9be55ca56a7a1200266723b1e67d737a522264c71e724745871c2c79b50e2db65d8f6178e35921bfa2c43523282f366a751bf5661f942ea285cf6b932410204e8cf7146237a9ba711f37daa00246fb8e14c691c7a808ffca3f3998b2e273a8c773ceca4f6508d4f49fa53eb3a8f90540417d3f4b90f3ac9ad10b8ade4fd2160402570cc18203a28e2476bc4b1c6e675222bb0069c5c746498fa1adf6e29a4130c8a20f4e0af3579d034deff68f1285b9633ca02424b8109768160471ef1bc8b1568041cb9ab428e3ce878fb8be51bba998c757069948289620ce91497ab6a9c17a1607f88a6fec04c125fae3052d1384fcecc98ff6f6418d4eb4b26f8930188b0416461765277fa0d20a15cf1b9fbf52a522b50f12d93365ff9e90ef5b2f5165c2ac2b78ec978703c7dcd8d32f140ea78aa69544d8061ce9d68389364235bb2974484efff4882018eef001","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
