<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a51b8304f209c6802b269b8d8d0d384c37278f2c9ec39282af04745aec63b7c2ace78d31036e16324c291d1ee310588ec976cd7ec1ec5409073a731ed32d7f605c60c117a69e49508ccce549da9c452f2d970c76e1741bbb4c9a63d527ec7c80f9fc626437dfd8e887ee85d93efdc00ec21c75a690a7dabb36b1d733ac43e50bda8474bafda30f9a9928d11d282b4b8a0b93846f13b0fd930a373f2a37ab7f44a68bfd07e448433ba99d45d3e31555a17b1b196ddd3bde6b33dd5911d5810502844663b46958541b26f319c8d4b8076f1b60c90efe4966c74b18e47487cb499b7d197db2394aff2a12a92646af87f8f5cece51ea83f78bf6bc3ec9a64230e38a70b5515cdc3f0dc197a9cad7aa579dd83fd0636873ddc72082843114831e16054454cd2d265ace2917c82ca10631c89b85c3d437fd1e361e7fcc7ad58490a9ab65606522478caf9b998cfb9aa586e07feb9cd1d6b10660c8865da0833dfb25db030f02650bfe765088eddc541a0feb9dd5a7a10ceaeb88315155cc6d036c429f702e798f16092791a57df5d37d48651b852d08225470eba5fe4f7f2774839bd1b0816e21a629a5556f0f8a7906c6d77aaf81b9d0a6e05368455bb8461f514de2f5e3d1e43fe36dceb3dcdf665c5c37654d4bc934a9cc485e02ed19ac87f17c11ad296f126ae2fe59b620cf4bb94a393766c58bb79af526b25eb36341f7cd128f475e46804ff48dd3f59668c7503aa67cb193036387bca6d616f4f626e4a70b1f2cfdcfae17060bb40f3ac1f1f47ad44075d047a97e017bc94ee90691579d759c8e5a3298a6b7c0a51ab63c6222339bc24931c96900218571f944eb5115a00c18f4e4a6f0cfbaa584af62b6b3a10859978360bd18baca853c87085764737ef20cced11d7baa83f6af83e1f30d36e84c2ea87220e750a2c216fe4e545bdc4105f442fcdfada67e2daf7ab3ca5d7a9504de982c871db42e2449b5deb9baf8cf53f2acff1c5f5bef684ef430587d00477d3bf515b41aae918e1fa3117c8aa3938d6e598b5144e2f4c2fef88c1c550b8cff154cae1d631a65d9ffbcdb3dd23a890353bf23d3e472b2540c5dd6e8a90946ff6c18f525e8d88d63f0c528b7b40eff4fa539732a9162c409adcfbdd6d384e5f762059f4d431aca6127ea1a5cc6c756e6209a6fc29299aa508e94e6e1ec8f497b00eb1c729e0ffb9ae0bd8c492233279497f290e8eceff501903f0c96188c94d80c33d5163d431e6d58b10b36cffb32f4968b0f7586553fbc0f6eb0869a4905fbd5f747de0abbe3ae44d143081bb70242b153e5a486852a84298f6c96e45de4ace5964bf12b7c32915ce9b2466bfdd6cfa5e810a38b6fe2727a72268ffeb09dfd76fc7fcfdae8d81a1dcc51db9fd2ea7c25a6ab0afbde95682ccc7a2bf8e5a060a1377954a74077a4f2eb8157d33cdc835c2e20d5143b004d0904f9f6528ec44a360816405b436989b0d313cfa27e7c565bb258584bb070dcef73c9188cef034d80517719d21de0d8362d713dc22f84eb425cc111a7c30f416314a9b6ed7e74b5208aac2198c8ee6957be7143ef6d1ed701c9450a298b307d3ac9c36d2f0db1579104178957e58d8b363630f58190eb87dd12de0c89f55249733bf74ad6926f520e274909031dbb39fa9cd3b0bce5914d3db83aa588ffea29c412b3ab0e36ec99232728a71340c3238aa468aef36275362562239151dea5e3ef6fe78a177b6c6a0fb407bb1584b882f52ccc9e9066ec231b16bdd9a100b9ce4c27774deb8a8e90b79bc82a4e0b64623d9557f5ea8fd866f0150d8542ad99257ae9aeb420d56ded5b7cd94a2bc129c2e7b1a50e39e2a0f9e966b4e20fae106f9af1ccc029a86417e37de672fb8e4437325578cd6072b5dd637b6318814ec4218e320974d147e4901d9a1c9d6db6d23cb6647b7d060d5fcab054645c750b3aaf005f3b03dd6abdc60ec238d04df509ef82b770720c43fe390e9e025f5bcc6cea5eae565178153e90eb9ae78ea27ef1175e62705b0be774d64f281945892f31db4d3c9cb141a55eff2a71ef07c857cadacf4a73d585fd6c4257e9bd20c5e228bffe5a2532c7a5fe71e190aeb7d5d4feb0d6198f1656aee7f5f01543d9437eb5b0426bcdaed12a773a143beae17cf63f59ddc63948903017cf13368a721ef3fbcfe9207f993ded02d4b03bb7741f3990b583c0d3508b5d6583c8e2fb69f6745b8dddebddb97c880b1e0348fdd0e015033158d89d35f413e66ddfa90553651c16c2c8653ef168d0fe17b0660927bc4967f5843047afc6d60d58e3d299b8e4ef0431798406926927d4dc16fa72df508961c6e7816d1eda8eb2324690b39842b7968a27e74158dbed21bbb7caf55fa125b5e3230de425505f32553794d4b5f347cc75623cef6fb6c76e8b6073d5bc46a36cd6330572db6f82a8949cebdfd88f9eb2392320055505a24c2768a20843f850da502287e4f05ac4e6316b9659ae1744bc6b9173d843b8d45d06f37e18177fc7a7a07fb13e2fc59d178e298634d860b05b0a35ff94c0bad2b60267998c306a4aa02c559303d9cb8be609245e55f63e149541281c5479623417719228fb057a3f5b9b8f8e8b686be715dbbc5b2cfdbdf7e72a977c34e51ad9f7083949e5fd7fdec6bd82c4116dad4c6712d1c8fea1cef1750d3ccab3ed03838b64f7b3cf38fad7d7893b6c562afd6546a6bc9bc2c3af9cdcf91a070ad4c81a8e0f164bf7db123d8ec1c36cb84231849d83ec2b27f1f0d7a1bac0ce4b7125bd48b277a31e1a6099e6fa802cd03d6d1750b8f5e79c2402246fdd84b5ee521b9dcb1064a0b49ce29e29b49a5b14e6ae9511d3b92ee7ffcd1674b13006f1de93583141de41bde09fa5fb206e9b4c97b52b7018d4a86733df2bd8b238759992660d168db283d65c8640a7e046118650ded4e96828f680da19284a482e0cba6a1c10cc8fc0574485c7503b76f8e0c3466f32494e4f5d20cfc8a61e0a18010cbefd06fc8d3f1fd173358836b970b42fab358b8af73619f09207cc931a2f47b429528f2884618ff1e7ea90ad7e611e17030da8269b7dec0a3f67f71154cf5bc565d4f28a45bdfb80e867f234a0bf2844b35ecad40a1bd9d32cf990b1fe82f57ba9aed9411826f7b918b14fdd5c5b38e5b1d24eab304dd670b53c504319898bc56dc6dfa522077cb72b056cb235c0e535fc96725e019b4349ff7e67835792197ec0fab7d338dd563ef38d660ed04ef46c479865717c768d20ff3ca77d261d4926c9ecc74d76ad8c2429d9545f322b5e315fc4f570fc3e4b352875f74433b0236d850f56a16199846e0f38aa00a67c73200db83bf23be19260fe425233e189d29feef7d49e274261645b63dc5ef1336ae2a2bcf479c3cbbf01180b606fc78447fb75f0b59f580c0290aca221cc19be2e2f1def8c93f2d2c4c16d03f9214b9fda672c385906fdfd20c8f7a687910a8990b0626dfd256f59bc58fcbdbabd1085e3ca8a84c82465b8e110c0b41dde1b8de0f53cc8b219dfe33c52fa92866d439245305233e9c40c2d533d300eea08232e19fe4aa73305cd422f8fae9e6f1cead1746d1631f7dc752055a85674ec11c3401b0ebd52672aca0aa1da42a8b3e3807a0f836718b2a139d5477c3ed730caae8b919d6e67456957dc98a91b7ef08125c7eee0c6733ccda70ca90cb0fca71f1be03b597de3e98a5a262ad17588305cd5bbde361de0c97f8171c687aad36cf42239ad35bc8e330d162a3e52001643241a26b2bd30610b1d2520449438f01affb039089cf71d7172015bfdc817696a4e54784384b72353db137b6642f61f7710da55e271c3c989458fb467d8d72ad82cfd93b16d558869e3734e6cf46632ef7a015583581341436e1fc13248bb392abf8054fb65dcbf54b56f6d268bbee0554a87ea0977cdb8f43086f8e301739041ed5ecd6c75ca2cb7e35101c3e1a4ae7d1afe55d05383a5756ef1166316549074cef20e4b87a3b2fffa6a488ae0ca1ef3cd6858ce0d0cf20d01ad8dd5111bcbc90fa7cf74c6cd6288e7b2c5efde12f8a4b5538098f72d3bee30b86fbcd9cda5df6ab83828f5968c293f929b5b37a00986332bd051251de60e69dee5f56381118a8ac28073bd45668893c40fbc7ff6ff2121cb6b23e8ab5a7623c7bd6abbc3dba8b50f1090aeccf9e4344cf39747d9eac3d45ac87fc4d706a0d04d8b88d7eb449f488570a924481e5ed41f35c936d402ea732b157780468a364dbc55879d64d5a0662293ce6e8750fc6b147f10e4ef8dba7802c2a884897140839c410a865238ce7324b61c438c2fa08976094c59e6247c7100049edc57d6724b93c8541e6fb46a0a76b1f5e4ef1ca43c291d5d9d16cd7d4b87c946814195e995333a36eb97363c92be301e7c41264944219ce3c25c0333ae6f51d73e89f59aaa540cb171becce0523f43cb1edb8fcc3642852b7507fe156b96d650e88138a6972805ebd145b86147a9a3c00634556e857403314e8d2d85ce4b552f1083620be00a051d3efaa650358932e66f554671c561fd96f50a456b129f22e9562dc6bccf6141272252baf840eea487514f6c75849b3b022277d1d4041e92ff404388fe24c65bfc4b5af64b2650366c9b7ade958a4bfa2d60e638089a4f51f7afe8e656a9f91c396e82fe656f54c65b9b3f6c0f0f09fd377d15dc42a16e397697cf92cdb37e6262839e271dd86b2c618a2cecd377740ed844ff707ffb515934cf5d48dacdff30a1d5939620bded7dda0f6dece2f1880900e6761a28dea6c4b6774a73d9a422c4066bab009d8fd160109de617c36c1923e83cb7ed681dbb9c7ed7e6b60235cb243b5920ff10008617c3dc71f88dd14b37140d64daf96c96f2da4897bdca07ea4aa577f26b38362fe1f9e32b1d2f4422601a7a9625d20c1902fe10b3dd7dab3cf93ffd3b8aa03877798305d39998c90c35c7f79d47682174f5c1e05be5248183262d0321a86472cbd374992a2455d05365e6e934a02bc14a45a79a8cf31da5cf228a563668fd8170d9315af9f02ea5d2c37bd2903c23195a6d1536c8469cf46ad1cbcc3185f579f2b1adef96b7ed4f04d47427e9faee7cfc3ca2db0968f6db9adf327703878b136f8661b2a4dd64f79c0bb6780123d2f35dc136f20667035015e66ba1db672cb9fa9871d45de6f4ddab012458db933c1b4c833e241d620a265cae559cf1e88aad0d9e2cc438915043206a5a673d9027035fb012c5ae165d4e86edb50a2f429e1d9cfae4f8d7876047b864d174120a725824ade8bb541d8b69283f93674a852c4192b59398e3bfad226ff85ee223fcc08675631bfe79df044aac4112e1cc811e0840c7d149bd70ccaaa19d59d20fdbefda86926e51dc8abf8102f58640d601f30552f4f0b8b53e445e3324581312439c2263ecb6017c0fcecb75ed07a859b75c7dac1aef07839bfce7c6a0107cecfee749a9ea3ef0f8ec1c111fc1886876897822924e38e4d75920a981b79e1dfc7e62a6b1365175749b28a160c35f180d5084352ba381f3aba678ac15a216ca4e0c9f615bd83913d62fc70c274b8ebd4fec6a06e922aa07a6b9c64fc26538dc985819fcc8d9ee57f6d11088f35c39f85feb385b10d6d705c8aaa4d2a98057780434339eb5a3478f3b8465ca79612807d2832a9564ae18b86b7e4387517f176e867f0e178bc9ff134ee2e3fc0e53300ec46a033ded0ee8393f0d9dbd8f4deb64450145cd85acbceabeba8cb6e6f3e51b8d9f5878d5a55f2d70fb7a2afcba6947bac52538a55e9a7022434c697940180da55d3732795251818fba47b320d88ac1c35c281249de742b525cb535bd38ccbad7bcf1b5b7406d2f22276dc076e4cdf3e9a6304ccb6415dc70cc132e3c461f7756f3ad24883a0cb939fc050b856e91f4f6001e5d97f228411f0854a35b415be9b980089f01cd4aeb1596efdfebb00cb5da2541445bf7d73d08c61ba2ee32579cfe354f059b35f87ae3ef7c76478fc23160f9b61c6f3d59192b1e4f97a22c410127e9dd86a8d4396ee7333bf551018cfd80b54f6379e19a9f867f0044f968d49137bea46e7279e105e86f4231e3d1abb92f05e1cd092f414627bd8b7cce224727792eafa158b1d4f692bfe794d733b48e4cd6c0af314ed46ba4b83c259eeef1ca68691ddc59f9d2196ebc5a14bd9b06d8fa0574b5e01cf28e2508d6b93259f4654b750809a04bc8792e782a096a5727e10d0d2f0b2f3d3e10fbe44f037d9d9c011d18ade94648b9057ddf335afd3d531dadcac9ee1c5d461b46af5a2aee14e7ce1c469187b1dc1adfabb6d8d7117c6ab7d08ad0448d00abb6e0b222877e4df466a1cee335c1447e3c4a08e5640d37784706e46cba249c28eee439f3b156b4fe236e802f8a6d8b348c2200e24351e5b56a9d0916655d8adf53e4801909464b6971972476d93f26473b07cf5a9b2f2b8cb0b2cbab6bcbc963020a3e8ca1cbe1b7fc5835fc1cb6ee13cd6e744ba5f95f029441885356ec0118ed661ab5020b951a5f51f02709fb9afe4f1d9648905f9f7b9838aa67206457da165f9f06fb4e0f17a8d6d0ef22d1d0c2974a7460c8759fe17f526e06236c6540220de3cc18288ffb0856e113f87f5e71caf2b6c87f6067658043e64ea64348c4606cf99a22082d5c3be95eaa8789fc8a1fcd449e4e73d275b5ecedd176b37d532c03bed6b10a4d477134679ab3874deb8434f6e53b1712cfd28c136ab5965d3efeb683a163db6030e54fb9cab7d25bb0e179c279a2f0bbdcce0ff2823547cbb608a4fd56d96b0b03d46e05aba2b6f4e44c210f171b357d4d8b6ceb46057d77f49269ec9f54e9ddfda202408f6db64c752a9fe9671a68d550369d7ba66022c78f204e587f5f76edb0cda13d58e3e3c5be9a8eb558a4dcb7eaa66c84bd42d02fccac84791f491839f0d228b8ace5eadcbf217b13a4d5360f420ba86456fd0f2b1b57a8b4720dc4b50ea4266e80a85a08249026f0595f878f7f585f627286a8aa792c7744ff10fd672aeaf6694e3df08ffaf332d2bf00d3dd8a526233b1fb77880055c09fdbe8bd6600082f4fb7918219f3999bd5de5d554151be9d516d854476d0b7d86c7628aa002998cc6aa601d1bb43d9386d3c10911f1612bcfd2b0b471e8c997e9f4bb480f08582a9f27c76bf3c1bd7340837eef6ff183ce5b7ecdaa203e8a60104e6fdd8bd83e64f58251269b1d227bed24c207582c117201afb92d42227d5d5f21b740d15d77954813a915dbc5575638214f17e8ebd821ee8c87c9c656cf88f7237942705f3b8c2e641c84e6b6feee140fe0f06900cfdfd0b6a67b5779f137bd1fc43aea4f7a10f1aeba7f4b9a2fac7da6e4033ac0523367a6aee8fc6cc3271b60112992f8d6f3d0c7bf20b0ace4b8cdc35233c013c0d9e2fee2e5f3bf1b84eb9e48fc26236f12b66758b3660d4b321b5652e3ef07e4ff8f93f6d892738566592a993ee454499c20dc5da9e3108f859a22ad6f4f51a4e18d9ae4b452cab49783e143a7a31d1dcadef2f190fb0c7c6ac516105bdbb317d1861a8de8ba50fe9fe8d2e61638716dbaf96d60a4f6ddefb116e2beabac7594384b76e4e68313a59d828f2c2c8d5dc1010a89d2f0e89c2ffe263b506319392778b328b7b24535cba1a8e161429944eb32d9cc7aa041cfbfea7f06ea643d6f6f48c542d9c4728e3f0bd0b4c009fa3c074116317bd80d804d58bce7638adda59c3186e3312c0a04bba5d50084e307fea7c9a9febd7c55de73781d45c9af09b6945a9d9e140b7024802fa335720deed8f5f3cb9d5261b71846df966fface3f8e360bb554f1c95d2f073c06fce0955c7fb8347ef41df44d1b934402de97640077f309e7afa8dcef10777b1d052a9a6d8ee287fad2bfde92283458f63acf39de5a4392c46a23d46049f91325bd3bff858fa524f2d00a17e14505979f8a902ef07953004fb1ab209400318d7f221d59483fdc9c59fee913258783f30a58f00b366b01b3a66454ef279be711eaf1d83bf532af2741f559ed7885776ec3744d86f197cd15957281fd9d0089f26acd17789a919f350b4809b94b026d2774afb3a60d26a2be58d0cde6d0446547b19e4329fa943c884e7fd500f3f06f28ce50f192510902eaa13a49baef7bd3fb1ff1a750d7d1bd702cbf40d03cf181a92f29dfce8283e8a4b79286db232bad7098c807b3b6b07d19510c48cb440880057bcd87992abc2847660cf3ea7dfe0a18c5eba419a45a3ac9dd621ab3ff5e1c5ae4f912083f43bdb6567b17f575adfb0cbeb962ac01ffe2e420a705395350d546aa81bb2c84308c35f9e6ed42148afb7b06059f0b626611619fccd81aec9a54c72c71c919d5e1102ee6dbef5ed0e6c276ee6be388fea86619c659eaa4175e272d49b912155dc2cf0558abbc308ce9d559890bf669c45efd12514429459ad3451010d04e241696681277c98b800132cca26a5a794d4af621f29ce6eb0f4821127bdecd52cb674ac0ff19e7ad9ef62a918318dd4ec6bb78a77916074f1b5fa3d438f9fb1999230ea333701c8254455b402cfa54b85bf9a06f0d6366b7662dd30754ec7928f1a04c54e2512620950a4ef2cfd058c9d44fd5163353511aa81c192b94918113b43cdc8b7cdfa8996c0033f024c988fd1445485e238953aff561b4a554d77dc2411c9f82334717d7184cf9e9e92eb71a88af25444cec7903c31a895a55cb7022730a12ef62f8f86ce6448d74034d1ba28e1a0635cf736740abb64272f63d454dff1ca6025e79767a47ea8c3901dab73897c63299c7998fe2d1ced892264fb116214ab22177bf91c25365f52d731b2df538ebf00328e972973d6cc8750b981574bd9b952a90a736e436503f318de2b8b2fb0a910ff2a4863d2258edf59648f11b2154a2909c82ed351ddd9fc246f0e875f53db2d17bb249f119a618bfd233993c158dfa56347add290a1c158d8abeb739c6a861439a75b74e3a7edd8bbd4867346fe5f8746e4707aed8b73e2900d61680ae491179589a4d81778d768485dbefe002a8808430d5453e6f3cb91f5ebaa6565c65cbcddae8827a18004ca7e48320d851a715a2afe9f348e15c7ea3a3a8491e6177bf17ddf85bb2c49a18ac41902c96073f9bb0d2bddd030d96d121f4580032df43f9a9192beaef4867fd697a165200b5a6272feea7c037f9a84a6d086e3ec3980714e21a49fe0190755b1128d76584587a2763fadb61c95668e28475cc4d1a39c2d332a6307b1e6b82c4fa851a6158f9a0e1e0d661d7fa82ee5d8916e8c8d3e50139a04fa284562662d988c3b90a7ad86b9e56ff9f28d30b9ed870d13eff92ad557364b5404018c8912635748e0cc3d1a8afb8165a1282ee5ae9638d54d1ae7f64d55718dfff21048fe1f5b566d234f973da450b4c152a4b08d19a27ab67ec467789bd49ae3126462a4bdf7a7c3abc12d1d1d8585a1bf8e0953f3737762007c1e6010b13792f1c203ca9c04710881c0c66d8d93ccd364d8302f23121e7649a962a11504459d55ad504e45d5e9a7dcf330c0735b7fdd6151aab74bab769c41aa430748d6d33fa7927d13b8b81d1c4e83291b55fa9690cab56eaba35b2b7afaab7d5737d3f479a57a3d5533653626ae1924c1c39f950eda5e371c16248424dc98d8515278aaebd47b2e05f9788a099007eb5b06ec83bd6b9f225b412fef1d02f556a1adefc84c235a5e7242e598869700c7b0ac439c8b0270c4db9bc7ecac11abf156dc62c0afa01e4a8a2e74b58b77f881bf7b8358044e68b7a7b9e41f8abecffe74a6a78e2b67133cd7939689c75c2b988fb376e70f532f4a4e58eca6add343b36c6733d213773c16677e0a3d35e2450cda66117ef5084d2306a8f62832af6841f89480a5447d117ddda1b18c7a49f28c3078f2025df67ee092400fc78e7a30039855150eabc573aaf65a0159b49b9f6e131df1a4cf7f8838c2d5d4f172aa3766d3cfa4606d1d8ca2217f4aa09d33d1f448d2f456a8cabc0bdd68c828eb44af8e58a3426adc1132a1251a4f1364037815ce5872f06a782e210363de1e984e00afc7c3807b820e23e7d8eb24ac9715dd93bb266781068a067015788d9a57911d0d531c8d2feb54a12858612412ed1b1b3705e878a07c8f4b2587b3c54d4bf74ad414022af56d616e186b4e0db518f39f23e64548f9d47761bce58349333b7dc4585b8e0a7455195ebcf7ea7e06513393d7dfba2c0f221f6417d638c1aa454cfb2df1353127b65261fa2f53d067bcee82786af61b9319b34e9a1ae505f4997512931a1f7944a54656fc175eeb55795860f3da09b17b4aca52e2cbeb851c7ce8de81a9e51335681ecf8a060b6ea54959445042ffac46009f10da74e8b4cef335e02e9ec979200e9fed7eb93368110b957ae3515bc1249afba95a21af4d3b41d24ea82b8eee7020076fd993d9bd134168b5612f5d835a8780fbbe6f0f776491105ea07b3714dc7d9c795a37ce48a2dfcf36607b51092afd94af21963a7e5978f025fd1cdc5d5595c75b862114272ce69807433ed55fb575714af5aebf95db76d0346604ff2af334a6973f4616fd86dd6ce425da474c52601b48d28744b57dbc31858974b8df8926d15bbc93f95cbb559ea3243cbc4f0c55c9ec5c0ef2396367826e304ed34fcb44e4c5f2d6321f835cb0dc9a73cdb35273f864e5a5083fb83bdbfab520ce13d0253a99b33394d16ad766c9f8addc41195fa40ec3ff347fe27ed7ae683b8297a5fae904be90460657d3b8a8e5628482c1cb35afab54ebb1afbce10d15a317ddac812398e54cf257becfb319d324cb4691e84f1a0b0ce58615f230c11d49b1a0db07e1e9697ead9ff24644c86fc905ca1bea49c58ea6fcf2f55ddc782ac43e0d2914c7c8535f2c75b896bcbcd66bf9db54c07e49b27c6eaabeda18720ed4c8075dd51e2d2ed9db729a17d5fb2a7d6b3a668d064c71778374a0e2591a73d0f602a52f19829e46c006600239ede322ab1375ab486781332e81e1371c96be6403dadad8963e35fd5c8f76c83996a0c60fce05d39da2f43132a3c70a62c61ac64e9d7080586873884c6a61b9e4bc61ca8b4511db3e40b836292b642ed4967b7b1ac52fe5f29795f59f783c52030931d9be28bbda05641baa40c37a6f2cc9123b58a731c9c37563aa74bd6445e7dda3697aeb301fa1768655ecd28a9d2428f219e5fea53fb57f41fcedf9a9479144b94d41dcbfb3a1d98fe35bd77145cd0596e215499e8a64bbdf2b68a47c5bc094abca32a7126489bf2af523c0f1051f056ac35f126d767ea899c6826fbeef25495b8077d703f3a7ba471ceda3739b3cc161e0bc30d80b6bc02500212a134e7fbbe5dfe2c8df6bb1bf82782d169b8428c77c50eac2bbdcfa4c26b8b74e7c7c7290e5e91bcd773f0d3439bd2f0333b70fe9eb63ff7d1d65d461cd0c525af5e915d711d4e9c4c3ed0d961355cc58390994c3e0d45865dde77ab5c98efeabaa5dcc7074de33dcba47b7a529240195e9a1415288b7bb3b4a8fcda30b1330a677a5b2b6bba73ebfab48133821f9bd7e29661fe885d946341444f1c7f0f448dc30e8b88bb6b0a874179b7eac8065d13e5eacfa5a27481129d89841a79b1fc323188ad27fa8fc65259b6f3fd9af3a32b2da754da09edafc3f9fe0b142813c21a93b82ec314ddf3abc6edb6b619b63dcdd39f7e819a81b3cb1347e143f01a8b0cc172a49b882549fc4c158667a92a82f532cf6997203dab7764f384431b384cdc1cd5d66b3c1960bec11be12119aff87b01c5da09474692078ed6f113251ea1856fd87082fea6d157b6370d9c1ec2d4d0ca2c87885e53eabe644252fc98cdd386e0b064637285bc5a4409cafd43e3f1a10f10fa5b78d8bc96b8625f563a54ca093f406956c8eda336fd5cf223ca59b4ad5533f6227b411a15dfe4fa520999ec3ef88848b592b587630297e7b590f98af715c8f54ddfbc3e99ec88d0aee618e93fbbb1c89144a0ba2b167c8be0860f842cd84bb76c14090168440050af078d8ceae623494fa2e665791a5e00928ff026e4120dafaa077fc9a458b1a87b6326a8ba0f33c3f9c3fe6a447222f0cc2592e9312ba0820b1c7c4138f8e9d4ef53a617d8d6337c178e4b5775b0ef132ac8133f1f8721c76d167929b9d159905c45ca682d46cd7597afa5ccb40713c4a475f443dea8e093ed3739520ae638241ee6b00a94c95cc62654f941d8a7915bec3847ed56d9d164e0d005c3abdfbeb329da5b1e5fa4793bd6264b4f609098bb8c91e1f7a7db75bdd135354046091756828479962c7ae5ba998e54cc34fcd1a57e12c2a9b40bf87c78e3982e9b734d38661b6cf527bd691bdb5bdd7ee14b190fd4ca2e7d724d1bd3de2ddf31ea10e2943f70eea32ee1b062fde7e1255d908becae458869d71e1394642896d04112972d46cfdd8af3cf16eed189363bde700b9d2a74bd5749c01b88e614b26121eef05784cb7888e2148cb838ebe0b5b7c047cb091fb066cd5233bf0dcd470835645160d9ef17f5a2f1e35deac5fab58b57e4838565f796e7374ffeb8972da0184f6cbafd8d8ae95849f3ddd0f767d8f4f92fd3896fa7ca117ed9be3d875c5facd588630a23c3dd22ba7666887f9600e617125e58288492b898cb1e6fce9069706e63b4ddc966e21f8e97ec5cebb7e266fe2662b9679094ef9006388f8fbbae5f5c6a850e05ce2738b9e75e3926640fae55fddabf16dc4b2fd627c9ff4d0d6cff0cb899ddfc495d74be188dc7711119cc12c7fa9cb7403ed2293cc50c6a82e8e41c502f91209824d53ceaa2adf24bcaa601a4acb0b4c6f9433b8b07c82d39aadca03651bc285dc2064b9047d74bb49253cb8c63bdbf57722a75f467d395ad291f903bcc7d72c4e82bae8305d9f2915567d710ba7c44a796f19004cea8d57dcfa2a1d3ea92502735195d4568b369c60c191e94eb62414bb5a69e44ac224f1ae52f7f049339432f2d75a59ad214de2b25663733b1d0636a0a65189e23c532d13109a7c4fb8d5170bc2c9de244b757d3af789bb373f069dea32fef4f7f6420d912d0230b4f5a4f1d5c78f842194cd8a674fde55a7a0fbf475a25b04c48d6f68545750ada0efdb19224d80e287edf922dc6644ef78ee120cf43ff2bc16fe226c980918fed8df999dc9808a35a45d947add4e5e106de1a6d36bacaa5613a3cbaddac19edff8cf7093a59acf6a7f171f8447743992094241ab0b45a3f2d7b4eb48408d7f292214c80e41acea82e234d6b5f62146c4bf3fd4643d4debcd93eeeb4508daec9f9ffd6d89ea5a9de5fbb1245926c3888223a9154888c1f5e31545445417288419bf3687efaf10dc295b5c1688f77bb633790a52ae8df76a42f30d3755e74f3f682090eb328859ae2d14f5280a1db2f06aae2ee69f6548507b2d8ca4757312c7fd84fd8efa4651d7d5c38d2d8f64e76c2a8c824283ac50686d2d52562645e0f588f9f8e9f1e4a9bbd19ff767f3dfe2018fa50ec6fedc69c8f561e6eae3f5fd53138a3711ac85923171c5f4e0e359a1ff9c6aae606fd811df75878c962387df7706e51f153decc6917a35a477f3b28035a778be10dafb418d3448d1f73fd2e0cd8bf2cde51deba57f7bc7bcd7b99a4a4ca0591c560252a9a288e8a273ff8cae86f0f3e491f6ec4b7c50452b393066bda9978912eb96d7cae4a20b2b852421c9c90c3b650e7bf32d236b2f33408df78a789023e2e980b969613548c695bfec5de418eee6921b7e57ec19c3b3ff25d3ea9b0dbb5294f5f10f662881b3f492797f35e753e2c698d79edd6e0717d16e98339ec07b5e6637cc710b9a73c2f0716903de5f5502afe50ef196d39df16441a9b6b1276c955e71b9ac6ae4b6ae36b4a075d11be6866132326e464293795d54fb0e9ad45b17690eb2bf624686b6e6b376f61f6b9c62b333e83dd9ab99f6710a3e2aa6634b68aad5999d503adda0c9b37c973e25ffeb9aaccdbd80b3a634edc78d28ffc1e5bc2b8cd28438aaf301807d4e4af159bbb62ed713225c584a2e986d39310a899eef222f709d63b6e85ad3857141849882fde1edb39b913bd35a77435e4138a2cf6869f6283fd7768fd64f69b2a92d55645de4ed083f4082ef116a20fc28b16c6530659c152b7fe4be405e5456d6dfd3fd65294d8b994e961cb9aa3728da41bad9d2c3f93f7fde8cfbfe1812a83a250aec50dbfd989e63872da596d2fdb28015d43529d884724bdfc98300016608a2af0ce839f9a822ef096910ed532aa637249daa40661ea1b9705c6e0778e5c37365f1893dd58d50072bbca3e0f5d37ea76556f0daff7cc4036713460681a26d1f551632ad2cb77aeb09506be1c8fe0a19b94fe73683a495024249179df070e6a949ede733c007c8782051517c0052172f13bc6f865fa19f5889ff4ebe312c5839f860961baff99e46ad75b8011674cae1a548514e39b5865d30c51a7511a2a2927dd88c57e1a7a50ecaba15986547fa7d9cff0696f00893832bdf5bcc794a5f663dd5b9bad64d63aa77c1740572f58cef85c3acf25ffb7f1a160aa92613aae71d6dd5cfea82b14329dd3dcb5e756813c4b98c6f9db085217e4a4cbfbbe6bd5533b50376d3353a717c193d2ca062ee1fe2653dd42546f8c76e1483f59acb476a6c3bebe8e6eb381bd81f314000cc6b0c5e75bb2a5dd2d310fa4e61ec552600509b286ee211e1a73d468a1dadb42bbb9b385eeabb9a147d277ca5664ce519087df4b1a121482eab38d7b0986802bcde5fd3be21cf1f6e7097e76d1f0bae62131b5a003b5969dec1be82e13889412182ead10098e455103dd3a089489d61820bb35736ea10fda30a75cee1d39808b1bef896fa57380d795175a40f3ee3f6c0b3907774e910db0f53486eb13e8663b28f4efcb2bc5a88b3f2e0504c9bffadcd26cbbdf904a6fa3a16dc843c95c976f140a0da6d6f399f67a375e50fe9cca39588f3eccb7168cde199b22bbc92a2ff684763414cc5dea74bc9a73b9033dc79cb02c0a5e356ef93b4dee88ca3d8b91b9892715a54443e65d34d8c2047593e31548ff7150c8c67186867c12729d16f37c5068c62dc2d9a025efb2ebabf43fea81a734556283fcb950a8c696f8686d0964b82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
