<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"027cb915a216aee4948b233dbb7de9db81f10e2be40ce5f55ed85c6aff7c19d95d13c88d91176977b8d5d06090066c9b43987229e52d784167a49be72d2d49f6bdb9376582f29c648e6cd7c2addf4adc2b8ea40d02531dbce23acd7eede1a7ae2282eeec5f9508eb3e14b135dee6ba4a916734c254da0f3f4be005037150a4ce166ba7e02af7d25c71b9df643eb186de0d21047cba882640a7b6eb9b936de3460fcc4326699306a72a031794ecf802f89b264bcf527fb41426423babb5c378ebd8f331b417ff01c89e72fc86bb8ded973d339d866a257e7ff379a8ff5f62c19c5f7ceade7a28d6cee5aa9264fb5cc51d2824347175f40c10110de2064b395fcdf5b92e335c5201b97f010d2e7d3f05dc2e04ccf55903314c51ffadf3e28bad81cffc5afaa14a1957092ee79b6b07ca1d4df98f7b1538b9067137bbe10cf5803d9beb69507bd426a46db68e400dd62703c06d784d970a3e0c85477dc310d3a0c2c18f7728ca0c923805f30ef00fdd8f870e9ba21091c674f4f842d40c933b5c95afd949851c9754eeeae984d62fcd5af88278b5ff1dae58afc0cce8d744def610fd083e3a38146d8e2e51c80b700444c0fa6c2450852e91bccc121bc84c80c25a434292ebe9b81e443eb94962cbffda4e1f35244aa613b0538dc0207ee3a4121a5a60a20b64b1e1e08d98f753d0a5438305fd2b8a30abbd320955cd23c1d63e2610603d504f2f8bfde97c901b28187b98641f0ab7b4f61c0309a932faa083f51f8ea3af8bb06e523e9c7e8d53ced58236922302884bf413918e65ec5a5891a671a3cc284a0f63157f594344e897643be46707a748ed27e53cfd37dc50ecf33ee7ed721002ff598a6eb6e06306ca0b7f4b57dad8bb340e9654edfb6831739d74c0cdbfe4c00c819e665344f1bcdaacd3fa117644f773e18e3a896d62b9a7e9cf2c3e2ec4d2d677161e4276d409bb783cd24db7495c799bf8daad8f67bd3ecdc9ea1e0136c7332d9f9c69a7ae37f5924ced36e787577551991d0fa7821cab88352fe32b1e09dd7042d00947d7cf3d104a7be1a2b3c1dbc36529faf359ad7fb1c4ae57b54f879514a68eb0c4520a3094bdbfb1de3ee72301894c7fb2cdcaf88978b60fa078df09803823174bba7ab9f2a0c747ef0a26e9d1f85180c71f0f53175b1875182daa24fc9c0c22996ed22a7cd9a132c4d5f581b91f56e549654c4c346219b8b626fa6a5f54f50a4be6ffa89af7858fcf787cbce3e4d20f640855d2e50f24e0c74f01a08bae7c25930c61b49307f00ed6884ecf7e4850c97e9284660d9e8a0c5e211c643f32b0b00963d201ba0576a2930c095a9f5fc0417254c32a8f9ddb544d8853d936747b12a42bc19ab28a65898eba1f8f3758f9d0a066c01106d85790be266cba8cb8b42e147838f961c680bd1581b95fb6051e5a8dc883b3bfae851f157093870f03303e5bda94002187e7fd30576407d27e41e712b2db39ff9ab8d74c16451ee15af9ba0ada09997d5117cdd428be5ec8943264a0e7646d5dd5eec6b09826d0d0cd6393160a808e53143b4388c02577b5f537458632baccd9f9601c027ebf5393969d3519813e1dfc12960c49d2f3466285c2474b1f975f252ee5f91e8654b12cf0176c7a8885521cfccc800f24b205292a21a3b7491e343298ce431b06734cac20f7361e14356dc37d946270e6ca64f0e755a97f299c95e7f778f22c786e6c019552fb2a951ce10f5f425b56e740914cfbfc16dd14be1b564d942c21701c7014cc6cedf5d6ee921c0f25847bbe342e40fcce48b95fbbd1522b2b73b57d6aef6a66860a19cab3714aea0d3df5a79c10ec5af81240900fbe0cd25dee6523534898787ce8c5819c4b8259f1dd0c6b279cdbce131fe87a8416c9c75dd7419296323301006f6206fda77b2296b5e02a359563e25e70ea506d43cdefd15fbc4bfa04e3a3230b35f16ff5a00b3456698c46fc0a693a96742c11f8d95d1c0ccfb6bfd0deb4eba55f8ad05ae612af079c0e78ad8c5e6922a7c1ca47d5c0004dd995176449c050d2860263476f7b0e424e2b07e2d8bf3151f76539a414d608597e1552bc378fa9081b8f92c23a029895447ca1f14e39cd7324722f5ca7755415e96a91a7335bd26acfaaf3aaaa6c89a235f1b7482557e1468348124e6d0e161c9b4595897de19928b4bb854353d3ff7e2785b66e400029a2b5deace0c55a909e87171d6f94286735bdec24a65882762b3c0576a3dd0c17574725f8ac63b0c29eb133cb9e208b76a6a88e60e3092fc375e48eb7b524f60d0c3eb2ce2d6c625f9d3b060305f0ed35a448056b02e762d6c8ae59a24fb6bb840fe874bb5905b1b91825d18945d5d20ae203b13be136a75894a1f648c4961b2c558178b4e345d8078952a7c4c54566797322896041461c94b064047028664ee775563eb7c2fd74e33e38175f1e10e3283bbc1a928cd1c1f5c9511657f68a0ed7e8c8840bb1fb4094c75c10fc8279dae8a5b7c0eb7f1f5fd09db01d1bc80c504f306290dfa6c718475bf32590cf64cb74efaf3d79b74b68c73eab032dc736eacf1957a413a04b5e3080dc7aeb571be855dde9402e083a0b18ed5f3ce31cfc026f3ee0f67e34ba6d984c4e9a108cf02e944d65db335678bcbd4c511269698c1d38aa573507428879b3be31b00126a8c758ab08faabdce27a3acd9414bd61395cd3df3818148fb78c4a51aa81a7c78c394f6cdf417a8eb1145c06942472cfbeb749bb6b8a5cd88d7bc880bbda1b44be8742a7f8483bf5b76872c00f4c534ffdc6ce6d8d915f18fb9cf46aff963874cdb026f9cfda6f6e0bd65f3e8723d31c399b81a369de81060b58e8c537ce21fa838876efb84d33f911e6a7f6db6c857dd35ff9e758faa205159691f2b7cfdb4c8f52580942142c5aa9b3b096d1514733042e99f8739aee56a95dce006ecbd16262efe6ea4b3b3de4c67555ef0b98fac3c53efe2d7d93fc4bd4e3f5e1eff4caaaaf699ab6809d51437c8babaa6bd4b91e781dfb37c752cfe26b7200f9834edc69eca259f7639faf4c7727436b7a364efe4c0ec3af8a5ecc4a75fcd45ff74a977ef53bdcc9649f47632024074f759746d470b242db8f3483a68bc09a5cfda7f4c41db39159059f385750f5c349a6fec5892450140a3c6a5f6fc174b3e3ed42e804fdd78da0a9132404b118c4988f5e642acec4527df53f9743c67739feee30b6a56e181d80035226b06d352ce7c07c254bba329b08ebc03ccf58fd84e69f8e09f11d6ddb6d44d930ffb3bb918296416e6e7e384393167c3df4794450babc447c7a55ea5c8581b219be507b7ab602eb48ae9ca3b0849318599d132aa89b50af69471c5fa91f7dd0c85f7a79d6a1d74f57f44c8b687b6f56393838985ea5f85190f13d6e1b1470bc684eac87d9f0ef8e0a17c2b5700db01bd5a6dec6150c75dd9a1a8f17cfeeb4faaae8491996dfe3cff1b7ea2dfb0d6c4a80ce2067d5cc88fb3d740d836ae6a2ca0831a8cfea4db9ce9b33d653b130389710bd73e6c99dccc0188adaaa00e699037ed833584e1deb1321281d4db69f622d45f3789641a8ef061743a384ab2526bcdd492437ab141e7dbf5191d27bc16b799d04f4bed7c1ff609dcadf1b592dd40b9cd32ff4d38f4ab025da88603152794cd381120f5eb81cd483ffda37507d0fa569ecdc075749f71cd695602538b87acb19067a789a8fe36135d20a5dae256f00a5cbe766ac50731110ccbbcca5c21a7501b20f11cdd722aa2da58b3e160cf5874451112c6acba7c2d763d417100f4ab5db5c4c9e5a05795b7c54d93e2a3dca4fe14b84650f48a5b2de8d2dbd6d40543bed8f1f0b1acb6ee0442a207d31e0d3e0f1b7f0466f822a911cbbee29986070fd246fd68593bf5de729acca9daad3dcf529eb49337f4aa6c5eccf304c03f92990b714ecfc8f2008d39084c9c3d87eb11a363848bfab8ae0011d241ad763ffbe933ede347354d7a6229463a369b7550f63fd58c073048c7a3660d06cf69d2108e20a361758f6acc490d5a2357f58100aa69240400e1bb4bd8d590f05515b8e87e65adfd7890c11e7db8a8aa517de0990fe0f347f9ee96aa1e9ce8299a16a38983cc4f21d3cd89a4c459dc9880f2aa8dec384f4e579f8efb5e5eacf58d86989213d61463887f21747d02c397269a48aca2d4de7cb359bb9692b58410722c8b58a6c614dd24f490b2bfe091447e2cea2433ac8c72901609e99df53af4e218227da3f6df2dfa92881347e1e94612ec9a40cf5b6b0f82a86b787392483f294b3d84ef93bf9193ab9d21b9b1a1df8a8c89580d9eb1e32aabe94d773f78be378f389aaf55706975c9981846a7684dd0190d103bf4609de7eeca4819092738b4841db43197f8665ef352a06889b71d5a57792e180ed3d0b93bf40e566fac6c7cb53515e73f5b3bfef0ea59a131c0f60ccd4609b38d20f4b7557e9d414ff9860cdd993ec6ef82c44b5a93dc375ec0c12d1f2146200dc423f2696f9bc512db7d6f53f0a07793398220f308a8918aa85338580df71365171b85e40c75fbded5e6ad02057d7c8104b68c5f519ff2002db804c709d517cd00223b1c14b0fd131a14a3badaf80b448accd5ca79da4216c2956166fd7cd03cd9c7a5f39e1fdc46e0c52b6139e9a22f8e117823559af65328161093a7bd2e1728f5e5d7ecd8156935d0dcdff52b7b96eb260b889820a07fca440835643ca2a6a5e481d145d75b1618573d929e4232690b29a940ecd722e7ad7d8e548bf441c962d31b48c44b19d1541a53412b82132f764911f02416ccd474c8952d3693224db04196240668d4920e7be72cf51075def2465bc5baf1989b497061de7ea0ca8201e9110ea5f158640b50a02fdfa873bce86dd11918a84a993a5c4154c93642ff932289e1ee34c5ac38ed18ba37f646e9603e1f320bd9d2cb04c316a66cdac8d1eb0d926ac113db08e05b264a6151cee59da111f207d27f008f71be2be861f9fe241e2b4e8f0819d0463f1289dad249701a7b27a0937a0c2828c18fad455ffd56d5e08bd42e4205515ea6741ff025837b9274b926534172c72d3de13d60d58fa78f9388b3139085b87484715ebd7780eeb9f4153c0ee0c18508b100d0da9999c775dd7f11160e03436525e676d418ac44d3ba917d07f2b11ea3fb0ea466c4ed4e62f986b6e42173eb413ca2137f724c7effa404c7a3e2e717e3c3ce12d354ab437e01bf00fcc55edfa48007436c9115c6490161fd31a474ac799ebbe194a19da69c9c6d10dbf2b077ace430d048972e48067406667d0c68159a25bdf5af2a1b40372b35035cde84e8298b521b3183f4af8731a9186c562f68310fdbdb75cdd7b8402b7e4e2c490404c9677098d1237d954e4706b8d207815f05489b2041bacce86deafdddfc8695da944b074398adc0341d868468634468a4bd4c06435f522784b041b0ef0dcbf1fac2219b8785f3dbca7b18345e06bf00173b40d28ecf0f61e1a68bb2b064cf24d578fd715400b99893e06ba855536b92eac20edaecb22ed040f837893eb54681f149376be80eed91cf4776a40efe983bd54c85d9d7a3c017c187f553da08b365f558e81c9aa64b8abb8304458195b6f896beeae806c6f6a9eb574522230cbb53fc52b62d6f9e40d69365a27442601b594451cbacbf1dc26e114515f5451bd5f091d7e18a5692a4f1f3a0da26e749b09388be99e5fae23e429343c810b8a188a8d9fb17991aec32eacf1bb0351590ac0a999ae376f3a86f4f8017b3be164e51469759850690a750a2c0c5f66d4cbd4cf2544ba1372bd837aadd9c04d997c959f427f5b6431dff03bb461ac13fb3cff640cefcc7453268ce3463c0e291034c945c0ccfc19d3f10f50695599c8374bcd2cc52a8cfe0ebe89276748ccbe19340b8350b77b344d690cbfbf4a5a60f133e52fb667b17f5895c6bdf78c8529d67bd9b928283a83c217c83bed9067735f9f1abc76a3f441286733fcdd999a0d6c5cad8840cbdbad6879ad451bc624947f8a13517918c1925ec10fbddaa81a834295915071b5b4d73fad91aa6787ef8c79512d80a956728af30e80cb6cfe195f29f5d7660e64d745f815be71dc3525ed6b748e45a9fcdcab1387e7403adf3e2fdb10872bbe417bf5810555d1e3d9123cc0053adee8fc57b636c8ea41cd2f5bc54ea7cdbc8df8c3f6a8886627dbd28f7cfe98becbc2d031db9764acc310abc2f4d9f13d003e97333c6876473e5eaf1c8230e2e6296b17e928b2b1e42827063050b8e8f9df4d9612ae78a3ec88eb27a2b3e264ce35d8f3aa609ebdd81f0495b505f1294c5ed08fb0e01960037f8602d1d4b652d8555ab39e7bcdc894f6944041343b3b94a2152b982cc6eda1ed4c1b287da2c2d7e6862db0dc5e721f1b9b86bc89f2f8e168a9223c66af290ef2e0751e1b1232f5880ff4691b922122eb277f2d790b2a6e2ba53ac80dcf1540fbe34f766c50fcc42cab71c0a590abfc989720c9d929aa01f3f806cdc54b763bd61a45a1c70225f88b0ac99a86bb207b1b8e6020d993b8f9f789965fe5bfc676b6822806119453e05395a90b4868fdafd456c69e13500305e4e443a166f16b996d521e34effea4c1504f54bdbcd3775b6e2f519f09826c9ec2f62c78b1017353bd8aa8f5eba5ef0f17949daae027351d24855409951d321e56f6c3ca4ca8bcffed8afcb4ecf54bfb52dd19e554b4ecedb151d40589dd1c68b305a7a115c154115444ffe2cd6cbe27038991aeed34368118f264c99e55cc95f93cc8d7f6e755cb2ebca3f0116f832316c17b2d4aa959cb0f05cbc598508a4e0378de76f30eb12cf063926f856a5349e2d2066cc3d6476f969891cd0fb26d60c93f1077616eeff8e9060ab67208d682abf148f285f1fadbe6900ee68c67c9e92e9dd72f30c15abc1e402d81bb84705700421701def667797ba81a6da4193b39dbae5b658c6d1cff7ea99d18643bbeca8fd725f308b17c3c9436aa4ff9271bad200d023d9516e72006a47a7e9e6bfeccdbd0beb2b4efae3f326b2ffecbcf0699db7b67fadc7c16e3b97811e75f702ea8b477fcdbbbcd3cc8faae4d65c1dc7daa094cbfaa3dcb66482c21f46645de31c382e49c3e526a132d12f42bbad65facab76644ad61b10866eadf9134b0dbddfc22364f2e0b95ab296f691bcd1f631af2ab1bf0d433bd0ccf18cccc856e2303431e9d1052e3d3461bb50332c498a256164c04bdff8963eb95e59a9052805bebed57d5decd40b3fe9599f059ac36bb0f381eb70b81f4a5d9cbdf8be4d7300af0d246890c4d239d0bbdc359dcc4324d8f140408bfe3363aacdd99c724a5831737bc6905d0532bdcb14d57d13f5e709dee6725791beaec08240c8f768a731c1d4bbaee67c26f0d4b3832c8bd4a4dd9d9762cd98897fb69c0d017bd18bb6dffdceba4768029cfb9a9ead8e9824a17b3520b11a7123ff1559fb16e56a16d7781d42ab40c849932c3476e9e4547a68497545786e9ff560388e0aa3c2f1b6cca02b7c859403ecce73c66b3c26c2449e46e1461e633f6ab6f6fee858e222b2935f13c7d1969e91729fb771679947cd32642f006ce667b2594b3b3a87d77ccc8fb756f80864d810d9625d1340746f0af137d9ae09ba2ef22a54723f2d00b5821823f59a8db40df8b092a75e0470af4bdd2074db5762891c79b64f2db7de6ee6e8a9a6d36aa90e1cdb0a0f4e82689a80100789be99fbed906abc6534286e318a2fec9e15146d37d7af3fb44e24e74e455df678cd64bb8336e33bd7d26a1e0f17347a2dd79d4d52efd567a203e4bd59d1837bccc5e360ac1a668df95f4bae9ea31c25e96bd6de9abb970713933801a3b1d1e04850c083c38774166efe45562cb9e6efcba57889d6d14c5a943f85d5902012b6d7c07f85ed5d350231fa98c7a9512cef3e34f7c9dabdf465815d0a34da7721aaea865f8b0e3735fcfc939bb4c8043897c4036384bae3feca42e1f815fd4919aaf6093bf2aa36b002b993531de5b2658c673d7e48b5d0615391b5c5fe206984df82d11295698924f185d7f160d96ab50aefa82c7f7d15e8c051d07eaae100353f829092caec325aacdb29a509870bb967da08300e1a593dd75353463ac48687ed4653c05bc949ba822b86d34f9d793513d22caaa827ce1c3c8639e9c53dcfc82e099539e67f6073586a617fd47ce2a4e72739f67e4df85f2c6d411fbbf07e8581eb2eec8a9d70ea40d57760f22793ff457cd1014306982ff08da4040bc392bfb2342a65aa125e6bc8fe44fd389e51ccfbdbd8c53b572b43ae0c117b1f8a84ef34b4f99588cf15d29083490ae085d706085f334d28114a1cef9bb0c65e0dbceb406e5ae2211d0ccf79bc8dc1e5a61cff9a3f7979150a3876b8e23d1a3d0ca3b687ee228064b9ddb7528940129057d3f615db5d4f0e5923a6533c28448e520ff22ae8c97f1b30448ee64520281ca3921b60bba3810cb08c3bb01cdffec503c021c104bda278c731be891e3e15495aa941b46dee6c335696e5ddb8c7d45351622d9bac54ef964df0361dfeab00ea7b3ebd273ff747a58a5d499d4f4a8771ee67202972d70fceb6972ec1de4fa7ab00b56968c340575fee1c19c4e8a0e6fcc1853f9dbeb62bdac37eb4f2153deef1e458c17b6e7744f3c83eb20b72991efdfc21b0036aa715758baf073e0dccfbd2065d55b0cd3d038d49146f636878e4ecc2221de1a99d1e39585f45201f64db76eebab51d8d39e5e844310b9c1c24dd049fb619651e61c47cbcddac2a1721005d23077734eed4500b0f9a90090211e063562e2432ac4cf4ac80dd8c374c0d09b210d19eb02f119bcf15b3a536e826eb1fecc1d7bc26b850d8e0952e7ea1472cc843be665c112e0a6524dc80e7ec15fe7b0a0208d28dc1ba3380ef00dd1f3f8b45958466d497143ad3fd05d5691c0f2f2b6848796d02c5dc05cc566c3e8f91d1c55458680258731ee287815389bd849ee60379b4867f1542eca43988144fb66ad0b9f83aa13e0f564daf97d1ca507f4a01d843902a57fe98c6183e6bc46f339cef9b0905a7a512b3b3c2f651b83f2e424885544198a329f80084f3af6c5ac1ef3cab00112003340929759a619bf898f8742557f3acc7c0d77670f385ac018157b798b18b60a238e037df19889a6b97bf1fc68f1dc03710157b437f94f54f5915485b2b58f4abfbb5d40bfcfd503a46e4cb35ae8c3b3cbe802d6d31b1de7166091966a69ef60486d21391a9f070b1bc03dd9fbfffc4f208707c45fc715b9affb3163c55dcb94f9dc19691e11771ce734de1fec369e5fc2c46125738c480b771cb4223246eefc9c1856f5e05450e5159b18fa81e32d7577079364d995888f8773610704b5ba4d40b8e18eaff9ec133da13093a980d29ac169e8539e2f7e46c9a395b7f067b20d12416d33ba4d58d7b0139fa1e934c31421b7ec75da8b4f30fad9e806096341d0b9e1e39ca39efe7b84c66c244866fb4cfbb58223050a26ada83b1a144355553c2435916d4ba051580c613295a5a5426bcb33e10933c1fed28d3483c06057e1f2fc621c637719df719b4ae4fda7fd5495480d227cff042fedc16e637d2196cfe589e376bc26af97f0b84c526bf3e187b53a351ed989064fef2f9a25a30d75d522358f35b89758404f309e2a224c711863f90f9d2269c573c60818f365d9f8db0d0c6eb2dae275a31b403bf5564f1718b17dce09501817eee913348358be8d9643e875958ba0f9c1988aad56debfabc6c80f32110779612c5777582674cc643a85efa15e638465b149cfa997c88136a37bdbbe757bce5879fcc7dc12b764a578caf859cb08b499a8d7e6b93f2728b4ff69c5fd4af11ef2d156efeead8a48f37e46b3208c19024028e4efa5086030e2276852f8ce988aac2f09a059e1b09338e5b96426a85057170f7102231a856f848b891234f6b63150484406df3eb3ed91512fc91a8834b7c4a868570f3289547c9cbb9a1c36861581b4d996b7a29499f946f7e143b24d4544475fd664d66c04f98b3476dcac47d62a29607ccc29c0437e75774b010ea6c827ff8cea33f8f68731d3f83c00edd214d556ba5d98b9b82d3d87a0cb637dc9d296d58c2e3a3381ac8a2cafafd82c5fd36e858f38d32dcf1e8d4f47156fc295baac5ded41383254dfb6123898a4a47c71aa0232a666760883af92e20df2d5cf13903699748da8863a3aabd74cf14f3dee12dfba007657af041017ffe45bfad04d4a3da4533ab0aa9e379dbb185c7826426eec726f43bb813ea8736652c8e3e122bcc188326fb586514831a3eec3ef7470bb2c054a4d6a7a2ea8d7d26474670b60e9c99dc8e3ee9ecef365dc07a4b1b2d7d6ca27d078d47f1765a31e303503f5a10b4ac382fe7d78838600e0506918717ed954d1c33bc8dcb02b38c8152a6965bbc9e86514dc7715da33d51cb2c596cfece9e8f5e272a35e352d08139f3c067c401f93f42b0afcb2baa3a6ff9edb59d176887782e33205152aefbaee36f9a8893fbb16bc652c66a9f6c4d89d7d06b668d41ced6d1435c4e85485a0b77678052fdb53a9ca5047a3a68c5c17144d214895f56cfe0e6a7ea17e95564218be41c3fe5a8596a2edbf6d4d058cd9061a4800d6f85d2ea8071d0a22454382fd2e3e22586fbf40fbcb90b8acf651c603b41d425810cdd6c93248dd72bf81defe3253a0cd2beaa5a3fee79dcff23cf2c95b1a595aca9f1165591c84a6f344c3706b08ad4cc88803756955d8ebe1d6f3980a912aab5fd53c3be99dc6f81e4d7fad2e62656a8de178d256e5e07f1e6c7db8967561f848145dbbc36c2ca1e42d37bde84330fcb06325f274d111493bfc9641f6355e5ff2f0dfc8f08427851b4bc61a29fb9a38a437a078e8e2ae014127d960ab174abae279782fa1425e74dddc538536c82912ba8322a5c2b720adc91583bd13e6bf5eb9cd2702f631dce87512574e9659d9bc8eb9597780313d6211c351270252800463f4f8ffe822268176d7489936be28a5dff53f93a96575cbc15d950d8ddaa31ef8877689de23de0960012d98bc14cb277ad1eb9a0898bf2a5971e2c99a9f0c255055963ee0e24aec28f39dfc2a3270d477acd0282d4184e07e7a22d3d3ac9763ae4958a4573bcc8f6644207b93a2659704fab5fcd19a765373173d6fe45687636f9820dbfbf33a307149325f4d6516c8de0d6184f1e069329031bf89fd57eb6c2737f5358c8cf85dfbbeb5683e0ad95a52b9fdfcc59f3e32352018e860736a72786e1654a0a4a4048c1aa16790b2c86bfe46158081ba6eae2554583c957b2b2cd26dd7dd8943edd93f93855a421cd11139b5b84e75d21ac149ac6795a5931ff63a689c63448b1c9cc2018a00da62a6a7da75f201a71b08dfed08136c6844b24ed40eb76288d483b6b6b9fc524e6462052cb6b9fe5f6b0abac4b16cbee0039b670257822174b5995c3ae499602e8ce5975b40f093d7029b9dfdf715097af73449a14894307a65939fd693a41ff4aaf8db14d7a338d01870d5804272c54d26ab3b8dc0806eecb57f8dba4ae2447a31b0c571916f9cc72a17bdb61bbde779939c4cb14d484010af588e2744bf1e1403cdd9a2126271a131a4bcb42c591261add76510e0478083c33df630eff02ace8a314b8992b0a129ee025ebbe0c92f2521ff29a37afc5740bac375a51ea150379a263d8f873aa3a6ecfc004694da6fb7cff56be45092e785829dde0b7241498a6f91c44780e9bbfdbfcb965c12a08343475cc0d9ef0252522e539019792439efa5ad436898103f61c214528e216ccd275a6f5be6d81630f15f37e32b7c36397ce3408a7a7eaa37e26f90316c5be802c5e53156bf331f1d4442260f448ea5baeb49d111e19b1672f0e6b8cb12d34c6063b1ff1bcec7e17d643c6face895f083f5780f5c7599ca11a76991601862099f5d732e42a5221991d7d9017912bf5735c3a759e81529bc71bb04f8887e58df709c14752f648aae65a0e63ff6719deb57e5dc94f3b3ee0968e27479642708b8ce72a24b55cd559f11c667e18931ce994377e5a1c27031b2435e83eda4dbe079fab7bb90c11430a5d04b06e3a599e0eb720d3a864cabfa7d8551395823431fa64cef4680c8dcf94ed6bd943ff0ec5a256ed40474b5c466929c1035f1a948536aa92dbff7104793cc7ed2a2c79ded6e670370636949ec92b93fcbec27868b208ef68bbee31834ba1a33b6518b94e012569c287fae72b915bc2807aeeaa21b183fc6407ce0a5d402676b8f5a67e77b73126a7b4ee871da8e140fca0b5b9cc6ed8f75949ed7b96f8b0e6fca996589eb4d2f34f3664c4e1957be7d81a5d2aaa9aec234e0676d383e25606da3d516d4a92958791f15081debfe41626c46d8e5e6e1d533c62fbed84edfdafe50d3868d460997864a642a17ae1869da49e47f674d36400c6acd0dbff88cca61b84c3f791b78a24aa19ac14b16c095c68f4f4e37dba743d4aade7bb32324ca1aa508a9d22fab8117c25e429455091e1fff87007a9017a8fba6cf6db8352190c982c0519eb9edf08654c478d377d9061778435ad7717f6d30556029b86eb1e19983008744591ee1894511be348567ba99d527c5ce920d0391cfce1a32cc45ae3faa40deb517c333d7714a4d8a5533db1f4db057cae075f2c5947d3e7855b830f25eb76d5e184791fb0d999bc839a3fc1959227f5599b555ea2cce9e8ac9f28e941ea20c6eb1cdf8c60c2c2c69e94e5efa7a3a5d9bdbae0df5d134e943378bde11835c01ff54be18e0d2629173d8dfe0e3e74ef00c4e37a422eec6c2e53e9d66791ba13e19ac83991d502e834c2df77d3c2e2cb3af88392119d8f0ad65f40abc50a8ef5fae53a9e0c5bc62b427c25481df6191583c3a2ad09518677b322d966a0be656b90a6dd3287333b6028c7a9589a997798a27591e67db51a88b7c2c7874d1c3ecd560cfb2a86ecefbeecdbe8f39c2da6d15dd9a2042fd53cdd0c074f87de99c447f5d23c578a98c58f4ad70e0e24793f0b7115c54f13b149f4ecabd57c46402f68bb24ec3752af4dd042c87f6e37bcd85e28f0a1a550946a5ecc07da5007f8889740806590c0644d4971118b2b6fe3216b26eb8f8ec4d81c13f74ac0b5f5d4c8bab84628d965e461f64f626a8eb6cbbc7adfff75cc148197051e71134f46365f96052fc72e6ea4c59d2dc7649696c535cb2815d9002f813b6f63611aaeb07a184ad03598c92c4ad9b77e25327e8ea6f3e7a37125751f25549d9ea90df0264c9c4c1fbba02d5c4c342664a3aa64cc2a8a76036a7f1f310c1b24be9e5e0f7a46d5b0a8491fc52604c279a4b065386a734b833eaa5f0bc78b94a371d0b5071158e4f468949c10d68dd7a99b58f44426a324be218f1206396c7baad04c497111d3383f97614d26c3b06063f2edbe1e17c3db20d81a62c9b43d1605cd6349c721a00d25256a572f6bdb8e848a61dbff43be0716572bed3ed0fa8cd4ccbf59db42efc86245f5b5dc2d21fa2849f1f6dc631f146ccf233af5f70a26c7290244a6714cf216a50211175b0e1a197c5cebbd171e39308ad0326381e0820d9ea889bce09c45304675720e4e67c597cd3fc1e3457f9e0ebc01b965f6ac9be9e07de7883228742b65e38b5748ec47d0416c45afde710201c91b8d924674b47fc6f0372844040554cf88c89dfb605b91361f5cccb0f41d5dea5caedbc6784288a24703c1008fe792cf58e8e760697ecccb2f489ab42e4cbc1dce31083d2f7aec5ef4c001576c5e9d062a8710ff37a4a07c51dd681c7754e6f613378e9669251975e9f1cca223326482b436e940c4d391d0121044f2db476b924ce5a604f8b90a1982f47253b7b8a8a0ec7e1bf5f3eae941d4f4b2296f23156b815fe954063d5aaafd2e8a3adfb3b4c426db7268a6d2750efbbd1aa98ee085ac11d1d4a655e4a7c04b5da697181967a9e16e11c05aa62d1804852eb508304bd8f56f5438fbcfcc617267652f3fa6cdfc5e2cff2379b08ae200b97e02e0f5277563e36d9d2c24809dab31de961f47a08d7925d94d3bd85c6e355d647c8a21cc5ce14c745f39d40c1ce74c1a12393f45ce282c9b89c02f07578b1241c5803aa78858123a7c0d131ea5741c79ac50d05ed893993b17f34ba91279a6de4973ccfc2ac48ce1e0b30f9b717a8672f9d99c829162387d4a8fa6033d03821c8d9126713c959d33f754da0f93ed4f35de8fb454659d9df8006e8c4f9b2646e41dbad9fe8537c1fc7a4c5b17fec8ba510100c3969e73da0fd746c045127a0f84d74024b8cb649c922833c074c5f24321546a01650a7ae2d4dbff35d71b3186781fb2c238f247fa9b51d32f79ab859612b662a4deebcefe09a62c932f454a3419985a69068946319eb2e36fc50338bc38055352c122486ec0900dca17377fa65c59d92c07a6b98795f0b1e340ac2963607cbf5356c51c61523b0c331b5624ca48bfec22248ad061c7eb5e688ff78386e9b91cdde8764e7bc2e771b014b655657ad50c4f767f5e356bf829236c9a4830827309bac32b13e2e34a0e05be2fcf2887ebade6b846ece5f76456fa8ea4b34dd9d78b0e1604209485104a4a69b49c2a504a439a78f0a1b9e89fe233a129d7b1c45772d9c603c883b19af102d5637efe727ce90a29dd2c87fa4e26fdbd6e9daaf23542c08db65de3b1445035c7b53cee00f107865bd256d57a4ea8b8e4bf2e64bb7500601be04e67de8b8604e02fdf34e4f11c9801f3dbf98e5d1e9f4487ae60ffa856532944b63c93b1a38e20d399733defa4ae7036f475dbf4a18f5305351c73257ad2b3f166aa274dd2ba2fdfd8b0a821652a7f6eb2dd24f23f581b9c72b38c7a7f9a5e574626f519c7fe653e5a8fd5cdeb588f1f7fdb8e9fcfaf4dcfe80c7b21984316ff349ba0f6cf1975129396e3960528c09eb9a6b0572d04777a32a5ce24c59acb0ccc7911e4ee8d5a910f39656e3a2daa38a3dc3912007ceeb09dd46d8a4bbc890bab523a75a2074d9c6a462885528777c3a3ad7eef9e128549ee0b57a05090b62444e2a23f24357c7d2402a1d3249a36f76f87e45cbac13df61e619b49ab3365773212a43639fdc9432ed83433bafe09da90fe7995513c5df390f615399aa90b78c7df58bd1e15bec46cec13f88c7a2352e90215017b09351b804440a60cb727b68c6ae26a061a8572e962a6dbce6fb954a3741db99393bb8ff5812cc14231b04911b2fbf6dc230e04224b460ca53055a604a63c0236b28e46f39eb26bc8a18bf53ec3d5689b314d8e7be72743ca6a0f298f1294336771a9a8c074e4255b94381aae571d293ae855b0468c948e299bccc2db7243548cd2522ef18688b2404f7d5314efe7902c0aab11b5b9ba15f3193eb9167679f08a31087399ce758f04dad024d372978f42d9d143fb49ea64e4bd7db2089f617851a3c12505db3b938b82addfec140d759e10a9786c4846a1d0df7110682b4c99a3eb986cb7eb4e26d0986f81707318630b23e4bb751907870f0c68828f0aa99332084dc95f2aa4170628011d10011e1e7e940e97d33d1aaa64a41bd111e18df81b25f6d98936be9b97da9e3241306ca068f4921f281947367b10d743fb719acb992a7ddea194a1baa4f03908a98cc9834dc8a0682ba95922bca29d8942b63c6f5e148052ea9519201fd83dbaa6a518e3ef8d365d8cedd6a052c3a6b4f2d9e3d3410bbb2d1e818428335f168dbb36a788b57d96a6831f045780b31b89905ae85b4879e0eb7c179370d87259a56ae5993af5c23bbc67e5d91e1bdb75e1f470cc38d4b18f1642caf8e7a07225e1c3f778b08a9b2b12b5eee5812508ab4ce4eb476ccceb2cb6f610fa6e26474c65d0898f0d3b61738c2c1c9f2a1189ee11791ca1295261fb73389ceb914a1af72ce105f765d98f0f4fea77acbcc9b980495d97e521c5e0559587f75e3a2c20549f44ae3276c264a478cc429bda3faa07d9a70d06ef8d2814aa86b816ac39820c4ebd3e1d021943231ea0b358fab122b512d996d706bac47e8af47ff6f9449c36170c6788d819329d8e52c400ed6520b8cb3eb95ded8028132532a9882298af13884a11798f3b442d7fe56dd404c42e539836d10e60c32e9ab28cc602fe06b530cd71ad8074e6d8602d08ed799d39295db127a945745cdf2cf4021f33b9afd0efbe5d2c96c7581eca85e467dc83f2d44ff9879def96ab5b3947147abd3bd66750340d6d0e329f8028c1c8fe9c77abe997bf39601ec3810f556b93b6a75965a7ecfb28a654decdb86cdd14a56b7e9ca35fca1c534245cb5f51a656625cab355d93af88f403e624214361580bef3967792280488198755e439d5fcebad0abf78ec7e4f87e6a8ee7d232d91bf796c9bdd7f27209580236e33c1b1979fcaca11b73ed7b892f076be66afe542e94588deab3320920bceac3b650907086e6546ba3ec68a7f8f357448527402231b9090a2c9dcd634d744664e51c65e83d6f3a5c64dce0f958a9a0fa17c73139aa53ae1d527630961868941de31d0421c3e13d7cbe1e00736b732336eb1df1312ead0aaa842296f241be5c749b866adefe14fbc668cae04d610b53f57893ce4dff4491a44183e5e0341b5c21193f9b6c5638b22e7104485709ba3e465387dd1ea67bcc11007262ead38ce8856822b505b4d4d98f6ca24cd7511f8025afa7fde50a5b32e172478aa1bdb146f916d8137c1c740ed2b805b78ec88b7321f18d8a7295665a5daee4aa659a3579a24c4aeedff3105634b7774aee6247f22dc07c9a240b79896b0e5bf8791ba2e36c3b91995d4ebaef9a8e28b732fa66c47a985c8f4d0052f8c1e6d3640cb6afa7910b1656162587141c4e810e6f606c3c8b6aa501338ad78632a2e6c8d7445d9bf2a02ee6491efddf587f661767bbe3f47aa11463805ef3b0d929814b7da9694c348d286e636def97d4bb383e4c99f241ec831858107cfed6beee446845ef7441da52d0c6e7cfd3f09619ce3da45d1f1d8f4a9a72f6cfaca5fbe39619ea01239a55b9cb58f43ed5429a0b0f86c348ac7e19133112d2c7397048f38fd94fa365770ccebad260aefc586bf01b91051a2b20d922e0c34cbc4e0f6738b4f0da0fd53d924d126c8c8daad808f6081acfe31102369a1630ab9b9615278ff2aa7c028c50c533499dadf0a6e43c9803a5fa71939b29fb04fe08a59d98a77d27dcb0ec0e73a605ec3857eeea41d46569bc88587302e87cb5b2a142ac8b48f2c979389179bb9860ea09f3e3d5caa90505f25bc6c1f57e97c4bdfa12e91eae0d427b0f8681e743ac22ce1b25569265cc03be0550307d8443925d2617539f9d740ad5db47591a1b064a81dd71b8983dfce69b686a48eaa723ee03f405e7e30eabfdef9341c3c655b17ef6f754d3261a000a009b565c0f5ffa28dc8776577fc47f194539aa5c85a78db88460a209847b9c8b8318fb37e1a430c4eb9cb4a9e1c1871d4ff849107f75202e6b97b376298ad359b9fa063ee27a694b3ea05246b359e0cbd92a8a598cef05420c87b667edd39cbe83849ad67b9f0180e2a62900848ef3217f0ab89a7bfaaa8451a95568ed2bc1d7fa59e3cb35a8fc0b3eab0702f4103fcb178e79d9baf7fa6d991d25ae0db49e716fc1b051cc81b81746e0ddd66a0cbcc75e39a678ffb4aa2609863f57e176ee7e3f94f76194e81e141d0d31c6eefcd504527c2bb470729e27905d510ee402df6fe75ecf7656356f01bbf140cf3780868b678913d2207c6d324335e704633ce4ad1742d72fb4ec0af04bae8bbf6aac4c921ba0d22824600258f982381422c0487ff5623bb7a21ab8f51de601d121ec5ee682bd66b15739ab898977463f97d3da2209672e595f4e46fd737a18c5a1005394fea3a955f42761e0d9d53afb98927e6b2f4d02d75be10253f38287958f67af3d08e77a2a8e92b22bedbd0b76165e85264e2ce03b97885311c3cda22e49f40c69e1d5718840e609f69c8d85c93c96b170881147f310859e7524e28bc6426b5a1a481686ea2daded2908b1906f78002a32e187f2fbb9f6dd9479","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
