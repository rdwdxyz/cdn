<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c507b06ba1fe0aa0789acdfb632df5632e1c3b01ee76c50a0c0b9c81cd61fb2e396558efb36a7809450d3650667f42797f78bcc47dade03c7bc2e49a5880dd770a2e8f9a6a6a93e7fdadc5f0cf9b29bd0fa38b3500b0192224f1abde36320d33487d735e85dff13919f69e0fda3635f158c8143f5482b319a7b5a8a11fe10c4200b8361862647addc22a58d3ce1ae7b2649739e40c2b66fb6fc0319a598c6e1ae992a826efaf6a29cde2e2c56dc48920aa6e950a6303c93a3496e0d41a40f9342da0b7183f91035805adb926f0ba00754c74b159326aa673fb1f06009449acf2f9c88d8fc6720fcc1ce17cef33599cdac9141ba2300c199fc599f4d000514a5a5c3146e578f37639087ffbd7553f9725a08d490a8976345151386bfed69b1abb0fff332a8206bb29994d4f98d20dc2e6e6836aa25ce0237ba5dc60b5a8e4954ffbb0eb59aae2dc58f98f3f277d52d50078ca22d1160b96cf87e503578536954942a99a70d849cb848f98579f3e115dfbf4e6c651cfd76a9f3bfde09c2131a5aff05d8fdf4343cf8490530473a9df1ea36b259d601d8a4fc7bd5a26e4113c34851dc69a22df999dddc5fdbceed9d9e9ad36ee24781a5f12206e4bce04cb3b4ae4f3ac228005ec8b4fa89c809af4099bbcf233eb6f45297f2921d2f3ba4f9a8d71aaf0cd22e48f50a9a62490204267d52a115f317e84ada43b6ffb5c328066b3e506663af312b1b1fc13b3c9c0c9f601b4757dc41c20b04246c5d2faedd9a9521e69dc46066e67515b1b59bb28f54a6121287101a6746a5db7a5a7d9fcb03935944a353bf06d53b046eca1708491985b3e85dc070e6bf2963e98e01180850970528fb3ad662eb90ad484653d525c5ba3fe948384bbedc15e2d4e8c7e03d61ae00a47f2e64bd69b7210f2eacb0d84ccb56e4f64442f5dae4f73a7370f6d4a19dbae389dff1f366b4d308aa7ae7de2125d14c745ee65e56df03234a35932a1b3995af7dd7d479179ad39d8e970931947c970bfa0379ca606300ed77cd6bd74e0ef03eaedc944af76c6d34e5ef567fe944ccd35800493c71ffb20a2d7bf1d59ced1aa21609c99d961058b341c5558f64e2a8173407b541d64e4869ea2690ee1d96621c68b46371f2f34fa02a435a41c510e4c426ce7ee72cb1de504896a8395e38eb9baea05dae86b9e3389af320f13d358c1e827a16a25695580a6389c837f851f81faad212e67b7d9be3d01bbf811b22394b2d77a13099968a0dd106611fb63441bce188076e76719c99c416d19a8f9c23687c997c36634cd2ab2d5242918c153e82d95b6bd1b46d12505c5bb15707febcaf83852c678ed5dd3fcca3eb338a83977fdf1616d232c0cc87518a5c002b699b9d7ed3bc1e23c81ece26a2e13fe2ebfa77fe522b62a5b0e778771b191a3cb05c93024abeb46e4624c4b7d98039bf48009226a75dc66b9475061bb24d61877cae660019ce28a483ddebac964c1fdc8ac82b06df24f6ae7ca07109ebc78ccd3e70d540641e8aed9994e31806f499a582945755c2eda9ae167b407d6d13f2e60566c58a551264eb277c600cd77dafe927bd6e3184696464828d00de1a22625ddabe809784652d94e835285aa397d3ac7a00dff45360f7d0b3e632459ce5c498f19126ee3d0506d6cb43e21fcb4c90b03870e46a72e0f42736a090aad429b76576af076582414b5bc7b80607e166e5cfdf2aa214638f2ad70cad7676c2a1dd490ec16caf12d0be25f369d635a41a7cec4da366aa23743e5f0afb00bf9a62fbe1e3f1e75900e1e7f85a7d658cfc0bebe5930080a9c947d2f58b0d804c3ca466515279f0971fd074fbe2021e66645908b5415579bcb0d673108c17bd8827ee4dc36c6e3f769b0cbe22b65e56f7ef6df28d604c1cb8d2581113ea969c4e3e0ad617fbd273982800aadbf7d703bfa9278d14d896e3f5371492c8f8705f6579ac463161c840109b3f892d2d0a30e52813dd14681c773fe582c0dd568b825c48793a8d28259a8d0f4a33afa8960e3927c19cca86ca3b0e2f42946d94b2d94f34bde11b94ec6d5f856c1f1da951d7878a0fca40ed5b78f767ececd61d28a9a3d4ab14ebe601bb70f6b149ec33b78d24902ad16e34e902b2cf5cef5b284c6540659e74ae16c30310b941fd0905c6270908da546f43228dd459a11b62689a6e8ec5928bd7b9c693a6c160901059353afc276d412333d69ad89b86e72bf98363b7f5f18f345aed15f4fe4c1f3abbfbac92d2490088cdfbd04aa228af4f9657452feac6a6a221769a1122d082015c5f06ff581ae81d9ecfe1e73c51e07dc6a0835127434cb4fce5da25ae4cf0ce040ccc5a58bf4477c3468fa8c7f8da26d93efd2ee85f9f8ab6ae4f74f743a75831dc3009bf799ae5efc2a56ee56d95edf4e3f36097cd1a3571e1cc30cc97a8a180a562db9722243b6e44b4114b8a62f467f8461905be318ff1de60c46b1b599390c55922c96be30e37eeb03172f08159129e8a51ba25d04ca58a1c14fa8e51e401d982e776e5f6599a6db1dbae7d3ea60d0a0f52b71d2112f9b78617f79515b2f71f26b1a0a18dce0274bfa43aa3e440c5eb8c3a6b8cec8856f097bf9a8a68887a1c49c796b6a73c80673668bb3a93680b30fdb8cac01deb9de9adcc0c87db689035c3d0da575c4775c7d3e14ac8887d4bde548b28cb15b7603281feb6cac8c28b422249fbb975243d0f3559469e9b68b7443ff77714ca1b0361e607a3544c213be5688bf0848c058a8e511f1ae42c0c6b2775e8fa9a6ed96fa483a29b12f160d47eb819b293dae7db9660fbab69212c71cf41bf3e9aa342270ded8924f9aaf26b9d83bfb4d04a5f21278e42040a4192c204c82c010dbc01367e5b1768b7a4923824d43341832abd86d8e99de4331a6ad634edc6e7121406d9ec8029b0292ae8e1f264904a1afd72ad65d219abd5705359b71c6142c6b198b2aba48b56140cbaeb939b297bf7d3ef4cd8b82baf5af089f6c3aa9ae3284b5ec1e1aef68fcdb6dcda65ad722db5e32a50361d0d2a0696a30e059fa3c569e79f6468d1c1b210f50988b94de1a9ac5931bdc80753b028525b5f6efa45f9b9732d8e3d53882af629954cb62ca2a6170f268207aa54edc1a10f17b9c32111e82644c59bad54c6ceee108c081ced215f28ee15641e8e88acf9baa3a295ba64c1cd3ceffd4267e58c5f0005a71321fb65451592b858c731be1e851f9845229804b8289b1ec5aa3b178502439d9375ef274d996513897d2530ffeb1c07dde1fd42a34ada0efd6b225e2379cc0eb2cd78982954878f733afaf86e841d9d3d853515baf7dcab0d75d34beb022bcc08e7f3c448ca052324ea9adcacbe967e1c2a80983d053f0547018e628ebe3803e8fb480ef20a7010598bd6e103d9174d03c55110875579b194a4e73e424969d37467f9c5f281876d2a38d7ba40c730b71477665a7bf68e675f441a91ec61651636a5707da970d7919f63f8c587e8fecefe4428be05f87c3c50c9d3d660cdca955baafacbbf1a652a2566eb3928bf788acecbc119d38951e24d5fbbc4643cfe201f204cd3e08edae7a87ade6922515f624fe22316746be9b288a0e9e8a4c3042f5eff13fad526c7af4cb4a74deaafd84955ffc0fc554c04a3ad9af420e775f92cff5a443b548ed3827226dc20c68886cbf4e34838ce4c6226a7b9a36962a443f86128f72bc2ade1df57f442b9b57d654eae1961b0b72d575cc5c28c7de53432dac3c9c16224a9d2a4bfae7235058c27051d4a23034dc9fdc9d424d62d8de478a0376add76bb0142971e84897319d11e8d68c4c15aa6f9b225d35559b8862f83f1b088f771addd98a41950086e3f425d6fbdd50b8c854e9388dcce2d69d46e82ffcf227371fbb5a005432ceda3358e7484017108cca00889e1ac6b4d1a85dbcd115ad0b52a5cb535636ce0a99032ac1e254599dcb7289840ecf56869a19027e5a0eac54baff3af95b4719cef9dc208e6f2a2e2b28ff99951498d5d53a0999c74c52d1c5e4b391da24f2774a4b540c16f418b84ec9ea1439d716183af46c0d88ec5a0dfbaef65c508e4323a11f76ce62903994ba395bff29a4b87fddddb0fc7291c4254d3ce64e111149df699930febced85c03561f72ccbf073f4d0df33e48e322e75ebbfaa55d0450e40afd8676eb664fd50d3540d01bdac3cfc5202ae93748f37e474fcd936c16010830609d4fa2b381e66445a19386b9c0992f29184918058d5be9716e2fb19edd7610864e72a1b1696961559016c0f2433596bdbc5f876290c354bedf0ae7763b2fbe87968483cdea1370ecd1ce2df6a8ae5127b7ede5b43d8fe87ce68b41943c7ceddb0836bf55b0c4c3b1fe2fd36b206424887a0d4e4f6c6d4c56ad355beaf7c90fe435e546c31d12d0273b1044cfbdfa4d669321656275f7b9573df514271b42130c890f10ea9d9bd6ba74e11d2a35eea08bf4e7abb637d59231c4439db47b9ed75d3297a58300da38535b5124e12b1e1b09155f59bbd4d5e79f993e4f9c9e2a9e8856424c0ce7251b3e247b10cdfac1e9e0a3b4b95d3f11d4495332509b8fa0f572be511924d4d14cda428bd30aa7664fa2d2a890a0baf554f64c7ff76eebba84bb0565250440e173dccfd9d10741a9ea871083cec3cbf62c35f587406a13840abbfaba70c33df74f53d418066a8d892a3c7a5db7ea4476ad88c5d39e18623e8c4d9656b56e660468dea69675d51182bbca2ca7c18858be87f282e307497d00b3e4bf238e37c2b74c949c179211573fa0ddb963f3508a0ea4f6a3d64d8207c097cbfea1ffe17136bcc2498cfbc04a15da4411f2fa535e9dca0cb8cc937a99fa2943f734a7414257f4c682d5cc780b16886cf5fca0fa0de82b5386530d4dfab3dd1e14f73701fbb4d665800dda3191000840eacb7b43c99600219226ffcb74091b788f74b307009153fb9a44f64e1a7a64c0b4faaba1db11b561e61af75b2dcaa74a0a2b4e0fae48cd59fdeabc7d987ac15d4697f7d1a91e3ad035358dbe383dc90be08880ebac370cefed68495d2f6ba77385c180a01f97cb78e75829124cc5ffc9b8dd73358dcdca2eef20824c13375d7f8991344ebcc2e6a86367eef0f1a0a1f72f26c4a5c9fa4135c04267f141f43058e5b87f24a079bddd9ed7498c55d866d3cebe0667a8789d4def2439ffd4c6a7cd0c18b88fc564c150f5834be457e6714e7f14b2c1a6596b25abc0f5f34e71e033ce46fac3647392895aa6ef9ad025502dd5fd040bf650e4d24f81fc0157ad36a600322b8a6d7c749ba5154a7b36073de9e994dc396035aa58c7cecd48ef73757a3608ee24cd7f3d2df98b894cdfc368ed58e3a232f3e94618b8d123d29f349eeb8b624b966708c1e133a7c68c57901ce42d97d036c0c2d4e439529511c1a77607128f104af62dcd532e377a4a6caba72142bd9c51ddefb027b41ac8db20c1f82bf925346294acfacd28204df97f8c9cb3b3809cf74d8d1bc9600e8c9c66c5fc330dc94526d055972933b44bc13e558a3ad73729df2d661ec4b639f9f2c3a249d9ac09ba9c2e913f67587224bab7512f3a133487086ba7117c830b31e78e1e016dcfae685a695d66745407270517f69960a0563f4cdeadc7bad12a101dc812fd2778184da9a932bf386ad59f1f743f965abd7dab75f75328a223bf4743d7f637d8d974c8516e1e94edd1582f655de0ce24b5e9674e532601f4b486c090b631e12a9cf7cfe7e2178c3df6157b4cc52293cb425fff70c9e68978ae0790cc29686de2e947c6b6445d82215462f8083deb477885952554177207886b29d09f608e380020c8783c2e9bd398460ed77469ac5829f3cf15eaf5c5a3e132c38996aca366b6fbf602b9c304f787a965c8595b195782bd2bc6627ee1683acbcf9ad64ed39a4b0391102adf21c9ff6303d3cad0cd298e96c235d23c525050ffc319615ae8bde0ce32d997214ce33c86a33bdfb6173494b00023d8a64ca9f3c61b73fed74a52114185e289624344b037f58469ca6ca09f15ada6b4d6b99ae36c8b6a1bdd2741c5c1c62625431acf88f1819863b847d59000c2c8c6135f1e10be4542602e30260d66ebd57dce4d7c3e966b27e5fbfd7c0f1996d13f673ca998a8cbad734a663b7707bff063759014cb9579b48a29df7da524472155579ee12b799470c8525b3260ed3b7e37257a2d12d97539ae84f86d782f9b8704e9650e203d600a03e23df1f5c34da4f3d4812944e40d3650bb0b4c3e37b96c5e7fc238d7519e208280d823cca90230cf66ab4db4a95a72778f44f08114ce7a900f28c410e071f728b8a5b6f181148be707e48c376fb637002cef22a388da6c3a938d23ea61a12409966f188ba93c657744dedebe02b1ad24f281ee274b9fb768382abe5e9ba8e00fc0b2648655b69ad4f5676370515c8056223fe5cae8f847dfab28db4e9377ee53b709a5f163a35606a359232aa98b2bbb8de38e5f51059ab6156299f59c11fb0c5f5ac3e8dd6c4cf31915302e85a424a976d520a1d952d7a28fffc286a8a525ffeeb053d40c493c5b296a6486ea82e2b211653581030a8d3622cb0527ab46e16c1696b6871178362e3982bf10182fbebdda00c4478f30a731cbb4c3167da4cafd6c8653c3ae13ac91c114cf9d7b09b116047a048ab61af6a039428851e04db99360037d6f4c2dcad7af7b2b21045c220eddc7971d85b62d03c201f2de864e9cc4470d4df017daccf5680fc858e4e3f622639d438d03f866893d4d462bb5a033fc1a2bf070ff32f147e48eb482c158bb7b84737a4687ba797b70c3204242e3ca66541a3f97c143f38b4fb8fcd8ecabc8c021fb3392f69dc971aebcd70a5809cb6cf90b742143df177a83f1d92f87f9883245851251979240275d6d38d3033df9aef1fa8a4fa482d0fb351630325deaf677047eb3aa16d144fc47875754302828dda34d81e37051348a96634dff240c68e458ea58e7d888a5dee8386e5fc5fda0cc248c858d9d29a0148cbf16f8af0be0a6caf4f0e696fbcec62f62346039031c5e9667c9ef87a500e95b0b64fe731d089a9a490e1725a8022ac8e138d70389732aabca7d78cdd9d4b9be361ace87a893ed25953caa25b381adf783c4fae193f50cb151060e5c246af44d892f49666a087523fb8cc928ee454ff0c2eabdaf4c8ec206eb2c75233324d6fed75ee38e872444cf2062118f55a219a83fb2d5f4863054e36709fdf6e60d1aa2584910ab22a46ebc12418cb01d3ddae9b736b416e9118a10107afe9b52170a1df83358bcfd9510bedac0883d40cf5f3da4325b74a3b72ebce01ffdf525d13c025ec8248790e8fc2ce824dd5174b156088df20552ee8927c941bd37eec63d9986d43cf396584979b80b9f00980031822620abf89412b5e718290316eb7ff95df654e40c953fe13ccdaf5a037cafde006951efb64368f8105086da19cffd1474ce49cd7958440836189d7b4caa193f0c2410aa03ea219888033727955a868be747ef989e32eb85b9f45209fe9aecd85e872c3ecde27f6b60a8b548eda84ca004b58a121ac23dc5c137180346d0618e5a70faa98346aae7e750cac7f83ea13420a18fee69b708b4967aee310390cbabd705e377fce63c5f0fd98308a444bffe5c38779a9b6fb305dbe246a825560da07a7662b2d74876fa7dd4a1d8d7e2b2ba55cb1ff4476ef165f7d89d3dc40ad579438c8b13c9ba8424fe49e2ac02dd862f191282088eef80e020a976790291d03cca44fe570dee77d8fa9bc498822d522050e0d0ad0628653689dec6ebd00733783fbb94dc5526fe45aacd22a08a50c0df62cbd07ebd78a861fbf085eca6d2a1875388abef24197c954b5d3603f189261f89516a4367409f69721e4df7dc8666eee9c4ab2214ec37b161040486625547851973cacf7d4c6afa5f70a4fed52d9240be43811ff85ec51f8c90006b184100f82750cee57444400a148b5cb314391405f006d97b92b377ef82b733771d87599a6be52d685c9e61462580a99db6fc7ccba65b3abb15cbb333cb7f85f7b99fe7ca4cc7cd16cb5b52629ab1ae21bada1df79a0b89e6033ccfc7263489689e17f0f8bcde7bea6256a348b2af94e5dc16404cb94416b2db34b8369ed214993bbed3ebaeaa2ebdab51d5dd212f74bbd106cb5bdf1257dc0ce3dc44a9b609359fe17b17fea8b51ba281ff607fe6a05379eff66f362618e78835750e2fb6d247d56f7824ec1e0cc35bd4f33f237e4a77ba24cf150f7f63b55da9d4a29e6caeca3ae0667510b315a6480cfd562660c92bbeccbe4000dd191e733cbbed7d4c1bf67e60819e14728111fc7754010fdfb3e16c7f0c74d2e5b1b15e96ab9ae5d0c651c5fc48fb69397ad811718aebe2c81277cb7148421ea5204ee8a83018918422c80c0bf1029fcac6b066ca654520da4b59fdbaf4b0d822b1f706a80595fac6726fb67faa7dc4ba2a6d8876e9b70141685898472a94c9467dbf0e3e577f7e27f9139ff6c881e3853ff4623e759b9d5df10802a0f92519e49ca4f238ed091edb889df38fcec55eba3ece3fba4f97e863e80d74d07d016745278369fb90d0483e8666fd7ba5513f1f71f7d30f2a1b5c671666cea56bcdc4b7c0f483471684814681edd416c19886cd63baccba67a1c65df92afbb0d114a512975bdce8b4e9f65bb7b6f08ad177253e498f29d3a0ce93640ae0700b709b64e08a9754bfdcb769db16fd7bc45f081119a278c0200acdd47ad98b75676abb8c90cf4227f4e8277e66b310326ce5c840c582377a9a8258a0a4ad31718b94930900e91c16f88eb58f35d4b4da869e5055c8bbae470e658e00d911d85b36d0ec7cf055f6afbe8ce31337f5a66c49e3f0381fa4886e48ec3e09135fb541fc7b56b0a9455b49451ff7271d56b244b4ddd97af9d461bda814edeba30e48462efd5d5d7c0f8ea5d1a31556cd10a1b97adef95867ff2a291ac28a136e9cd935cd726470beb59ffc55153bb85483437d8b9b4b54b436e7654b3fe9c877b1e623ec5a5f43638ef203fb4f5215a9ab985025f7ff79fa7c8e1d0f730c9b94c438c766eff9cfe0f77288350630ecdba0fcbffe417703cc27c61b573a1ed68a4a1440400fccb460e4169ade679449a8360116eb2e868966f354dc3fae78e43c1fcb346d3250858132e4402a882ddd40d0842099a4915397f3e567252d07703342587c142da17417a325c75e6818ac562261e8bb3869d5cf80b480c97678b21bad40ba2ecb0be79fdc9a0b88fa1a516a927298c0990677f3e7ab0684a98008273d24712020e6ec9f4390525fab3788c72edae4d5a471409d5f80aec52b8a528be3265f53ff05d4bf4bc9ca5ff21e8fe59d75982837732c10c30b867bb77fc6a568cfd635b4b449fe8c6077355f14e42f06c8afcc162c6685fc7e7a5ed864cefd652996f8b8e033f10ed5f1603e25000f80b3b226122c58013d5548b7e242d7319d3ce1eed2f8b6b23e60c5d3b0ecb65a80fd1fa34896424628ad859f5a4954e258952c9206eac8450317c636ae8409ad6b4f9f98002b37aad547aeeae4798ea09f0bed60c7468adc0982b8f30d2297efa97475727acc8d9a37c19bc38e2e807f9a420f69ce50335dd27b9ef08caed004df83092f2e8f501fa56bbb4d65876077f282258ee900c8fa5f98b1b9354cecf2789c5dbc9d85980b03bd72f9d2dd7a99a27fa1bae700c9f57b77e7806496f099c15bf8941f7d461bcc2430490b27dd5d7de25082f2251a414cffebf2fe2800adf8144f22b55680ee1ebd45bbef6f329d36f846786134d3f2b56ed8a8980e9910dea009b9322bc5c73608723f6e3eccb30c417a2873214d5c41fe778613c2ac9303a876b663f7f2a858912cf03986540f240a2faab98335eaed47c4982bfd02a3ac77cf5c95d4863d7bc5eea48a334f00a6fffe75c4d26a4e1ee18131e63fa238416a0c720dbceb129e320e40227fd8eec35d555c2862cf329af3dbb926ca40c2224341d123aefb4089c3d9805807d72744e2db19cf0221cd2057c609fd93fec928c2f5685e730b2e107805292645cab2526caf6967b4c6c5a699d66025870cfbfc08d24c0ebfa91930e161ebd9de0161d71c432717deeeb317bbead44697f75fc67161190b92b418896c05d682b7504627e67f6a31c734af352761860572d438e90eec9cb32409a201a522752a85e2de09691a9b019db3b42df049e7e36adecc3a93c0a5072e65cffe2029159d70aa665cdc354c71f8d5fc2f7bdeb4a2b6142c109a7e25ff3aaad2ac7f8e73afe5d794ec769c786c71a3e8c741426f9415d46a0e939048e3ab925dc2fd79666e6482591c4ee11d035577ef4faf2f7d392db8ea2c25c48104ca4a783f03a439a3fb23e8ad496ba0d894542c671ccd224534425a8c806a17f05e0f94ba973db6d0bb038e1750c099eecfcb41ed4981be85e939b7c7e7d3086eb178b83a86b3c419d7bce593b08c9b29e3d4151e93b5a6220d07d584c40d2a2dbf715be94675e2e2409e758f25a342054b8673ff65efe364d8bdf6706f9ac6504258122dba7258c45c285302f6f43a470ab0b619e86550276309c4e79c22b53cdbade06fbaab8a2c42748cc1cf45f34bbcf2c0c0424f70aaeb7edada3f8a9973627c3b633492d43b074f1ea6da5b85bbfb7b65f759db04f8731f53a82235f4d106c936647fefc8b1d84c3bd212432d5efdf9855bc322cb41ae2bf895bbaf0e6f913a273a3147012fedcce3b2e7bc02b103a0f662a2665d81801648ef882f18b599df11c127d7b6dbc86c91223add8e85c6cc67b8d76dd261f0b222f25b4bcef55499854455d523296a309fa8c0e6e618e03bde9d734872f694e083409b2ae59dacbcbf1f708e5ee1a4cd0a08219196b16923fe9513c6771856f4b1ea16db750539e1cc254ff68f90fc054370dbc32c4276da5ffdbc4a3d2ccd703b12fc951c0a29854bdfab555abbe5dd39fdd45520fa8d6288694976f1f98a6cfa024f11a369a590378b3719cf49e423734a0ad4dbeaba8a4f39aeac707d0dc06a0e0fc31263be2a679c83521133e9e3e59e8d5000824607f0e6c4dd66c0087465c002c87031b71beb6d26c77836918c19a2dcfb9fa4ae4a701f6b443cef7d9e58096908565e5f7ddce469b652a7dce511a843700d973da37d68f228d38f9f7a416fc082436df2e85ca1abb3fd31630ab66529dd77ad5ba8e844cca7461369d5276696235e55c7f20cf10cc2dbd8ae3e3d77e3fb541bc7d12e80c5e3a75380dca7a9aa0954442582c0a734c83c2b2824493a438f4c2979ae8a4081f2f9056ff1219e6e14413136e42e65c3d7a38504da8624d6e19c008e1e4c7822740329e4431121434d10ba50bd8b0cfee220f06554261cf9834d3b4c58f9e09cc4b4c4dc204d0024a26350f311acad224eb26d8ed8aea7a9c62e4e8c6de2d4ee45e2915cc9d3bdf072b7ba9a494086e7523697e38c47210a52ac319793dd7b72fc55c5ade4cfd9cfaa5891493bc6409465fd5c26412f9ae488df160e910b981ada05a967f76e6f9aa8c97067f460f4659a0c20e7034a2322536235eeb80dfe6987ad25296bfce7bfd9dd99f805983b9cd218ce22d4af0b4754fe3d47887ae069cc208b253d598c10c376145796e22f45c570437f51348cb1a2c7c1295008b603bce6733e44b8f83e4876a736f7f933b54ffc6671e54643f8db10d13a6472fd37d49fdac4a2307d2e71c5a782fbf1bdecac386c8f9c9a96e4d75d0aad8a44046a6d71ec79078bf30a4f0815f157c3c1ce45a4fe57ff11c4c15722533f98b66dadd7ca88a9f452f324da309ba3c913366a8c14e8d58111e589211cdea375cfe00f3b049bec8ae3c5130a00fdc41c318a82b2acd8cd2788896b1e2d93566623bd74a01ab48ff5866bd868d71afea97553434baed4748da7f6890b88008b98948806fae4b94f37b162c23d32b38433d666b2febf968023010ce90d4504e7f7edf180f20de46d8749b3d390a6740082d13af71fc274704115338702b32a2887efdfa10fff0418beb67b565dcc3b1dbee4d13e05e803f3a370047b9526ef4f83e97fe64dd07ab0e12c135418d598301891f96a19c0f6e8931640736b68d24ecd26898c9c9bb8528f81b2a7e5a023c46e5a7a69677a77e41326700791e87ea69422b05d3434e95963c0ea4149e751e30561b02385da671442624e0198ff732aa5040fa3de4301258b33b0acbe96d77a61d6efe119d9f0ac95b383ee94e251b3f91ff448f846f9ea5a47df58e5fd1c4cb7e4b04d130df952756220f5d66240b9e7a9687b2adf211a27eb03daa123dfbc27ef18464164f4f8cc680a04639b259210e70cd578a3d2bdb7fa777064c0fa8f64feef5ac1261bb4c977a13b7f440e4d273274f4b666afc983b9087a0d388ca26202ab232ed209d0e3e4536d37ea8219d58b3c839fa585cdd9c6cbb74a8043613760cc183d1fe13070493a2ac87dce780784a644e2ebce77141c1fcb5cd33610c48d33361473662221a987c0b1ef3f27f26a9c5b245291292862bdc18cc054496b0d247f8b3fbcfd4564d8842e2b0e909883af18d12b74bf1b9cf8469f8c9a061f80fe0650228bab250a2fe32ec1d1f4e96e230f024b8564de79660b7ab741df0133171113c619fbb09d77718e819ba22831f50dba0cff58d107d07e5f8a91a9ac264ab1876ceebdf71b425078554ebeac59cdce80e3f8cfd2c0e2f390e8799886f844588f990f0a8db685fb4484baa9e335f6c760f1c45a91ad2146f751342dd8be9568a04f5806dd7f571c6a3fc827df83cf2c6d98f4add0aec951af7d8b1202f9ebe7dff97e939108f55c348f9f34f43bc484bfaf6d1dd83254bdc710cbbd0e32dfae6c776db81d33162947e6486113730b91eec7d31735624c0de2eda5d111f916782cea9d6d1ef3130110d09443a73e365b727c03b61c4798e07d64d67f73fc2baf44019a353ce8fe6cda20c05d958ee6194bad7e618fa15f706c7d4ec8b25953d4f9bbf6f99b990ec0605dd0b78b7e59ab09f868ca6f09c66574ad1b012773549cb47b3c124d8a64bce4612d02bf103cfc30c9559a16bdce0342974200cb7298a336a5e5f527326143de3c5cc9ddef3b52463f965fd79a22c1a9c0fa19f62a834209a98f2c5869b8fcddb8798549390e63f6d350987b73114ed58862c717a9746caa4dcc20a04fdef73d285fc84860a95b5c52a05da5135575bd4a9cbc630372ac0263111654fffd7dc9e756dd52c8c506610e8ff8b95fe7711e1f0a3a51bcb5500ae7042173c123a0a02e40456f5f0d39cb6f1eb639026aa5e1b4be66ae2accaa967dc312a05332e2d8f77261bde694fc868c7643d8ae67badb3c8acfced4accc537ca2f83fdf87b0002348690d4e8bb09d75e91659c4977289ca694026b6f21ac8887debb46fcc18382a31b312717ba50fb8b74cac3b5c7026168f97c3098dd09f6e191cf9f4bb34fe0dafa66feaa653e9cbd3b71c03c34f40afe60d09ebb9bc1304172abc9a47cc4cc9c89214bf6b56e22a0327ba4db0a4a7cda9d8902675c48f148e1f6a6e0c04f960c755de8c165942978220da2ef0c18cde253dce5856e5cbf3bbf108cc04bb3fbcdd5b4c00d3494ec3ab5bd2458717993f1a0358faaacf93fcf4d930bbbe2dd852f8e721bf2cda3a8eec41468869a6ce5cd2563f2c3f44ccf1cb856973cbcb9eeea552ad6ced4077b29ebeb9c116edf15670cfc08db41f6f5ca7c2627855ed1e8b1b1b2983acdc68a1a880e5dacb1a89251437cfa1a68a9490eac07e91ccacbdfaacf7dcd033e52234b688f71353b253ac90b26ca62d4967e17319375781d2f027ee777157456f304f681018026f1b3f210aa6e64f4b75331440efd2a392f9a06d0d092548f6634b80ec2121df4682622466c82d316ee1720264bdc9af89bb1ab5fe25a9a261d85e17dcf75b6c961772243380184c9420905c6e974e2fd95c2d3f8387cab0bc5aa14332314f32ad620d99d2b347fde867fe2b15da6d5f7d416ed09aa7a5b46d499d3f6001b6c21fd2717919aebd3bae8b175bb2687bbd470095bd91a2227a37c2d391ab190aeaaaa89ee3a32df56c450ca0e07409cacb1fa1411b328cbfab2c5225e1d2c562759bac9db9eb640580486cc3da17b97f53a20f9624bf66d2dba95c00e6dc73454ec22bebd186d2ea47fd0ba61bce8126aff2b7a82b5312a48f654a5c000a32e1629b8b82eb1cb993d32ed4f01df5d38d2737dd0ce6a36db04b542822fa33c8a2ee4750c491f469716a0c7eb6b5afe85166f34e21e782d9b969f63f81272241af9cf0ac467ba3e6e165f148c9b20d29a1be04f627dc0b0aba0c7d569cccef98634046fdcd4c1c4b2f43552d264aaa8a1cb8a7fdb8027870ce97218f9d6d78dde579b7be137664aee91ff9ab4b3b2b7f19f481fe35b8eca6c353101ac986ab5c89d192fe41a89ea0451de5d8c5e981afde35c0ba5215ad91b52aeef32debf81b78ce0ea0d812a98e1a4b25c2e4037ae5b81a0f462df3be7bef93ae7ad2bbb23c2924fe900b05e8f77ee7a6bd52dc396be59c3004dc1838c5317c73468950b527b69bc81115433a25163fdc014c13e2a2e99d348654ce3484936001049465e0acbeaf801fdf8db525bdc19e542b7cb0a27e05e4db9395e1627af480187052bd86e21718a61f244c3d9aa2b8b1134a1920899f8a1292ceaddf87bd793482aa938a4b9a52b668d6152cfe532c1f34fa7a113e0cb2c97a58796cc25432715b2cbba263b40680dd5a7044696099f5552fa146f1af01f184e8d43e7c3e886a3e79142cbe297be91eee740d213b10ed21c7be7217bcffe70761b1a0286aa70108b71764f4c8a1c1d1f2f24c686f4b6efc9fe6acc45b5c793caa60acb3cce1466c29fee73e1c15d3fe49d14c247d397017a3a8787330731bfe3ea3a00e88fdeca9b7709867bf63c180429943ca3cabf725459d792d0e4b72a7d98ae48fa9359ba2a41e6d16c40bb605013dc8df7afbb35900caad5397b91b61bf207a669bc15ae9039e8ce686e39cd086b2bd5b97f815a45a20be94111e1a8645ec091c7304ef99224ed6be077dbcfad993780959b3abb531fc47f484d9604fa23f6a551294c3e560a4f5c06cb0c54da89b7f3e60934d6f6a79688b326e8edc7b735d67d814871b24401e8459196bc05174b74e0d4dc0880f6d80da73aee8f6481ed4350c5152282e4d8a056e14c9308d9badce6526f0e23f9ac8564ad602941a92e367a356beba1cdd15a63184dda0cf502c6db73e86592a2f0bee5396ccc46e2d8fd9cd632688427144d4dac2c15db26617f947b282275568bdaa2f63bfdbcb43319c1593a06b70d79fdf1d9caf3bbe36271394ed16d8ee0758e1ba2e721a21ccd50e0424e81ff4cf9a47cf080492e251e04fa83f6c5b57c768cf321f157abe68a3441b2356c5b9f242e4daef575976b5b56a963b3b5e3a40f935b3e4a9323b6c79dfe358c05426f6c83d19dfe8ddc618adc4307e2b8c44bb9e5bd12ac9ce5748e0e319b6353336ac70da453416428aaa0d9b2657cb19765e490bc9e221a2637b56acefc3a0c47438963b484f380d7f01cb4218224776afa1fcb0210e042e0cbb80ff1af7618d41d3a502da80a27cae9e7f247252a687c5ede58292d8bd4f7640da61835340f8a722f96d5ccbf6eb71aec66360bdb7a55361fc435de6b9b27245d5f560fd52c4663b3e62f2ad4dd68ea41e486062eae059b5649cd924780a97bb6c1bcbdba5ee5c3a77973803073963c86d23a3381d821208880a3f543b2919319f06bd617b1fdb852cc5eb25b54167276691cbea8ab6695e197c563c3c58f5339b0686f226de4c577719f8ececc0a7d410dd88598cbaa575ae669fd8a4a733e8638387496bca017bce8e042a544e6014258ecba2ff34b51d5570519594de8dfe15f64ed93403a68a677bc9fcf34b6aea478d36d722cc1c7091ece25ba8ff8d7387ad6e76c851013c7c7cfd408c63536833047eef008cfb3046c54fe6b356768e7d137d666eb7994ad9e386f6eddb1c95ba0065a5228850f7df2a47d24f8b598dcfe6be4c92f72701ef086ac0786b6828f9a691ee0c611f85cf0fd4cbe28d404979a8b63b7542d3717c7ff135f274811323d9b63f1bea7665aebf78a8161802a671544cb3a98cf447b62c047bcccd73cc1de24135a0a7d9e622fc7a6ef2b4be9609f093758778092c74d1dd79ac0bc1cd5dd2b564a26896690bfbb75d63bc4e1cc6bf78c623cfb49a8537633ebda29c377ede567347da6891829119c6b69d141e8c3ce818c4ca2c370e09e8650fa2105f5ee0ee1558925b042b7adbd5c8aa60427fad5a3013d108b0b59afc06862ae45994d01440c0f039efceb6959e32577b928cee471512b8c04c055f60df1902a4b8d95234721533d722b8a2fa0b235dc659e55a89d56b330d6ecb3496d222fb0d7971c55d6a0d6300dba97a4a7451bb0aae830601b8ec108206fe6460cfbe8781871499d4f565a12018a7f1c9f869910c34014962c7aa7ba59f47ab465be396afe05f52091e3af40828cbd96abef00c0ac40cf25bc69f179b4c18994d2befd1f9bf8deb21b883c5dd392b5bafae6d96018179d3e69f73fc6bbd0283bc7527e8a82c62041457fbad80121dca200ecb2c23258ef0132b27989750bb5ffa1e8b4ff9b21a7287632dfc0235700f29497d3abf45dfb5619e0e65065c511edea8862aa453c29d30bb4b2bfc2dd04c2e5b9b65bfdef1e3322af628b0f758c72f703adb53560da7ae89f45b9926ddc4affdaa45fb261914c40cb51cc91fa4b8c748321ba7dbc8f7ac69ef39c42ddd95ad7eba291c6cad56b90c133d769fb3cbe1408a3a1be98594ef1a520b5320b29a357fb6bf648cd6db23c5d931a9494a9db6c8cd4b0e9e978fe7c237dadd2965f9958beb5fe0af1b7ba043d7b3e2f33d26af47a6048077400243e1beeed5676b30874e2d33c78fcb7e4f43caaa10b9d2ef9cf07a12a7d0672153d43863cf806b6171eb4e749870c7db5b937200381290a9e80b12d6790e2b9f7f6172a41cea4ad8b73d08b3b5af63da124c20237c71b256c442c3a86593d3873c9b4d1636eeef9dcc409e567d0f10cab2b98a9086f75ad7efa215504b8cd171515fac1d203a7ed5dea096bf6d399a0ef4390ff5b3fd999c57d7a3f75b8c0f431a0cefa9b280fdb130c44069c6f81ea14eddd913b086904ba34ad86f9c76a99078eff5606f3c103875a64beb792f0028662497cd4bc97a680e3c3726702f828a2af0ce1539b384f9b451dfd8f64e46c7a9b16c3224897595907f54e70c77a9e050fad9f80389efdf2b30e565c96288275d2a8bbad3578ec54b28c3fac87be5e252e56a5717afbfa06c965704bf5da014b867a6e8352d54e97ffec086dbe724aac8f43196bb02b325e825a93145a23c636d07edbf6cf9e25ad65bf391de9b9b93f275c2d748d4972cfaf0e21a4c83e0d307507b09746f04c4e46ceb6d00a6f1fbbbe9663335482bb4f5e188f667175b55ef3ca8885419b7a3b1112abcccb00796ae8e03aeb32aa7868273bd58843935ac0951a5586fea1b0c0182077fce1648cdd245081e60e4dbf52c3dca272b276c00d094957263ffc120b5808d613a02e1eb05d252d0b9cf23344867c121b858c1a97f1a531c7286a94eaef0a2ddd3157e6cedcb5bd97cf9482f0a299410605f5cfb8f88854dc4e92d79eac21cf27ab665c819a5bfea7eacafd5cc1314254c1ed0d5fa61ebd63088802616394c153fef1e530d322f18987ccc5c790e8f20fc7216ba7a7e307f57d9a74a27783ee2ce6903b74410430378bb119974fada493df0a63c76e23062668f9502a2d16a057ac21234511b3c581a6b8f8d19ba6f6b13021cfa4e1b8b684a05851f3d4e53003b3f34ff740f8736e42c623151a604d7e61a4365ae153bbca7ac1662fc6ca3af88cfd494c1785ac08277af87cbc7562e32993cbbda6ce893faeb5c01585a068048757e467788e1abc1bd9debcfa19a727ee012ab74a2ce3ad2b833c5248b7a50c8a98de937cfc79f8df95d5daee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
