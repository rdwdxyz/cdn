<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a39804d9d299976efed054832e3f1c682410683baa8d8dfdd6844aa9968c472f9d9166a93ee273cbd2466c6b3aa7f3507e28856bd18986d7196e749d19c8631a9635ed458095f9ead52360132b2642f9c9ccc7a9dcb98a482ea78889fd275e69c223713d784c8aaa056a32a3e2b985dcaab8a9307ca8a13462f015b76689ce22862777031deb15d24ac090fb5a2edfe85e6020d290eefb49601b065d2413944d1f8264e3c19096072253d013fc84139e55d991428d1116a80f04dcf8bfdd9f4d99fbec486a93d9bec56bdb2a3299fbd4d3c03efc70db0ecb73bfcf45989bc9e8bcb6cccbe3cd463b8b4b5472b1322955e7e48e1090fc65d08dcd8c7ad2cb05e1909473003214f341dbebb495e8b4d1ea5594518afef0d8a3b3a836e4f8b968999db19110f1f650e1e38403874dd56d964dc94e200e4b974e1317c900e0e474681400c04fed87cdbb0e21972c4da75cc7a9a3494719ea0618d9abff6ea6205f6560926b992308e92144afd21820d0ffe0e69777ea66961396593ad074b3893e1dc5518ba51e43edd2dfbaeeb7e2524dcc6692b431bb35042f6f447f41640b7a9aab1dbb12d507f32dfae15461ff183dca526063240830078090a44346b4a5d4263b55eecff37d26313e51f089cc1c88fd9ff345ccea193168957cfd2c8d85a47c0ae4a690a2e9ca2f6d4e4f6c1accb7e28024a73ed6f83509024a14596e962640978f8bfe5e300568763079097867ec94659c003249e2f114ab8deeb83ac74aeb433f16e25ce5c6a7017504d49a27d086e15f7c099a002a9beaa9f1313baf34f6b04218000499d4a9526254943cda95073d54ce7c7a04d35a61a29ed304bda0714705d3f14ad603981bd21b55f4e9c6002d1541619009b8be60db7d5fab8579473e640a9813697c99f24edfb70d8c024d7573d0f6f49e46e9b91a3819e4bd1c9bbf705631f5b42766e42274bdd31cd49d7a4572ef5187be93b52155a598c96eb69396d50dafb4de58235aadc1145b08a6164677cfea48bb5e67c90c176954f4f0d1514c5caa20995ef417532fbac0aa685fca360b5cec34eefcb221a7447d8aeccfd1ca72ed9ae5f920ac4cc94bd3337a63301f90177addf9d897979d5cb1a07d5eef5ab6b46dd2800c9f1675f21b8e72e88eb5fed1e9bc5310699000ead1a17199c8e40d56f6e3ff5a1e4be0248fc8089499e2314f694bb239d559987b8aaf7a962524c3871b8f5e4997f162e60ce974e8047a1bcdfabbe308a36357edf6f019ceed01c94a4b8c79160e475b3766df1d46dffa89e3363c33935d9c4b620edd29a52a8d0353afaa0b05996b2aecde08b420d247f88b02c10aa84f776ebf559eebd47e01493b62807f3c84311569646020597b918f3eebbb41eb78092949b27b3ace39fb2700fcf690b77a7c62ce17dc7e2d54495a70cb1c180a5100d998644ac224366511f731338d946c9539006353377bc46b3d47964b4b3734dc9772a15fc6f6706e755c2c92862be3afcee595cd21f8b06f83b373fa81c3b9eab91617f034da0ba865e259622cd7b2d441c65c480589ecc25a2b3722df3a92e8396226b9f9a000725b9190065f76d8d28f8eed63127e1858902b0c542a4e67db4aa3080e4142b1f1f36284c1a649619f98e5f7d8b3869c0078dffd48f30c6e02fefa037987da4006c424dd605267bba7c986f564ea62dc6a3252c6da80e64357256f9e401f1c6ef7899949442374a141151acc811b7549f8576eb0a278e8176393b50e1ec0ba52b4b53776b285d1f00fbc58b9cda96f0d37385796db219bc8b812a3a0accde2b843d1728d3db797ccbe80725a0618babf6913d4427bc2e4a45d2447930e44b9b37fdbadf350d40500a1cbb74f202a3f1258ac893629d60a649227fb5498e2f178b0693cc968ac2ca7d8a45e3e6a120394872e25a7d0f9602e0e1004bd6ab31b6aa3e51a49705957da6a137bbb362d78e088a6832dc3cadbbbcf81dda327f617265b613623a91cc71ed9440faa280433d3f1e7daf1761d6986425399e2e920bc556c60fac4cdec2e5ada8cea67aca8f338abdd633332950f98f579ad6554213d389b9ad176cd9013c49fc0991dfa1aaf49b8dedd3f80574be56ab7ad1b6eca42166fcbbaf131be7a4854ec52bcdd3b954844b4d67d4229eb1db8313099ac98e205a2f15d5188e0581cfd8fe37388f1556b8912718e8e5ab70d759f28c5dab96091019f9f6be970ac877171fe465da4719acff882e9876ea14b0f8c54f0e987b01cf14620f3322046b5c62673a5f58c7ee260010f5d7674f0fc8c6ea45f1a18427dc511c6c0c5d939ba3a2e95f5912c20880e15fb6be8764b5726113ec55c51cd7b70087ab1590bf148c1bcb1ab0aeee688ab23057048636fd5934d697b93557938cdf5dd7688c921e00f2db40c200c30b6bb2b7dd550af724092fd4b5a6400fa6e4a351d9d99d96465242d3abad2748751d663a4028cfe078569c50a45f4ba345a36f816585ded91387cae5362a3b54c8fe419f6fef3d3a6199e3e9bd56ea8cb6b0ab3edbe063ad2e651d9e40ade5a1eaabf2ead747b27e398987580d12276ecdae0829960b01e8f7d083d4e2c2288354529497e9ab109c04ab03c556e854b600abb27d3b991c31d1d88f15d55917aedc8f145ea00960f7c4b34a170f74d8429868056572cd5ab59f0bb42e9e0711f5f1c8c1c85589d4fe0231e05208649b888c0eaa7165c71b6e24499fdea1e687128d6c5e342bc2138058640b2494403c6b3097400e63c24248c84e3b297b8860909412fbab6451a6c15c3917ca0d9f510313c0130e2709cc095ad3b7437f0b402ee6e5d0dde3fc1022340635c7d88a1332441f68251a7f8f983d4153bad7ec512863b0765228eac6458b95c70c918425405f3f227673cc6305096bed5246066f7d9f77ca2fd8141a30fb0f7b853c885d4eaa86c4e7d71517598bd39967078ca7e7755cd1f824c604864921f317c663a624eb76ea80ec20d33df92b620e83a3c3c179ddbb5405a56993d67403caa4ef8861e3b6ba5ed3e1f7ada41a392b2700ddb5542dd623aa82f12ce825d64531be38bfb43da42a2de8f6254858d4fbd48fb16ea11ecd45baf12f5306073b78b3804e634b617c151f86fdeb8085f9883cf8bcfabf8bdcb4935e15e13a6a1f349c02221718723d04ee9758b2f85ddbca4f357a94cb435c15c1aa3629472d8990ddf371ac9c29f2ab710e5efff4a0918faba6cf3826d73c31d4fa6866431dd057b482d5df33963f49e59669f2dabc07ea45389d83f7c201b76a711fce8a81e01ac1aa05c1c1d759e710dc15d32ac0be70f3699b63035c1f0747c8f06773e67dbd116c0dfecc07b420b30ac9f0c9bf7789b6634881ad9abb05582ca06db7ba44092a7aecf2373a6c7594375ac4d3bf37112ba72f044bd2e8cb8b8d8f3bc0ecf8e726337dd54fe654550bd727b19bdda2d1932a95c8d2c2d982bea86aa5b1a12a199359aff029d27f3f273dd054555c7953c1a7d50990986555387a49939cb33ec46e3daeea919a65a36089c9ff7f9b7ac95e52e23963bf172c643c898a7266ccfa4442839e0c133259e6d86de10c581ceeb0e08db306bd10a9353662197c84667fac38eae228cec725df79613a0988ea5e160d4e215c32775c9a1b6310bc489905f56a475e6cf95fa8142ce8d5fd10d867e1146b2a1d36d1a3eaa3632c9cc464956a3bd5ec5a1b0666b619c66cb10a0af7bd7c1ed3b3c90e99d99d7ce75f564a9d85bd8dd01296e1b08b00960376e90e8c148bf247bb85092a10555c17423a5ce9ec278afef62f5435ab3ffb31ef56b4e65b51fb170bed6e05d2e6829f26794620add2b9969bfe5beb5927a838a8bc50a4555c665a94cd47d3dbbe3da88e4fd8c5da2912d0194496999f511955a32f01eac2ef15410b757f18bc1b47e378fb71c2edda92f1dc1b79477a8e680d709bdab0f6af84338caea6d589b69b6feb83eb31d808631f99df765c67c200aa4dba979eba2c426e56eb733ff3c563e4771248a61d0df3cc8ed2ae2798d85411c7a8b69a5f996a96a27ee41899b4e097c3ef8c7f2d836204ce892e6743d724d4252a5bd1c0c9eb7b0f2286fcb9707de5e4ca0124dcc17461f3187dce6070835a0c0a424a0140e7e790756bd7f78dabeb7e2965ac5daf1cc4fc82af4eb6d72db61ba60d3e02394bcb93f6cde0880432955cc8a152563b1fc428e57f2bc3ec7310cd637c13e1e07d6cbe5771dd78e41844a3f31f327d5a1badfb714310fed41c871d55280ea9dcf729526159060fa198c2a72ba3af6aede3a4b840a34597102a34b21648f8d6516c1d3abc5516b4810e9a4534cecd8ff5fff017ceca40206dc15633c4c638cbe30fb10b614d71938f5486f763b798a0e2be7e088031f262298746e245196c8b2b125d892de7d784fe4938537d95313c1a65b1d8a0adf205608bbc8bce17ee5c8e0885853b7eb2a1d4f96ec36189acb5e802c606d7359cc63ec43e043770daacd467262e9e457563a391a833e85b38ffa3370ced22446cdeace45c552617ccd567bdfe9285d4b97cc2271a5c1625482c807cf089263734f969324dc46197906314c77964d8d0eeeb1fcf89fc751d783ec303371067a8fd68ecafd5441fae06b6d76c9791d914e195de391c0de35513141fe8fb82ec215f4f8aab0e7ea82b74b5d2aa5f77c986fe1a8d05dece42f4a76d1c35948316738d73717b4734fae3e2782bd981a6158ebfb51ef18eeb8674569fa641653cac64953e2bb4122793040f2234370035dd2a602d7e6b3ff2d7910ba55cf252e581b2e0f822b3705171ebfa8777deb835c47c4865fbafbc72c65c101d7c8836236ea9347526b06eef61e2b266a4e61556d3fc99057de9e544b6cac59c9bb3cb1ac0b1ab47151d5c3d29175861ebea4e08e73e17dc1e8cdb098094656c7250f7f2897a053a56194b05ac9de1711bbc592147191f869193a3348c825e1906daa398541c3df3867aee24aef2b7a41b00c4a251baafe7fa5c968938bce50bfcc0e69e6709aa47f5058b215fce7180d04ebfbbd864de0e68dde9ef6ccbe501888a774d78fff392233930a2b39128d337cd0f04fd77aa2b9381cb8d1dffc67cc54eb056eee7a973da0d40f0d995279f8915ae278554d9f8b289b360e2cd47ff4e00ac6075f5f5f8112778efe401fd39976be31b924e15148784882dab2041cd44169ea65fa19c4f2cd89da50f994df4d78b7d11c7ba926c5fab58636a3ec390c49d79f8db0526cedc8f3b641fa23e7aee19e0130a580e37a9a2b842a01d31ea3f580e42a3531265c53c5a7a0939b8c201048e114235f20543ea0988b83b57c9cfd980d24ce8b6e81522621fe371022a58d0542cd3d7a6ebc7ff8d23f2b70912c2ded472bc61467d524f42aed5cdfea2bf267df89b94d011c91ac1d07dfed1ecc1873e9677eaa481209d440af1af2ec3ced49ee8cc61c0670bed9c0a6f05139e63845e1c10ea32dea5158210147c7c7fbfd7a97c3e1264c7d9f9816003c91bd2ed43133dfaff77f45feba9553030b9e2bba8344e7262f7fa7966eeecaa121a729b09645c54ebf85b5ce6fc30fa952f308a80d9145ee1d9af36f3e67cce9c25af18f89074d6ab1383a82895e1f02226e2f25c934353a09eb845b53d75441ade617f91b4659b250e755c5721462ca09deceb86aa989fafbe499ddf01ade65194ff71083384418983ef4158d558195433a7738a8b776884083375a78a17d4d8287ec87878e633aa2aad262a4a0da12651e36317f21370b5e4275f22de20d7749537393f34dcde0ceed3e6c418e668b2ab871a622e4e3ea0e0544bfe041f7ba350fd2cba87e96da237ecfb9347564ea8403f153f203b833f480a8064ed4634b9955748954d62519cc87c034453cfd95321af11f2d7d1cfc62c4727b44aae6ab9ef89ca697061df283ed8e23ae37e36891d9431afb7f6c77295dcd23a5ec3e1772c67edaa439b9589a94acc78a6082ce1f06824392f733ba7399dc9ad0d9a48cf3c3e8a2d3d1850e53df24c053a0a334fb04a458f71409081e5c1f19c4caf688aa705edc916ac3ccd0785f3703abc5bc3c7e645bea8c6ec764b2e47ce80dca1e5c166b95e3bd98f3df89fc2dc7a21165588f760dd7ec6999fb87214d8832c5243c5232b84665081217c9179447c93f540a4734e301c1bc5f7985c0057a7a6f8a97dc2994e4dd8813c895bc060e9bc4bc9ac0e04d6e5d9acd1249c440c26b13a0be5310c39bcf8efa4c686e120939d291c780acef7d97ba91748fa95b8387bd76a66dd2184355c2160b3f233d7fe34e00952132e9371a734a955c4d4d8e5603dca37d8d4a177bd166347191b8784d8172c1cc35e9b4de57344cbbabd3da1719528d443ceff1519b5edb581d84fa02d57f2d8938fb7e8113c388bd87b55a8a928b6c269e6bf3fb1e552dccd082eb3fd0b63a9e0418f9126869d17629dd5045c54a85d128e951f6a6ec764e979baaecca81f4ed10602a7253e4af7b6df2984778910d1a77fb62aea8536f5e2d6f05b3634d511f61cf745004a1d04ef0e1d9cac260608407e2d6630d7dcbdc9e0b2efc3f7556dd32c5fc09bc1211fef19befd4d823e928e51f0e71b059f56c94dc67850aebf993349838659b4a4458569f526a5b52e9f904b27ab4579841479ec39042f8182b5af6727ed2d1d616fe157bb6f4a6df9af4188f4567f9c0714907148cfa61c0d01ffc96565a0d2b0b1011c94b851a2e07189f45d0b2f0a411fce19d4712f861442140c00af7f293eaecd52a5b3f133de75659755ac01dbb1f74a9b836c0a236986d9ea91cb73a5b1010fc1f262a092b5d34bbbba5911ab2bc6d88be8a580759f2ee9811305190f1115a2d1bf5bb0650150acf88131502ae54e402ce67c0e8eafd497f2b23b5e01fef069d1fab5b19c372edddc1100fd813649cd8fe8d4f12b252384e58ef2ae448b3c4979a7230345d98d2b868d3ac8e52d4bdcfabe2c321c29bad5f18b63ede67f45e29f6053f21391f47418a14cbf671ed0d742a7af5c5e44f708afc4e4183a2ca772e86d8a19c3a4051689934278ec45017cdd51af4c3b9fa12b0168f789ef43d8382d13779590a845f2bacfa8b56612a79e453d85fdf5e038e8dd994aecb46ef06a71473f2c236670c87c810ec829b3e058f0589a2f4002b12c6059b20f2c852e645c5235c7ddd327e306e09306700758766eb47043310afa2f9df62a3e5c2c9cd1698ab98f59d8d5a4be5c55bf344979294f71914f8bcb8b190b2190ef6411f2a80fc71d46c71ffcfdab763b59aa786cb6a56dfd0fccec98e2b526d45c3f1b5c5f338e5011fbbdb09723cd954008ab316a3f341887de7d523fbe3b56bfbb0a2f2983af9d1997437e9519f5143e884f47d340ebf03e01555f5c29b2dba22d562563c711be81da74b95b0c0f832bf3f3496f765c76e3201b84b5f1b150ed7c78c49d1edaa3d2f6a94fc60c462266b52b63eb0d36b0fc980970d53361cd44da3e1088341f19303246811ecd0354a68c3012754e7c2465ce3cf63c8086d23bccf0b4ac462307635457b0f38fe95061f73dafc4a45bb365993f8fbe584dc7d73af44a141b8707ddb38e9641e8cf42aff7c67213fa61fe43253114563ac770f386d2c8d3bdfd4b4bb54b50d0f552b4e68ccd9d32405c24ffa274f7161f4edd3aad5bdb8b1da482104c21793ed79864d3c122142c6a6362768a143661a034134e25f92ba5f993194a418d2ebb769b164b642eca85c282d44818c0b3c4faec422da38d534d8c5a638e0e87196fd62a05d3f4e49a26f2941a2e38e5aa9ffd839d54172115dabd8e86be89fb0c929b406ecd96480a7294277280963d3fa689a0eb355e75a7f133835901773447b0afbe49282f832197a46f3fe03b48c0ef431b00ffc3907a5b3212fcd49a2ab5aa975049ec58a30b1c300c7fc9953e49d9ba3263798ead48673ffe60e6a59a4901251db488be9842b19569f40ab6f10762a813d9c3f8feb1cdbd7713eea4093d46fa43c0b0dd6eb1f5dd1ba26e793bb49811881cb37c945bbf4a81c9c5d4fd022773bc993c44502e6821fc13dee3b5de2a39db7f177b1d0c2972be187b6bcfe11bd1e890824d7777c1787f3350f9f07e094535f03e92ef394ac01bb4181ca0cd3bf25ed5e08d69f6d6826b5dce3c02e0e0b6c7ca1178ed2ee66fefd04c983f850cc0aaec1bab7c099e82712764231158e42d77f6f2b1d43c640184035fd4a32d10afb46edae61bd470c7ad2f14dc39b2cba1ed3388b44c4b4e1a70ca7852088c04166f42503a7cf19ea35b66eb0e6679121bc30f8460575beb479fe11e426737bf9c46ff7d7b2f99b867148a92d7d92a5866bbd60a9c596092f4e49b745607a2c0f327248f08a6fae312f6acec207ec421f41a9bd2845b3b3f912c0a5dd0426cb46b27fd69fd8a3dc0692144c4fe77e0ef89d4071fdd01df77a2d2a63276dd888d167cea46ed8f2114a3a191ab2c10110f21cfc8effb15f3412cb12f282390da19095ede9adb37de40e95d1c9b61c8a9d94cd3bc8bf3a6c6de31d3885de19655d445b41c9ee1fb8460e3b95a15c9ffb82c8946c41bf97d9fc3e80a88486011d37b630d0362a1a097d8b63bdca357906025c616ae9c316088e6c26035eff358950102ec3e769437058353154f841741cdc39424182c447ad14a977806dc1ba5d85092c2ad017820fa83ed25e880c69d9d53427f61813d10b1eee7bd62e19eb822e8ebb5f5589d1e096ad5cd4a139eca7e1a7b36c128fab6eb17c352c9860a927294c4b44186e09d6c5ba0d2eeb4972e62c04dec48222e3f5a95bb3f52c0ddf61a57d599025d8a94fe2a4e8993e5aef89aefe27824eea9e96cfc2eeef2f08b48853bff81fa4fbb34c19d75929756d12438861f1fa4588e81411f211542a1f20ba165966207ea5a168a7f26147ae3c1f5798ff2321d2e706cdbf200278cb62ba11eefa57aff0b2422ba2b4d92d752a577d2ba755fafb8637b7e161ed9757345b3bbf0bf6508f7d06e64dff85652e1c14683b3c38cb1d9f719a8916755c7e18828a9ec75957d5087dbc4ecb6eaf2f5a7490db471dc79f3410964123c4564b975d9f6a8e7568fc559e11a21a28ad872c4c1f5378c9a3520e71f4f0f5a2538cbaf61d3508958ee77aea2e60fc33dd49b2a3c62c2b575078e826ee1d9eca0c32e3ba641c688e51e2a13af5e558ebc96ce96961a06caf6171d3845b6a34eb31b8b329b029c8c5292c255327d97818c5c2503a2800785de6c28f73706c772b48592324aa2904973e3ee6b4b1e5e6555c63bf2adf0256818c34adb13f649370e6043793d4542b322c6c0d42c98cdfe006a5295f10a305061841717f43967cbe639b3e03ccf86e9e12dd5e09b0787c13cb2132bef607defb0dc7088f2a6ac92fe7357e696620a9bf3fe0339212c622a0f9cc213ceff57a5da32f9e01ecc364503815c27bf44ab129defa502cd5b5d7c7f5b290222faf4ab2bf5c53f9c31ef7c8b216331457197936d2a8d1dac19ac3c1f4c4a872af072d328cc1ace0fe0af80d22bf4f580b3b9f5b76a507af5febb1351086198196f6575ed33aa4addbc685ecaae7d097c9157c5ab0d064fd941a72049a819f5eb1b471db793b26f528a5ecf46384e110d51bf071ac013057daca82b55b0113c738a8bbaa2c6b513b0d0bc9e2fbdd44709af28eb8292c834ec66544bb0d84417b1332ce25f5331ac5fd5e2c1b039347a48f4c1c9948cbf402b2a7d2af4a84fc8ae94b40fd5695d0b53bec4d89a57ff3b6863bd51c30bd2d301baccaea788a5b25a4b457ae486f0ca3fb1ba02ae35ffc0f11847c31832fd3ec682d45b9b084ab2b7dc1aef4355288bbcd059857bb334812f4e31670dc911d905bdfaec50d4709a07ca67d86682d32fc8fc359862fc20d12ce1eeab6f0a69d202e9332922472eaca7c7f03f405e72f565a36de54037670c12174ac9a7b8a8a8e2571444164c3fc218dec80736bb0192dabceec535fcbb6ae349666371a709d009f8433fa0fb449fa8b818a1be301db28f281f5eca4b9c2825786a740af1b92fd9451f217ad8ed0b795aa0421fa01795ee5acecf638b92215e2da4b8ccc2c4328e7a8e50ceee8f5c108bda654d135a778d0916cb03201a2fcc4e0fc91937fd6241d3d828d6bdd3b82a2a244c93dca35401098cb36494e26bd32dcbbe50c3370641f0d792fb099fabf9795a69651fb5a98f6ca17747ffa7179e54af2380892618437b6e9581d5a82e385689b2295180270cf6e5c5090b1330ead2c73022b2f85a3bac3d00cf3d8209bd93a99424cfc09e49c863abab59be8054aed1a71f455e05a1cba0136349fa8fae52ac2577de284bf4d5b3ff435b3aefd69f5edd153807a4b551f2cb8021cd8c34de7d396ac16f877670317849685afaceca31470dc26ebb8b0c55c47d3a1f1e951fd4721e35e7b8284c8ab8971a723df49c46d596409a3be7bc395fe27c2f20883568bd24ab86a63bda803b493c1d341ad059aadb15c1295a3cf50fec75b939e9500dd2113abff82e53b696a0fc9b29a7652e9adbbb88e9b2da0f2c71e9bd3c1300ca03c2c2adb1832628341f6198b7c916ff002954c9bf636b2f7cd9a24b1dcd808ab681838e19ca9797a9f075a160e2aa8e64501e8d6be1b2d4a59e715d9f7bb1be13529de47076d084d0a5e9e23e32d0d5595010489f69953699a446faca539471b8476db00c769b2234c3810e1eb1d33748c43dac4d00cb6b9bdc5eb029b70fa6ba91dd68fb845bb8613d1b426f7d69513db956d72af40b416b98bb7b10483cb994e960245637d0e1a8340e6f024729bfc8c23284c343a54c03b4f6c92a1dbd5b0eafaf0eddab55c7f785f4aeb2e986185904b4fd26f6a5f52fbded9af4ed352007b130a20f4c62544d64771e7d8e13cab756447cc218f07ed9b15a7855c5c2865ad18ce3a5b4b30cca2b9024ae4c1cdb999905807602909507dad2dc1f882976f531fe1c8a781e12a1ddf312dab6e4e74e6a03394afe6f0a01acbdbc37cf81f7288308b02ef380c20af8c185558dab98e6adb99cc126ac0ae1d8e6bea59a9899ae036dd06d047bf5264ab9ccea702dda0fcf42163ec2f2b07e4f8c542be69132311b35f2729cd6373d830cd088aca32898003e4077bdd237ef7e4b13b2467b72bc4669a98d22616aea555a740a69cdbf6ad5fd9c0e2a93146b9443e697280e3865e24264648103796eb90d64f490d213dba7608ba9962a419c22d660f3a297459ab096d6d51c1ebdb4cf20d18e5ff608945ccd883b6a819e18c08cd6bda8066ff4c5a0c45257d85df1429bfb16799ab8e7ef363348e1adb6ef183409fec401ba2081afddbc2f30d1f0a66c552a63b1d9b5aeee575679d23131fec3dca25e7607f03254c626380d57dbd9505309f8aac57f8e79ec54ac12e8ff88e74b473677843c6b1539d40a5435af95657643f2c5989648f734a954e93d62b95e1d6bf4482262feba214909789e564d2115ec35fdf6e7a488fccfb1ef3b1718f8732f14317124038b52a4df4642f1d557aeac4028c12b6bb799555a42e9b0a2c37676634ae70aef7f9fc120a228d367d49bd0b3fc559761381ba663420e3de98552a3e186d6d881cd9989461e564d6063c02909704adadf6d1d66ea08d61eeb38ebfa4fb3c65c37650dfe8a22b087c3522e830e880e4a1760e3b2e8704225560168032cecc891d2ad17d4b0a0447c8ac1a4b9d2f64793dbf22d0d57e984ec956ba142d0b2e9da28a9b8df564ddbdc6391a1b9633cc4708d94c3b3d01fdf4e85e21de1b4a7ad86ebf65aebb4af6ca6b7183552bc1da9938f338f42311ce070e3fc3e46580c68f10e80866d38de181fc7b688bcf91f81e7f89f24a7fbaa3fd6a0014ca22fd48197d230852c64b09db8d80fd35b5cf3cd85128bc29349f355b1f0e9abaa158a73d8547b2986e10581f724da92f41d795d42d18191aef0cba5ddafa8f1a8adf3964506ab03c60bfd5e749655182a84429bd498705e0f72e35b13d6efa052e405e177b5e57d166f8a70e0d85de52e1080309ee94239ab6af58043ec8f5647b029f26df4d2ba9beb6d98066ab7ff7c92be5492baf58ecfeb563d75fcf4c5e9812a5df2e268cd5b93a948a93f4bdd346a05f85fec04b10a2a2f46ce66f1c2b1d165e3e5b872149ea573728f30d5f66c1b82ba1248502f0bd3b3f243d756db40af5cd7274b9c8883d7efb46291a98afb9d4001e5e43acc02d4e2164d0964334bf6b22dd1ef682935fdabe9a2e5e091355ec38a5b708f1817fe1d17931ed3529abc32bc10e1f6be199de12b01b4faf337b395127257afe25d65629ef46786f4a733d3d6c0b9858e75b535700995f08610a13462aa6b9baeed68db075e02779155dc56c74c49f633f043fb359661f57a231379fff586edd8179494a4d4429de7f0d7aa912946dca87a90d20f822a15f00f480ccf6229678e88e31faa07a5d5d31779ab3630c0782e137e1c4d93cca96bb73cad1231d07345e6d00643075819c0d38a532260b9bfb0adb393c2833b6bc01386fa1f6fa6add94a29a3c87bc581d6c6beccba377ee3cbc6c41841a9421ed9bdfcb6cbba8eaa112ab14c53b76d16bc27b54f814e80f495418a2b95dd386ccf840be613675997d76e9430731001a1bba04a9edb7571b98b84da001ae19a6d8540309a8edbaecfe9906c5517f60b6bb63698aba9e3eb3849412424a002299324f08ae8ce17736a454d0947b2c788e29b5fba6c896a25e884eeaa667216c4c10b33808f6c9705f4437f946e16b2a82427624c680574496623c39a82e036e95e65dbe6ea54932085f1b38f1e001e448565bdd646272a043868a4fa34a4112a4139ea31f495385500ad90e030c65636f41debf0cd5d8d09be386401591030a84c203fc88f5f1ec59d3f60af7f0b2337586cbefe2d624d2220e45861d81e2ed8dd3900351f4ec0798f6bd645784555c4c64a869ab24cc73bb124797ce8321cfd87422adb78444817118b525be453a7ecf93c9dfc1ea0c1d0b98ed5bfebde1b3e74332cb9c76858f04f0cf50f2b028eb6e2b796cb02c694b8e8d38bbcff6db8293528a1b36447b552a7d470792c0383511ed7438911a7cccb382b9f4a1f7e61b78d4fd758d8ff66cbc79d02dd34734c60d054717cf8a3aa63f9c7dd9f3992326bd55939520257fea5f7cfc6e696aaba3fa43feed52feeecf6df969f56c4602c10c22ab4638acd23218629a33dccf4c1a8e7503241a9e75f497ef9ec648fa0356c7faae7c8559eac1f0e54bcbb41cb5a1773b4046ed0f517a88c13be787abf7183cd9ce78825cdf22f3af9ba7e31fafaac40bb8af7a58399a6ab05f858bde7421068f646f713a5cde0a71047708632f9ac81fb7e960b9b78c988a65337f91239013a8593313cc2447a1bdf2ca24508e56f023c895be988b6925fdfa87f8324a4c15ab3581db93971534c5cbcbef3336d4b4dd76aaad797bfd72b08f5c8a7d74582b63ba450f89b65c7011759f94d84773c2fa0ea0d320b74db40f3d6df7a25da88e4fd19116e694b2539eff43676fb04e228ed99b149039ef3284938d709bcba835b72f79237a334327fabe6ca5316183821bb140d22477c0a00844c925534e5844149fa069c4e617c1953f998f50e6e711493db9a1d817310c1ea785f58e1b549372f3f8b995979f3d82bf4d307e871e59583bef88707d3ea5afdd4a9d43cb8fad66cdf26c41501d8cdd2db7cc31f2b03b62804c6aaf55a726847daa615301e2f9e8e9d8830ec5d1d3f846f47493e7ce1937e6884f1334bc5af624d140518b9f074be550e5eb6aa51c82c14c55911d69d13331faa0b5a8ec78a29f5db40e0c0e77c755e01f636211faf6e5b133f0471aec5e37f6d79366a8fcc9315742abf228f895fdb973e87940ce85679dbc428ecf022cbbf1db1f6cab89baa8731f7ff7b5220b9807429ce27fa7892f6eaf1ee3a7482baa57646ab234838fae6b4148c04035f77e9708746b5730acd80dfe55a2d40c574e59a38dae75702d1871e8e0f5035e1092a4ee126b20904679b4813fc818031b69fabcd61a93913d883575ea9b1f4b761a1b04f1af11d53c3e796731f869d03509d0bdadd264eb344701d60edbfa56d41019089a06d4c555b5b1377ce69e155f7bef81f6bb98469b241f08db499f6f52d6ea56eaffd3e03ca3362c0ee3c8d288d1cbc8d1ae7ae1c170ad132077239a530e81661a4dbe728f7d4edd0c7d64b227a249213953516b7ec60d8fe9c258a5d6e5b39f42b0def366e89868c38b4f5e7951e395651f82ad7df46d2eec0627a25a2e0921cd4b1e6049e5afe02572a4b3e1999659e3882b1e7ed7e5ac1b20a58f3c160c2070396c7c7d25636e77059b92304f23d31a40830a94adb037fa2bd0b87fdb2f03fb877f3217a221cfe5538c247bba80a60cabd6ced9f9fff5ad042e4ffda4068e641113a7ae8be6c5e6ca41959e3db5272b91caa44ef74e51f94e241a9c0c4bf19308f1e6c174a1f26a052621d2feccb667ffb398f97ba6ba663c8a66439164734ef9d13637440d5ffeb12a44533aabb4d26ebdc9d7a999319d3569b039e54f2adf94286f0b0f238240bc06eb3f0053c56b78b4fb46e20b9aeacac9efc295097f76224b3b0fb54c961b4150014e8247c02eacea4178c7dcd19c17b727bb271ff0be9089ae037924579b285c137053bd59245f2060781c802038e63e3c122489b9125a3405148550afc29c0489abb031961c72524f91c70ef374a0d6d930c5118534a8379aef8621e497a149ca295e8ad05009e4ba109aa17fb55c2e7b11dce88972fbdaf01474e7642447a8bc012eaad166311f05ea836f8acc368c5a8a72c1aac2d33b399ba175b27a8cb5fb2d3eb9f03621579a2766f84844fce2929b3f7f8abfa68d3d8b648f7d155f120fbd412b86fcd0f201e22c1130a5fd34e843483e4225190d6fb45ff62a48de5f637d19889ae9c09bfcec0f56049072bcb66110227c14cd0a8b67e1dc979e0ab980a5a518facabe8ac8ee72bde5605d0048a5df6e0d4c7fb348f11ce3e6c740efe2a098c1124928dbea8d2c7c1057103ef8eec6254a75fccd1560bc93079bd289e2dc8a3b713cb0de0f728cc319c129bb50eccf6f478bcd7e160ec7386625af225704c5573eb1160a93dc734b9a1977c46a03cdc4f0405da52962edb29305d21570df28af2129401dfdf8a20e76d4a1d07aaea5dcf45ed9a71f54a8eac6782b17321ed86b84713de4fb39159e12daac6756412fa798069adc09fe91c3ab1788f607c888c2fd15cdc8fd309bed7fd0ab710ca1ddc54d41cfa850f43240874eba311ee9211827f94e9524457608bf43cbe34d8399fd3240e1c75237ac48035c23d12314bacaee0001098ddbb29d68fc703e075f06f512cb25bf06013b76a0a87426ca33bb44ccd73d0188d3a537015bb33b6f438c55b5acbf4591affe1c5fa8d9c1d11dde2ea667a2375769d1bbd02400222dc44765680a9867c9a9c883c3add7bb583d5dd869622bb8465d64dd2120d8c79d526331830d10245221488319468bcdb99a25c0e84db2851a4a22b3bbe5b5911f3a2c08b953ada6375789949434a49c149cb3563f35c63fcbbec6a31e1aec574ced1636631aaa501cd0c6d5aae016700da95a18910d5aa4f1e6caec4e7fa488e98958ef1434297c6cf75a18730c89cb6a33e91d777a7ed5926c356d0a06215e3371fc9e6097d63fd0dd9935645a7e7a66c8a169170c115779feb6740a48a08326a1833dccf1e8da69baa88fb8a561e29dc1bf2e040accec9d7bf31f0d809fa1fe5faac53cb0e647d891f90895175dfacb35e58e732a1c0099848cd18d20b99962d620982191f99d7ce07bb8c730378d8d3e793af88db27152abe2a54cdbb535de33472770fa6657836185b74283a2bbc4ef82d56bc6d33e13fba513297010c4cd9d262c96d57df2a76be390917cd311d602ad5d99b85022382b6928aaec5931a9fbc13c98af94c9cd718a2d6c71848bc3b422844bc03b78f863d2ed9683f4a266effe82cff7dfb6010a6c44f34f5cf1ffddb4eb71db023c54e35ca7f6abfc006f1a996119112afc0b2fc57022a8b9200a1fb743e3527ba94fe31073b1ddc892d0688891cc56c923af9aa15dbdb7a42e3cc7b59ff5d6af3045bf8693dc0421119c718f449ca86a063fcb18ca98243b20765087baf1595f638fe6fce6729dbc6d207371dca2e1b7b3b0c82e63a1bc96084810340f38df5ba6bccd4f65f62b834ba412da502a5a7598d26712fd94b8ef8b76938939861b35c9efb2fd2b5deb450924beb1e35221a685ea327e360a99dcdcfc2ad689734158361f7207f2f2dd26be6f666f67df571e822b26129b72052689e2561218b0b88eedb672e4068a481f740b8b12a9a9de4c94dc0365088744b9a7a08f412420e9fc6c04fc9cc86552e81cb8a6771bafe7498fa273185b0afcf951bef32bc4ab1ed406e692b0530e86d2d676983a7f09c289f531eb64f143101d0f2b93eb79cd11e1b26ee7e1cb13b22abc4e9c045fbb8a7d6ab98da775ccd17221c09ba1ddf22a58eb8d1fa2a84954291169d520d8864b9a41133b0ef48f024ac556801f63e50083e39b1311a42876ec1ed601d86aaf1dfed1e3a2fcb183baad07fc66ee6bcbbecf6193746e3738479c0daeb3a29327f54b010967b3089e3569ae8236011cf2e9138632d345fc9f75676baad24d62662a26246b261f8d8379a5402ed6bfb345a86fa8544216a130c3bfe424e0aa95c644164e9f778ea7e320348c8c18cd28b9dc8f2d6b3dfe1036615dd04380e624f8b0e81eea8afe16dafe8959e309ed65c4f5d29828d22a3801f5548146073b5b08dedcc4f8434dcff0fd25889de5e05f1dea8832ba82019648dade4bae8e30c8d99e95957fb926c254026fc4dff916b8bfe3b57083bc0368e2e1cd253a9683c7a22c2b00df2d9524c66865a4402145212c603df8db4f3d5ffd4a8703e4da59d3599021394f64e84bdde55cc9106a4ddcebbcb1c1e5be0cd928a2e35379efb18edccb1d81e4fb94a06c86089390523f36fcbddb71e718b81ab292ee762596006a6637f5468c7e3ccbfa420668e87bb225325dedfd6fcc8800c4bbfe8927b8abf68c67404ba61bdae25ab716a3d378af581db58f60dbd666d9df068f69a014b72d29fa05ad7a053605325f0eaac2da61350f03728a0d40a6957663a189f8974c5dd1d14ff408bc60bc7104e1ecab596c2863033e16c5c25f5f93d1e6750add2fde1670748555bde8303d840665f4f8bd18997662743501488d71119272f10c7151f9b8ddcc7eced96d2caef9982e16f7cb1c2c264c12046897679a528f1cc407ed0660a0d9ee50c779e5f7dfce323588f98630ab9b6cf69fe4e5fffec65089e0b8f8aa8f11181cd355ee384aa6bbb2bb2f2212c3be6d98d54117543e15f55302113209c9fb308eab3dbced943a012aa4bf13339dd7b4a5d91ca46c3d3e16bd7724acd6628ad3ab0b5d815bc597fed86a31e401fced13c0fedcaacf13546d917f7dd6e0ae0e5725c7004ef9867f5c0f397cc1a431e098ed397bc6bdf6a38636174b615742623772fc83fda8abdfdc1781497b0f0537100f65e572ea2e0554adb8b22ced9db44856811a26b5299e958230861a8212874b2039986f4291f6dd07ea2a7f33e868cddd27fce595d47a7e5ad4d2c2ddc783c7085bd3e05de9c946cbafc15b699913f59a642a7f95a02909364cc75f07042528b27eff3bd8bb6c7d39e93098e5c7c05884336371f6014429fa97f3ec8db7cc11c41c9b1e9dc9a3cf3e76cc7369315dd2bde1aafef7cc6f224331875a96e7a63955a64a8ea150e0a7c823f047f3dd390a1252d355fda3f7e2b345f6faef730d2012c6b276eb52a35f0a962c73955a63e3a51fceef40af3a058ae3bb1ca594647f9613a93c3a4cddf3f4237a5bd39aabc5e524ecff18b7e38ccad3e37a4220661557f459dc79e97acfaae897bdf4ca4db08c2b7973ba41db7733938eb119101a9b299ffe5f6b4fa6fbb2f47b8ee1e0b85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
