<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9955f17ba6ea5c135cf623d4f4c2290114f5f71f5039fbcfcc229c6ac097d191902481c3df6375142b0605877e8b4ec870935cb67e577852f8f7dee91631069535c5f030ca7bc497e3a0d4bae036e26512bf69f0e4a50821a94a69cce3a1116b8bdeacd6a81b646030de1639216050704a29bc9136d28b48040dbce2c906e74ec93b9f0f59661e6f6f5dda5454eea62282e18a4d27fb4c58432afb215090ec0925f81ae4bda7ffbcd5f7ae83115ac42933b3b166ba693e8b4472de2b7db5b8f660140756579bbcb07fa2ee79aeb7d94a5746e92ed8310afd05f23af9f84d050ff68bfb746b9c3abd3a91882ec403945492529cfe140108d6235ddc403331d7a501ce7408845e2ca7ade1db3c153cad0b441202d187f5c8fa85117137ad38d813554ee84b1f9d34123f04044bce3f07de4cfec6ccd2cc16d68f832e22c7cb13cf8d4c581d7df1b89f28c09c1cd98afc6786758bd98a94121d8c490a409e04d9553bdc39a040a9b6c1c038f50c748dd881d3b74421e9ba1e2e5cdc0b158a683e23408658175d61de795f7aaf4c72a605f1dabf12686e6a034a36e0e34d898e1a0cb4e83f680e655c0eb45351aee05250fba8ca41a6c481900f7dd249ad940cce7e742f4e48c9855d881664f72aef6f01fc4267da49acdda9cb2f5cebd150fb571ae827c25856bc434ecadd71400af7f33925a07cdd3bacb0343039eed50a62c29fe5905c247fd15c4fb355cbf65254e35662421074295c433207c420448ec3ca9d2d3379e058a9bdffd3500f41e56998e7e90178fc54e60b4cc1f880e8d33aa60023b827af4dd8040497b9f0dc78a7842a8217e961029887402b2cbab7cb1cc033587d482c26580c80ae50569b73a9bf345a51f764eb402fcdf7417646f0200b0f4d56b22ff1d889ddaa55e67295bd6258ce62dcc0fb242cc8a089f31111e31affd31fd719541fff98da6d244f80aa24cf71de36ef7fdb59f85adcb0f3fd1cf4ce3b6c4ae9b146e590842eab76d2e5997a7e210b538defd3c2b3742124d1593760941956c53ad735a6b5a4260a105b662625c2508273c2a6b50df9a79cf59911665d9454a7e3647049745414fbb568232add0cc829d07913951bbebf216b01cd09168da97ad8061f5974775dc31f0b3b1f089591fbf2aead7086fd1977367e68348f2f5f0e46ffb43ae7d193b047e65255a7e79b79326af7dbb60487e0db53597f2d9584cd8c9de63c700916869d9cc7a9fd8736a8bdf76eff9bf8a1f8d2b807e0bd0ba7bc095779c134a19c109e7588d82fd5528a6561edf4f6ad285a46d9dddfca7cf378d2ec1c494138f6cfbf1d7bb403be570620967462651f61abbbd97b5159f25022974d1895d494081f6719561fb1cec80b051d43e538770947590333fb0406b98c7bb879b5abf7a05c873cf8ff69e7478a6b5ef2178478cbfe0aa8c58c514f9aab8c2070d70863a1c7c26ff1534c9671995ac4ccd0d3d87df48dcb67d32c1e9478038eb7870c5ce793c61480204c2645a4732b1285ed214f5c74ea2df6ef6e0548fe7b3451e793cd025e72da875a9413645094a7c20e1133a0798b1f52ba686b6cdf507c8cbbdd89678ed6cde14015b7156bede9774a87d11bb7830fb7a30cea97429cf5aab8bd4232c61bd886ee8503f0e4c390a26e6e8d312a0d59591808ed21da82832aae34bd629953b14d5623ccb000a55cf4edb39e5cbcca0978e8f704b3c0b3b72bf8aac5d5e3a2832a8be9b17d3347b85a8d9e230cbf5a40f25f2fec4128415d65afb9d0a0d358cc3e734516ef02a0da166098b7970529da6ec3bd739e29f5ca0cf875f898cf77b9ffec16a39e4dad1eed783cb1784fb35a3252ae3eeef8380c49ebc5fa269288981617d0a719c021f34f80a8e72713dbe575e77985592a35da4d38b012c0a852382db15a539370b9851a65aae44b2e1ff59d3dd7cdedb3a352afd3c59b599a9474ab2f2a6625d97860f88d72694dc62a4bd70008a17c452275822b9279669dac5d45b957d81f4ac1d23ff498ecb9f6e6f3b7a2dc23acd8db8a27fcbbc0bef268b5bd8cc06a0b0d3bbd4da278928a06cb53987db081a3e3ca195d8ac91ae899194f3e288fd2409bd0820b182b76c3e06dcf93a43aff0bb31317c54b113505f7c0f15ddcfad80d24e4b2453b10ce129a1112cd5e168fa38b06fcf72491322d6521290c0be7e823a486b596c3f0d35fc05e9b3df231760aa224b9c1c376a81d06421d64121aedb3f02f0377da8cf4a3ffb4f9db3e7ffa567a663335bd84c39fdf705f1bf4cc48b369547bf66a3b8e30ddde2501e19ac75b7603e7136b9204f2b6f163b051e700246195d5a3b2e4c525e02a4ca9ebe0b521eb3c0e125b8150ee4b596d785a0a0d20b3f308e2c2d7727ae1e0b2cd0fb5b577703bb587aca09d7c9aa3f9a62f370cd90184fc52a2d58795944d01bc055ed884329dad7279b2fdfd1eab94b11ad677e30213bdd6ca6b158f3e9e6c45958260aff461d83c4ec4be1cfa74e07373f2ea07f0ab8c3a58cc94f045df82b28de10d87657312c0a0ec7f3a30cb57372ddf548f3ee83f01a9c4c48b1a75680e3f8bde665afce14c2bb1fa4b568d60e2eb4b49c8c01d0c9010de7fe8dea397472d601d0abb30bc0e5a87ba0d35ef0e4bb2a42eec3e622f5689227a684fa1780aaff951ea70ee90966e4de01483d8bd113831fc8d35f68ba5f2c514ad57d63104354bdde701ed17a46a11737345cae27181ba959142b6ee90eac54b60ef6b7296f137a5534ccb2f5f89f2b87f8092bd25f497f5e8f0c085e808af76c80bb93909e48f0e9e52ae1e6b60a057bcdbc631497abf083ef00152789a273673b961f40bebfa0347077cc2693b213909d4d52aa3bcc33990930243312d625b45390147734ef703d9f50016791bf270f6ea46d8f41dcf56bd25407a50d5210e35991694faf88795a97a5b449e1d1d412d633e48dc5cf0baa5e5c1d49ca18e71eb7186061a8a6192bf050f426a352ce9f0a7c46741e0a35c09a4adf46aeb32a5b4d0ab195688fe22e981c42570d5e0679d2794ac43683f67ddc8f964be47688d27ce276e4ec080e369ead738a3d3d3d21cd9ee03e86c9b6dd6f8cbc1a4a28cd72e0a80e2b99e752ff405b7f93c688913063e4758a065127507d29fea38ba2f1d3b636282fbbc1f5d92bcdf21c541c8419ae2c0bbd693a829e6a0066dd3e45953e1f6bc589c8fbd966fc420a1244e30bef1b96b572cd666c1a9564e3b245f542be2b4f7dc04318825dae26d654e6701b5ec961e9ef917f837d45bfbe945141d1d227f53343aeec15c83cbc5a0d199e492beb38cac0a00ec661dacf4ecf12064f62a7287d7a834001b000675ce9af78f5428778900733d2b58dde48ca5789fd29a19c6fc9ae47a47c17fe65b0c66afcbc654eda32baa3226ba32f083c85544a38a31c66fef476dfc2dd720c0afdec0dd5f4cd1a9a4d9b814ab54f157850e2d6fe28b1fc053d49db1b14ac6cd90a26849f56c67ce7c77520f7dd72c4bb8293b919a3ac171be851ae5455e63084b869d3e3a187eb552d4c67a7fb3321259f7bc7c5954c492ef203f32032267ea1341a12339f5cba2625f44e07fa2b08069f5db2d650a10ac878e1c9001c6fa922f327bba9cf86775fb36908b432eafa2da475fefa7bdf0d47f086914751f2445533d7211d01a7446749919fc1fb523b863a155f02a5fbf03c29f447bc20f3e2390ddae05e17c53bd4681242f78bd4fd549e271d774a5dfea50108795e0d0a16b05b6d046c77269d8472425f3394229ed7771bcc4f4c279e2e0410ce48ea568ddad01e50b199bc86080f49ca86dbba366df62620c848ff632e4014e016a70167f99b22ab1453d3bc16bb97e5fa47a8713db0a3143db2b916fbad10e9bdd02c45c5c0f09e396077efda0b319bae24136bbcd51126c48e5191871a1b0c6926f0cc96b8d27df816b0579a80e97780af136a728c38dfd6b94b339864373ca9c7b272f8881f8221f0af8f92ff8efa04099ae89131f7888638c70eda5d56aac52fb020df8d5de5ce421beaa47d8bef326f0f71b0a1d1d3a83e113aae297fed7b82a3574fe38326dcf6d6829189d0ed6e93a6d5fbbb0d6e13bd0b994f619802acc26c0ac7a0bcbd52db31d5962e65cfda9dedb6794c407dc7c764fcdfb27a25bc9572ef52274fe1f9568d1f91e491a613f0fe61afcc78207f415f8ea95c045e5eda74ee4964a79642fa100d899d6d0ec24370e88ebbd5429a7e03db98e30267fa1b64cca4241297c03b72bb3fc301290fdff781d1b1259687db34f71ab26588cfb3f905ceaaaace4f13766a2d7589fde77a865dc0f7a844a9ad2a5e2dba3a1378f43b021cab9ffb65413f07fff85af70017591b040138af691ad3e1bba26b545ee5c09e0d6cc22492fb72ed83e82a4688fae1db31ef227d1716053fc5fc68401a84343fbf289db10682277f2883b750cb0b6bc8feef3ebd484e06fcf2b97ae0237753e115cac4253df7dd3e2ffcb162bb03988a9df4be2edc746cc475070c97600941d7970ece862b2d20d54c420536839888fe100600fb5f9b9ed2d577249f1a02831942b8db08d0936537ab7f0272e8277ea2cfc835820cb883f30481e883f1beb657f3912fdf9e730101f037cde2a8ee401066e85e76125de3bf3bb5cdd639439e1587103d44082fd290c7848a8040e3d5539a4faf221679118e8ce026456d7f558dc71b99d93ee6ea9dda5b42629fb3088fb18f24e4822700eabefe0b3e2614e4f49bb678955796dbeaf4d33ae9ac24593d34dc97b8b735f23244aeee09fffa8843dabe7fd2520db3b082835f05aa3262afebca2f508df25429be899455f61a178dea224bdbde05ed5072aad7a10c2e4640e9381aadb238aede0fb24dd0b3999bcbefe6cd91a1de87be345835c00d0d4566f4de00ec25977ff45146f78812a1d9f6a16ef56a808363578199a2f5ee9e3b0889975e163962455cf5fa35f6be8ed8d1d3a10c0363ac3ebd9ffb98051c0851d8616c2b9b64d9434a61146b4e2156d73d61867ab519cdb84a990c1b7d4a0d0f55f1875f6030af0148bfbb93051e96213a471afe864ff3e006237b9e26efe7aa066a030556b96da2ada1f45c4df0a144c6e8b5ae32bc05b7ca3c396dc8a7165b8ed04c0d185244ada7ccf1e823e4b1712ba5278555ca8ea4288e26d8c83ec2ccc83321215112db07262a98b7c766c507e9c30896d929e7a66ad919789f49d465519d96b94d20159f76745436b047757af06411dbf07a3ba317f30c4265e9410a4813971958aa2a50a2012e1165fbe7422447cfe7fa3ffe3264f2501c01b232db5ea5cbd7b1bee685dca45cfb9a41c526ae5e2d3ec8a42331699234ee89cc7e8faeb60f441864fe009a6cc6914807708bf18b8e82f073450c3ff751aa13a67545b38dd4ebc6cdf518b76355e97ee44f8d594cc4f634690dec5e05ed3fc3c7f6cb83b7ceccb67c8b7768a6118860e7b675116133e5df7ed71c983152255ceca66d04d26b387711c46fcfad9e962f36c2056578138d4079c1fa16c4be727075025d5d3dd0bda3d65ff7f427ef386c86af96990c30ffd120108a4a86e89120e8beb3af13ba0f7fa016d83c8a0b2acd44fa8924b59222805ea9c23f2a18e07c7049e8291fbc870db3bf5125009c2bc67933e138d954c031d1d9dfd68678e879ac3cc35ae28b8d60633d45a826ec54c4b261495db9c84da9a109cbc113e6c0ce79ce1c6492c117b63a6f2c6f035fd4434beea50da1b678ac3e12a0d61fa9694083d6e1ac77a80b23f8de6d27d3320a1f60556675a348d420c234aaa3052da46316c006277e6db6d3fd89163c4d527fe8260a074fbeeedf8af9b77f130f57e81cf4b162e5ec06508f75b0e90441043a5e413c30362a626a0d9aee74f6baa98e39a9162be6c649b34cef69d9523b5429781441f0734e6f1fb92203100b3bc464678a72b60f42fe1b5d4a9d232e88d0b5681a4586944ee2af3993b5795dca2765df97fd8f212726e38d3bc72f780bb69357295fe52f0bf8d4a848da9e8dd292f4e096593b859756d7bf7a6332cfbbe46baa0956d77364ca143da28024d686309778cce59e20df02ba8c9fbc961d945ecfffc20a255d194f202b441925f159b9552fc4e29cba5e75965b2ea28b4dbff799c2f917e6ebecbe620133dabfbec5008eaae74417691788d6c0e596548ea6aea1e341f16dc425ae79e8ed96f2fb1bcefb99062ab76efb1485550e120e843e3ebe09bce190227823edeffcc6cee0045cf30d25acdf5667165fc42731a64816295980b9be24296725046589536568d6c43625f412589671f66dc110a6a18edc50661454af5edc50c891d40223dd66f2f55a13203e50b4b6aa91341a3516a91647add16a52e32174c7c89887436009f19308b3b99ff2c842bdb1b40d98b88566279c01c8edeef3ed59f644dc7f66ca1beb98a7860cfa7b81bd226362dd91ff0c5c304ed748a66d5dfdf34c0fad0af5f705f8a6a1ea35d2b8174d75cf3b9865e9423072907a50a7025646d87d025b0f31342359bd4d55b1c644dc80893e5d23f89c8ca50860dbe20f2f04ca52c1b3b04eef155e11a3d86fb93c05f017205c5dd26cbfddad684e15714179a711b9adc5f5ef6ef3dc09ae8708cf2e0f517cf12b5d855b326f511cd1b63288408ee6478d8015bb0c6372ccbafb6d2ad1fede5491d8f01221dee1a315b4edd48873f656f2a73af7bdd90cb519bc6b266cdcc52098caa688132569016f3583cac7bf8fda1a1396a2075a91b846020080fcbaeb571596a85a0c234a2f9ddae3a73c235de01a55072ca1c4ca26fdbf4c2d2aef03e163826390f1d8eaaebea21e605e71dc6a8ea23ad15072e2736009ca2acad5307bf3f955fe446c2bb60fced82134cedeb2b216ec1b822b335062a7ddf5d4cbf2416318941e08acfb1beef18ebb2e0b4fa79b6245108b2c4db175016ad469fa6bf40984cab87325e9dd5c8b50da55415edf7822fde12a50d9d082ab202a73c939578bc28fb0f1d293ab7b478422bd8beab0ec2652b8c1669546208d721ff9a47a68a80c5d33f3561158d75ad8f07c55b85ce59a0baffbfbac7f6c7f47eeccdf73bae32059406ab2c3df01ecebd1d118379967921a4c24091705f65ea85f6eb171d237e24b744769c2ac9b0cdfdc8670774a68a060893d3767130d9131f244be9fc3921091f14eda73b5a2ec97f9efab28eebc098d31daeecd85c76b3ac32d70a714537fab5b7bc9f14bff633d707e120ef264d40c2ae57cbe4f9dc4425b9ffe27f2dab19ff31683fddffd4e1233a107974a76f565cab12419b7bbbdd54b2ca2e8c029860a1f849d92b133070e6bbb8867bc1ebe7eae05d496357ab46c4b3964bb12ad7af06e07301e73f75d02a89cbc5c99aadce271e9cd661de496193e803d7846a0f7610150a53eeb839be27b28afa2e7ebf920230f1506bfa7243e16b1f03b7fb23298864b59904930f5d0e0283e2640a389794d6bda3a7e79cb87df9db28e55a0430d6d89a550dfcc87793b96ba681f804660bc9db92d2e7b5fd5b2becbc52d3fb970692bc145601db10c536fce3722a23ee1e3ea197857694d8fee4b4279cde65d0a4cf8525c430ca4c2b3a1523aa0578b30a9267205a7268c23d8f20cffccd931f387563a4aa66c67bf9ebc8010d912fe2a9b5a259a96881757520645f06bf956cc8f9bfad09d03e2544476d97e7f4e5de3f905b7ac1e4dc30bacedab4fb18814d0d9a5f91d29c6e0e4f69411470f090dc32aa031dd6beb5ca64ab7540493a6fc73125b74142ead519befa6427fdaef1cf119cd6415aeb3247a2b489737158019235b37e6879954d8c6805ec490ba2bdae1474d9c150ce091b082befa6cd930a96fd88fa897786f6808ab4830e65a6544c465a1480c36ff0e4d5ee3d7151debb724ae5aad72dd07d80f27c38decd4c717576d286cec247551fb560848eea4030bc1f704000c7c94b61f1592a58012f9436a45bcbf009a70fc16ded813abedf908c7395ad396db68f5dbd4b9e6394d63936a928b2d064f91a94ac66b48270bc142b648f773668e0f55ab2c73de37d8ca11fa60f3db75f788ced9ae9b1868f50f337ee25f15b2aa49e31eaac5749a96e94bef677c6936283b53aec82d1e39073db56e149d0c29985d049d30e7e969c2b5cda089da9c954f58d194e17d912ff197b428ce52eca613ab5759b79b5c4f19235fa2d214670bf332aefe9e5baeab274fc7a9c5f827428fbce67da7c9e0b02e259e318ab49e76eb0858a0cb1b95ce8201c61f3e1b4b4c3df18c4e8573e9f0a8aa5db0f90e871387cefc38cd31907749473e3df1862479059900e52c9a61ee98a6caa69c7b86b6222e7cb7a373d8166f24704db0f62100f06dc372ea341d41332da28e2295a45b23f7899bff2bed89c20c93af7ff686c84a0de894b366a0598cd92b98812a42b57213fc12fb554996ceb334404f12478d63425b37006e30c6729b6de780f06894eef0e8791ea68b7aeb5d0b38e72fd7b4e63c42b2dcfc8562e5ebd0d3e17481da379aacf2467461696ba9df25a7dd420426329a246fce8d75faf305e3af941cec5851b9753214b50abc5a5cb77e789a6019baa9b7e51b559ff8553437b1c455263a9a2d9360cb7989d60fe9f1cd241c0fbd4b9648b46f1fe76de6f77d49cf3743efb3941d852bf6a643341cc542ef55ced6f934488fa8c15a225fc1499f9e24cd1288c9ce5bc5bb27c9cde8efad9017bbebf9eeb12baf7cd6d6a4c9608be56fbbd8c4320c699408cfb164b14dac80953b086ccd9a2b15910d6bf983a5bb7139288187c4c8e27a7a3c1f2b51c84020dd7975fb1c91b079977f629ae24e4d89066f1e91c397a2f0627c42289400ff93a9bd95e152dffad339c08dbd121f7eeed3023f45cfa2bfae515de475cdac02fdd72c606b04fd58c4e788260dc52e258cebd1ac6418c8956e8a5572405ba228b3265c3d00b4273902eb85699cf75a7e72a09a83403ad40a54f2cd8e1098673dc88db04b5807851d77b062d86d13b371af841f43924252734fd1915b97c614f9de2bbe0d2203b4d3dfb679e5b5e9c9de367117daa427cb119845222e7237780e5b3bd01c9f09dbdeb8e456ed5a4260caf4fd1efc4f441aca1e7f683d7c2e2b1f96ebf087a167f3092292c8535e54c4773759f08a99ecfd3cc71a6c8061289f3a3e378b2ffb5d373ef1bb5ae041f4d2962c9d6e6244281a6e4080b89c78aa996fdfd0c47710aac51fff432f202c3b415753c5ebfe234ff3da95743bc8ad7c10dbfd1011d2cb80965da1ca4b95b1e29be9836f6c2b9d51c7f7a98ef4efb09b977492b979cce3923211e8a0aa9df3d82b0c168126fba26dbb0fb8090466a8aa07be4ee283fe6e0952dbca233d1d79691d228b397c2dedfce819f11ff331c6e0b2f9f4699b20f4369b2c8caa262b910daae49d7950ea7598d1c30764e8040013ec2bb1d5a28e56a726fa95a38696865e819ecb1cc0ea19d96faf7f39ecb6a447a3f781c1cda040821dffc1ab2672b0b445eb874057c09db6ebcb5bade43126fc9b09e90916d6bb30e646cfc27ece093bf8f45516d69928bab4cc2748c08c99c5b1e347c0305734cd92210de3ba9ee6a8ac9f3f573fee49ae7f60ef45522a3065421b75fbe1cd65a58de5769e7bc4f6696fcf7e85407c2771a3b2944dc21d09b75ae3c461b958e4b720fb2206a5d1427b892d79ada9b4648b6e3653f403f4c35bc5cbeee3a9a27ccb8f8452413f3452445c12d9c047070e542163562d7f0b752df0dacf906fa350fbdc8c9d63b84cf0c9d38e53610081c2f9cff7f73abb73520d26d12a46e43accced99d1a49b322bda1b6fbc485fb7976840023994fb454afaaf1f834d74a352ddb33795d52dd55d37a67d0ed5a086f1c72caa3de4426ba0670ff91daec7a2ec2934de9b4e688532ab214c935f8eed37f85c59e69488ec9a4144280fbefbdf17b33d001efe4d6dd128e4ba891821ba99a16faf1eb8875730b7b4aeb4dd4638bbb2a9cb419484c82abdba139b316ce0e35099827fc407c34e23625d4935f59dad3bd49cb045fdde2d1a44d918f8642aab626a1e4db68be7de37ff92c33014cb3303bee622595e884d5a909dc15fa43009599620fa3a68f9d7433ec349754b599bf29e0a41b33c7ba146b5fe37bab3777235a07e5f40eda698874e3e31c5acf76ee204a269ab58b46be711d7082dc6d3f090c04b33108c37f0b2a6f43abf3186fcfb818c56d014558576707ad69e6e368708ea0e22e953ed974c84da13bc349a4c1f84f9eb1d08800e049a5a081b34a46431c957d09e0c3dc393cdc75a4ded3cbf470ab0a5d41d2b2264c2bc33b68036d2cda89843ac0a8980cd448be44195545d560bdcdfd0b4d2d154b8fd0ce2350caea5a3dcedc6a09aff5a729077ec842e3de3d7c22abcfa023fd9fbebfb143b868be1198c1b0266deccbe9eee8927642333db38788fc73cdf5eb065c7874b596dc88aba4966c49adb7de96f4b3c22bb6f864fa09bd38f00f284f0a79fdc068d01d4f963070ebd92f8fb1f3b3847339b0682dd131a0aba4f62089d1b7cf0daa2983280ff5212530028e45f4e4445c22a62ae4639e8ac7be6a8a80395228fd23f963c6d5aa2aa3717f55dbec20ca4a7505a3b07f307acadf4050793ce910fe2ff7d3b5e68dd10de80a7b414a041b224a16cb4539e06f7d23b080a9dddcff3e4ef61017ca67f91e2fbcc7600d8b1ca5d49a604a52171b86f72783ae746c5153010caf26d29dcb3d546a4e5874be0501377e24fd2548da9865f682705a65a1c2eb8c8972d5b7e7e66109beeb92815c2ed0c6957dec4defcb36c8e909f6fa49ea429a2281fc01f6effa64f7d3d3a1624af0ceb94d94e1a1d2b3097228660cd58937f2e14ecbff06d4a8fe4f5f5b7413b89dd0994f29b0d9a722e6426b52cfba279ac301026695269ffabd516b4e838af270a9274bef165fb292fbcf1111b60e240f47cedf7855acdfeac32e15b2a93c15e07b3fd928df0e656ff47c3a4cb69b90fca6f989419db91fb9087563376958b0fcfc0898c9d2e4aacf712aeff57a65e4acbebc7a3a1cf94928b2356f9434d3802a789a488aadc23e74e2c8b247da3033638c31266164907f914e9f8236cc19166a5b495584a17c1e666ec7cff6ad55d290f0d2212f20e2c7eea00923cf22772ee948c62cf3aef4368551568858c01159830c1fc7022ec0cd016a18b8db76f8181ae501dd35cf1ce5275707a61e190c733701a1c3f86ed66f9bd0d9a48f0d2c0f300889cc007691d553d71810a30ea6d8bd4cdc603b3550c6233432ba16780ffe0f0e3c9fc4b7908be10f4111472e8c0658a6f2e0470a53a580c464b2a6be1109eb5939f6ce8672011f6011e1a561bf92a94be3e7d67f360ccf19092728b86bcc4bfdcee74725ca32202d6b674f87dab2838590ca415dc65dd1096819e50ce01011af2148cdc0be8f72da9858da760438b96efb47e0b54f58ab33f7d2d437e7a4b7fe911fd0fcf570808d85241dac7ff57f7cca0e08985659b2843f75501cb4a5e9cb1c7b76194ecc36539a4c6409bedbba75fb95990f737226f1f34fc765ec3ed98321b6cc2c166c4543433b3fce9526f239319a55b5163497b74a02b589de9908cc5eb44bc814fbfec8d35ecd01c2bdc37d055521a085305e96d575de984c8e69c41374b2211addf5e2e4d40f08584714cb16b8f0e5b0290f3972c82fb8333342d2c5227cc14c98c634c4322b558ec128f473d4f2591aadf729d9ea8172d3c594d5bb555abee7a510ddaa6ee36b8d24462435e7752a2889e6cb83435547a99087f9a6158f2fe60298229423eea532a126f3a5cfbcbc0860e855b90bde83206b1752541fdeaea619dc124b12d17063cb410b6ceb52a38fe4f25fddfaedde296fc1ba4ffbdf9bd36a9917a135b3f5fa9437cc322fa8938a02d298a07e5dc9f98be0ecda3088abeb8085280e85d07669188c48bf1ef7b616f1f8aa5c6e0297f75cdddad273f746423c4f741a5e824522a67520908e34a0287abe606692bef8f648fd4a7283df23002d5baa76e540dc15b558feca1de19fc190a2c54a62b22a020e7a457ff9f77615c2a1a77f92a4d7e22802a29b680a818fa511eb3b004f33cede31cf1ed2b986fe9e5b44e7cc1ddffaaa8b25fd60f17f82618dc88af51c8e91c0a802f1e953a7b57cbb52b1a4cf60122a03a4b0031cc46c62662c16ee942bf1f6d94e883711534af13f3874475756693fe1bad2f59346614daf5e79312de10d1d43e7b847127024d513b08eff0f2fc51195d4cce390fc7328c1214e1c8d930b26977cc2a2ffce29e7cd144867f73f3111f145406bac2b254c1dce521a700530f8f02b97c4d99b3fb6b4c064be3d0b4298de428c63d2784c04d210505fe751e6314c9c165be7e623c00786e7c692412665ff8ced204a0d48ad26373ff9e5367dad346be3f871243d5ec30eeee7929bf17ee296ed2d720732e63242b6a8a4660a6b1d20f00d54383737a34773f19266e5fae5fe9e8fa52da08f27fb17e0c77288c112f56b30809b360605b873d037ad559d10793e9245c9266ff5ba2c36ecb1eb0bb4d8e907a1305a56515a0c59bb15521766652234b53fd57805887f9090f776ecf243366670bdeb17fcb89fffd4e8db30d81e5b2ceb878ab60462b6bc3a97c17d0163e48210dc002c67466107554ac0976caabade99a159491562632abc6a71692ec91c7380636aefbcd571c83550cf0c8568080fc9f01e9872d60e49937d05def6e95437d31c98dc625960ee3753bbf0c660cf25173e0750d45b2fb5415dbd795667ff2cbd5dc4cc5a6e3853d36b6e65abeeaf7336833782f99bacc91c14abf1e5014441c144bdb0573516899e6cf73045b46bbb51dfde3635326a8eeab2d60f8ec874267f0cadf68fbf9d24bc6a09a6e5e6c9d3e0bc3a4e02c53713761f5fb69e6a1cdbef51e4a1f95e9143f4a4ed4d4b51912c3ccfe2c130663e0f310f44fa76abaa32f9a25994a30a481471a01382c3d80d862741bdf7cbb67100f1def536f4bda529a3ac08256711b83d583775ba5ff541feff7337505f764d6f7d970addd2949f6feac24fcd8d629984395f52df240017bc4019c13ae686334bb0d6c0d067866b64e04858b3eb5ee3daa1820cd3325091594c0b0fc7590d72aa337112078be13eb027ef906786b8b5396db523d313b797bf30ff1d6220e8ecfde6c6be332672e85c5ae37b7aa788433c89f6385de426d77b12cd6ecc43af45a137a6a1e67673e552d98a13212b3c6efed3a965bb7fe9f4d0431fb06f52e7c98b874d17be1009e21e3cc9a717e4c18cda9ecc0316be4f6a532a9eaec793d88545b395cbec7977712f87640cc573d63063d7253f399e2e303e0ae532681a67d5e277f329c48e3b5f0698c6f5e10bead8bb5b05ffba2720725d85309d25d8dec7798947045818817ebbf305c7054880823b4ddf77df9c4f5a9c8cac8b838f777eff7fbabfcbee53c1791ca391e18337a2f8655e9952174db6603b95161a5c26dfd84576c733f832dfff32040f943f04ed2b9c21b57ee65a1ee62b8523637ccc67b1d09b7c1077ade977a8dd9fc7c01e14260d4beba0fdd015fcf7a020e0f8ae6bc2c689a4db6faa2c057407586413879b5b51f59979d212785a89d464a2e5ef4b78c9f362ede61d69061a3dd73c0fcf740bf64390d4d697d347a244200068901d4fc508c3625906deec3497e55e89a253ce64e49aa24837f2271117e6912a310937fbc99da54184d723fa82999d237ed653cdc429ef009cc227ceb807589a5a799845791bafb4085533fc2dbda9ca46db5ed12b823c465da45285f19b0313b43523d26c5442c4e3079dc7e590431ca4a9d1d9f1766eaff2c6c4f08255e144c5cf52c32f3db07371ce6484e075a90977f49903bbbd5346f2b72478f635dc8eeaa46399274b250d6374d615b7770e05016de713e809229e4bd6031ff46d4a23b88100b1b9287ecdb5cf39d6fc7514da5279bfc9cdfbeb93f27fdb6dd92f32927b037f8d8b4d2c8f6f31b9e207f1b402a8b5cc082f53c03cd255d524fd9972a7ac23087f360052cd19dad2881d03853c3186a8a3841da8d028a10224a1fa4b6e955e1d96f32d8fe7be159938b0789c2dc6fbee3c95dec00c70aaf08c207ad03fb281262c5d85271d6ab1b35024073c8c4cb7bfce036f1ea122f0b75a9353d4e3aad28de9a7f47caf0cbca4ba109340c44835558e7de61a8e474b6909337df5af87a78bbe6071e3706804c6b5c502878372ad41df563d2a32bb4ceb37ab8a9f424e015c71268f8a38fbea7b57eac0c8bfe565253101881c363389535407ea89252f28a66dfabd8e253adbb73c821db1b2ab631ae5a157823deb851866c18f7805f0defe37c09f2f4ff85a891fbeae29094d635c03e7b8a87eb881cf1b331319dc0abc7b3722e47960e8cda613eadc0eb38f256c6d386b4e337b77027d66937165a4ba53f56d4f7e4ea29290d872a3fd143f649ea67fcf175b1c18d47a73f08a3e6efeb3cc4eb71f1b5371476ee2207d9e7a704eee9ebe4589fd00c90c33a6e0aa6eff9794671762782e7ee74dbd894765808b67fda591480fe9fcf13a259e85ae4a02e07dcecae461b410f4140ab3a89348b74b18901a3785471196185fd9a9557c9c9019296f86fd7a6068aa4850e077679c920526523d51d63a666e90e5b2bfceae23ec1230d514586818e3cf5685e8410080e07180b463ff00b6d8125b81d3bf933ec485c71c40c0a59442a08fb67b42f24de5478391e2afd8eeb24b37cffd393fa354300dc9e55431ed7090bd1a74db17093b0f3b310e3efc2031cd02ba93beac6aa71a43f23ec87c7412884f749b19b8eebb757ccfaa9ab0390785f033ed0105b853900fb813c42baea33f1c2efcf9beb01be4cc9d3dda2b0bb5c5ab59b055aaf758695e0e416cad4f15918df07f49fc901ea00b05590cac5262af3bc67c18b2fb078c0cb035332b4ac4da970090ec82c222a96cece4784bd9a0330bf7ccf7492ace4b501f118ed65265778df9487ff7086da0837412e5a3cab7c0b289598f6b56e5dc0ae6024f19ee4c6aae96ab5a301a7a04ec267597e2f02b1fce4ebde01e943d2c8715b2607452a4650ac3314dff05483677cb909ea2c3af0a0d80975d91f8090bb75f20cfaf3f29f257b2c86de0d77ea09a7ef61f08c1ab331ba8dd5778f7c7f766e06229e8ae60078610af84f4cb06df5434c98509f8167f5eb1c6c7bd100f6727b87bd1dea2703cef681682b34720c140f9e8290cb0ace2f0ac62225dd96f983c9e05ba425c1a571e8a7f464bdc8d3a93f9978cd48db45487a97cf4b70da21ba8466372856098bd4dfe89439c44f3e81d07f7a6d05bb6818a95b7a287c294af05bfff2eec32347f5cb5aa12772ea404e0bbf46d7019c208be24b77df03b43ebe992f82e2b7aa62e8d5d606c71bbdea1f3a4a179d4bf157c4576a564f20756d6bea22d102f6aecca9e9434ca92c1e68679d10d7ba9b3679603cae6dbd7063c09172f5665b28d4eda6516f404eb4b0c86ef24527dc3b56fa70fbd39a61fb0f8e4be181bbd68544f1f0762f9cf2283848b6b853b16effb07944e7bf5f20424ee0139f56c7717c5cc696ce39bd61ceabd1bed176791f6b03e6e6d15e28cfb644a28a4403babd4b09310823ab514ba413a9d847ecb9a5aa806b8e7c2fbe991841dac6fddd24b046973948123c838e12a4bdda908bee717a31598750b50b2edbee220f57115e7a5caeffefdc4e65eadeab8c82d15ca08fb02873b16c396193d0bd9d5f61a275619680e47861589b1f4578fba4895b0498408d4998e29c69b13656900a79fea7723ecafd074925b020fed4d23cec0eac74d25c0be4849c9bca076952d83a2dc2588817504463907997f97548374c73ad4ff56e811915c00356bb073712cee5ebff8977ba2363b4ecd143f680055417650171a7d05aefdacf8e83d53280c90efa5ab4a7ac3c00ffba3d3b0d817956a6bdeb85d635f17a9120716ed86bf610109f84dda5f96d603546d92c86598dc67fef289aa5c0554fcf54489a31441326661c861415c1bab98e2ef2810f3ad90e7b071ee004fa440a92e97e4f642247a4afd54c3eba52113ed625f722572847bd39b6237148799a1b16a43d466b802146092113ce066892edb4053b8e446062f9503dff20926fc5d5e3d08955caed3992104357652027b5c37812845acf7229a7a318fcab0f365af03607b4f7df6b43e4ca5f58f5346bbadbed3e6fc8ad828ce9b32fdab96163ca6c4bdacc077fb68acca46305af5ab07e79eb15ebf41cbb6bf6ca295a3eb8992be2268e332f573928321d5c4f9fbde6d6cc8755d61e237c890286d774001e960552bb2e1b1748ed5326753db7309c638b13f637b8196debd32c3ba1c9cf0c5b40729be1a0a04e612007d2c81bda001587d70328b45366ab10d504fec8847664b3e0498177f23d9c8fdac72dd92858036ddd9bf347cf5efef9740a2cd729d346fd9952a401f16b8faedb9dd183479196867340f64442f4032e7ef41766f08fb3040eb3a54a43e5653d23ccd0cc9b486fea29117553fc065ea07bafa9520135d4f8af38aeb0b7f3fd7ec9324e809c6466bb67299f5874b28a170e824cb34146ed1af3264f4bf98ad54d120d3175a14611ea675a80907ec55af37426086e57e99a6bccdd931dee61af0e00b4098d2aa6a55d931a91463fcb454851c49e29c2ca48f5d972ea5c8a0163f05ddde584f8373d53e05790003e4ccc2faebc92d7cab8809555ada974132b16b62f419196134a5858c949c42f112cf8ed3fa2425463f673c0aee08939495d576859aa8beda6382f12cf59242d82334580d630253d45f8cf5f118036e0ffbeaa41da0e8bf9541c8b89a7c2bcf118cbaf8096f8752dfc09825947b7f8e2105659f447a8060b88fb5f1b8513a03ec9d4fb62d9fa25c7830e6965a0a26e947a91928250824eab8476265287a032e021dfe940f64c3c2ae28831efcfbf3bf4b68f4793b0af17db5515f98990d0982f88ede0aae6a6489fff8bb7b33b984551136ff15adf13dc85444a01a50eb202910c93a9b15ece5ffb3669175505f8ab6a4f91cebbd05edd3f3c13d8db2b3546ac82a2d6e25a8cd2014191eac4a5b8a80d8a40af94d004378fe70f722e39f7c78dc402defa81506780b2607b17284607955f15d6361b4def11144efdf9540663cca5f08ff4adf50407ddda8b6a872e062e378a9dc684dffb8c1ca4b46cf2bd46c9c1ad5b00dffa687c64787158f199e16a4ee4e8d8bdb6bb33cf607965e86adca6f35ad9e2449752a01785f954ae1bc25b045c29f561a7ba11d290f6fcd531975f6deafe097ee489afc739a2e9412f3144f57b6a2422d1ea57a4f86db3782cb288f854eaaa84f163724db2e44b37bf95bc4a83909ab19eb08d6687ab55eb8bf51273a964969a14dba94469cade875586158b996e9303d3ecdb559cb0e6fd5eca13a9fb2930daffecd9aab5d5f058004efaffd04813b53cd058e2985eabbe3ae9f051f3f8e7051e7a1de7ddbe712282d0ada3eb8ddd10afe3e524f8d4a0c827c6a46510ed1f58d4dd2ce78db0c9795dc44bdc4ab475f2fea62f75782f66c204d533dbf2c695666c081a6b0051de519f13a29cb6ca1798b851feb4178ecd61def8aa8a065c366edcaac7847a9e987377dcee402236bc357dcd192084c2404d74be4fc3e6c6d06ab492493955fddc1e1c7935abde74832fdbbe45044bb9b923ba4ab3f5a7b6f860c44f7caff22e560f230e29f3772fdf44654184b1ec59153ea185e9885047e27d4f26972462be0d0305f65cb4a827e2d0a11c67986cce58cc8509bbf2e7a34f596018484b122c1727afdf1b1510c1c4d31bb2bc2abad55e5b1becd55e7b03a833c33773a4b8fcd07ab6c936e88dbf626145037bc5e85ba41879075388625ccad78b317db8fc2063b01bb1e5acf7be9cff4f84791095a3fea2627fcec478ed8c819d1ef913fe23d39df8af7f2ad2684","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
