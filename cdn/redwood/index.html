<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b81fc62864d0e4477559cc768950d486f4c11720624730b5909aa969b655aa7cbad1c38a49838b6e8253e550fd2d83d1557e488d2786bbf6df63a8a85c652d0c56c08177997252076a5b053ae4e2a1c8a5b4b89278fef4bebe7b7c198e594d65c73a89a1bf151a539b7ef3d16453ff4b38cda0abc81b17ed0ae24a5e8f3edd756942128cddec281db09736d76f2d6d6c56550fe3a3bf86d3b3aed4c315db2d58ab0c1c239fd43ff83cd0ee35edb7434fe61f0c0349ad72d9fd78555608800c7a40f2f1db53755084c6b7b6200046dc1682c35357860ef275dff5c874eadd4ba9c81b77e75d3c81094157002a642ed562ac4a27949280a98fb2730de16ab7e5b6d7642f0d13e35df9d4062dff5870ac0a57b104341479232649aca4d0e815f046f2d82b0456fa3fd4747ea072ada13354ee48e4b9ee6471896a080316c9ff300bf446091046c9852b992e6c4fa4051f58e8b297005602f93f3694aa23501cd86324fe3ebbff4c94b55295e033e31efc895b3c144b8bdf022d0fa4872b2d7e7f98d0e17051faa189bc90f503dd573641504b8c8bf0551b339f3cea25f30860a3a328f508900c1a3295ac5c60b0a651693b2088225e3af3f645e515ef316934eeff78b29dc1d0c77ecafd3e94ea73238eb074d28b7cc143ff7f6c984f35987fada14a2bb6e8f78da6552c8ce3f13b83fac8f5ba733ee4b51bd6bc717bf3c9a1109c6d998a3489437d6ba479bae3fec3e8d30d58c821ba79189554ce9965b56ffe1458b3ee322d480bf74cdec628b8032ae1b8a23af72de51bcae11e1a1f93d8a5e48efe625ddd44a3886a065058387382db0d34f89c9cd3ba33806e614cdca14090ec91c31e62c252a6a63676ef273b38ceb48e162e4f2becc903ecf8e434af68aeab68ec4fe7a88ec14639859413b8ff4303f01aea9fbd93158fd27ae72b89082c11afb892f301561fad901ec52f0e1f93022fa6ac52cd4ae9335298846d497abd8cad7071996a6f4a91d7f8648fb1ca0679b96d30124b064567e22a7c16381389dd2cad1a5cc17be2212c32954849c9b0070ddff5bc9e0b1c76b8888d15a6ad8244181b57a75468ec9a343418e9e794ef2004078e8a818470efa21677c032c39fe90abaaf466bd86f6b6a6a847ce9e2ae2ca799c2c7cf581122825b2aac9df1ac7928bcbd4908a3d1ee3d470f4575c8815d6f1ff03d4f301d83e52548ac00e1ae60932dfd2cfe502a63064b44861ef0ef24b0c1545600154da19e0b01013ec9993ea5831644dc9a22117f5500bf75e7210eca15a88f0b65945c500ccd69ec63e6a42a93b1e23ed64c067684d70b0624eed7fdfbd15ebe1fbc980aa72f956214c61a8ada531b83fd8002b68345ea2d313d5ecf557c19919d58ae88b53d056c78e2e5b132275e17ebfa1cce904c31e7f4801a81300f456aef557853994db5b5649a668a4949a6883b9ce0f1525308cad19ccb6a65f1f5d0636075a7f57057fc624a6fcf60dea827cd37421f9569de302854f77ecb8b119e32b7844b4dcc567d5d4eb19f9713ae1963ce59fbae11c903e487636a9e145464a7c716ced8d92ceb4d6a5f9a2e2bc1ff0b04c858cd8e06865ff3fb049f0e3495385611c8d79d01111ab947d152438098d79951a43ce26aadb772b52feeb44de7409bf72e837f6d889393751260663565be74438c2a7e9a9fdd43699c8ec9ee540b9af7a2876b70f5c4b73498509a8d70b365fce10c7387c9933c8f8bb125da27861c904906d54c3f35fcff1f5d872096d3528d570ed37f4b3c94640f313260072c0bf35458dac5dc4629b46e1283f8007557ec4424be2981d2b27eed91702b918be8ff4a3f5f0c5588b1681760495ca3e92b6ad1cb7d550e29cb41b046ac553e5881e0571f2df0416a531d31cb7ac6e0d837a4e6a49ed8d6fb245d287b7dcd144062b8ee46b9d81d5a42b506d43550cd9238b992b38aa5b1da75c2bfce35585ec39819ae5a9675bfc4090b3c45f04620656337db9a225328a38823a51e392e2ab5304febf9bdb1d3421a994b26b066cab71493db5ab294d65396ebd58dd2f495473a9fff3d514376f10812635944f9b474caa3686bf242766e5257fa22e6eb91b31f2fae99b803c02e977daa2f0e53629d66eb9092a30f3a18f70f91736233b0980d7c52deab1f40eeb9989847609cb77834c7525f3b1cebde1383e6ad1cdff63a05026865afdae4611c96948dceabff9ecbc0a66847f10c48ff4ec1a6da4547aa9fd0dc3e2d1ad134c9502b452361870533180d143f4d53e89f3c7ff0b4ab074b7f5427ea5184d1691e74b474c175ab528b309f4bc95148997e67a55c34a023e012b5b48bdcb97aef20c34a5eec2d17488c3e1a2ecb6daf1540e6c902df0475da8b6d0271e8f3bd5b67c54ac7d2e33a1ca6f8a1bded68a3eaee7802451dac401b3d1327e682b7586f66d4c39aefdf918119bdec63c6ccf6c4194f85fe147c87d12e5fd1502b303bd05a4636c025f787bd04457e92024133585393f3d3e0c95e2e7ed09d5fb22bb59c479a13481c93cb8d94bf938b58d713689741c0a1ba812b973ab08c1092c079902efb721c3bd0b42a68e3305a84439131f75a3e4885d6ee373680194dffcd20f882b7ee03822f7d05c3e85bc2c23f3eb94ff5165295ad2db3ab48b4b74bc8f00a2fc2a2e3657825e04d7c7d2c8f1f3ffa71d3885410b7e36e69a185ffc897cbed8b82dae4b1deb0e5c62e0e9fd6f1d8314c1435a21efe2c9590772a66343b2f790af796594f0b86d458560e4f9b465d8c0d2d54fc600f5370fc875773660428bf6c0d34cdad5e9510e319843577c05ad165f2b97aac122a43d70383e896d0291329ab2995364d6a71dca73bbc3cc59e4e812fdd0257018155f5a0b5d79ac9f89a3b109f34fbfc587a45e0c6f3a2c7cfcab2f0e8ae2047a22344491a6addd02639c593555daeaf98eb302873bb0f215e07596f6eae687bcb5fe3b9d4d142d6ff5938f16ef91c3099b58ac94cea7f0976728bea25840a75baf051504768b9b5a551edea6430494029f7cf9c0720497dbe3012c6d546e3f298a2b4f16ee43e3a31c86581bfcacfc512e4d8ff6ed489e4e14871911560188abb8566a8554c21d6582f10232bbffe52f64b5e2adf6de2052ab097c71c4f4b6f7d809894981b53bfd2e637b6461aea4da02bcf8e94521bd82fbc4638e10a39389355c7403eb04ab91fa9ee94662330de1928576f4d0104eebab1608242747a10b4af05e8827d071ae12f6a89465e27267073ba5f7790f7f6c79eeb38528299cbcaf93684cb826efb68f64bcb45ccd027ca2f7eaf4a495a566a7c3633d0564272bfdb5fd3e15d2ddeabe978c7a10387feaa55de266adb89ee7d3dfca92da70b4ebbeddb8bb819224f4ac28f75baacfb4f68b4ca2f7111920b0dcddc2ae30a047f9ba63066bf1ff0e70b2d447e24d7b1d0f3bd651b6ab62599b147a6c7a221537e3796fb010d7efd9161df0ad6b264abd77f73673c46886635fe240bfbc74e63c8e45bc3ac07f822900881c24bf13e32100bf28988984360cbe7ebd18b5dcc17e4d87a4ea7901a48c27944cabc3d42854f55ab1100bb580486b55ebd7d5a36786d2fd8d9643115648a38391449d7c991625b249e1a584a0db8b894edb4cf1e6fe0efb9fa0f11118cac85182b2063ede60f94e0ad5bdcef81ef15c5cb838bc015ff74e048f9f5c9d6823a7bc32e957983bcda23c81c4a3e529539ab92267cb3d7b0031fc43e812c44011f15c82525e4a386e1ec4c933b009e1767f8826fd5b4268a46f52d5a8f62e9e412a8be572ad387bc45746af490b93958aab52b93e4366cdb1f88d93f6e2584c1c5df52afa4812e4b9191745433fe765f3b4386098a41608b1006f3471a70d4728080e4b8f5c044e313fe31f0952eae86913ecea863ee85d84852dde33ba7c04791f1ff8c08c3bbfa7763eb4678d48ba33b2453623f1d6181d3fae5d424b0e5cce8d6d74b9416edce239166bed88479c6172d3be3dd587ce3f910c8b8451a4e582d27d50946accea7d3a3991e45bc1513fd8103d1053425bee2dbb7cdfe7c652805b12c45d04487900432f5ad3c92bc2ffddb086efc198326e3d7242de2bf329050c287c32ba3f3b21c9b4958959051b4f1ee659d3adbc86b587027f7135b33a2021d2e770367ed614ccfcbc99ba68cf4ad88ff1d2dbcac26ddfa40c7ca7ad1d8b292a6f7c16d663adc80dcce3a86deb3f17d29ffaf730f7b1e8a5c467d0e4c559746b58e4d4368911c3f04dad53da319333a20c4c1dd96c6c456ce704b789fbd51a86eeeb0193273c6a93c029500b9b02c1fe0913f1272b2dc8ea5e65cf170e56a984be2ff40c26f38aa53591e8e05e6b6b34b3896c45df271ffb794be4e96414eaff686664ba3681d89dca66253c23e6809f2b49763f2dc0dd9228249cf857de35f758f68ff452f01ee96714e49f06f6c51cc426b07879d9623e0c9be8b0bf799a66cc4313940d977a749e2c68b89b8788c3572ee5b15aa3c3bad0fc7c2f339cf3cbe7e89507e7d2b352ec4ba892e20869ae7d91cdbd974ac76397c6674f72acf4bfac8782cf9deeee1187958473525ceb42f973549805582c76cb373e58e04fc7e3ce2f23eefd0188c1542078c53f7163baaa17515e83e38efddf483598cb6698fd91c8c1f3d44c9daba950f254551d3ad1ac3b2494968e7be77c01d3814a1c3790ecbf95573e3313cc301c62fc6d81fd63ffba383c03acfcf0464bdea2b3653f5579f290479652177235635bae8cde503caa63f1bbaf43356897ba7d7723bb40b605730340c48727f514a10cff8d259b4769b51c84af4a49ee5a1e5f26643aa11d8b65a3cdeceffa1941d5fafdee7f49c043a291f21cd948e6456f129a63a661a788bd440390cfb01a673b3a7a3bd4d4eb24af2ab32b6259612c4bb68f885248f99100b5eff1b7037751fa1b4217fdd6624b4fa36e3334c4484a36ffb30f0876a9d1f4174fa7003141b8d72cca208738358490370a5bef414f079b374e74ee1ea8aa6561ce0ab67ba43282869ca2b8f3bfa34ab2f4242508fd410f304ec52241b15489d8deb6eb4286b73abe59049ec9f22296742fe1ac75239d1baacbb231206961e1aa715d76fa8314a6b872ecb07ce5560cec1661955281f3abe7502f27ff2b6548c9b0d50fd2c4818875631625561d2ed51a7a8d5e68534b15c1d92e6024b3126007094c2ababad85bac5b2b82e8eeadc3147919e9887aa66d0b53673da06e77db3b4312d9244b4d35ffcaa1e5c38e23078e36625b1d00a2da2eeef1ee43e00b039d243050bdbf54a3c8ce973af7078406b29fb6e4880ace945ab3f7f8873b21fbfc562141c1ee097507c8f0c0b8b633772dc47c02ec86920721bedd6f468a2f1f870a30f77f7abc1f85132b15d63ed1fd66f095faa8ea8b93a93c550e8216e60cb90a53b690863cc2fec00d85686474c70ac1bd4504a8f383a223aa0ad1910c56031f5df3dc2eed0901acec8de53695510077250027062ab29c4882fbf60377414c5991a0837fc6adcf9dd0aa4c38d4017559d8a2a840ec3f072db7f8e1883f04ced1e273ddf97e5d353830d155812b3f074e4727513fad0e72ba1e714adab6643563d84b5081061337d49544306fe3a57c5fd07ad34ed9381c55651f6265cdabe26ef73d2a6b1258060257ceeafa4dba8fcbe0d4196277a790a36b21d8cbc8c77681aecaf556563c8a0ddb1b087ad3efe0938f6f56bbe59d383a894c9b9986c3c6732a86c236e96cb27c08102538ecb86a618ad3bccfd91ce4ce4836bcefaf1852cf652a5a8d55306ab16c09d62249bcb1e18b47a575e1c56c70a417e1d91f2383a27ed6515bd3cba8483154f3405c581157d81730883f99560f220f525d19cf048a13abcd1df78d343673052d08bcb17e4ee2911bf05725d5dbfe4b4b9a1315bf2d8fb180ec8716134f5405ca2550a94f99feb4f1982f241b5b92e5f898727173510eb71a9e31b3734c31ae1cfa41e85e69728f5f89f0e72877b53b2ac014401fe8016d783115cdf98d29b9e08fe8b7a172ec195776fc6640679824cf231cc15c1e10a139a7d320a688e88b5e07afb0c47dc8a3a027bbdd08465f4fc6df802dfac717e98c7df33f3d0303146b5465dce61e34d20ba294de377af2cdd970f002d1b8e306c9e960ed33e2fcb85cd8692f905ef358899ac605b0059f7028d8d85d13db29fe04b5fa2931e2258be2e3090d11627498e053206997dade067c18012c90d48d56fdce289ce6f0789ed5f69466054d437830b1847490e46c94b86f73784443b051b4149af43f6ba9ebd3c20219c905da922a54ecd10ef823287669b441b8b48e275938567be7a697734b0b57eda855b07b927a70614beb73af4e5aa92f826ecb31eca8626eacaee49db0221b240ce79b82013a39a4a9acf815062d4b30f9c9ea89b6ac669bfbde84f538c050d43648c85cd0a1baef7278cdd41964714ae71c3de98f6801df66589c199728dcea805305210b3b2227d4982d156d87059ec9ea2e236b1c71a92118fff1aae8eacd96dcb54eab37dd9bdf60d8a58a30899d6adcd63a664f1b8e232554f529b672aaeb7272d56bf81b947be302c9def06ed3f7eb01c19134ebf0414015e9a12dfee0912a73887d968c10fd83e927d5151b783d8b8f0d4092971ec6a0e360b81fceef8eeaba1248080c8d854fa34012dadf2aef967fcda3c58c356e98eb8ec0aa360491b03e849705308e55059ab1a2066f1cae58ef0f18c35e0b3a10a816ea8f85c53135db69debcdc18e9344b851e47c90a5516b697695a97a55b579cbd85f75d4cbf53b41da7c8b5ca5254d8f553c72e28be43065a762b56e9cbd636e4563d002c714be79f00558bd7199648b5abac8e9349ada509fe9197a72e33105d3bf8640bb5d69fb930079912668ba78ce5c2d74d51228a88c7cc463825561e2d5c38cdf85f1452918ef89851f21ab96f00a8e34434a8ad2039d9c2eafec0ee66301bb5d97b1def2ea7d4f302c77895b1b3a380f617300d7bf839f826b008056b08d0b2d4c4a63ace4acd64f891a7f93a25cac5963f73f1bc40e6f87e9ac759ede8c3a1d01a9f2028c150b105bf22040fd0c7791db36a4d549726709f4934c6ab53aa21c6ff645eeb6ee4a4aa12739b10454ef4d97ddfcfdfb15a60e854927bf4360e9c3c78fccf13682458da82b08faeb75adc90685439aa5dd804ded11677a01d3ffd880eb3c905c5703c09a6019f7fcbd16c98ad1fd77042d11afeb8b4ddaf907db10435c6b0f02327f799fe31f56d96195500f5c0ca47251cc64f030c3473437fc6fce09aae0a93fc5a098326f461554a01381484865c1eaa5ee0cc83ad39542623899b2f060360a7e03a2a8f328068a130a3853aeab332cab5c07d4f440e369a0d8fef4094695cc554222a588954092b8e4c8e6b108e49ef4a0502ef619fe73f833df4dc0a07788fa99191b2e615fc37a7ff019c028092955af16cfe104170e34b1bdacf65dbe5fbf9dae5370a57622d1737b21265b573650bd00205f2d03d0e828a353f832a2f319b5a1eb06f8d1af6674152d657163761a942d11856413c0bf23393fd33cfaad879d1f3eb230cdb922291eb7284ae31a718ed73a820365b967443a5441ef2b530dcf58f548db2f387793f7bbcbf06e3b7b05cd3fafc072ac6882d8680e933a6e09fa80623e324197768550640562d5602ae1acffed52cb88bc9d788e24e18e8df6da2a84f0917f88453854df715148c9022665ffcc0a5457b8136454cf68f01f34f3a54bf98f7011b1f352ac8c063cfe35886cfdc7a227ae815e4d451c48fa1980d1b9d5e8d2c8ab69949daff6ca1ce22c2a0345a54704886f9706017da70b8f3f1351fc2822910a4076981ee7d9ecb2f93e5f53a4641db1436a8179bcfd940480bbfbaa05641513a52b12740f802b1fb0c3a598e0bf7b59333ffb03da4ae6663a1c5207ac8f56701e1be4aa4bd4a8122771ff4b3a65b684705d158d220cb5ad1f37b8b12848771af06d8556fbc010f63043a363cc4898035c7afdbbc135119c6699d17128f5ff5073431eec1b9bd057a44492770c420fb7abf9bcb143c58b4f6247bec97be08f7c903fe8840c19cac418d5918d00fe8993033282a0a864756a6205a2d6bd15ebe08bc5882799073f5c458a31b99bb616890af0f7d492df036e4e667a97e8b72c30c1c2cc64e02db83ed75dd9132d33f83073195d2579ce34625c8b2b37b5163e54229b1f524d0a04bd8c35d94bd79259a02e5a533956310c75aaec6419fc86ab6aa39ef8d8a0676f3786be6457d79367da7636c34570f538480f16378e967cbdb69d6f2fbd2f2c9cafd6ec38413415d8467c2d205f6ecaa221a0fb6b6fc6a588b0f1ce4aa3c09cb96e9436d2998d73a39b048de9c3fc3df78462c0a34c29aafd4f1ebb49f90fb5289a9f1012b7cca8277a62694b24ab4089ce4c3320ff8aa3d5ed65a4810c4e9a4a5cd10b7b22efc93b2852bb10604bf7b3372589dcf0aa8f670a6229f9d2736e3260df396dad98a958f168c33d754bbd504f97ddccb9b799ad979e556bd0ecfa38ce107e0dbc52e429fa37356d7fa8a9354b1c96a4bc39e83389a0a7ff66167b7d5713e3a88f913583333cc900ee4ccaac185e499428dcaf9676dcce21377ea9f686e8deb21801e9ad9f85b91a8529953b26dd0793c46a23b6f9c92c16c2d4cd75a29a3b4294a6f34630701480df0a83ce9c030a1a6af1797c581f4a7acfb57d4cb9c88bde15516d44127c396ede953dcd98c21efc9ad800a3a140595c236cb1db12c28a5ec13f94c6ffc3b5e1dd9e68ad64edb77bba675fabca30936832204924a12b9721731fb1f9a2290acff5472fc473865c8096d81c92091f239d2f8d51cfaf5803842699c04de50969de5bdc02e51c4c5162659a53e2751c06fcfda801d25bf4f1d68d5ff654443ba0346e6207508815cabec23bd4cfaf780ad6292775fab44cf8e0ed875be4c69e6b7f816bd04414f5fc7eb11e1e5b9d69514c620b586856451250660bdaf652d3e2e9eefbd5a77c7808b35913e66f2a888decdf9df57c182ffcb47eb9f4756cce0e0bd4827816b08c7f48657f1d96e625b0f3e21f96ec4f6cf5f4e07d4507333554a5c3eca475e7c1fec417bf7024cbbd887eab2fde8d7853df7741fbb0e31cf4be64d49ca71a62c43e9583c76e055b3f0a0842ec854c5885c6e48ba7063a11b60217e5fd7a7431700af77fb7a046491ce13ce1cf19fdbfb134138749fa9b8e33e6e1322c2193a55fa36dee1790e9ca828abff73f0ae072ddb61b5502f977deb927c90ee7eb49c66cf0c5539fd74a233327843666db9b968a05f264a4e5b36f186711e1a3750531a5853b6cf29c02fc4ea1cf80a9396d4b5522f696ad1daa2c7a98eb47f54a83f5d004e7c8763903ddb30c4ccf66317cfb59ce1d8673476bcb4c568d5f3e6299ec7fb2cea35aa60899258e7d33d07b5c6b6869d983909ea307279e2c316b6bed3fd8d04f136cb71199bfef7dbf95dc65585b7e6a542bf0b7d15aebed64a8877272e7e08da59b82f4723a39aa1079d7dd0afe6fd24d39462bf1846728f3871b35f9f3f28b5a33b2ccd836f0fe818cff900df6fd3ba506d5cc74564eb4f1f8a9cfa298f2e8111b78f8d03695df514b71fe534d844c065eebfd4187614ceaba00efb30cb29ab2639537e09c968ed74c20a6506117e56920d8b59353a0ee6e6f442cdaac9657c928b563e28f455dc81b4da8eab5b4c207b3b603702af1a1b41851f8444455c3adb2506065822602e5f4790a8fbd91ff9f03ebdd4323f0b6be391a2fdb53426a5aaddf264fd4218e44c7695d73d1e108faa9c0fc7cd706d9fefcaf100a2411c7c61f8e9da54b08b64291d993c33457f4fff594a720785df5ad3edc6459a1a889bb612ff56e559e8a24b30758e6e1c2ef5767d540d33a9e97fc21653da9533e9dcff47116ab86aae5635e6b5e3ec78aba17ee6d1d74f259400ccac95b44336847f3fee31657a2cd1f2e12e34adba94365252b0069eddedbb979525b3e68e23a8c0303aafb60d4c3f166c216bb5821eb5318923a51113ba2b4ecb76ff9f2c10ed23b91148a1c8356efc3d2e43edd1c6f26f7ceef0ce6ec60cf7c0827c18ab83f04d93933cf772cbdd8c47f295d3c1520773d832a43054e18498495de1bad1e1ed9c3e84a3a82cc8f5896eb8c441d6b0b59ef3ea0c561669259be64987f994b364781128aefbc6dfdc8fc79b708c94871ebd687e2e91a3a66fc823eb980174a51ab7450a3a7535b06c8b19902be90dea7d95e97b044056759f1b5820b102083d21d97bc4c8bb1eb1cfb21a282a5845587194aff85c8738dcca79568a14d5a924ae9dbb8f78401393bf43e065d315deb630d56ca3604e70c71bc70d9e283205c81bf7e46c76f207e7b379a64f3e26434e882b3c657833668235574c1c1e945a8740d6cad7b6c6dee9d05bfff71e9bb67e102a912a6de77a679424117f91f0dece66b6035e624f3f45d9dc81fb99f5eff2dcf08bb75678c31e24acd13388a74095f297a8841cf0240f16443b6abb8ef3d992d2b83a5ca29879039b59ac42a3df45ab424ffac61d5b6157734be81319fb70db4bf6a64c2d8365f92a1514f6eff9180e9b3d6ad0e84c6eb63edf2334348a508ff8128bc22e9ae9a7aee29727d8fa541556ec99c79587a1cb62137215baa3793b836bba641c289f2e1868c7115705c14b7e7926b15710f7f7c8dea307faa1694ef879005a27e08fc5ef55a3180df92e0fc8a5d048ed973bae5f2c0b26364a4dcd408a8abf974bab97c6e7236278d279b7143124b31f4243e3736fb3404388b0eadc5929ad5200e35ad01b87945511e8063931058225d7c4ff40a37a401de5b93a4f259703edc94c1e5bdd9c93ffb859715de05479bea17eedecbbc06aed942ab10c7985823c6b2c59b50f1b2f801178d29548a50e5a0dedef327d34c57fbc4c86f0f368bb46d3035ff281ebe48397de8a62dbb2ae7a1a5ecc5c71d3858cd968f82e21cb3582dc5a2b8e92f509a42b204dd8fe23c0060f5fc2247d9d20d3cde3a8496c723f88911fb39a9b38c1beab06e8f0659a820b5b64d038f60b6e3b64db97806532c1ad63dabaad5e4b01a6d7849d84edbeac118e51a4e969511d01b8e66b8baece4c64e6a182cb357e68dbe9a798384a64ea164b219da3659a267f5ac934774404e5fca590bbb42b4c4ef9ef6f1b672e9633e46fe71949d6fb62dd58282d60d1f935a4faa749a9c6997d4c755943a30d63751e16ddee4b17c083e8e9237020216300e7b4d6c5146bd3dd9cc4488bb9a0d120fa92c88f45d7015bf7c583c1a9f59bef4c1f7dbd1666a5c7adbae63b94ae6010cb4caaf4756cc0fe9b174b2d48cca46bbea95451563e05aad87bfa1b737005b864329f9b0637b7e9674a44db3005eca75f8e9f0fb085344b2128c07372bd329f8d69739adaceb98872f9a71b68462b76d9f41f392c024bb3eea79d0c7b877fa5ad9d02b02352206bd032c5ab7210a35e0aff471bcc9aa100e2433d47f730bd571d0c7de59a1e047ecf80cbbc81eea32e4e6b697cb82240186f3e13141684da3b8d996c49b7aeafb5112c3b1b4a83ab02b7ff732cbdc313311411067312d41999cb512b4c11d59712f541aab3cd3c9e4ab2f2bb56bed81b93aa090cae852a5ac7c3d053f89947aa7e95f3f172d90702ef8adc106570a3338c6e1cbe44d0faf0c9d13fa295ca7e146df0a3270126ee33d12af16c71767b068a5aea5a34ec61e6cbe54fa746cf50c6469df7245f3278de4afa91594686eeab915abd9db28b616131dfcc95b50a1158ff249ab1d26d8f1e67fa3d1e79140f8125c2f8ec508c1299a40bd911256e4938e5d4ae6740691fab74b581dfc53e8f92167785068e21b7d55d0ea3f8e6e032021323391220198e037ea3abf4aa0372bbbbd06677e4114f647320a23a4873bd5e2582973b786416ad632d9d54d14cbf02ba4108f9fa4871048d69b34371754fc07b3c2cdf4ec16890a3a1533552404c14dde1d1082dc897089647afd5cb0684de8412dbc288fc916ee9190ea1114d3004e5d73bd92f64cff45804645e0850a32c5f37be5656be1f92424a4571ececc89b6d0f9c8f72e685aeb3d4c73b1a813dd8b387a55fc3bf5730d6aa7ad45abc1ee615066dfee9611f11457b2718a54d60ff49b1265bb0f32f6962cbd32695f9f6f43d0727a158110a87196793a9a4d2639c6a5b6ea9cd0956f1cf0739920eb5f5516dabfc2e146bbb717f1067e77fa5f6fefcbb821c25c5aa7b6d8f191ebada000506c26eb70cbead2ee724341b55ee85e66e6806501dcb3a7f9393e99a021f8d5734824d45b294813ab2cb4d5927a3c169affa824aafbd242ab05c7c8f1778e3d3892ee24df3a3fddf3f3dd9b5f321a662f5a7425bd90db2ed3da6c2f08e328363b3ccaec2635e62d11f1b8ccf057494441c7bd684aaf4e087c618fb3a676f3f19c15025b166af893c25c6eb95cecbd57db327d5146404b16c23e99673a86928811b67ffd2660644d9381a6c133dbf202396e5f47c6e9eb544b7744a231a8d868834a3a489d1b2a71b6c66a8adbb483a2653a9e563af38ff60414b157364f313a41b97b7d3de2fce8d762b2672f2f5f681230b01558d27e0f622f9fb83bb0418d380deeeca7c4a89fe36bb70b0cb547a42c8da8fb86c000e50dd7db28edaedca635ed4965772ee8836697791bc4a8a846e3d414ed3ec12e4f6a206906d1e243ff403b9f1c24757e2e6c6684bbae4fb788655b533d51e7e5a318b5017fc330347c08ea422c3eba3949fd52029edf930fb1c20dbc991d5a9da57901a3269f689e6cce83493b54161e3cf99b5de715aaff91df40f06819653cbc87d0b82951e92ab75915e00729ca3a442bb6cd86f8b70d8b2ce80d36fe6a4daebf61fea57bc70af1dd91b44b1c5246c0137a84c21e3a6219030a9f615538bea8747fd8a20f3afa98738977e39103e8918636ab2449730e4e676bf4c8a3c69c89446a9d02b638bda6715128e3933cadcc9a4c1385fd3a529d80e55099de444bdd9bc766159ec82020d154d2423a080006cf233e44c279c0f56564ecaf8be8ae81ea9369b4ad4ba4aecb5665d33b80bb2a40363829406e26f36ccf41bdda912dba93d52d76513ebc360775fa301fa16437abe4a2b2a332681d35b92f677ced4fff6cfb1be8d508b207f379f0c3e7eaf10c5eb7deabddbe1d75430a3b6c8c5712bd9f5ffa3ae5b6fd15cc56412fbda315f76d346389d98b17d3c2d37c2224e1dba67e52e8a027af1e8e49085832791c776b98f287f3952a55097d7a72eab7e1fc0d655cdd1ce2c2b5266226c21ec630c1e73d8245c2705a8dab90c34fbd3b6368c3539661f3087bbfed31ca5213c85052adad3ff4db5edbf95e5e59e44951dfef000bcaf2a81a9718126c8618c426770deccd19cbdfc348c8995222c8095a63efdb5c2c373117f688dfbe7fc158e1b0e7eb1bc3e8ee5087edc7a4ea2485cbaf72849251af89d55c3c97e9f8e01ddf7c11085f218b0e46457934d59b824287bcd024e571fc5a362559ae9dbea1ba6035de15b72bc75518bd0cd099378562686db5927e8ef3381c6515efa4762d42e96e7e599909f960feca9acc47dd8380697445c183f64f5d85190fea46ac1e6e0572560378bced7a2b02f4e55b2bd6127d368a6cbfc7d5c4ffc5e50b1ccd89763f5fe5bd05a10307e4cca3e5948f11a210923a26ce85ff3e622062dd14f486547c32e93199537808db91e7ce87157235c794f5ae28589894aff544821d9450089661c3ff333faf68cc6b7a2efcc21f57ebee24126d6279f6b7e2a20b77afdcb0baa444f9f4cc419ca8e1f61e68cf22d7aa028fcb74d4a88c029bb045f462be5677c8d27a51499bea1bf4c911cd8bfaf8d9b55686445f5608a53c8e7d3749f1b7c0b165bda76c6312f3fbca5cd243d27c3f0e201f083cbd79de030cf1bb3ddfbd1e520c363d4c322dbd8597b8be98d870be41067f2a59a980e21187ba5ace2f58e6f822ffbf2585799d806de58eed303ce242d0b31e9573f7428f8fa96757a12faa2d3cae53411dae3554ec21f8d7ebf737cd4b7f4242e9cfc2a97ffeb57db6d82dfe2388ea98ae07aad8136f70eab422f12871ede21e26b0dda2bfe69c70151855c225ce60f189425f7059012068146258c1d674a38d3992ef532d6432db9096b36613569dba31a79be81b20e689f905cd8c45d004a43c7311b26efc92ea8aef65fbd79965eddaa2367c879035a5c1d8d78f2457045af801aa7f6cba8532f04db804b26d4909846e5ad408b2e084a2d433b749cc233707ede0d2b7ac599b4ad8f872dfb1ce3b8df43380ad7ae8480e98056e0538eae72e264b5ff76cc8ea239526d5c6b6c77ca65a7372f5f7e00402ee85d3d005eb00f5132201d752113f773cca4bd403533a87426cec8154e7deae515a63188ae6a3b6e6e57ce33bfd860b5ff60a42405cbfe3df359aed5d09b3b3a3f953b1b434aea63682b772eb20c13e3bef467d82ec7952273dd0a8a57e926b2343ddb22b87270427ff6f5bb54a453cfe8c31ba548b8efa63620efa9b094535992d20bd48302e25027a6eec1014441d7ba94fb9f0793eda57a7a1ae83a36b000caf6c18d518bbad754dc6099ea464145ceb8efedff750759be42c4f81c7102fdfae952a8f71e0dd2e5eb03219d3718dd2a64502b6037e54efdec944d540829ea147e42944ebc0fa9cc864fc365508dba24390da16040ad4343c5d36947576cc30ae2e8bd6be6da4dde30bb023051e1961fdf4424281f844283246bf20918e518ec28b615b7a241aff834e38ebf4f421fe5136121e0c955c0ab4a961572be65c0d0bf364c61c3de8b57dddd215efa65de8c29bb283500efcfdb2e50a908f433e91f8ef0f2a4ac19e0ff7a30a2c2f55aed647a098e0b95ca55397f9a11708aef381ce553eef67c15f4411794ce937c74e24d0db46ccd31cf0c25b9effadfc8ce338a225ff6c610c1eda581a33e477b1cf4b1e084b4de7e196c7a133e526f42e800a6ff508ff9cb2ae998ed170e6022ff2c03e381a8654e142f33c5c5b0dd9e80e27cdd833c25f000c858a939823c683020090074ba4b28f985597117a8caad8bd022824c5d5c10e561b4d5cb2381e9f540d09a981791bf441cf9762f55be62b7de931fd6f190daba187723ddd5cd3d24f4685515bf4b851459f646239d78577c2eba5968fdd1078e3853cf45da46dff3903384173c5d27b598cf423af6ee7135ba5a612910d0727952f8d9b60667411361cf2070787fe8414b9ffe20c39f89d9371e615a2281dee5c26eeb3deacf2f0447d08c64df2e286a34fb2a32f9fa7b47a98caa19b2cab9d939814e5b3cbb81ea8a7bd4e5c13aad6a2960f797c1cd4eef76ca9440c870a24e53e066bb0d300a32b5b3cf846f5d9b1b2e6cfc63ec97aa17c3c065687ab046276478e838a15f24dc3f5be034800aad7733d7db155b1de1f77972af005c387a359ccfec82bcce45b1075e7990f2982ffa87108a385374acc52b287849ba4194193576e79416c28325e058b03d17f7477c7702002c490bab48a275a1c73e986d57c73b115a1d92b8af78a22af6daab716dd0a973e5d652f286c362bbbfdfc4d0fd54a804f26a77e6b4966611250064c444e6640313082c1bc0f843fb491db5deb66cb831c5cc23cb30f97ccfd43f14c2362453ad625a8de24b49b2473469c0027af445c8b3bb58fd7f4b34f410bc2cf3407a7d82747e32c8d2fc09642472518896e8be4e164d63948b4b3f06f984da6896893ad1280374aff36ece577b032aceba3cfc461318b24989bb13f7a913528bbc8ae45d437fe12297caa7158284719e94dcc7b34c2dd22341b6502e5e3d8a0e81795f46be3ad5817568e29f0fc99f318ff99e40f56c70b69f71b576d74f95ca6ea4a615aa035c282c9a2678af653a9c3c28be98cdcbbe297a17e6995ac197d71ae03cf798fc6939cfffd1c0f72fe20889cdc15dc018f92aced8b215fee1176e89d740e8c8d6ee47c534a6f31e3d36533904107d490fdb99ebb6f68037c407808fae91b93f3032d91121d24ed5fc3ca9df852de03a3ecb7509a31fd6b67e7205b461e3188a470aa733e4c1f4412416eb5250f6a66d1e462c8a3ca2a3e2888f062b312332e59341b0cacd319d7cbfa7a556998a4af0e860c9239fc711c275233e4d2feb5d8508cbe9bb14fdf4fd1288dcdfd0e1758e6162df48c3b331f87e2b03407ec4503e549e80f6601a106c3b7f891a28bfa59193643f90b1448ce21b6e63b16b78cd4d18aa239f75abe386b1b1ec30aa42990ca0811b0dd3f8cd554270cdc7fd3b006dc6db3800c5015ffe0a16fa79c34e53312cc1b8af38f644288178ed6b8e10f16a0201d4b323c2bb7bc325470dbb1517f7273acce01e800c44790bab8cef6af67864a61815d59ef05f2a23d31aa6cea75780b6e59736ef6a938badae8e5b3347d94e92dc19e60d45f6dde3a5107ca60c9eb4fb2605a6986204cfcf8e8a02aa3671d20870fb8a964d3e80c770b071c07fb11552bdbdc8e878552e4abf56e1e76712db35e939ac38a1427f84e25f80ae4808b08dee451f17a99b1a0a9ade9189f2eba491c9b15f5091f8afb22ac6e8b731815a7ad1c401b5ba02f11c2f9c486e2016b983e23da2fc4bc567684d652fa2744ae3bd512164a3a5dad03fb87cad569b0a1c2300dfd5e4e3c9844b9a3f6d77de97f58ed51e247aa58161a98ab73a1878e26569aa26eea47169227997bd6eabc3bd492df83cb26a61c8196e8722a72abf3146b985f948df8a778f3c02cf9d2768b7a34d36ddade469662d609fc5fd1214767e3cee0b9eb29d3af569723ffbf3b218610e70fbcaa3609862142f755fd15358cf8ef720e635a2e60783af90d15ba4516ec38ade0dee14eb3f0c99b6b2599f4a268475fa1ec1663c8ff5c06167af312f871feefec708fd742f7376b5c415a97fd57638b285fcf312bcc4f6c56a3f3c77a22e2599c179d25d54a24177a36e91f2778cf29bdc738d2bcf874a7bc77d8d446943d30f799e85a34a5fa21fec7b9435b879f0abb558fc49ff164b84b71bacf603699efa4000d8ca000b77e31c4f3ad08fab723ef37a6188c2ff25d0f090e71db3e9895979183261b0225d95cd6c98eac55063a953f68bc5b0f2a10841499a093fa37e4409ddb30085b4fe3be79d4d52c6725e0441587c433f39778abae10778d0ba0a3a22489162dc73395d8b86344adf88a18537eb59be55b2d9f33411c025d57dc29ad747bf697b58788b83193c08923882be8563ca8fb63fb2c5715d72c659f02b62b1cd9455aef6601d6930753056d9c945f6e52e34eb9291cc49f9a092c4edbe0505cbefea1a5ac3c6f6a0ddf0c9aa9122e23dae31932d75f21cfddd9672135a21a84149b0b22cf9747accc8513a9598ecedd4d40557633baf3ca1705d0314b5a597043266b9c008d14936876a7b7885b62b6f7d3f41e00b679095158042a9f7b3a150a2aab6654ad5625c8187f4f56782ffe2cfb3c240298eaea0cdbef632e46faff4fcd2094d9d5ccec97f66074388129366d1aafbcb971c33547bf2cf1e3b5b03f18a7995c9c7299ab7885621aa48c5b11c3d9765fbd81ab1ffbc4258e8e8e115727dc1596a426b5d2dec50a273255b5f977a552f08e0b99c4653d8cad8085a27331636cbdcbfa804f309b7964fb2f1262b45527bfba7b4f2efa8890f1b94fa809f4e2500074c614d76ef2f484c8b89ba9a8943c1dedc984ceec3e97804d7b4e77c87561f12dd4c0d297cf6e6ea2ecc3ffb13301a8997302d6f12b23812dcae62c6783dc76b8249f67973b82d93a8b2547d3b4b6e6ee8069b2a622d33c41102f98fa81178ece6a2b50176475f9d6d51b50c32408d51732b65e3c26a2a09eb4537585fc3f05172474106217038975035c500cb290511a9aea81e63b1d2acde4578f3bf5a40c788744b71c186c7067c0cde59b08dcc795f8ea2de542aa3120a764008d3f671b25ba13e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
