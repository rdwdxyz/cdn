<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ffa62d9f92171cb39bb4bdac0a6816630233c9f4370cf78d37e64ad913457acd4ca54b7a4886559c611ccc4274ed23ea8b86c7f2f143170051ddd9906160ce95b208f6ab305a1372723e451448cabfb4c244de6e826b1d4e210f0778689a343b83f441b4df3495163db2e8ef130cd7b3706f61896d8ef4c6b4a008f4c81cbd3cd4d89b120aa261f4f7e2f39ae5b87af62011ccdf62f480ccdbe0969f7fc20b094036eee881df4ea2f7ea13cb908ce1bb0250c80202d383ae2fc3658e65641926e17112ebe3a8b949ef84d6174f8be017a549652a6657d2cca42b9e45eaed58ee0cb5536734bc51a428b3460aaa2c3c5fd7e85c6c0af23845091164b5898f716584dfd16f56430833fd038756b858361be244c51a88b623cf493cbf7680aa7658022fb3d6eedc78553043583f757af776300cb39e50f9e43e94778d8e886987410ddb27dd18575b3a41093e3b0a57a9052098e72ddb3011ce38860b8b2d7a57116d6ee68fd20e89a4f67789aea604c74400f1cc726ac00bbd1f8d76db237ab5ddd6c6bcfdb687ecfc56daff0735ca13fb85c0e59616cbe2bdf56f861d4fbc6b7fa1ee625d5386f2ad652507acf658eac073df5f6ef9a54b090bc322a68b4628b2d99b530302fc30ef4c317d60ce858278cb4322af67dc24864701bd51413dda51bcd42284d0f89eb936b87afd34185a433590dd117a7eaf7d30bac410932b7b12238fbcc8619ad671646158058d513ecb6ea7c992d229197cd3c3c277ae8217176dafad5946f9d8002b3ae134a9c1ff1e92878b042035c2299318631f4ca1cad6ee9ad09e5817dcf9f8354a85a693053344432d87459939f3e08d92045c8e50a3f0efb60e77e46e9e5694096808bb0b230baecea49cf7c19edf2a1cd7330ae65b0d5c2e74b98e0b83fc1bc1e1c03eb8eab9739e651cdc8e0cf6ad490109d5b7fc6ee6d6e012bdbe37ef55d4cf49959157ab178fd535fb66b0e871a298ee4c672c44c48299ad9b26ab06eb535e0b72d80197beef89f2bd9c1117e74776e4c56e77a5fb4c8863cacbe8cfefdf68a7b0ade482a206799126042541bafa832daf94b931870ddebfee5df2cc041adf66804a4568cce0e124e0ca7f3c788f76668f404df8d1a01b0ad49565eba250c60405c6bd4c79599c1623827f3fdf5b0b3f89f0784280381b42379f294305dd8068111d1788dcb12c1f1e7ac48d9730f00fc7174982378718932535a575054968a6bb01ecab010e9df906afac730661ef0d2a5b4fe661fc15766ee177d229fa5a1a05573489b40cbe2e04fa39814dc760c250a4be1b8f623674a0bdc46a596acf48b67f9476b2459d3225d9c3bfcd28449a80279d35b8a1711b8e96b63bf49bd4dc4232bac7b49eb2ae0b06d0ddd231f877eae821fc3a0a97de04f6f9188a8a9c536b4eef0e977e87660c60c75a8f182d7b792396772cf02acdb489cc30533835506dac16104dbea2cbd3c3b4bfb87f595b87c724c26271f2b51f87ff9f890e05a5f87afbee6f55e0342e70c658a73ed41379f1a963a45ea59c12e74cd093d02997626b4d334c33a8357949875231a2cdcfd481437ba68fa762f104c14f9a1a1e35c2257c26900ceb2093ffe84d70f5d879823e70e75a9dcb7499c8c732ccbdb643e3147778d6b79f22f10c0bb32f76bbff35366074f51e084c2d50f573955c91147e378bb250a3c68834be763941cceee2b5edd2443e177999d1a5428388d4bb65a17614871c21e7c68c60f3615e2188c7f39bd2386f7dedf5476e2ed4089be26a6685f18f8a5b7a222510aabbc0018ba75c4eeb843a7ff45f7e6c689c5c686470315de258fa7bc77c67802886fcea7e638a70a13e506b5239066475c88c8be36e8c8ecd6cde06b80c1f054becd0aa8505d794e742e8ee1ce894ccd8d045ac20ea866e14a227afd8bf1c09c6921b0c230245d2d624392323505054ab75efa760a075374432850d4e2b8012aa7952f3183fd3d9b23522e61efeebe55aac44d87f89789d012c046d6f07b46cfe5c4cf53e2c041367aa4e109760d95fadefa7d351b94b7ea31283841f27a290d0abc323f329f638d16949a86921067dcab0bca10f01bc14e07461fe54f0b2b5ac83f94fa350fed393bcb7924bc9dc3a7ffa4b8b7a3182b125f3e7fe582ec82181f9986dd816a02cce76d755b1edb8b0427023d8bc87b34f0e859cce50c09492ba6cc41e6a0afd333d3d1260cb06a34dc17e8f3d4075122803a06295e8f99734b624d8f3972bd9b17f3430264d3a1eec34e5764774773b04c2f4e0786082fd14a918b46d015e611af3868134847ab25e88db3994be2d8c783e9907b76d57efb0f76eebe4aeb6d237969b4e6a3c078d7bd0c9d2338b0a5d9b140b9ad59bfd6a55942c1c36fb2a47b59d661906a0af72d1b68db663d53f8b1c994925634a49c4cb2a1c8daa8fefb9bc8d6ce7b08d814bddff6ef8b7448a60cd117dc48615e3fc06e7b254f6da0efa9a3ac2c178effb47f9455102ae4f12bcedb4f88f4680ad3f14196cc8ed68b47c246b52301dbb2dd2bb1d96d771a9882dba177e90a505ad407171f14a1db774cdf5d4cae64207cc4d2d0481f1769a4fe84f17f9251d4842f4c4bc9a892c1f45681287f4edcf7bf4e88a5bb20f0d5a9a81fbaf886d3db1b16987ccb91c38f0741969608dff51b040584f4de8aabc85774590b2fda0c9b214d1ba69aab1b76d51d3f922a7cbda105c5ebe66069b9086551d1bb7026b812d57e147c0fbc75bff88dbb3793275584c246f8dc502d0339b93ccfb6de64320fc96591eb40e8080725c089c893abf59a937413857010d495cc1acbc9c3f87a9a1e1568a3c24d6d644bdabec41ff9ae47287908204e8b7943fbfb47f63a46c3a26165bc20e850ae7fe50f012bddab4a8336adb6cb6619dd7a8e3bedd2f7502c945a5dbc4d6dedccbc3e24f4d1fd05ab938a17dae0081316f2ca9af396dcc6a5f2f9ce4649be79eafd43e7c1a8c3803c1b6a731559bf72b32b77f69ed98a8116a0d83891fd6c6bdf08ea8c260e8dd495c5c39734e7e0ab11762f338be699ca45e73394f272f5193ebd58a0f4697dc18309b3a9f4b821f1483cec1407e2952ed8d0b321ee0eed5c5b7324d0d80cee91513bfb82aaa3ac4fdf7aee7cedf8408eb0ad007f119c670de961852cafedbfe575107964fba60bb105286b570f08327f3a7b4815261583597338c1567d914e62465f6edd8f3cad4e42a1d58dfa5bd07fdfc49ba693299dbe9298bee5e8b79204456fdcf6cdbb9feaabfb3599703d0b43e479dad378d3d6b5b28a133aea44ef7ae2975c0e281ad37c08b619d460155279a2c9d09472933a6567e8d166fbc9cb3ea727069abaf0959dcfb521d2d69476939e3922571584c820b23f4df607c050b86b982a72de89a1a8c53b98acc441fe998f33a684acda283960cb22998f24ea493304f2f38ac445a8de07ba96cf4c290f001e5859b5dad12ce0f8737a063e5531148c6655748488e2e920d7e6c304d476432e49368566d2eb1d1c1986053dc7aba7bfbd95358ce5285a53f94a677abed6eb9c4a14ead31a9fd34459dfeb0e2cd1e1d4f6b7b3270c9bed49e74a00beaebb800aaf41223f88256d68c45476ce003618f05bcdc05b934111766cb453d17fd45f9dfbb8e5ef67049dfbc73bb8486836333849cfcbe7c1391bbe966e36b2c4989df8b55d9bc49618755a9c14e6c8c09bbf9dfa993a72dadfb4ed4917ac7811b1b6ef8776456c8d242ed3b9a3ca75c540caf917545bd76842e39e6a57c7a287cf5d3fdfd3e4ff6da5d0ffbbf6fc5b86499b147673bab9f3d588e49ff12e1f43126380f22faa6b3fa30f226fedb4c885b327906d07bd2a7daf0d86be7fb3b78a42b39c79ecb0e03c3365942a8e77636929aa15b4005c33e6e5e7811cf667e27c552e147cb2368bc1de9c9d800a2e33b1e6ff31a7a3731e8cb811a54b673c54dd036ecb2331136468172700d7a7166bc9e8d259d55662d2247bf0299a6870d56ba45afb36cfdfeae5c2bffb417b07c547ae7fdafd5475b02840b2be8ee64e949472d1f5cd3f0b6745705e18eb68ef00bf78aa0b0ef684ed27ae2ccf672920973d84e4b57316eec495521a1728ac57303cd7c36a58994740ab77c58abab0bb129d01cd5c20c255846923922a240e8ec1afea4d30b2a03e5b4028053c5ec37ff12d33e336feeae8be4585d5fb7232303ac78afff471cdf6850f60292bd0cadb590c6a688072f7efdceec55b3edb0420d83ee26b19137793a3af66c2a4fa2d43840633aaf12f84223a44869535954adb0e808e6846e17a173cb61195c60881a1d3201d7bb01fd7b29e83d1b64b0c9ae28f524678f3c8b365fd340e7512f84ec788b80689b6bb8b0ab2db9be5edc986c1fe7637159884fe07d194ea49a3704a20996a88c51d255758b02e715ff689b60d410cf65067d3902fe60121673d648d40e95faac4354fbf55ae02ebdc65d325b840b032143a8ec6004cac9ab3e171b6c8f99c91ed8d4f48150dd10f45203354b841bf8984570159c6843363221ced1d0fbbf0ca737a350be812136e3a3e3035e7087cdf530dfb4efcdce5545c270eeb4834f8583626b02c402cf59fcbab5b4584022cd2fce05a84cb210ae8e1dfe0381510d5d06f6f9fc0cbc2a3189c8d7abd616ec1d8e8e7e720fd2b92b16820e6e2b08d5c417c68a6c02fb9c3b71eddf9c100155d5576b4a4566c554384cab504c25f44bc2cc03e66732e7502ce90ce5540484e2eb622487d4bd0858dcc4edf1c81223ef7162747e128e56012a8cd37eceb7d57c29fda9f9c675d5dcd2d5512714d0f20049fc6f19f94a298472ccfeff95cf0a37ea4c7ef255192b6678dd3fad0326055b2e5306b2c8edefae51baa73a639530d1773f7669886e481a1d50fbf921dd3b347b968acb12e6ac29655da8175a8668f5c01d88a922ec1b32601cb8b9c56ecb24c0a53b2fbc6b908f1627cb9b57bc8822505334283c88544c403723dc269d2b1a348fa00cddc89e342791fb2bf89601f32985f329a1785e35010c8cb69315cc295b4c45037b79bbc422fbd8eb5b7058d8cd310f0c8853752fade3c9679b9ec22bda7ccd855bb5633540a9b02e15fa9f43d50af88d93548391c67641222c7c71f511366463dd0d12857385ec3d2df39a0e60b732d606cea52a1232bf614f5b64e42c3e0efd28f70afce51099c50201259cc484dd3d19e8725afc8d8439987caf1f5d07b4e9e4c62a00e5737c58e939a3ea4f2e520e8c8dbbb8c42bd9d81f5d01a579fd8d3dc622c6030923efcb7fefe264f3925e21139966da2b360ca3e3e6e24cd8d5229a95eade3fdb99f8fdf45ae5a0d77f37ae59bb0cb2796c670c9d4d6a89a068533d410bd4d94542435f8a64e31b0fb0cae6ca1f92cc6d551d92b1cc9a361130071ca9c373c142cf96b7aa4dc552c7c0861ad1e26d39681e1a533f6e50a58e3469cdf650b3c859cd80557d778a25cd4775f0d6da2dc80234639be73c4f560f653005c1b2b2dbc8e191004fa9656bc9cba117bfe95a975b9eba3725955d16e5b2d26813eec0efa1907bde9a90e7bfea2bf799cabd1e86c3da9e13273fca9d2d891f3abb74bd59649e1cca31d5035dbd67ed14153e67cda87a4978debd5e044b92525f51f548fbe5a50d3d1f84c0d430c4d762dca0980bf87507b4681a93a6af564b9f11b4fa9404100a7937c1e421bb6f15def8c2befb884044f05a73bbe01648b4cf41033c76c07a2b1748582730da8027c18b65e1635bea38daf924f7e6026b89506480643aade3e8f86fe6370159213859d31a43a342993c927273d99767f049457514880e326f8d0c600456e2cd64ac8c929e00bd788cea170524b2f8be7e707f37fd634b8f260d8464e40013aa21720e14f33d955e6d622dab9fff20ec339cd11c41d6f510dacd238552ec32b439b476820a3f980cf39576d0cf6b1fd8351145b735448db237793c1e01cffaa100504592c95c02ba2d9858eab9e1b2e8ea648036eaa297a6a6fdfa1d1e9f97f70dcd90f4148a51866c46a834541551194b6474620dbfea10a1ab62eb9dbdd6f28c588fa04cf2452c4098ff6b798384b76a42b66c20b2755bf441962f935b031d3339d1b692e7dacc2699d8f283644c11f7b2892706070609c222bf505e50f04b363ab7de159acf0a7252a4967303ff7b4d5013786b7f4380e8bc8da4250bb5d3f574e1d193aa355b5d35d7e1763a8bc5e10945f6c1c78444dfd957796af1b69b7e8750a8ecba892dda8b8010f45391389c15177adcb3e2ce10d2ff4d379fe650978fb3af0739a7edf9867bfc7b13ab5a4db4a4f29e5be8982d9a27234148d3dd3221ac57b02cda0717092b974ff2aae8003b8a2938624d4bdb6b5ab20d64cfbe61d82826095309e05c82f3daa964b0479260762b9aa5d415b16f3f646519773af856fd31598c78be7322d9809356b518732a67073534562196383c36c51d32243c36f5715908c28a7b9b58d07b09dafb5ccbfcc21c49473c53f7f8b949f5d10841c72dfaa050c57090a2ba50279a07237ce9956db9820630d40c9ce953066cea7a65cf4551274233dc94c7c78d768b213b393a54fe3729816faeae81db1a50218ce08bd2fb713eb0ba8918d0776446f02a0c339d461984f600d5f077a6635a52c3f6db38894927bb4c97ab56a0e177abde9a4f1122cf5769ed3f700d6cff6e53330e2294bbcd900dcea4583e7a1514dd03a214006796cebb48b0228dd19d32611e07b5b6042d6e21be7de2cc53ffd067437b97d6d227a224541f204d1a1061e6964b5ae543cb6ea1a326fba90e1e1ba0cd020c8a4a4465365e1eb347659c8c40317e83c6bdd485985064a3a4fbe8d63f90cac05de748477207e5ebe46ddb99bdace41693641a8876aea9035a3cf4e4d22d109a0add825b4d691486a1524fcf386b8e3953623789997253426636665c2ec926c5e3e0f7c9c6432cae8e8503d814a85686f028400a8fbb3f5892bdc0df8181a2395f4580bb7efa81a9a06860222f8be6504dd486a7f89a72bea3aff6282985a0c63d939bd4ce24a12f0047855a889881eb9ef091fc3a4127af333b5f4cd58bef4cce417e7a54fd3ae66f22999c0fbccfb3eb78bcd9cf7c30a7c0a5940468b5dc4f0822fde290129ec753e8c45dbb436b1d4e56d9fbc69fffe5f4698e6c19b7750f7b371b548994730354ffd9415ce7c6a3157c568c0e9b3b27bc9e4669dba4c2c088594a84522cf6ad938789bc8d75b2834ba8d780792b402857ba6b164484bf196709b0d645bd9c8c43fa45a0e2673f05a81d24b4fa581316bfbdb217fb3f08ede94bf9441f9639226616026e7dc0794c6d0e52f04f76cf18eb2414ad92c1759a0a0dd24f200b274a5cd002cb0df54e6fed3f468f71d9d746672677ecbed7bf13b7dbbd909d92dcb99cb3a8e68fe5271cee6bc945cd0b6bb4cf51565e18587f9452ad2e762608500ffc2d2094e0ae43ac974e7b95a6c3fea098a6cb021de0e685030bbfaf062d51ab42b7ef90ae38718699c2c010fc7fe6de499938fa38a2efa648df9d59b724ed6883303e7420b983baff4ea092e8a09ed0ae667b9eadc658dae0693fe0a390ea5c97cf64d76e287950998e229a7563a629dc231ef68c227f7cd985914f8c33cbc52ef46420d80828b0f08a241a213b8d5a2dfcef230e3dc9af12ba5f5a7cf80f789febcb4510a7eeec2e01c3ae267911be3bef1cff47ff8bea308a0ab5d863fd2bb7e3c12c9d13bc6979f03fca2228664d58a47297868325f69bb266d805ded172ba5365cd4701e9d5436c2096ccc32c2093b52a46f01e32e8c8fa8deccf18336a6cd32dafb60909ee51581c06ead0ff8dcc898201def13d1039a4b1cf532fe169e679bcd0f1c097694fb7e51b4b383f7c05bb4bc08a02cd2eec4d132685134e2bc6f499535c2049bd575c7fb9770136df5aea65b869c2af849ac00f32a66733550948c7ef325daef9486f756c7d406f20be133188d38943dfc80a819e21912d15f395d0a134bc4cb15e5b3df4b4d267a1c3fdbfdbc057ef55d2efca04cc87b3c7351d29d3e5ee974b3527b25b28e1a674c825893669c37627ec47998cc7987101f4051fd61d57ba893e33ae3e11e7af5ca192698262cd9fbcab23eea43f67cd6b0fdd103ef2aae0c7c7af835d611631157a58e112a071012d50f393f1ac17a4d271eed16f5de820c8a397deff8b0a729cefcebc8fea5d02384959f64b71b980b8257d68d053fd5ff6ec863feb3fdb30d2580b1423663fd0284a44b1ee8c3989a428337090cba5e6180159e32aa6213f1bc1783b31e1c20509dff1465945644689d2bc6a5a5c0c6c5c27c5e81bcda6081b311fdaa1598fdfb6023ba18baac747403c8ccc2db237ca2adcd85dab34a22df55fb294757fd84f64c74fec092e542191c8385433ea4a951f73819f719b600d2943245b11f2928cd0a4db4a2555870c2f7aec5a2d65f6439fdf1dec67bfe0e55c26bb1d3986046620a0d5553194e1ac0d800a8d7581b01386c2992faeb5c8653bffa8ac9d2ec17734d7810052e6871d0f83be102835e515da7d064e6c30d397c6e68d72224a9275d5bd01236f0eecaccf6d87916a606baa4fa5399a0e56cd5429f0f95fe92580059ec8db98ef4c1903d488d463d72354bbffd7960e680297b5f12ecbb897468b4fa4389ab44d1819805baaf64f97796d7ebc6948fb1ae772ec3877076f1887e8ab876648b30bfb718fce7cf8b6f6b53b58944762bd097e78b2a5d08b1e139b094b8e765e18aa7259b76bc578116bc99c4d7aabb33fe464b4e366193dd2e63a0c46f4d16f22d220b389206064a463f15340b6f13068680c0464326fad4f4dfa9657ac91b133348fa43021cafb3c5e8f96b892fcc83ae6d76fa156023b04074bfc53ab2d76ea5b24589fd5350af2fd2efb732a60ee1abe013a9bdd9a5dc1ccf77317890e2fbd9dab7c6e8be959293eb124532cd31d1a7d9cad596d1994b29906837f585ccc9d2faf776191fb7545894efed175dcb0d9695a907f65f5cb3e26e6b5df08610ef1f29594f10be3b51f43b350cc2e5209797aca77859734455578ef61ade18683ef470d4a556e3cc8eea18d287994478343de2255afbebc1d4cba5aa91acd05038b441f51b5de7fd5639797acc839560ec8ac1cdae7573fbf723abdc9ecbb4729960b28e9c93397447f06460eaeefd4040a1e1d494edd2e46a504e8402b92efdd11d4c015afe91e1b4fdf3badba2e96a7bbc421540a40f9debfab4b9bd43e5d1e78723e1e03dfda9f9e75e80d295fe5856d91ed16703f62dc6fbc653976ae628e687df8a28ef3ffcdf17c27e15db43855598d78bfa4e6d8bebba08e533f2f795bc54489d0dcc0d0d95dcf569e598f3cae3b78e96963cbf229bc2324a1b93f6cf6f5da383dbbc53244775e0043ea020cc037013653b272fbf076ec714c7f40cf5dca7cdc0a4cda6eff6dce22fbdd83a2b01256fe59e97f629855c7de0c05e4116e85b09d428730b6c5dc69f424c3e6f47c4137f85e401e0b672dabacd4a481944a6f6c7457b4cffc04cc18d1f18f5bfd13027043fc0c2f9f15c8afdfec8c9c6a54752055e31c19a6941d6d25d39cb915df143d3b8d3b6ebce5cca9d37cc82eaf1fc81ff461bb88a9748975105381eb424e5b422cfe4cf0ac1ee8e113f20f6f389dbb4de3c3cfa87f7d16507796d0cda5cf803f42ed3354b6858704e71430b324527a027d711942a7de05a4f636cbd52e82e8a5e77e5db1f972b80e8becc0db45e290da58c080066909a4abb63150825558d118448fa316d6ba8464acd2e9583245ad90771803884af10015e94e1b0f55e92583fd8bdea96fc6ca0c86b90e33612293a44f3856c925a1607957464a9c0e2ee6375482c205d115c6dc03d0805292810f32ee797feee303e97545b4989720b84f7fae87a544830cc2529fd0f12bb872b762f97d6de1e4186dfccc155441443dbbbfbbbd39b6ad5e800a76920a6b7156497349f0c8323127c87391fb3a11036309bddc78e1f516d6eeefdd5b3c69d7b680b84e2c30ed54e22af6b5cbb1fbbc92dda88f892c4c67af672caf4b2483dcb5a0870a354fa78e45edc7a9ff5aaf8cd382c85a4406f43031547ef2f0c5a3221d00bbf2136a7a513a3b60460b43622441e5cf115bf0297df349f4ffaf23dda60a08c2e9e9ed247028071daf275ca4e9dbf9bda77577b12c30a083ba042e5bc416fe5bcba9504c04a2539a3a9282f3117a4a636a2f71889a99009d7999bd70ce44dd8cc782105efe77f19bb31deec9ceb9225ac3f4f715ee8ecfd5ec373f7a84c3523f606b487e6528bae4faaa9211e4dc11beca0609d07856467c480dd0747a421bd796d627b44b3afd0eb5eb20d2c1b36b0e22705be0a897c518cf89e4a3260643cf6f8851589cd7ac55f1ffb8053fa7cde4cc608a87a890a59d3a71becfb3eca39ac6f452d5631c881bdc35c6fe8c131e1e204493077da3857df1a851d48276eb887e98da1270e7366e0169a4d6c841111f323b9543cf2cbd918eeb0174d4e3be60cb5509acdbd5987b139b20ce541bf9a58e34b9ff3174d2878c9a5e4bd7ff1e4cbb36da465f1a5456529275361b1e363cc8820d899dab48777964ea10e30bbd35b8eb67187628e283ac28f9ea91ba3fdc485d383e6589e4f926627a7c1cecb9884e4f6d5f27f40cb2e0fc80c94eacd9ad1915a0dab90fc374cd74334aa724c5f28928a8a899ae22634d90cbeaf7c216426a3d4e22e7b5938430917be62b2a3d0dcdd10ec663e4865bcd748f0278ae87c8f39bc33ed3baf96e4693606d7e205904fba2855b38717843ca48ca7abbc61521ea8229fdca59792a73966a6fa90beef12a844eeec249d4208f995081a5dc96e26d0e4dc1f278192834ef1ef88bc8cace163afc90a7f2c2f4721bc3e68b267fdc536e45aef4c0474e84689f6214d749a95452e6823facc68b57976491ca2e3aa92855f9170847110cf7d95d74093972a9e08f673efcc8282f5ef8aed046221bcb639875191d2e85808ea4ef567bee9e0d80d7a1ba5e9d361e43544414d226ad0001c9a27f26fc70f69598dabe0ddc9ae15ccb4a0ef45ae4e4802ea940663df84daaa03a509a8d3751ac3a8cc4546197951bf3f5067969c4cc5d291b1736a864273e6a968378aa16a7fb5e265a4328b13f138725d5c7334c4a79a337facdd5dad492a715601e1cabc52b5078f93c27ee5f43248b544c3d90eb7a672306358a849ab28059e5c28025a1b6ee8b258a1e940e0a580b066f91ff520d7040fe610458a7d26574667396a353de8f4f4bd1828913e65a18aedb9835e7f363a12fde14c049e555d6cd08453ea388f3b50220bdbfd2a274c447a0d56ba62ab5d8ee1133a6983faff0fb8269e4fc1af984f51a32c8d409be0f087c0cd014fb5c631cb69ebbfba0bdd3793350bffb0de95738dfc883808b9b95ca43334b085af7e521d3f6b448e453feaf339e7c9be07c0ac3cd5e436fc806e7c27fc630531e13788f5166887ac4cad895638f6fbd55208a68e46b2b3d6c6c7d7067cff804406f962fb394008918ef70c0935fb0f774b1c0e2b1a41566631455b8c5ebf54fe2c2d5e9d67dd6c18e1705bb01a152866e3dfab40bce5fafdda8a79e81dfa98a49ebc41c39be994832d594552cb11666cbbfc005680afd801e67b2a778ab66ad8bfad9d6955dc05692ac6b6dd4edf3f80309d6e0572a93c0237af63adf5303c1dbcc2b760faebce67e7af47168e7c1bcab6e18a8111831a642ecd398012d3bafa1f29af06f391071d3e5d9d45459e3a9c6c8791e52b801be6bfbc9618bc6856ea11ead8fdb9169c4492c2d630155fa17306cea8bae51d8339532c45281530b081eb33717d57a3cdabb4c55204b492b67d522d6ed59dd6188e6004dda1c706030bce3ad9e023a6b38237ef14671e2b5af906b6b6801e7642fb0aeecbbcb1e9e16ac441ea1933005fb05d152a64b3f7534a2bd47d7920b7a24377d03dd0f3d2c8061c0085d0d57ca2c482e40336ced740aa9b11128415da56ae552866953d6bfcfbbcc720a7cfb5c470de6a997c28e0edcb0a48c0ebb22ed2007572ab456939ec1c15795c2d1cf1a48fdb683feb2e1065e64b93f9e4bd4b9ca80f56b5ee6e54ebfa99e4c40e7c9cf66188d71af349ed07f411ee1a5427adeccf845c790ac2ec2a041afe1fc427c6b68015ca78974e3e5f6a4fb6b0ed74c3d32d007460265515c8dd0ba282fa0b051988a241a550fc4598bf1293c987e466f8b1a5b9812b556cb847ec4af0b143016fe9766d48fc730a3a4e7a1fab382b911f314ed8ae64681b9e2f6a3ba622b7c03b21142c284ac1dbac6ab297389657ef23f22055ffe811aef61faeb5c19de47ee1ad9560b5944d91783241a52f7f6469dc26326a6393589318491814eef923e18fc5cb26274d2bfcf4d3535d1c0f6ab1df8cb61f07a00d2c26a2b2d97549b8a09cb3a5504bfb3cb20e4a2b0ebc0177aa9d012b2cbb84062f8111e667b74b494441c4209648d971fd936d066ae2762d05b5b19dac94d2aeb533830b28d5fb3c7368eb485216372539538a7f0307ca2b619108e0aefc00b71526a39dfd47f3a92a716998f871ced5820e31a20f497bd1ebbd27ecf9a8498773d79ced014879cdce42a1d270c2d0c9456b1915b1ff1b9ea3ec9101b9f98e0401c3f918051508111351a55c53121535e966673a0b20646b4130be443bffa78ccd5063545a60172fe114aa7d1a79cd8ec9b76a50f9a79d423ad5576779523456437c87bace07712693d9303d5dc2356b3d2d1c77de6c940027c41405e696ba8641f6d585cd874550569c1b327ab2bd486b820b45f53be3245748a51cc10ab11514eac37671841e72fffaee8b6af914a2bad2736594e21c96cd474513ad07aa0a1170aa2da2cadfcd64fcd0be79f89fb5e99e85fcd1de43bc491a4eb3aada0b2c5734b18867beb306ff847660fc58182060b0cd3e35d5dda98eaa731c407cc54aeaaa0e55ddb1b9fae95b433aa5dd702db835cc40402c6a54e130223207805ddc40fb23e69b37d7b15b60b157643bc7df9c5eebdcd699a1456fede749cd051e5b25c116ddae85c859f0850588d4d17cb4d446892c78f0a364f6d207814b7d47e7c32bb60571c93fd9769fe46b0cb594a4a037d77bf0ce7734d6fa655d3049a302729999c7a110e507a8113a8924225b1518b8d381dfcc9c185a4705a1d539d1d020a87b9e744f72c493bec58774739bf7d4443dcfd4cce7d2c91a6ea62ff16495a7babf69bbff08ca769dd9344d720c34b1cb8c17132ec93be7009b2c12f539a3de6ba56e00f8e53bc51d4c78f2fed2388856cae468b1499cc4b6983ecf657ac2e89d535d530dc43082b58a36640609f36f2edf08a463fb6ade567ba5ab10dd057ffb92de319fc2f5e0a13ea29076a65ed175e01b98a5e3e6315eeb02ee5f542280bdd08fc2ff80ce20982edd20817910de73b5d172f4c16e8d441b861f95f2a711b19a3341eafd4c20d2b533df670d09eb93eef749be9b9a9dec72cebf346d688195c78efc01bd57211937c2dcb288222ffb4f413757f9b5a5a42fae4b12543b033a00d715c57e47abb949671abb1c990ea02e3146e62ca2c5857a6a59b811d1e605967c31fe94d7c38f7253f5b8c440adabf85ffd330870fc12063935a19aa95cdade64fd52c965fbbc7e38c09bb9f1fbd6d526bc3d9ef64901841f7bcf99ad685c6e47829f177c575ae33c2b25b60b9238e4ffee60749602e3b729023cd925cb057448960da2653e75e4eb47176b73e834f92ccf3b233f851f7c31b643c7dd88828295b193c46adc90413625d4f6268f9c153d343133d393b4f24f5fb7b557f5c1999b84fc74915f46b891b183dcafe2b5b75dbec9f7cfa62c75c6d4a87fdcfd6f301dff7a294b7d4ad164ac90cc032def73438d9d6d5e7eb57b9f9fd52d2d5992cbbc1fe263e02be6c178d0bc76ed0afd9cbc75c9b9cb7bd4afe44ce3a930763788a03d3bb052d9662aee00f43ee4acdfc62979eed0811b1eb7a5c538d4502c73fa8a3ca51d403a0afd1e712cd905422bdc59a24a89fedff4317ed6679cbce5274cf6b3a00a6bcee6dd2e7e82258f2667fcee7d9570f0e1c214cab087bc0e765da2d226604065c9611449257e5e8b27e21d104be1f752ba7df0bd8f8e2a5b8cafd31d381e280178b7ed6c91ba5ae4b8dd7d8ab0aa907bc4b22ff14d35b3a1290be640d16a448239c63829254e6bf7e457f91856d176f523b09fae24184871a62a0bef1e49e131b68773debfac41683fcfaf08d03ad7194625e5d4c00b3f3fd7c59594fa86f2723722855385c2f3db7ac4649d00c001e0a53ae71f436f8e4794131b06c2b09b778e1fde242d28367262fe80afbdbb0f8046045966bf73c2926ca46a9f37991b9b4bab181e20e936fbbd1bf8357c03ce726db0418a7a42955e2fe61cfdcebfcf75668a8cbe38b1bc467b74ca8addc2d6fae723f78ef81e659c4e4d2535367ef097f6b2ba9040e996f70e7c14de64119524a73100a5905a776dd57279b364bb0548e9f918ce0a4a395a8c37e2e1e8462394682efe3487c2387e1dc03a8dcf125e0558ac4f29a5ffec6970497671db3ea8447eaad7eee87270dd38e21dbd39530cb7021174b20732b54e2ceea963d3667c8e9b683479a3802603ed812e7015aa80dfac91503d732ed57109475a7ff1623cc7e54033004df3382ca7e72e08d61d3e585c3831979367d408a74f677db6143f7952256fff5a4694310e6ba40f30f8596743beb622fff4e862e2301a5b7c79a6d66a057b0289ffcf8b037e65798c18ce257c14d5fd0e7821986ab772dddb3424d293a154de738629c1a2db214bdf8c34811e88511bbf3c6c22a89d500629617cef6abbc26d2edb10f51b30d75df2901ee0088dff50d64de0d37d9d63956d7c32f78d30b744da16780eb6193f1387e158bb0f530fbcc5601578a8416d9593601336dca27fa5fdb73e78ca6b47e09a4b0a2b9570b20dddb364718d26e93597e937dae0576fae8b8a439ae7753e5e6e968f4fa3bb9114a5b8a47f68b55aa65e0d0fdc07386221a3cad9aa9b3e9c980afb316d72ebff17348ea3f9778beab5584dd4ae6ea6c790a426f4f3179bbf507950819a9949f7560d83f8f901397b5d9d58d5830698827a8a55fbea48ba71b783d3547856b5af80748f8715cdd51004802868703365bc54f9ffa2725ad6680707237f33e2dd58fb20781f6983966b2f8699f855e136dcc0e522889a9c6077b9a8d865f4add50e1e1f74b8189a17c34a72b16b2424fc10bf7b7a66a14365391da39f851d891dd11dbe7ceb1132336772313bda08b7f36f3c69410b49712e9b55225e4b844f2138a0c909943770733d7539188886b16ead89b9e51b62dc22d4cde57b0b9b13bc4f5ab52ff42a6e4fbd1ca5ddf8f14e4fb571e814c170f4f45b5d5057a060b53656fc62c9f5c1bfc608dd08a3c6132f665e5251a527ea198979954557b20e3fc2c951341cf0246ba55e9991105dced15973afb5b8537be5af8f1e002aad0a0f670ff2a3314ca8510af11161f938dffd1b0d35cdf0e554cc38b1b4d62fe3e17dd5d827445af2a48bf0fbb8141e0ce730433df614a9df04ed10b00f984c648555c83a00b7079cfd20f2d3105d93462edad3290022b410c0bc7a6bff60c23d2177e1d482bfd2adbaaaf99780fb281a36372861c1e2a638ec2c6b1223da7017b1c7d802b76f969197414b1598e3a40b3f22c223410cad0c4b2bae24afa0faccc17bd6279e6dee4e0bd78e0bd8e51be1314a6f998b2c769ba6caa365303b4f59cd81e3deafc8ad037c343dbd77df134b2d256a4983f3c71243c0eb8fde70dde6e5b939a98ae9572f7e32d1a5cf9b09e943a422dd1fc41191263cc10fd606622507b45c3fde8ec70ef798b7271094604ca68c45bfe6db82192c5a15c7bef93810b9710e68784f773689e467e235592c6de9a7f9e366e180a98ff1be35c81e63b6a329650ebf10f77d5a5dbe1bec3877927c467c42cdcf458a47eadc252cb8b3d188324667cbb71b022d87074bd976e9beaff8dbb281ccfe6a847882613cc4b6d86187d467330aa01424f4a4e828abb9550dafdb12ceea2f3da1fac5e00e81259fd0ea3177ab78b80e9f24cf41cdabc66b677f9614e2e1c5fe3329505ddf07c94e1f27f6e6e812bedb21cff3626c74eab1a9f1e6796b6f2fe25aab254adda263b187b64ce2928d74029d6545eed79f4eccd763eeab1922f0eedff647251af061468b4ddc09782d5de0f39a2ee8d4c03a262855f6855fb704c734be80db8b7d55d2726b2b699d39689a14a34037f74c2374cfdd175f502583aa1d560bd72d84cc86edb8f30d2b81210668dc4ef96942ea9a707e782412e10316b9d8792e792a30740c646747fd2ab7808609b52748dad37cc932c8356d5ace524a718f309ed53ed34266450d597b4ec66cfacd0de5c356dba0ecc4145871e1f383e26d1962162d092304d7c582aa707d915ff431bc05863921b3e7b9d8763ddfb2995505aeefd1592a5a73a5cb94621a3a49938efdc737a74f4687a9a4c40c9437996a37a41104666f1b99924d189717e204402d41f368ecdda04008dc85a7e6d777a5b73ff0413e38ec46bb2af192c87a18f3da69ac06e4e64c45c03833c406043b09a77a89d23d70f37e392816e33c44aeb67db69c2928c382737da7b33c219f22d600d0c114b54eab879db262c703ed35d9827826fc108916cd2ff8751ee153561ff760365a0de75313618255d45c839e4d5c2b17a6a27ad78f4327fd979d4a0061423c04c4444e0031c769801d97b8aabd3595b5fb8f5cb2d38143d8653757c3cdd2bb745a808b716d5b471241d836ff5e66e725e6d5c8b9cde247d5d9c06536f29ed9f36e779d15ef46085dd13eb8ad7277d0158adb1416b8633f05c36edaafc65f19cc4e6b39ccdec94b6e67aaa7350fcbaf6b704ecf6e678e1a8a35929672950e02e747db8235fcebfc581236f8e8e14c7c141423daf49c50f81af96f796c706ed66ee58489a03c212709b544742ce7a27fc0f0a1b7be8978a4fe3a5b265f16ac46ed49f932527e2db9db032ca9f8f2b167ac2926372294599647ba82f5aa241de4a626f7c1ee0de621ec624c93704ecd9df9612b96aaae33f5b4ab489384760aff3593c3646a6568035ce0ebcac224b2b2769bc85a1fcd9bd46142faa99654df53cffc2d66dbe09f328defe478d093887eade2884b3f52f0998aa4b8b0604c117cd5b88d9076830dd17c81b181f62be4f513baac59eb050522d92859b37a6be95b20e1fd893da2459dc88ca6db4d0b098450fb2f09001fabe2c5d9c5b2d470935740fff3f9b26a32c510bc0ee6aafa5ce3500233513ffbca302602f1001118032b41d100c795cef09bb06c2fc22ece8671b352d75bd7a193969eb4b6a9b87d181d68f30a42ad7d9dc72db0ec843c34167d815dd288368bfd9f96d97522bc934109de73daa1d24444ffcb902b38c71df849286da9f0c66482c5245f188a42a2830d82ab01a3315c36b6af2d519b517198a4571a9fecdf2cd6a8822f4aa03a8e3a62d5388f2b2d411762772daff20b32834a1d8ee2de0399f30bcdca9c727ecac842c82a2eba8896b064b1a7dc59a9afc9cfa483b63849d0970e2d4d8a909f8e181706688824464ad50b92efd58e69eecfaa75b1ae8074f23b9b90fb80d31b1290790510b9e3fe406878b52dbcfb4eaec9b16764296c511ce8efa3d448b48bbf8ea316c63e8f4e87f31a8851cb3b2e86b4e0a96765b57a245a2982a76f83c1d953756238dba3bed9fa8ec30ac3a15b570cd9dee99fc4dcc4a529422a3f2e95feabe3778d6405541c98f627db2ac9ddf3a10e18ca2d36cc75373af237d182a94d1c886a8ce39a79168c4f301fcbbf5eabd610921d1333b579669d1ce99ea00017b733a5d5ef49b084eba76e0280208f92a34cf07173970dbb0682d570118b92efeb117b717759cc63ac1bda73182f3836cdb22f17974ed6ecad848a7338f17e86","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
