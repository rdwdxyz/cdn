<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"351f3287f597270661bba71d44a14e7a8c56a3ada5afce45078843584cd348498b0e525dcec7d29ba3d792815c89ba4acf0c87cf544651e01d699a81e14be5f580b5f55f3729cabc69f32099079c56dbbd511c5ed60c0c8043a4e8161624dc89378ded4251360cdf457d140a37069d5675ccb002801672aadf4b665395f4068d89cbe939aec78e7c0c94b3ed4c72a75b0ad1722edf631e7e207b2ab71bda6182c954b9e3bfe929201b2e44407366efe4989daa60c6e3fec152be6342176f7df83c975968dc526a584fb15c97fb70ff5d56a76bc288d1ea4c352be4548898c5bc38323b1dc219e5a48de90f2d603800fc131791042324ca57fccd7bc7497493db6cf9627b985ac5b639d8ff04f3866bf53f2f54d28bb03ab831e204ae63878410af12600f053d817140fdafb46e2751b136e410f02a9e66a926f369ff7428d44ef80a702cd82bddf269d2537643b3cf0a9bcf921f5f9628c88b986bef976f45aa085915371846a93b64ad49fdc4e9c41bf1a37bcdf3f9fdc8dd572755fc484b9ebe01e2db25022391daf160f5906f509fc35c41a89c7ee7a609cd7fad275bb89921904ad7060c5b1c53c63e539e7a4a9392c255fa77e092e9fbcb7628aaa02355387aada4cf41f3677b1f43f7268ab4faff483bac053d46694bba8487a901eb98f5dfd6364eea0644e915908bfce5ce7805305866f7062a24a8fc051558335b4c7f788627b6308e33daa88e013b15bdf53202a88fb0e04ef28a92c4964b6e385c65919237ed02612e90f01e200e73847b768cafd7e73afbee7d7caa81751dff864ea94d9856fe7371398a15ceace7d2dc24a12a0d553c8c8e6f5b8cd49358672f6a66f72d49acc568dcc56f2862455153774f3fe09bdc70d4213d65f34e6a3b887effdfb5f63521635c3982c246fa07a86cd4a974ad92f3de0f92fd1323f7315cf1d76684276e783cfbb66843b8279a62f03ea34d995f2886519f39d4a34d1fea693d93ba211fda0663a1ad287aa6f34c5b180cfab115712790ce201645943652acf10d4713a99bc7dd3883895722b70530524171b46c5d36778add990383da4df9e0511b95f5b56d56475175630453b9d9f0c50367e7854a70d00c82681f73006c9757bbb58cdc0c83fa35d366a4ebfb9a5543bf2e5e69ef628468410db91b684adc15a221d4a1c38416a9ed71d9edbfab4d800b0d7ea7f80322b02504d61ca88dca5c839dcc6f31a282282e16c4fee8092883ba81e1bdc68c1314fe540bfe5b84fbb059058d336a07d433e8de61345c3676205e95173acf6f2a984e1cede32b81f0c1926b524a6ed5df9d5622d578942895e35d5c79099326af9991d16259abf9dd178aacef2a3aed65dc01a6873d45c7765c5c1c2e6a5ae7d53d5a8f454871ed33caf96b0560656aaa49bcd40b7c49c0aeed22976cb9c8da0f085d4faa5972ffeaa7efceb2c4629d1368d92fb2f858214afc37d0b1a4d74b5c3b2d0bd2ec5cbc7ffe84458c56fb9f9594b7a736fb4e571d33c53c5996a23a4e49dea4c849a6af4b31dee78827a6450ef225634040f100df6053fe7947f740f32838838df4bd1effca074a8b916e867b2b54b5ba33c7f48a5c813faad1a456880ff625626227db8ef758663d188193ccd36c75432038aacd84fc2aa03fde66b34383061f01e982948ab6e56b563aff453d9e869b77480a62eba498e47d79debda844cdd28c6c5768ef6b8ca778222d16365bd4947c9c8e85ab95c6cfa6bb12facbfaf016d5ed21c72d74c10d93527ec28a7d59524ee09012a403dbda5186914320819bdc9b282f6882807dad3ed37823b33532a7bd05d87105338f11d6457dd4881cbb5dea97cb6ddb2cf19fcce52269133b6386062410ab71c3a460a9ac01cd62e4a9151c62436080ca069f950b7306baa0531e9cbbaad1ec42811cae21792ab91c4ac3007ee3931185f56e8e3ed69db47ac8ff04b334cc637ea559c4b5b64b319bf7f08d11fb09fc43e12c2aae6cd926d0211dc734f5d70895f4e81bb6c2ebeded4f2d800b3942f4a6a2545b55794a74427ff4bf7d8b1058a5f13a0e8d35939596372efcd999c9f44d0fdcd11e88b6a1c803b2e6f592f9465bbe73b44574f6e45359e63025a18c60175029f5e0ed6b022cab93e9997cb47b2349054108c87de8b8f52fa419ae1598da8e2b1b655c7c9263c4ebb79c4292f65078989d9d0a5672fc7bc193f3f19a7c14925445c9144b6cbb27adccfa87e29c3f279684548bfbf9fa3b0053b651c79a49365af5ef3e13fa46a07f9a7d1c4aa737d43c13c3e9af01cc3ff3c11ed887341881ca95c76b251f043f945c08ac3a0293a53351a18e6b78bac05157629667c013553e3806a27f66e9363e83498c75a460930be0037e48b614639bc0f0d1cdb0b92d5433effb2c9a450c2879da4afcbfd16c39cdabca14143c61f520c50e7737a14505e8d94b065f5819134ddaa957366b7a995d2059ad2468e3728ce73313e895c07ff108374a9aba7810eef792e85ba35384c59d9e84e3c80643dfc8ace9d351e05c0a13cbb2b118dc19cf97ddff9eef3ec9262e0b47dc1cf1c9a0c18a4a9f8a81d177f423ce6429219597b37bda9872495c751bb89ffde0c2ea2a88a544723487f96a25138753d714fc92414f024cf7651806930e1cf1e5d75fa2fe4a5a526253dbe12c4fc9610fbd65ef251e27752f22551abcd3c0597d0aab82a24d9114943cebffcb1ebe81573900f156a06c2a08c151ead53a627172fec2abc5091edc9f69fcb36ce06534db361d9acf8e00d309d7ddf98b9f315ea6d8c8634260aef3ec18d360642deecdd4bcd2c0ee2f63b00e1c6cc846f0177d49e5554acff921e4939c14c9daee4f8e8adc6cce05942fb82a7caa5512c3b6194d5e4e655b4c5ea33d64253d2c60479214084ecb20314d7e9215b99a40080c87da0e34004373ca3a8cf8a578c41e6beda1b4dc4fd770b60a65283fc9484b601fcc77842c62fae65d62bac9b45677568b9146d339ae76f3d6240b977b3e83467c0056f4e3b16921103ce78c1238db433532ea0a3f08917b085bd107e91d664d92febbf69e8b5297807a744b49e57307c2b766bf2f96429ca344d56e8a5f02bc5126725f71b50fdfbdd0f131c46a4e6939af1a664cf603434423aa3c6a52838ab7d6c83a981f4ad388deff3c16671c7c3e374191e11e7773183da2de1e38ff22f65bd65d3f9109f17eebcc63d423c5a2d6db46e629c17aba2ad8973b12bd6290fc7d8db694d7602e629d66a34b69d8e9ed61dd9852aa3eab95ebb79e123f0fb8168f6fabc3498cf3818c6461acfefe61d77fe9902b98c908ec7ea624a65a26c42ca10da96386199375a34e598e6053f02c26ad712952965da8388c7d416d0a1286eb94836f6e0f3a0c263e2f7e3121b3685518f41bf4ca115916a32386164298c550fab196a2c0e00ef4025a23e51b590a1f6a7f9483a64e0ed5895d42b15e10da4679013aafed6f3ca189fa707e05ae2888402f2c766942375baaeb62979ec2775f750c0ad98de65e9f035dd744c28fd509a1bcb26705876caeefe7f3809b0ebbf145bd43f037be82c909d7e2b84d4c656c1b50845f0e0384fa214d5e2d0f2451139288b09ca61b4b31bf262217bbfaba2289b3ca294f3b8b437f23887d714e703dea9ecea8cb73ede96840641d77a3604ab0d26dae783074fc7cc58a9861d71ca104824e2c49732cea5aaac080ee7568481d52bc4033fc7d790a59bb797346e3c1a269a99b383149ac72eddc97235f9e1f91f86b2e1d43c682865c9df4ebaaf3a9457a8fff11208eb245c244a605cfeb6f8633ba5e71ec6a21a019604a6ef5f7dd7aa88b232dd77606c52290321ac5e10785858df3550d55b1d10d5678b2f1d27037b62f4887356ec2416e0953d30abd03a912fe5fecc2dfd61be12361033f044dbb1c4683bdcfcfa31bcea3975f8ffa66507af99ca5c29352d112eb106c565f2c872383c0cb34316a563fafbd42cf37ca9492bbb899b7c74e3b6aeb531f504c5eac8c97b96bf2f375e3dd8bfeb590e371c493117c7cb5957853c3042aff222d61a706b3c8e0c1bd0b400e193c0be90b9327fb21b56284a23848c784768b823aeacb4f02f66670f85631d462e8afa0bd0c73bf3d7cf9c746ba6fa83c6f15fb69548eb7fa4358c9b07b92378bc477c5a45c84f69ec066a59d434e0350e8572d94299690864cc2effb503f961902be855c4a53de94c9623d75564580a618b19d315fe421ba35154474f4c1a25191283ded83f43d603fdc1d1ab26d06af5609362f602cb43e284be2c6c420bc2c7ab8e1484f0960490392a0d6e050343f9d7e33a91fa05d5057edcbba1d2506661077aab6344ba1c4dce1affb66ac4a99faf3a206a845b5f6d5ce98829c2d84624f8fb711bfd11f530209dda1f19832719af95b70b4b230ccdcdcd65689543c2e59349ce85c0c1ab55659e42a5bd34a2e41f0d084aaa6b5fd8035cc5c0904727c5fbb335472fcb94313bbe2e9fedac3348acf95108d73e7e5851d406728f6539e3926e62ee86c7f1bb9695bcbba559355576a69924168078918798ab80b404dbf08aa57b73ae92aaccc28ac514dd7f5c51e45f05224b32520ff6aa9dac1ce04b9bd5e2ebb5499d54b98466f6ee7794ccf7cc70dc2efe26a9a6fea3ad7721b06a42754dedb4ee20a4a4ab4dbb4607ec748173e8cba8ce4bca7988043837859363284655b90b587e4a4aa29a047f30b2db04d840eab33b695ff521e02cf9313a2df311aea70fdba3e5d1ab2441238714e6bfb05cdaa39cca554692771367935f496452aaecf7d36b2558ca567cc619224d80e06595210e08e8baac397f77739b50224281aa69a8d7b5ad6dcf6ca81753d8e63292c382fa91459acbf5a822c5a7837f270e9447f4c43f7c678c7ea6b10338bf0aeef24dfe9218ed7d56a4b30186c384e2e230a0001037f2698f9efaa1badbe0ea75fdfe8dad070ca665517cf1501afb9a49da986d2afa024adcd2e87e43406c4ca7bfcef77456e80188f5c491a6f0e232e46b49b4eb8640e3e0d9b7f8eb8ba2b0b3bc8bab2b5de520de903466cf1250608e5fdb63878199783a71947884cc9b0e02c6a2b1e6d986c37a7e97e91a4c6e3202097358d694c43d2d6c43704033416d67860e55f350fe1617a36030a0b41a8571017268a2afe775525df193dd5cf071c42778e1729f13ec04e7a9023980e9d8f75a609b87a4b9d7f3ea1fa3290fbc24ed9bca9cf484ed482b80f5c30d7b07d9bbd32650e57aaaf1c8275c9262abffe6c1920dbd72c897a66e4e7d14af25c6686cd61ad6f650b9e1d77210e94136a061f3a72aa393101814729ae70d6feca665c6b913619d54390c2bff42103b6bd509d048f29dfb5d819bbd13fc28be5e66bece38718dda5fa103c5591210b2f72d780098493399a02c7bbe3680f21936d7fd0bb5d778e5b178058297ee8cf2d06a8ceb650e51563000b0cd799b85476a92660734e143d76f534a4a5a7b7d327c59c0f1985d9d3606c50e88aea75001d43191d0d121f4e375a629cf54928bad96acfd812be8fa9fd1fa1a03071ae5fd5fe55a761c7f4e40abe991ac07e62601b0a4719baf209c5da0b623591d85849bf172dce25aa0a8deec4f7254ace322b83f382f5b98a2c88bf0d242be0bf56b1b9858d8a3644bcbb2a6907b77a84917b9e2a77b5fb209d9d1a51a16e446d3e7d4ca93260b1e51e2de04498ff14423e9e4d976a5692c3250abba7816fd0c8b0ee4c6f04856a52b182171db7b39451c981251b2f09d050e07200d82cd7f986aa0c0da83c87f4dfae8ef2e483632ecdcccfde555425a47db9f31b56e33a4122dfbebd5af64768baef6c0aa132f24545ba6e84195b6c7ad33914c5e3b1bdef5a0247b4cde5f5dd1eace0dcf3382b410d9e8538a6fde1e928ad54f258c1d5565a93570d5b45b0f543b6fb73651d5ef052ed7bab3ab0c4d8a1e577b508d5d54ac82181fae078f75e3855c15d9606fd1552641992338fbace556f34572b4abc5722e8401b70fba3e090cb58fa3f5e9700e5e5e3105b801dea76c8cebdc9c0bfbb04ef101d7f61049b2d0c29771b2c076376ee21cad0dd03125500023f348e1a9c6f04ce9bc5b35884c3363e32b9991ca3ba4302d0837b776590e44efbd861d0819fe059f3fa8e55d8663ea21dc69a509ea65507555fb07d15411580001d19abefca942789dfa4a8192786c982b37052fe3ced7e7e893c6a1885993789823a45f4e5c2b774f3fa430d120f97b28a18e8e9de00f060369ca3738f40b3c7fae00e7ff81b5cca2bca8318a360eeef1269af175f32eed67fdeda7a94afd0cc60dc7e24115223c7f089467982ea7d8f0f4cef335b6d5a908de1b669d71f8e3844ff2679ada99f20d6fa62bee8e65a3e75a3d4ee25d124b269738e789992d2c9ae232fc63f03e126df627221665b5da4ed8b27c964fa4e61cfaaf6a7a5e8c7a23b664b8786181a2c408d76b18240964f24f49830c7d6b89816813891dec604d6c263e8947a7daf932a8d29ab1de2a4b678d97189ca191b1a3c3754344210e800336eb81c037579b2d22068cbd49ebf57caf266f698be34837ea33ae8f47c3c2479660cc3284293160dfd8810f11355b78a51eb812ebb20131867c20492603ae4e8ceeab72b403bc875542a4d31502719513cc383b51d7fceec3e42f1839e89b93c0995acf8da3185d7d78fcbdf0735247b5a0e6092ac6247aaec1444dca06d62f41064aa3bf105b00055db4c977cb6d3904eb46d015b2e76091bbe15f5a9d7a6ad3147031c2645648c34667cd1e6b25a003478bbccf8e3a762f5eec356fb3fc8bf612d9e0ac006d6d080b0a4766a5a3e808e5b07ebce831984040caedbccecda0ff8b9dbae82ab55ccc5950ae043f5df303eef39d7b4d73ab47416603cf85b5d88e80af55790d911b2d6dd17e5ce0a6bbad659b0af41c0f03e625ba062ae0b185b0c4c1c51e8c2579a92897ff1ff1b29ef6d3482f8176363c79967c8350368f3feaa7cd548d24050533bed34e234724e57a8b06a72074f013ce00925bf79f0049cadcaf1fe53baa600b0257f6cf66b8d8e91e6c803853536a619f48ed877dfcd0f0f19909a3b4f1d9315d36739bd590fc2ccb1b441e83375d8d1ffd2f6d4431b14e999790e1e6fcd187220c8b2629d7e9772291bb40c7e5dcbff2558c370c6603f31d648fa62d85900fe951d47f3e721dada0ab16eca431394df2faaac588c4ebe6b642bffe413e9b482869516eed1963c23bd0ca1b7b872cea8b64328b43a33e1fbcba05c496e6f26c1096bfe5f31a8916f7e804a2d8a6dd790c840f3965a4ca395f6f664e003a51f0e3f5195b2190f7955416e43c82dfdd888b8a341ddc5a0593d59254e98230e5e10e7b93417d0b3178e7717a7a0f1fe69c45ab69551be2f5f2a6ad1e2c0e249f1d6a89be2637befb9630da19d9e55bcc2ad1c354a06a7c89f5b803df3ed286b17d57153b49770314a375acb4653454dd0ae771f87ee04b9095fd9dc87bde608f0c38fee258223973dfad5c758cd20567b8e9459438cb27e0a08f582a000631a0e43f45f2964e8cf5bfbd976e0a8a414873ddbed32db6ade61ef0b32dbaf9f26e205332da1f2794db7a05ceda1d43b5d21c1b3a7935ed0c343290b9a052d2007c802cb1dac0da32ab62f4906759d23b8e5351c4cd6cad074f8bc8a251c0028862a950cc807a4032c93d46bd3cbdc00b754f90c1b00b4ed7dd671049a8a555fac70d55215b3e9c951bb38e821e47a85cd6b273d50108f628a1c1936effa637e39777e858349ae9ebc67bab1cc6b766ee8c07b09110a6b9f8eff5cdd1083ed0815d4ff322f1fec8ad8cdf71f10178384ff2482164702c787dd82a631a5b56f8716f035c9b938c6085be73109c9a055770653cc48e145bc1ab7ced89e3f3cb034145c831478d686717ca4d3e02a9bca026c1188cd3588708d87c136144b47f6f55b46423f3e33c7ca4324392574c37a6a597d4082bcfce5ef6854e5d572d706503d4a596814fe4b43c410976ee40dcb6fa0052c3f572f4ca7f6cf2ca3c71d6b183d194e108e58bfb30a44ca0049c52970f0e2b6340351930491280e20fbc2b1a824e3ef35dd61a68d2c0cc0ff42ab5fb1dde915b1246ccfd48abfcca0689a4b0cab4c9e7cdde882c3c6bb2c35ea712628affc68ef2401810ba9531f879a00183e159a898c4abf120254d7c990da2827e1271fc563edf5f70a859ebc0403d4b25e28c86532df588a460ed8e06ca2501974d113875d6ce36206a5d619066287ed64485b1ea3e8353348049a40a9fea6690a0505e9c8851f72446c51fb90000f321611b09042feb128855c98b0778a416f67ce5bcc4a524736c97bc329bc8f61f497e7c85ddd708f88a21bc599610a8a368192a6a110f4fb0d9549b54980b1314a927092fc9a603e6ccb37b79e50af0a6f15d5ab1f1c0795c60a4e9428564cbe485168c928bc45f0489beefcb794dc0678ea0518e190677a3f0935c3521fdb874234bfe0ee021e0071fe2c147ab7e48ac967249fa9e8b61e2eec54b5060e8df0b272099eea3468d8dbb316aec9458b5e0fe94fca0fea394291bf4a04ed8c5d3c1321ce64c9d545a5e18941d388f312a3e656ba5e37ec418b38da1113bfb5e5928d2fd97d423937ab66116730d87a3b78b673964ee223de69a9661d9c8b83e6cab42fa7effccbe9f50ca34a59e77c2b4e88ede02a501d4cf73378bdbf53f0c2e2ae400a6ce60a4dbcbb9bf51c8762f37bfdfafcc7018de024d6e95155a4063f091da2caa73485baab46f0df244902d33a5ecb259f143aa75789ee0399e521dda1546c449935932ebc8bfb1c2c673a4c2d4f4293ad2ccc087469248db3c9ac0a72252f93c223eaeb378902a7df0ba6031c50b577b7e79f0be67e29fa057aecde139312873e9460bdb7dac09a27f2eb183654f4077162a27c3203241c5545ed906bfdbe0d851f43ece6b4de6ef1fdb095f7b5e009cd80b529ca825a67f78d70bca9b689b5a38c688c45385be618aafb2a1954e7581a9fcb73484fd362aea447f16aea21e4ee551acc0d2191eef1341beb78fa7b198ce85b71530d96176312b1a73867ea4cdfe3dd457b8a9bc34d269813439e89765a86c35c191e697a0044aadfc00587aff69d4223a076ec2b4f2f54d8ab882a7177cc016fa62a040753298c2114d91531cf7162d20300ddcba062e339b418952d6e37de89bb8267a5851f15a5cd6c630c7b3a04549c50a0c39244cd86c1fdda66a90c9cb34bdb845b6edc53d459b859784e14cff3a7c0994f3c7c5580466068997a5e7e54e1258f6a40c021a549eb8919a4bc64cbfb285fa73a3a7d103676ff128fa9b467b6d0180b2acff17b01c93708e824bd093b69d2c696789bdb792589449f43cda2a1252f11fd732b628ca4b3dc87989dc835c6b786b5c8d9a8ccd6bf86817e71f76a73425a7aee186af0bf34934c2852bbacce21d18f8de3d33c93958dc03a42ddfb6d55553a7b6f88c8c95ea77281fc1a18533e34c9fe44088c27f4c2a7b5dd62c199d63e5a34dcee123b49226a17aea0b76694175e29d08f772f90440c99ef97c91288131b841e04250e0f3376d3d6b6680114c2314d19e29b08ca2b6f8e15e0157f943d6d0fb1651acf5cc92ea9b1c258f9e98436cfa94f93deaebbb2a66631243cc361ed8283bde9fe0555c7be4d8bcbcc888bc4ace56070ead020c6ad1f6dfea78880f3e097205f78cfee8194b7eacf6c80143bde87474b421c46221d21c6a061a9b390f546c38fc376b6f27683c846b6c6d7e0ac6df56aa364004a92ff09d11fbddfe4926a4c9878c3076b776c4ab11863b66824016367963343cc5e046ec1ff47863f1d9d34bab0d8137b678f4e23873bedfb1f9c64804a21e3b878e9eb9b5848b74a7e9969e0b37bcdb01e28490cd92ef92227f11a315890457a4d9c817f16f951b65e27151b8b53bed717baf4bb756a7752078e0460a85af57e0f6784efc06e951ad016a4b4cf736bc53d91a90aa3e8bf10a0a0c9a90322e1fef2a587a19f126a406727f369c8b440fadcc7459f465a096dd2d8f664d5d677c2be6d950e42cbbfe899e48e0b2e8a575c8715fe359c598b417331d88bf00c6d0e375b444fa75063b21104976fba9d80c0b5f87697a7dae9e2e6d4b8e3904ecd1ce43b68956a88530deecd46855e1a424f447efaff3c13a3f2190f57386d47e2a52659856abe6673f24a1ca9dba2fa665c9321db108f4f06e952578921fb5cbeb800fdea926ddee5bb2478957444d52a5269d78a9de97c6ad467a241881058db94966c8d214d157ce6f8dcb3e2adb7c5ad26280e2f3a462ae67fb973523ed5f0a3be09eff538aa39e7b865b684e5bd445dcaf1b7398d41645d99fd1867cefa5f8cc6b607f9b9af24b13bf8196e81f13a3a53aaf6489153138a84c86d5c92a931dbf53c32d0de4c22c1a45f497dc098e3832be3526251c2f3143784c2a0c369347872be2472fa65b12b3f8163d5334e1fc1ebd3a2fad8a831ec58213fc7f699cfd2401d7708295902f5b044f20f531aad192d8e033848740e6953dc1fc62a663c3a763f9e75caa9be9506cdb0db04ca62ab701b7aee8beec05e96aa813173a888301a3fd5d3cb391e3a99455928a55c5269ef3e48859699ede8985e23b482e0ba0c7c8e7e2be2af7eeca795d6413c5ee892fdc5abaea39fa0aab522c300396a9ebb6915cb6d3fb5c7937b9c68fd0eedca4e11b15ccc762fa08f86e1caa251ba7583f7b7b6f8bbb18d3f43f5723b18087c3b435d1a1d3c458313017c3b3c9d406fefc16a151e44bb3b901d77026a613440c5bf1862c550275aa5cf76489c04e2cd36d5e2e71d26d16c8d81c0190609e4de6b4dc642412d1b345be546d041bdf5e9f7e79ce9b11ca43675d2262494723f5085e73da06287eda948f06607c30e6195bf42d8942eb289f6baa42964bf42e9793de09e9af69a9a503032d19998e2f0ca0e4c3775e48fb48e117b6b3ed4cc38a43e8d739c7a32a2ca889a8c7b0466e4a71d87f4925936dbaf9ecdf5f9da15358a52778ab5f938c23b2542af1c1900bc8a5c4af358b69fe8a1db4783b87dbb2bb5352e89fd36f3fbc7dfff66dd8d96b80dedcbceab59e45415fb0c71f69e21195a154e8a84b94ffac9565fa3dc3d36fe19f940ef82d7dccce213fcb27e41cc9215faf8becb1f39c46d1b02725a7f306ad27c9457b6efa5864f53faa3c675926aeae4456ded194907921f0b65b6500a006cc8cefe23def817928da8efafe499d545c6e9de7d08665ab58422c728d20389417e4a806afcad76eee7120816c98a121c9cb74c740b90753e14c5ea6bf98f517b1cb8af750ced55cb45bdba39d64148277ac913d21dfec0ad028cb1547019cc9c7ae1d112510688ee865f5735140a364f5782637c0c02b455540873f4e5231097ceb9b2a4c061349a8a5f389b971b6b509c8b3d0c2e6a2c27b3f91cbdf26ba959a482c27890aee59ce0935c03f7c4bc4d020420034abdb2cffc306c9716cd1c72d9f354aa6f9f1df81f4f946e1f40cad39982d571163371072a9c637884c0e421052f464fa22b7df1f12d5f94b6cc0b64f9ef49d36865d295734730e8dbe68fe8a8c37db3aa94bbc7cd7837b058663bdbc22d522ed0d0d55f08155232b315ff78435008652deeb7c5a68d5267438de0c830b7b992c886f348f62ba6fac855059e6be6309134fc165b373bfb0e6cd90ec273df0aa4ff6a0c5e2341ad2d372c5abd7315c3755707330cb2c45c338350012fc480918fc082fb3ee993427fc0caaf760629c9177a903a8af3705a390419e09829f7d53e8f569ec053462327169f78222d0497a2401d0f31f4e9340e5212c52edc8657ef57bdb5be40ae69f3dad632cecb926d929c2a8b1c5010d4036adde807947d4e608ba977c2206ea25888e4b38acab00a8037d4c1ccc08bd99dc86e48b69499b7168b9fae383902a72c21db1f130701eeb3bc40489aab649b9be6263a7640318516844d71e11aa33519e56da8d79c3f084f57f630f00f1f4b220042fdc1be03b62f12d6b4d7f0943add1a22882365b52f13987a5f630218241d725b7c7ae2f905d16634ae386abc7662dba8b029763720de4d3fb38fe743da20a087634a5fb94b179f3e86ec03d0f207dd5d6e6dae25a233d6735c959e92d566794e4c7bff5ac965e279c161b684955023e91e0f7a8ffa24c6bafcf777caf04c4e64a9746918adb920f18c3605bc320392941a632e959a0258222c2463daefb20d36c24edebd10e4d200985daeb9116d1ddfdfaffd0b14c67841ada753662422c8891a6e38da88b5acae13119c2bdbe478e37c942e0500f1c7a3b5ddb92e4e76d3daa0cc46cc11ed92eb0061aed5d543d043d236e8a53bef8781c67e09f6db7473b8086e03e552e4c4342a2d087bc80d230411a36c3ed4caf502a2c6b0611f98808b1ebffd01d1e76e29281e3df4ffaae015ac9abaed87305b4605488ca2528e285a3645ed4bccb2afee5f9dd83ed520416d6a824bbeea34bce69a0018d103543759daa6516fb3e9ccca1af0a2a0b6ace57317fba5a907f71335ce62700d4ec9b4e4b4d0c4f84746b4a040d5276d969cb29f2b8e34b716356664b27d9a17c0af373d4326ef63247338cfe548667ce87d3d01c5b215460a73105a6840872c3b5554f9d31a56fd10bf1f188d3f799998209be4657b2d8b9870a59b959b4fe3d1a61430fc8f5033ac12f11a5abde57fe93aa235f8a331fac9d5af00be1ae13560047fb72c135467e181ad87622e9a87fa3154ac2a8fd26e4d266a4600a2671404970eeb857318ff4f5a998b6661c17951cef48f189666be7902fbcce4c4e1d9126b5d41cdbe7e35fb0f9c8d03f65f883a4727de0209c7dbf816cc6750f29b8cc075ed3c4e3d09089f511f5ddfaf8be0317550824ae64462595dcacb818054db917ce470d8b4f4c7db751306ef3178693684cd976547ef371388197cd66592845db38baf26a9d6c93c0d53c17b15f28c332325b3a5361ed9c217cb23345812964f1a2f4fc7da250c150fda006164c75ecfa30e916f760485eff2f694e382eef3cfe056b8bf7e6d020b32b490b3f89b548bb6173e5211b129ef5c76349d0147ba0d3b7280250edd3e95ddcf03cad51baad9999234db713e7c78a9c9ad42d1c1c2975e1c43d3c115c3b329c6b941288b1cbf7054e3c30df0c662b1eed096d575fa486d96b513cc811aa148c55f2cb45f34e47238f61488ef3afdfbc67aba9a15fe1d28a6e1335064ad24d53dbb7f17e4ec7e4deebb1fc47ec0a40654ddbc9d8d556455ae2ca67445eb2c0d5edbf9bd3d2108e1827adf854ea844a8461066983da20033b01557e50afff710869e099beebff324b999fa6c31b7237299ba7c15733c5e4b9dfc72c68270d55c15df127b626800cac3df0c9c7b6dd76903b063f26a7d5387edad131d948ac0f51b4434f14bdcdfb105fdae7038f12e9392cc6d0e650660b0d48c426772248f8129e1b9a2301df5cbe95e79e55bfb493299ec7f98e5761f11e4ad5296318dafdd180444c0d33a328302bbcfd95a99467a5be4e53c34a0b4d083342ca76cbe0d090eea334560a39e32c4887d2cc609d2009add1deb6231dcc4fd5270dec1550fe897ac66fc72836498a34a943c5c0880dae76b3d5d8cce76580659a3443884f2a8e0a7fd65005483e73a3fff2a1a8fe6d70eba770d5579f07e5b2eeb7344631cfade28b6212a4f2c09c51e48eb9deec6284cb997c1a728cf57c913167345e504ee07044c2d1682cc5f692377e560d0ecc895ef8da1737004c386b043b6469b08af6c8719a9267be6c76ed51ba59771d69651650355bc776d8b40baa2477f5a0a608aaa485027ae391642b0795aff3bd87e58bf137cb093bfa38fd9b9ee54042637b34e33745e3e6284104fcabbb5308ddd1124467643c14e6ee4aded7980c4d89cc23b951e6da2eff440f4b34520314edc26a93fde43c1beedd196d79c8c73b94616cc3d60c58da4ff9dfa92156d23af3234e079e9e56bc9d628caa74be32a1fe12d38c260864ecc2a06f2ebd0132aacd4e1db99f6121e4e37d4a7bec2b97f7768d81384b3fcf3234d632c7c510b2a7292b4d9574607b647f642d63bdce3a0ceba386e66b2885e545cdca6a9e9ed122f157bca366c4d0023ae711a22c90be614657e07a19414f01db74993204f8bb135521f8ece55af763e082c298d6dcb41ebd527c1fb4b8b1ae1fe087810e42d059afc1fbf8c135644c01c95315b2381acc6f7557f0285ce2edc782cb9dd26dc6cc1e06630eef2f6f744f6a206ce790e94cf069f98c6a8e9997269542259d9b02dca0d71bc4c056661252be499b3b3a1ca0c86809d114e584493e0a33258de5fa62f84e2c8c9dcdfd6a1bd846d932949de33cc755d2f52714b355d81300ae40a54d7c9470e5d1d8520a3e99c834910ca26236691d5c1299516598ec073f0942da7c4c468975911c6d67e370daa323d59ae4c6350a7897d887a097060ec9e7133973486edd06370ce4146b84425df73c5efd6067e6ed59f8fe62984e5a5c5cdf083a400e129f70c6d688795a1826b9e9a4817f202ac04dbb013e09faaf11f1c80a9dae678a3acca9ee1907fca6fc500a72ede3f2a00681cf29dbf1fcc7b635578d869f2001b1ad47f78147abd55effc2e55fd04f34bca6d716a74289dcd94ae61d56145f06eaf5f18af292b6170664ddd2c634a2101eda240b7c33eedd9eb17619b37a0d89d532ff414d4dc34fc1599d689d5c7edfdc0abe047da2f1b4c89cb54cf767f8fe1585c4c399355f98c1110769905736acb356f3fa077c02689e318bd82e8b6dcbea824c8a4d0586ceb320972b29fa0b2c54db3cadaab61d0677992355a8b308ff46854e6ba975ed3706cae77deff8e122d2dba94ada93c92c821474905f9edc791abce3cba19629702cf52ea6d731d9c9c2a0f12a083218976db917a594d5a3e7461f521e24f5b0f136d92039391573fd53183956d50c637e3de4377edd6b6f69caadeb4a546479f8f26a5852eb1002ae2c2ff0e84750b190459045b3096f9623516eb3d98a1f76c71830a3eb1061b7e3539c7b4865eca0dd44b5aef7fefa6714d9e7f3c51b5d2b7d3c109435765b57c47d467dd699b5ac1de4f4985c3998410df56332772d41016a314f9e41d5977bdada378621d9b97c8b3a29a9a575b125c9e473c5e6d59cc6d60b7073c475173402dbfaee9c815c6fd7549da69e477bf206e357e8ea8cf1680a54a8bb29ff6f0d156a1594a6eacad12788d151138a4d49284798787ce4275680a86430da16c2962a5264de049944d7de616339777626fea3b2ff2c80d9e41c1472c1a823b4aec77033725986f1b9f31d487c147764b6314707284cd996bdf080952c35dc2f85c671550812c11cff055d9744cadd587480cf222cbee2e056fce8df8e78af19ee9cf4406bf58eceb634b7aa29f27988fbf2ca0a5d295980d5e9444f1e9b7759ee3cbca7508525baaf4707bda51b103696fd89befdde0c84e4429161d15c953daf157aeea3ecfbe72faf3f684728c05356f8523a87ef6c1a784e88c6fa07ba95373a1c1384b291e0f386f54e50626f38465f441fb4dba558abc22e04fe650b1fb861e03d4f4dae894437c2a9c0d409147482f06037394c7d038e94d9861cd856eb5289357f0ccd274bef38157b66137a8e65d58987faaea066833c2333ff7d873824e63a0f80effa85336ab68738200df55df49b84c68d5bbc6694c588fc2e79f61811d9028dd816e9ee3eebdcb78b143e47028a77e7da17caed35110357b0386588ec72e44b19e2815f0aac19fc0ecc5e82188663b4cd8b7f0dcaa5971d9c9e316fdb352c70cbec44c7228666926d0aea2ab1c06fcfddf1768392ae0ebfc0f886b0b2c88fc7c613b69ff1382b18f821766a66b3530f1ec822ee2ea5fa763c65b78593c20b950e85b87921bf0edee4efd271248cab4c75ec1155e1b78960e7d6c14df0bd42b9ca1110ece396467f9f4574e3bd44460a0641307af042fe6805d38957f0d9dc1953313f6821dbf6d42d4e4df882910b04d56e71693137f9afa7ddcb2851f6ddf2ae59475b67ad6720073d56e3525ea95e76e1c69acf27f55158de6499d607c3d033063f8ae627e1fa0c9cd262cd0805d3e684ace013518ea622b91f73dfaa715ec576e8d493acfe0802c77d15d8547cd686678f84daa83a63e64821c9516e1e79ecb731020669974be9b3db08e36c669f830be6bfc3cbdff787c64378fe8117ad8b01fad475b474a5f671bbcdf9d35be232ad01e526faf8f19cb50329b78661431140c198acb28a29ea373a552155b5248e9824bea1cf419e2258258c75da8227ac8ba5a37c8c56770b863d31de2149f4ee475c24354228f3f8ba56146992c2320e6ca8c9481606597217bbb8d09c0b6582d5cc4f186537e8747c9309be661ee47651fe45f5a5b854a578792e83105dd5e47099aecaeda97d282e1e295728430a6ebbf0df1a59fb6bb81a3f08825218e363d1d18c6c16458b5a3f70c5d4e7b3937e47465430cc11ece4ac1109bc936b84e7086e01e1673a80bddc7a1139b9f93b780dfd3b1277ea719d631a9d131705fc042f336e1f1cb833110b1ede8eb64b60b65f81e942a0b6b8aca7c393719f37897d963b35e54c41c8051d789789fffaba6e4f2fe00a3b8374064d4858d8a77b4de2c2a7b4a6ff653543317721d40f878c3d93eb5dd58f839c91ca3010013a70c67b49b365c6f63022728e66b10aa8d418e83617d82cc853863e9704b3e1f8619c5e7c86d732449b86d64c8d33e187990a91c4710e3b2ae407026e5be8d2e937d59133a22a6cd36758b82d1ec7854b74f7f99c5bfe4473079cecdf610ba365c05577a8cf3041cffffb7564824994b6bca59c81464e2dcf01f9590bfa3904aad9a7c896401112194edf447043c33b251f1db58609989907dde1208a2cf5bfcafdc8ed4d7b4ad688f98a1c6a7ddd1ac311a45644c52bf28d50b70b89c80f2338679fcac22fa87360dc7df68b1bb1285877eb4e9e3e57b247a3a61e3fb8415942db964ea1cb4b4a51c439f6643141b755d9ff9a1f3be08487cdf9eb0c11c478b2c68d4f9b29d1922afd8982df1644df2200cefedaa3b4a263b3c718d4e90bc0ec9abbf505a558c33cc1d9eef16d1283191bf0e7c4a74e78aa7983adc0637a8509572d81ee6f8d3b81d33f76a55fdb2c03cb547628b92bd6a4274726e0d0789efdb21ab7f6f9378b5faf88a78405be47f31cbc4aec82b1d9ba1a5e3355e873d858df097df199c3d8af8450d7e66b7415224aa4831ec09b7b6de631dd65e3ccdf25084b01596f092b8c405e1e0e5d75446c82cc0a836381e7dfdcd78d15d863302444c01a50260853a8514c6116148370ba4c8ee8a7a098d23a5735c029014458525e64fa1b1dc2ef1345bfda94c91cffb3c12de43b0ef59e4bd45c1043f257f4b689ec70b1591a78d0253ae8ff3f9d58dcdd3846b72715945df8dfe89d19088a44a356b5e40841b2dc6d1c7b6a0a84fdcc3bd33ad2256a889cca3acd98758def14befc182baa92f2f2252c4028c14d0faf92a2d4ac3aea4e6cff0eda8ba67305ea254eda9a7b76bd6571f14b7008619949f1d061918259dd310ddc4acab6968fd1629a8592038a636ed26479538d45363e6e28b404f570e2014d5a2f9f193def9ce71a4ee11a2fc568a68ad0e86a3e19401cc10b75a2708ca638f6d33dc0d3395ee7e1841d522ff60c8269f97b0ac9ea3f2500abd6be086961e521d8b95f38da4b16d6f467bf5a16389e0441e28ce72eebfc5ae9015bfd149418e2bd2a15ef57ec087ac2bd0f34e3c2fd80529eeb309ee4326a683e46a95a23cb60ea969e7274912cccd6e249fdf216d060ec6235876e359de37809d6a61981685339b824abd433b32d88a62c5fa68b48b8d69e16f052894560c624d347819595854a94de5ea30115ae7d933128c22203c62ef243c2d1b871796acfa81861b309610fc925b66c8c0fd02d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
