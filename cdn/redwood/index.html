<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd82c10e86c0287fea7799faec0ae95699777da21b5a12eac96eee58d2bcce7710984e92cda115c3bb91887bd63feab0b5c7d20826dfa8b210cea55ffeab606b2bcdb3d1a4fb0a09ba602a3868d73092875f5826338de14d0e3632eb037a92f304346ce2ea7e0b46989714a84e27d86f8f0d3517716884566fb57612232a4ae99410cd2fdf812a9e4c53233406306c4ea7c9279770decefab6985fc47113aa8fa1db4b97420c74ddff331d8931a604640a514d84b35fe86a815a260c41092a604f642f0b0a8a267cc8f47f6462485b9433ce5bf8c186bd32bea8cac144a631ffb0378b9eba0c7f11593535e1580aa9282f348ac2e74a40ce785916691c70c87334443eefb738995ef8ef3d2eef003dc97f20c8a2930ca7e840512ed48d6ed000748ac137a134bafeb3f3bb696432fb096c7594e056b3f9ee54b052fdffefed44d20951499ecd3dfd8acb4402a5388a7ca2f640cceccf388de54e7ab0e933ef5b8e9eb2ea2fb55ce14555ee066368c27700cce5d7a2745e9c959d985b6d88f1fae2021ef00718617ccc0bc2e1c8b132fc5d5d1f41aee49d2e120cc37948b4b8164de98981baf8db520ab15d963e24868caba1d3e6fa06ca001121f7d918accc73c3ce3db8f1e5486fdddabef9a44bcc2ec7b3cb0edecbf23b2d15d3b88d7bad28c16aeeaf4739a9ce0de9614ba5fbe55fcf87a6585a57643deb2f20d9bb8b7acfb1c011383b9f395ef6a8127626cd0010eef16cac9ccb8697eb76d14186979a62db0a3335b07cfff457c61117a139f5421e0374382b8da4fdabdba1b502f77d2ee53ae8504ca96f4df72a6a1a9bee6a7dc39cbb13a8149afc0e5a17b0c0ec2a9380c99dfd6b5fc4095015e16b9771d95b795b3044e64858994a7159b67c5f7defa6e43e2049537b9b7edfc0dadb4b09d1e812c89c208b89a30d260a69a0a779b6221e9645faea4a2e483ed5f9abfa2f5c69c53e7a588c3f40db255163ee9a2968d684c987d26427e40bb297f0d0636502af3665b81afd49c5059f6cfef720cf801ee7479971e85c209bcaa1e315f78ad196683d993fd530ccb762c71e76024827be319ee6e7a5216e8c65c14f7301989b809cdc8a1e217c10d1b3ce01c27949fb0d8dbe79f74192c6037262414aa243f8f6b7986edfa24fa38c9c5ddd36d0f2ad509fd6d55deb9e9d05a2790cab3aefa1d8fd3b83bde8311d915c3dc565098ec052cc0f63a42354b390c2e435850b47501d60dac3e04f3de4e44cd3bd4a7906830b226cb189c809b769295e0a440eed4d7a4be5afc2918ddc15c2244c68b37511e26925c28f2ca05c1d0c3c01d059107646590aabd3630ba4297e7931dc6094f78819130695b768459e79dc7150760ff6eb5eb10aa9da884b4849606d7839658ea34d9cc506efde35f63df965175b5528eeaec61a9bb335eebc424779a941babc161824df11564904bdf5c6ef6d7b95c5b8da58eb358ef06072c32254e8c8e36a445db094596e8d3018d7f92400d4b8915fc2178efb7b887c04c0ae081d1170215a7741434c6581f5360c1145e5dadea70352a71e178f61ec9c48e2cc57f29a1e42cbc5d6bb3fb3ac9720aa2d03dfd65badc758a2b936e1f96ffe4302bf52bab685666eb8dfee22b1dd6f0157c41d49a5cd7b0cf8a0fee8f533dfd71f49f9c342a161c1f75c929b87be9e7d02966125cae8258ebd409152279603936daf448004f7df9fb4cbb1b502c2af4bf824d615178f6f3e02570cfd3a0b1e6919a4721831347a5031019ade1ab9f0e337fc2e021e3a87a1648c41f32d839c180080e6781b7fdc300b337423c4c115d8d636b0b3482e0d4fc92ae7218e9787d86292a956456427b58903e76537052a8d7cc242e92ccbebf0da46264bda245d07eeace02bb04a5963d78a445c8cafa7e4a61f630be372a01c00fe4d83d40792a139f04286be69ce3186aa08203fbc54cd77465e230a704683ae532471a9489ede5fd5b75046229bf13a69a88e3eb0d51c4f92154e925a4fea375807f7cee074bc8cd0d31661be4c546f5b283770c844d9b3bf7bfdcf6a70799615194bccfb629ee0553d5840e142b45f4e6580c918af38f4ac250eae3c7c0504ec3970ce9a421f287929da92f53270f6915a90ba4efd27bac3a43007ea291ce7e670783b197fc018843cad3826ad7ef472bfa1b902f44fdaaed6fea5db246a919d9a39c23d92a523d110394ff9169f559a0e328116e04f3036ff2986a6091a9657670a2d87f497defcd7565ad5a84f857d410e9ab5bc10659b199ba7fbcf3bcb786e3e128b7038448b3f9bf4ea3864a23057b1ee6be6eaa0b2f4a1ef03221cd238ad280273c49d4f2b9fe092c7cb7eff27c1d4608f6564f769db7729a7fe6d43819ddd6b159dfb272d287229f59e61e8b56b34a114f0eb7bdd80e65a836d4fcf01d9b6aa05e8c082b99eb1baa3777886810a96332f93e4a9c8d3fd34b665dede7890f61460036f0bba9806921b4e6ac4e532ffa3e4083dc2a60b8019fcf166c3b594c9a75b240d18ab898da4fff643a6487819aa139b003d89cf1cdf1d6b97408345ea4382147903ce71fd53716657788e15841ce31b4ca95be433dbd38c192c8351427d93e32aabfc638077a1e5de69b617fcc03d18d07df6061e272234b87438c27561b1bfce41bd38f794022468e6e854dd64539d20862c7aacf58dd1e87998e81acddaca1ac2a8d057605aadb2d3c93c44f64b0a005724de5b2e5fc572257db67a9499e0fd43c70393e28016db92e51473eeb734135711908ae05291c98961fa83d76494be51336ede3baed68935c8c8226841fea86f5d246c645bde3ba07a6f85adc01aa30529165ed3ef46ace245c08aabaf65e6c6fdc1ec95b1bd10db827c797fa0bf24b566839b575d849df905533bfc7cad146b3bb4ca66fc7234de555ca10a252887972cf386555216d1edc80af962bc3178610e68e11a9bcf3053b5b69673e4e5aa26630ce18f7942eaca9b36416fd1efc1368d5054ccb9b7b637ba9363e7f1e45c849d9969bfb371be64b7fc672f8a4eda391384f71762a83ed77ecc91f17f64641e941c8443d0ed15524045b35c68fbfa361085f436f7e1cd630ffb77fde96d726f1d0977609ce4b4bf7e34ef3e4431526862508e7b13f2ca3d48e86ae9064fe717a93f6373f774134b28d150b8804f0a8c0536194eaebfd293b53896c38dda9b825ad60f097310ae75385362db2df3f058c8f77ee7c14c074bbf85ccbd4d2acae58cc9b813a1eaa59a6b00ab809d34b4b9816c76b3134944d779e40410f0d7497bc9c9fb60013ea29eb6661104addbbea6dbb2c4ca3fac80fdabc2318bde3f6f418d40afee876e56774951cb58ebb1f1894b56f27e7d2aa5085320046b76e40f0474074c0d3f6ee9adcc5796e8bc2d6cd4731a6c3d99cea7e8f30490433414d9479421c3cbaf9071f0b48490ee8a15b685f14ba4271ba4eb15f82a2102c743a0dc162de46ccf898bce3b9adc1539ab20804a4ff6eb5e5a43d61c7fc6900f6396c226e9d37be376a7685a6488136a6a974b1da017fa34fe286ac344c2c67afeffaf9193c2acb5bd22221d9ade22c0cf6f1b265a87c1904c8ca5e437eede00e765514fd0d8e90b59785dfc087c701cdd1ffd1d23fdedab12fa347a2f4c30db222a48a65fe265b84c2a822c97965208c7151a784fd93696de3c533d8f60bdd75fffe7b19f612e8601bab4b98992148ae4c48f6ecfd17d5c9448ab503df0e9d3030e1130699722ae0f57400dc49c89b7d4788d4aa45bd4d44e5eef45094d122ef399be4ebda65acb6fa4ded125546030c31dd48982fec64458197da3514047aa573082874308d3e09854689bbeffa2e23087612323a314437a8adde51ca3842112461e4e70c784d75d921af3c38b7fb8c58a0e85631332e1ffc06c7f32d013066ae34357db1a1562dc5ab60f968360fc5ee5f062c64f9d37360476b703126870a385681de5cb58989ec7d607a1e38cf4461350a9aba8442f2c827f6489ef9a3a000a8115e92a074624269a331a0669e83bb63199833eda4f9266e4b4d28cd36f10145cca34a5c29ee3512246a42c1c0d469674034b10174388b09f0b7b49908413fb28b9d149ebf3d10aa2e278dbb061829d1ee677c65285fbb24c1d69ccdbb7d17e4d04fc1b393d79d57bb13134fd1c45b3bd2587dc50799e435ed006448bf72b89d9b66066ffbd8057cb5cbd59296993164b961e7858e9953a46903f94a5821b1656710d759c5615181e595d972fbeac10983fb02071f02e2ce4a36de7da631f3c038fa6d30d00232736e8f91217451ab9856da0fc394f6eecbf8034037c4b22a2ebfc43bf52567537ed406a0a9aecd5895b4625905db73db9109287371589124459c304d3d51272bcd62240753915a2f0581fe82498ad769c9f3f07e898273e9c5cbd66d187a3a4e387270794957c6df3a95da0c744e1e047689be1ee0cdc6d972eafd5abcb7357dfde8d96b5a7e04c1ef9b344165ddbf1c9a769e4d869777fdca85d28e4c66696da2af3720b29d9e7ac18d450d1bee6a341d2314f62b7cda798ac122d35350b09a4865b23d66e2dadebe6b6236f469dcca5b9ee249b84e69aabb4b41edb5b8b2c1b7c4d6df6260fb3c8d708e862077fa6ae06eb9b187f24d304dfd9b14302b18e58879a0c46598da8455947c07d2e62dda1c10de654e73926c9b7f61643897d29889f45ca4ec4c9fde3d3973bdea56d041fe49ec99d93d32dbdaef08f0f525a768b760b7baaa4959a94c1cf38ebbb7671ffe11edb41fc55b98f30abf8a736f2e2bc865b13d8b859bba7fb83eaec59fb346dce0e3deb5ca053b220e4e137729fc97211cb53fed3cc8e91ddf00bad5a7a7f3b0ba20826a99a85d5cd628a2ad3777670b0caa65f500944c85f757ff2c222c0dba80e82a4dd7fb3dec8d998d0fff4ec3dc250e776ec08d768125cf528d291e61f535bf6133bb0dcd58cc01d78b76af0eb6bc1ed54961faab8b3f6d1ee77842604308e81626984f547ee3388167d9bd7cd19b376505ba286b0c0aa522c02c4bdab2b37e4bc17bbda010924bd827f4be1669a25e95f0dfba2c1ec815c568ae031609373af12ba9a1be2ae9ef607b92bf5d32ab51bba020c9d0dacd4c19c4f3a9d2036721e3a6537c5434e141cf409d6c6fbc00d3c72ef7045dc734c14ea45f2cfd2ad7dcf1bc4fd516ba420a9ed660781be60e682d1b577ec7ad012dc8f3b661383806f35f965fbc245845a221eb8ca597e23139665890347da01cca50aab50109f35214b6cfa64f36b5fd635990777a20ff1a17e1dcbe7aee75a892b17eb411adfc619dca0aaa6778b5761526e55b1857b1ea01a9f3686bcebe0afb66e24504bf6f7673722846c001af296f322f783a4a03a084599d867512cbd8dc92bd692d6a4cef22eba2b66ddc02cd486e938886c4db6174375275fde654133e9cc3ceea3c75c735ea8d6f7e35411c615b13bd957ccfae48fb68e0be6984c96486e6c8f03ae91fe103a07a72aa0b31e921825475ed7568d939d203349c54cca3a6cd9f1e86aca433843a115c45d32bcb840b55131bfb0bd9044944f4d11df4ee3c20c4887e5b0200f50ea8d665e4d45bca7ae15bd01d858c68228938628403cef390842918e24260689664dde1493a18eabd70b7706dff71a7225ace31bd75f1f84ce8f0812f07a164377adaab4bb3c0a5620534bd56e3112d9924057ca31db15db510766ace2a15af1f44a14794b5a6cd4aace8dbb417e1348467db1076cd7e16df86e6d6d4b53a36fa9fc02f76009edc594c3997ee98124179ffb89a89a1a4b81c03a86636a2c0801e67f568f37bff9ee6095835fd160d7dbf4793abe17455dfe4986fd3afbc45cce1a08a560ab5362e4c8944697bea4fa77ab91f6a8d56771a0c0ad276d367fab3aff02c765508a9f11cc8fc74d0fa4b60aa9233755888f022b24f8ea2b9c53917a209495c8b4f0f188f30b3521498f8aef37cc84755c5463fcd7e6f8758fce1318835226f1bb32a6944e2a7a33488c2f45105c8d900d0811c9bf991404635a5c66336ff3a4c50534ccc4238fa150d99fecaf36312046eb4aef6b68fdfe9f3d4bcd5af244f8adccf62aacd6a0879bbb7166c69a5b7a5058a4a8804537122151c563987f5f9bbd0dcb73903e943b6941bfa55fba3758ceb7c0f18758a497de1c0eb039f043bf794872876274cea0c1c19b989bd58985b867b4451186928302394af22ab2ed51e75486e2ea202d9edd3895c92d7737c4eb15958b850c8351f8ea8461beb76503fcafffc723f25ad9392fa2fd2b3f0cf13c59288355a21131b422823d7dfef84c0372cefb7bdeda263fc98e2dafbd8d6d810a784ca22f492dded27ef83891ccf092e4639bf31e850dec851ed2dd3e97b530dfe8a62d41ecfd0e6f5e353cbad5aac25f7f24136c13cdb0ec57a6ba2797888e0186e6884add3e914d027aadf91faca91ee81641f0988ce65c4df138b3d84b9e4f6d439dca5f56dbbf8820ce999093209c523111860d98fea0d886d9570e34d934177ecdbfb88c23363a03507ce7330ed7451da6f48bf9b4295fa20dbc1436e44248e0d52770b80e5a450349828d459ec6fb2af10443e6f2c788bcb60fe82416a37b44c77ab2b743104141c046a20ea2288948082419696b2dea58bea79540cdde10206caf08bc4c81b5727c2b27cc93161d7eeb1a6f043f020e1d3a090ec9e08a136648a74b391ae2844bc68cf01bbeb0cb6de40f94e5b22873fe7659d2a3e3604af94a10a19f1efa5a22da000bc22b01fc430ebb12ac2b113007b1a4ae84ae9bcc4c270e06622c7c75452c2b6b8796cd76541d46aef04741b1a280cd19ca2545e17839161597a5d63205511f0266facf82705cf5ab478412a3c6c5542141888169d3a1712166143e7530021a043c08beb3466b15158d36af5f95f97c0a3f02cc5b068fb4e725d7fdaa576f25be541ceddf37bb72b505beb25e6ca8c78306f3d3c557be2bdda3c4c4ef8edd66484a3b4f4e0a352ab827dfa22a5fce8b325ca7f2baa7eb1232832789edf67fcbbdd0307b629c7ec5ec5e3ffcb169a4582220bf0525f9b8c609deefe5ab8dd1bb8c4962029434552514c2f75326e8c6259491c3c78dfd525ed09d3a678ad9111193ac23bf39d7e24eb43278f5ad704999334518e30e999e293d5aa75d2b33114e83c9cd6d5ab56463c631e7895d4853436d16f019169874bd0dcf363b231a7a33b2924c9608f50aeeb1fa079d620216fdaa9b78ee36dc7cec51a8284cc9e68c84f0a8d777a388353844ffa27bee40656516335774e51bae884677bf526d2009328ed40e58cec7dce4b6b88fa8708a39bf6cb2f3799ae294b76cbfe715b6cf3d8fd27b943f77eb6ddd3bec997f0ad290a4d94c6557f65177c028a47d98af595b94b80b35cdd434e0fa5c41c4a6ad734cc3c98991cfd92f211151758ea1945b53389e0cd4f62b003cf324c56e9bf1f853da749478494113bf338d0d5e0bbf38ba4a1c2ee2c4320f8dc50752cb7ca19b84a9c142444c98fd7f42716459b51fba91003ce642cbd9212c1a7bd3b3dbc45acf7a4f1786d3ca145cf47395094584633871ffbb5748aaace62fc2cf891ad3bacae911f93f76bb644b3c7b5dd7dc6fa931fd3c2624f63f842a98228f540d0580fcefe649c47d30a64d22486e903d8bf644217cba7e38826e2274a3154c4f0cf9ed818db2cb526dda26bde49dc8246734dc71eed75eb7f96bf3d884c0d32de4732ec9837d630bf032156a935a35d6c7bb011016a948aa88644a7a0fad1ad6ffabbfc03cfdadeab93c078fb8b49f2b938cf81bda68c987b8eab4b9377f56bbe74449af9bda8970144317669101ff6206bc9ad9100b8cb780f1a7e920b8e42fb65c992437b9b127093b435abcb998aba2c6713efd0fdd5ad2595061c7ada6e16e0cac3e8a378014511e9cd3f1f3e89355f4fdfbabf08dd1bfa11eb0f908df321e198cad9ead49d75a5f5ab973cfd9b1b50997d7e1f7d4dfd6a3c92c9831ed36318bda4dc20530724afa2ff233e6d7abde065e3d74e836a1770ec63ba748dc40e590e50f177843611db0403d5c59de158634293393f775c8e554c3e08a5dc31ff64ec8055af203442b9d6973d48dee6df77b69167fb9b433519e7b9d136b692067ebd1bfdd810d033d7c2f4658e795c3ae5924ec048841141b04bdc58a546e09875d3416be2f350003fb51ca013b6076ce2e6c518d420bf6f1176609ac6283dca4c90d66edebeeb8fdbd9b4fa5a6a3ec6b39d3493d8c66d2730afa11f9ca0d9505d4e7b54202869905a3f83008601154fc588605f662cef992cc41acfd25c3804d514e8a9dce0906c615ad4bf6f267033596adbf5e2e6e7514561e0a7910a89f4fe5913e226f393baed8ffc1bc96b493cbdb6eed289710e17318631633e32e0b108f6f86e40f11399e0ee22bb0fa1e71a5a7cf69cd8f9b0bdd9301ee5dd2b3973546231372be31c6a9432d2612fb1d1d4c4eeaa37ee7dd93f64ed9c73026e65e07c2bcda2310dbf4a8cc1cd5786e4b57aec3d02d50d9635172daf2cee8b5dd7fddf0a5b463bd630f6c1942555e29c9524f0f1449c0d3eb5fb1d4fcda920ba1ce5823f27b8aac65149f0403808fc326f852b74f97dca66ee8837f1e5d34aee1df172555ef53a8b657c968df9a85f42f82b013f8fb45bede561677da066f938b1d6d5004ef4a1d27306e43e5b39c4338b43745184feaa8fcd0f09bd7a3b4e8aed85e2374df73ce98ffb5a0a6ba17f6ac605f51c9ad69f46e74f77b3c3c45c2b11200cfd38a28c00dd01a424e3ada18186f64524ad9aba2eb2373c706a605e012971e081ce4991203545f5c7d806128fa2bfe62898bde077449235416a4a06b5c77d5c3caeeb5163bcff5e6d2d6589490249778e11df17588d688c218207155ad75c345e913f910628481b0d497e97602f36926afed1249a078c8a5ec8b384771c0d6501848bbc649cb8bfb662634921d8997096925937309b76e50e38a373f42f07b07b8d82c2d4cddf4034a9b440ae3a8d89444f949515805663be263eee8880ef3365416daa32e03ab6990521ada83b8db3c7f77b71bffea5704b60afb273dc563aabb3fb28b91a6032d9ef533b010e497885b81834372eca22c8fe4007b6d9e8ef54d83c5b6094b0e00cf176daa3530e156188214f74bc970ee644a49097a12a5683ca63024721d5883ffeb5277e4df14785324d65c07ec4b924306ad91280b18cff739f54774fea6cf153a8a52046c902ef01a385d341e1520bf4c883988215b6e295ae5a3e704e203fc2e75530eb7aa609cfe48a67614f8cdeade0480395882167e10aeb01a95f32781af7cff1da343a43c1e09e4132fa320e4dc3d2d962c75adba75f50be1c2ba1f3de511a5a1848d52062dea7a03be2bd0318f1f0cd2ac255095630339bb4118fa97b79446bf6fd61c960af5526e854f280c0c843e19a81af7cf54cc97f9f8c92bc50584e6f520d964569132fe343aa468129e083b19fc18f2263f6c257a51909d99ef49e6614d4661daa39829b5d578f2ba39d7fd4d7f7bd48db3007275f24880e23cdc1f1bfb3b2b2ef4350ca999d1004037e982deda1e4f2acef3c86c0fded4a2abccc4d037846ecae39e11e3a478592e62180d2b68ef1d597ebd1e5b0bb3ca1fe56e9fffadd6d23f71ed7f9b135cff9994ddd6fdcf5bac06ff8c0244a7b42770c60223ec0831a79a0853829b4c52e7615e18bfc2511f87d0617f8baf0cf968b85f96445ae5826b2b8f090ca6e3358294d94f651086955f830bb6356dcadce9d647c5d378c5fd28a5a97e835571f7d88f948c002f4597671e47f1fe33414561ef704a26391aad3a276f6f06d3a5ffb357882809d56df6b870a629945b7f97d73940b6086e4aebc2f5c2b29626fe7c35d8b735a9b4d5448f1080feebd74407660180285d8716d4b223d06221732971128ff86cf50fd31967eb57a58a6384a79021b1bb873f0ee94391f1c7da05a560c0ab5830d198f3e6316ed6a4e2598e38ffd5823d940dec7ef43cc530c789a9831e70936e75e23a7a86cbe28eb2b64b20b12fc78274f471ac71a9e62917e24a3e6cfb7dbc2245b0b751557c046d749071ceaa8c7f028f95053d437c3e3056dc8a908df2d7c285228369bfa57356ead01833ebe246a42a689c0c098fcd5bab3bad9da9893261d6a0f9e011bcfe6b9aa6f35d8462837411518ce0932f5192b4dc760dd79fe11b35832c21954de68dd065033c213b41145aca794121734cd2d66c32e20d05fd41a25f16f7bed97b3956d7aec13dff4697f702e88f49a871b08ef8f404d49f77e1d4e2e185fde9ef15f6e68b3c26f7c794c24cf9c9cdd83349272a9ecd6e77401645b256c6004f224ab7e2c63dbe79dea27f5b81a77f5e6fcf0bc48816d785b6a96253131e6d1a4edc73f20b428d835d3a794fd52444c8824c12643f74e0e6c2b7050647159b8fea825b6f9df39ad109ceb91dd3f2e93f71cd03569a5d4f1098a9974a816e68061eed822707915f6f7a192ad4a6ea024fcaeda7d1dbfa0c018071402bab23ef40c61d08854b109f5541dc34aa32201340f9714001c4ca48b4697c4dae4bec44c3a35cab529cacde0d3e576d3224bf618967137a737151f2ad95fce2dde0585c1d31d8c4e1f8ae4c4263ae64e6330b7afd4fd579ba1fbc5b8e1d1d016123908176eba23734bb56e17284ce00074b278f65f2c02e8100cf21b0fcf4ac12ab506b097944868a70ec2ac2b5037d752b91131bca11c592e9e66f709a2ad70aa87de72d5cf3342c111f0d1a7fe7ff35acab37802130c6e0087f5162d28bdc82141db796f805a3a590eb973c44ab4c75ead5a28320f78c6da73305729fca0088851e359dbf9d94afedbbaa075298ae937e1b481ff0fa53c185cbf203d1913d8fe2b7f2fe35313c694d5a0fb35676d8ee80417b59a0c6b2681f370d5f64eeeb1518407ece9ac56a9ca4cba4287d97d5b3bc824b6780f62afd1eb704d78123ff8595eba4f61680f72c2f3089386bce0c40c50e23fcea31d58bdcd1ac4b8fc83f6969b8f920b77ea175e927902875a2f65124dfe5e5956fadfe1d3d24ae1bccb0d19d3ed10f6a7d98d626bb04536de0ee60485108cbc093cf824932bf352b424d26d380adf5a8be044421368b61d1b4e0d2fde0b88989837d97281762db79dafe3604642985c006a43ad1b9ab12267201a847d1ac036779e38ac615b62fabcfd15d3ab881888a6b9c1984d1bcc6ae316ccdf54c0eeab650220c118c26c23ab4bcfb2949c36b03ad398fd9e9905f811ee11664cac87d0e959da3e509cb2e5ec8cc60cb64170c7473c3edd765edbc453c46bd2e7f0082edcf1e93db91944d9de360ca46ce443b289c53cccde36ad3a3693b967dc36223a2267a10957a37dae72a7d90f3e85d54951bcf5139b90af05b2cd00648faaf71e8f62b6f2e1b4217d617816f0cffb07965b497cd8816e0f3eb3a3a9911cd8fc5368ae107c19b17da6728af8530a537d009a05aac1b9328b4a66c68661ca8d1f672396b78173be370bf99d975acd375d3c7b12480e2d8f47c4841c7580606fa0bc333027f659656bc25d2180fe8930f8825595319210e9d2f7dc05d553d99da8276938d3d9bbe13d7618481f3737284d3f32ab31c6b282080788fdbd826e924852fe9345d866961bb84e00f58c3736a44f603b106166ace6fa59a27d4a33db7196dd9c574cf5e166ddd4c2a7262c183e64a82c4c867f91b728c1d862c4669de1309266c07450ba555dba06f9680ea4580f10a623ed38cd9bc415a0b09ff27cf776d09ae48be3379b9249048124c0fa31acbac09147eab5681e1d6b20442a00e695a17afd1bdec4637cf859585fe0f529f322ac5619cf0da911f0a50799d9210f41bbcc1a60fc904e56ba4978e7db061df35b9a0a2f6910ed7e104b185a7da9826fbc223a5e7db0cf9811e3e17d04d557b02323cb1b95b45646a5dcdc01d45ffa330a40ffe7caead46923e4c07b75d43ea9404d6e47aadea2e9f4834012781ecf86afb97c5cc5a68d8e9c5f24c1bab63905c0470c8d168f9e17e14b6ab23377d419b17f32aca8339e8ace352dc0b8e44b3bedfba24b0d8408efc3dc20734c6c105127948f9f4689d340cec4810972e69d7e570cf4aa95f798fd78a21cd971dd524a52e24a7b2da0130370380535df3b8b164fc63d254e076ecb74305ae37ffcdc552b5f1a9b08469c22923641db62d5d0e52b9336a3c2ae9b66ea475b167d21878841dd7604d7e57365ba1c0a93026b1e6f0b9be00dc1785712abe991d9a786cc9789d9f469fbe82d9f5c186b721076a4a52ee7213b1b96964c381a234a0d7be6629dd59aef1c223d2c752c905a289bc87d49f5ecec31159943752de99583e1255fc94eae9f9406878e4e8183ca0e54b6aa9cf27efa0c38042f5022f4999f00e686bf3e166213078928323cbc1fd0c23331e7d97ab9df3ab0bcf46efb8aee1ad6fb7c916ab1369b461220d56a6e69b09c52706582da8bf43a0aa768d12a68bf269d4c6c32f0076eaa530f5b096cda24b7ef85dac306c34e99c635f090665c64dbc44cb5cf03afdf8c75cc0bc2bb3c532dfbaff640f5c8c92139c791ca2232460e2783f0ee61dbc33b99e6e9123b04fd27cf1f57af14d00f284b8efd52c8afde1cd0b2cfdf31f6418aff71bc18aef7dbf31e624a2b51970ba0d09c2faf24964533b6be40ff4e0f2bbbf0d4baa159b6ac3ced58dc49285e5ee65e0d653398818cea1102fbc4e69d6fc51cee82851bc724fb548e9da5dc0887cdcef8c215d63eaf8df3cb60e53a283584331c8b04615b3a2ad666634648b2f7e43637c74f5db6412cf38674c791034f89b589211353dda913425bc2e0357d8d4a0bae4ddfa1e6158872202323b2fb6aa9adfd9498ccc22a4f68ee3fe2c104cb42aaac4c2b53f6cda63888bf6d04173417888586036cdb28675f4e9299ae9c642a56904be56766d13aad9e02c7c6bf8b421b8e50c480e38c9d7ab70db3e1307435a7c6c0c99e763913e99a999436c9735afeb083528010b1ff9087e40636afce7c2cb8ed6b62801d097e6f3e95ee21b7fbe9929683ad5affb0b3331df73d7443b18958b4071a29ef46172c6ca1e714e79a155807378e66f001301cb5f68403395bc8ba46d2795fa21ff454ee21394a86f24390777bc25dc56454b3c400c8a9faf336cf03c1b94600d76a666fdb2ab0a5c72d1e5d42acb832d722f2b30dd0ea464b9b27166558d4e262c3f14819804c76db41b8566b8cd9ce45ce6395de22a413e97a79f0da196226d3491a92d79996ccc0d42474cc8aa63bd8522f6607fa4aee825c2e637cf82ee4266a7a6e7554098d7b78c0fdb7e9c5c8eec13bb490cc2c091006a3487803aea2f8731d169110c8e6f27f15fb24a5cda38616bf47b59cd6c0a94bef813997b02b6e8c5153afe237b2c6e26432a660003e4d62add4be455c8db6cbcb841af37bd3b769b549d4d758e645db004fe5f85cf3b851738edeff75d7813a970ebc0c0fad0d661e166d1facb3b5e5e0de0c7513fec595b4336f9e0add2a6910412080297865556e0804d6e0f345f344647ab98844646aa281f815311b689af46f7a061dfd4ec52304a667203402eb912cf47187dffabf8741598f5578e2f96042d5d4a85f0781a61f487782e9dbd8126c93a3db69bf0f5e13bbc0ee93e1c60d69f3f03e3443d10a002a5328a21e3e5122ee10cd06f9d15570ec51b0f827907dfbab52690f33a00b9547b19a829c2460706b868feb1a630a64d2398244310995ce47936e9c5b85e58783ac97ead9f4ee94a621d2b3338ca63bc78a1e084417212a8140334fd28527f5fff4858770fc1d12440a21d0910878b245ed1c21ea919199026405c4a5ea21a5322ab743bf82a3e868ab8d33f72ad5e13ea38f8ec7ca8acddb932b17c1ad2a218685d16cfbd1bbde100a51e340c36f1eee9277325008d8895d97ea60191ed590f83d92fef1a1c32982cb506f255d36cb3cdfe62d8fa9041568f247ba3c58ea8271493637eac9597225799e919ca152e9914085f6d23bc7b36e6d4e2fa69924aad9522459d11c4659121362ae2e5ceb2ddacb09b59a000c58a7b063193b83460f61d3ea1e7bf69ac9cc42e799d549334b21a36e8a1c697bdc32821b8dedbed17cca250ebd0b082ec4b24a102d7496ce1a0c7f345f49a3b31b7695cd0ba6da273cf6dbe0cd724c0de20ad9f08444f479f008ef9f4b227ac57cd52b4495aaeed77e45c44e23b22731afa2e68ae79a79e24f7ebc1e1fd8c648e891a4454d7e842fcf1c81caaf3c9a64995a993fe5ea4fc668086ee7eef64f5f705da8b0b6a44540814b852f78fd090e60b883c8cc0904c03283d1599b0cef6676cc1c1965b87ed4cf03d1be8ac91dbac50aacb05821d1dcc911e7a88a10f69484806efc1f8038b4d29461059c12c7a28e81aa5dd438683dc0436cd790917308ca121c4bdc6f419c8745acea00dab21bf7f12da77013f730a56752798bf77fd1cab8e35a8bab5412644120d2e9ff9d42c7c0cf9a8b8da85f1c24a480b9bbb7a24024fb8a768fccd80f3759182932482bcbe4fea6adf7bd840a4d187c78b6d661dcaf15d73db5bb4b03ae69defd4fc93297bfffaa585b73b62a529a211f428687072f64906a06e26a14ed2b64778afec7b789520434796758ca2d7c47d3aa864a543d23c87bc0355d22b9525a96c0ce9f85988d7ada19702e04de98896385590f0dd409f735a8ec5be6504c3d7a198b8484d6567f4309ffd801227dcd616f7ac416cbd7a931d7c5e0f63d24bea98f1d48db68e1e5c3ab45a5c0c9615346307a9823457a5527287e0b069338c1696a2b7dfd81708cadd023f1f7a6c5c10fa22c327eca87ac40d54390fe9399c8a50b537c1119703cc3afad306ed3b39a78ea17165f84060de12161e7713bb6eadae9771c6661b6b1601f89323e06139e8b9cacb1433a3aee966807ee720fb2dd0b1f65441ba25413e9bc1af00ab0a383763175726f9149e5c816ec0aa2b94da2b449856069111a2aa4204f975d0be5e5471375fae38b9d7ba98dee08a8c200497fa1448d5827330f835289aa3000fcb67f0477a3350f59f22a2ac08372414cb7110658bf14a38b71140d68d0a059a0ae1605c1b69922d4ee508556a297e7a1dc3496ce2b604c98cf2cdd94473dea9831992f52c58c858fe146b90b5ad3d67844cd94173dbf48e49286dd11ff2ce65746532b3a92b5367b0ba80c3300ddbc667f653e7c1c85c7bf8c865ae8baf4f8dd289b3fc8d762948e65522b2b738d38ad30d253cddacff0bb5f522acd57d2cb815de50aacb97a36e085fa5cfe6cf9c0c480c3731cfa32bd8cb625b2beaca6b9e5440662867f02f878af1e48b0b93ef68d55ace7738fb3a6991a62fbc28c2c815ab18c6c43518ae71dae2f3c5b97aa870c1f68abdbbf81bea8d051e7f0cbfd6c48537f35f7c0ec285be5dac478d826a8def14d014b12802b4d091b645bba9cd381db8cd6f81a65a4039f3bdbab73ff1fb4d27957f56bca268e01482e1a5b363e8972167086ace8964206e9ab2848181ac461156fc16b2ee9147a78ef8a1e0e5c328c42a5dc2df0d4896b59a4426d8cc0106a1dcba1b1fba7965b0a5349bfd56367c515cea6139d5024f21952c87f1a4c957ed0add048bbda6e09883b970d9919b53667db7b1dd2b4ff24ab296433028bf11f4ddba7db7f22c9dbafa48602ac552935287bd6cf689d3ccf859b64ddb75bea14eae8d2709aabd70ee834be67a704259c5c5f1265fa8332c26bd00ab98091ae1c016c8630143f8a6df3bd7e9fedef678bf1416c539fa5edb42b722112f875d4d93e0d2b6ad379f5c19a59ce8a4d413db9e56b6ae84c407b4bcc4fa1632aa02c72d6bf6a8098f4b1260a2ad96cb7874df941ab2afb59338d07ccd5504d1ee2e2f128a1be6bd74dffefdd1bef1c56e0777e253ffa79399197ced198d91a0b7b88387d1c9a8cc5e56bbcd874c4214d6bda87c49da8c1d933ee676604b0ee90a42ad1d03d4badd38492e055ebe3caa1f7fccbdda88abdc0ad185fd986e38be2a7465b5206462f4428aa09d3b8b2ca441b3d7f33730c9dbecd997dda3e5cb45bc0510b0af568e18a46c74fe64d8df969a13f6928507992f8d8611456e98028891476635392fb1a585bf08dc928f8b6fada4c258ab9c89bc471bf65214c788a85787218805ca794945b013a1fa92e8d5f2c27d688a2dd04df195b8ce97cc97ea5ad0cb68f1fb06b78dea3fa53e6e6a9280c2226bd777b0459db700971fb9e6ae4ca21c1c8c0733ae56036f5aea2f09bae78544841f49f221e5158b5959419e0914ee66d6ae687748d755ef76015813a14984b7d1ed9d48c99e0f359bec63ba506c0e723dafe72c7b07794a9b66dbd2e7359f05d7607c65bc24143a29779ce6bd321370559cc49abdf7ee0ea400123f1f995f4c6b84b988ebb748df6554523a991a1e81c747f78721d49ed989bc034db3c78060684a21aca0541e9e8472bff446885703e78a587bc0b5f484526981dd1996074c1415d9d44a8014de1ffd126896f05ba66a7a278a01f3d4176d88d143c2c4a24a5f23aa065d1dcb382e2919c5053b59233a508b5329b410bf660739ea95ba8470c555edf0a6063591e3ea99b8b9603ebd46816412928b65a465889be34ec458c12fdc5291d7c0f239564c3aa5d9d825ba0d555fab172736af63846cfefbb181953b724a0446ed28b2deb622c66937304a8f055c3d20eb1c6791e6fae627e8b709c4abdde1e345a366047b8a73b371bd8b1acd6b8486f88df8c8a11a6b94fae1f4016c642bcbe5e4f29a6cd120bb277eb767d361a83158797bfc5e4ab5eef434e52e4d5abfa6ebd803412da7ccf39228a464b93fcaf6c8e8939ef85fb0c7b833526258267a17dc16800693d249d229cbd9b96c415b0a1e6aaed30814db1911d1d979b168037900d85e68a05589593dcb20aba76638921dea1b2c7af4bfcca2bee1b575ad27454c6a1794eb77cf7d81ce84f9f08ed1522f4785062f79af8c76f198ba51f01b5d85a8abdda2ff90aacab5be834cdb9ea64198ff509d0de85d8dcf827a6f4fa8e56930484045b018eff55bf011f011ceb071d04eebe00dd8c642f848ebc2e81673991a7d8dbe07e73b0d04d55547b8d5fbd0ec21bd4f5c91228e1e71715e4b5935ad933e34935b867893304f28d3f86042cbfa316820a42d1ff991fd267cd84e1d7950f926a995b87cb26064538ce51ae36442d56dd5f3db99b8f5c078ff2eb844252a213206e3f3eb7497e72302b3a681c28da2f7d85c7ad00881b212e0ecfdcf96fac1d14e60469781602938f0ba459fefc885f73e6106c0c5187df38834116fd4c0f16e507bbcfe491533892c4ed5737c204ceaac0d8172d9042a4b05c7c813ba330b3807d0df0a06f2fc9aeedc2b891d43c073045ae4960de96b472f0cf16bfbffb2f0b24bb93c8d52c5606e6fdddccb6b3d10c81f064cbc54b9275498f9560f8fb8a42d9eb6db4df9dfcfd083877acf4eced6337f616566997c84e651d8c7e6785a14f779b78b2964ece0d84a637c441e923cf3a1639b613f31c72d51335b1d3ce805fbb3726362fcf912403eb2fcbbecd6de9ad1f66f361818ce8a11022f26b27200ee2f8109ca64d89d85e794c28a3e47d0bac43ed096bbf4b472db614039b78f0fe7d48913d3c862e0dd1e5367d1a88d8b5ceb7d39630d0880e57ae4845e2b55c314dfafe342eddee0921add8d5ffdd7f8347daad9d0a1a70e664c2dcca0f193183653b71e0305ab984ac0fac136e9ac7abdc9c551d6f0b505a53c8c7091298310187c011b71891972ec4dacde7171e0899a2bb9fc8da972fa27761a9cbedb4eb1f2cd98c37350de1b4e3d6e5727898bb195bb98017dc054e0e0c40b7f7f81eb5ee1dfb8ae3ff62e706ef3f6d607c39e316c9936a6bbc3bb3715edd9be186297c3ac18307a82713f2305fbe45afefeb6216052357e2bc81308e6dfe7fda0a05962a5ac96c4850874adec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
