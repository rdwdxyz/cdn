<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f77d7575a51831a52b74e65a2894263e84c77cf10a81faf254d88797992372cac686df1aa4e92a7fdeeffed0bf339a4f75dffebbc22718bd1d25c17eebee763cfab9401ed5b21533420251a08c262d02dfeda6deeb38a37e4953c705482fe723551e37c109cf1d40ab03abb82e5a7d2fbc86f3b7a53f37d0230aa14265aeb916474da1ff700378ce087dcfc59913ec2241f650743b2b13b9d0251d77eff8d81d263c72aef4cec346da792dd90b942185fdfc8bbe3ff28f58159b2f1b75b244103c3a7d32609e1053fcf5b4379192f5d42c94d83bdbe2aa63fc97cc2bfeed2f87c25671910c8aa72aef9ac2fd58828c5c7f8a06fb863e43ac2147852816b28650daee942babfe22ceaca221dbd432572644e070fb7954864a9a04280ce40d8cf915c2c76ee4fa0fa9ac6f4402e44655abfcc33eab4ca9882bca25a1ede286ae45df9272cba0c824f36056570e7d763349b2d6edbd79289f173a53ca8717d7f46e6740b0d5ac1142bb809f0cd83ab13181407109c6597d5de252bd7110dd187eed3b83f3ace5412fb3df0ea2aea890d820f80c452e0a12fafffe8af625cea7fc98b00dc79d7a8712d9a5f710dcf168818d9500a11d75f4843f59b0415ed891ea8c03d2bf0d5b6789a73df7a48bd71bf2edd06e28a6d9b50cc39d240e6a5916c028872f19601bcfa6f4bd6a58f4059a2f06dbc7b81bbde137e7144858aaa48d1680c0fbb8b07eb535b0ca73bdff2e74b6e0c768f5720e60ec21a6ae9880084e0e0cd406523407f7529c3c7f2a322d539be65cbfdabed53b50aeb9c856682db2f48ab0d08eec809feec032b069f9d4f5b489ba964451ac5bfa725889c011bb8d67e4a4ec2c4c97a48b229d3f27b6eef8c4a930f92a145bc0ef711240b742b9d166481cb34440623588e3155837c4cb966a050c518de7f9a7586b8e7e35f9c19f14247ba5fe665b6ce86fa9d453c3a58a5208a88dd076f006fd5fd8de15acbfae2a4345a6edfddd0a79e8035fb8bcb14e434a530409a06e414eb9386fb7bf472595c602243e29059364d02a9ad035481d606ad9ed2d812f11fb7bfc30bf4f941f06b1083c47c7234b50e2f1f7980e3c3b342aefc53bd1ac98cfa58ed9582b2eea1d46363ae4b535683f736a35dce73153bc8901561e8aa4a24c699280d8d5a6d78f1573c7e78ab34f5c901ab3936f962db6f097e65db6696cc4a066a861c906421a6df5a18ad63afbcaecd0e7915f36da2e98e898e597311a54cbff947f2293b72f7c2ce2fdbc6851497c0eb5aa17cf2f953d037d8072d446e8c1c1dd9eb30dd388cdea71e3c4e893a9c337d35161a0e9bd0d77d906a04d5409df4bd4fc043eb943ee1456f8d0ee55ce4b533f0a3555c967c97dfa7dc9c9f5cb24baf2770f4d730eb335694b828893ab9bf82efdaee19c131244315713d61895b1643a350325984a44722c017a8a5ff16e878c9b41a0e6ff1ffc34ad6926c64483cfc3c40ff2a473706c5b57d2e61b21faf4fa5098a01f88351959587dd1d85e40aa9502ffa8d355a95b31170b974a643f16d1b76a21bde5da0a57b775629d1753c65f094dd11826f1f1e3fb052ade8568d0b3780b226fb4efd08c32e84452f13fb18775bb248321c1b593bc9d2a89a8bba09f9a1eeabbef41e54218bc87821dd0f23f08dda777da7815cca38e5556f95b304894d2b8fa81767857dd92e9497caec6d0153e3a417d442c7d420cafa66d78ef0bb4b4a4885518423575179c6b20a79c6e1a35e9ee5dc4cc0545fad66f645d07e0076a7087399614a854635c65520f777a7c1836963b65460dd38107ddbd51ecc2c7e0e418a1a60c389bae08e108c64be0643bd1393d1d699ec4c55c613bc532726a18d0e5937cab4d50138f3525467e1206069d4c6c78cda62775d3aff36b990e21d8492406cb6e44e649c7461d08b16ca46661b8b6bfbfe600ea10d04222096aa43dbc1148efdc890383fd8ec37de81836003f6ccfb77867414e6714150ba35c80d19c8f470f2c17b6dffa1b47b7afaadbf9639a5c0e54939f4300cb01118b97d9836574b9e3e99c751248d5b4639b82600a4277573759ec3e31b887f8f0a4fb079bb2d3bf944fe3b7c90548f035c5e5df34e943b4dc7c3487040160c9c3e1fb378af098be21e05ff718f21eabbc05e5885212318c72308b5a993bdc8947da5ef949545175389c366409ff45e502fa8ef0e9fbcfefdaf57076d342f511bf18e10b73c007e731a3722e8fd0770a5d1bec012e6c2d87002d82849cc2afdb1b2810e9cafdbe2db647db0d5f1734359d94c9b66933e88513cbb7e770a7e861d966286339d147848311ccb096393d4d53445e926bb48d22559a15e8e5b708613752e303d87a8f4ccd24abf368e5523be6d86cc22f37ebf86538833899f56bacc000c8e28ce319ce7ef50b23275a6f9e0b2a17d2109d19b5227d5fb262753c2c5f0ece507f3eda277b7ede9225bcd832b270d03cf273ed03f6a177183ee8e0632dd610d92717757df57e213cd996084ba37ae6fba8a4005e32f719b3b88ac85ed8f9d58dc9a1463f37e0d8aef688f1ef0b14aba3b912861807a5591f2a08a3245511f6b53e305153a3d19697fa255b054b0231f9a39f8a7f8676afad17e3a9987e69407a110cbdec98f32f5586916978202ef35c74580d21b1c39e4a817988dc3b7b051187953284a9e5cbcda31137ecac59579c3cd88a4bddf80b8549e5596c62d1d368e8ce26a6b2f9c88a0b5b3b3a8723825f6aca1714425466e4d2ff06bd30892c9719d25fae2781c2720927b9ab5bbcb5c0be422903b85c4a0e5fdf8c4a121ff0391d999f4ff10d8cc8ec6ac16c73ef65b69c8c95159ce17ef03a1b4f40265ad38dc09377db046a3936dbd322b699db54032cfaf79dea3cf9ed12fc147bee607490d06864a7bd7b9721ff89682efb041e79e242af61527f5028fc159612342df92835b087f5050f4dec806046e8932c28e7da3e29755096fee6047baba0200e66a1d72819d686a2d668ed0b941e729099aaba7ceb1532d9ad8b876fb6ece07c7373a503e94b2ebdc60d118e186928b5097876d9c7be970b3db7968c14e373255606a2d70d1f3b58f82d4bbadec7c4f3bed1a8a7c8888ec45a03b28b86af1ef9cb3504b84cbe6438d23186f9a2ff12ca55888d61df9d8004943092df249bfe2d43387a1dfb8295b03369859558787c683281a4e6eabfa14f775e58ee6037bb80ef52cf72f14d674060c08255840cb1543a6f339a2d41c5fbc86a5fa9d9c57246ab70be5683473e2c27cfdbed463e12a01260ee57b5fb4f5d18ad8adb47295702a4b007295f41c7aa7ffcd98226c690df20c398d4aeca5ef8072ab14dd158feb1a6b01b70da81b865c479731f93adf2c6fd0a47ad3b9a9984ffaaa20995641eb380e0917e48c41e8dbf8cd6ba3ad5397a662890d19275c065b953cf89fa0af9b42966850643778d9cc7d9e04f80e81ddf1d3f65ca0a932573b585e888f5b508c9e6efb4b0e1d5d84f901a93f958362044433fcc779e1225d6aa1f459e5823630d60dac4729b0550f1dc2532b786904567f8e11712230a4be4274a234af5beef5bf046ba5e28b6c97c25451df9d8b08cfb479d02aa9338c2b3d97f11d5173f8ef2f3aaa7ce150b990aac92664cc0f84bccbbd284d331f37e5e16bc59e7b2092bd915209277822830c8aaf4ded8b08b9710a591e284c5ce5c208d5f65517cd86e6f2a2f10038580525de0b42b04b7125ef34fde347b63ec928d4355416ca7667f08f7da35b433d5518eff22161ecded498a6f0d758839d1a9b9221153138824b5249b6ba0e477f6332e3d803cb773b6e9dfd3f9058e7095bc8e10c77243f92b9783487b57644ebefac67fd2a4e040b7532a24988abdaf764b7df3fcd46ac15053d8bdc09622f545b10d30927d5bfdc78276ea5b997ed338401012f862639ffc613f8dafe51f8b92fd53526ee26293d29099b7cfd129e4299d940d6a5fa5e1864524a1627a9dad6a61d9606138f72757c2e84a452e5364565893f1cab4dca7b3cb3f12fefc4381b1f382e653aee0fabdd079605dca3b909c61102cfcc7633a89ea30b8f3db3a3ddc955e8fc0bf8a84b0524058d82f8b43ef925bd507afe5915f74a5f600417e06335e71bd536077b176d5c590f6d98481b2ba53b0df481aa243845f35a74e1c4a069113313b50ca97bce144e1f1a2765e513e9cb911f90bf1bbea997464c6bbbee2e2958d08723481f7e2184cda63c6b7428e9aebd0f91f798fb80c48c4342c04df901da2d4b182a1d57923922cefa8acd2f78395372fd65987f061a12b14b4361e37248015cc9206718740c78f2eba7ddc4e1e00f705fd5fcfa9f50ab50f4e3aee01a748402ede028ff361a7cb9a2b148338636773570b9cfc0f7fb0988b2c306d474387d5df1135b2df0a072ab9f7ffc0c5afd1896882700aa7edb9ee33493dfaf30bcf3e5c63400e88edfa9d168e0ed3bd3abd39ce1d6fbe45638415441b0668dc6f36afe02c2f709dceb50980bf68d7278bb3c16fe21f2dd86607ea2e8cff6eb5d30a1e7ae9f32a857028f34bfd33734d7503f84f09634666b5e3cd50216dde6a47f309c5228899247be97ce4fea06139d725b6368ae35e5f0af335dc34b4e3fbc29aa6c6b7cc306b33efff10e44197ba190e39d56fe18654646a60a606c26526a533acb0756a9f4362675d7447814ce9f8f761ec777a2b8f82c085308ac1188024eb51d42c7a508dc113094af9fbfe0e356a4ac2dfb61a03a7283e61aa2ae30ea5121fff9a44f401933b9e2a45037550543c3167229e98b2ece8dded89e2905eb210fa5f5dc44c890f047b874c724c21c3d3c231f5a4bc1339469deba27bfb7626fbc79b6b96b522f6acd957fa15e5fdb9a5ee83bcb5717e72db06be0731dcc071dc82514eac26ac2654af8c02b9dea0c6a76bef0a9365c5f90c6451ecfaaec93afba3df3b8e233dde33b5c0ef52f0b04e26a14e035a6a94ab32524b80d6ce150361005a016cd80fd3dc174ee36c1f6fe5e3f1e561964799b8324e6e1bb8c6392acaf11d76e946d075a7f41099fb5044e85b55961b570930c44c2838fc54b8af93fb73508b77bce4040305087bdf5d7793008c6b4eea1dc30ad47b3041e2d1f654d9c725a9e4d444a31d6090ea26edb2b80719f549b62257bbdc69026256685b944c5c9416735a0d67f96b3add3278772b67fcfcbe08b4eb6ea2ea3a648da5b0b59c83218f178e36e14788d5c5f8e2724b7463e0a1fb93da15470f8d772d8da73e4caedb4fdd9e2c82c2ebb7be81b5fbc4b20d1686d9a9ff35d1fe21f9b10d3a25bd18dd2b46907ed5451f20c008bf2bb9d0d0928f2a29eb6b3487137ac72912c2c3d620d103f94f700423e17d60dbf2f8183ee122387d2472d2f1661288d12a7f2bf1afa4334281b72a490211fb9a78e3f7a158dfe99130e65af497ec6b73cc5c523e356c050fe6155a2f2d24d8b90c6b8f3c667c52713f73ec94854f2119a0635caca440a05a1c479fa06a584e36c2a3916e736a2b88aa6efeb2a67ae34c980fedd1187956e75233f8b8640b0943a2967b8afddd371b07e69350173ee615d4ff7c9e7ccf149d0dcc029d37cd9bef63a24e081860f810964fef155a5a162ee21e724ace6f4aba7cdbebc2fec43afb62a7b727390bd7275f74d0c5b33f3652a1ade3e408fd90c6278f6432b035b2deb70f10576fa8e9964958a17f45cfdae08e934c42cc4033984161b71809b0b6f42a04ba82211f4fa7943a703abe0c6005e65729d2f8cc4e4f4e7bbf9ceae384e18aea377f509400a57414af6935dd42d276b711687ecb339e2b96d48309b7eb143af15220f4c7b988d913800b1ec4f6845297bf234e1242f8b751aaf118bf286a22292cd81f44e9ca112f01874d4bb4773622a21418fdea8349ef622cece75d83035709edcba5008c6a9c3a37a6ae2d9da35692efb5a189d0993d4f11a17f07e6754d2f69fc8717ccbba20f082967d26cc23b8d5956461c46143e46cde2debb89935443de38997b767c40204205cadab247170ebd94afe78536c258662adfaba8b02a9ca78b4be90c12e06b081ab57e1ddb1e1b279af8fa30636e52b3b0b0cad9f4d7332be7e231e202910826faa9d0924b2499352184c5ac4c8a706d7d491bc56c3ac05c53b085f52b7bfe38f12fc2ca05b1cc3939b9362f9449d036814c3a4203dc72d134fa144d849466e17086bf0fd7ef316f679f551405fb65d2e2d4f374707f512a94dc9fcc5cacdc90e2a8689eee8f992616b638acf239ac97c8cc3e4c4de801d5b22dfed681847483366bea49bcc5ae55d3100bf4d2ec3bddd9501e07f7fdb47db9b468f4ed7336b4e5fa773bf4079a76b970924b68bf54d8fd9579eea78348d0170564601c417ab23590e8ed51b609f1c47ab8975773e40b31e7623ebd2c5eb267b66f62fee5e33cc9de6f8fefb6df9d9dbfeebdc0fe75d87586cb6d931fb5f3899e328548c5833b742fda3e5414b2c29c8ca1a3e36c6d0c88a7e84b7150d7c2c1fc30f6593562d6e7bbc4a9481d57969feb7423aa0679b14d78e1855a4ad4bda9714cf45357123855c06e7322096d67f6b52ee99f5353d42338c60717580f9704f5c758601b462aabc911498e21233a1adab12c103906f0a75127228b2f15200a6bfd9d4487139e3bf4363b657cc06b52e0fd7cd8d4669a413a3446d508f3c47f4b4bad2bc234d29f431653b5f5f43383cff4086bc7f7cd5d18418ee0453b58ba9d48298c15be97ff3ff28bef8c5757824d4ba97971788d2769b00b901ee3f89e5f99cbf90d9a136a4ad9839f180c08db57bed38e2300e33f7054b8687a762b19950789024d734b475d56991ac401478449c71b5ed8751a3cb8480e42069d1b726c58b349392c7a8da71e98e3a3bc04767eac089a4210ba64265dbadd75a1a0b4ebca1f6e18d373822622a2bd284a5761889473b5375d0ce68a9d176e4108ae6aa9fafaf499d241e593a2427b5dfe9d9f1f721bf623b28c8243d7dd45f686e25ed7e6f4f17dbc63a8db616d2ebf566df87b5863e06508937a74125cfd8fec374f3ec7d787ef421ced8dd59b51ca97089379a2d118ad8568590cb762c078ed87128553de1d7528127fc5ac620836e3a43ef04d1fedd9e753f7a8b22d3051f19a74e347da4d7fe06982ae80a726b08b7f69740a0106c885621dfd704561cb039c0352f544c878646ef9e03d831a4a3767360398f4268a39023ef6f83066810b774685bf0d5249ef49e23631a2c48c0212232f4c18d84a984e0add86e098197061d367ae62dbb931814889d6427a1b8c8331380846ef2812636e3d908d42f2309100d892b887b965308e1539d21b083bc4d99114142dd749c4c31217732a4c85f91170d8eecc736661cb547f38901595d99709fef9e9e6266f5bb27d3915419e7cce2666cb80a3b13e5fb654424518c4032fdb572fe1cf30f8669b8bdc96f37e158d2f0de2c01ad5f9a8cc80902535e82ff885adaa78105aef9ffb39e054d909ca472a266de1f8df5b75aa0085c8ee08ca3144797ed131908dc93826ed5e19d65dcc2786e2226a6572d5a35bb42147b0e8859dab43bb6e7bd50932832740c97d366ac710ba8d8dfd44b6a6a9d5ac4a9f4243287dd56d708729dcc1b7a0e888e81307b5012c72f8bda759352c2abbeb2e5e384d1fa26d3795519e5192de49a715210ce2052cbc5afb0bf73a3086fdcdc6c175398930134b8046a835d532e13abd833e7d3d202df019133a837e43929fdc149f1891063b6d36dee13fbe3c4c296c8cd7494e7f17a51922ae118929fa2eff1255d095c6400b6d0f742efbd8b4e90af57dd0ac1f96b0c6eda949a6b0229abf2621ea4a8b46e2a020f6aa9f1d2e98bd8a1863052aa220cf401337c77429a120d3932176b1944eba54dd355f3489d87b51a60657414f3991048f8bef6422d24c99d5b2a49255d2b6ba437df82ab1dab65b90e262193d3fc91620d19323b58436a0dba0bb41ca4bba8238111ec822d861a375497b2f7460b9be5bc00586b5cbf9dcf7246730d593b7481376b01eac624b776645808e734381f0b01130f95a29c22cd16ab8c763c86998c5dd09b234fe5649a96525b74c10a3f5f1b7d731110c434fdfb89750a019b55b384a4c8f93821428b6e698052330d7542ff561e319e9021dc480a52f7d236768535807daa7b8ba550fd6770f4fdc981216b1da5cc8f97a2f28259dcd59c0c7ea2655e0ae57a051e8b2b99f0885f0a96bec0a4ffccbb370584527372c37643bed899d2ee5cb844873d13cb81576fcf7bae662f05661e588e994d356192da5d9c0d35959cc153737ca7bb8ceea2b1c689edb4b2e3c27adcbcd431b3b056017882d4efda6944773e2943158366b4fa5115cc3c9c6c2ba7f562a2d9993040bc65ce31fc412c8d78a0e4cb4d78c6fa0b020491f805974ab2d841cc4624f227be39850798d81870c26719066f6c505fc8494c2d4638be902c667d48c432dc3586af5f8764a86aabaa810dbd2a0cf25705ab374ed0b538f5d5f7ff10d1847672e2fb14e164c3712307e8b62271928ca27f7e714c7128317961c70cd4e1d85818301322da530b5ccff3cde5443c83598ffb553251af24166d835cfd715e49f68315e599b8747530b82fec91fa4453e7efeb63809357f663921c4adc99cd1067a60c5112d717d77afa86f1ad1acb4b94ff669d62a40a8399cabad0847ed25e0a5c4f426499a44d3200cd7fd3486dd6f59a5b66a5ab90e8314de7ee4af0fd2dfa8efb618d18a03da32e115f14631e5661f13586bdf485b2bd9c3b616658b740bd107bab8afaa2c87d1be19051fb33b5651a1a1a8791574c2a1e7feb4ca388b903a01bd69d2b7ca0f45b018d6147d303bfc215607e77f178e48fe24f0a388eb3f012b5e5979f48e34658668ce61305dc2747a9cb7bd03f03c336333d106785f534468b569e8b2e4420befee374cf2abb58784dd65ebd4d1118acc6ea6c3bbdcda884b5d6599e49d86700f03ad1af82525becc2f17ad04445c3db76be7a97643a0fa5b9edbad69b360c720d94f3f2b595c6422cbb8969df1497c6736a27dfda546ac11e57d21cd6d6d322c6cf28567ff0d67ef6e2c235ccc48d0b35311082a801ba47112970edd5fb44512f7737e22e159c6b897262e21c3869326c1d4161f411c9374c0558155a6833224b46d02c5a0fa620704415e687f48b65c73a320a2ac595edcaff445f30a433ed894db170a10b160f03a6fffc811ff156d4cd75c036bbe0c94332eb1eb99ec1656e49b12ee1c93dee20af020ca3b20d2ee680d7f4923efdbf3c5e734915651021d22f3531cc08705d7b17b32bfe9cfd4c2413948f4a4c427f33a4f9cbde51f1705e249e0319ec64ef2b91a6c388643f1af3a98fcf447cd442defdb7fad68d32c550a4699b30572443c324ccb8d441d736e7254d9916b7e9ee8416b01b537dec19099a035d37cc9faf8a1aff1fc926657699fac039902b0ade0d6e75f4379ec44a3c91bcfc8f77407461872825e834d1469c997df8bf3e308ec644ef80c857313560ffa324e8863747c0902277ecd14ed588c8014bff781b316f340565d3d5a1c055e6f0c3b921b5c8db8ff8ddf8d57f4d17e8b8f848ca90515b086f7aaf909e2d3adffb81d806933642f9875fad0d570662fab79293efb3c47e18cc9cbbdfcf75438857d0ca2cfa6d89fe185b3672f03f0351fe5fea905c01b8973ccf373e49a93374a5a0688abdd46a068ea492f4e42107a457a40d7c7c1115b6edf42be5b6e7cb696aafc36a5eae90e9a0a028acd53ec06e215412877f8dff8b56348335e4917e60c15ac4b4a3c67e7461ae997ac7b3d7a04f5ff211a22fa1e5b3413535e24bbb464bfe37718481078dbd18c4e76e74fffb1673fc77b69da89531ffc2fd7ba4c3c4fb0b113928adb12b524fad9cc0a0c69c1e41061333541f5a38f7a157c8e3bde72cdb75fd3f37a6d9e561c022a1a85d59c3c5f1ce2f7250896ac1312169e568129314ffd10e956ddc05e54105c5d85066ff1e84215f51aca7a45b475bc7af4cc32c30136c0296ab3b36f414fdb531a2009c59c63c88411e7224468d7b59fe862e7f75a709acf766bcbecc184f55b683e0f983a2d4cf40fdbcfd9a61adcfce97ab326becb11ab4d136a0bf16a7b26fbbf945c038d6612e76f00df10f217313d5fcbdca64a52e532b4316575e045159f8c3003d5e525fb5b6ac9535954c1febfe3fdbd6835b071288062880dd215352841e1fd563a706e0f29af89e6f38e92d813289259aeefaf62e581826eafb1b9a69874f028453bd18d94993e29fa8ca836012159e1c681a5269d9eaafcee69cd1353e117f829230c2a1b9acb3be247fa8db0dab8691e3440593cc0150b9c8af2ebebb544a9a3533eceb46103bacb369221236fe5d1379ef219a634461bdd7c3d4a50b707b4f338b30d33ae1e2652e0d44f0c29c556c2be32e2b627930ea22443abf8cf1b918acb6b7fcf482552a83561fca4fc2dfdda5dba2aca5469d3d3e670afde92af6de2589d92aacb9daaa08213000a87d5f5719ea559cf5719329a913563c172736893a57b81aa9dd91876d851374796d6894ceaa26abb27d343d09f7c0185a53ed778492dd2990d818f434331fa024719b028151ed11a8aacc3aeb1c6055379b033bf388c2fc7773d6f986a3559fb3741915815f40c86ec8013c0407ce067d3679415bc74d27a712674e33cea204c56d65700184fb7e2bd34e0352f819eee3886834cc1702f4bc9e4f2fdd7da4ec53eb6c4d5558d77c7ca44767604e9fec32f994be21ac0f657e32d95f66c9624fe6f5b8bcb07e1d26ec7e68f398deefb3d12fd514a7cc8fd37cbc6aec1175a4108014931ea9992334280338a02dddea5296d5f60123849753b1359f00d6c850ef1664560cedba59d6b10e2407fbe581cc72e421c6f4e75279d6278eae09c6cd94b64401ec2dab51beaf8c9c4cf98c22babf28d7844eee4570277156646e7a2ba8e650c998cee756f73dd70203abc26bf10c05af65719f431cfc15096b896b484d6b8c64df0a1f62e689c4e96214a7b0e1dfc854a1fdd689a1c4460c26c7b6173b062492f26bd7ef2002dfda59f934e9915a78c86e0a8f9a7aedbd578761723f5e4cbf655ab7d2742268bd02f0b90ca0f55e03bc97cf7ed126ccf364071cc2e8fd48b2128262ca00ebde8bb9a8f6e0af42d226eeeb74a5fd1469474e0259a99b150b9c7b466374cdec2bf537f39330fc34bd45aafd4a35d0a5a75dd2631c115d5635a42d19d64678984f98b80909ebd937f1ddcd9484a06a4b18cec8ee921f255b08981cb5c31b79d5b5debc7babe8624028c3c9b006732e724b4a7dc7f604823e000bf3d6b2ff5c11e0024e8bd42c64f19d8f57f41331d2cd469b7d9d00f6f82f7981a92d17e89282eae42acd9ae94daf0827a4201b3e5c386322a29f38ba19ae565f0e21422a3668e46ccacae06e41c7a7b70be46a48a80fbca18317bd98fc5043b4025679702c4fcc8c6b69754c39ecf91e1f9385e7e02f2e61921bc2fbeea389a67d78edd9afd4743260f5b6bcbf54163a0bf97533d6312a83b7cf92249c16e56ce8aecd09c3da40fbda242e8984a725d17dd74decb3ea3d83a22175297ab8dc3dda9118faffd6bae3990ace8a50eb227cfbf578b215af153e2b01a3591fcc98609a517be7ea9950f0c7fbcd117a3c3c27a2296c69ee1b3706244002a0006f3521ba4155da38faaf5de2b58970c2e786a3e5d89f4803ed925b079a8e8944b06368f978be8621efd9dcf474f87bc9f691ad545b05b73a793e2d7b9c2d449e4b03bb8c3f4820a012488ab2630ab1cb10b290dacd634e7413f91368d1ecd66410a22db89129357b983624a589b1432e9b3e5cae069e05a648202f09479c914ec40b5a1424b2495e63f36023e4b315274b42fd786fee8a219c9f6925121ea58d7aaa37f5add39dc5ac2b0e0e03daaa8a06201a293e26cb5dd5018671eb98cc8801a8df58596553b91d95e2ab21d44db39920a631fcc54fd920c21d607436538fd2db36a48a47bd7677020cf691412143ace051d8c345ce76111e554b6d78fdf25bddca07f4af8eb5af45d5c3a72591bec32c187015f8bd515c7eadb0d474670d093ee5970ee78dd14ece77a9eade0a2579016b95d94a4d488e3ed69f51141cbc740c606d94ad36b5308c4200508b495a65ee89aaffeaf3f5af90f783234a600369d9052307c904ad46677851495fe3e62a4902511ca9c5af3986c41c29fa2cadb94699118feb216227f50828522805ec5d6f50ceaa24eb458c9525c032c19cb44058e3254e0914b6949befcfd550798f4c81acab12eef3b60d3f363291fde945c2d2fcbc0cdf31a0cac45f2f6ddde42e7e324d2748e183094a2f0ef586f71701483c666fe1c69366215b0829ddea087518fda3766b04eaf16c25c2e9dd81e18804ee6bd8f3c8406b70283674327ad66a3797f0c3b79199fdb17954149f43d65d9e7d586a8f46c389cd24ff93c6930cc84c77d2408ae20b87c88a496c560e7aaeccbb039a5e0ccc08ff9c46cbb8104f3f5abc0c95afd44b3adc20f292fa6419024ea54f7802f45cdd7f56fa6e030a294a198c335c93438c569bbdca0b9c130de8e1387d1cd664db73b4adead5dffb4d4b08c7bb492f48f92cbd1b08cedcaff276a620ba02617ef7543c04455836c30d6ef53e26e94635c4505c3686e94f1255a747ed8a61f6c2e665b574d9d331b2744deeb2af8b8424a8a8bc79dfbe726cef508467c96d6c975fbcceb03ec330378ab38912bcc180383710220528f74dfa9dc1e49162562376b71132871946b7581e8f6a99a09e387aabd335de977116839d48a8fed4bd3965c5f9b74378cf49e24ccf80a04997aa5474b32350287e73b91297763bde16bbd4b73472f6c3cb53c974f809851237966d45df8c2be0865c7b0106d6643a917bcfe95891d7d9a7499ac383c6399d020eaff70589692014ae436c1da4edecc21b447ef8cd561dea7286290ef005061446d11f62e915f135da61d55572449e90bdde960b82c7f1f354fe8cbc390cad6b30af1d4220fe34ca78e1bbc63a8faa3fe634bb8db9e2e0e6cb83aab420378cb9cb53b4edb778e857ad31e4c4e61d4b456299166fecffbcfd5da19a481d0d1f6aeda153709b6cb6bdb8f96996a25112dbbc1cb5a4115a74064f6f87e0492b220ff16ef149b55a070940fa36cf843253aa6a0ff7fd4234af019cfae49b984ea190be7e2ca1f9e2a634d573b2924591f1510bbb6c9e6a61b5ce308333d8f4a2dc508f7385fc7947b6c53bd9c2a41a258115d372e952689a5eef6b302fe353f762bd0e28012691858849be553fe4ba2a2fef773678ea981c6dc23b45b12de60c25db843df7c73fb0e62015d61d62dda8cfeecedce06650568e044beb6ed5579340054906a0d161ed30e3247c79907c2130241e23bf516c2ac8c21e1621cac1e1326900c7bc9f16ddd4027b51167ad8565ca15b9c6059d55e59e547159c603a7e8ecc5d02f5dbe5c6bdb42ecb672ba77a80886280a0925e4e53a9239768f6895b5408c36db4f7841df03b15c389a06d5caddeea67504a8ac966aad98890fe31478ad5abce83c2c87165542b0a741b81a0113e8168e70a244b58d076a3c744f15045b5074520e08aacf3aa66a37a05211c2d97f179a344156949848688ef2883971960612ea387baa14b524fb85f7e219f55363d0f3354751953bcb7af131b7306b35a29ee368662ec78185c27c13832b6beb0c8168859f898633c275ba5cb1e895898803eb8673dda032dad086cf6dea97bd5101531152c4b8792e04b93e43bb60138a3d2556f2d8e9ac6244dcba545c95bbccc91bf3255f09f56874700f5e02bc73854659b299123d1a80d97d65309256fed8d07bfd61a35e7d2625be4cfa469111f711062319a441b5368ad435f544d961e4158b80870a07c16a7ef3b4ee1b7a372d21bdeda2a104f6f999754ee41e293486cb69b5947c2e248fc691f32b01fa3f7f89bd2373b38d927961b4eda49b57f746ed4031f3fa5d1a4eb6292bee97f67e33901c71e3a0747b24b77d3ab5817ec83db584c07d3efecef18b81f5fc8dd2fe25564aba87e8e87bdb846a495cd112d779c43d0a74a99424f87261ac94fad493bc79d3134604daa4f52458baffa45882640f6b8f01091d3793f0b1dae8489e319905c03662a5e71d8d9bea45657164d65a2d11451d062aa68ff273f17501efc8b4f231305a5101c03b75ec4cc425474a624e5616d560ed48fb7624e658d5bb95e0fed21dd161e50fdf12d9dbb5398b897338d2ef434bb3836307ad0f17b1cf2e12b8278a6d54b0b80e1b088b8b61a990929c411ef44f362b4394a6eb720310d21a28c3062571920d26eff6d9b813f63f2817a8ac8b9cedc67e971aaf6bffd2915f21e08e10095d7a55b3afbcd85f31a17270c52aaaa07d856750b15f61c455255f2e021478b307c505738e0f1db9c4e493cab622abe191b32575f4ef9378bafec0bd6ada9a3e1a36398fdbffb55ed205f914db1a69459c1b84dbf6123456d9bedbb44254309cd41707be0512985a45b5cccc232a550771df58fccc7be5c53a416289e08835086a0add6efa9a8075e4cc0d87c16f7b3a4bc8616309799f41e156fb4ec9b3df71aedd6aeb8de113ccba2a12aa1276eeb1603c7884445d2d6b0f73e252a0920f3c37381f56af9ac56de2934dbd52991c8fb1589182d8a5f10438d56037fe46ff1402e081130b22baffbef7443c1c3e527cbb76313765231aa233d65012d254a4de4192d89790defb278b40772eeffde4c3f55d5991a690a0810dc2b78c7ab3d737cf1389444e436118deeada8277cb0e8668de1cbfa25de181510f323e3a15ff5fd3ff96165e13b941a3610f3433add78baf39823e1316c0e93845e8957201355991cd60f16a38ddfb3ea93e88e4f645c9c676bc6ce12e864305d15497134617f4f486526bc76df9776d2818a94d6a4fd66076fb2d38308a5d913642c32438a7497882aa77174161970ebd23d51a93a4cb86f2d0f7b2108f41f9127c8edfda780151bae62f5ef178339b576526646e672684c92bc7bc75f1b9fc0161137c89212fc0d014f10ac45029fd44e47d62e5252c89beb1c258c124e68b06f72dcf5b611a33dc98a139f695189edf3c5aa8c0af3f4a5eba27428ff92cd3a6102cd0d06378a2d5ff99e9ad59862803a2b78a8cae0206563b62d2878cfee12ad803b9af8b947ae12536488e5eb6eb6f49c291513a57f910f02dba8be5eae5c81c2e3eed0df0687db5b0f0e9e8885e3b6a98e7993cc95eebc6603ce7a0e5b7691828f03b15ebe7598d301a316afd90b6ac5df23313c26c218c15051f9b2c1ca0502b69576370a33e8df4ab0a426a074bbf9e9eff7a42498ee5391dba5166ce8a07ea9d4cf9bbf51005a9c29387d8bfce659c4026de49c8c6ee8de5ea74d8dcb23524806f19e3340a0bfe07d719d0285d34850796f24bea652a510aee908591a6847ba6050f3aafad7bcfea8ee669b4a28c8f0ad13d33b1ea8c8d6058645012bae6a887acfe9a14d777ac0369fe760e8f47eb4d72080a3d838f583f19ded4dedc611825d9d7624edef3393bacf91dd738f89ce31507fa7bc22e499997d83f27b56900c223851972866857f254d11af589f47868881944629f165c2949555fae0e9a9ac26b138df8aff1022f409039a02391516acc203fa70b4003df4b7b4664414b43dfc4e1849635b66c1ea9d88589714d9ac9b1f84c70e60e160b28e2a61bf04d825657119fe800c404beed5f09141094d6090bd1c33ac4716464ca6cd6ff044cb09a6ea1e67131cf28dcbb067993cbfce4fcb6cd85a77d1658ab2de8ec7f58bcf7c3923ec692a0568b48f5feacf8ecc3e72ac24e502717019026917591e161b08c0e4bab656a8501cd6a2581bf7577dec839e23758442fcbb6588c9c806b1750d735ace1563df26fe6bfb09b6233a24a5f76ef04da586bca26194ae8b0e5bbeb6e24d110997a8067ccc33f0b52e2a9494466947e478a0d6549d7fd6b4e90cfb94479516b9ca6bc8ec19b6f417bb2434c726b34a730e456fd9623dc3671cd84f6e77f6370e00cccab75581ede2d380cbe8e060aafc4606c8433d73b83392dd7f95acee3d71d51fd61ea349412aed2d49d493ae164db25b8f3513d3c0ab7bbc43c6fdb66ecf3f06bbde3e4cd44daa156235c2eec05fbebd50976bb23ee8bf1c3089d5a7d434c517a4c4f718bfb4999a0279c429fdd80bdd6d6e53119383329fd40147805cde595f3d8a95ad04c77f7d363a2b4e7bbb811cb421913631ab75035ea84581ca91cb89e6bdcf7562d2941283a8efa7deead1076d376965dbbcb5fd2bc39bdbfa91af837068d0b006b362a8dc1eea70715f3e3e042ee47d35950fbef90f14da5455a03b0bf7d65e5af059c1415f10fb3e349c3660f83f4a0b5e8902678d540b2b1d86e1d61e09ff9a95b69d4daf9072a4fd96e565195edddf58a7a3afe49ab824538fa0e82285ce139374dbda2451f7d7a73b0bd0c8e8e594423ce862fad2135cb193d6f880a211678219d68532ed3f1162674bc2de30b15a9578036f5e1b27e48333cd9692427d887aa54903edfc51116d971d6bf78d9371342b75911f37f49c6b2f54cc2f515b88ec2562f0d752b926c65821cc06929059490163c049d4d8e82babc4f0beff4381e6ba1335d737454f990db51c1ac488a843c1cd48e166fdf3501867748e6510d2f05c6eae69bea635bb6b4d9d481e280b832ffb1b60596c7c92a1fc46a60db401c1c75dfc93b2220b9fcb614632cf05ff8a3dbb365ad3a06ff2756969794a64171600dc2f0788f062f906ec62fb880eba35b267fa8f7e0ef98d2fe7c7e638d6bb600a99dddcf2d95e45f4504c8528d9843cf5476cb2bb3b62145aec135eebd763d23d3128cde1915adcafeb57c7c74b57bf3df795d253d77e3b62c2d3668295681deb924cf94b4d731f965c05c9ae8e190990ab95e86318a0c3a584ca1b0988527092151ce7ca20e0920e7f36146247a2ed7ead4f983e84dc45632572f51e6a644e3ecdb7e777c2f5e8aa78bed0e4b0cdf45869956b89a107e3e485c61b43e027f705ba2ad3497cdbfa28deea7ae5954339448a37f54fdf1327a627538c2a2bd0550c084742f5a8cd2d5439e3bd65b4dd640dba3802a3140e839d95ece50998896e21373724c0824b7e14bdfc9d79c8f6c13e73c4e277657b65b5d496100486c3c62ccf84a363393ffe274b9fc3ea78b1773da4c486e17e083d6fbbfcca64252774271d543378e932b0789062558da8ce3f356f0adc2990bbe5506294bcb9463c23e253491aff74641f30f44fa2ebafd5365a0cb35b9e572d50dc8604d9bfd4892f87c0627de7b7044738dcd41945274d755f577a0d82ea115acfddebf58c36975008fdb9a05a033ff48a72e7f737a8a5c20fbc4997a8830bd0c47081f15074d14752292760b575366b71e62df9925e324d8031fc3b071418c0f12c8b7f81437ec1d911f58e3521e145c7bce7fd912229c07aec1bace24222b90344e652b7f81744d8a1a6e90140dcc4831994e104c0cc0e6b8e2463a0aa4c7fb8500618112643bb7ba4ce58e778f5826a981d596e70991c60b2cf48b7a9e8a9f91b1c6485aa1782a24d9432c65dc3d3475ef298da32d15cf7dfc47975dda0e2e30bb663df68a92a8ff5223e3d8f3fc95c16709b9c59ffa59fe3b7d5f6ce1921649328cb4a2c595d44b5367c545859910b2803ad2e56c984ec96edcec83fab048e9bfa2abf3c80d3a0a5480a4db06d1d185943e7b3a89cfe04fbbba4f5c31bf07274f4cd7994aa4143d63b23a5ba6b31666dd428e1de96fd402273e111a00a46fec4ce76b742273f644b098174530385d65fb94e430b8f1bbb96cbc78df1199e91bbcf0b28921e1196a37d3a85e904fc9b7bc778e29283dada87d4606c27bf92f5ce3cb3701f00d9baa6e9f98ecc4aaf40e84da661622ffa31ae9c192f6e50291af61b8d112830","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
