<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1574ddcdef8c9e0045dff886c6b1871236bbb612972a23a78b2bfdcb174dc31a3b6816a97e412b5a0212e21b9113f57806df401bc72a4e4da1d3eb7df392e8307032a429ea7fcf8ad11d9c66a2f4c99f5b3308589764d73bc31cbdad8227d55a95d43c9180e93516185e9f4e7ffc2225a470b5af07a7c3973ac9681d994e0c4287f3cd3324e142710cdeee60fd525209ce77d4181c2e42981196caa55c606e2153f46dad87656ddc102a1cb53d8fb016d6ab3b021c117fd6a24af8d99a9b1fdd890673ab1b1f5012d0b6dd68bca1fb14463df2919065a0c9e1e1570ccfd82138abacd28d8e66a99b4bae11cf658e0e42887a35b1b51175a8530d0c12bb05d733714f80d1f01668686c461eb7c05195a764bde8f4d4f98127769b39b3a5cf3535eeb5e4abb29ac8e73fd8cd91890ef38bf700a441e890e274f5844710b206e9f39bd944fc200134e390de5d111409ece8be75bec9a8ba82068378eb2b9e9949cc1c7adcd5acd4ff4f0e67fb7e8201025ac35b3738fa8f2536d65c8fee6c7a8bb3c4005de7eb062fba83cbfbb1245a1b0cf4a94653263d2e47d46157e9dbeec005e467cbfbc9c3b772aa50144f1343d362f45c0e17b2aae2763bc1b55539f472699053a2bfa19ef06b2d491934d305b8bd955326acdebe0eb2ea020a0e4fdae08102a78525b7541a265c43696b488c58569744b13ac575b919fad9c5fedc26918b4136e3962179ddfafa887b1d8788a189785050520a83653fdaeefa5701fb1f74f174f89e1d844d8c8ebe79b754d1714068d29007bad6bdbdeb3954d49ba89acd72d474d323a10fc52125f1a778942536136c3c769163a98878fd73de1a1bc2bc8f722ba471875499c9a4d166bb5fe1f21cccaa1a17e75743f7694dd88ba9c57f800419fbc0dec8a5af93704a32ccb0eb8aeab489d71a481d525b3b42e62a6ae1f78de6684a5144e84d8388feefe79afd9d0d5c55bc97190285d2490b1e9ca65bd6a6d63a658863c442810f63458584bca59bc29f2d56b9882dcd0f4b23a46e19c62569070f4d0edb7042ff7de909b473c9e0edb68ffdbb8d4013a700a6ada795f75ab21e986304debc579f5ca69b645436a336b9d0b5ff9dfb68a43a417eca7edd0758f7b137be0165887b87976738fa086c4fe6bdb610b31252ad7addfed69506047270b00d2b92ef3c555dd3dcf76fc8f0a537a057502072c73b72a0d03b978d9fb5008ea104d49d597c00c06fe20d5ec17d1109fb0d3e29be9f4ceed8457a31dc0c0b8b09a77f24a70947cb85a8b9422e18cff8bfde76fbb35705eab0f4860b66ff96803908d9615a874ee12b707821041997849219f1c12427c7aa74bc224db361b10ebcd5200048e54631f0c14571358fd3e5ebd85bc07183ecdc9e57d7536948a104cbb0014d1491bf92ac4c73b09872c174565cde888e78e82649202750c852933ec74864ed0d97054b7a5a883ee6c5132472fe44bd11315f2c8018a2e0caec3e9c8e38d965db84f68a5d527d69d2d0b3ee821c37bc3abcfb508a477fca0ba3a4bcc16e6600c2e537428baa52afccd5168bb789218824a634db76ec09fc7bda34381094b9e4fd1951a45a5cc3519ed92461695c698d6b1a2c4a075c71a1b917b5abb6963a04871fe870da4a804a83bd5f05da6ac5bff0f3d28eba33e65ffe45dbe5a76743d0db916976c7138b3a0d0701341ec4f08eb64f65eaf028df59ddebb1ba0ddd9e619e9cc7a4115f6d0d06de218aa889a20abfb721103c0a1e7bd098f0c32b79eb84b48cd3e38b91bb5c6601c571df20c89929938e9105fd157bd66983119462dfe2970d4c3e3c052e40418fbcdd9c77561726e3337eabfd8a3c452a18b6675434af5d49596319ad506579ac1cb873e6746490a4081fcba7dbb9e15d1c30f674b7439979c4e86eace089ffa627ddedad786507904660fda7c95f6cdf3ed15355795df7ce3163d49f8c3e3292341923678fe703ced95183062655e29e62c54a05b91b1256100d6289db71c9b82d8ce1d4c8fa16e79828ccac3d0ad6cb0c436af2a3435a100b73d7fbdd45f03bac7d85e18b0212ca2003779d24911140e4392500bc2d29baa8ecc29c193d2e4c4667a42c8549fd830b12773c38f1fd7c5fec57af7c3cf6378bc909cfdaf7c726775fe702317c2034edd5d25a2003a7644514ff17dc6acbda9e85e69021a12e1acb079e448d023702222ec8493799782b42b343d123bf54c46764524078da055bbef3594c78c49fac3e42724993ec5c0783e28d9842a04c489d1557c270b4cb92fe02a15b1fc6d279bedbdb987cb63a077944bfe17a2f28a0865588f8e4edce3f2acdf8bb424b9a8c01cb7bcb35b715de06d53871e220426b5f42283a4f5eb6db554a3040cb03a758e357731c2bcf031950647cb7be52350196bb3fbb27233cbe2e269ac4ecb9db265d28380ad53fe9453b7bae254c015a1aa0cc98b00d492c997b2f0fa6a9a5ea8807df75b5d7f14f6ce405928a8fbf121c019d542118166a89ecd9327bbee69cd9487333a9ef96b0d5d5e80e241fefece10c93d44e52979a6ddf09cea26e344ae308546a718f07d4c66bc80a2943227d86114cd8905f99c3a7724cae8750ddb74b8f726c4a24ae12e5232bddb854c95d0bbf753c47830f091e313d564701b44417a54e5b5c6a97617884d5eb961189403dbd79ae78880e36353928a49790470be8b8e5d1d80b4dd1983899cfbb6a98161c2b39a454d87bfefe4fc477f1dd049fa713f2a6adb4b0f9185454e0ab01fc14c4172eed93abc0457fb9b34a2cac82dec54132caecaafcc995946f8eaf6c5ebd079911ec8987240a3a748b916e008b5c9bb9404f3cdfdbbee773f8f48ddae5e5b84732eda990803ad6c7a2a93bfb4f89e158aef44fd0d3213f23a91fc42842676086b8309f256822e25c1e2b119028c38dbd986546e5125c8e67fe75fff6a87607ada7f88e0b077b5f7629a549305792e1bdc435479cbe11200ccce7f1775dd467f02e2613aa71838805a591999b3e4e6a570874e58768d70fe48720506dbbb8a269c3c621b63fb352e181115796e8a961b408ae2367e31f9e20409af8ca7a73bec5ef5b6366a7936d3aa6d6e93a3bf2558274b11cde6d44b06cc9dbb51db37ee25a450b79b3a01aad3b862179bd7a470316054e92aadd20bff9f5a336bbd1aec399347f31787c2985dcb1e2dfe0daee4c22712437b0dc806138cd914d6b2a06302a6f7354dcd811ea27c93712a4345e26144d45fa5a1902517272ff8f8f354830eecb1e16a8e2d3848c7827bfc2e57b5706a7c2a205298b6f4fd6ab9cb20023ee8ec147afa3d789ed67de26dcc6e649078997b8fb7517bc11213a2aa6a06ce7e15d4d7f06e8efa87a0b38df05a0fc6cd07c7acf81a2ea4ae9f3de23a73d76fd7a762a7119a00063ae90b204c37a170cad15dd73c90c68752f4ad01dd2be5515f1df3deedad7d40927c1237637369d5f3c2d9a6f4ddbf3def2617607794dcea50a8372c6aab8f6e678b916b35ab7b23e9604f43bad73cf942db29f66d8e6872ad784ede1386db320b1473b3bf054b12f32b52e3a9bce0a9047e02a671448d6085d68ec9c90dedbf194aaf6dee83c97daa5cb9e45b7b6524931110950f9323f2ac23c124f6d87c9d58e9b749efe85ff54b2ba2090eb9b787fb2d0562ac95a42b809039039be3989623a6c732fa8de696f16b06a7d0b0a8826bb48601332dd18b10bd56cfde043deed639807529c5a83370bbdebdcdff5316380b35574ba3d37e06bc9ac2dc60f39f38d7e8cd8ad8cf2f0e03d6edf833c6f4a551b8b625e9abca2cdf7e92bf97c27dcf859b219813a0e69ed305dc6725e034f78f7e14920f094c6f67132fe27c7f50f58ea9e1427a949769c1b52f4cb9378bf92207acab7a0eaf2d5d7e711e9e00016f9b2348c80c27bc56cbe726c14d39f0e5fac24dcd4c79f833bb239641ab84c9d9a9d9db379e0a549fa8935c797666bb8444de6783e87f00bca2e76f8e660ee6193db8c9cf0f054d414f7fb1cb1b81722e3bd91de137414f9637adf8aedcafbdfd5f6224c21ef540e8e25ff9f6735bf40b32223337c65814de300e6500b5f57084522a0f52efadbad1d400e106215d103a270b593c99dd6fad5659934fe60b7c4236b17d55f74b676734033b32a73971385080b5f9ece0b3e740edff103d0a37347b6c1a7cbcb3582fe829df2df923aed46ac04d973421750c49e1b1798eff58fc2b737c36bbf0c016aeb87009278ae4bdd5d405af6e4694ed7eb34bb3af7ca1537b716684ad30257dccc2aed67a5ac662f0d9b5d691956261be5431f8186719a81d3bf2f143929d48b312bb0a3630c92b399c0e39e1c249f80edfff578662111fe107c56593ff6826ee4aaace52a34310bbba3d94bc66ae67d68819887e5b73c12881314fc77eae060f4717aa457fe7122f113a5d3dc87afdddebeac98fdca446686494eb320201cff156d081f184c2788987ace56dd653006cc7912ad7a0b3062ef97a872e384e5c2091b42f76b61a25ee9e75083177d11b5d45f0573cd91aafecb22919f6c35234e4e159f76bdfd3894caa5d5b26d85f5b4e3179f1a6954b895a7e1779ca3c435ee2474dea782b649bbe742fd2dcf7aef99744f05e076f3a530f21fcb27e1eb446cd248585b7820f3c635a5180ac0c1de1bb75ad81e3735a9e221eefc72624bcd273f45cfb4571c610521fade813b61dea678fa1c3c87efec8274fe96a09f813ac3d995835d3e02cf79bdd3e3a5200ea0bc766817afbe99e0a5e4351eb8dfa84010c81b3f8a4c65f540ec81a3f92a24a620e6ae45595c787b1637b1e8739f6b1d1f3664a4163bedaf9c166acaea1b58d37681252f21f290849545b453be16d60d3ea74b1400d153777369dd71a61a35cf7715109da2d3ae7e053978a4e8d1d3958ac777d69fef2d0eacda4f30f7260bebb1e189ce3504d3f577f427130fd9e453e92a0e79d4d17687f6e331706b8b4cbf8eeedf1e635ae75ce69a16931da35b8fbf162404dd0a7bd9f494cc24896605ffe1f42a668b6b85bc365ce0a0d72f47f1a5e2f62bcd4058f71fa795c62777e10c67a0a9a5e8d5dcfae1d151c71bb074267e56d719fdf54e506db99a66111746645393050148359037a5d9a885775902e7e1402a6daad2f3c6da2ae7bdc196d1578781b3cfc81d25343d69749a8a29e38fea923306c5247ec66e195626806de8a6e8f966fe04bfd94284428cf9f0ff105d04333d6c73e11632cfc39e393ff4ed3ead39a2899bf5680bb37eb0e5dc359024ff63826f333b8828ff177c01e64c296e646fa14cdae54bcc4ac411828ff0589d583a380e303d1a72f65fd66a8bbdcf94df1454337b2de3dbac2d346718aec143a29325a2fbbd896ff25d2645e0f34d49b18bde065c64640f15e5d70ab99310cebb5427a035698dc0c671db73b429ce04861c46d4b252b4d2f2b25a0c3153dc8e0be5eb994205a461dffc32f0623165316125e29d70ae9f265d3015638c37cb4399241e6779ed7c9503d00f05af7fbd81149433f506c287065db4a2b752b480542f4f0ea7041e696a84a47f5ee7bdfe8894956538328362332f1c264f868892472cfdbdd8e4663c3229fe1f76551717284ac35b52a1dbee2ac507ddb301d297c84dc78fa347cba595c32ead8b03c5fd74111f945573bfba1e25b13747a8dced5acbde549f7e4dc448a6638b297c5f0057c007af9ea3bcbb9fc8d7c8d3dbaf4e9c7943fdd0aa8c45bf4444ec34a4d7225dcb919a0eb2b77d2883a827ee8c010b2c76f6c1ea9866ac534ece47287b98a9cff7b28bd2a1623e76e7303b01740c378e5d66f9f2bbee545a312887f537af8db601bd88451fc41f61b5091cc3a0c90d1392758d4ea001ad2dad2da915d43f3c6c5133d22788688c6d53500728fc06d99e5b6dad35ca43a688cdf89a171ba1c5bac23f07f5dcd4b917768fef63f9ccb6abf8db2a1fd2efd165fd543bcfff3a7ca83a4cc8d9460bffc5ffb8b22b41382d5feb9b88ff9d9f19448621a94be4dfb155bbedb87e806dec79d0027b5ecf3a0d6a3ebe76af08bb648c163da08ca035e16d2399ce732633300575083fd30d295405b8f6b521651acf1f1c7d2a44c23a60ddfbd7c76b8007a168326542decc79b9cf2a34e71ca194e064a436ae8b8a0cbf66820e6e7cae7460159ba6e34c750fe17ef4748f8ab0d25d9ff9f2c5a2a1dbabb4d6a9a90e9d7363a8d212e298a6ef81c79853b446baae7e12c426eceac7e2a734401cf15190bb8791bc4a5fdac35024a8b9e387d33476617274bf0b3714abf0056191c90b68cb87ee95eaa065d4fe062462e696791649e485ae8e2cf9d8673d36f579498dc654f654f1a9a073f07cbde290ff2e37e7bf67c0f4edc978b2d818b8d1c5320d0588d969c7e333946cfd8587b786f76b6aee0e73f4dca1a040b6ce49d271153fe0edd5ebe6f5ff941e634a0057cc8289388a03168d5ad40feba9dfd5c50b1338523f474d76bf3623523d37482b7020cb3bc956e3b0c0ba167de7a11f8abafc695c3023a06752b9b4a5ac067ca035f76282ea1aea3ec6bb579eff53edef67420fe75fbaa4c4bfcac4b796e3e5a9ef613fa9eb933f7e9431c3b530205a32645329c83d1a142d4f4150241c1bffefc275f22588aa67d37781ea9c542d0473ecffdf40a97937fb49bd50aca63ae56806e771ab21efb4896ebdde03d2eab36cc7e32935aefd22710cc0620e6b0b08cabc21c551f402c8176240ee93dfa6b32396f88a55a4ea428d9985b881deda8e3217455d9bbf935c7b39ed1ee5a40a48f2ed2870692da48b7e448dfe73aa06ce9370e5bf0e1271bcceaca6eb5b76ca6f20f399760ca3690cd1a94a84bd4b7cac9583673ca0b044eeaa1b27cd989c93c24876ab809f6e5bcce47d6f1782d3603c48c6592630b8a327f3c7fb19fa3e5d8c0c672ef00f82be12a5df4f362ceb56d3018dcb9bf9a48c0e6abddddb5acd4a0a1ef07abad4267d2bb4fa6a30774c5a0ed3baf710f7e32ffd0d5e47009f4f9765e0c374846dd1da349bf036c7935deb47a1783f634fafb2bd260bbc6d4003ccc90340d57136e632fee76d2d4946fdd380b78ab99cdb926481829a27bac91f5c975a9f037eb6b2dcf89b7e8cd0b6453c00e925c70fb27594616d68083f3217d7c7a7b12988e9b27585f13f12b6d7c37058feccea82363f67a0549ffc887dcbd2eb1b09f10ecab8477628559c742285c45af547deab14b2ee2ea7d7d71cebf344bd8d25f0d6666d9bf75f98d21eef7aed0aa4badb6624989172cbd86122e525429e5dbd93fa77085fe74d2cc5a78dce14bdce130b5af71f2d5c7742569ef3d602452fd06d86fd2487004e51f5b3c6a318d3a9073574020dddb21037b644af518b29e4d26986cba3348336335e7be862b5a5ab2cb1b79bab647ea189a53b677c1edc9dc5acdab2412ae5d8b9d0d072d08d4c6913ce2625ff6d57e9fb839e720197996c3b2222626921b2596d098338dec317ed15d4114270ac7a247bc35477e843ca9bc394c59319c983abfe382289ca3254b5167a827d73502b81b28007c16db2244a99857dfd1409f57a76dd738dc86633ddd33cfe7b5f0ccfb46f9285c006b5f90b33d0f03bb587d20a76694ae3708ab4a0a234949f4baae865b5067d7d85a812332fe85dcc8542ccedf7a25c03d30945f822b7dc034d9e9319dc1b367e3ab3b4d96a6d4123ebc45d77443784693403123abfa68b569cfb36973298c8d0c491c0bc198b8e1cfec7538f56917d324f652249f102e218bc8fbcb42263ab458f4bd7feacdd93fcd257163bbc5e4c84565e6d6a4e3ef64c730997eac6800b2b242640234a583cf4eec43adbcaaecc8642ac1a47e13b1609234ea8eae7b94dbcdd063862f7016ea13c3ea1cd4f723554da8c3b2775eccff69f6c1f5bf1e8e9fc4ce1725a40394126abd7fde8594b3bc383e8a6ec2fc7e2428417f9811c9b479625cdcf1c0889387a990f13f152d3f1cd3dbcb538059c222760af4df26d4f2a38e452af07306fac35f8857c70473a932ac3c15ed0b424cbe2b8ca0af556cbd9787e4fda5c44546390d8be0f7f7954aa5e9d4c15584d4460ec666485142b8f41205f7b8b1ff2ce634025654ffcf4105f6d7f3c83a88686a08f492642cf62da44887212414e8b4930c69aa960a5be72225db08a6c6671701fa343fd6772577756cf5dd2e47d669de322f175c32ef4189efd34b87a49068e42c16bc91b19179ab9d185c5411cde350b90816be4483b44602384ad2dd51c237317169c21c3b6df2219facc224ade800c76a23cfbc025824686cad8ae3b28f583b71604b1295892065ee69990527c0f2ba0077c4d8bcf446d6b20ef73ce54ca4ef1775fc1fdc878c23387f12e232fefe41de5e7073dec42bcdf05b9eb19f6cd1b752c771dda35d0b577b18cab42774f57e3881b1e58cc302946c8828c3091144fd29a89e98c0f5075a6fc61d1219a122335ad3e3901956ddf75bdff5c65ce2576b59e7d9a389f4d838003a204cf16c801110dccc134fee47a80be7acc0cc7c6546edcf793334115d9b5c46002e0ceb97ea4dbf0a319c6317d94dbc0513dd65005e969143e5f5e35b276b7c8eff2f13ee6bdcb85214e9e8a1bd492b69825eea82167e6472a00e226ad049fa2d477c62501b5cf08c6494c4fa3886a2b33c495d7a2d2f5ac51b328b982eb4f02b30b3f69f1e52eaac54ad65444912c4a9d415ae1f5b961c9940b3056774755013b087d8e37102cef082d7c06b73b917f982e0a6babd502dc9c906109bad37e7432f8f69c334dfcac6b947b76132c06ccffcd2f922210ae54d1217f115d25501ce2b1c2a9811d9ca76b8477d2a3df0998847356dd9fe773b6aae1178007566ab3e38b494a6288aa65cdff98d353df0193f04e301c140a3e7d27adb49c011f6df27b6b87bcbed510ce0346886f52f3e0817d9242e93da29a8ced2ad58f69ce482c94b42bf20d8f769dfe3cb233a116ca9d3fe7934fb478812b88b7f16f9acb06816fb947a9a3279c4ba9a0b2d25282ae6d10d5a9fd609aec9d3460d667e870323290475d8b8bc5d05d4389acbfce1ebc9e5e1137092f78a5d1cb8cbebddc3cd22625bd225a8fd15f650bacc8c5bb8936eedf5e2b7c4b4e688a0960db3360c7db89ef46db0667057be8ae7e5f02ebdb893b4ef64d449c2a0f00f3ad52a4bfc1c1b297621d6b1d28aa5b62e6b1505fc5347f23a563e45b7442020e75eceb9c32d2ffce24e706b20cf6bc2cae81ac17b0aa949551569af1bc9543eeb731edb539c2d74783d23b024841530eaa906c4ee7d94d352d05b517fce0ae416c7058a135a7bdf72768b905f718f18a41c368b658df61cf1d7776917d556d80edc223e61851c6ab3e0e7710b1126afe79b515e3d2350e76e551f2bdd016719b4dea6b43e5b5c1102a2721cc21b033acc1aac7428cab2eab5edcbbffeb33cea87ea5e4ea768ed72151f61c6ccf42d795e3c3122b29885380b5841de0ec8171adee4f7ba59d817fb14c70e5daed44a058378d19dd36eebedc44d471543ab8a990b91eb88b4f5ed9ae05e2245ddcc69f998dd50af60ea4af70c111401511e939e47fda2c3b83c8fc94fcc2ba9d972c4d0587a4950e9472cadb6a61d594f6255d586df856548cb617eca9aeb81cabaaed3119f79f3057fc7cda53005be5ad08bfb4d41b25671b553c99d494bdffb3e643afd24291cfeef472a937120833bde833bdde0fa75e692a6fb89c9e6d07ea006e7d37795bf339a596bd428f66dd147376a5f9265d70c835abba95be6246d1a6f4503c1a962b1e1fb188a52dc6ce735c2a23e4a529bcd7c0990913087aa232747459047952cc274785f126254215802705ca25a55642c17da429c9857406ce6a20de6617b9682c36e8f7f32fd88f4a3ce7892997da8d922db7de215ba9861fbcdb97b605609e40a166dbc51b175176e5794458608bb0433e06496a21a7a50df6f28b81e9a19cbc3c7ff05715feebe7e4395335de7529bc5283551b68d6ae93f71114bb5ca6ad33427a02b4dc904a3aaee17d2299fd87de9a2d777414029590114d6f2482d6107cbfcebbabc1a9f2e999ed6670121ce54a63ea5aa7b0c8a9471eb2eac9cc4ca2710d59be784486ea9301441fb7b07db09cce99aa73ff558abbf90959ff9abcff9410b06dc3bba7814974083f7031b5b4fd3479a6dfbe51e18d5618bb2319deb1b6b2168c9b0cf365871f523f25820f56cb6d650724ffc017936d0261d6e1b46e490b9151bf97bd0113bec85c6fce5919e0f4ee4fd6bf7213624317ee690c161b80e5f53b8a2e0d039dbabd34a86935603b0bd688113e5194893f3be5188f66ea3f315b0bf92f45711b1ed4f16ef0b9c9bf8d6e9a2e7d8755aed736f18b8625d3481f3e3f1d333d7271614747c5b95d109d9cd08cd111b5fa587bbdd38f350ddca30b9afbc722e629d7f2fa9c716411226c05183cd3c6ec4d000c44d2a289a61f070a67652793060aa6a5f304287a781b29e47f23d7f584128e1ab7c4649a950af9d71f4e1a133bf898ed47cb3f3251332f25f4ba245f3c9bf23fd802ef236ef991848735d2313e60acc49d34596604a157104875be61856fc7f5b38de4afbd025323077eb1aeaa5c1bd827f8c84584dcffde2f9fd56c5fd576f7b6602f97f4e1c264f2ae094a3e36dd41a0ea02ecf75a1f8b7d7b336fba63472b595c903e1c498287628f74b68aac3906a676619e3b997247ecdf9283f046827b5c015799d9c09e087e1d6282992f8ee913d1c88dc1008dfdb7f3103a2efea9620757ea5cb60530203832532fe109b90294745699843594ab2b58b0c4fffde2963df1c09c126e96a298de7e26621abdd13fa7764f2a9e7cec9be2556045f392de07f9c63e7c8e5acb5ed64e32d0edd6b7809bfd5fb88538f7f0dfe68483e708d25332daa58bb31cc641e76daa520ed96bdfdda7df59f8c7e4a9ef5cac6bd8f36538c9f89289c9072d5a5417cb117aff3f55146cdaab21b6655b664a4106a3aa61532a20449bf54a31ace077e342b34ce03b1892979825dbdb488ddb556e927d7eecc3d29296b94f0fd2ca2c0bff1689bb991a84f8bd16d701bf041d9feb359243dc32568482b8e574f55bd126e93e370f8f1cf71b96cf731c0499ce021d8806ec21c93553f622ae0ce0e4fb5e8dc1460cd03ebccbb86151649f7ccd9b9b3c5e3457f9f418936d230553f81cc2cb369a0fd67958c832f93249c9b5b56b4878b73c759a96257415b2c183801a914cd83911165a77dd96cfbe218728b4c8708d025d2f4973f2e81c2aa56fc4ec558d4facd50f0b38fbc1474e4f6a56c75fd340135db43f09362006404ae1c9bad5d11c4de99ab652b07e6bd3e524749fcffafa77c2f1efe276f428ff6a3a205f1741953a0f10134ed95f94713678fa5cb9cb6832f2034594abea1df009392c66c1465bcdd39f5928abb4285b379c84c7f6e8c694f84b4f39b00db18c1157814f822dd2cc67ea275268b203596e8e44283bf9a0722f9375c9e0a2697e68d51c49c134da29305f1f456b46abe6f9a3079c88e2825c9cf2c28b51383ad7aacbb4a4e0db872c6073528677bf080dd4d4855e679c73cb07e3c743b047578f1eefa75d4bb0c59662432c54565fe6b7e4149d94879ab4698133e0286b39aad290e3647a52d93ed3a2ec917b91e80aa07d1fa6ee6ce281b31f625a58eecd789fc27e70a50ad9ba916890dfead6a9389c0f3de751a2e26e045c0de4f0b73a96d222e9c25166fcba020ed9007a4da272c6433c0a1cf53736b8e0ff07644edc3de6c1921931da166f81c1e0307a1186f349f8640db48340c4630a71ef3222b4facb5135d2b395418bd59db43255dd47159aa179ecf03bca92973060b3b784431923d8a330d93e86bb04aff1ee31b0b24b876e48858eca8a1090b0636f5374d205e2693a5a0a33d53c719fc5823cc2cc6c50b620cd6ea575373ecf61e6a835968f784bd50008cb2f24979dfedc64431c91098fb119377fab12b112b127a7aba8417369089e86d1d493c70d9423ee23ac4b297977839cfccce6b695c15efd88f93dcf397239dca4a0579554d037f8284f818695619dbd0576a181d56b1d2bfda0a2c7fabec48b7b608cd12e4389b06bea689bf673f7e9281647737e895b00207e3ad4f1fee0190ea5cf49414f1966a0f820ee1ea115a2b9bdf7b8066be0841bf42671c48377739f052808c8a85176a17b1e25b6c82376e0f2e159bedb3fe895a3c4a342e948c541cbffc53ed0ed5bed6e9019ef80490fb83614eb5ff28ae8a5b759e7a1caba1189b86582b5b80ca2ba8c5e9836a1a5fbf9bdabf673e37666627a9e37f36e91edb9860d9ec214ffc5711ff950bd968271ddb6f1564c7350456b0a3bb8835479e3918b16fa359a0a30f9ad543c85951924f9a71cb801e5a702f98a0ad4810b3612d6ef6bd56df861adde6ab3c7a80005ae04f2327254458e4b5fd44b50b51c34b8fc7f27092a3b309ad32220e883511142b086063b24af3b9766f8258b43a4a9b7b7c2b49c85beb02715be53746ff800c1e31fcfe51938c3c56ba32f3fed8e9f1d84bd315fe7fbc488874e76532bb69bf4641be7bd019be570ac62628e0c9ffd37e92bfeeb2c8128ff04499a87b4664b4f5a7b6c92915cf0ba647bb5049312e20d2c2b771774eb3f034b288c4c84697e22505bee0a94a0da2de9b41fe057076516bedec922b1b116dd4ca54aba34333ca53093cf3ac3b911f4e8aa1e0dbfc4e4a66cee843797551dd61742a7b05d7ff93ff0c1844dcd914e2aa2f313dc6ff0bc3a2f8f3af808d0efe3a835840afd827ff4fd0f0acf538a6c144ad4aaf1c42467ca8847654365b4b8b71f452678eed588795cda0ed270dff06656ab9d766a85327b32ac9fe303e02de5dd57d846aa37e57430b60b2059caa0a9669fb48ed73f728cf30a76cd0288834054fbce8f5ffd7c376845778ba066a05e004585c590ed6738bb4f643917f34449963560ef4a4b229c28646ab380bac1354a53fca3e8b8b716636db1e3f8b9258ec906dc1a5b506e1cabc2a9f97feb34fd58d2466b943e370f28a4cff1340f2c02b659494af5fa7a73c827e20c48b7f31133e25e4685332bd6c011f8166476f0ae901a0a136f290df39e9ba3a3b822d690dcaf13da784297acd13ca9075af381fce464a6bc9d0059ba0d8805a18114d27462bf95d34daf66de1755b21a9c55e39f22d8d7b31bdabd59d3a0b0548895e8e8518db588c3d5a4c439ee7f50a3e723150318cb6c6770d025d745fbe92f80f8fcbe0c672584f8d06f6798ef0c56315e37df77306002c5faab56de31a7a13989baf328cd4ac79387741d14542e7c73f62ef7aba08cd5befb24090a036ca144839c77de3730b4095bc4e3824ddec8a15d449024cb0de89daab65baee2fe2d74177a26bf2c66432635930d5ab025152a5ad1d0be8b59e7b3efbafe2cf35ff88e3d9f0a357a23b6d3d53e31a4867dddf94765cc127c9fd87b08b73d3f23d3c8402108094e2936d3727e3407f77404ffdfda768c40e54a602cac30439ceea1b70a11949e4dd14f45c69dc40c5d9b61b704565c2fe45e43b5aab4b4eacb117de04be17d52966116c2cd54b39bbbecf4ee5f98bda7ba22b8a7e5c5d60b2e8af8ba7a9570d71e82117c2cb4855c35ee866ad3873a983bfa13dbadd89a523408f713c74613723040f771bf34b3b5eaf8e78fc1eb474ff2d7ea2d54683878c8c38e2618892d301c15a1a1d1d4d52f60716ab62e809e029ae6d5ef52e00e33ca8815ab08f676607047eba12dcd0e693dc7e3c96d002cf120453d8c43109a203f81d20e99fd052cad922f4985a29f330094b2ce466e9759dba9ffb82f41d0bbc7ee1d833451eb9d1fdd3dc93f1ce209dd3afab0b96c70b8c614a5bc64743f8f69cd3411e47d0e8ffa59bcdc12ceee7a83c69903c6ebfe2c988b818f49f2ac82e74f264fd366171c5332436bd379b06dfc9186c8f0599fb7f4473a05511cb751cbe5316c5ebd58e119f2da2de65d8ecbf548c6fed806c913ac3d19c5d5b7ae3181872c42cef0fde5da4e6734ee7da61ec6c53bdcba66e2b187b2399ec10eff4b71020cb0d8ae702d990a057e822fa43fcc3b186184a70149afed1500704cf7d08db88c9949a159ed0a180db98bcd5b30739b06f47f71d23b7230ed46139346a206a7d1a8ca6815369ba5c23162b2f823f81a528329925a3e9fd2f257a42c6684563fcdb9b433ec5861312236c4b7ebce8459544ad0b66240b002aa92c547aff53a6662c62f7be670e0b4e2debfcb15167ea8a4ba81aeff47b13d5524e04e194c2934e5fe8cdf27fcdc67e40ede0ad65a4e6ec6f8e665490b102d42778c2f7e700b745978d919ff800dd938991f8c94b78ea4bc270b51f972f9036b3fea4ec6928d6aed7b20f98bb5846c656e02a79f23d9e45894327a44ec768bcf8de6774a17fa26903eab45eae8b64f6ec89a35a64e9e7d7c84463996d6527df05a35dcbad690a7265f8148f23368c73a893b7402e438fc313f66af86010660752a6f8036ac3440a8d6fc13f4223c223829cb9ed05d3adc27de4858f48e2660da7d99d6ddc6b2b3edcb34420ef79bb98c6f7e70becaecacc5f05e755548e622da53f4811ea3755ffc995e29b9e9098b99d3ac9180b501b8044c39af66dbe15ee165c327d84b6d5d39f46a1258711b6f543ab7b728b8e73c0c9ef173f788c8c44117e9a40912d87dd53c65256ebe2c90b2eeab90b42c185f08a737c0b4e426c9c9bd94125395d141b43660e8ac461b53f4a111a5bbbc81795085cb814bf8c7aa0a5058a82c396a12a1ab0b1567718153a1f192d291504cb5891e0ad16425b210e89caf71d13d47a0d074c7fc5eff682ef08b05efc762a40876641235ad03f71da08fab8384025eafe5ebf4fc92c89e6b5e0a081c9c5a0410c4c5b348db80bccd2f73af4c414ab973bb0f78ba8b990c0d527e9e35ef58fe2cef897c5b8c842f0078d73806da6b0772dba4a97cda6d806de0b2c147b50c765162bc4afc177a06b7f94fc5a39dac9e9d065535df8c635f224127ec3983fdb28626490158e341268e1f90718c12877d7e0d30c989e581665e94e956206951be13df9f77b770b352632010b64125fdbe74170b56a3c71b9e9fb9523e28ad9653698aea1da89274dbc12a163244a76dac5a5f53f1b6b2746dccfcac3890c604370dd100cd69f666de50f546e53ddd92ab0a1f6188bd4a9e90582133cc63e57d46e657b78e41c56bb02e2d1b9ad764c09e6b92afbc5fc2f83c1603383d9a8ebd0ad1766fdb1eb1ab63df8d3bdf365d74b5fc366ff80dc5c87c2b66cebd221b7eade491e159f859f300921641946c6ee20d1558f07c2d9de36e0f05a1793f59c07e253458cf109e09e57a16976d9b45b342c00d4203ff3d5f8e272188040498867c93da45cca7d0d50cce95ecff6a206e782460835e662993ed8051e1e88e98c6f195063ab3010eb3b6c960553d2032a7bc08f1cbeac7bf1e60de83020b61c865691cbfc484e0841cabf21885151305646aa69d35001e355f138d3fd758d3fa0f89ce4b80274457541977f6c915b44585049846db81d097c8529aa6015abfe794b6993641662e64f0dbb615d3228fd2156b7ff7f8a976b5f50a7acd79f2629df870a32d7dc5144a8b919ae9e48b3a0a3effec6c0e5486d9a5bf6401f78cb26cab0cf6b57e997cbccc37d985fd880354462f9e11deeecf170f3624e7aca1c1b55dbef54ada459a10538294c683b47a3023632a180394c15da59daf86d818ebd88376093633fdfe74fd069c7525039f34b1974924791d04f11162f7588897587e47a42e5fdc0523646b31433d94e71320d9d6803016c1d61ddd89827f37dc0a60427d42882d54c6eb97ec96270d3fabcc9d4f94bfa8cdc33e1b5475bc7d9b81651f1bc8ae1872853773a59a49afdb9014630dc676ceb8da788c25368deeba7d69339d4e656cfe39226eb0a150f88c02b297834cf4befb53282b712fb8eb1a4c68f53bf9c63e666d05758a5c08a07dd526ddaada0ee731a371cec494f04c2d301db9dd3da4d864ca927d3b3be564353dddbad578b03a37b2df76de303a1d182136477705fc78efb950405e84dfb07d3663e0d5fda7d07a2e9eaa05601cd5f9301dabbd416b8da4bed21d32e5bcf9cc07b83faffa225554e05d9ce867245fda68cddacfa5faf0e70424986fc300606f25abbe6894450f06ef99845c32c063c67ea83c9b87d472c6db88ad407e04c045722b9f6b066214f5b9b2560d0a2a0ecfb51be54989698bc5bef8bffc1ffc5b4e35cb17ae3b2ffda7d2055ba010e8cc169bdb44af602b6a139bb8e5ee8f153e1786e405e5325cc9521ccb72e43ef188d5f91010dadca6341293a39e02340aa8e386bf8f53adf88b96618358075d8715ae1e0b9e607887d4f1b4d977e60412474ecef886b24df1b2e485210e25115eb1828f53f7791070568e0bc6e00b737509b9501237c1579d092448c86b5d3e0f08aad0b7d04e9bf73bbbf9fcb8cd8e4f8f3551e21448e006b2f53fa7a5cda1072ec2873275320ae24857ff0a7568c612705ec098cd25aa5489a255dd6f69f284b4d8c8b3e6481e592771abb1933772df011ccccb4c997215d966ace25ce56b40405258c6f280aa0b5e05b500926e462538c22be26dd58c2ae0610472b1bd033ec3292627dcc3b7e4ba1c929d2de203201b94aba2bfcb4b6be6bca8418a800e209d52a7c4420caf7c29afcc23dc4cb9e865f2084461dbfdf86bc32055606fedd103c00b8687edc0f3e16004a084f81f95043ead158e7f430c9f8415929f4a460c137613e4ea2da67dc11ca329f426d6cad675ad92672e53ec781423686cc456a48d92ba0aba0466f1aee63ed425c4b89420dc9c1aec47bb82b3afb207190c3b1d67149f219b62011e3b2ef1d9099253a14671bebccec89073b03df63c31c115773d8c96f8ac322ec898ee059afbeb4f0341391d9c56f6fd903d659ee90bdacb3c61e29ddc27ebc66fd544e7f96d84a0914f0dd0c82e774ee650231318a70834bef46d0169eeee17e7da691994c95ddc52298c2f8825e495cda35d33ad3115b3ac2b3928a08fd9e657031fce30893e5b4074553bddbea98a41a903c6144eb0a07b65480e7866734013a88259c5067300316e1cc7585f870009db72a4deb34327b83f1d01e3d95af414ffd88589c5ce4b9ed95ac1120837d6e48b0a5474ffcc0bb84c267378691281eaa0d050fee2d9ac024ae82f5d06d5bdadfcb3783541c01d2235959a9d2b0e90139251f969e08ef21e00c85affb88e08a629e2fc2eedae9da59791ddfaefda2f9aabed9e3a205fd7cb9a3a0d14df248cb8bc7547c70df11d6507af7b92f973a6e66ef059858ac32e6142155f2c85962145839f64fd54be55fa81840c490d95f06bc7ac13be99c05b57c87b5d12e3bbc779a6b04619f09116f4de1ba53d37406843401c3aff33e7c06781446a6efad356f9d5a4a8b1f9e09ecec595206339fb623b8c14718b53e4f54521a0d0a6e1450925b14b37cdbf4e588a23ae944b6c167203f165a3c1007bbe150456e28ac9b476a4cfaab63001a315012daf868a8e7ba79f9ea68502e08ae237d264e20663d14a4e1bd70dec341bffd81dce1d86aa88d2c8f4ea444df0192447436107e344369109e90e4300c21539bb5294dac7f5ce102e61927c4451f4fd130f9b0867809c9fb1eb5bc4df901fa070f04f7235423252a84aa1b4873170876d4ca54b557285df7c6959ded681b2bd8895611275fac38cc3ea152d0356f9b4b44227b0f419ef2c451085a040ceb12c756fd56a7317333e1d16db561b7a07d2e58979353ec94002005661943de3e52b595367b031ac2849a6d90ca84fc6928a9c38fad40fc1b8859cad32e489abe6a98b981f653450800a2c7c5c5275dfc041dc2b1d83c6d28c45235e616c6ef87d3038bf580132fff85adeee91cc95c87b54a819c4e47606ad8c0f4e0a75d171ad9fe4a5648071327dde813a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
