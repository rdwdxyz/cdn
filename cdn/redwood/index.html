<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f94a4fc8107d34047f47fdfab6ce36ce377eadb2c6e8ea9519905a8a01796e0be913c18d34c4b1c0252c06ec37c2ea500fb3820db2aaed2648627645db9cf16dcba105c62a2ddcc42071a970a6229339af7d37786f32afea26e8cf033101533a15282ad66106df45a21b8bd868fcf0657b6a99581635c50ecdd83e31dcb6761f4e160358353ff450154843906f2edf22b44143dd2c98367a5e020eb8a7741558ead473646b16720821a6023d98f11c7c79be32c04d17e6d88def3d8f4b9add84ef5687e39cd185126b5bf4d33e603b7242745d1e1f9040be573a24e2a132ea4be2b9f46635a5bfd30aded4750632b89b2da169151c36e0cc9b003d0e7285450988cd5bab2f53ee02b385152bcabb24f850c9cc8e8162cd0757106870e565bb30b0f06ee03e853959d2a0c26f62a8c6694e96b3e3f2d33eaa201573863d3562b688dc155911706ed2ba9b3bd0b20c05d7cf14b157e551f9704a1935e5d5cbd51400ee4a3e0cc0b510b9e5fe69c9dc084d76c766ce5a814a76e97e26faafaef11e3563f7323090fe95c723144b02db8ae2c3822c991e5c5e4ccada8f02e2735057b7042bcaa31710a223fb2eb9ea73825e405806c3c66174b6a52a2e8f02bd3d3bf530db28a5a509b8ca0aeb1da60d5be5d64b0a25fc7eb3cce468f9c22cccc55d5ea0663029b59b96b083a994cbbd73947b43c9023b49d60c670a9cdd055d841fdf316f448a03e264e7ab134d50da1eb313eb0c56b6f79c6429c532bf47e6ad088dfeff508a990a3d1dff59046f459b3d415a284231d086c52fd4fe8b8cbf32bc1567ae7970d827752ebcaec847206d3f21524a0754cbeca6fee3e4a98f5922b706fe5ad4aaecc2a00783bb7f7da242523b57ad64aa45a7194b2953150e4138265864c21d446fe61046ba5c0b6e1f51ea307a75a1cf66cb4a39eb093b25b0d59b11e15a74a2cc4ec386c55379c99d565decfeed81be1d60c817363321a747d5e2cd2e87aa4aa68bde25a2f44b15b87be2e15ccab593a9648a411c116aba422d503f09df47d31cf2b0032374232e2ec33e1befc5436672ca8c06bf5c54772ba5adab61370a5a2022334fb670c4a34661e610cafbce2114ecff079eca68b25c1a2e0e73002d3af87b860d8fea5edaaef8c9f80c620879b6aebc6c7e0e3a0c6ba0bb6b10537e365128c596f5648d9cd092453856efb6a3a8fc9d4e5d21b3b724cbafb290b5867a11d64bc736cebf565f9f5d0e2a071f632899561729e818b645f79f282f40bd5297399f4a2320702e028ea046c0d71c1c0951f568479a094eba0794aa523963d227b1d2a3012adaa3b30657fcd9b0735c93255fa1bb8fe9e15aa8b2246eb89dd6c1abb99179cd7c18e2ba182a9ea289c5b84e8af82b6ea9427ed411538d60e5b356a6abd8d5022ac5205a8a9475c350ba8ce4414793d2bf97b5df3c5661bef429b5ca2cb26e81c39e5fe32ca88ec78a836a2f0e9943bc7f2316eca7069d585ac713c90118e6acdb5cdab7e6567cfe396ce7c9403981b78ebb26caf77b8623b350c92f72fcbeddf4d88767a3c346b734fa9e31940cbac4baf2edd2ed407789fbaa9aa986b0837d9b441ff6ccf1e41452d91df1591f1f8172541e78574e09705dae74eb91d8d736fea931ef8689d093b1168cbc8034ed1f64a69116c53edcab761ba264491b66d3c931b16c79826cdb622cb879a2f60c0a4e0a837e32ae334e8284e9aaecd555b0fa63053ad4b7b41f16da40c225db68bb28b30f3f7486e87d78ecd9e75046c68486561cbca38bdb8e452cce8eacf5f67f4e7fc1b9ff908c279d4e307802f1d268ed1ece66da1b301c9991c95e58533dd1a350729e5818bb9b0e0bbb68570a6a33677d3dfb6ff58bc69051d6c81fcda8a665a2e3643c34d073f33183a0b34518624cc0e290afb2b2bf779586ed42c6323303efac54aca21ff37b8b65587362222426ca0aae26c6c69e74f4f2ddd52a71988032d69c7f5970046061baec2c44588a3312555f589ca34a21fa147d81c827f65fa482bebaa99c7b92b35dabeccff2a331e7953da1378260fed99c47851ff107b3960e101da97950f08756e5ba4cf0611b541f46da551109f9f3023ad90499091215fa07672c3755e846f17a9520d571572d7451d8b399f58a2c0d3001298938db325f26cd063b92585aeefbe6edc020eedd282425f50f122fa5e4a679c282ed4ed99f99a88239efef7329e3c8c8d97f41c0ce33382f9f0fa81585197e699541373cf8d919e7a2c25ef39fd80124355f98d5006693585a0556e4195a4d61bd8b9f2436814e6d7e6036074b7ab3287b76fd4ddbe44241190fe604453ce5a899c20dfff0685707326386a35e69606c1ca7403942f1f008d6036271d04b9031161891d4b5e081edb39e18a048e137a30a54b1216e0765e001b2c0448dd603b4f08eed4c8210dc9a5d77335f633b1546c8bafac5b6edd999f98dfb44a2473fd1173f12d3749fe0bf498fa24b365614581f0b70ca211fcb91d741fb1fd3b81f22efd87058ab3727c780d28b49960bf089778b0c17b6209dadf09623dd87f4ff2cee55387447dd7fd66226ed35129bb3762a4c8a1689ba46e50ad6d0201a906844bacb8b9ad6cb5e91507dd81900b0c23e8cce9c9eb536d8cf757e9bd241d85d9b1d22c72f68ef3c144666563fb13b6e2e35b5d30b48a89869c09957b8961dd3c2ae42773a1bed546fb76dd31256f25a29d20147a6fc95f3dc71f7c7bc17755224d18b262ec668d4a7c0e442c43a022e8483c53f33305ab327a7ef7a2d314734c40dee86a6590be031056572244ed043730a394556c1366763139b376abcf420096bf9787fdd991fcdd62acc1c2df2e099df7ec025069559cc9485a66e8d18936fb1c3fad78ea461d09be5708bd93aa3656472d38ef580725ad25ed957bee4331ab4561f5cc52f0035471307f5dbb93a7cb17b1a754dbaceeeb56568ea9daface78cfb39da1bdcc34fd95957dca6da8903cdfc262c2d642874c523380b960c81f77033b932057dab695304d3d2384baf183e5f2b863132d4222c1067a8d96f7dab66ba820f89cb3ad08c08d9bba9120e629e7fbd3bb4423acfa79c07b1db04be252f83a8f0f4541557e2ddbc39f1607a5ec4106c52ad468a578674904085cd7c6371f6ddcc0ce7afa0c4f6d31e74e5f56d9b9381cd599a32492d242e2846b9670b0592cf2a3ccdb8fd90f1e521a63f752c4a88d7e236df3d74a7f746c174bb28e8d54cb59023d7227776bad90741f5aa3f429affd6c13e2f25e04c03e30d959b9b27d583d03a07ab233aa01ff2f3b9f2ccc43d778841849d73938d2392ef40f5bbf5a3e0198124a315924ea6f0bd0838c0a544eabde091dba2ba4d7be21179aef8f7a599ec330204e60bec70ad9227b9e4c494526137e7a986664f8b05d8bec8ad1a1e427145ffe3b9599965af5b89ae38c9416997b332a53ca6c3e457d62a54cc341db32f61277c831f2d5ee25893c2eb07165bc565385ec4a99aa5ccbb87e399a7448133ebfe50d5a4132569c563944d8f68048a9f6e182d8a6db68a44889681f522c4dacdca728b49a11e05c4fcd2403849744ae5a71c791fe93de7dfff8bca5bb400771ef2ea058d216c2a7a77aed1b1b328ddfbbcb8f6fd884c118732ec5bdfe02898a230e9a4c27a212be6eed67b0e7fe6a2387106e78ddecc3cc3d713e09c09e67cedac4523cb1a1d9a960eec8777f4f068bd32008ac7c2c4a9e21e451546f02167c6e8493b6eb869119b6311b0336d7fc4bd36730ba696aa356e573b4641f0c9776bf951a7c5342c0c591fd749a1524c92f4f06b151caa3674a15456717b9c1d414c41de3f4317122a529abdaed26fb830a47c8a9aa184609f048f1891e918332741f7d1818980f73e554bb1b429e9f42b782cf1baa44aea252abe76e6f5ece9eac99fe3783f2c43684195efcfa1b84ceba450d61c77d898a1e6f50659e1fd451a022930d8649617ba8fcdf220e591857e238188c530d96cc7ceb24cef15b52f9ef888c05cd28fc912620c8c85e2b1c53e0932aafa9427eb7d23b5b3d22a712ddd92b5f15b209a19713cd0f68cf08cba18fa401b70cbffdf9050f999137900ca7e89e3db978e8fc5f5db5c062de49ac2099e3e0d8ae048bac6503ec301ff3fe7d22cd993641a8a12d68f8f57aa091f13925b4b511c397e3db39ea72f0ae93b6673b1343b426cef414258b3b228a40c3bf13485688204029fe023d1a59af4b32c0c80c88f28aa5e91788cd330d177e069f5a841406837f90aa1498c053422aa76a984f2528c52974b6b8e81209f11bde3b8a2f4a2e1816311cc89993e738a5fb0c55152b24c0f565defbb7e478b24f499708b2672372776fe0807ecbfb71f42359c4a54da6827de16bb13fd807b3b5d72824ad588062bfa59e1e1186d70bd138d6556ddac71bbfab60203b6d11af07af10735e91bed4dba9675c961bafd564212d97a9ec0d337d36902abc021658f416258be7ee16004d07dff60f2d432107da0b0b578dd6be179512cf0106d29061e682c67104948ac5b37c2f96666f399d730a4281fa93d8c5a972a4835e078ef8c06eceaaa89ddfba8a7a168e2f5b4825c50fec670f3fb8c2a192e330efc0c239857c735f1b1336375a6c0df0921b85bdf1b23a65007bbf9f58749cb6214fc06210030a20599c70915e2e357e29daefe7443b7f227349a31d0a0bd0e7b933b24a126fdabcf8c0507c5ca806cd9e45a7e09dc651dacc991153a26ba64b7eb0ee88bed168bf25840430234c631bdf8d717d82bc1a61fbbf0661337b8a16bfc9c4bcda5623acfbc6daa47d019ebaeb567281e2879fe18e8c8b420fae327fe2c42b16d37fb108a6731a0ba5e3c7fa66b789639b9dc33515dca70146fc7a0656efcda0f2d8c3340f66529c62c634127fca51b00e4e76537af2fc10ec7d0c96beb5bfce8dabd3386d3ffe12c00bc18649de7643c6a53ba664a74214266863c32bd11ff76270c814a60dd43451d64d2879f1fb5f39afaca4b204d3c353a35b610a957b0e3ecc167f0b06125cb9dde8b6da4536141b74775e0efc5899f6b355e3552e115c40bcf39b42d8ec0c19394c621937907655636eb8a21638f8caeefde78d5ea626517d6a8400b61b275f357b371c1a56285397dc860ccf72d6aa6a092f1645a8f9670291681d908f9d75a7e73e817c700810750cb1aba5a2ef4a4ecfb0bd78a8907a630810116446a1301d3592c950c3ab3e243423e84f76f14e2f985c646d5eac3750263670f2ae9e8b357c74c5db244c9f77f93194064fa33d40f81185c05cc7bda96389e020867a3fe84c91a1668ad467ed25b2527efb9ad728b3e6f6b2ece182e4579ddb9a8711b78fa4580314907fb2c8861a8959b6d12e6c78e63a14cfc3abeb03cd043c872fe1087fcd880a4dffe8c81dd2f2cf8520cb383c86c565cf19a8c0c84f41600eaeecca8637b3b8d2c7a47c19cce61711a136dc1598a6364a09bbf755a0c50985e012c7a81b436d72413c8c930613bf466801a0cd4096f4aec18445752843ada5275c405cdeec844c39f8b664489b53d6a775523065e95420ad317f926fbe364c346a15f4464d846384b97aa728466a74af29d794fdfd90346aaa81d6d478bb09dd100e0f57dfce9cdd45cae144048487cb89aa9acc2941d84ae37c1b073c83ddfe68497a7713d88f1411183d6d244a55b097252615c86bc740458c512805901d75f53fb5fc12cb9b18c681dbc83118c6cc8d75104d6ef88bffea66ba86a5f57da655623ca161e80219634b3a6979529bf26d607d1cdc60bad72f2eee7eeec2fa240b8f67492cece379bb7f0d3a316190c38c992d84eb9de017c5b046de1f4c9480a2e54bdbfe1cc9f5f79ba7ce69a3420b3e09e2de0919c4bb14bc1a1e2338f1fdb06440b1cd56cce87f4d2c76d7a78c0664fb33000c4b6f47c8adced250b7f66d05186a4b4e07f97263b717ecc74148cd489b3432ee1d531dfeef096dd2482d4c7ff5736aeae49290178ff998b51df945753b7590c510c0582c3703101dc896b4abbd2409df4dd14adb54fade2e561fdac2b4601b1bb85622e5ea664128207b781a3636b37a209c2cbfcb15f715499e163eeb8238c44bcee41e39ad74fa031d2d7a202b2fa4017dd491c086a34ef15fa6e312e3672588cb4b7201eca386d3acf7ab7f62a32247976c4941f89dcc87d67deb6a6661fcd5c3fbcaa803c29993db8c06ac7968b89aa7bc0b4334d850e1aa5830c2a8b8c5394c6c811eb86b0ab32cf5537f84f0dcdef9afc1bd8c7f15ca2df97187d8edc4cd89a14a61328beb1458e4e82b53ab3bc1aefb118c0ee792d20a0a9826cc9413acbdbdaae203ccde5393b1c33c7966aa19de1c4556b34804305df69dac58c56f3049628afa17f04295f7b7e9def31f1a7a8b50807d72be03397abe1d203406b744157b5ce13b233be224b73765e34d93c0e8c787785bb505d838b583fb76e0c65345223900a42838fa7c3ff15529db883af4e57cefa7aa98c66f7329ac19149e249173ebf40866c59c0ca234a283680591bc47607b1eb86a07ee57669726f273f546cb303a66b7829ac7c5c0b3c9995efbafa7859778ba67e9ead902e793fbde236d741035f6285342d6d4aa44ca455d51a537b05b7c3c54f5d2c3bdbe9e983a13f6e9a28811de71a31bb894a3d0f9f99ab3b837bda3898def310332aac2606b1261f667f76a1d55a9f3bb98bd8976cb66c70a5faebd60be185ff8668be77044171992fda5df95bd55dc5f3e59cec474e36850392331430d9f2f64a39c812c662e1e022b102fbb83659850157a6e8a4e863b49298d429adf88d34b76524b4a110fef5f03b7c100fc9b6ffdfd61bbd9361bd67bd6d0fb5941f9082038de42840bd5399dc2bfb32dec1d190c58bb8b65cd9efdec04ef58ad85994eec0544d273dc544e5675af3b4bbeca58fbbbe1f8036eec970fce72eb8c65fa0d98a5b4e6bcee46437900b6adf94351d7d08312a742b156b8a71037656e40917d6c6d07eb5e4435a41445334c73dec5f1449acceb0fa6ebf8f7f90d50f9b897b69f5c76159e2a2016a5ae1c6f26e262a74dadd3f39a48731968844848f0c4f190a0c770a4b46183fa2872561b12ab2ec0061e8352ac62d42b6ed82741dd170f043701de2fc77b4ee412e3ab100a050b9be87cf166429f3492aed19e013e86507186481236acdd48c47cac6fdc39aa335b8b948e32cb800959eb84da1aafb46edeb568f295ef8ee082ce3a1007c04439263729f31a02408f15927502bcd5b39948b093b1badd77b469a02b81713dbd113a1ff50bd5ea3013c923e521567f6b6d98878a45506d58510d231a2a3ef2b467edc90fc8c7bfa4f5aec37d48c16e6ec54f730ca4bb093296d13d55f4e971b9df4e10719d6b85ce23194d1cad6f59b4d4a0d48184515b3c9cd19773e894abfdf69da50cb64aef48a64931348946f5695b86b55ff553109adcbc0a06b1d5d07c1219607bab3b6b5a5c6838f43668e1fe022c6ab59b56df88ca421d5f2a797d43cd7cab7354ad7a8cf798e56de9d74b18e9528d2f0e338b3ccca447de00037b48798d07eef6fdd61668ccf361a3514a2e2b871ebb3b6af3fefd0ac6d36a1b2caddf4ab62be85097db955c8c77701954d7d676786f3aef5cc6b44a33a9cdc1cda0b0ff4a5f313c1761c62c2ad18b57caba264d8f30c7c3e8f9671152cf0488c6f7eafe43dccdc6839ba123235654845a90b544331e416b8bf563e5e6e967cfba67252830b7e52245474a5dd099eecde41e5553b07bce084d683b19a508cecd84bacf67668d23d5ba2be3dc4649009b0f7924376e7fd4a7e1a4ebcecf2ef2d7161c4198c7d1b71bd669c3b8a9a83dfe118453f01e6d758a4c13f5b523f02e68c382bd94c463c91985b5308a8ee33eb0d2817ae756d67304be70917928f144a84d7a1808d948920b130c1d87d8019b0dd373086ff459d149d9c929243d3ca52fba7e37dd8dd7ae0b8e6940837a12a4b03743fc2ff9760b3302d1e2d95d228eb96241ce04b1ac994823a849e4729656e1453073f0d60fc20d75dfa7fe4e823b7c7bb93e5f5d05a4608f8edc7215ee1ae187dd83fa842599e3e5ce72b17201ce804f1d946d2d7f7f7d8985e8906ddeed747150309e9feda92a96cc086198f9e8bd4fa16061f3dff02c0430a7418157c01474e91e7066dadfd01b3cd12f8de7a3bd3d8ab266b07f48586ffcb85be51eef55f09a94bd590dc13ff95a2775711f76cf78caab4a7ead4cd7b994854e324db1949f0085125c773748475a3f375d44bd7d4c151ded8f7b08fec9d9ed5a591e84bd77c0279040c5c9cabd7655dda33682b703284b276f1dba7acf5d2b5062af1ede5f44c0fd8d1aa8ac0ff893fe2e6fca3590ea6b10bede4a8b227d4436c232881ea5666ae717a4a79b78ff94763bda8b3ba571f2772bb99aa934d8ecda97d33a46bd8d82e587dd2add7b76a8c570512759e481fb623a8a4980c847713beaf6fa3e0dd4914bdf2c56b289428af6f20ba84e5c5e4756c1d7b7140a16f43543fba4b19d53da33164ffe9a7af932406501e0610c52275e9b487e60d671fb34dbf829e665f1bedb379df921d1bfb6b817bf16332c5664e49035986981b048a717e694237958d08b261e7c91f1534ec8db4b5815896b7b3fa04529334a6dd2b2b068342943acab82b6df5fa2402c321807981f0467c57589462655df4826e79f1aed450462897ffa36a25abb628acede9b5b5eca71cb9c21d2c318dffeb09bafa3abb9ec039cce97247ea18220e9e71277b205eb524d2161de99a3828bf1a6760f1d75316fba741afcf405eb23c77fb3950467328042afb0b5a9e4f5cff8863455db263bcbef8c22e638dd8dd4e4a797d3184e1ecc99dfed680432a828753b00cc6515b18fb1e13472fd7dd33b3453630559ba79f14080a7bdc6627b802e2284152f4708cc91435afa012a1be667263fca67e58356fa2fe2ad4e75b465d408caaeac0befaf1fdf934aa6332a14c3b7a09b2bac0dc03c9f018e20d3224ae99e2cddb6c428827e96929367b49b9e87d8d8cb7896ca97a539a594e7325d07d29f787946e686f9aafc800a2462f12a92f574aaa8a10ce0260357c041cad62b1932db175735d35b4ba918a30ed07a749d9c814f3b7d10af0c62afe5b3173f8d18043103e968e87c8465961cf4d23218846acdb26a6ab5009e9407cd86f7953914e00cb3e3feab8eb7862b40dcb2a7d84a0f6ab64b1376d41c5d316ebb4fcfa7e251454e9eabe2383a4578982093784cf903066f8763d3a5498b6b9079561a35aa9ca75d21cd5eaf86b8c163fe4c49ad3cb6bbb4e875800e6cfe5a5271365fda7708962a7d48a933605892981ea6319a9caf45fcaec996a6f6caf65513ed25655f774544542aa4092d7e5b306faf7687fe8a3da3a4b09221191237cc77893f0115c4f25ff56c27170e942d6de37d7d6582791e2b9cf698b82f0af1493ec651db1734a5af4e07ef701e32c986e6c75b68123a7e1eee4b2e86e3f24fab6ecc91da78a2b193f0bc475770aa48bca7acc69b20debfd85d49aeae81cd3f99cf2308b0a5ad1fcd223c694efee30894f9f8916027bed307328baeeecbaffbe8a38d53e86513ae2ea837b01e9b4cf9efc3289113b0d67e1f31473d98deeb1423e5ebe5b10773d0b9952620feec79ee8f9b2e28bc2e53e99484b4b7ea298af87b84d24ac46d2d7388fa1e78ab9450d1e4483f983bfbdef82aa62ef40edc0a87d2f02c1d79fe1517ac8bc4d65d8ce4a0a76d023904a49d4f602ffb6a652b046941cc515fd8cdd694e914a67e2c7fed39fd1d0efa2e556b260ee6779505c86b6df45223c8814ed1932b5cf7d0a37021a326f6a63fe25a5fe5d755dc77e48c86b3aa25a587b3e4181031f29f06446e68fd93232ae62ff451d7fa8725d6b8669f211017c7a818e4f2eb51082218527c88da4d5c42a6bf9ff0676ffff4bba0737c3f288b1ac9633e97b16781f0f5600936a753840f60a5be1eed159ef093076b20d321ac32dbf7b1699e377b6f0020fbd010be225b1b7400bac299734a747d74fd1a8f6cb3d4a180e351ae673f8ced0f31225ed0572b9629c29308dc5930b55c70fcfe909aeba5d55ca14e7d603d46dd2b96f2e6d042c5c120348eabcdaad1050a63000add7f12f86142a712e3ccdf6b35d541ac3a3e7911096a7fe9af892495080821a04e8450cb6309ceacb2efae7a1ff9c6d8ef730f73524e142c5fd63bd43c75e591bd3d0c0375930e4ea650e6d3d12f09740b0aca42927a4bf9d8a00d6cdb288e657f50e38db6430d0cdd626d0402fa31105b41d0598e71a245167b4c44b9c9c91f65baa5d1694939475bd31b82fee1394e0ead429b793e9fa75c304809406e0f9589495b19e086b54e957222c9dee91b27478335dff389c92e6c90517aa46b9d67f81baf9021c22ffdd5c7e0459851615bbb9bc1f2dcdf166001c9386f7ac22e6baee811dd6b635f82bfad33765a6579ea6c694d3e66cf468dd00a8c5e9c8f5288cdbc7dcd916d9cc83af2e8cd68b6e966919f04d2228ea97b6f10f7afb1f58e4df2c0a3134f834bf888b8752419e61926663d2f368d50aacecfffa7ce67e047e32dc4fa881f54077daf7aae23222a1c5aa5c1b5dae65e5cca3396bc7fdcf685f3209f5d00fd783497834cb3ed6c755a5a1561996a7bf5ab2ff439fc46be761445498d20bda0dc729b1c18afaabba6fa435cccde92e96634dee020559a2685d285b5ad33dcf792893c90dbdb368a92d80b8cd1b7efd0cb2b289852c1d821f6f0a171733b72808a5b5a9ed24da6f17a19592edbfadcdf0805648c40e0be1ed886cfcc854dcc0f6fc193b268b68e9c5f06a418d8d0b7422b2b8af8bb312644fd648883d4668bf6fa1e10b8f60c51ab88e161b8c9c3b8ea43ca636f56eb2964b0bcac8cc334fa0110775de36ded8cc18698ff919d6c47e5fe1ca815676238feeacdffaf98450cc3b7aff41463cbc59e6579888159073a73366169067797e6b1d086a9065e37bcbc5f9220605519c93d4fa728183b19188615d801de4ed707e4a3310e045e7c30d9b218dfa720e901e48ebca869c304155905902ef39440e5835be46f3f84efa1da5a4cfbf3351fc237457e975496facc8f057d7986c78e9be122bb8ffbb6d13071cbe4cb374cec22ef377554c26a6b2d733d994335dfd694ab75877a51bdfda578d8dfe33af246bf943ae40ea1db15956c65de99c9fc21b587708ad14e4932697edcecddbf96d5be0f21a2ac8d2a15ece94e161dd7c9c9fd8eddb0a7f5e8570ab7d96864d5937cead444c98bc0a45946647f64f1d6b133ec21259865584982e9bfa7bf0248428d0e59de984d5e0eebf014998fe27038c779bda3e2b903ec15616c4047d3906babd39287db0a7f555b2e01b84c3f9b9cdda1897398cf32404230992bd941763ab234b2fb493ace831ec17f0ec804ff4c966009e380580d62bb69ac4e67650ee6b7f65cba126b23730dfa92d72e8f8c890d906e15d0fdc554999dfd01bab973d4526a2d0aeb1ff036e1d0ef0448d69b4641efa8a356cf9436436d8ac309aff231257f53ce4669553693bcc0e5731ed8cc7ef248994f2a229beb1f4b4f52c1fff3769e44ee04dc077ae813e1f28e7bb82525c938661db4e7f3cb30b178c8b10e137fc63a274fa376c70eaf1f576aec437f64b67c01a6a223ce26004b35983c351c8e4dc730d6fefda2cd42513bcbd94f8637707b37a917e7849f862a6c529075c1f0829d6b1f06fb8f07e17d6a71e868abd22952e7c9aa54b73d6bb2429ba8032d1b3428979ae6607ce4405856fd5f81270339aaff24282dbe7faf5fbbaf6d60acbfbaf8fe7857c9aaf753c2fb99bb90db0bb919ba2ed7ef4eab5006c74094a9c4e1907d834c55649581c3f92df9af6f227e124df212eefc4235c60d73d49989e0a8ba7fdfe458e9ff4d36fdc89bebacf74cefb0c9f1541e12b66e833e90542acd87ebebd1c567366cdc36389ae80750035e9bbd19214f8a00c75c6abd66b5d637fcb1b3b7b74654eb8ebc13afba58e6191c4f19ab06b9dc2041d068e0409c7ee3d710da4341d95cd912f530f7ffba733ed5fc5711ee45b9242791e161f439880b30697784aa997069d885664038eff85540c2e929c2e19de60fc884d2b7ff95ef454815e6c2136397e6433da45a0f2c4fbc002f1c8e2feea6d5e65228c5c0742be1eb233ccb3d461bd683561191ef6d1e6b360de9d208cd1dd907165e30861f02de2fdb20c7643d09e00f95a0eb3d24e35dda0f3f776690475601128c3d5002b644098a79e69df1e68be452f5f35a9d94d8fbe223c2a6aacb4662476fa6329eede7db3af2b4fb0f56ec1e233913a12ac821835a438e7987c097eb3ceb42da65e09f2cab088a4d45f251cc2b7836c3011789f439b2145c448892c1af10875b6b4a2220d3a9db50cddcd74e8cf3c960e5194941719500b6aacc9d0b844fb5de81ab59afef11322e2cf23e8f3a14f44c61f766a91501a49349996e175eb10c7906d87ba6254f91ead9fa2d1db03fb4a52a764fbe514748bcca00beff859b6d0ad9b4d731c1e2f4c91b41ff15df146064be800d55823301dbf12ea19c016e94bfa050fd062e9f8d46ebe1799ff729674d238186b766a39b665c7acad3f72ec2559d7b007dc86563e9571359cde9129e45f821e9b8624afaf125082ddd6962f7fb97484a791a7a70f33df01819fed2c75c68a003c1732564942d288ed977cb555432c31eed95fad8eb685c7b1b410a0958d9b9d158cece7ad8549e60b94bf8963c249e94f647c36db5ea7fd1d20c96f511d01e613fb8914d98f7b7ecd8cfc4241d71e63679e665722cacb0683cf6a785ab0735441b9664fcb6f48533d971c45850f33fab059337860f165e512a71f027fcbb67cb8f8803540c52cf6e43270fec9e2cbb7ad7b1b16580bdbf27c44614fbd652fb2b630a9d833a3efcc4c38853d506a0722465d2e5b100d25eb89531beb0cea0091ec5d654cc19bb0908eaa3c9da5b8b8b9a99a9d1ec2a01382244495b9a2bdbcbabc05d425ec41de1c0d5d0ac32fe8941f3638ccb19e3a0a2283527ee17c0baf50d4b618ee2ce46c7b6baac98e71e25640dca5fa4b078ad002b5376a502b2992ddb9fce69de5b5e905a9e3e008d9045ffb7678ff740f956c56c6a139bf3fab7c60c8c643890fbf653f63da9e7dba625594d1c4f8dc67eaca43290b936acf30d16320bbea2a412445a64d2328dbd6201cf4edfe69ddfae225b05a8854344a78e342303bd8dda04b7c9080ee0aeeaaa626d365159c1d8389d0294a9c7c6fd8f9fdedfd312a9ca93f23d0e60e734d3c2e8937639d9851febf2468163ae0b7250a76624cd36ce6ac65e6029e1cc01bb8980f0b412434115c518b49c1487ec8a4ace9ede37ee6f98de99bbad8aad8eb71d311907ab0ce5a0c1eb0ebe5a46c77546a7b59240a05c5d4acb75e12d4f000ebebdaca9d3ee1c3e3f2477c792e49a6e5ad0a4870cd8a87657c4f14bf9876ac84b680dd1558004effd285187010e78d006e081a9b10665114d2fe4a93092011fc4e92e0d7f3c44e02a35bb87ffa41ff57e4a10f6f9cbbe92c44db104eb924d0ce8c9882b718973873e7d885668dffd32a854caa12145ed8794db7eab18e0826c4701b5daa16f7a7b6bb73841b03dc8c83937f999a3817ca05562e97de63fc7e0fe1dcad4c622730303ad11a970f62845381c1151379bc82b384ba48d2b8d7516ed51b8d732bce4ad7a48402b26faa80867577452088e558f635c6d4db611c9f2063deca3b8b16828236bf4842c343ea4af904ef35c2f9f51a97c7755b606ea7ec4ed4d2dc27178b9fc860ce0d1a6358d15bc2ddb19140782e85f23e7e105bee7e47de67256d497ce94cf24a81bd5963edb12b4f3c33b8d49992a1b697ee9468d6702e74f7db950a3848b7c8b0aec5ba2763425e62f1d72050f41ffc756a1e8d5cd867ed80e1b53c8ac2def4e36e6d1da65ef4062783def45ef018c5e83bd586f9e2da78eb03598fb1243fc711696686707843df5f683ceb35ec0a400991ebac3b6db01f882edf6bfb7bc1963bcc144b254ff299b2a3f67bf01a36a3c5846c0bd9743d272e376cfdabbc70321c9577ae21e7beffb6557908deeacde840790e15a4a9365ec570c386d3259793f58f1cd23a39d2025f0962507a39f8e92280f13855b39834440a43c571c91a05bf78eaa9532efae219ed2621b1f4c12c1627b96701e7f00da87b03d81e35a7b03c006a3c7ee3ee7c902553a4b358a224e1d2ef8d553438d29ef730b8b1f3ca6d0dc7d7374a4f626db3abf73c50357934a519b426457b4e34e3734893060cfc8ef10efb818c997d87654d7b49e62f53fa0f8c5b8827b6832510b775afb712eac458503ac8fa267db659df4bfa5547b2b3bf3ee68fa660cc785e84dc859822dcf075e66e36ade1ef3f7fa2952af79a6c78219bce3a9cd4de86b72cde37d40186a651ed5882cd5809773d96683dbe4eded9d58076f6a4755a7f2c7c76dd54f0471481a450e800193ec45443c0c91cc63a7926bcf064939d8150ed43d4a639f679aa5c7d4de84c1d6ebc8f2e68281fcc6cb04dc912ad2df0c259b861eeac1422c1e2c6eecc3f7dee10eabf369a3ebd9124f811659664ae1332ed7ec052212bc76e96a7d413c7a175d7aa1a093fc6f54d7e06e7d3cd5fd8fd18432e704e7c0bed34e1c7a3f86dbc25bf8b32a5db71226700838b3cf59d25f074097a30199bb6d445675a9ed952bfe8894dc82cbfbebe47dad602bb0eee522c2c3d9d968655129b67fe2c87667cb514477d41c86e43e18a1b2ebcbd5b35a9232c06fe7e4b94fa6e87897b75b8527897b127b8cdb91bd6a8986716a17dbb004590f2b5a6a2a91e2aba6c84b19fa0ccadc3c1c8862426200845e7f9ce4de16b03ab9dc1d213d4364e470f562b36513cf041622dbaabab19108c1c0c318c60dbc492d37fcb4b5ab0af3bf5e65cc1ac4c0bb8fb67e8c17011a99212515bab93d13cd2660fe8b13d38dcb2dcd0887d83db50cf0c872ad8b0defa72e678348b0df622e3bfc45d5f4b31eede19566238c022251f7a744b07cc5388b6e0559eef0fe10a2c744fb220291d813bfe5dbd6ffc4db456466a81c3cc08e816b00dabab952f1a00146733d8b6afedb4050064c60304e5e1b9cf6d234de17ff1b44b9d73c4a6ef228c623bfb1bef1075049f1679fae59350158d808ac5a7a0ef483fa232c8b7ca500d25dc5b059e1670d45010fa68982ae6bc0f91e67c853a60d71b0f2e9f264eda92251f4cc3600851e74e68b170a8532d850da0ac8c1aa998338e65fae21ed007b058cae518a5f8fac2581f42ad026afb56866b71d453f5190050df7c7379e5f37e57a8133eb658a037fbb82f354f99b33cb9f6f4a63372f55a70a16bf1fd66a18d4354c838700195c84084308dfb832533735ca5d86d525b1168c5bb851dfda9952640f76bb6a529797661685ad25934fd82e3630e57067f80e6b938f67bd23c2b74fd8e5d096f89c9ccef4c3ad327452ce577b0bdbac5db3582eb9c602d53845c32cc9e8562e5ac6eff430537f38efdcc153d3ae6896e02080dc3dd73e918b4e80ca426db1691bac1894336d50c54253e4c8e9f5f323b1a396690ecdd2a6d86207f78f442b963c378748bb68f8e6f15abae5a7ac58535cb6caa4ed159df8a8dfee1f6893039ecd18021c8c7b5bfa5de4b54ad8dcc8ad340e4fb275716606d3d5deaa04fad4616305aae9673bf4674bbb84b64c511fd1d00a24d5f7e4a72b1fc957601da47999efcaa591a51980fbf3b536c9805726d73724440a839941df6f171c76499b88d6e8cd18bdd1ee1a587125d244c6847d7802e350f3c278c375e003479e1b3a272fdecc514d477e7789437956fc0fd07dd874c56bbe88f01ce626455386a5728d59f9a690423ce412208edfd1ee24fb94fdb40c9ec5ce5cba112b9d0fa6443b7b4572ae326cbaee2339c8c46145b3986bc07bfb4037a956bdcfdad70eb2f345fc8b470b8ad23b7393e928b3e6ab8a74cf8815411b3cdb49a94c4115c348ee2152138ec0b8268788d794f03ae860564415f6333541054fc26fb0f4d57706f0db38c45a59ce4680b4e26beb2660fabbee6a3208e5a26f1e3a48bcd8e67f9d431e94ab64c39374cefa584352feb86100f416f5f9259d17faa16b30acd85a4cb0d3c44c750e9c743c5e46d4143ed1ae45588ef864a9818836e5047dbc0cbab2c91b2e4f3d6ecdd556411cdfb1e9170fc2b410af6aeb570ffc544aa88e7ba8d8d1cda19d6524362722c1d908e8e322bda76dfc57637580ad52635b0390fa38cc393083d3ed2aa92c14e11ed7e0daf50576b67e10963652be235468a6d63992ec1b749ac06ae017b81f49b1fc40742352ed8bae77496b2aad4eb7e5236c95f5062fd90ad6e7b2cbf11c5da9ca63b560eacb5149d72e041535bec33681cfb5b8a71adcc43264635168a0af133de53989ddd5870bc9573c7dd558a75642b14d92a00260af647c5d054ad13e37413b5835a1a97387ed8a69f10311db64d6abfe886a5d1e4becc79f13f3b98de8db10bfdbd596295a1ded4890af0f701ab6bad7d3fc2412fc0e9a344bb82e955cad77b00d7922890fac1cb2ff59ed1eb8f68584ad2367a38f3017a75cff31e4888a4da8eb99c97034f3fd51bcca7a11f34ba8f8c09b458d8a1742dc6ccd0939dc739db7fa80b7004b296665dda3bc130851450863720b8c99868edac96d99931260d0f83b385c8c0b3e6f5c06fba7ce6ef7c56c334263a274db61e20b9b796a768edda60f3e179bac76cab06984a3f1e6eef2b0e5415fdd8b84ece059eaa4289395486387926a4319b50d8a5da5c53e84a356148635331edbcb6aac96b1f8d522d1def9ec00046a746c2242e7b0a8c02af20bfe6c10fc689dfbd0f3c3cf5af5e82c9a0274e30cdd9038e2a84729fb469538e64d90fe7ea1c06d80cb2bf2f9754ef62d4339a7a2d6d0a7a06ba34e7d97541d2ad42d3550b2cdaf0d973219d4ab1049656f94f35957c80ed85eb887a1f5f4c23039c12f3ff5bb50629d0c69dbce816b9a206a16a87d7428d1945a7cbd1b86162b44b014906baa9f5d806eb8a148ff65dda86b5fa49a9d08867065ab50df300c32250095a54b444df91a6d1fe4a459f3510e72c68a5755ca1be9bba8c4530b4d0d2b8a297f1337f0ecce1a0edbd9d49ba182ab2e0761c5391cefc48f79b0f95143ba49f17695d693c5f0767b9ebd9e8b166c07b4a960cb882364d6ff9a440282afaee1b458f4450225342e11f2ca552847c389d015e2135904d269407d448d918691d060765d103c3ae974748e498d6f82a4ed12bff544a2293e7d9dd6a6e3f4200a363294f8d0988e57e86cfeca97c538c6e272b64dfcdad983bcabdf0513b574c3fd286c4bc76c8e0d37f262bebfce05fafd3b21069ebd6fab01cb690ab4a99059f592d35db7fbb327bd62b6548b614787930bb9bdf95292b180643a9228e2fe42814ca6056f80af3b31fbb23baa3953537574d4f2e35d41218c5a3e4d8ed94cb80e4bbfc8928d6181583254806ed034ac02843e17422ab854967d7d2992820d2e1f9fdbc1dd94cffd1cb2d8a20a6288ac9e5cb731fb6430ba746c922f0d9f3a62e5b70a1fee8edf7e39152b540a7cc07c0d5dc2a3ff0c778271d608d8736e24991b519ef736f3359dacb708dc958283072349debb86dbb426a17bec082bc549adc1918231d643a1993364dac3ad448e8823eb1656b6ae65228ffb3fb371754e8d30c09e78b803dd4b01838f9b7157bc1f55da313c61ce2785c709a4aab72dc868019708ca43c201a7d50cdc35c406c86b630643b420629947258446836c5f4ff938a6c61c010ec46e708dae60ff4ee0e71ef6115fafc12543d823be8b39ecfa19918f262a6e5020aaa662b955c503d8fe740f8fd618a1733d288ace1d4e7d5a235d97f40a9d8f3146b2031d5c6854f9a3d4e3c4006399ecb2299643b720f1f4127905e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
