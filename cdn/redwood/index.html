<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd0b619f546838a00809f5053235c12917fdb9dd55db841f9f807cfede554d3b7ae3898b884cf7a0ccde43e524a546a41042541bf953ba363a98bf19ae95a64d867af4bc468c4bcc60f309ee4359781f6c297a9fe94a6644371497e6822db4d228e005a0e7d755f0b8a627d26eeea1badea393525d6629a53e7dd5ab30d05221cc1466f39e349fb3f655e005babcffab065ad7f6cbea217bcb16f16c873c2470d498cba02389aab08b5ea35303992b659a3509cb2f6e32a6dc66a7ce3b9d0625ddd264601f98b52c2d4708dc366f6b725939b81358779f2150fc5dc817d4efa9754c24a189029ac9bb4ff48b717a9852b60ca05a8ecd6ba09d3d2ad33be30f599adf423a62cf068fc66d4cc64c7f7b80cc41a151a500796bd5e4161174641b586ec78c7343f903f2e5a7559e368cae24e728bf5b82d81e34912933cf860ad568a182b8e7bf685f52a783cd4e8b16bee408dc7cfb32dc4566b614af4f0e44fa327c7f8d6139ad2d87815afa6ab80a6cff6890a00df7a603d2309a8add64789a5042c4a30f4469077b08a38c931958b6d06b443d5cd68c7eb270a43a5c01ab4896f52e453960166af9b494809136bbf71e662d88d8805b92b02ef0f23fac62c92d65c757058b749d468fc921a815919ba0b06e98e145da1bb559b6b304be144701bad0bdb967a5211794a770e9a896a4446a4244fc82edeccdd7a166a8b9f7f68d3d28bc0a7306775a9d737faf671654f5ef2560ea5a4e5a01e3d641eda4508c7e8b053dc2e7a7818c5cf81149af8ef878a88017cf99a967fe1a90da479dfc2480636f60f0e6c61320dc409924fae56adc831f6bb911ba2e2806cd150f6db849cc0448f20f03b66d0a09699f4ae09a068175bc50bc7d855575eb952da3b5623cd94172dcfcc4c1939782b77ff97584d682274ab92bf6c3b8033480e790f1b794f5d2b45bfa25ecc93751b45b0a0263c8f0ef7b42aa255cd10059b17e41bf04a80eb7f164c3158bc55fc83bfb37d7435026299efb3fc163df7909c0bda73698f00c16b3c371cd62e23ebf7222c5f2e0467a2fc8d13f53cbccf3b725c9168935b2a261dcd44331b9c34d5e8b65002e2f37fd2ec68d844a5c04911cb2db100f1b80f6f91801bb6ec6a0c561f5f30ace959b931b2f23f2d1b75bc75f7feddbbc41f2f1f20aaf37aa3b8af56a8b818c5f31b7c1ff2fd36e7c98fd0f6be391074d916526aabb57619c892a4962545084d038e30b716947df20cc99c8799325cd22e827a202e33fc22610cbc3a187d0cf7d9403e4208061aae11a2bdaa4b021b6370dfa11f3018ac904fb135581dcd5d8e773a0a1b3013b31f6989ab8ee1ccf3c0888763e579e8e8933cfa5b2457ef327dc4d290de09328e0984f88aef20160bbe7d0cf4e2b5aeb27cee548cf2ad715c78275aa399af61e07284e91eac24a8f8ea7cec413a66ee3afa5711455ca4633a30192cfe75ea778418a5727c9b8a59759ba8c5e933acf7db0c000ec7cb74aea0bafc26eacda7b57524d30c4b105f89555e20bc40385917a37a00f6edc0799e56bd4a7644cc2ec2558027da1203cdf9e69adf14e450bbdf1e37f4dd7c034f225e09169d56a443829961e7994f131b2180a2c37c51c9fbd97194f6616ba5437f8f5bfd473b37a777cafc396721bde8472e2dc57ed064a33e7b0d8be979a5cf6c3afe9adcbb632638e698360817b6cdb5b037e89b4655670e744743a02a74727200ecf59a9f41110a479cb6e4d91b3f38c9c640cf2951f08cec156c1d882f01ecdf76bef0a5dfc30048566d4665fe8e08cef3a666ad9139243f84bd75c89e90607dae12c5594b6543b4469d8ee5c1176c2f72b6b218290c22a48e90b32be2d544c3ff31702e31082f60fa7c970bfd3ba670e16d57336ecc664f84f18646da51f55701a83703b28ac794569a9f3e7fc2133a79c037e8b88d723678d533d3809b30f79df1712cf9d278cf8605ea9e41404f118b41f6e88e50b50791cbb22be765ce7abf50b67f556bda2d3958b2944550c217fb11a6c0825c647b9eb6dd7d97599604021d860a24d53c5d379a4b10c21b2d5318f0c267c1e0bfa713149a439b90091119d05df155b4b83b43fe8c4aff8d5f5f5e704d84261956bda5d441cbbf96e17e9ad734f30ea318b5942f5db17db360b84b776d25fffbd82b092a2fd3a634e38272dfa84987fbd785c0bbe36401774b1f1e076e50f6e5d93cc13d155d7b47b0b2e36f692818905edf8d929fc9058d5828ff3ec3518fab5c01ca6e2765aa03c7023aee4efce7d64126df3877f9cbccd4572db999704006573a8e8f09d84ab6454fe4c4436d46978bcc2e3ce05d0d72d89589b0d17184ddc348b403be0b7ab57466973f3c1f21c174463718eae41d717483473bcb38b00ea9d53bbfe9736cbc363af5ee922457473104b4eec0923d2f4a718f1d01a353d92bec93b1c2d6fdde40a1c0b0132d075a5d5cb1373bd12e9eea3b26b76a5492574cb14d595141ae222098784c90c73720cfc0a3f72b4dc2fe26ff676959bbf94a4a3189d7ac9177ae4e51fc30ebcbadf056f3d4e23704ef4ee82b5d7116d03db32cd26c617573afc677224ebb2d7ce9d71eed8afde7bfa8c60cd2bd659d81416831af2aadcdfed3f062aea2be63d4b0434dd2cb91742581d1daf67ddaa5702f45c193d323479722a50d5ed5a01660525ce77948c74486a1ba2a6a500ed947df2c11ef727a7465f4b0baed9e90830794db46f3c161735db92131f6a3f05ab826175e19b3eba3358a3c398d38c648e107598e862f3bb245886ec5abda2db17a7865aa401a84153b78fad545cf6c020299f9a21b6e8ceb31cf5398c3d6e407bb2c9b7358b3c71b11ae54258f8ccaf1e047de9e8391c3848bd35c0ac85aae2d0847fa8b345cde46ba7d2890c34defbc2d5a200c45ff367a183cbec8db4f98709b63cda818cba540e6b275eaf813eb76988fc233dac23c18b6a436034676754e357196ea0ac427447d54bc4006c17ee3859c5943ee461b94ac2e5572ad1723efbff88f750b4b8f7975709cb4046959605725be7812ff8bf218c3cee16ec8d90b168e79d5f484a6dcf28247cf0cef28d0034a9cce65f3b98742b059035a04abeacc6b5e6955641ae9d5ee197f0bf4d5d4a1d43c143627d6a8b755b094576f05b2ecf0ef809fcde9bc1bf109118f649e9ec12a0eba451dd7f9965d40b1fa4e167504d44d4ad8b49c301a3cf376dbd9afac730c08472407fd3f838f099810b89a02ed2eaa31d4dc20758579c894a1422cf6f7bb935964ae92b1164424b4518ca17f639146c29af8b0b25f4efc097da7df49dae285ba9b801b8710b1396ac691f08efd0a352281872e8a02d5120b6ad51196fc172cb6769cba3aceb76c47623b190d3f9b472f25877e5b8d282b6968002a65d71042fada5fa0906c7f2bbb2e172e32f923b1ea20aad61720e85775e6e64d86aa41a6874a994d189760fec5f8b7d0854eaace4c5f5cfdbf45a11a5b667eba0a4c38efce101ae5421e7425bfbe60b329de5944a6cde38b16dc2ca2ea4caa97c7fecfef0f71d2d8b0673fb2440d63f33b7b288f36efdda315e081c1ee0cd2e3c7c045e86b06b4a75a4e345370de1c7e19d581856e4eaa7030108448f607f33fe6b474d18aee5137d00de0aad97c3c91f0d247d18be60b58920bd64ba172e2f7ddb14277ce884ed1a40c93593107bed34d1aa4a71090eb27683da4949a21004e5e8c785f07d2d0877012b2061ee32317df38f765f3927bccd2fccf030183b502c8ea37e8203c4caa4a66c0652d6f9f97b4d1756f994048a01b96f712dd7946062da3848fed15c31f7136dc02fbed5574e16292b0b14385140ad9f9f478b706604013c0e8e81b686be21443adf894ef7d7bb33d7d837ed5c8cc023e3bf7f016dd750bbb23f46fe376e7b0e4d20cb85920b21e98fc4ae62d40e7a85d3358b7b5641810671a4e127bde59b50a13370833c132a431a631ca196129b43e6ffa1155ff728be5baf13ff83934a83ed0dc587296b5763523358bf006786ecf987cc58e593ad4e01e046d75d5500e7a18fd6bf4467cf56fdc9e158311869c8bc9ffc0f5f776c28acd5fe1bfb6a3c0c95ea9931e6a2dd34145632232241ebf4015ff238d0ecd89f60da3d4d8b23e35bd27ad9d179a207354a9de30cd72a0a73b5840c3998a75a44ceab77f0e4fb17ee9939a606bd4fa4751ee33fb93089a9b5dbab290e4a527a5339e89cd9532e7f48fecf6dc9a0e5374fe344e7f9676ee72614cb4ec126a577cf560cd87db8e7178fccca1c8e6bff93e3192705fb4f9aea56fbdb8fec3ae9baf9584b34e0ca3c685d09512fe33afb2abc699b0ccd8a27786829edfc2850ff7a6c4372ade09d8c1a5d6b1067de2d81b8a7eba218aca6d6c5e053d3b6ab12a8103f9152b4171781d9220dcf310fee3c3b2d535d929e52602ef584c0b9cf637a0a47fe0a3bc00d26be3b7a4719cfe1a8cda984ef84af10150cc520acf9218d5e6bdf914db525a0674c10c52fa79f36c7a59475698d2875d3ebfe82b270031f0111cc904c34be5f1359d148ea31386823b1603a07c782373beb577254257843c91ff1b2f015171a09f21e647bef4578645aa3714e39da542536696716ce0efed5bacf6130673802c3ea430f1e01a52beb6ce5d306d901bbae366e2112b2d11134186dcb7de82bd08868471a9579f50d28c35c3855bcb18c8de82b3d311d90c602a80905f7f9a740d72eb3233b23b05355da93b4d27a18e582fe04b1fea08d9476ab3005325b405d2ce221d3cbf120ca095bbcba044ce43afa536599171647084fae9982b4f6fbadfc2313c330f3ca3d38c8efdd37ddb2c6873a08fef49a8ce6be8e51737e9dcab2eaf65b62c027e3e55bbd0ecd4537185c9956e91f552f8cad5713ede81354c504e193e291be77e06b328467c269c0f030b9e97c0d08fb127946fbebc5516fa1d7516eeaf035b9a604bb35ba314e3a668de0b41f2c3468c97929222c99621d67bbf15781b2941b653e9276a991247b9edc58753c177a535136317a534590948c4452a22e328b92aaae1dc0aa060cbf595384eca8704eb35b247496c3a7b2e5b52c85a0f2d5ce77a85a6d11f5118d9ad78345b4bfe903a474e41e1f86b5d9f616202dfa1cf4a70b02f11695f49a89d1d4b6de4de96fe69265453429e27b815ad0f371be6860e702f5532bb76e15d0df415632e56280b9cfe91e56db316f2ce701401e05f4c967554d60fd6bf9873398e8413842719a70acc03fbe1a8253c2766bfbe36565acca32ef32db99c30ece6c23abd9de028f5265cd25a5759038d79118f311cc6ce15dbeb163870625c3ba367d6d5b833009565e9c700c93d6160f9a7180393dee0b614c378a8852ca5180cfa9d7052df006a100661a4cc1c458ba1e7eec74ecd9a2703f35e95699a3872ebf395c75da0975160a89ad916408a1ecd8311c7e62c32d9e2ea6a34dbcbcf0e27074a1701b072ca457cf825e8390a66292612fbe84fa0a7ae550ece618ed8e4395189495f8e53ae1acd22ca19d97775447771084537c161d9293001c5a3dc15d763dc0b94f09ef901891d9609d2636c7e440c695640b558a221cea1de41ce19b011711c4c3c75c3459546c9e2d96f5818ccc93a18440c9e17c040c052dae8bfcc06d314cf8499b60e1a85d0f13fb282a53e378c245e2663dedc1bfee0ba65cf2c583826ecfca5b5ce3604c955b44695c2eb947551141ecc244aa4dc185417e4d3dda9209f63ee920725c13c8a82e46f5e76945438112a111fb56037168373460b8cd325b8199ed600895326a92bc9e7aceafc1596d25dcd9547f591eb72a76703072d8868187a78c4160c1b50112b43719abd572e28f7a51f88fa00f7b8ea51ffb6354505d5a9a47338a9dc9038055db42cbe3bd50f825c0ef5bc0509bb5c77a3debd030769d811ca3ab1737a4168bfdebe76a7777f9585d58afcca23285381308d3a0fbd4dd16742b37d2ece5471567557f8c5d3853322ae3713f53f350cab248d5e5caee48d51af258882c2b8f9b2d7fe2c23cc663d168f27ec3b84ed6fb139d60396385e5d1ea5403bd8ead3a09f81f780aad8012758ef7fdfcba66ea35a7e88198c4fee0745d239a4c89769f5b32204ffc2361ac00ed850bfa7aaf6c65fd29c94ea5e7de47ed17cfd438216703bcb54d00400cea32a728e224c2759fcee18e598952c01f2929e6ab8ad9e4ffbebd07a762d095d60bc118207e5520f43e4f5205046d4a1eb54ec00b5d201b28d28486936b854ec473909a1390c2d95db9dca0ce01373827edb78971aa4b3857b73d02077383230e766a9bf7cf3481bfb6a28d333a5dedd5822691e134399e3e9249bfc612606cf185bfd79714569a17f17c1bcbaf347314c17ce3cfb05db32d2a8cef5759d70b9a7148f9b204849b65693b941155b53ab4e89f31ea0bd16dc083bdb1adcbcc9951231c3145eacae600bc8f070d3ff9b57eac8ab7c30bdbb711332cb1478c2b9b62e2316e85cf6e96981dc02d767206eafefb2d9c614e24f811182ccb85c0d223d3d14c58033ef29066814278e76fda0cdf91c847ab1dfeb28788eda7266e689dda926187cdd46843adfdd590f4f0599bc693c40b7dddd6cea27ff1a422be9ee1e833977a1f3bf16347e530cf8a3c1a46563f9fe34bd924fed82172bca75a881ce2f8102390da107e4b6f0fde53485ee23697142a79abaed19fd8c45ecb0ec76f20991c201037fe1729e9969034402f64a37787ab05f10b76d222142282fa5035c7f02c1679a85b3f1f108ac67eeee493809b1495f5e18ec45b51a8b511eec36013bc6fbbf84a988cade2fa6539d4cdc94018da288effcfdac49c11566b7a8f35171541406c65e9e53c8ea66e1f584d8f462147a6383979323658a98c193c67df375474d57fd9d2555255fcb2a7df7f8928906e1b0167d94b9fd314ed8ef42a6dc42cc9c1b66f863ab77a23768450eddd9d410c8fee4066b2c39226a444d565216592966f996cdf99ca3c1ec8de5f9f6791aeec9a154ced15eb8ee1cbe4a9ef2f7ab08755a490a8671575e9ff24078bec7e3b366cf20144cd254d9637ef3572ab2b7606b643bf6541211eba51254fa66aac1ff53668cc0003c40aa206eb39598775564cbd469b5c84819a383e539bbc724e55d5baf4d41b6eaa586806103f7a3efb047ef7a809603f5d5fb1c38903fa80cff42e8e08b5c21579924c295b407bec7d25d4117dc3ecc81186145a0612428bd3e06458893c299f212ed158934802cb7225e3d31e8c833267e45431932e68dfcdf8cdc05fea05f87bdccd0fa65fdc963c917890a5030a68014a8c2115fde73a09cbd5b75dd84fe2e8b1820e22d7c45fa57b212e05399e660389888e3bb78d06c15f1978aaa7e8f6d507e2066ad37c3795cbda1d7b06bb3e1f8b9b285457cd00874aafdccc1dc550ddb5a3425aa1c117a57b893ac3409e668f97a101ea6c00fbfb581d8d0b5d26d36cfaa75e57f75b66fa971fb877f238ec35a355abc31018bb3345c5d9a8ed73384f82405fcb15e0783e9c1d16735fcaa778e2dc7e27e6cc613fff9ee674c2b1795c4a1d9c4ce592c6b76c0fe5fa65b97c2528268e17b456c878089ba9553cc68622b02102d9107f958c5d1e38bb03cf7b50c6d176b4f146ceee1e0c5338d0c1cccf58db6983ae80fbe8ee4f4486b5bd4928c1131d74a638c36364223339ccdbf7903ed19cc72cf649ef55907d427665f073163b78a72f41ac555fe45c0668dcbff4409684b3aa28cc5765a557bc1c97a54c1e2eefcd126e7e70dd9385cbeedb2b71d5c8a2b1b14be5c2e3d2a31cab790205f736f28d0964638310e943edc9a475c32d13bc1569a3ee0d03c9e7cfc8ef547f3635a6fe98b5fc2730c657e31770ac822077e57409617d9f59e20025ec447cc86d3eeb3b4cc93dd4b79710aef1a9e88f84b57c6ab33d4afdabe03468bc5c4a04786989bc48c4a244c028d0520fa824cb619801cfd1db6e4817f15f8c0018646fc0bb6558c1ee1dd30c18a42e76060e501fff043725a3628c739e145d94e0bad4620aab65fa9241eda8d175ff0cfcab36a9a69b3ffc162e7968be929be28d01cf688a92f0956b8c72549bd366d7e68e5094b41df2d3533d3d16686cc2e0dcdde5c4b078e302eb113ae965f0cb1e5e8d286fe2d75d9e937cf02688611e815f88e19d3834d1c7119ca68af6fa85bfe3e2d828cbe7b02b598551f1d0263d309dd82dc949bdfe3b060207b1f12c4cf3184d8d8dc2a38a0fe781d8e14000b171e0d6a5f2f4070d562efe5b0bfd3989ea61bad0a67ccb60a91b436f972078fb18ae72a44f93676a8c8624d6b9877f8035c3865917d05f3244235ab8fc04bcc29e4a316d0e513c99e8233a79112d78a646581186304fa9382315215f8cfe990138c724a4952023ae3c4e5b2ce5fa9ceea20edbf466f2ba6b52b1f0ee6218a05e8264f09321e14306aae67f51530ee9350c5fc0b3a012895f0544c15ca3e534e3bf7435835270685435468c70e0d86212e596948093dd631d56f9e912bf2e280d4768d49fa2a3c5d0471838c9763ef319c9807ab5250ce714ee670b4c6053a256a77e78d7b8560bf868fb74a4bbc50446ed73c0a24edc50fedd6e4ec85c98876ed076da16c5dc7c1412e65d622c5a0859207231c1cdf13af05e69dd594526483980b7a487dfe22224aa4e2e2fdca26d23491e96568175f0551b55afa0de6d81064d7b11f4244c3e58e089329243daecfa41a0e3f8747aac6586373ee5388442cd47f9bfb7bee7ca07c899836f3afbb51c7939ee450e573d2c4220c8608e0ba41e2340f8d412cb4ea053d5e62f4e3533e8e6d2ed87836ff0afdf4374958505377275854f1adf754e132f5e8404a7f892bec2f31c06fbcbd32b7db81b5cd5561af5721c6b55b2fe748d23e763e5ec17dbc4fa7b90693c96fd543711d28c0a0cc9f014b96a4a96049e04063a2915c3c3a23af5b24f15164b268c6d5d4d81de3c1466f37b2973b2c30c08d18c0fe203299b868024dc9ccc1f97d057c7c2b1cf526fc41baba79dde597711d440ab48854abd4fd5a31217e02745feee185003582a612da0cec8f9e01b1c4edc6b544c28890c6832fdb0a5d47957df74b8369556f61fa856355e3a2cb6f119c633611f9f05cf4322a2173651ad5903dd84a95faac671f8fd8fe8bfe9ac098f276fb5e8cde53fbcf0e17722e19bb97f0acb57a8f216b26a63f9cd682fdc1982d134d85e029cfddc4cb4c77c4e218d9c5ea967b66e1aa0ae62c49dac02d3e2933e2bbacf6ea8cd18db18e73ae2fd3687005870328b26157680641735459293647f31bb2327528c84f8544c18fff5fab13da1474ddaf848d53d36f9f6ccdee3edc1c7c958c10c79c853f98f5ff9a71c99ca4c18e189469310507f549cfb4affe7f6e93f655cd9d1a80a685721eb5a8aab9e280aabb6ae3d3e8a16c0a40e4a3483bcb1740feca51a4def47d2d9ac786cba277c536d8ae5222552f035d0b2ea1f9c46d0ac5f066751d7042d1a218100eff5159ec93fdca8fb4e0e77efe90ef5bdd597bad28120dc5128e111091b8d3872e94983187a28bf931b37f6c9ab5960e10b95a761fd9aaa6f053607bcff3c02eedd0ca73e8ca4b750cfeb8e8069eedb29983ca2aea5bc72cf2144e9f6429297e1c222106e6d9b57a1c39ff89bc0b7fe3ca40eb3e2768e23410a0709286ae9c0b610d995538fbea1a29e2b2c3c87fc1ce20d759c9634236b4796030c505600d7b75f0c9eb7e6a3560a4b78127e85971f276f3c60a69f0c16ed02562f0898ba85aa6b09e27dd4f82afb1f9b859a650e1991659a0481985ccb5cbfe6993878e2f7856b8865cf74ef19e1cbd605d38bf979c4b4feca1c6614dc7e5c5f417e0f6a81619106f90093af683eb23b05fe6fdb5242b0ea63e9faffa1e1d62261b45d21f937596184412d80920f4bda923f5922132e1e9acb773da0d432dd944c8dc983be7c41eeb6272bea5aff5213b854db250f9424a21e5e992a38448366a2737ff9f1d522f9ca1e30d8b4e95f7e77660d9f6c84b103562aeeffd2f1d53dfc5a78e9bb9862c1434ce57a6828283e68409d706099c511415c1e65759dd06ce9f56c7ec20ede13c6be7c5aeaa08aeda2e5bfefbaff78025c109fde6210e4ca3f5e5015e497d2d47fead007ef6fdf038544584f6ccd17e285e73e64f34ebf6457072cb083042a542424cf5f35bf82706edd152fdad2def1c59fd9f7be64d1b85ec14c6eeffe2869303d38df6b23e45fbb4b4fd29574546afbfa4fdd60340f3d23b04d4911dcb1a3870e51e3e7d85b8e41ee69a5d21e6f07f1aeb0c90a07ec0f25c1ac99f8de9411b95fac3b7dd77d05bb5507003e28265a55f548b912dee14d2283afc056c3075e74a090635393ae94ff174534f8b5592596b2fbdcfc1414a9a719fcae68ef3c852d97bb908bffc9c23174ec6165891b8178138fcba38c0264a74f43a74c3224e9d27d6b40706c5f0ec4346879861c84b7472c527e0948ef2ecdc0601dc64f2f05c1f10971d28d107f3f422b6a744f9f67b867b86e35e8eaab9bd0f27e90e85aab0004699c7ed1eec1f95956769586f00124a44fc89ecb1c0d9236cd09dc7abfe5395fa144b5b02c1eabf728c86b04e07143a87a0b51e7e9ba12f05d27e2b3f0bb6e2285f66977a00f175acb573c16d1f1213b3f9a01b558d0cc3e60b477c91a50ce6c810c514a7ce31f85c682200486c9269d395b656aaaf61f9a8444344f6ed47527bc1fbd15567cccd96070e53e53151bc336e52fc883cd79722bfc488b918ff83a08640cdbe32b2b5e56de22cb4b55152df20466be6dfdaf52cea37ccc1c731482dd459b39cc68b51bee1dd0b627c5d185525784256af84d776cdef1b3e0c7999a1f19432c1610238791111ed47b75001a02d516b044766c530e1a2a76f879106ec50a17888ce486ba004908a12668e94b8fcc90bedddedb3ac0c4b114ee8847382886dc3d36eddde0ac961fdf08bf8a8ae3bbca5175be79eda716e9b4ca5156cea7afc49ac9a942872beafca65abf650bc11fb3730c7e917b98bda45c2dd83f9e59e7ad1910614359b5ef797bded1ae4f3260cd664bea08079bed3eb0e797e54716dfcd8b92ed7f35324cb594c66ef088cfebd6710a2a5ec779b7a161630f993f387bfa90bce7ed05e007f6c37a5569c656ecdc1b7ffd3c6d2edd2a74540cb597fcb0de2d37800b2f3c08bf7c29a70e5e13a8c82cd11b65eb1846fe448d532168857f61faa96fa7d80a73528b1709706ba096ed56d822edd07a00e6dc6dbd483ea210908d3777ceb9ea27d4dfdd8021e492801ae85371e01d92ef0bc7c8083864c3f36c190c52fcf0a27f8895dd49b7629b2f09edb5dd53512613c820f8fc00f87871cfcc34a281139bb705b8a236d139fcd136f57410b2253534edef264e9a1e31fbd9c717a8fdbb785e4f0d57b86bab8ec6586e064e9d984f1707a7a3a7438a3199c4f497e604a57bbcad3fe888df149f4ee1f991a2f4e7fe11ef5664b75871b427a635aece7a15d46d8dbd9049118d4148231812ac4ad3c636234314048eca8e273b328b05c61f81d6a599eba8d4fc7aec88b92ddb11748326808d275cc6b7086fdaceb31817775bf31724b59fc16706d3fd1a545c580c98870509c25dec71ab94da10026416c9d862c128df83af2d834a8dacf76be614e582f7cd9f168b8204cfdf736636fd6719a6cbd4b2f98e405c94a571bc6fd1f27c2ceee421f63f7e662892c5e34cb0116eac04aff4a8f87e90ee55200a30f0c5d0bb324fd7d7c72dd6699a6690a38ebf23d61a2f7450b49d4ceda43552c12c3db5ec2cfdd8a27d4ed63ceaadf50e14e5a1d29bdfacd7663d16a7ffd78a1bf29f00c999501f8696877b49ffb861e6bb18709cf61036cd5d540dda37179df65666edcecd3e5343a2bed6d8bd81b6232f9df88928a6973df96edf0a73611a420f6d4c8d88ed51a24dfbd9a98df4d64347f2d3be94adfd89a0394012ea68e92075e296dde0d5904db85352523fa5525da27e77acf716bbb616e0dee6cd7b275f613d70f97e1b4d68d386213d15250df8471c5cf0c0c6988da7a43177ce4cbe3ebb9962c75dd99e55d388995d912dad7543378ebe1f0ee36dc9d2f0cde393eef44ecfe1a00bbc0a6b2c4f1b8c76c7218acd9f676fdd62dd7fb3fdfe56afd139cd7e1ade19910e531477c109a6480451085d4687798415a24bb137a25cfbd4487b60ec69168725760976bab656e301ef2bf9be98b4ba5bbcb9f0fa3796c65cc2bd862d9d1cc29c484b000099eb2c1861dea60362a8a7433b8be98dd3d3985b14aa784d54c78b0e9e96aa4cc7e6bf24a8f82a73cdea2e06ea950a9335af62f60ed7a6921cebfc286e95a52cc29d4523c941c2f183aa88433e3d5b3d11ee9e9a6036e6d2bdef74b0e5ce1e367b25d7e0f2d639ee05abda63c6e423167e481083d5bc05de0baadd6384cb5881aabb829893f83792c067ba5a1608b49ca70d112ee58474231b4f862cbf5a35546c8bc6a8af3682418c4cd78f69b9dae2d03fb8e82996281365273149e5cf0d47ea1cb310cbf0e44c0d85992f625c74ea3149e77c574d31672652756ba1fdcdcffc1bf004bb7d61dd457ee64c0ff36069f0663180755ad1fe105e91af0c235b447c3b06b142b624eb904f1331cf8c073b1bcfc242d811552cab7eb42ca0d8041e37407e94deddcf44eedd283823af7fc16dfb0e6c0a6be518df6b2539b64609a21d00a26267cfbef06ebb320a3b37d7549979b3fb102f7a40066943e95fd5f0f12ce01759ed3d99abbbe96c4b872fddb9978810aa1962ad82a92ed6f7a24e73876a84a0b7e4b582b388e73910ee4fb259f205403685f6dbe207be8ce677ac7bd0528b0c6371b99a16971551de6a1d7da0046355945d5b437841544cb405ee573db7dbee9809ef165202b29f6a28680644005b79551454677af31b4c17b2ebcbb5c5093d3ef705a679c8832829372c00249c941d5b0eb5322cf60794d9c92961fa3824bbb5475fc47e2d8a2241f8564f1c44c10077cb7c46d70c783c8eb569920c49adbd42f595c5c743eaf431e900ab1507399dd59ab255404f18c4a84af7e54452bb23b1b2d1b3a893c7c09d5d4b4fed7a808570d580d31b82db95f3fb42312d419821530069ab36f908b138cefa3d138b20384a3887fc0f76b9b4b196941a6c86ce5d808e8112d9950925ea1b7c15d79e185647adfdaf4f0161882308c2aa7c621c04586f862e9f7b05c21f78eb0d1bdf10614d09a15a0ff03bbd15ca91ec357a8b81f3799aa9bdd7a0e0af45bb3f26670135eabd64390031a8714881f63d2f2cfe1365e3702bf2fc18819d659252bf93658ed348f716f4450b0ccdfd37919e041da5e467afe4f205c90911e1bd165b8315b59f7b47858aa6eb14e0bc6d47318c35b4f6692fb1ec8ddd3fb9352729e9853deff568875b166d40839bcacdeb79d5dc49b119934e27574e94938445f4110e8e016f5c63bb0b86ef6f03fd45dba2f5185e69f7fdc2895f55ea859fb4771b7481e041c2bf29c308213598fe9bf95304919d728b98dfab583bcdd0e9f800fde79019c07e0f6130d4cba23fc3314ee5a2f06a528ada025e9efae435c1ae4ea64fd0c306e87146aeef8579c4c304517da81df7222d0ded50bc9fab7e3979ab09b972e0b84b1a7d40e6bcd16b51586d99e806592798cb63f0990623c103cb796250cc7e629867f276867aba9556511ff402fe3cfb0ae7fb6ffaf7bbe062fbe030b15ae1b916e4e57527075db4b0b561d228489b5be9eb602bb14602af61613eb2a1040ff97deb89d2f85f9c205422c372e77b44407eec819413e14d21d5e5c6161f98a02f3658b59aeb72afb353bdcda0bb60428ce8bd4745b09922e8b61a7fe102fcad36f802b4394aee7faf9261e052aba96c75dec369ae92787ec4f92a9e68135a3a605be9db68bbdaaa7ef6680c6184adacf886a5cca45dcad2fdd33cb46677d22bf9e3bbb141019467444d47667a4256a7a368d9722f05652bd7cccdf907119665f6f1d425f5db71fedaf3e1c0239fc194d6e29b31da5a172a18dc49da975ed67baedb28b6040e4a158229bfb95afc40bba4fefff5c19f78b4cb9981aacdda722599db16ab7c2f8f1209a70f886df3a6a80a4ca67dfffd07be0ae7a77fa44a98e49e1a0efdc4bf0b183b80ded6fd99788217b1d9e6d156ab110e0a5a21a9cb8f267b75d4ff8143be5ba0a97fa6260afd36a549cb6326d29dde7317b85711faa875a36abddb73630b354b6f7c130e91ad772fcbda1c7fd5798f60e02841f496ff77ce05ec6065c86a1a9bd1477ad180a1d4884cc58364959ec4aa9cc8b06048b973730551867c99fbd73442c10d71084fdffcb2cb6800749801efe1100b151fc92fc683eb60abba915d62bc1821f7dae4238c2f55beedacff24ca01a98b6890d18a9caaeb9fb6dbad7d7ca098e79c53821eb0ee13e66d948cad3ac3f69d81d092f906b72955cba4f3695b8b04c3e7d58190185a0ab44e78d5dbdc132ac8b9261247270f0df1f60d28bba5bf3ad71a916f6edda51498d31b9e4f2e24754433d41dfcd5450b334f32b53c54921c49b460f9ce54e9f16b1e987ff7d15b12227949c204a7eae80301b9852cf97106b7e2b7068376c3b5d706aa47886e53f91d009826aab541301dd9ffe849519bd1aa8e4059b9d7ade4ffe6bd9e7a52f96b974bc5097319680e53586979e5dd8a4ce4510b65888c44d58a3d5cc3661f01ef3ee245bbaeefe5c54c15f0627b274f023393651290bb2b73088405299c2f4ed666ef2fb46b9f142f3034e0d755d07eada52c3f4ac3d90ec67e4aad54db215cc25e3a14fdbd35c9f9d2e55c384c01dc84e3a74320e3a3cee462b25549a83507fb65df1bc655b932bc057f94fb7e7167abd886aae014d47d2d4789b371cee0e9b6349eaa35ad3da5c7e1906915de01d8890812fc6a74cd11abf43ec5676efefd5ba7ca71222e56e3f204500a5e77742a1eabf30a86b249117747ae13e2b60fd388ccf15d3dab909aa9fb8018607d0fb66a5063f02f8a86f56558058a595f38376125916fc411b8635fd44df2e209ed98814461395517d499a330b593f4bdf36af2a3daa52778ac3762409515c243967e227c78521ca56f338659d2d4213d0d3c823e14976a223bf26bb9ee677d62602e0bde4e63784484a7cc638e5b9f24f76807186e1245f291a17e63c56e20ddc3e5709fae7ae4348679dd0c1b307e1fb79aa808bfb7ac0b1d3f4b72e5e01ab6ada8c550da93d6a9ff37feb38f618e8a4148bc83e27fc948e46520b621793aeeeeb75d7b8899517d69bbc2dcc0c2811e4104e2e0b6c68dcec138a854ff8632eef770b7e87583b53414545413a4bf119095fa9d7d286fd10843135ad26ffdee08a42d1938917acdb89bcd47c6df44b2e7ef265ec7b488ca283ad7e8b650bd61e74eff24bf8488db4870a0dcdff8efdac81068e525f36a8b9bee2bdbf7b2511b64eaeeca001f4b5cb14a3313dfcb640c7fb47e3ae15fef09d5176c6a285f885a7329ca656a9b8946dd88e42ad27a449e5897f2204dc0e406a6475017912a2250ade40c19b0e503d0d730f0e13b3c4fef5edd5eec1a6774f79f2be40fd456298f4ab0b2e60e6e35066a8a9bb36e1578af8a7f7ec8935af9a07c81e13041141fcf5cd71a691c2a19fbd30a33a5fa9f33a4cafda88c67d866b861604ab22212a46e319345d6c7cbaf358c86612c1376a97081ae15c32ce78292873bd8a244732f4f1ce787a6eca1fe61aa8e9b4e364092b98fe94777c30ebfac58698f4ee67807ae6f1539b9c5c524cc9a8219eadaf768d5d05fd9fdab53caf50f8d28381d0b3fc507bea659e9fd1cc3972dea845f7aa3071a70bc580408904ce49c8462f911a3211e3887d4d61997bfddfb515d2cceb6e5e4a2243558fd324e34286a892091ef2b74337272f3e00d5aef27a1204977a7f521f5b2996df458a63feabd7210f7d41c40847a9e8f42f29414a77929a3ba6f9988704553805661e95c9d0554d1ff71f8daea14b428c62b581372fa83fa8045db1d2d0aed7151d3a76197c775c6016ce15412fbe7df36d4c747d59e0585de2a1f714c7baf525d7039adb7f2cd1259a3c7bbebe6b007f557c5aa40d79e3c7c2e2e4b4242e0917de803cdb979cfdb40f7c1481797c9ae52cb2f3a29d38e17d7093569c9762da38934f4714eac7bc458a65559c7f0f4e023318a1bf7765a1f66cdbbb0c4ba45dd40f5eb8950289e390995075a582a8ec0d3c0e5b964f0b90416215256010d65eed9132df8da2a06d306447778b3f796d4672b0d410ac815e3a6d2014e27736750965657f30ba9d28f5957a8371e2c02d267c9ddc4f9299997ac5f087cec2b4e6442960339f1fc0212e620ad8ff84da8bf3a3cafb791be3597ab4ea9456f649e92867bc6a86c44263218c75307c5516cadd3e0232008c5ae9dfe7dc8e07d051d8e1bef5a8ba6f5df063d3db08ae4026d18fcf7c2484a1db40ed5514fbe16dded87fe730404fed5e467747c20889451a84083e65d5c8afa33b8d61d6d852e5d0379abc16203162ac215d184ac0e3973aef5377a605c14466109cfa529abc811e0327f7ef9597d94d210c5e12283cac5e135095aaeebb2ba000e58f8bfd03cfb1d7467a77991555de08a0463fe54d90a97b9023b8efc28555c6b33d7afeb0bb81d086ec88e2f68eda163e34c27f5c03cf0910727b6a99cf3351e1631db5ca8ba85beb25f61704f613f2c0c19d4ffed3088733188d328b5ff82c2ae45de32d90d4bdb163694f09a950b46557f979811a8a9061c8901bfd48fd9d2faa515776908c6465e2ce23380530f65625cd062399e3e4894549cd3c3743e937cfce0b5212794c6338e0660b2ddbe6abf5852701b723fd1cc325ae9243bd17373cccd5169084491688f8fa9ec050008a1971d7346f4417ee90e5cf82b4b0f4d528ce96d00e279c67e0ef7a29ca7aa6795bca9ca2db45170771267da4e156842d4b5fa238ba20086ed33b2cab1034c992ec986856f2638b9103f58a047699b8832ef09a533d39dc9987d8ea326d9cb4e03e2976d085e8cb6c0a86723cf9476783dae0a8695715a9295f36170170c37c1ad80f1eb790ef1e789cf399a4ce933f55217cd364841305d8c050733d390506539a157872053cf56bf6f7346d50ff1e587c8b2fb5e520a81854f92b4ad2a3adca244e90f1e2702ef270a64ef861a1ae874bf57ce5aabd7509e48639bddc0dc23eedd56b77e0f9bec18fc07bd2e3ea8268b2b75fffc2e87b9be6615f8a89d16e3b9ae8984b2e39922f738d79701edf36acf2210ad775152ee11f08df729c1b04154a7f280cd5c27af2bbf330afda2bfe4a7836b74f4144e188307dc6b94c3f5a761d14b4ee17aad33edb22da185f51af07542ff76346107a94c2b8e5401be72a1a89862e9c9896218324c7cccd65918b3b43b560e8e88bfb703754a5796ea6cff1e30e0cc7f624ce9b4048071d0a058666716c8a50d985a73c4961c346f0252adbd55312db1da32cd4648a48cbab8d7ce11638502a973efd4b87b06fa2b578398e22249dbdef4dcb5c3bb106c023fdff6168bf2e079abf7b11058f11e685478f5278bc7a63ffd2a361a3158abb3a5bb25b29a1827f0985358dd354f99eaadbd7b06604f8823a1e919f3a3c52d61d429c58b84b2f712d7c8b2e601426e8531b676111ae5c4af143c6b6b2445146d33365a3b47612ce59a2de185db49b101000db628d053fb4b60e918d8542bc8761f1e9db39729515de8046267e9197c9af929493f0b6522b0971a3f9b59455c3e2402a65e239d38673ea5a99ebe2668b2fe1eeaa703a0f3dc5ede25ffa07ec5f613c8d4b4158b12da0e5029d25f49dd11e1dcbcad8b3ca460b6fe386815d21936375e548bb38568b05adb37eb5cc5bf52082060bcfc34225155bdb9bd0939ea1b82eb5b26bea53f20e9c7817b3ba81c711716567c3db8613591c8cc8f3a573752e75a2f17e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
