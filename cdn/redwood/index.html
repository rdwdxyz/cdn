<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"997a1d8c8f8ec2748e423ec7c7479c3b4ed353acb67c72e9f093f6b066faa370958d661be58acc2a128bd77f83cb9bd8e170ef11a2b1686f6c1ae3c212fdf004b3c7351fa520f0356307844806584e6f4674b62ac7b778b27d3ae52d4a501566c312d854c098fd286203b754a3d03e1d6c83460abe8329357945668c4dc5df81b8589949d81156020510389794ad9ea7e4901cdd10a3007d0b3c900afd14271481c34e874709b147b765a2d2146657520cdb1ba2e5803d89b41777958b0d60c2ea1cb5c3784ecb4ea76603f774e1cc7936cfdec438d0ae4b77424ab3a2db455c5baf4b58f2a8073e9a93dbbe2ab7c3c03e74e65ee311c12baa0fff9261b0ea84f47a8ee2631f0cae9735cb04c8ad61904860d50fccc8e6c61ef2d84a5814c8e6ffb36b3ddc16c267f7beb1f244b60eeaf879d13f3fedf7d0ad98eb4e113ac3e058d5ff6262af52982514758082b07ac451cd3d701b21eb264092f625dad7f914b11ec8aa1f0e3219c2365723d07a4985a8e2b049d64698263b93648a48859e9b4725922b158d1111ce04049a05e6ba1102b2857e77a78936b188b354e5fb2155d3a8c434d9231f72b862629d00dbae36f85fead78fd364a5ef57943f3ca8086907b6a0551548a31ce7e92d7f75c25b02621ce0c949e0ffebbf8602a0d8bdf8195bc72e60032c3d2a4049468faa8b6de2168fab5073e40726f745d669d6edba76a0b7a3ceb1f8d893eb0426a5c48ee960a0bd3679a49172cc3a98e28dc023b7646f6bdfb969d88432768a4e39c1227ab7f91391c3387ad9acbead215968b9073c70ef854a8fa093ec6d86fe75c9f77ccf24eb69a1a40c09eed656e8d52bf307c0a2d5e4281859f10841e15962c59deb847632d27785ee1e024abad8b71ee8e8b1d8326a3043a48f5e37b08bcbc21ae58e15b6301961045404d50c809ec4a5daff7b836f1f6e2bcbd1c0da05c9b2bb97fe06d6f1e338a051afa53c8a83ce7f2956f2268ff809738de6364b05a570b10a86bea591081f0e57c6ca170d9956ea44da804b4ef07acfc3954393fceccb22a1175378f5b7e8bbf4ab23ac92bbabfe2453aa0e07d5f5099fe0e670bafac0dc58e02bb38a7389c1358582ae23c1294a4f80c6e43e36fc151931e9f32c85f27170b1efd7f2ad8a8e653c2a5cd01ceb7876fd112105ae09502c6dbded302358cffcdeae27723af85703b0ca6919d8a0e7d8c868258f6164105f510a35e7af47d956224bf4c1a90d916285c55112bd9a1a971a4807fae2fc03d1a296dbfa537629a393970f10e1bdfdfd919d88041cc7066039164ab667139b2c0818fd12e99ce15908c0b3dc9fec4354a7a34e6829b65dc5c7b75289da8f9e6b7606116a40af5584b07a97509916026b49cd485ad35d2967f01c9663df2cc36fa7360db9a9dfe9001c58fd5705a9c569991ffea566935fc76c6824c0d204f82a5a29f331090c132b889405f330e1d310543bff1eb7b6c47cb4416a76a4937d837bed8e1dacde8f05430dd3eadaacdcad8976700239cdbea0300be871fe3c3e54ea9a591ba6e4966b7db46211cd7c78ee0acc4b1a9ef38a5dc4ce4025bf5321ad7cd58410e830617e856f9fb3a13a4895ecfe089daf63dce4aa60306ee83e92851053dde64a0ce48cf0e00c305d9ba607e50883c4b9fd9726dc522b9720fcbd68eafc93933153935e700ff5753785d77a838c4555a766ebb02638c481974385e46a959a603b582334b4b36e978fd91b66fe9eecd713c6ef8fa73ad43d52790a192da9b39621896e42b620871c983a42e93cadf72074cce87eeaf7439b7b67eb80c9f0aaca44bbaa8aed4c1c39e56b58a0320c53f818b8e56d6e1a58f46eaf7921bd7598ee8c2f34b4fc94faa247f28ba4e3bed1ca2eedf10a42f416b8f68d7650fe8d799f2a5957943b0c3c14d7d4a15226ff3e8bdcd1b0c890875f389c6a1ee18329cad38ad882b4ad3d53cbdd5c8d574e4a037ee6abe3fd9d03e53aa042c83f870f827c2de08a8ff1e9a4ed93f8d518819d27303636eb99502dc9ecba42f654582d34f3c0c0f03cee8471385973064091bd813681d38adf3ab0839742f7ea2833cd4d521cae66a9338b93563a9ffaa3b0ff960d90ecb026dcf6c74182362afbf982bbb4e374694a5f751ea0bfdc6c1b0ff7c876d4698441c2ffc5559524a8a1d68a7e8812b35094cd6e34111bf821fd923a35a9bfab500e16ebb414cc88092d48323f88b8c7abad2ba52a1b66d826fc9392b3769c99a910e10405001a0c06cf2ac9aa9b059aadf20a1f027aea160a1098f1628e882276c40cbb8636d652a3fdfbc29cf1f88bfac8a408b7eba5bd799180a14f46c6967f83b4584872c835d8907b6d6af443d24d652c467f62bb1d77ddf7971a2609a5d1fd5a6e4cd5ee83a4faad26105b1610c3ca429fb86bf8ce3d8096fdac709265d2195f91fecae8cfcfc7ef8b07204fd2009beebb1a6c2918ddbd33a49c125aa5da8c656acffd3fde5a5bf8dd4eea7b87e22835ba990b48f6e48330cdef5fdf1681dc3207250ae297f3ae2ee311f07abfbc62f38fd83f4ed718dd481e5b25eeb40b6f028acbb46ff40e23685513095bfac32002544fdd161b1ab82c0a699b7ba9971e7a496c89b3fb0e993afcc98a5bb4273bf57558d8daa19bf36b4a75f8d293eaf3d7d85df9a28e8cc71976200f73cc21b236b83a743a82b664757e2234d4ad97faed835c069c74764bbbf681ec1d804485a18a4b2bb46ed451f65db74dda3c8de8b88df83c8f1dc5185b989c9d9b8dab08bf4200a3015ef55764522fc0948713c4a6146b76086fee5b8951c48e951e51be6635cb7a8e9153f75e997441ffdf91005a69a3701b3ab4d20bd5cec4cec5814414952131e537d09ec0dd232b96ca16471ee1e3a3eff3cf5447a47d1016899e6c3fa6613c0515600d8b3f6da79dc710743fff3ce2d8727140b42ac1e75e607502c3789dc52b9bd6ec02eec14a074abff34db4bc7b34604c884026f4d06b60b5fe44c9027196e437012e78ca6e527b1542a78037f43f130aca38ae05020026be1a811756023a5dcfff4ad9c52a73164e9143668bf2d3e73d90953bee32249afe03ddccd5f8629fe3efae325b1f6d58ccd79cb0aa66e55d69ea298e25e92bcf87a8b0c887b123fce27635d4c02c668625cdca1438bfcbf9b4c49ff803523d1c8f530012864457f78b6402e33a02a7099681b2c9988e7395b92159ee6e7c320bdcda7c89a3638ddc5a18ac75b9fed43bb363df6e7ebc932c95e76fec126e81795c37ad9a7f6446e51f53490ab9055970e81736bb980059bbcd438a027b046228fb43763b3340b836ce3dd037204797a076cf612c879fec613775e5311996c056a637cb02485c65ce3734a3d0d50438126970fefe26b4b162d09f8196eb1eff7725f35f473cfa2850018915282b656ff9ba3b9dca991fa4f10201882cd268d7c17847859c1e1188afc7c618687c3c719209da9f44ee76e6f3303b35a54a0ff230ee67f26f5370f2ba6ea30a509a4cb2cbb98c27124bd54686bc820a2e30ddcc9bfad22e88d1547c8846067bc23252cd7028299fe4c65d426dd59ef6170e55d78c83c26a8e4c422ec7120434dad493e47c659b5230cfd59dda29bcd7023b824d50b0a6611aa3adda667061068384d2411258408823b299ead89e1ba1b6c83c1c70d0c9d32ddca3a98d8c95c2793ef14d8e01af0bf3de958b3bf0be14289e4327c749ed3df8568e4a0152bc6936a5d3de89aea68a9d372d95e34cba35e2da8065dfce26e9973c32f523705a355be926552801441accc0950211c543e8956b923f5ac9764141455f9a447338c1d0625cf37f73eb93db9b1cdf3bffc5eb01f93a6d33e3dd19216d2675a62b3d8321c1f1c0602670600e92f43768e9d4d36b559dc5b2ed1ba1d5af1ff14ab38349b2bbac7c87c05b813e31fc88e015feac58c00cad17b65d3b1dde1d8bda006e01b260e7a096bbf360ae0b248eb50b4466e899fc9362b501102c33f6714940f8cf98cc9dbbaaf63d00ef09b6d97cefed599b76b0b06d95680a92bab5327e1666ecc38317e629a7bf503a39827e523cac29f5cd6ba9c66ea67693bf79af913a9372b67aae07483631019807338c2a4cd389ad4b7486a1468114f0dddac28cfad9e74667ee419f9de28f0f20ac5bb2fe47d81e7eb37b6c801138fdb9fcd4df22c238ce6b8b07f88c15715a73f4bab4bbd5909922049b979452398c5fa36beb900b4ecbb5a57adb8be730e5abaa7131bf7caec9f14c7c2e34a10e6d95135cb0d4f3177b5336b8333c179cde9848f665ab01bbcf1b637cc305375c3c16c78a984b25313e792df0a9e346a135eacc9f09b16fe6989388fffdbc7c41bc886e7e3cc6344909256ceb10d30ca4e834065a60f55a1c5c0ff9cfece95ad0236852744f7be3e2794edd084a233c0b38fb97481e451eae0c95be9bc8613518e5d091c45bfc77eeb1a72d224b672d7390996f24a4cfcd362f5e073c19ba88789d0cbfaca3d336ce467492a23c1a42de1daa7e45c2e0a14241ded0a0e7bf347af558b6ea0020d15bd7d3ff26021d3aa63a04a76835d204e9426dabe198979a4843b552e5b59df2e0733cd23a216eee7232651ac116f1bee922d02aedd91d7b083e8b6f89c4d27a24282cd9c64ce1ed163cb7a6a0923e9114cef47fea8da67334b97f2cc41e415041615a7012a0924e93efba9431678b30584865ba660a36bdde1dbc41947bac24b8d984550d061ec6501b4adfe2964a7792840ab04fd7324aa4103f713342f52915f961ad4f3cde9b5359083aae44850c1ed372883af949e95714312aa24c222680e68df06a027881362ee6a09a25b53fbd34a619e1cb27b31c8c8a64be5487a2beaea3a6daf391084b3fbc82fd20617b6468570c403d3b5d7a7d7aaa00c189603f51105e9a0fd36093c79383cd631cfa7f30be424ec3de2020af61a1c03f82784f021227b51f7019495875685ad7ffeae61171f7f6a04b1cf8f6aca09cd6ebcd7ab46feaad26f13d636cba5fb2caa28ac011166b076a0c87e573ebbbe3d89ff4362cd7ff3a5f4cdb6c61f4741beab166fd38ce8efaea024819c78f578166eba04394ede229494e31fa147951c9a0f55b3f9a2cafad21e0abba766b2f2f9bb8069bd33fd3f0af6f8087165f03ba2051f9b6478a8d7153e262783020f62ec44dac7ca12129b16c319b6976cb4146c7ddd5ee92ef5efc10e89b04a91f873e4eb2362ec2bfd5b5c2cc42a45d94b80df8793bb60633061436d5dc403c9fc9991818e4d80c6da7dd3492f9e16c69c0c242902d13134c9cac09f20015af5144c72502a77978692c5e2032ed059937194fa86e0437dd9a55bb31224bc81b78956b0b21360bf6f0ffeeb00fe37ad54f405ae0339d622c67d4fd8542bbf316784d965ea28db9a1ede0f53a2b286e34da8f0d979d75f02b61d25d4adfe0204fe8de6df0d8ccc12fa85768834106be3074d27808e84d452bb42a1811fe02aaeadfb5b451aa0da968b59a5d92feefc827c947fbf5815a890b365d1bdef0ec985af21ef5c8cd5b36bbeaca7bcb1eb59a196815dce899e3ec91ec10648ceadedad9c3fdde46bd0c6c76ed0e9e2b425be0d120e0442498af66d4a79f67cf238bd9df9f5f4d39967b86bd479b17ebcc9950f50c19ffbcdefa3f89ec7e50cb3672b48216422a60ebd705540032bee9e2c7dd849fcc8ac582354daa8a2e6648cae06ac4840ee99b8a2501a3d808685bb6567dcc6c3c18942c766953bc81d1a71edc926f11ed1981445e0ca8f0a862a57c77a7957caab3b38b9ce257d80e535f9532c60d484db9f1471122cc75f9412e7ad202c4f260f25eee0e0a9e36f8b5f95d333a9dcefb9eb49bf1bd531df52008029b2e0e4a1694dd3fe723dcca322e03f7a6d8cc93fbc4c6d0e4089ff5522ca0c5f0ad6d068404a8b5718fc00508d08253a009d84548d0315507fb1d2463bbc64887a79ab76fa5c33a5be404f7954c1b5bc6a59e401594ef7770bc0a76706af8d6f42e2f32466fcf40a0561960fd3f742c383de6d7a784fc5a414582f7c1e9f3030ce6e3bbed57bcfdae3df157bd59f15c67c837ea153fe469baa2ccf83380bf793a0796e7fdb8ef681f4835e1ee2f5fd41a4432a6cbefe0d5b50c97de5a44ed3137fc3a331a11c4a90b4dba68f2074ca47d6f0e8fb9ef4802f418f3f44d866eb324c460f23a1acf18a44c44f78dd69a82a971634de8221c6955884345d6886d7689e9a1f82842f1ac55da55690d5c6fdfa9b3cf69972cd9e5427f21cc21d26946a7ca0bda7b04ef16f745aff5a7edca763beceb2291f1a3007409c6d725f6bde460f1a96dfe7b8082637fda06e9c5bfda2856cdebd98102e5d1c7506b959442bb348c12eb5fa622d8750463a229e7552405797a2b1d4354bf30bb3f766bcddae60479745f4e060f78069bf9da9ffd156ae32f62a5286c6c41cb64272048bacbfbb787d62bd38f58a5a9fd15b619c51fcb451d245da39f5d513142124e70641b75cd2e2a93692e9db56f523a6c2ace585d8ee0f048342cb557f60fdfa7bec27e1925e1c1cd0862be7010e3767d8593a79304f153fa817f38255a064efbec448f928d0aa76da23b4f750ca4b7189eb504ce7b56ca1ba35f498c04ed1136b3c9167178d08b09f3857a275433b152c35e2080c66da2b4628faf2c5e6f68ab6610ef8ec25245c9c0e82a6199253a44e28daebed2933b5f9818743228356c0223711fe7e456547a30a18dd00e711275790edc8cdd5ac5cc8d8dfc823d7c7ad37c611dfc143c7e64d4bc670b6ac7605930240e9dbcfbe9d3f33d9aee5a940bf64b09d31ae5d1239c87d8db75b4e077b3f2a8887a5408c8f8d6bbf904068045fb124e23a2bda957ffe835d9bb491c7753a4eeeac7b310d71299fa8383e2a086e72fdea6e300c94b163a0f3a63bb4271deba4697078925ea6344ece48aa9f4d29cdfe65cc01514ddf3b5d027e886fab0aff187c3b2f8249262e33f8ac24761b8d7a8adc44e63bc0dfba99267d5c1520bf9e3a0c083f292c13b9516e68fe3d0d711148a22e64d6dfdee120afa549c2a0bdc1fd9cc798fb67df4a02c9520807fdeb46c6fc9dcde98da5dd305f57fc26c5ba1eacc29908b4efb41658aef3e8e403a8052ea27b4ec5ba4b2c65b2e36b8d27fcbd1ba5f132a1f7006576ad00a81922849fd47eacdf50843b43884a8013887beecab2e3ab719c3797263ef6c817a5f0b38dcc04d2a4d72554f61cfa6673c1531f26fa91d1c3882626474f8288c666a6f2480fd850677f47d0f0452562c9ea482a4f6829bd39a61e0715db912255183f020cb12a7367a96b3c4e9400907d0bc70ef7305da5a9fb0839961c268d76e402b2d7bd0d026f6bfbfb1bb20f3975139af566fedaadc1c007a0c6ae5af78a482dbff782a1b652d97d7d9bc75456e5a1542e8901acf84542926bc64b0e5c6456d0cc6a9bec0592e314d1cdbb0eef34833d5d5e0b12117c9daa95e31b29da7d80a724d21005474ab3cbd89ac87c0de5b4bcdbaefa3de62063dd0a703485504d0654e1ef9fb056299d06d28aae1d856b7554a254627ca178e39e974beabd0f96015e1f2381296ad60d9701609025ae34c3184ae821fc9f5cc89fcb600803449384080426ef4224ec7e52e99a6b6c64eeb4cd1ce57c96ebc6e86e4944f7b96d7ed089ab898279bf54fcadd3655124046d0d73d330d5948f542cfd4edadea23f1138e465f138dd5ac2ca9504ce3039c910b47970df57ea1dfa9f7751269a48729aff501e3f5050dbd453dabc0724cdbd48a208acbe5342cef4c44f8ac6b222bc3c64de2ec11a2bd4665c5f638f130d86058a1340738a0d5e9a981b80cc33a444f513d5281a93160a37c241457f335b8b683d6fa10c89217e77f4a5205f9d8da35a03511f28fbd93e5250c2031b5e87122a23cc55c77350dc428013365aa7d1ac6432b9bee86996b74764d9307cd3e8ac5025ffc9c245a7f5f0525424f5ae069b7cc38523791d4d90279a730497bf4eaf92449247e417e3a27180216d4ef0ff78b9de215ca877f194c5c0a06725e38fb831179dba9e25827a0a8c103e762dcf315035c67c959a4aa09ee923677dc86059e8ad2af38fafb50f2e3000c76e2c41668bf7411d635fd6d1edd05a604d009062666b3d49bd7058185292a58950674c0188667871e599617763a6048d37b78f1483c54001880815d23e35d2968150263b0cb341c8a3a39d7be830bcfb88af1c8e08358b082f04b6906a1b9e2941a62bd8c7e0e0caffeee955c8f6fc4874ec5031aced928e3667f45103d42bdb94638a12bf6752b1b7808e60d92c316be48e1c04b1b7ff593c0ad239c702fddcb9ead970e5260c9b3ae1a8c5712f810c86e45c70f240f4b9941abc764a344dfdaee41f30526236b94469f94d5c016bc6b0315977519b8061779580338c4b0e4e69ee91ceff0601932bc61f0d361c631d71fdfe2f9200b26f4713d8b6f1c3e5ab8d5b3b6623ccdd3cc4a28397ff9a72a75fc6c9f8ae1a6f96907f8372d23921ec1dbf691d0d2d7830479f8b6ba53b051c72fd1c1cd02de383b5767b04f8c8fc62b94484517d0335fee7b0f41783d49a1aff257f5ed04ee9d31b1c720fa172bc707a9f98fa35dacba24c22f64e94189f5273b93f150c034253a0ffc0674f4ba176fae27396f70adc52958639937ead05c44cfefaf6425caf9878f4f5891b820c49439d6f72233a7535f5a7d09949525c4c2c8126204fd0b5d5d53bd52fd1398bcf43ca83d162da20e183c89bb4524a83cc851b5de9735a01ac1de57b70493243edfe0716d41fd4567e143e514876ddf22d224891a280204243a6104a085862e683e55cd7c3d5f3c35e10652aa2454b6c568ae96db196be016ab2b0849b23732d6fdf0f07450a5f063b9bc839dfb90c98f34edd0b9158c902f4f78e0c6acc61fbfba1ab5f1ccd040b32e9834d098dec9fa7b1ea73e607fc4223e85ce4c7120d1ca874080bcade24edadff75fb9bbea1c66962aaee00bfa697268446829d3aa610e1cbeb9c80ffd4744044319162ea851742c9200594bb3df19dfef3af109df44aa6c623f96941533cff02e8a1def87817c1c3a1c586ba0c32436dc026f18b71550ae367015e0840241e169f9e0a843661d887df96b79715bd9cdce76d04a97bc74db1857d4da665d1293bcb6443dc70f4778a32ee0d0b834fd764cb5be10a1876414671ce912cc10e3a8fe0fea56a0be1ca32855bd18f5573ed754b9aed81e035ceb77e4f7f0c7f2959bb67f35832c960c52fa616fd89e2e69d406a408d8c3c2e03c4ea9245cb45c32512094e5516b64d5e99891f37e96be5223ca3c0d263753dae50c4aeeb673a9a8fa7db7a8e31024acfb2ac40335fb7783d6c393699a13e4a72424367d414d03ee12c1259a2701f943a88632f3987eaa63f3113bb683a540237b2aaa4ae71343ef3fbd6461397a836f32944bf078ed817feef6c824cbb170b276499c5ebfebd291c2e7986b94f65a620831e32ff3e1b0fae5295a1816f84a2617ea44bf52c606b6f30432bcd1a161a5c96dd3565d5ab596b789902faaaf9b483a36bc816e12a8003577b2c25517dc98581f8f37f7696e5268774637cb3b6517a52ded8710c07c86445fabd7941bf366982480bf36539d9d5e70d1ad1b696f6cb5f2856139da60ae4082f5c582120fba1b2b9523978fcf54d108ab7f9b8107b17b62e8e5523b415aa427931219cb5074c55b1c5ca577fcffe4b6107a7af7a61f261d82b2e477a627e22a0ae0f04bb8ac82fc36eb5283605c7ec22f098b71a443adc28ad3f47cfc5a0843480d4e55f701b047a7ab1101c211e842e0dfeffdd01ea78b39fe445ecf38ba16328e94e58acb2e34023a8ba0feaae1b2debe6c25b66f25d6eda1267c33f9c23b587b8148f73c036d6549b6d3a18a4e9a639f29fa765e63406261b928a742115f9fd04616c63af4c3c95b8df5577c8d8fa2b2ced50fbc0d194a95769419fe1d7c8440ef19a0eb2754aaff14b8424f6600cacb9cce05db80fd60a89f42f60e3d8b58d8cc24ef5996ebaa559ad6efc9c3073814a9a71f283323e5ba1a74b06bc0414fe9e98ea176a09ddc15db404ffa8740d972b4a9ff4a0b77a06632717310e241f3f376439af8c9c63cff3455134140896f9dd1732c26f6a414baee1e57d81ed2220ababd0575105976f1f4e7a9a357c8b65ff6f8b6f844cfec86b0193ea8c6a106d86aa83c41db7b4b0f2baf1e1dbe67d7cf6b53bef84675ca58f84cd684eafc8def2b26c6f9f5e980d2a2a5b0bc98a898ecb93400eb2cbd6ce23189b0982f480d4407e519b8a105d8ededc37bb0241f3046987a3460cd87846145102f2b517e574223df67e2c0668408a07850b273f0b95068edb714bd9e6ccdff2e2d1b0123779a66dc33adbe5aef1a33456fc9b82b949ef091bc7a1272e0f4f545ec3ec7cc830d7115e370241bda34ba1852213a9e0dac31f58dc6e3ad139400fd4823b31f4da08ecab373234e1fb8062160bde1da4ca2430c82356cb0c044d8564eca1f9404352128a6fcd90096067517f1f64b2d42e41f71580a6088fd7041b17abdaaa23a2b510fdf78ad22abea06d447f7866a081d75f6e0c516c8e79063ba9538b0252fd4867025f69097a1629b9284d916f6f5814d6211753df0d6f09e5e93976e4b286ed2988b358c6531102d32a8a027bc86c0d6f3fabbaed3130a123bb7a5067408607cd1fa7cdc6f109a9c83285ab7dcc2ee70c24c0263107b0189da41fdf68dc4868382d61f5bb9352ceb284f68a41d32816357e5e1651090e57ab5aaf0202a950b7c177e261dbaa3f1b0402012ef2fea36167a251d658620ed73a78da703c032c6d81a67c4fa299acb6cc3413bd3121b37b8346a18856031cf938dcc3c93f816eba5219675cb3c88ff49e72bc9066ed0d7a7850d125100370643441ed9f6fe27851799ac23374b7cfa9135b7257c05a065712d781787df466b74566b5e25867ab4a4e2a137cc32844bfb7f024fccdaa89a10a0ca60d9567d19ec1552756e697073c3847aa3ee098e4f3044b7141164819066454f56d4f4aabd04b32a9efd214082ddf32d68b75c68307009d09f0af59dc2eb2c1f72eb3f3d34d41f15a2a3ee9cc797ab365870693dee2f0d93e8fec3d3ba609ddc9a77306ab38e70e56e0d81cb3d0eb2f8977101915ceb3e36b2f525fba85ca40e84da5793242f981dcc51cda66e041ce02e7bc64361d36a007b41dfa40047ecf8bc8172e8b95fbe46c84effce1626aaa1eb5cdde3c1e03e57d2c27d71d311f8156ff8c8a9e72e110906be0aef288531319154e5a7b05597443a9dd63d28262d75cf80775ce7f51855df5656dacdb22c81b6001beb3f011e2494fd991a5f7d72e5add3a149b2a366a180a973f0b84eab332bda33f838633fcfc61e9c59d77b7fee89ab62fecf789e1c4b05db53b24160a4b887a47777d39345a75e1dcc48557cebcc5c23c4e8e0935b4727afde82214e4bd68a386da9b1251811ed5e64ac15f4f48f312da7b5a926835cae92f0a2911759bc381be4f9dd9ac9b4f7d7551128a9245d5a3fea369a0d800af1e4b55d6cbc9dc275c87b6b645512dc0494ad7bacc7143bdcfe8d2b0b632fcb2bb3720e6cbfb2b2ff0181b060caa4c9f77c00864d5d24183eb56a8ddfa205104a38faf61d07134ed5c4a837da536a8a4c0af2987a39237579e896b635d1dce5d00eb5ffefc343fa75d36c6dc25f582438a5e6a0ece6d56a45132dcbb986b6075677ed36225f6a881669e867462bf8e16d9a227e7f1c12deb9d83a38ad74979d3833e0377163c4663c72721bcd18df19c9bbd0fcd12d8d4c28c0d97a6019e9ebbd186f6c984bc49903b168216e2667908d7aa615c06fc48110558cf7ac6a349ce3eb3e3a3425553ea7ffc37f093627b3d38d0c46537417008666dcbef44d8f6f68b4bee66aecfbeca4ed5e643ccf93efa5f4c1886ac89a9da6fe786dc7381854d583d1dc352ed46e6e3c7f3615c08378c8dc4281af33dee67db5bfae3a6ab361f07abb400953e832e2139209fa848f1b0beacd39a4271d750d05ac73a66de8aacd0b67b66d91b93600598e3edc17363defba81074296bd2083dd8a46d0d55b40e2367785d722c85bb54349d61a27428027eaf95d0f3eacd83c56464a684c76b5807327da5b228dc37374053d497dd04947c23d45077a8d40efc059f3fd5a9538a74d27fc88651d11d7fc200f10cd5f87660c647aa06a51a6fc797fdebef93a811615fac6ee63d240d2baba36b4360a19e7f667d677a99b64fb5131b2770abbb4aaa2842814f355329002151dfc2df88f4d7f30171513afca6c094a2e943eeba06453f6c7f06f9149beff7354451e1ddf53d33feab32fbf4d96ec8d3c42adf8195afd0d12a1b8d88417c5c2935c91de4fb1324cf6835b7d6434911274011917c8bfe9c047dd0ec574dd7f3119fabbb0f2315126783ac5b38e21608cd94f01411b7abd27aed61a8745f5b6f979b24ecef500a1bcb4569accd94a232e15aa0253633bc9cd7cc2d5ed59a1d894efbb98954e5260ef18bc75816b607125a8a5b8e518720b967092d5cc95ee79eb91e916551364e7d32349f6f6f17ba7d7a81e751d8baee5758644ce9eca932dc31c899ba48355a41d561e894d753880714b3092077453a1e30d71a0161bb80b3ce3b13f461b1ac828230cb139d062eb68342ce3d4ec53b8f2323dd759b074ae7974783e88ed77d55efb71b4695e3f05e63c0515af0c0e1e7e8ad0e83d2ee39c96fa0758da9be9cd3f7c5fefe72aca0c058911e6741a212a0f358b6a0f4b7678b0c4113cad8de9d597a76395515410d811b88f4d0d34958bbccf6ccc66438adba115fb0b9870d2441c32dbc06dc18cac983cd66c836575d99311e79efe12d8ae1518640ff20e5f34f6faf66a75c9a202528153a69616c7413731f37bf2770bec8d305901a664a5bb2f353af1fb5b4cc578206a0c63922e04eab857805c3078621ac9d27952bd8a20dc1cc76960d06ab255b54b110028b59b724a7da9d64bd32e4bf41362b7f84e50297bc0d93ac880d5ddc61abfd197e68b92f2b98484aaa055d0d9754cd5ed4eac9df8d92895cc87919e4d9a748bddfc80f249462f391fcdaa1f828df313d3ea4f59127baac79dc63dd5a3dd88e397cf3c64d55ea78045aad56b72f5d6e640f0e36d241363af86c18a4592936423aa3df3b252d64e7855d1f4133130217fe775c17b73c74980ea02563231d8111bcfe729a6448d78ce4bdc10db51ca44caabc626a20293b1cecd50bd77b098d67d30829f06c6d85b5fd4ccf7df48c998b6bca285a23420f875fee8fa3f8fe005a41a79a07a6310ec0ff1a2b96df62ecc45b10b9370794f974eafd4b5dc5132f035fbd0a38d2b104e37db2bb444df28ee6ceea423d2bd6222c3f25bc83a8b123ae46ae3c74574eee67657d1e53bd23121d548ecdf938ae73b71c259cdd8bb19af8473cf8a9d238dd5d579f35ccd9ea179e620545f24e3d1a651a7c16615e9bd6d5dc8e3beb26d8b192fb792d36125186f17b731e616615bec09868ac0949781576031584a06d91be1f7f49bb1778e745a967d05950d3d01ba84ab47af4acf1b8ef27326faecefde345f4b57afa967bc8be514d24c5a7c018a30a8613efdaf30047f8dcfc9513eb90f329b9dd71a0047c3074c36339ec53fa371c7ca72b0ad732502a20bded342dd9ec215d9ff09887640d2e5408b05acee647f4f71fe3f93ca5173d79af39189747ec1c36d1025f0fae672670dff1334dbaef6bf12c91291948b794f7805e294c0115c3ec2cb79cfbdd0570340f64ba0f657e9710a9eea2f54fe6368a6a341175383551fb6a89ac627350e5db3f694c3ef93764e90d80c8486357725d739c02ceaab4240c2828cd92b61a0716dd0f4b619fd80b463b06288784d9032ebbdb6f4d4cd32c4ee1e2da47684a1b31df73c6d232ec973109ac0840e1d305c569ef79cfd0bc838ca2e62033640eeb14a7d805b035b36c7d99382730efb842a3c03ab5ab80a6e246e0cd059e300066963305147cacd1441529da43d1d202f35902a15089083cf78cf29e95a1c9951f34fd6be5b10f59d51a17a09e9d9cd905cdb6064291ec97cfc667ea653020870231d7dfc6f98f7a733152d9d04290e389fd4baf6ca86a3f78968c946f22ac746a77189ce4097251f63183f1c15384e5b826cbaeec1f12cada17caa3ce565b3761381f4e603d83195eaa3736a186d2a3419127faa4ca5b3f647d08f97a707bf6bd13b2a05f0e1129eb1cf987fbf89ee8b0852baf856218e16fb55d516203e99bba8b25498cf03c9c0eaec7df9150017207dba95b5eb32dd16b633c7255ba7191e23d735c17a5ce825ff36e75fc810008238617cd3ef6fd6128839fcfbcf259d0aac65b43914c1f203d37710976b0284485a297774fd95f8e925542bbd671636fd7f42de1102c29e21a33bbf484b8c844da3ca92b65b2d493c1cebe10aaedce42b19b313eb9c8ee055c8b103da2591501bf81247dd6796dde981c1bc1ea45d8da551f1c7999fb522d2b68cd1649e7d14e0cd41d33ad3fc6107ec16fc51e63a8f527b223efd04fb6941b60cb56599e5a0883424af2572a0e73ff037ee1bce7a75692f5d039c1fdd505382b6706a6e711d1a3823ac1e042bd0d14f3b2bd22269a2afdb7e45d95eb8e0fefce096bc25b3ae25a94ac3ddcd4749fc4051820633149370215672b97c1175f58b008ff5ab3ddd9d2e186eed16a9f2a4c4c41debbc2e7b1fd6f2b4d65a9ec1f8aaa93e58dd4abaf52c02ea506cf18dea7475f94f96c50a03a29c67b0480a9f1513e2fcee6b4f827d45cbe5ea8921ae2e0e5cd3bd184d5800f7553af63921a750f4d5d12e1adbc0a6ef62dd1f74653bcb06fbf3581d1866d105f5f4ecd2359beb7d80799fd4884308bd7c60029dd8a55c2eee7f905877fa5ae79b0f92e254fbdc5b3302fa22a5ffa5c7debad8c09dc3955e9900f9b13abafec1cb8c799fc8306d905376a53f95de3cbdd18d41d33ba2950206e38e84c66287db3d933860e00ec06885b4cfa9ac6ab5096eb9010fedb40e24150ea4e6cf2a64cd456af56ce4c6cd641d9273045bf8ddcc8f3f37b3957030dfe8e21d9b163ae3637add35212ce6e0e27bb86c40e9f5b64fe85f47b29a66be221a3c66b738ad7ced466c792d063fc7be7e120c3214e5597df473e2b1abdc11240440d6ac6f09ebe339d290a515fa1c66509b0c15eaa4744c4070b4a22310054a597e326a10d1a5c6b914a06317dc9bc3b5a3a2bc30fd8cfb5669a95d6f754a57e015e6903e1411f9a38c354cfedb41212472c72a48e7167568b14d76eed421c4d92f75881479ae1afae3b108e2c08e00b863dc1f3a0c6c57e220b06870a18a9b5d2836ab10cf03befa12686622761ea53a8a56334576682cd964456c0c787febdf4ad4245c2ccc4f0376a1c88f8f2eef5d725d3b818d7b0df20d5ffa6bdcd1bb880702b02f25e85183e9677f7adace016790529dd2fa2619ee29d3c37b539761e2dbc5940391c0356ec5ee8d58facfa2805e23bab835a5f7146bede23f1f8c87a8faae401c69a809081fc11e356eaf9fd16a799037f4370f39797fa1a714b81f4ad90bfc0cf53e54bbac0e9519a6352dab4f6d3fcb6d1764a8cfa29d2a965280e3b910507a25cc107285191658117f049dc549aebd3ed1d6664db0227a919171241bf4fa3ac39bc5d084a331ee19d5ecbdff477dbbb89ddce156dd2d77dac11fd784f6c61173c8373addccb5dd452e1bde7c6ae395f65152d91349a6e1a30ce9718f9846fafb8c1fa7afb2e8451b74c37342b4fae4ba5afa368172f837da6baf9e920548e39a1aff6403996d562f33485b81eb18e0df4b181d759053c86d0d71ec72ac87ecbd9c1405d1bb4166af57ad4c8f72153371eb55fd00ba15517c14d5d4c557eefc568ddd21266a0fb1c7fd8e4cc110df35257b42319cee357f7bce3ccdc043b6060ce726bbfbc1ce759e7b1011aa22dde2d7ae1e8b9a5caa97cdb8a1aeb52f2602b45563c6fb70d3dfa0d6145ef789438c18384fe49c4dc7717249ef534276353689d7c7c7bc87f786a5a9c631d581a7310307be76e0382ab765fcf37a4926944abf7a01637bf18c6c4c2bb6175ed33d3a607773261ead0f5e793d4a633e9716ac30a35f5c496827dde90e9fffc3786b3b91fe7fe364007e0d082d618e0599d2eeb92734d17c264c7f8506af1b41a5edf3af61ff2739f65e6d812a3933acbdba21f297d7701640b664ddfaac9c61a22509467c12cc8620c1ce2dba381adea16129cf37e45c8e7df1fa31edcf2711429fa76ec1113a80a56e2e6964121c6b72a70470e4c2ff505e5689c3304537cc9b1cc62944ce30499394d0360fc32bb73f47b1b5eb57560a5c015deff84099a4f23b8acdeced26e18c1f93a07e8da7c415f80d70f46a503b6df344c911105c2d701cc736a61871d26ab5f962a4344daa6edebdeb1df8ee29f4d41cd69e2d58bb554c25778bacc390c579e333a7a307de37e449029583d9491d86db3fe736f3ac58c4b12328404e16e7a9bb5379008a3750b2eaf2583a367f0292889692d34effa6706822dda70fadd92ca46f936292bb20d701af58998a47135d6cfe5ffc55c11db3ceeac030989cf1fc353b1390b7b703bb7186b79a7df75e676039c80111f65a60526601a7fc686277167152b3d620d8fd4d28627b6e43bc3379df40cad0c10e0614438f191a4c5c19843ab55e3f95fe393527eb07ec100e7c41bf5fabfbb860c4262f00fc61c73034c9a2b1a8822ac125f40579a53d9bc14570716ba1a1bf1b5aef69b5f67a8fb1dba8d7ec1a40e6b0d0ff2b9787a1331de232f80477748632b88e0880c943a11faee6bdfb784189e80ad74ce481d9d8f36a0a99837d71d98a1b80bfa9cabe0453de208a61a81343553e73fa74664329071789dcf113c5580f6563596e5dec223875c28b874b0778d02d96b618400f062316edbc9e1f4392ee8d5cbd354d944a024808133c3a38d88e41cadd77ad7a1a5283d605527b8b4d98bd17f07f5dc32b52c77468fa40556ccb3a3bc4cbaf398c5d201c7ad86bfc3ba2105ab90c294d2e922cc7eb924e7a310ddca7d8bf624d37fc76550142e7258c6d7ea370db4b99b655bfcf33c59b3023b40649dc0d1dae4ae01baad2ef709eff5293739c95b9084424344b124419e94c57c01feee0964c191245f84b2d230d3d76fb45edf5c037d4806f67d19c093234eb3f3b6a83ca8d8fd85ac421ab64a8e2f4f702c6a3bc5a954ac96cba125a3ddd051b4e32a73e4c2cb2bf8bc731da9304e1b88d518aee85120bf5f83a8befd698d51dc40784472109b4ed47978babd95196f7f5336ec98cdf4d8f0fbd5a678d1faf49de25cfbef100502cb6f33bdd8a1549a9609b2d2b78017e3dcc04a92a7324f428cdc05646ef3d0a4e26755efd993147c9dc2f752547d3fe52ce3d06216e43a83b5719c65914ee89faa1d087db02bcdb2fb35e375f199fd0c07f2cd491b34576d1ce18e944210add6109a35e3b394ac9e5865d13985d675c5074166bb0fb2a59cd4339463ae8676d9a9e6ab12fd503c726cd5249c5ff4c5a95064c98f27aadef010c1829eb4030ab704c5b7ef015c67225a91d9545d398f7ce832ef358c964c9faec9b12ec3349812e659b581c3f855fe61c86e258d8e7985fee79908b0b445f7fa423389ad97765871b6e1e4fd77ac835b740151e808c76b5ce6e1b98bff614b092f25b1665cc082c8d2d6ca794a0a9abc2fbc1175454b8141a0c14bb073a8ed005d1f52c52355402cc762c42deccad4443b242189f35c59b229a8ab3b8154955b0285cf725a4ac14b1d67220b7f628ead3d4343cdd1ee8cf636a1ac8b3da6fd52e63eb37f13995c44f193d3cce5aea49be6a5430831e7c8da8d4b1b9c64dd981edfabb6f103998a626ce1774cdb3be302cd43aa3684e1bb980a8d239a8ed584a875dcbee00abd513dc4744dd4cce6fbaf3e59a268acd05385b856d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
