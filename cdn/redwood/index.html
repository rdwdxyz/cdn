<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d9a8f65549b39fe8999373ad6cf74e2c28ae90d9cadec777043eb8a265113839218a83b5b59916a73de204339dc28827b72a6b2525b984ed6801aaf0c66d075b370e1e52507199f1f4494e1779c6291a33351e0923afc37587ab1a122eb542de5f0723e90c0a9ab06d0f280356b21b2c7bbeaa4bc10778a90024bc6861efe68cb7a65f8c4f2e0b9ed66a733abb508e6dc0742a8d8895722cb0ca2068582cb817da1add5631df1b7e1019bf0cb95a8ab6932ebb9c2e85431f9c1c9b3cc7540276e9888034435972386f2fe2272eb620bc477efa623edc5f0ad24f2678b6a68fddd5ee3962a8812ac65c3d0f1436b6664c01bbd6ad9a8e93b525704c23d37c47daefbe5050029ac0045a599b7049ff85929169e4c026b280d5188df18ca00b9596e1d3641cc7a53ec72a620657cfec8a5d79b2ba21879b3f00f8ccf97e3eb93b7d3ab43c1ba2bb22fd6d9c6bec87f7766a619cd03f5aabf11e625bb4085b89fd61e0aad56b0badfccca423ec642168a144ae0d5097d6dbcf63f4285a33b5b371b2478ace7c15b11d87787ec474abffb1cd1707918fffb0a2dcd46da0830c1f97e0b5bc3615710549a24d47d74bbab6004b60f36afc266138291bfe728aa0204596a4545d0aa7f88718f4c46ba6824334c08f5eef4039c9cbf0ed5cbd54893e0354b6c1d8b22632d2b0840d5b5724e1941e4b7480f18d8984412d9a71bfca41b528feb86cb70d3153733203611b226ed6a8f9f1bf9adf24195b4ebf975b43f7508eeac3dd9be7c07d0f3f386f57ce33abe15085e0ea86e2dd1a49268decffcd70a1ee7eaab72977b9d2fad5e5b4eb58583efd4e321b9f24ebe6a5d99dd9b0f8d54014588c21486bc792e8ad69610d52917e1351427aba22a8b466b9f4d352d606ea2b363968a8a79edff9d11085b84c31769124400f576561b2baa4009f37c449147cb63f216c5498551877f3f3935406aac55f59a621255b7af2ee13b29516444fa9e980f99f5e647d7a578df10308b8e4ce4be07ab3ecc024c1351eba34de6a90a1c668180dc75ad6546d77f0f6d73d4354b5e8a287d009f71ff65004a07daff1d6410e9768a3939e17b3683c9e7369b15c5dfd12e86965946c653dc7adeb9aa76c2e7da314a06e6966ab5561e162534ad69529da67a36b225d0a6e80d6de45e69baf9ef7f225cabfde400b33c23b83b1440fe02d1fd99a569d62322674751dce752036a7e6b519fb7133c7f9327ca17ba64edb26c985eec57b4ea0469eab4bf5bec682e9a7efb5cb24d2c72eb1c016e053d79679ade789ad056333f2aae0a2bb0b5ef40da19a2d589ffd669c2aadabbe91e6b50b0c5cc9f52033164c69d8d4afd92f44e14a00fb736b3e60315b275fdf59807e634ef73f53ee8899aed8912094ac32cc77e293aabd0b21f4ddeaa3781ba9e70c0979ecd6e224f3801bd42ac0f07522441d1635f20bcff5ef0a3f4060135b7d6d2898c16430a9cf6cf378674ae03f095eb025cd92b50a14e7ee2fb84e2b198020feff55143840727f0a8d4a334eec78a4449ca0d5eb033ad2d7f98f0f6c4551f1ecbe5489f420b336ebd567bc114519301d9c8dda11ff0bc749a9a9eed1e923367f15bcffdd6e4a6270a2000b6914791dcf76974c09274c797e4012ab5105e85df27b3963c595c57aa26d2d08e3305c33af54021181f97eb61b0ad10e41e50b79e691d3552eec4452e5037e44ae4b1179c7a46a6a5aca09d84eaba32a5d250f878c3713f93e9e3fd3675dea2f22da85738c9e63865ab0a33499f7f311703bda482ec4063ce5daa4edc5c94acd4ce35eb6b31637d68f1805fdb81fa9ee976d52dc8317d6ced0228bec3289e8015b2b1886468bf5cb50da78af368961095498175d9600f0537a25c1ac356eb642a0f897332947d8c9deed66edd6d9ee39c85d96aa88eec77c4e8b66a63dc9c06b414442ab9eb9d40b5456246c349585af3206b1d3ffc224e50b8035e97a83094b96b754a8a59ceddde489c242d138ec7fb5d2c3ec649df23bf390b5e7a013336837897e530687fca769744e79e7fbeb95d75c61fd6f923aaf99a191ecde686d13943fa67bce7504d1949e8a286fe09fb8661df4d7a77ca9928c71ca4c7f04523162fc0d3aadea6cd1812ab2c29dcd1a159efbdd2d6b936674ce4b6e9af313a77bb3b4abb2974765306b276c70f595ea9d147f009b86048a30b4bd1b39c54e87e54810fa8610b1737c1b5120fab9e2e8aa11120d84aab2bec4263ad23a6a240b13b023fbcf26a371edf87340a9dcca43cbb02e92576726492d835d0dda72089bbfac6d383a85ddbc8aaffa61493dad4fe5b214a5b222c3bd63640d00e225131a6f087dec1ea70c7ea512b1c34c3f5e31bc06363a7fd3a6f4e8e6535b106dd1e06f85f9d963d988db17fcece9d36d0d19c38537352ec3f9e2cdfcb1dc31f0344a3dac47848ddfcc921de844936f045a4db7d2ec923ef2cc675f25b226fec45baa4eb7e3540fcc67105967eb9034a298339003fbf32bad933cc11a33afe8748231ec1c218700d4f0e71f6e416d799c9017955176e1491d85975f89bb7646c3f3f55443c4970d7b0b7012a0eb173b2b48a72fc64104ff19fedb15fd327e9e9892a712a07a357d66fe02aa3b1c8f73ae1717a47121e47819fe33f25c3f198a56c9e40a9a9d4b1f0fba8c061a4b392f5c9cf212c6850dcc21f199011cc68964df8567430c8827bcb4fc41f7d35cf84f5b76f86c8176e937777536ebf190940069df62d6ce503c62e039aaa0c0d591a3ec2514cb9856fb2c89b5b73c1a1d5f6aaf0b0ca5798ef1e169ca52f42455c7aa4e563c87a69372d7e8c09301de8aa53398b6da98507cf210ef08a8a4522b3887a1da37b6fe423328da2c239cad6a840c7d783306041e38703ad37d919ab1bee748a8daabd54668fb85ffd6046798c56cccbdab135eb4514c69cb912236703c87d57b449e9b82e44041393dd30a6331fed0c69d54bf868044bbfcdd5f1d1d767f0cc0524e2cb366ee92fb839c4bd1b4394801718b1e3930e209b5923b92423f359f76a1f7b60ffcb9192ee0f10de35f53d01c60d2dd4ef42f6c588faf3389a181db8b34e2afc67c6f71692f72706bf2e80e0dc4cf50e17ce1b781f1b293c524f021c590245795778eee42f5ba24055dd268881013578da23acc7f57a78c334a74d93a35e2c4c38d7b7b855984faab81372898afd3c065d5e165941d3473fc6d9a8372242c2b87ba385f41df8894ee23f9aa26dcb241f60da0e0bbf81bb9cef2112e5dd1fa417c644abc37a1ebd93a92726f41afb9f4aa82b2504700461659109a4e158232f0ed6336d1fa5f3cd4025fec44f79c7346d1f2fa56fbc81299a0618f61fa37bed2ce38f618a47d8093430c55cccdb1b4be305bcebf4f25a2f000c01024e9637fc7af6c1fabd8076618ad9d12d37f97ac064fc5c0436925bf2cbb763924918c68dba13ee2d2d3178bd06357e4fcfc044b70307ff45a37440c88bda9e334927cbcebc96aaad691ca2867663c5b647452d9fcabcf0b6f6e63d47245fdd9b1087e1e1d312f5660a539ff4bb4aa63542bc06ec0d00ea6a8e99024d9bafdb1a5ffd4804a59dc2761043d0b7d49a80f0c05f985da089ea38463db7a9a12df2fdcfd8f2596dbefc955e67917489c4ba74f57f75d1a1e1d6df6a56deb5dd57e4b2320fd512147c83ae303108d9bb6a62bc2c1a0ae5183f18c5f427f6cea99348c70afc75a61ba0af5b4c5224c721c6b42d9d05e904f5a296ddad94b5bd581ddf5684f0c63608cd64c3cbfcfe8bbffc572af5388108bfad4668629571e6f55665e7f990c25fc178293b2c45eff66888719d26a69fcf7a7dc0d69430a4f7b9cea741a8bf4c2de90745990b0a5f086cb8560c4e9a0b01ca61b0437ad7905fe90a4bc57df75e3648270facfffa391d8d122f86a373d57b8786f4c91decc49986089222cbb75573fa198a54e8c01499b86f9c684021052fb72e709ab836111acaddc429b41bf694321803fa3ca629bd988e4a6b6f76793c56941328095f773913b4c812e4ea85bf3fed6948ac2330e5930a6f009a3ceb97c678f3ca7d26beb8152d9862db2e137bc89f9a42928b5122d1189a4a4a1da14b915f9e44978f842bee7ff794ca821bddf38b14e2b11041357cbe2277c040b69de6053e99c316983a10fbf57a049062ee2f1c924fb239445d06e7a58bcce5ac427c96e82068a51db82169103b85489942842f9cc356e8e77c87409a8f0521a63b6bf190247a9aa96e8231eaad3882c1483ca66b2b60ae459e20436f99873edf624b6eba11b69e400b389180c78f79816a8a04a70df51dc3499c075861152da8ed49e09ac454683f15168baacaec8b98cecb8a5cbb18dad693d1001891ba0c2a9924a8c4d1286faa8e942c6cca8969f9bae2cec4e6132e2919ab56ea153ae4dade9e06e9bf837cbab359cb74c39fe45ce66b3b0075b2d34f6c61fc7d1396ff28a8bb823d8ad6b57164a574f327ea8ab6a1131aba02c9464f5a47e489a2c6a6d8ea01263ab8c02b3a8cd789b53a9b36c8ee05e9594e1a2c3886d315147c428ddbeb03be29eb30982ca8620d7d11cb85de1044416f8dfe8678227337cf9b9b8709df5970f3a887c1fd303c4132f5cdf44f60ea394b17ba63aa6ef2accb5bbf88e8ea2fefe1ef6c46abd587ec982536adecc8792297cab61a5ca6ff10d58cb0ab129e19d2c3801d03d3db2f9ed4053f0f193215d7aa5b20a754b09fa77e4e459f830d4fb682bc5e92037c6a45989456f9ecbde797127753a0e68d80379b2028cc71f37bc62c06e4ad93ae83b6a78a800ab9dadb3722a50d79e25d1d40e88c5e5f568f5b4c683891039c8223adf8e8195b573e4c143180631c05172f85b4c894837b78fccca251d357bbe5de9fa12fbef376ee76f8738e2760dae0d365e516344b8f222d22065dcb515b0d163b0a68fba311eff1c16ba9c8fc9eabf76d7163b3530fa2e1140879c0326022b8484e08d2a565a4fd3e31fc2c09d731489a9e29a3db0a7a747948c66d317cb23160c7fa00f5924c382f4772165f8966896417e29bcaed059dadb812ed620ec51ae0f5219824e9e37c8dc459cec71ceb093b850baf9328e3a4f5b27b211d35ce32a27954180e955180a30e4bc2967203f030f425a759753676799022d44094afcb1fffe9ce731f291916bf9631c9fff28837b2d5b1d37e19adf12cb176e59d293fdaa8e02c8b4f76f9180d1d7c799af99815a1743d2b8406c509c9a640649dac8def290180ce42b6212c82a20d6a48fc095cf23d13518244349655b47b29f1c13aba72e42e6dc2a0a64a68ebb41bd4ea0c809575fa39c493ae8b8e4445e5cf0639a060bb5b8b7c8836a70448736c15da8ceded860c6ff1b5295f3a549018a2bf6495819cc7fa990abf2533c24b7a5915cc928a5fd685813c8b3a5b9acb77de757f000dc9e26dbee6c5d7cff33099b7016d84c320b1e83cd90c8622aca4bd1076d0d137d104a7ff40743d475b3f6245e0aaa8a10369258bdb86e24a748a5480fafd444e0f6cf969e67762faa260faca9e1ec996653fd1a3427f433e27a23c9eace8ac5ea85e6f241702d4f667f7d002068fa01ff057b827f7a9dfeaa032070f790548445ffcb816f5b61d39c9088b06ab1bd99c365b7f90a331871b3109f200e6a6d70f661007b176a8429a0e7d31028318d6c47cb3a710853f39bc4c386963dae5902d477887f534c11a3f14791d7a281c4c0c6203a851f88c486c1c7eca749edf174b0b3f54ae2f48dadf9630da43707cb66383e43b28f7f87efa155a993fb64e102bfc04fa5d75b64f2be82ccfa400fe4132f13c29ead5df39265c332528ab00e000e3a9f74af1c6f6fb099dc1efdb05f92eee1569a8df87e0b9ff5750a50234fea0b3cbb1bbd81ccc1e6ef6a7680ba2216fee30cc4d6bbcf21f6f051fe8fe351b64024724e87122940977627e2e0f9f8ebce52eb17fcd5333f26d80ff7b62cb5f197c122a1bc57ebef6a10f2d5d52e61b34c7e018f61707d1f42d95141efe6f5db670437792cb2b49c1867aec06f41422bdbb48a5e56b6e382cab005e4a82ce630df7534c3183a726141f5d4f611ed35459caad282b667a6f55d5632bb2e3223d4b388464d0bf727924aea8c35df12c11f0334458b7de58e08c8f0beb19f2b36560f11ec9d8fbb390005d21f18d7a4c89e6458cbb6536b9e1799af4984e9ce2920661a64ebfcec9bce32cd7ba3ee790ca61f5f98685b231098845c1382f47cdb4ae5ad5e3e5cbc50e052a77cdb8d0c7eb3a89f3d118a754db0b88eab3aca571f1c16690a58bab38068183a016557bcffec76952f9bec68b0b28548e284bb5d2b35e68a2124dab08a226aae205f87be4ead8e5f657f16df6fc0ddd9ef6027db26b48535311a2713673b9a9f3dd6c6ce4ae5ce6ffdae8656291b10d6dabde46e53afad220d25d86cd107cd4fad39f1797de2febe91d42cb3688eb3f9ba5855ba1a00d700f1514b00ece57d31c59b55e699a47cea0cf2b56ea49970b92ce8db1c075a60783121ffacfab3228f8b4e18fae31f66162bffb305f37544963c63d16434732ea605df4a119111c46abc8592f2163f47eab255ce1c722c573a80e494fa13abcb6e65bbafe0817e184ad3f2c4db59c80dd2ac0a6599979f6c4e0c1b639d528d90bb3c98e67ecc6783dd9bae92430ecc300cfcac7ab8a32d8a4d90f2e50def474b14c0352cbc117b3e4c793509ed849f01f8d6d400709698dadc4e9e79611d6d77781a22cc153945a3f103db9ff3f4e11227968d58d055ef15faf09d499e2d471d602478168eb35642f98c1693651ab15a55201b6d8b69200b5fa6e550326ae6d02bd825935cedb957ab26883d6c923a9b60cb887f40cfbf6b5aacf490168356fccf2c59e4e373956c02a0d48a69fa5c409f9bb9b26f54e5e3b9f0a287f4e9838c97d71c22421d7d5952a647eb0d656b9d6951b851734f1e97d739cd2dcf5d8cb9bc870f544a1b3cd782d44af713c863a9f7ed5fc2dffb483a1bec333399d63ad2227de8e034fe13bd77682127d0edb0876c2af55cfa9e49844d0ef0e594d23771a30ac0ad86af8e8541ca57c3f3a5da998eb0e73ed3d725738e42c56fba9e75d7da8b0ac593da4398fc0ef43a2d60f79ac6abb171ed9dc0fae9ee5ed356b5080d20094dc260d9db65fd1495330095cf3fe748275a707e2f456c6ad5c8611d883f346c20b8202aec067927c84b3571074921bd625573e7612390510d473ce894952e93db4b7e6c8eb2d8475402efe6d101f31cb32ff881925d0791915649d3757e9e4346f636a9ea675b82c3da880aae1d3ec8ebf34654df533566dc71f2ad364f24623acc801da65f597067203469de688971dec046905f6c934cb3a2617e9a0b0e676349ce32a8cd2456fe4ad265372583bcc349098a6be2d55d0c4a659063de9ef3b09997c0bb3afb3db932f46c73cfab23eef043bab2846cf6518af219054e22ded19c311d0e12d16357e8840360cd405b84c7672f4a6d414a61be90c4b9574ba1e54eab70786d6b5cc909764c61c99df72eadf522173ee41e7d84144002bfdafe0dda7e5921f3f1323bb39facc87291bbe5b8b429cb678b707127dcefbd205cf8c097910ad28b7b6fb08515860995f5e0051f24c57714bf597d729e3f8db1a5894f481bbad0a80a9ee90900c217f508c5594164beac14e4263491cf0a6fd705d974a0c21695bf6f907f712de2c8340a2521131515d5fc4b11ab7423c4bcfc53a151c361ca791bd6fee028398288346c52d60bccd031ccf40dba6c7d27960b8b7bfeda982062d6225146ef8b240942cb668e7bf45948b5ab5e99e3fcbf25c9ee75ef06ba31698057d44acbf9660e1535dd55ad8dd745e915a6fea876af8575ad309d894a49ddef5f8cd28bec44d336d889af327f7e00e454ad900eea7eb0da3f08b893e36adc29a368e34d9c1e4df4ffc56b7c393660a355ff5cabd6f12d5dd7313cd87861bb318fa4095adec3ddee351dec3a742b61f271c8daa0c38f92cddca1305f13ccf4724fefbbef09a57a81c9c37e9517700df9f19b6944d228e8a1a1bac018c1e8d2fbc25e824911fad87423a9796eee32aeb94e89fd86babead3d9bd726af61b002c90eee504af056680347a7afdbb11a2b90d328ef139a1aca977dd1d75f810b2571f4015fc5be067e5ff16690111b5afbd599978a2b3b8dc612d96e3961d287c6e06e83d81c2ee5a676aabda558f3edc06b2a7d7cdf161afc53420e0231fe7dc627037835382439e3a852047c7a62b949e83ead2136449679fe0555e968c5203790ae6074d028749eb0fe95912647bfdb52ffdcf94d8c7f5479d1b2e21059c02fc8b6c2ec54e6ad7ebc782eb6022b7373a5f3e884d90759cb118902213d1d699671af164d7b1318b8de608a27aa70fd6f98229ad58612f1011f8c9c6080daabfe4984807f9f1d7dc8c97ec591c8dd3905c3fe14682942f82dcde33c7347f00c83d433a4d606627a063c64beb039ff0dcd504cd0e50cc5d16f7055701a57966f5196049b1a2cf3d016787d300f8e2783d545859287e885e5ce2d271996fa871b2275d4db1c161fc82fb90909ae350df17593c6c4dae4a4294b8c74549def8cf05cbf9e1b62d93183ad2034c6c5e64fdc393fb8ed9db9d9b452497b51e4ac0a678f753f45a19faf7a151c4e0789a9f4927061d886c151e278902ce247b0f824fcdbdc9126371b1d11dbc27047ea6cd223d78b4a982504b9022035ff3bb458f0e234ea47c7ff6cc5e6312282a353ff3fded55cb946f8b0f0334590c0bd89b5ce50ff44c749f3244bd387212a4c01e417e7d53b70ceb3be0dc147ca312fae44f39b6f4b88661de4edba529dc36495e946b659872605a2d25352fdd0e89f30c90ba636367ea9516d6eab251c36a07c9fc846c955dcf2714e1c0e478ab9927cfd753386c8b4cb33c1ad48087d5f1e3280bb59a664b953f4665af6c6e4a2b8c35bbc188f43a0a793f51da9dd264fb98832ce5d684f889295cd3d20d7f66eaa3b58b78f035f536d4cbf68bf453b880eba5787ce70481be90781f7f616bea56200b2c8df5ff68472790d3961d440abbc0dc98e331016997533172196ad354913ffddca49eddd92297a7766aaeabc52be984b557feb7340414bcd16fee33bab0e8020058d60912fc32f21755c000e591385d52d568df0dfea543438ea2773352590d51e196635747ba58718c23305bac7e76e5dc953a013d6211f8f7435561a0aa18cc195a25e491869197ae32a007ad3476d60d602751cc98a3164c939f2eb66cb3a3d32f46c3c8d1056d073c414545ae23fd642e567c5f2de32959deaf374b250515a9745bbe0ddc2bff3b5420ef9bade1f2cfc2a1373440d73c6cfc706f179deb0b07445c5c999217c329df79a6210e22c878634ed9138ff611ec86f7f424a74cf9a89cd0f9db6e8fc7a781e7e992c8033a859b2b5cf4180de6efac4e8cac06aa82543be262df3ce3e0b3f32dbb32e4d5c9c4611905e92679eff0735bc7fe4de3f9343adf2b32faa1e0352de1cf93624dc568a1dc9466f3114be72e3c500e2350816c8f5e025b2c40499500c4e1f176f95c40688da765e6843377277b88def5234f05b52bc702382da1c41aa796db414e9e85b29208dfe94722a408bff19407d3f8d3fcce3c974c9196fd37c72d293570ee6fc1d606751174bd0d9ee633fbba6a696304a49edcba53a2d83cc29fd341d19e4c5c8ebfb6b7db4efa42324e324365afdfc3f61abb082fdf52541d76aabb74bf8938b6e73052ef38ccc44ec69b1751259efa8c0ac3d86238ce19e2e248a5d08c714ee3443488a4a5147313c98227d61aafbc2112a401dd26cbf0828fcf3e6201283696af6056857083cd9885f2da59c290bc3bad9582d5d2875485cda04e2f20b8696c516a534bd700a1e0c58ab37d9a2526e51f877bef54a405d8dadc34a5428fc4f4b5d285832d9ff542e289d86ac3c41497a932c19487b376bc4ce54c3980efae0ce987875dacff371e0bef55ab1ac064b76693057ed4a5eb7291f686440b58bf0b5d8fddf1181937c9bb73c5a86aad89bc052edbb0cf58f45e0b196da4f7af3a27af247fdbf8c509b9f60630e544126ffc8a3db5db577eff78003cc4278818308ccaefb07a39bfe6ec9389b2ccef8720a4cd9ffa0a4f073ff8ffa4816d83a70fda8fe0421172a5f97bfa36ef48df6781cdaedfd9f97f36d48dfecc6485b747cb83ca0c27e8d9fc624af231b835e978625a6fc32b37bd7c03303902526907be594c3b6c59bc84d279aba686a51bd268f1eecd31a981de420b4dbf217ac3215de4d692f1a7870ed04e2dcc35abbf5ef90558f92f22bcc96b676a3fde3960a53d884b687b6e7616f0aea2a8561671fb022854497529edd76e52e12e534febe5813e2d306c6f7ad31b679034fd4339b505f42fd804f02d99f939b218b1d02fd794dd2b4c37a55efad01096374538cf8852170b359d57fd0316f75f9b0a9c7a2cb951daed0f8bf7117a426606cabb45d1bed54ef61e3fa149ca43954ef5e668c8919a180c07abf64a7249f207b4bcedeb88076d047a5a103798a8e338126cf4c701f5083ec6c4309652b219e0ead5fc75ca8a202edf6a8b5b7eea8de54289ec6af8b9cf4746b0af10a6512bced7dd4390ee93e1fdbcf5dc6df82ba8146e205e680892b519ab72bd79ae982386176664783b7887934b6019819969c5e0bb29af7ebb973cc79ad9ec2387dac1f6888d76226b3419a83ce915e4c6d4bb3fd4158932e92ad233b84e82a56eec58710984053b59a6467efd21ebb33af2a19a17986948d9a4e82d797e3f85f89e4fa0d95ec3c89fb4058ae799548ca8e47552760495fc53a6e281e907e7e14e8a4499d2a01de5bea773966904c2dd3893c311319f48b9c528f988090ad9e62f24bf339b848bf3b490952a9ad8be997caad04d368400094b56f017d716db9269a165720a43bb3ee847f584e28b012aed3bc8bbf9d848b9c781a681b1517361486c51268b2084cf34ab5ca83c54e5e325d402238a8b33fad559615819a92159b069e91e5ae8ab26544233f475f0e83dfa7de07f9115b9a0a4c0b540546ac3aa6bae9314b5c5bd7c3f8818b4261d56e88d0899b3b4ce615115aec6fb533145afcf33d9377d17dcf6b856d0153dabeeff7207b70c95c024c020140f81750b5b8e34a13b2a0e143538b767e5f47415b22c27b3390be74a9d74d5a06e887b4b12f063f783fc1220a6b04a70dda0d685eb3fa56e106a69840b6fec82c705efe0399be815f3caa5562192c08e34b98705cff88c918defd3fec4699a18e37c181acaac5ce0bd30d8b32a0a8438580a4c6b714428c851127b8ccd9207df9203fd37ee582eacb4237abb0d2f331507bcc995c766cdf1786fb627b0df65673ee805cbb2f72a4d7adc11722b497fccd58d109af4e583bbf447b9f2c459702778d35d500416619bca7b51005e31b88d1b9719e00e9ec39a930676d4dc0523d66200e664022e7bc15c6fc97f8f35da5f39dc6ba131d32388379721263e817f245bf4ad355c4981d3f7ccb441e5334b0a9057a9b07143ffd1b9b5f3a1c3111e8c77e9f9f3aa9c776e8f17895aeab5ee2ec0093666013feb747924b5b87cdb3a5d4e4499ac42b637836309782746cb41829494c0345231f7e7ca8621a324d2aceb9a857bf60efaeb0078742443d7d959716f9a3391ace85344c37ffde634b9e27ebedb9ab2f64cd5db825c25aa1bbd59d34826d14e1ba4de5e643e26e7419fc23f8011602982291ec434344b73e8db6f605f9d28925b766149808817f02f0590d3a3772a2326582d690938099aec4ec74763f88e83d26ca98419dafb34ef34405489025dea98f398ecd3db9830ece88804a9f25e232a1a7198c81de4c7ed4a7ce4d6a231e8d1b70acbe110f8ccce7f945cfe771a68c38762d5d81c13bb408bdf63da171bd57502be5c3dbc6d9c6db6d24704ef17ebfb7ce39d6967f5fcd7bf1da1096b7c5afd8647a09be853437e22273d40bd5a1d3f2c287a3d68dc5b2e61107e8c10c58c9ce137b6f4984a6ddf525ef30933254a6648394b5edfef5f214aa5ff9d34723a45fec30551b0c6b614221f858697dab478e8e9c220472bc5306d0e26a2db7997069b657d67bd5d788b3093e0cc6bd4f561c3883f36a524fac35174b9cfc9a5d20a671193a56ad8cb1b5fa8d24a4d9fced8b228950c7e09ec30d5ccbd5536f559659b6c002b1656889b2283d0ea3382e6e6cd11927d78835c34a8dcdc2d39ff8f12ab61f998bda01f0738f769f989304dc6ff7dbefa091a460f12bc17e3ce6df6abc20cab451ca479495fdd068a39d19e02b00845caaac798b4b785bea2b0d2665b29a2fd116a025459ab6ddf8a262d0481f2ed6ccd56950d811546fd00a12f228500c20ed7f08b556cef0e0cd47da56028126e855008ed05167bf5f07a89e241f65d461b6fae670d1bd95baa78c915e2dc7f0f7bb3c23c7945e8dc44aacc99672764c0c378d96da3b94d8d57d7e195ba8e8c625490762ab70a4da665340c2f6b1bd8255e92eb3768e77ab9720e54290f5a5532595f335a9aa297c1ce61d4ff643aaf5d319aacda0273dac037c828a7191b54b560dc71cd154c10e8f96a76e0717617729a62c1fce4ff7b2527f308f7924c8e7fd1119bd6e65427f97399a97057aada25151200cd66d9ca12a9e234f75b9bf7aa30e35df34161898e76c1fec29db2a52aa97c9e0ca2ef12b7b1bfc8103abb70c3ff73541f64220bbae9bc901bdf3f17614e55d7e78d8bed451e5bd6413b5102296ab3cf51cdbaeb1df999072ff673715008e4a521f1cd09cd51ae93c5ac2638cd6ca1bf4679032d5cc0c2a0739983482413eb3dc6b1bf9277db081dd6a5ed9be9441f35e9e19570a024097dd853fa46be63daa08d365603491db5d63f50fc1f825e1d42448a9d379f7940e113ea02b740cfab3f0a311af646eb97d25d22c0d6b6756ec1bd5e97a64e142c59a60544d7b0e03e8b0b9d8e66262582983ca99100c642447000623b629f04fce78dad5b39b51024c8c83c58b983c9baf5901f2d4ed0989c1818367914b66d63cf379c72e1c9125f7df71adea32a0e9823261e67b45c69c51d9903913bb783221c5f1c24b38d5439ba49cd3e7e83ccce1ac8bcfa848ffadaa71d7ef4a5af8ead14b3213d43ed2f4dc2188ba3cba629b55d02f34de77a7b2627ae690640d498fa2a20f57501588d7fc61c032f4329c732dd3b85a6553f2cad69b77c6616b37238f89bf2af6161f6393c386a3eccff6771e87692af3eb69e33c2b0ea37739d50418fc4893480ba469de00ed5149825b75241fbb6d8591e07e8282d207f0058b29fe13a45855212000096dd38023c340ea13c534634ad55495e3691875bd1d742523f5aad9caf25bce4180d86d88cc41e87b6cde64354bcb18e92a257a4b365c50437b43175bfe2e885b0fc5a7f5fede220577d27fcb028542d96e73e413b564e8970341fe41323e1bca2df33177aac4d56ee39377276f2ab91610ca1a921630f2bcd384e69e46b48541c311f0afea0b1bc294da8b511d2ab72f6e08a63f631d730861c022709df69c942db246eb5e08311585736e656a4c978833de6de483d5e1f683a262fb2cc62eca74a8b1fca9e2e0cd6220c627c77fff0707a7acecbeba9abf2a416b8ccba82ded1e474a58a646c9421f3b98ee5fd5648cbf850beda6d02399d558cd5528112848c65e42a731c0e95e9f5144c8023320b0d03704bf85d412de833b0fdc1bdf20950c44911094631dbf03bbc23864718a0eb81062e3249395f340910fa58fb0a4dc721a0c4a4af31c90c124ffbf7f0896f687a4474e17c470e769f505c6439f2c0a2188ae63a32c47ff22ee114c7d79dbcb54ffbc56e307443f58328304f3a905de7b199a4add5120d86dbf26e426edc3be4f4c2d42a27f6e5ff0488ba4e725f38a5ac5fa1a2343c4ab318a903f06b8d7d87b30c57c3987fa6e9c7d6c479b91f6899d987018a76e9a3060d2fd49ff3aca4d73895956e3c984a2a9f280a4070cb1ec7e52836be02978e129d24134d9ad6ff4d87b9bfd8f09077c83fd5100144cf0b81e6b2f9105a91ff61e0e4cabf212f53727a8243a2d0f4de30f3f9b5fb796e1c72eb1c1ac7b69879dad70df022349694bdb811d802c29471c59db68f93e078b7537b172cc23b12a76062e4ed001f838a0f74fd4b1ea9e1f6911500356a55e2e92f63ee30540116f3f4bbf1e256bb78595ce0edd681eb5e987a95265ebdf26e1ba4213ac2f704095f9d765392538864f074d0aafc36b44c8faa6716d52ddc98d3266921e7fcc7539355fa92133e205ad7426a2137cb22804e94e8dd168674a28386fe0ccd648f3e88991eeb97b3bed58280bde397c6d62cdc2923a35c1c0d465b3e62bde20f6284ac73a99ab400c16818107c69f131d435f247667da8bbe15c36dbdd84aaecdbbdd0b78adb84296b02ce64eb391dca21c880b52c9398c85a4894b6b3ec1a3d2dc248d10d9fffd5b6124aace32a35b02c06d3ec18cd55edfea9e274eade813f65ae4b5278667d42c50a86957004ae8dc2a3dfce3f37687ac32744a4b10984e415a83a46627a470a4f35bcd72c396646c6e35e8baedc1b4b258032815bc3c98dffac9f3f6d69b387cfcf4cc3565abbfc3df665113b6153ada732980bd03dc0ef2c1057d3b78aef464a8a99fd80a324e08f13c4d5c7070786889b599f2d3aa9011ccdd859e15ff876e920943099301b8768a3a48e6abbc5377f79e9bf7b1589111256677c4e9954ffab8808a2541defe7ea67dbc5062f61563ebb7187707fde88a4aec7d328039471f9a119ef29352244dced5cbfb3e13749f4f1b4d4606b52861a8a538806821ce355ac24c89d4b30afa63354d95d5542fa15d07eee506a16d785ccb47cea5291a2b981c1a9444b459668b73abc6dc817500004609facb7a9a1373370cafcdba105e742e8aa93b90accd014f21d8d1949c9d2679c2fdd40e7b53328e03b05ba62638f11093f797381af1aaa323bd6848089110c27df2de5019b5afcc91e385a5e5c9554f0a0349291230717348bf6cb110b082f91b6e22276259a346e150271ac797242b728ac9356a4812ee25e1bdd7637d78119a35ca696270a513df784d3d42ff3b6be305c3e5a27ab8ea15f4f4bfcbf7ac90451af880555cecce7b54842803de31d5d99d4598664ab641de1012e0188990b6d0f004bd1ba4c0a099bccf5d4ffa68d43cb72576908222cad44a2ab8caf4bbacd44ccb7905cb5f7838bf8bb7608b6d1052c5ff6406992b47fbb7b1e8ada2ff661ee39c334f2d165cc4a41096385bb3d9c0608b122118ffc06050147e15669561010e267b64bf67dab0dab7bd1e0a26187bf682e56e63441d760821b2fcae9dbb57a85d32918a3a60430043444d63f3d26b7b6d0e6287ddda393dd916b9393772d4665db38ef6f46439695d745f3eca5f89b47b0acfde8ea5bba0280a034b5284b5de35e294efe78d48d577a034867ead0d447ab410c704444b80dbf725f6f4227e5edabf968e49686755e1b3fcc5dc6ef65d86ef0b33cd945e228b5f1c179e3540122195f793fed97070b6bafba8b8e63b71df2c560a9d30de2fac51efcc00824c793efdab430a94914b49f5896ff79c0a001ee258173f18c03a6e9ee04b8c882366489e849d7d9f127fa50cf64ba79eef016978674427c3673ca89eda258d728d9c2ab2edccba3bc77587b1dbe643204f25af40c322b0d13ef0d8385bd5ae5b207f2bf10df46cde7a69ddbf46562f178870bdfa9e02331cf0c6f59f43de56b99c1fe2a63d5a4d5f3759650bfba78274732487ac70c5bdd18f2ca12703f5cf0982518549572ec99ed79b7cbccb390e3b9673fed33dfedc4ac987d27ee8d8b9f582c54339996ad19cecf217fbc14e04b49b66644156a47d9fca7525a614f387ed038cccea5d7203926cf797a5610689c8814998d3bb163edd69c8498121531054d41c1c6c0eb57d236d2725b79ebbe1eca7ba748e5d3e9904cfcf333f71b42c0c9332f068604966c8335d37aab12d765a78bba951ad08f508faaf51dbe5e4ba6bfdd39aaf3c9b1a2a18356cf66098ebddb92d834ede0fd3311c85210d3ede68b0fe74e163b18f434b54db71e7fa074ad86abf0ab958afa265fca7fd90e34a5954d0aa3f5fe49fe8320b8b34063921a3c8eb35ee2aace2638327b0bc7ab4c97da1dfb14f1cf49ea2caf4894fec6d099a14745913ab715c35264fd89edef6cba75969b90dce3fa788fcf4b0ac348fc4e762db0e4f637c293aebd9a4ae87f397fec5eb122fa4b2904e4397fcf4597841b75c30fa86d42fdd02ea11c94fe89cd50c258fc0f6d12277d37e0a2353289c21e767c1921b39da29a46da122fc73670b41b577629b866a1c915c0d6aab4adbbf4a7686f6a402ce3abec4d5b8a678cb31fabefd288670c351e5604bbf71b6a71ed0a670be9bd407d3cbbdc52c09a649c7358b202db1ef407455cd9ff946ae2b2be2d629709afbe838aa19883c9be9185e506a75da69cd1ffb0445e2d7c51e777c3d3e839b6f7cfd5d3336be933825eef257bd7424c8cab33ff84b57f1634334f0ea1d06d1c7568e1407adcd651b81a0aba972af45eac0059d33c28ddcc5a7a4065b77a83ac018e9ff0dff1416236a45837c422d651ffd481083db9c7b244bceae98595a8e2dd21847e9616ad5f3f94c7671b3a3ad80ad5b041b660ffaa4e14b764f9e64fb9d78c44dd5c1c3212890ab3e331c9eac8b5e3289702d279de81371bfbf2f48b211714d30bceea5962ee4eba793ed918d80c17827a81a348375e2fa6993f4001989dd1b338e6a78e657a717d95f4642ea27e94482d6d36ea30a92ef71a668369772f28e72ae74350379720af2df5e5bc97bbc5d3203448dc14edc6ce76e88b50f46df7f0fd48185c72af66dacbe3ff458a3735720e379ab030cd3dc9b25bb71bf5dfd63806a4a63c79f079a03bb35769c4864408652e7f7c41e70e10c56a8f2b0165d125011abcbdeab077a3cc623a10dc853832826d08713522f3cfdfdf9f33acf4f62ff44bf5e26f946851be5b2435b874312577b74850b1fb55fd12b60ae8a018d232e82836515f0f6279ab33477251340a0eaf6a01ee2482b55331858b7da6d7d2ceeac829b7a28690a30f522fc7b4e0a90f97d3748e7bad7b1af59195804ce32ea790b24187ebfa975a481a3ecc537e2a8f351aafe0fd5733981876545b4ede73b98252cc624f76690de2ae44d4f915ca6c42d2c798f98f3b9ca5909c54a93078bff4387be284cfd6a56ace02087cc4ebfd1f98986ca33c6e24bca171600679c1602fce9b84e03c2b63f89c3e0d386a0df2767317bb55d9132c0019efacbaa6301a4e12699bb7e431950ab4da75f48b1e350f0d97078e05921bc13d97d2c03a2da37f6bbf01a6e66c2a4e1c2655247fb71d3480e59ab14c58d88e253ffd45a94dd7c9f41824b5d2c7d452e2d991f3ea04a268d62bc5c7a6396b494f2e1a5daf2ee511e70e3015ed9ea9b7148a56010c397029bdbc3efd6fc06eace90b6c60d1d65fc760de601a559d26532b271f870f760cbca746f4d81cd543c43f044f747bee5c633c41bff301e82f677144fd4aaa5b27bb9d76b2929a081d9fbcaa07d95edcfd55dcbb5058a9ab908f73989dcc75e46e79458d647b32f567d62a879abba72024fb352fd9ccec3f25defb7ce7a3758618f979297a723af8c4ef9d4bf4d09e05702e3f4089d8df50aa545de251384cb93d378b08f87b69d0a89f0b240f8898cc1020836d37fab81d5c295e45e25b2ebdbd43af0d53dfd443291a29a8612793b34fc64b63e21f9bb01a6b01065736628a89ceb47205dca99d0cc64f29f3e58a31f17030cdf2994d8fb240fe9531340642e098c61d87ec59820ef72d2ba421d2927caf973254fe723871edf216654d45f63e83c3d28688c8afd13933e504e5ffe9bc65c83ea0310af115e73e0ac345a92eed1371546fd5a8c495b35ae773408e47fc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
