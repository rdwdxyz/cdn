<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a6144de65ae16d22bf32f3c6dd5ee646b9788bf505587604093908505a342b6ada0d4d19b346ed5dfae739a02d319996792ee7c917bae9b4fce6d5a99cba6544f134cda155dbd01be6c4cb588011f89adcd3a3a000daed4bc0807de0834bc0cda2942e85a6b4e770655db95c297ddb1d9db3ee165c0662f0359cd62bcb9dda0f3f83d8ac0bbdaae11304afd9716fcb148909e2ef92067316e6ddaf4bc288a6816468cb8e5e3cdee3316893c56cb7e7c4c43c3e9b76965f615d21e02d88c51baaf52d7fd9a305a98287d9edaf4e0fc10513400eaa27b735d15b70a5976551380f7ff2d1946c411809bdc29dab6f32f606224d0d9b7b20748e61a51f28b9bdc66f88efb0c1ed03295b637b6b2fa6e000ac3ecba1c5db3f2903154013beb5c963eb1f597f227a1453ea9423bb1ae2dd37773d10e975d161cd1fbb9817f0e56f1176eabfd56d77d702d0832b7263026b641cf85b08f24932ce2a88c68378247a3028480e43d22691f67a1ed1ba123d7625983bf206b3ef3bc553f658221538ebfcf80628197fe850c320afa8b9b9aac5b4233128e86ec658468e90dbd9c216d675c2b3bedde9045521c955743c658951bac0d35cdb07d4f36966e8f34d6bd68b353ddea841ad0cfa0a66b38bc55a6572e49f93346616b8af9abcb53739710d25f4ddc11083ebae77a2c8f324a657049d8be97d9b5b817b764317341d6996da4092b5d5f2bcd433ecfb0b82fe1c3cb8a7f214dd12d8b55bac3c04681699af597d1b56217eb5ed03c55441d6bf83dcd2f3d055397a9238e2e781d0d2258a1b77f51a43d7355d2f47c47ab5843107d7709b33fb3af14bfd856cf2666755a37b4e0f35ae9ef59cffd0b4779e521a80fb803ef4df00ed27d0f3923ffbae1708114a883ff3cbe84278def17fffb53103ce7d23900f1e0fcc55005f58f07a01c2ba3781deb5d04b4eb246b50be4cd9a1b9e6c1b9de4ce2fbf8d6e745811a41afe9126b9ec8bfe4546d3a6695102a58a3883fd29a38e298a1195742cf0c462bc70a4d4f197594ed340ae3965736d437470d5b33f684aece40e11e23caa0178e9c8b755aee45124f76753c99309c7950a804dd1014174e055ef5560e95a5ec494ca33ec3b636065b2ec15c0e575ee1b1c967b4c65a50debfc37525f81bffcf220c00bae9dbcc55c61ff5cee45685dd8c8936930b450c46b85e4331b8d2d777ab6fe13ed9722909acacfa0f21d57b60d1521df55c78e57439bd11265e87c6ad2d317e7d95aab26f1df3aa1856ddf6208d19ed6d277d4fc1b541376db152bb086d85facbf6dc5d05876cfb47e654c436903ce769977a28c350414792ddab98efc28eeb8ffa24112d5ebb51aa17a42d907f1598a40eea675f3377f9b3a840f4842dab2847cce08d49042a7a7caa17193920e5e1ad5841ff3bc46918f51cc389ab11791e4a274f3b701af0d31068e8605e0963ef9d5128d91f674845fcacc1d67b972bb68e93679acd706cbe1cc865e1c1bf3341c3bb096b7c8964e621265156117cbf60576b5fde1bc485b6595217082ad011acb1017401e0a72cb152680f5373c8e2066e8e4be76a5bb53a3a0d9c072b5b915a2dd0f5ecc7bf585a61dc4077b1f5c461535f1075526b4b67a6e5720653ebaf64f9bcc8e296ebffda733bb4bcac3b4d8c785755e729ed4fedceeca405e47df9832bfe6cae389a3f33011b4755e9fb15a415e255c4a9c8b91335aacf2d5165f87ff43fe22419c1e41cd319f07c4bf4e4b7f377a0586b7e1fa7dc89ac47e99cc6386b03271d6e195ac521278583250fc9bf190f4c01829d85d0e69c42313b965611200ad12e2300d5f6a3f8d3d4b45ae903e06157b7b4d94e84ed2ad35024010b7f57eb9bc0bc7ff262b39fd84edf4ed56a168fb81a29fd3f71143852696cbc93a33008a2dabe53da4eae708e48031d4025cfbc4bcdd4fe9450ed0b6e262f88ae1e11a906352784e9953ae73ada8e65332a883d527aeae8f2d29d6d0208e27dc8225be9c60d9c3b91a223cfbd59adf7df097e1f5da0603f3796c142350ada1396139bf93dfa05fc844b9239689c3a3b8e6ea2ecd190f4ab657ed2739b76db10abfc9f186d9c4a67c931d9c4f4a8bee5e2ea7038c61c4aa591bef19cc693fce9491ba2cc0ef8e2c4809cd6c335272cab60311220154bbd15407671686f4a1b6f528501116b68f72235736bd9c0a790d08e943823cb87e53c886caa8bb53ae0f3d492faee3aadc40c8e57e1c723e266cad2cb8c0f460bf3f135f17f0f217e6287ccc3f392d2925d5d45b315248708f172b8033e7ff7146112e1af5653fd6d46395576180cebd1a740e7e8dd1491ff36cd10660dd5d691af5269dd03623f020f40bfc9423446ea5726394c4b08f9e09fd86c17c854afbf91b223c3b600c459048a9598310e9ba10f9adf597a54861d7bbc8b3c95abf019e625176decc0ade949131fd43bc24f4c76218d85fd4e45ebc3495978de855e40f9d4b6a39b2cfd9e67af296c9b067f0ab96eff53fcf897e050a8cf57efe08040645d67fc7c683ab5b80a714b32ec7c61ba66654fb8a850d80b71e709de9425a65e5b1e54b0cbd054313be558cd55fa486df5a81e12e4ccd7ba71ed8a92138d221dbd62a5493f79c63452913424f247815b1583f3e6eb3cb95c1901f2216931a26bc5674195a9ee4be9901989aaeae1d2dc1d7ccead588e9c203faa0cffb8c2867021b7efb98e3da99876543dd6f8927290a6aa1224b66aabfa0918dc7020fddfb4c6c0cb79c9edd5ca0497c3e01e972781e95e207da0b57a7125199325baf0b7223e5b9b4a3752814c67ec4171237b9ca159ba9e913b7ded3e7a61ef8a51f45599f1ec68626e18e92272c24e8391c00b4caf70ee00ca0f3e0c3c9a63394b9d393e0047b9c36f7a46ab44df31dae76eabfc3936520bd12b9fb88ee71463b9848f6b48e67c1bcbeb8ff1489d4d434c8c8aa9ab5430ae494c67dfc88aabc7e624532e3b86103482c2a082e624c96d546989f369f0d6ee84881bbe3583f447a8d72a8cacbccf0aa1a27a04063d31b03eae361d22bcdc7cdfbbc462479e0fa934efca33002f4afebc4e868f063e35cbf9a7785c80a7ddf9729021bee1ec53e1dbed1deeaa1507fdfbcd4a82538db1b8e55202b0916af46b939cc46856a2dabea4ce752254c0ad5addd0728cf9fffd7ca0bc34dbc6ae9da967044c476ed07b7bcda2164529c31feeca12463fdc1cbec78397e9c5a6537f2e8c36667f97e43e115271bd0bc9905d99d8bec7b8c079652f6b03b5d5e52c79f44dfa7af07181601da96dafc055008718f8d85e465ddce68fc1823b388c35352b51e8ff539e44e11125549bbfb95949d3c8494c11d6f34d799f7e7444db04444710ad4f1f71aeeca402b152eb7a89af5f286f3f81cab63646524548fbbc879b6eade17193c75100fd18624a2cbeb01862ea6ae1a2b13d043fc7f35a368cd414fbe391453c19bbc8170fbbb22b5886860ced9d75df855fc62fc3e1d20a3137085fa957a22bda7fc98b0d21d181f091dbc2585647cca9e30675e0bab059d21bcf3480c5485dc75d75f398ca5a8853bffb659a490a6125d3610fa7d20b0c40972d8bf1fae265813bd9a7976ec546bbf7e6cc034eca4a5ecf294f4753a275137102046e7030c64914dff168e23528dd0fe989894225b30fc94f5d3c86ec9cb2c319b1bee4d633959e88c28a67ff8451e4a19f58b684008748425d6f6da00ea98a52cb2a3eba7a5b32ada5775618695bcbee8088b59aa625510d9ca9e5a22d05502995cae372df68bf8e8964701b8d7331d486080989161cab577d79c8cdfc448a09caf187273bf2451833fbdced4cd86ffd343d3a801d5d8a566c6abba68c6bbbe61823788ce132ee87e91072742ecf643852d07e4b3309d6b8d7b63a835e379a8ea4be5000aa61f8485d41873dd43080c23954213b74cf70978dd6d4e0d3301b4d47bd8bc6efe1ea5f64da25bdf88da8edc35a8cf161e0ddc25423daef931c9d44f45c415273eb3b05a30ac09608a8aedc5153823e93152137c010fb2aab7112a99c88999e1aabf43e8f65116628ac6fe7863e192d6ee801d5b8e74b119ff99285d570ec8849b270b9b4eb20d983deec4737a8ac465c7a7fea081c23960e079c3b3bdfff91afbd4bda6690cf483569814c6f4a1f4d969aab887f2a002827d31a31beab293f56b3c738969fee730dd0223b2c6e8ae17e26c94fced40f885cbb87d2676a7c4759c071cb1a42f3ef233008b3db1ad1c3ec30e2bdd35a9fccdfc94d8064dbf976eaa3abe8832ab6774bda2b6d4cf8d89385b999789be311bcbbd95184323e1ed6e6f6bcd942fddbaf82b0dbe9e1613af8def4cbcc83bafea0a211ef55af55f14e6636ca909e24330007887a1f229d5c3dc3d3eb8fbcdafe6ada0d842650faa340b854e16a8bf6742bf688919a5d3cc4020a9a2e073c93a983e117a9ee8fc6ec02837ff4365924a61332dfd3e1b65c556d32c4c612b0bae3f5a310e838ea0bf50b1e354de3787a326c235322ee7beb469aa7600bd1789e698d54d7710a7aabcf5acb620679a20b849e31e23f8fcc2c8624d1d407b00cc010b204fceab02ce1c677de0d5c19a5d896cedc7c1b0446fa0e5fccea6a1ef53e83cd68b2e196c28597253b74ab2c6ed0bbe38bb2337663370ab60179bdce321cfab1db0119332810f62f00fcc57834ab14860a68b0d39c87a2052fc0347fe81775501d0a9e46b5906289499117b9896982ee5dc33c03a240129706749168cc0ef635ca166d1e7a60b3369c47599b211a15b3800b7fa2a85d45798652d91071ecfadc78003356c1ad1e7f4cd47e35e2180ff3ef494fe7f84677c2c6a74f25e7ef624a53c6316f302986ad6a10ba3fa2ef5d0f6f67234a149eec3e3d8f445116d79894531cb9c614b9bf222a5273db00cb8a1eee851db29b7637102b1920a7da4b72a855cfa83732b061395e1c4c930ae0eab333333d36d7347e0fe2094525ef29dcb827746ec8c262815eaa4ff008cf0e2116f6d73cc0c71b603747fd0c78522729d06194e78265c66cc291d1f913646e7ac4484d01b1647df2987262111417be36e436be5a53d1fb108d2ccebef0e1a93c19a84c5aacc698a413ab4643b0c8a64f797f7dcc2b6359ea1fe0fdf7e590869a7fae76cae2ef4353a18b9cc7140bc420b004e4d13376511d9f80c74ed7a3fb5dc9253147984ca889c9d383ef0e9ffefbcd923ac3d3454524d4237fb041acb4e5a040bcf4bc756e62710ac67cb1a803d53c18ef1ffe586c67c28c7d5fa6b77df876b3e444b4229029610a900fb6a7afbce9b6e5bdc9485036a2b37801ad51aadcb66ae45cb7a4f14e13ec087e0f6a15a22ea4b8bc4188850933f7a9764b772dae39015a19faced54be44985afedefc5a212900993b5133d0ca3c239f40a81b81077e102d8e62b167ea5e5095be444f4f239e2a7d8c3cd6a2080032a9b0aa78d9db20968abbb9734c543e5a61a98b165303b9395256bde0aad9b950adcbcff0c8cbd9308692f5bfb3536b999e66f12a594b62bef70fe9729c0f2a7405872cfd4f85bf205c3d7c713aa4c49d6cd7b914281f071bd664865af3c965b07bc042568b6b643cc3f592ded9102feb570cfd14346ff73d486840a432544d20378bad4675bea2194030fc2c500c28c84916145c9dad9407d8d90cf752fd925b4f89ce4709404d4307602e5a8fdc9f63fc3451b1e2ce7e0f1dcc4e78dca6090b1f0a7ac6c86fef81def368b8b981d55a528bb6174ac2ef2b180e51e05b8b28bef4c135c3cf48a3d57309e2decfe77d7870e01ae1172302e4f14224fe0744058acde611aac4988959428e0b9e7afcaad953a60d912404d6b1e514744155f3ca9ffdd99ae62977c6e96573052329df277f3175af41ef75546d6f78a06209e812ea412be885d94ab7a5f845e9b241be7b04ea20dd9e3c61a2ceb62efbe373fabd6d7018d1e772f6e59a5b78f243a6e1dbc64a30123a8efc60eb8ea7f7e963c0f4617cf659d83b9dd5f754fc05c8cbd82d55fbfc75f90307b528ce237cb7588ee8859d58d7ed91d8f7c0c404aa51f435cb02bddda67acb2e98061c669f979c4ecbbb02e793cc3687b2e8890e1effc621c5e8a5a021c848edca56a723296b8593b971364150e489ab6dfbcbab9b90beda3c5983c8f36765299fc0907c1769976c1b25c4080ffcf434302b81da2a70d804b946dfbdc6e4d97296d72d8eedd6ef8d82c2282562a45b75808773f28b35b3637df5f2a0e2fcea5679a0946c87fd89446cab332e2a7bf19aba2c5964543b2fad78b8f0e12efac06d2c67e5c61f7f2a3df398148141b63b769b10fcfc099baef6a805e8d3c3db79495a2eff6cbbb15e3afd6175a9afd7f252ae1c601906dde128f7c9f84b2640e1b029fe8d1b7e5816d265f8ec38e594c9ccd18d211994212dd6ee9ce49aaf71b5701e98f306935c054a161570a35cdf9fa533b8f8161383ab297374eece25f90cd8b9ee881cac1a42b34a2c2b6424aca07f65347d9223264353fbf6538d31783febb0ab3448001f9d3e6c0b21da7127ef624db1ab605130065d38a01e96cb000d891a169933b0da31d1c3d0ecea58aada1c0b3ec7499c5f3da7dc2e1def6bccb850713be53ba46a3465cda3c804c665ca1df4d319d1abc8004a9c9a62a726da81a04da90c0a68f81ce117223f8f5beb018562f1fcffda023dee40706722a20afd496946e77cd9354f1aed0ba4dc11bb79b7480f034eaf0d577e62cf9b31ac8bce47d7a621ea83092472e00ac71b9c4f431445c26ef784c0898ccee8fb41848eb844701eb2da76bba7f2fcf60aeeb72937e8e3ec7245a49d96cec07608fcb29b463546d5ae3eb990dc8460097a12f9a918ef838d45de1ab73587adc56d175b863feb8e73765560949531f53a67839b0e6a65d8324bc933afccc137a292a82a82a0e5d915b07a4a6b6015b9f39b473ac2a1b0f828b0b55bee4cd2da383e3bc1d957bc009ee9ca1bb957133f97343591493e12a497af45f6650a4acb62c3b590d8a43409b0956736d0893d4d6262df847fb4ed18e54743504ae1a2ccb7450dd410ff08648e5b0a6f1896705248a08a2317e356203f266ea323315b585ac9f560dc8d2e07e277c683782feb335ef23cc27c1dc655995aca5b9dcc1cc2ba53e86bf71dfdd8127e268adb2eba846ed36fe1b6629cbfa2173e87f79662c0104720e6d53fb41362495456cee6675cea931c3a1f4fe30e50ec437bb5f626384f4b0389cffe3e2543c2fbb9aa2aaa8b5b498851a0fa2202bd0edfd74d3afb5b436dc651b937088a755a27d9062e87a65dac466ba88eff6f4903da5d73fdbe699a0284ddce5b61a7fa61ed552e37e397afd56d7ab49875438b9a3323c5b3c9aa00d5f1ccb67f6babf6b5ee73f4be0388eb165f0fd76b024ab0c88d0402c8793379a11995acfc7774fc2c93331267ccbbbf91f3f09ddb3898c34eee4f1721a84a327bafe426841f225491b886d1405b862cfb223bf11ce3c290ec178468d66a14e566374b58bd88aa2923658c181c38da4301b41c29084cde63e161c6543e17a9d89a6a51b74ef9c553d97b9aab8c8a90b64da066f2b4848d73f2ec2f4ba66676fb568f08272e722e965f69d4f801efd60563f5a5561b499a8b05c4dc2e0059c7cdd4099e59393f0fa00c4dd3643d48cff5f44ec9f4c45cbf2dc5e7101d9a6f9dcc53b33e66dbc5d65397d55054c675a30b560ae00b6aef1d998e1c5b002b0c9bef59425f048ce9f313a3461171bb2c1cf6d3e9e2030b739a460135a1b21a81197385dc3979571b4bc7a84d37553c64832f2790961df39f3ec00db69f65bea2b6e438f518e9d201077a6d0642450311103cdb58b6805f31992efc88604ac6b4841faab107c22c5ab70253058a94397ec5bdb871e1ce9736d02e3f1f3f6991a09afae2419c67dbf2e38dc9d542c85515ac1531a4cf50cdf4ad2d6586d5c717568d3d5111e4113a71b870e63c0ae9b96bf5d1149144c7ce029e30a6be0d1c24f838ea93f9b06505736665d101f8611982d75cb9d8c606df4d605cefba9142e9c55a79e56443a6da7bd3e64d2f730f982ec724111e7c34b9a6780b07078c1c1307529eedbef3f25faa0d50a1057208701d075257879c1b1b9d25ae76da5b172fbf1304d934bb1ed847c76001f5334058381ac6ee9ce9802c3df211da74dbdb79b87572a0fa28e662383288bbc9dc2be2f211822e6d930a6efe710f99ef720537483d78f74150f3f531416c9e26dc7a6f8de258b6aef0cd18bbe04326eb5962ba3a85c458f73df47a6865fb1a6e5c334a7d700d85dd2668603270ee73b8e7710154dd03e28b45af48bb1da588a8c1f3375eb203d7940eca73e54958d18682aac6edd615fabfde5337093688ebaccf7963016d0c89cb2200b33f785c6fd365fd075e9c4cc81217c2e10800669426388074e71b219b19dfec3719d9c205903407dadd521232e47e36e4fdebe21f50ae78304b2dc7f292a1ef776e0e6d7e7ed2e027a838ba481fe406f9c696added50c591694c33c3f5d61c5c5c0650a375b9b3081265dc7e0eac84a7cc39faf521f4919e2d6f12701e798cc73b2facb80c621a43167ef4dadbca56fbc514c6ffa5c41727b278fef6d7164653efc858495f3f4d687060950abe3a4d9afe0731e117ddbac1fdc7958c2c3805a65969a712f71aa35fd3e0567774c7f2e7ab3d38839114a48bdb569ce96d61e1bed731f9a182501fa39b351ca9f3e1b35ab75e9387b5caebb434e1bc088422ad272babcf89d3fa60bf5369d9ac3240f06307a77eaad4d4ea1a67c345f1e33955c1bd8c6320d8ba8a287a70bce5eed09197002dd11610b0d8ff475c5b3bcc3100bd3e25eabd886b8b951eaaeb9842366e0a83fce2a0b6d809c43815beda119b05a46a90bb9e045e57057c37a2b854bdb1876b9d5fda1f81a7985b482d79f5b00475c2de4ec0827f54985391b8cd175ab23efb66f33eb99dd2c70d3ef1b1dfb4ce09a0ee2aa8f261579842341d49b0dde90d95226eeb4b6c77d490c96c2c869f9771335573202eceae3ea43e62eedb1a93792de0e397052e406b1b111915bd5cfcf4694397092ac0efa5ed2bacb0cc6b33e170e0631f42f64a744f6881f24ecb08787fb9102d3147071f7a031b03d4fa63f92be9e18203b07e46d4764e66a02018cd7df7c721c74b1b7b78a31a9a522f1831c5a38e2562b01aedb9798e36cdb45c2eb92a1f7122a8faf31d9276e20367a0e635aaa68899d4d1a8872c388d34ee33b8569b4ac2e628e5e766cba7df2bfed09981a9f95c9ab2aae9121ad0a3b88647182d4aada47e2fce59057dea288e1d2e7ea5b9e9093824da2284d08a69b74bad17b7d326c7b876e568d9b806232e5e9b5369b86e38ac5706979895ce82ac574e77dbe9ea1c1129007f09a9df24393207ef735806fd071ecf866fc82a536271630e0524e53e39fb9be83e86f168d9b05ad994787418184f4d995994c4da5d078d8da52645d9c282f97c737c6f690f38a12c0eaeec431bbf990b7bbe4b94d98ec882fd2201d5a15f5ab53f6eb55a88caff300dd8e9223b5481df09ea42190c1dcb4cff5b16f470404e3f7be807ee08e6255d49c0987f27d5322fb1c7ca9e9e595446addb3d071134d4e79713290d0a8fd8b5ed4b3079d046ae2d3fd6d366a2b81788a2fb176eb02cb799421d29e62a2081f2077c61cf3fcd807c5789ff4f18ece161deb32e447272f19513f255624ce7ed3748444b6366e117c6526da608784995f3de56f700db2a0cdfbfe036c7a96d8626d4b9872b47fdd9524cbddbdd127971e7f1c373dbb39e200a5167502d4d2c517b113c77a54e48a07b9d927b6e5fc9e662a8328bc3bf14577c546c27e84db1ddf8a614d052cb85eb8fd6d78aff10516fa40eb4a0c02bad9cad8588e5ac82820093ab237c11a3a46b2eb02a21ae56a7f5094d9cd385d56496967652568aa244734bd037f836307ede9c54283e8153fd9087e7d9b8bd9e209425cff154da685b45d916f92fb46670d8da326b48b7e4d08059cf1920472b1424566f9142483c4dd2b9d1e0ccea5660008461c4cfb61a11be00504bb0e7a293b337af3a3ec9dff694c53ed0b603e264dd01ecf794f35aa880bfdbd883860bd1d8b91f5a8ff6c8b37e76f16a6cf1334644624045c99bc6eafdc0b055e5af0e2602ff8de0942ba299aec645d74f867f41c4765c72ceda5a2b4ff782716a87024d56c29031144597eefde06c3eb0e95a42a3e2fad9033f7a8c487c36fc4a25317017552cefb2d21eb2fdd6c1f7dd0c67b5c85e6a3fcae7c8e9dfd21a3e527f7e4bc71aa57ce06034de4f7d4eae6e278bc199fee326904fe6d86e318d82e969570f16fe6bbdc12c43bbc6648fe931c6120d39d40e968da766fd6e59f550b095599a42e409fe91b068640b9187a1c8073a1c30e336ea629e46f0e19133162b8ecf6b194a91815cc5b75a2b4b21ab4a33099996be13ed774b82411111bee725b4bc94b20cb8d90eb1676adaaafb5cd14bdf7f0aa360e7d0f2d08c9a63cb2a322dcb9eba44fd1388924f750863e041d2f714a5cc148a3277785003649be4e87cdcd9402ad88492240a1ba35128a699e6d2f3c032e1b151313dde9b00954694e780bc38ad8a3a1a0a83c22072e93751a4877caa3d66c3bb9577a7b7cc01879416fdaf7f2d713869c0678570e7d3e8066b8e8fb69a8b7119669f64b437da257ab7b01831b85062a105beb44b6b726a20a61ecd1a047b2f5cbaf0d05432bb88b76fdc8ac11945de5623244aa27dc3e716e131b17b70c51ec525cd2cb5c8c8361d4428e2cc8b3c24c23d341ba60f77d8ac48bafc85dba4beb50a98f46b6db763f3658a0e58be267feaff27566ccec77d747f4de83973af890ee3c4d2bbd03b45086294538f9376f71ea36628b219feff59c7b31ac3ac91f91f83365dcc413c207a839c91f58c79a85f4924d05cf4a205a22ad81800dcd7f4556874cd53194851f8222d848ea235987217b9f41407283cc90453ec6427fd4bd54b3cdd00eb01efd9c3a547adb8078297c9a98556b300a399ca5dd701dd00c1d77192205be3865f01f2c5bb9392ea2bff68b8f8e7b10785bd25d9f640495102e9fb0721b60882daa20ecdaad75cfbd0d7b849851844e3dc1e75ff3318bab9b5cb7aad5325350ee4ca9e18f69064201136eba08fef7a94affef773982952ee389c2176be7377786da94d1015e52d55e9298e5f37ead7ddf033d622cd9d8a1c3fcb2f0967f1872b0a40b10319007a819be7ef91622c309015230dc7dc4a1ea45af1b6cc6e56f146b707920081528c36a18ec1c7366ac0c03b287e5331801fb07f20c068e393a5fbe4864dfcee7319aafb2a8f280f1b19f7ed53795eaa847b0999295d66161cf033d64282171455896ead80adcf658cbd00472989d16c1152e1143ea06ad4bcc4c1cd57c9d64f57549202167f145659b1eac20ff62af877d4cbe5b1daef2b4406995dfe979b0c0e627f67b0b94e8ac22f77846f3681fe0cb7cc642e7c475b88e3b9e391a42d3aa9522f7499166f1857b8cb70d49cc56cd11b489afa723d4b928157233314524272963ac84ad378351af36af76949923139f9607181b48bdfd2280fdecb9d93cd8aad716fcf00d375fc1bf1e556ea9520120de2366aa66d46a361a02aeda785046e6f2d8ee428a227c59972df3c8128be8c7bf6e71b1b0ae98a84f91b60dd01206e544cf4684edd5943f8b98d484e97f1f3dfd109895538136bb3818d6070d46eca2eb197b32cc3516fb80face0b34a393b5486e6a15830df373b1648e5cbc5fba834ae44d70d061cdd90fc5506e45d58e22c88300872f21479bb0d85c25173c7c0048d1e9f675c7fcb860390ffa63a548712809c05466947ac4ab01940dd34dcec0f9b734cb8e1e7f4b6d84703d51f64990c49306c5b03753d2946dbcec19a3ea02b29805e53a4bc9685e922bd46c3f7f5bfb621e404a6219f5dd640c181c2aef6a3c1fa229824c9106d8c4b8de746479687c2cb522de3bb11a30f2f6d98ce79cb50575e7d7f2b34644a18407424a51bd62f2fd6ab8ec42d2f77d7cbff3a9886a53188fb441e6612155f79b8ad647ffcf76d01502670a29097ea91af14c3aead9b31901e923ce0cb317f11cb2d05faef384e5323613d4dd4ea48b7899cba101310ec53a59dbdf95c0cca1a112b6a94ff46f68110a77916b09f006ce0dc43210b539937fa4a3b253297fd23c0a92731c1fc4fc6f3e86e4049c76fc527c6d7396b9609f988184de9088528662735b5b5a4eef7daf9c4079b7e8644ecdc8f26627c8909858b6959dee70a65a4069d05703497a3a1e9c12d8f2d03053bd18ce3c76be5f82d346e2ea2f7321b294a767ad7657de6fc0270984ce17ecde1984aedb988011ae3e2b58dc8f10e1a7113c9090cb74dd52ec57fc674a5eb9bde2a5aa3d6dd514e47775deaf37da73ebad91265908fd727be70653e81c69f30bc05e15599a88cb562ac3726983a73d59176bb4f625f30a2e9047a30aae46f5da88da531576b9b1e90de82de8b8ddc98564b14dd91ea3d6ccb3579e31d7e2f0e5fee6e4a8611940ae041cb92e8ae25ab2257ff66fdb5d6552e69745b2a90558f7d1a56dc7f714aaccc4f9a556eb085220617f559b19c5bc612bfce88fe2f5bff140a032228b0e51371a57da1e3fa009e85994b919e7b8b9e7bb10140f8a89e2ab34337a2106a81e833a2d3d5fa13d51e24d5340f5ac9aa80523b3567b7439f5d8d3e36c3d4351ed8b9f45fc692a57afdbbfbf3bbfb7c8187f1ad3ac29442ff443ca620446d39739013c804031850791d60e1a115ce47f261834ae22fab58def94b159892f5cd38fc5c2b2e6faaa6a62550fd54cd94ac7fc9e2c1acba2100004e794f1b43046f3c644e3654a61c5206aa3d17215341aa633e8c10526ed34ca96e572eac1da2a45b730f210509771644b4a357baeeda0592ff4331c0d3b2bbc5b4e39b008885c9a3340a16465ef8df1efca3d495ce1b2cde93474fba28b5914ace8cebc472d6f276866279e591e102642e2ae60f0c16d575ce13dc7cf8d81dc23b9d06809b0b628c75fa62e18cf706754f58281399d957478852b4233da342d679d62aa750b81e0ca45f564d8f389644e1366a86be3af054cbda85513916d2440655fffda72f0cffe29cea99d11713e4662fe91181725a8085d69c4793048deb85472c8aceb7041b095801799ffc375a86b35d18a753efab90783db8a0df652a4960f7b5fc4036c692e9ba08e58ff5266b2f0af48c8f3991849f8b1a570b13067d3f31d767f55a3cc4ecd346391b038c595a14264d7d8e107ebf75ef8331af1853453296cb1f6bcf064f7e003701903c7f9e30272c0e191edef676e7c77acc263880e5338c60fda3eed267c7cc217be68d97a1e6e3e2e99a2589f5ec507035f1fbde93124c6d04dee8b21ac7b7e010231851a6a148742c84847a0165b305a3b5f7187fdd540a6e3e4774279f4cb686b559af59a63a388a66f6682dc80fdee2dabf00c4139bcf61780c65dc89765c6f2384ed81539758d3796e473e1aa4c56322adb72a82d3fc39aedc51d5dd0e81d4b685b0b07722a9ff3c6899edde2ba0fe16f0c5adaca6aec4ca341fe7887c67e8f05e5e2d4d0cbfbb9ef7663e8dd4ba518620047893a5171c3eaa87a501164c4195a4391875153b4ef7a3365fee2e52128aa5f3a705dd3205c4eb15f993950bf22df8e134747ac76aa43a71fc5fbb1b56d67d3283fd4785a4ae42c04d6ccbd5a7f29cda5a3c734553085ebbd00fc60e9da6c60f13e0581001f9a7b628e33975160b5b9e416c03a8456dc602f6e4e459ee19458cc0b640d8652a2af536b64bc7c2bc760e125c0aaf4ae39032ddc5af93ee5c3bbb210c90ae8a5e49c0d77ce78b85fc07ec3a539ef099fca73ab73190e9190fb8bde3f6f06b7fa9663bad038058768847c13d5a27de38983166f81e3485e203c528616fda61f26d676ef75cd5487d46f86c274972d1a2bf0de483c083ea014d6d8037d70f626e68ac6123837cab7bec9e345f691494a082120c02fd517800cf44a01667d77a2bb9ae0ace5528c51955e6d33ae1f91856674f7b6158349883a8eeb73f3b45cbd218358b019778ca8466a9bc212199e06bfde30da8adede85086979267eb03a29760153ea98efaa5dcfb17f4a2f8b5bd6b076fa176a0df3be5a1452dceffc222ad507af62e0f98005662c97bef4b1e4efaf50f5b0a821f74180f2e39d61da853b71dde27fe0a0607c0f9ef37c57fa678ea971f09468f9b2058bb7530fd2d9b7ae0ca4d69929513a84f1f8ce06a3da432042795fcbe1889970f4dd8c0ea3c88cfc194dac39223b084fb4a021089ffc1e6a322bff19ed889b061ec907cb2994aa745b70c0eeaa810fa42a9c5e4e5f38db40bfd648111b8e7404bdd40d1d500e4a482bf80018f3f2aa81a0d34c3d818104444ae6d411a52ba82bae4734b53035993974316a7541eb13f09e6e85c412f07c57cbcdfae105dbd90c2c02915dabc87237a1314c0586b26a7f268ad19bb7ff098d1681bb6179024cfc22ab87fca1d89f1e69499c3331f735d1e6a0275c2057260d7a566907e74323b784e0920983bb8f411bb5079bd9c8c3680cd3ced754d7a3af2d7b14dad6b603d5e1d928de6535fb0eb9f8f1a030e22ffc3719f31a2491a072232b9575d97b3b46a4b03d4d6281f73ef17ad74af7512b7f2cfd3f1373fdfac4d2a8dcc654f3707b303f7e9b7fd9050b4094ff642eb7aa7ec1de18499f2c49c1e9b3e87f8a6f0b095a0dd499d798401402cf33ef012d210031836f733fdc103c9c87024676a918c612f699cb6c7c5cf8227b06e2e2010f47baef42b9c26655c330c02ecdbbd4fe2e2df8b11da9e4e3f2dee301e4115e48828ddc23a5581a74ca5580eecd0811df501d39832fa54951939701aa497e4dc43f417f3d19880ab5409e681cdf58e1f6fa1172b9ca9ae157854ab1d232b451825ade03fb0fd1bf29a794125b9b8191fc251a0a6adae50a389003d1b519b8156b1ec74a3ed19775486dd3092d526d4cdfebb2c6191375f703c6bcc13752d60d5f64623c323dab03819fb867db81273d1ebe9d2b3e3e6f87bd0266d7e19e603d815265797885ce612fb6cb9f06b353b627ea331162cc815a4ebdcfe4e286bcb75cad5f6779029fed0138eb8c4c42c334c4354cda981770194a1da3046e00055e61d1c1165cf22c335fad8ca7b44a380beba5d8da3fbdda184008b3da74bd13f7b9f1c5e8ffd5a530d0f95970c9c14561db3986aa630a31f8bef88a0c01dfc56defbcc78ea8ebf1cfa8da17e4782446736e6c0db4bd597731695bb8326a604b4442716ee5313cb8ddf41bf86d5a0c34e63dc14385f3b33582ff7db1f14cddbf82458d7d6e918e3ef94dc3e7e8dd0131d5d020d24f288d5c9898274200115760ecbefcebc88b847f5a9b86cdf5b4b66dae72bc2dc0b7e671f8f09bea9d37821a20c85b7b37de0aa37777e3cddf178c7d3dcee27e2c1541e9a541a6c21e7c1f264e78bd7a76151be85f26e58c5694800286fd3df5d90bdae035bbddae9c125ec473c1621c675e4b75a121735641cd339dc8003353273965e22011e93b66a0f780c132f32876ab8b430237cb42d96e2d240bd74030dfd710c0a04aeb97a48da9b34e558c9510887931df1c0ee2e784594e606bd46a8c66e58827638fc2690dcfb2a17227c59012ae7eae3ad8b2b592c5a5b5084868b6c4f0183a15cdcefcc1db28814ce3459f3152079e2bf9933e1b1580b761841e401d12a7b393c1de16e52b81947670bf3e19fb93e57cc879b8629130c5bbb136c115a5d601ea0c2b250c2b44f54cf997d072e0a930c9c8238248193c61239bcf3b80e76cb195dbb9d5bfe366cf58697a3dfd96a7ad60e87acd3c8ae754f952284b96cba804714e67d2faafa5cc3a319e221144bc9b968a1ce589b8c083724381153194d6316e6fbe549379d4b9add8fd7e96e18ae1af77dfa85c727a790b73060f0420cb04fc549b989ccb695bb5d35948adccf9bdc3d15b549476f557718a301544262c3a5fa282a86d3a2d7604ec5f5283e1f1dde8f9d3df4dc169ebdb362751bf0018f597bf765df41677222b2102866ce85ff754472c2c8cd6747deb1ae82c9cb01ee4f91e8a8c11b53af5c820c6c1ece0fbff4c9aa074a77d6fc8b1cebd697c57fba04310eebc6ff87aa29e6dc1283c97eb55f5bb801f47740fe4390b06d183abc80c8be6c7a575c7c472c4218b70a4776a23df468ae10f054033d64e335dbbb4385fa7a5555d6c4edbe9e305229462fb17bffe8c5928885f13f4131348af73fcaf2e6801fdb40f982a5a286e64b08c8e409a7ae62875e815aed8e6128178ad8cd59c8b980f988256a580d253e3399786ade6dd3a1fb2f8e4b327c912e256a95229f1dda8d778d5f0c77816184ccd0865ca7525efebc5c53fede967787f48f3a9ec8b9568db50cabb08485b22725bba980aa919a3610b8f6b2ca68b8e34209bf0a589c0ea5fcdf81848efe0f201ad1e9fbca683ccd0bbaedf0e330ac0202eb4c8dfcc9b5722e800da03468b9cf6be09e9370990b8aadb329aaf9c2640f90028076b900cb9b484fb0a21cc9c1ceb3575b02a7412bceed94f81e8d431cf2b83cb86df93573b4cc6d046b14b6011241176bcafef441f5cbf0aae923be41cd383b31c830bf3e57308e53039837be21caa06695aa7bf9ac5cf1dff7b17803cb6ebdcf178179d1ba1fee623280f862e88290ceafb79ed9c8d08712d7614a259610c905234a11c013ed004f11435522929101542d865630091d3ac56c53c7e707a9300149fc23ea573ee9cbc511d71b8f8dc8f65a1fb646462b0cd342e5c7a786cad1a0dea0e4a4c29ea443c8be081d5872ed948405066e36644461af462bbbd18d99a4f90e0c0330c917e47296999fa5a25d33ce7a2d206c08bd6f7a6bb6929508947489b20832de9adfae6c84fdbbe20772b4253c43abdfe6c0d399342890d2f80045f92c5a91196cb3ca6d0e0659516f9626eda6eed360771ca833463aca76304d07d512b785486331e66e07cbad13eec4ece81abf0a2159a55bca89dd3047ccd95369225aec1540ec4a8e0ee67f51e6fb5c56341ba35dc83b67d5aec7074e13de5db952c2c41497c753d0fb10d871b0b4d5118b2bcf1fd264fc784e77e4ebbf8446c44838b5060aea4ba74ed262a4752ba6301f239f45106388c23a72cb1d85074def910925f6330729d844d58ce0aa3bee78acb9b97d10b2af920fba199aff3ea4c09c0401ea97ad7408cad4d43db09f15a9472cce2abe90e47e97a8140422ce848ca1447c8cbb896f03c82dcf97e5f009fcd57534413be48f488a488549983b0cda2d36a2990650ebf4ef90abfb2c9f860249acfe59bbb5b41e6f042c0699c4a90d99b7c758e74a91fa7e6530204c72824b3dfa57506aa7f9bf96c32c88bc9631940519c41eaf42bb8f4a9837e0de38297b0738b6efe514bfe1fe5f97980c6b6c06244988c8e82827fadc1ef048d7db2c3fac55c7574ae84b40b7425e73b36edad0a1076c342522f4618da2bb8a8baa5f3e4ceda6740f6f1273f3e442d001eca889b1a1af11fc3e287fece0754dc39fe6b48e794ee625c8029b930fb0a8e1f31fbe5b31f690e9b5e3265dec0d9e3a52722c9e77085f54e9aedbaded49bcceead299e105111d6d8a9471aaf00fb6054b7e0ca04947b643914f776e4594287c1debb7f4ae6948a10b53f6feb80599f24bb2234a3e227b5a8deb8f5a64f53c8fca7bc81357dd70dee17d727f76193353a4649a69e6aaa49d367462b2c39e9acba52c173964af882fb64900a044eff3c3bf6a93040262ae3f00f45b4a7f18b8daf5274fdedeededf3d2ca1bf44d7a8ca398f1e2466ecf87098033d1787182ac9f09fa16398efad75f5fe9853ba70acffd3c41e99916bb7fd53bd01982c79266afc1bea0b2a2c64aa6283562e703363429afc349e6579bf7384da6e0e0c5c254c2d7ffca33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
