<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"665dbbfb3d26c31ffdb709e3a345be7cb1200fff7d918b7e79c9ba7d78c49772db4ca3f2bc40f7845e1f282c7a70bcdc7d5cf14ea1db80f1cec1dc67f38493d8c8156c51188f7a90b9474841d13048ae1cc7904f5a9eaed9a38bd159f75c554fd89567be30705994689333b6bf31ed44408b6942e227faaf643c5e9f7ee9b5ff063cece40f853be3143f0f7fa53547449a501c56358b6e39fa868c1bcfcb24abce3b3fa1dc5ffe86bf42d21560e0801e4dc8b5c1ba2bb65e1fba3bc4a37b4ecd7a9a0c523dc4a8e6723603660e871d7bb4fdf2763b9443139bc47a8de2cfe00f6fbed3cbe756dc47182fe41a97ee78b4461d0ae502d747cc83c23477053640bdf18e92fa40dc7c1a4e3a256466cd8b0bcc41886feb90bf10336849af20bac2364a54b11ad7185901eee429a7195d409e311e07192bbfcd6bb78c8d12ee41f50014b2769fb76904aaabb12360f7a30b07755380fbc19270843bf7b796468f069ba7d1397d4e4445bb03138e425244b57331b4975325cb6c33d9b201b82542873c7ed2c3248412e7188fa20b3e5d361426931c3a768a58e0f9910be71975e92b24673fd43aa5910f6ed730743c8949062d2bcf0a0ca3cc2efaa03046c18df5a288434ee1c9f214a63e93ba77344c2fc1b2040122d16c3f572a36ff509d7db457d20731f956c2e7211923cc0695e5cf4173539363cb47f1eb1ec2295ca961834b0edff989cbc6efad41741e70c54a79f17e036cb26ad7bc83b01679aca04c0b3e597c64fff642d341b4cebc66a8265fc381cda71f6134ef113e4bc2dd408dba068c295b9e2b1d05d526482e7a057f2f8b7772ffea68a360f94708a7012d5fb245bcc60e0203ffa3087ddbb5bee9f1e57b4b5cc321232c35131d31b1f459beb9af2822754e2163064eb2197b8277923542582c1955c85cda4ad6088d6dd9669b18bb55bc45b99dd33bba1e4268f7d1ef4de03d7c02b1aefe79eca716f6389ebe9539ebedd88a9efd8fc8ac38ad9bab2d68a395d46d3814179eb929fcc0f401019819dd536040a9b159d883eeda127404427de0f3784300c66f445875711a4865d423e72fd7e59e5734545803b09661b9465473371e805ee0f18ccfa71ec124f03e153cbb041257550a5db0038afd37d88e06382f9afb800d84e79729b349d9bb3b036324a7549d8e6ab9a426889c2cf463cac8a52b468da28a8f41d558e8bda8166e87f0dbeef096d13facdf58074836fbafcabd0924eca7afc6923ea02578d4d258884fa7a937273e8d42e7ea76fb49b63af51f7e1029d38050bd2bf6c6b35f5129d6cd9b9d45abafdb694f2c97e5446fbc7e1544640154dc28b86536a262c2e1b2a8032c1bffeb214145ec3cce1f87cc12ae87b7b91e983489865351c8ab609fef69b27cd0548bf98bf6f9ab84812bc055ca3b61c57c702a93d4a0ede5a653f41da16453524276b3fb59cf0ac8a5642420f3f90ff3326dcdc713263a354a07fa40105bada88c8d70f5fb8f5ffa720c2c1b920d859006d400ddcd351a54ef0c215311b9e91f46c1df988978829a5446ba182cd0c73ce1da59b5896b2f1f1267ae3b6ed523fac966b7bbe7a8825342bfca2b4353a94ee699c0d6a35ca172fc060e48874b95a8f5e9cd9cdda6229437edee20805d6d5915bda38acdedf88c35e17ed4d150ec50d15a8a4d662fff0cf74a1872cc7327325999f0aa0bede4ccd8bfc080f241205a852d3e97377fb9faa3c0c170156dfff10e40ce4f38107b531fa363f63baf883bc74c72c4809427d9e1df33063e7f7e98008344f8a238f38b41fabe62c01f9f4a13e7514ea2507fa147df7d6c02e2e204daa2d92700bec67cd0525ee783010d8a00d576620f34cd7827eba829e0269420a6d515382fc1e58958574ef861579aad7a39ac802262487ca7719fcf919d80c62a1da9854ad4fd012c240ddc63e5306d4197784a04fb491304cfa9cacd16335fc79178a54f9776e637354f8a88178c48ac1c2f62dd79515f59b5e6a2de3deab31f76bf7b7fe54692e3ab9d23de8e5df3ba7993083f9786ff6b569550397dd0cb57bec5ab1420753f132cde1c1f49298786a41d7909ee760bb094db83cc1b777b47ae51b2583fbdec7754be91d82d6e10bdeabed96b921593f3231420e28cde9808cf1f7f712e07e1277ffc53d18c3e9231da5192ae4d37fc8738d643432dec430ba80505efe611ea2b98d02e900d27874a231e67f585c24d0a91f06b3b9463b1fff3ebb1fc2c3d713b8e3b5504e08dacac788251f962be3c386ddd0e0ec8935404beb42fbf4aba2eefaadbb05ef4565812931bb2892b7e781dfa9b937477056429e8744206324d7a5a5bc61005ebb7f856b27f9ecf4feb4cfc631cbd32e6cf4a29b93c379ac3962127324c744e6f52eb5791e63354daaa693dbc8487dc9e6675b144fc58cf8e1f2311026b14f1b0a2ad790fe88d33ef32df0a20207f326ded3d83d82525d77e192fc66c028c5ec990bf32deaf447158ac74fed7c02be4e9df3641d285b3888263a5f88806ce756f09d264f21e1c9e73f628ed6f53500fdba49f5bb874aa38e9c31663907b6ef676314df836ea24beace657b52de996d13022ae7e4dda89fc87c9cd52908000c4ac962905cd986b62e6f6db82649813e35f0be777011d51d431129a69311ad1a4e0c0ddc4f15f3cb2796d870449bf6d8d1bcfdc2b91bb7966c8c44a149143f022726c86495e2eff35cc3e8e35c2e4121d930a8ceebc67bfd01bbdcfe7cb01ee87137d39cd55203f9c6465204eb06f7c7b16ba6e154ed7419ce9166bbe97ee8905911505b19f568541d6505fa2a5ca0635137fcd6ff30cdc057783cb800417f04a91d29f1ea49206f2905d512047584e553b8719550f53c4e0ed19f346f5c9925c0ca8125d81ba9407f7c31d7b466f6545ccbb497172bec37e3c46051f5fffc9cfd21c1695ad3456d60539f35dce8e3466b98efb47b89ce4e3ed2fd68b9c805435274b73ae60a482821251823213a72f8e1bf05ee317c0eae2628fe6fb313a0432fb4f9c84783028df285a36154315f0e62c113fc73c017e6de2e16f3e9721398d661ae117dfebf81f67beeb1862390c33a216a86d2b01f77a01f34003592476b00b10d048e4575fb4eb12fa23edeb1eb4146e1655dfd32ad06cda9329af9ea72dbd3d61662f5c9e7e074f17238746a68eb8eb13d27707eab9bdf6257c08f1ba1c9998f35ad250113f0a5fe9bcb14e1381c9c477564908931e7cad523edc9025eae14cae7b3b6118c3dc12347a3b6378ab82c5b8c3fd61199cf8d2a02ec49aaf12b7e50db1d74f6156c44a320edcf1a260ebceca6db46729238d2f7130a5e53eeb1381236553550a191076717e454fadf28dca016dda7770643785b92794d39f19aec4e7e4f149fc1918ad0c3f5991d03b2f3da372233e80bf478548c2b46ec45883b704c98f5ddb2fd0536d890e4366ecfe4d2d00b00aa060185df06997d7acd30f96ddaa7575be535198187b2e88cec6b7d032903fa1d7608df03326326829679fc6bc7508a4ca43ac03d46c50c78e63dc3269f7ba1bb401e3f0ee2acf47e5acccad1501a7bc2d14b62bc071ad9da1c13ce514d11c621ab6523a0b986566bbf401eefa62192c380f37d4bd09cad5f971c946c3bea50096c44b8e6efca1b9c3ef371e0b0dce9aa8e742611d286b5dfa8ed392610fe408ce3a0f98c5ec89ae9df4286b5d322cdacbbf8d4b0ea1c81c9571b3d1873b96bbbd7f993c516bb2d3c2c23a69213e9a18470ce33a5d390e7aec607ca2ce78861b766cde6cb2fde985cb809fe8c1ec8493ce4e8a1b076c6044449a5e2b29525886bf3e2f59de967a92e9d066390570f8454eb708ed5961fbfaab8a17c5fa56dcf00129d59a9c9d7d446816db57b676e5d2ad3b14c5403c0fce704a296093dac213fcb42ae913f9a07a5b3eff79c2e0e839bc2dca709ac15863f3e74f373e1af1a12f53ca996c9b3e9e7f25649ed996b41be89cd8f24bfc0385efb5669c3bfcd8a6f685dfc5aa04794ba0dd7ba5875b3ffc34a415d5b29f21434faa70e3383abd714d42fb96b43c3a070b355651aa6ae05af31142f54a3986ec8a6a0b29788f02800eea69a0e533148410c72ee10f46e060e29d8a550391ed313bcdc61825981af45fe8aa0fcf608f07c455678f6146e893abf408086ec5119ec27abd6e1f403b5f7a49618f499508efad2fb55b1063c2eebffcf0a55de046297b883d5a10b37b8b45b66f006b526a52b6f72bd275fdde23ce823953ff250d7a225c87111edf990eec5fde3452e97e1e8ea91932858bbb32358a39434f40b7113ff57e0a1d2e6fc5de216702670565cb2a04e02e0d191ea0336dd39f0d887b553b7b35fc9b0c12d0923292c10dbeb5fbe09d7c3f4efb2e44dac4279ea869b3fa654202d401fbdd7d74a0c1ec1a77f8395e9853579c2e73e118773c467e60334b6ab020f0a0876ffeba300355473ba2d676d4c6eaca787ed67dff22579f06c58a1764557a5d9f3ed5d67bce2c20bf7ec34cac624966d6ce43200ac07ae537ba128f2dbf9b5f09c71a5665491ce3ab360e6fef784598c0ee6a8c1ab86240f33036e1a5305ccb96d9de145fd965aef626601a92957f0c969cee1791b76dde366a5ed4df98b96bed85a6efedd8cf7409507c5c89f9251f025f9a438c7adba3e3fd7b81fe6cbb1dafd7d1ba48d5de8acd73fa6d11ca11bc84450c4d0bf1b29907af4706b144459f07de8f8d75444d2860c2e6151e3b16f885523670191b3de1bab3e3e3eb34420b9bef33fb08434b6a8aa2512c0279100f705d0e675baded5049e0b956a8f9b51f14938b4ab1bed9335e25c27b50e970effc1f1650623fbc821df889fef1d1ab40f0a58ca41e4e864e02a3e435c5d17e389aecd005ea369724ed4fa4c824cf25ec237f5c2d8419b018fc80d6b1b161bbf926fd66c1d42fd29a113134406cce0a3fe83483961d4cd72cd4dc7c2efeb9857facf57094217eb73d76bedabf1b8cb8e5dcfde465e2b744189f3ae14bd0bd20895f8a4ecc4278eb76d90035aeb1ae7676159fec9a5dcfe9c83530b0adb22381ff38f9b833c21c978eb65744c1f264304822c60743e80942ccd2e6b51c4246a86890dfd95a26f1de5f73ee3d04a569cc19d94f070f340b98322235c976d850b940d8f74a2e15a808909cfafa4c2588b4815c2cb5a48a5d303909ea458247c992cf39108d500733aafd2a51f8ad1d4e8906cf55781e31b122be1a80f684ae25262ca619d6b03a2214c50d698126feb935274c705903d1b8904a448899f4b1c8fbf4506afc624e45f1869ef182d7ec62a2319c6d595193e1c941695587da7923acfab8d60c5bb455f58348e29164e50ddec75afb9360741049259dd0e514a9e2fa9c8d7f3d30f5a4e72986cf938e7a079126d7222c41b6e6c73a3c9ee5cc7ab77bd4b56b08d6f4127b7b198656b04b97e35f5afb952798911481366c1e8d315aca9985acec5d86a2477e9bda059e1d12a4850255911b62f29e1e89231e127922cb393691f6678bf2950c7672c89dbe1cb1b5ff8ca62a8d5815849879e11b2936a4c7959c713fc60bd418b8d478b54a52390f7875f28f473454d1a91e9487874f99d979334304e0f4053bcdc1103d77863dd47e35d0936feab84672cb029ea43b05edd7fe5badd0cb2fc8397c7ece207dde979c66461edf8d95b158de467660c350f32870799ebb062b302ccf27b6bfe60c869eb7db18738e3d0b4efdf8904a1eddb358f0d27fc6fba3af441f17877bfd10bab5edb498d80921d953e4a7dddad5d279402f249de8611037d2ea7d5167ab1e37509d8eec0ecc2d6a28cf0d6a622416aedfa8966d3e03f2d2228064b357b4908b3993ca0bfbdd6625148f1f458384f3b1edb3efdfb5b86596caab272f60b1b587c7150786ecb4c1556f98c7fc197816f56ea6ed41439c811f03c8e66ef1057fc4533f194c462fbe05cbee5a490edf3875d7ca7923d34ff03bd50eaf1e5e83ecd43cfdc2a62f6331b127faa328f553b2150d8aef3cbe232615257035fc87dc9643707c48fc0bd48d48759019d2be339699798f51540b04cbbec09c5c73c999a96e41d47c758fba17e9e6b26a7f3f87e6ea7dc51554fb66d05c62c5529c5971cc3f89838a515f5db6c3528038f392046de0925cbc214fab0675b2d69dc08acf93a345edf459a8a70e44d1eefe8dc1e465e919416bc424d27109e0837d09b6a646bce3218300060c72e9749819dd07fd8ab8c47a2e8e9cc6af3e70cf0366aaf5beaa94c7f4d3a0c1b43d351d11953685a606cc8b544c35b26a2bf13aa5a744b748b0385e82abf4f8338c6a7c62372d66e9d0a298da3a0cf093ca2eabe2a876350cd2b17744ba3dde791582d4d47ef161d806ea728500ae0edf2037e89891d7845aa6f3fc7a9d71e4fcd4e4e86d626bfe48b87867a851c71c43c33ca9566bd6d1e7f6ebd6997c7ddf8cf5bf8e7c7261c1f8063e1bfd9002e4bc11290aad1d06f3de0c8f895e446cb1df3c07f0f8a9989a37c0c264546c99c568d2661c2f07b4feade94e80b32465b24e4e18a5253a288424fc60313d971c96c415c731d9452858748049cd393520d80d8d497c50a2d42c4d11cd48fd972704ee8604f61e00122d87d42dd574771913e6a20687d3fcf12deffeb2901c56369e637e0d5595000864628aa2670446ecadfa6aa82ccfd8e6f58a6847bd8f4f520ec8a0e5b70e8adaa2c3cc17feb751094c081dbfeb374c5b009665627fca39e99f04699ecdb7a8533b3ebee806a01cec6498e904eed2732da090a90a7a2e1ffffe268928bd093c37335c97feaddbe3ebbd6459b393c8546b3d47c1f1a3c1253f23cd7bebd6d070073041c92b80cdc77ff50c1ad00e66d8299622f7638b0a182506b29e3c35ab4fcaf6a0d99e08bfe6eb340911f5ef6b649e61b4780352fe8499863d01b30a972b975f1499b7ae978fa98524d6b85886cb294f87bdc49b4402c8332ddb72d8a34fbc7a948d3643ec4692d7f2f49ea381c71632ef33e79dbcafa431d5416122eb3224925fd73e701fa1f0fe05ea31db45fee24902c518dfd2a51462ea988f708fdacafe53a60bae37449cb80b260588ddbbeab35dbb409c08e47c4bd697daaaa6f7747e1de9d704c5f221457050b661626a7e474a8fc790f5bfcb52f527442f015f3c1ffb4c9d94c61f8f8f8a065c3947ad6be92d7d77f40d9f7741dcb63ebe8e8428a598859f25c238f7b7813697be5bff334ea487974dcb51c1a928b0b20886f2d35f31ce01954fa42eadd83ca05f5627d7f74582ac8a026c69a084aafb6bfe123e312057a3cd4ae4fdfaaee87b9a2ee7d3abe3b1eb61e3b9121b461bf925ff468028ca17dd2610199543ea2ce6712e29568bba7f44c1127bccf4247af724cdb8900f23b3eb85996f4903c868e06881fc8fa77d44ff677c6a36d10662069dd049d28fdb048f7744ed141448625dee09c66eb51dc7d53033b0324229e156a9239ca8bee8e9b40600cb38c3a17b3b867c4ef270990273e110906bd81cd31b89ff1d81ca97dd4003f0939a685e85be05bb5f257ace682e17d2ace0f52a513bffb40feaed5539a0de578a15107db9632f99925a794237ccaa641f7a074d260544e3988574842874d20566ffd4e25a57ad6c49b7b5c645cfc32bffda31dcfc736a00b1ee5824229bb522330b5baff0d9fab91ab5c7b0352db8d3ef13ba73fe52973f8c6fd08426649fa0f35dbe71d21a950c6635a19bcaf06446b4ce69fd061cbd6c612980f0c298bd9dea852e8e0d09fcdc9172b22824d1fc881f068870fe783602dfb0e0ada20469d711b8c31f5f088ecffb7570deae0e6d95bc3ee48520a0e9f051b5fbd92f395f84f91d75ed2420bb2e766be37b3b69ac00d1b12383c1165cb23467fce80a272e3a0892f1c42aa4909b4214971ecb3c52f5eebfe834b0e756bd7dda1503b51eebb4f082435fd0996de85c260db2c835333b87acb3c983c7d71a62fc1356c387521812ba1746729bbf1f8847501ef464b5dfb7b4b2f0361e5fae8ff65faa44ca854f59f81c541f76b4fc5993cdbd5a986b46f67ea2b82690a98c018b907fd839a480c63562f57065f98472b6660a5231af31eab2b985a7c3088df7580c55cf900d859fb6ae7b0e019e73047f19924c33a0ac9764756f804301d60c0c00790063ffb77be0f58db8a4d8e5d9fbb2ab685ecafe41880ce0e374abedee5707e45e8243aa708fe05769c4cbd1999a2b7ea134aa2c5d93cd160c68ced546abf5f1f830d645eb7e40c0cbc972e8931092dedd8503fa727208c7bb668413fd4012742c0418f28d6a09dec6c4d20ee28cc2a7aabba5425c766abaddc0aaf29a75d6c7de6454c0374eb3fe68a7388ba4a4d7029781f3aa11138523a35f37fbd2b211138a6409afcb93892ddf21af833cf988284160e3495c82476c98bc87ad40b86ed1a5217e6a5ed61af399647d42266a0c582d8525488fb74087673d152b5371558ec8371aa0d3d935abcab3f609d3cc1aed2c527b8d9c083f4b74e24c5f371aa11ea478ae57b5d4d2807668d463e27d96f769d85cc5b0094210aa4338b5ad15e3346f1a68132ecaf5ab97f13d83c4e99d1fb84cc8547be44162e147cd1af1a0332ebf5cccf1523455ffe6653e91cf7e7f4fd8a3abe760ac79cb4a0a4a363754a116b8310c3badcc44542904e62240ac64f76806e98461d336acb52fe1c5ecf89eee3e9d4c80322938afcc42f86a4eb8926aacdf7a3f97380164ff05f5e801df8259ebb1e3342dc7b935055d37f0dc9ddf486b5463f5df4122de4101dffd79f4e7b9a554c633fd41871153737a349752132f47a94cb8d218669882720787865e8101f5528d53c0fdc2ce17adeadf7d370ef4b5bd3635126071fc30f82ee30d6bcb7d9d35efb2fb9342f98f1d99e6e9ae68027cca7a08239e219884c7c1b326579c1029db2ef144d2de16fc6054a9649aefebb936409b6264317b6084fe58b3d26b8796a176bdcd0a0e5995ed16ed103b10d9049f28732aadf9a6bb66e14905e27704ab069f7cbafe01e7192809a150d46bb183aa53ccc74b505d9f8364da0d1d57fd13adb0c501b9cf24054885b363686b94a61a583adb90ec001a2be69ec1a7e191057d30b1cdd18afa60569bb0020b48d1c24c725c3dee1d16b72356098bac2f7f5a1069efa84b8e34332c52156f76db4c51f32a014204fa7d2ad97d1864b4179635f9d4defdf13834d4fa412b86a55b1662e4ed02913ec107b5785cae39ebbe0a1fe30ab0c73fcd558e1ff2424e85294b632036c5527af1f2c0c567d8b8a68b9e903294a3386b24a1601163e90180d9cca4d5f31733af6de036212e573e890319abf481eb59edecafeb05ceed47938a8d3382fb2465b159d9b1839f9965c3e0bc14eb943a3759345da24f99b449847aef7245b0c21755b273934ad0e8b5604f6426d3afa18e7b31c8d0991b01168eee41d0489568bd1a0f49e6e0de35b1724cc5d928a57e9ae45d3cf9ef745cbcb7d78beba173b4a112cc128a979c1a0d0a66ae9d540e14538ec7dd1c2e0a2255847243e4abd2b20d2696f4a911432e3fae18c96e19ddb31ceda2a0b6228d9c5e186a5af55d6cdbfc9c5f6d0c05740299ba969fb7e44c50da6e5b0735f73b0d1b362cf5dd8e486cac58007fbd4772d784e7211b658e35f51ae8c7dd31f5414082d15f13078461b64a3838af263bdc0d668855f85d8ab25f5d40bf961b78b82b16662324bf15a702380d72c84cd49e42f70004b2987a4bc18d1836e1de7e5fac438b41c5d6a37ef591dca42fb4d4eefa3dcc7f971ade41a582c09093270fd3bd5b56edfb7d1c6015169e783a17043cb5da409e8cb491b5c4e25067d15648bf6c05a88f339f2304d98c18ba94abdbb074cdf1f919c381138792e75b27587b935bfc72f9d5c48fadb7ee40a0d5601148ca1148139d41550bdb46e316737d0b1b77eea543a719592e93a0f7c76b33bef1df780c00e75391e5f06f5d5b405f36118c52c842934494e59878ecc6bff19c0f8ed3e034873ffee40447add4aa12729d37fec2412680daef582fcd430910190b32b1662c36369f9524fb399e2bf8d85f1b26481ab3fc7f85623055d469831f9a3124abfec25f50225dd860b61e70672ca0f657569e0a85c9c19aa961d0f38c707abb86f9eac918a0ed92f72dcaeb3d4daf292557770b6592a7d15af62ba9a00fc02b692a3d53a00a9207671a9c5b3de0303a0285aff46ccd120978f10c9e9a10444a3c3a5e635e5acd85f346aa1bcf8b3e57a4937809de1e80a3c984ddab282442f3e98857c3b759fad92417efa923bdb0b8d9fd239d08d8099d0c00160341e0be3a9cc0094a6fa16bcaa9a5af83282f5e32ffb2533a0bf495c43be6fa2884ddfd7586672893b38b65b5664fa8dae9a4d8a7952227114bbba8fb8d56894713ac88f386f276b930efbdea63aa756f988517ba87ef70dc05e97623418331323f66dbcba60d305880aeff23b81638e8e6f252a4f3450f1f53e34365762db7bc04f2d8b19941ca19a729bae255037b4ef1e7978050957d8beea50259952191512ab2847a9aa5099be550a1e3e9c7b24071c69e6f40e2bcbb4278be11352d567c9163f37d08ea54015ed40fac26785b34f9a9eebdaeb36a54ecb58c1b3b0c79e2465ac428e31b571d7a8c0accd1839f0ebfdf91148ef6761b3800a93966aa6ed50b2a1a3419b88cbc9acf71e1933611c9a4d54de3c18f3d3180c637093dc921925ef7ae318e1caa1b15f110b1d123fa6856132cab712e122888187454c0486e6dcc20fa029b9ba01e74f03ec648b12fdd9c934d5f9ea115551f4bfffc84ff042fb723d88aa7c10267039f7324b422eaecb93e4ad831ef7165cad20b787e127d204387a180083d7606bd8950a46d9c72f1189394073b06c19952dd02a64707ba6c37a95f137b9bd717300186d7f70e5dfcbd2b23976a3e2382f27470334659e034093b84ea4c73ca3c46e27193f031339ff473b1ea88ed125e728a016c3a491c2265f73518795a0bc0bd7eeb36d91b91f5e9ada23fce99c4f6b6d6a130631af61d74640075142e10e0ad204388dfd65ba78dd6b65d11e147c5f42620a16b0a81b65465ccb709aca0fb05970000dac089938e0d2c2ee35f8d2a415b922e0488a5e5903b6d4a2c715ca8d48a9f05af236d85d0f6505c3b406c6b32ac6ca0b1e901e6764be6c00f39080376b4798fd3b7d2256ee1a54d28eda5c5d500b5cfd4f778fecb74d9a97ee3cd6e7d8df596016981878a2bbce6edb1af121f64c6dc409e2b08bf6740cad2020790049e966a3fec51f99059541ef6e3eb1c42c1ccf611b952a8e3e6d5d2913c12562cee7ce85ef8b8ef5e1579cff6aeaf56d11b0f295d165621c4bfd40f507c3ce63b6e46f11699ea28fca15ff4230f0f8f98a11104e4c56bf4d53068923ad851a1fa75fc2abbfe4c806c6a373afdcfe6c0ed2e37bc143ca100b0e14f89110037d0480f38411939c82b3ba4fbacc2dd476d88799790548f1cae1329d9cefad40a4f9276d881c6872ede2de041c994031ea16ed07ed847fb90e26ac6bdeafe810794efd50dce185f7bfcb93abe5fd691e48796b37e5dc2e03764d2d5ceb9e45766a51e44ed7de9bc1809182bfb5359f71ad89f3f4e4a56d7a4d8fcbfa2d172174a96e9f2f3900cd1c321f3edb25dc32c8f921c3aac5fe092c10f32c8cdb6feef2c54a1abd2634113c1e21ed1093966f299712a34c69ac8b1412d56a64ab04e7eb4eed39b94f7d5fa3d42c8877c6bac56713baf04e6a63c71194326926a8975576717f812a203b222d56f1f639e264cfce0a4950dd5494f2ef321e143bb07f041b5242924e5a3787c0991410f3877e3d925ad27e4e66783222d989aea3a0972fa541c9f5784ac05d73f3145d5080d00b5182bc307a05f3dfe5bfda337dc6daa4638b209915a090afd9a206699912dbe5d8f70a10a49a8266b249de3b60fc43716b8e63bebc39f76269533ad664a3c4a2dec59a57eaf885a71851e409eab32422faa344ebe58c07aff38f37a2d15268cd5a3775baac8c0defdd634e344d9f021586014e17dbeb65c6fb183d0f22251d615e366d7d5eef075491dbac0f2b928ecf89c10e44d0e1758144a47a3f08d6f608e6c1404a92623555bd44e69a3654ab57fb5149b7ab8d949c90d387164e9d65dc18ed86559bd6f5b2c8aaffdd26707170ef48f15132df09d62541f34b7945c5f84ab1826df363ce8bf0da92ec50f43c960800efdab6d8e53b31d3a8a170d4a857af2c7fae532e4198d2f14d6a8d98a8b355ea2fc800400aa8cfc19ff29fe81ae94e663fea0e39c0d76400c99c57acc9b669d7d45056ee7a1da928f4cc5f3bddbd3299b98d95e729d8e9aef06e7b11dc98a0bab3bc20c34a94e580a8bf85ce7d47f34d2af450cb6a9e8b0a25d362f7c6f965b9068b5324755c7383d47f1b0f768b11f25a12961c7d6e1d7c09ea85ac8c8eedb2a3696701074ecdd86df8e866b152e45d2fb5faa4f2ec1b554c059df1b6cb5ca00d7ec81e5907e982fe61c13a25633cabc1e5acb732d758762d04af656c0dccd4933d0f82cb0c86f6a3a4c86607133354b2b181c61d4b06f8351c74fc8463f2240225886dcb3768f04f536bec70a7a5eb7744bd52ce39307bc19e588958b3d1b1d2355eea8a3f397a1ffd1f49d4e454003af1f3a2e8797fee38b45c359dc496823a7c1590b1ae49124663abd07d4989d3265d5ccc540b49add5f7704435c84226bcdcd58424e471c1969adfb223829aab1cd049f3d43530e739e4d4da1d1610c1df85bc5b2fbbed9e66d5d3026d3e6c0d6e6f25c158ab37424ddaa38cd455b2d3e37fe726f396e7c710eb2aa5043ce250f9ebaaea1f211cd5ccb856473e519c10cbc0193464a187f12f233368818aef9b5014bca1f0b9b12cb1a2dda85fce51910cccbc1510f2e6082c996d2e1db958575986bc1c9e30368cce306249247817c1bb0f69db9656e54502dabfb2a32bb56ded275f73302a9f69d6452a9b5e4441e179786cc1ed899492fd1b711b5e4cc2aa1b73140c68428c109c71f25a9416435f71bd8ffb4a863242554b248e1985c88e9869d9123f5c55338360d6570dfab8159b69b2890bb263dfd183f63188afa0f4a0104243e6800916ee2d1074c98f835d3d377f00028a07db43a2b2024f21255334fe64e7a2f58c0e7cfde23c0b22fa2e17afd6ee96027347295fc8277c2a4cb8d12e98c656541076c17e47c90a64ab1ac257b3092133ce10784bdd50c65e95a1e9b1ae87912666a58eb31076d6127f4b3cd5d0b6b7cfd02c0a70e0283ffa3c3142aaaeb5e2b98fdafa6fd81f7c199772eac70c98856f35a9e54beb9733b7e8ce4f49499c242f6a821298e60a5b99220de2f965f1f4aedaa7501a2a26ae6ff40250681eeabb189a64f422f9731ca54b18d82472a03802c1ead4e11cb226c7a71858351fb57b1b9d7b5110b8c2d12d2598f14f774be91d91428bf78cf9f2577092c38082e81a98fcfae5ca1e1800bb4d2836d49d70ac024bdc7fddae0eda8722bd43dca1d9f6d009810a6987f77ae6661b485e55645fe71a52d0ebda9bc8bfaf69eb0ac734ad71ec0f063c9a5a26340cc91b308c63cc3242ebf3ca61243a8f06dd0715ae4c12ee4632729c2fd858bf2774e95a97a890103fbbea37c9a8c55b413b770c12dbb4e92b880f8e2ef1afcdc46af006a6aa71bee67478e374a8253d00d38f03589e9f964079710a5dd0cffc601a96e90c3db0ab06160dbc46919db0661c631c6b57a7f48ada24e2110d6720ff5a6505a1e9b757601a4fc63f35335d30280599d6fbd46c4b740d651bc79f8f5a7dc9954fa79c916d335a3951848a900aa69e1bea662ec282cf1bf951d1a690615f1f68a5d458549c60d1b07981ca07eaf27ac82437580d8db9d5fff12d9e3eb75a9baf09ad9f95883197fb3ea1a451f1bd96d68e94016a0219d8003fc34290c956aff3dd22370cd1d840b7abd9159819a241231d1f09266eed040901631adafc40e3fadd3099733ed472bf9fb8a95b683a685d92f9b4d1070993481e2209f8caa204ddc167c706ebae558a81f79f939d976912965fd73706b68ae8d5af60abe6e794b83ed744bc867bdd5dd30d06e0b7bee47bcc4251490c3ba3b19f78f541a83819b4ad049974583e8ca699fe53fe3264700dc8e52803fc1ee86d1a84060f910db84d729e8c0680cc742edc888fdd27f99c5bf97444a31ceca01f3eee225341c4697aac53a0ab72c8036901c2d1f52d5944e7e01cc3014af80404588894504807a34d70ebaaf000f3679c24e8290254564aefd6c1f5e7ac010f1c51199baf0cd0bf11b07a00d01549c66fcb62d6ddcae5cc81cf13cabc51840eb14a48bcac68dcdb296f87e3bd569f626d58906aad3b0c15f82087e3083526a38369975a5b51553a10e92c0ae9d8237c8dc14362a3c73eeb5b715c34ce3c5758577c4d833aab53870c05953426b05b4f016a90f2f736740e7d3a841af1d641fcd6bc1be02b557907475fba7d58bfc1163326c1039d20c5c22952467bd5e6251c6cfe4aaf330b07736ef8453188c14436993be57ae7c2956000d2af6a2862743ef0925ae73dd5c40eb38675d5937d1e5c51c506e7f922f336e9c2ae980ad310b5db33dcfe02f9f5793e40c92c4712a0e0c7bc6648e0665c5bf09c54b8441d457dec754e72afb92679cb84fc76abcedd376ce3135567e5dff0fe38f0ad8f08b303d20cfc3ec8ed8601d2cc3c8e47f8268c584de89baf4ba6ec9d71ac959e03a9123201a35a1d87d74ca5877fd7837b9e0c3ba06233988ff8f3594c72b166f13b5439ee048d6a9618bacfdc69258137e75535f90e91528baeab2e6a85b2e2963deb9b2bd823a8aca23fbbac666093af9690e58378d6bdda6d725283b0cdf02b8c0aec6dc82ddd960110c76ff7dc9a0b5e6290fe8ca60bde1dee2629134052f0c802bb6e5d6976f2508b67c1a24368242b3857682410a3e1d401c5d5a66d2a933d22d72e4f3b878b8af4b5bed9be2784faec686cbc34f2e9cb54f5af7b7d98b3050fb4a0d9e768c2cc90f8b855d86a4b1fd24a4c732c349ea32c7044aeb8b4197a0bccbd8b92e034e8473de53c947a3ea1b881ae7a1360d82ba21c18cd57287ef55b3ac670c8a239e3a940c44294a7bf7dd1d14163ed0e64cc116175fd0b89ada9db09445b8db0aa46b3f8891e3a04475a464f848200dd500b82dc557d26ad0efa66de5e7aa36a35c8a1ad8cb1fdaa2b659c7296a634e733d1fc5c44639cb5ea045d1264d35cc7a39f880011821b3dd7c04c2ce88d730ac2142bdb2b0846d2e707f0d103b9c870f3cbd225fc1a43ee62ef93e3019636d6f42bd938c2ca7c35373f7827db8ef3afcf2d29d66ba07fd294d8782d7a2b4581ec7272f4565b3990ce041f39f1bd966276b23c3ba4e9dfa7cd6daa9cf523486d3349a93648cba621b4ff647b229e188a8f81ebe32721571f62c68a500ff78e625ddc6d3a641ec4a6e607c55b3502d05ad8fe55caf27376f9ef17d0ff1d89c6da43e0c7bc3b7906828661adb3a040600aa31064fc90e045540864a7cb90bb85f8105d5f50176b857f3f678b1e0d630e46642bde2e93e68429e90c06706c624a48335f6e1b704d367b54d30a7509d00ff4f70d8791535a3a048b61668e84f5152d736c6a0e0ca74044901b1a6043ab9034d43e83dbfcf364deee01ee804ace35b814ab08513c93b0041fb2185be843972742101cae1402a5a13c98a9bc795bfeb20408810dd1c8cf8dbb0c38671b1bb2c18ebd2422aa61745534101bba2e4abe653907769276a596b6629679e349a57e34e6037083383f769c5bc57c779e5de69d15a064b57e6ca3944bc5f5b7685bc9be6a3d9cf27bf3190735959ce25ec41b82b0946854cc534b57f8f6d2b4b7a61ba042d1518a5d9071d3a3978527ef6ee0854f0ed00d8515daaee1ee089c5aaa646e41039d79728bbe292e89bd7ee9ca56f5fb6fa81013e20bbdc7eb5108ff5e46170c4c6a22a614d8e1392d523114e2af5fc44260d3171a25393a76e3f4044e030a4e7ef642a2b44bd75a99dda168a7919225d55978a345b0f175ea7390746c4ec6394e6dc3b51e90f2227d9754d15583d4b317f797a5c69b64a8b6ec941d39b270070e2698db5a4de2c727d3be88ee83d671475ee02afab1927a88b1e83fc82a5f660b1bbdc9d757219e409c0defb601ee177c3e0c92e36c429becc76038fdc23abd5f9f4c422e53daee944ba34cdeb9c7c3dfbc96a59a8820aa64d5cefe983ee9af875de138aacf308ddae865bfa3f74f3cc2c3549dcf1dd8cc60fc1e86297f96ef12b3c55be7b9b18aa97fc6b13a50dd4acba9624d5b25cac62fec942dd5d046d426c849cb09b17a088a274cf227d1d70fce7d9e5c2d9d4f7da22b995ca3d5a7f885e94deb1cd3d176fc730c26516954ac4810c0f15c386456bc9b5c960e1ca213a6a9e2396adf876c4c03e2f90917081299580bb711d5dd059a843ed953d8b0bfe5822a8554249cbcc93ed9add838ed476ca78faed19dce764f20890cbb59285a257cf27130f6912035cf410bba005c1caf7292cfe261bde53c197288f816177c19f9c40cf65e9e17a0f1199de6610ac01cee8c2023c4f915857b4e9130c05c3575c51a7a434e80439a076392a8b042499fc8c602e2a956071020df70d97a28ad1c5b110df2d9fdfb6076a5d22ff9efd50591e6e42a48d612a29af57c526014365db453919de74226c84ed11e74364ab698f0d2a85af925c2f39f53a4b9db41b8d10828242efbd793831c177dc828843d6a2fecbe4079f9200c871856e8fe35554365a02b8f51af530adf6fb222404a583406e6519ca77cafe499fea4f37dbf6e948daacc9fe652db4c63e4d1f4465284944b8ec5567ec0ac81c9eadb64466cbbfe18fd4cfc151b7a0d12b12ea286d16b87a23666079da4c3fcd71d8327fed23a5574c5826519fe68a01c386b944a79950f718789c05c86af4ed445a0a70eb7e9913a9578ac2be633629088b991632eb8ed902e631716fa06f736176d3e4360a6872e091b901b75f61e41a449fe837291dadfeb436a9544b775fa2bc1a43a3469aa8363e1c89b4e15e4fe5c0dcdd112b56f3aa7cf6fa80833a9c9e01755f510ce93d874a34963901063f49826baefb41ba0baabe70b9f0f74572a6f6f188e5f66ef834c85ec88344326dbc10093039580e83b7e78f7893b45bb8056286d8f004ad41040a03e9d91636eb66455bf3daa7f6f5527ab6c68df13c5ca0be81502c56fb983170416f1c3cb3efa0c7a19f037a71223bf6d07973be53eaf3bca8498d9ecd07db320598d96cde5a5f78f9b3b3b8422de9c9bca7d84c862a8ad36e2c25e2937365f6c0130083f15c9c7e3d7aacd54237c509eff3bd6ea42a0eb4639ef969255e22ee357a31058cd0d5a81dc6c2bb5127b43d5dcdeb24f9d220e285c8b597b921ec37cc050f02171dc67765b34eda84e0f60265dc1db8f2f69a8d92157165aad240326671a2b9f5e55e1ff0b693b14ad99c0a2656b583e738534b36850c70c096194141a9492471d7fd9c8a46c77da968a94aa6122041a18ff84f660521f6b20e9a149a9eed873d432e1f1f078bc4a219add186e6b954b52ba1704998ca6cc63f283a54474488da073cf0c1b229f833384661ec6c86b56e5fd54e2f196b188dcf3b821c03d390bf62fa2f3d4396a6d2fa462e9f4c24d6ccff28442fe60c72b6fe5e3368decdd4529fbcf5e52df9161f5b13b631c7863a014849e55fc028887182c5b35a71757bd72c55ae297d0d46ebf44082345495c0c337e2372c55187644abc84326c07f83357fee6baafa619aa2a62fc6c6dc0dc0281bd1a7af37fb7ffdedf95fed87fdfe7ba8851e1b239f03aca410f78f2ab8c3a24b2b70720f919836c7023f956e05e7596f3f4356f922c51d1d3b0f96e596613adecb9644823b46a9493656b971f7bb7be5d2b0a87cc30f50bb63c0852014ff19f9dc4e69bb469aa733a8ff06642765319922f3cc91","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
