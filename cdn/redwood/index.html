<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee1dc11a62feac28f84d18687bf5fe4e03164188bb1eac84f23c04b5103217ea4e43a44f078beb2b83f17d12543c82e4f7d3476b8c87656bcebc43655662af615cc8045dc08893b214f27721fd8dc64c9dfe356c1d7c4d5b337a4ff01fb5939b18a541771e846a3f885b2a3aaaa737787d2be2c142de02975da3fec0c1320386af6b9fcfbafb6e6a13f95eef87f4b15647806fdb34f50718ff8b7170d3f09ec7c0072aa7de203efab2ae6c8224eb37f40a25416312d0ba7042a890a9d44674ef385ba5ef526efed74e10dad6731a3813dce8f190203a800c900503ec40d289bd627c0a64040bd48735e6e91fc0f9ab5e91a0fbb6415fdfe1d81146584ae7dd2d2fc2d01dfa9716f38262d8d1f9532578432bce63034ba9e25d48d551db2590e66d2d23521f5e9ebfb397f905ec9268cf07ee81f3d62ed32a083cde4dfa0ad7cfe9f9eb1227e45ac2b81ab3d2c3f412e88e5902f2084843a118aa921cc32563909d0026475c2e93ba67e310a28af99025d8970f0b85efdf3ee2a230d26049bb70a6644f06d05f7156c1130eb822b6ffe1d6235c001d11693079091058ce958b5dc548085131324ee33a82cc4f62d7268dde9eacd8ab63971104c1ba18d4ab74852da3283b52e2e11d328f40d305a2f6c04ef4b34df5e74217999db06e91f88c3aa2d403a99885802f293648b2ad5bf737c19a215ba55e032282a2b922e24852ecf877caf3dbb31d3407cabad35e1c562b5e700b33212eba88f309f1feb346d38b995ab5911178f54e23716ba0e3ee6ff2df07f097a68db61f3bf411ce9be9a946ff48649bd573e685989a3c01d570be3c8f28f47f66faa20ddc155fe8a03351df8af4782a167a242ac2dd86e73c8121f07504e03ad3913761042b136e5b7fa2e6f2c32d801162999ca7b5fbcb16eba254d04a9ba52a2d0808ef958eeecb47c1fff8824aef6adb917a4565661f08229b316ec3c3756f7a48bb6357397360af1705d58050675e1e8fc5269df98f2c641eb2ab5f0a92190a37eecf49a957d6d2fa206b24ca0c3738f42e783239efffa12ba551c36cec7f5b422d5f9fafe0ce1bf5ff8aa2d14704392ed54fa71a748f24e66d4b56b361415a118c97f442ed6af90d29cd8af9ad7a7c76a5641153732a532061eda9d48e196b15d6f161a93c04903ef3626d1d4146f37c01547d5bbc9fc9ec122ded48c026d7291b82a0de5eac889b7022368ed31e60729d13ef5e1a3ede4c626c42f239653e7000a426d1bd92f5af299f867ba5491cad98e1cfef6fc031af534e338d1b5e45bef81deece796ef18dcb5852ef882b96fd4a6b702c3e8aa187233ddad4289bc939a614d5e11f91fe5b6fe1df7ad2354e6919b1241f0d0e0084cb46d427a967f59da96a6674562424cf51cfca30d3236539bf3eb31760eb22926cd17ca98840e7259c1383c32900454609011710e33a526a80d7c78fe29a2ac9afbe787c9a22968e26d32a4bdb1361de39ac2cf26823c348ae62339cbe826a4750b0d07ec8089ae6aa859c9bb20c8c10460955268ed174a3773bcf0832b4a3be8848ca7f8184947aed03c1ad4ee699435133ca09cd6cfa3c5c8c522b20579df812c14b2d560ce93c6497ddadbba8ff4ef6e91eb0e91551eb340c3ed15f4c24458da4e8f437ecec3ac89aec141752aacccbc39039625da113988fa9f4fecae5fa3167b115556e10221e1d53914efaf984165129eb3a7a22656eb6bd74dfabe8ec252675517639e67cbd0ef24aed89d98221e55c832404856d1f947cecd9624ca8a9df3de1d76d4831a5bd8a84536f14ddb362fe93549aae103c53cf1c1294433e5dfb805521d99f23808e9018a24722d29604c4042efcb0bed452913d82c65cae3db382d146cde541112d1ab749b9851f11fbee9b404b97f8887c18cfeb4ce420c0e63b17cff9ed53e9fcc816d69e0dcd1c71d0a6748e1930219cb12e47ae2e9d58fd6639cdb396c2bf18cfdcdea072fdbd096828e183fd7e441e9515b39d902cb827f2c33cf10f777a86a0fae1c3dcd2a94791e4312abcf84437b399becce7de440502e74419e8b8ba763c39a5f59d43e0d4f5eda7db3ceeb0e55b0cccae18f96a15660f7c1fbaae6108c7f7e0baf86901771c2ea7b358de692c939830adb5800993122e81747f711cf8106d873adef987a9defe2a262021f5783018e10f4dd665087445bf8106c58681820a168ba93fbacbff4cdf4d1ed9d1cc304c0dec5c5e06337bbecbfa9175b6389e98427bcee4296ca53ff902e75d6c0d3a7498328d5c87a2ccaea3fa0ebf3f97b2b366126d190e13c5641f5c1cd4de5a82737b9e7b5dda19349bf65040e32442314c1dff8ebb0cb2ba63968075a5fbc7af6cea5776e688e9ae329d49da9bd99c84c0777a94e6fea2d4edc49da45073410d30e50c46e0c9b02abca54bb98f4a21571130d906b4f2134307121a8a538bbac73e5a78ddf47e73c797e601f41426aa4c47d0ba0df57a1471ef1f58a860a3b4461f6e2c082efa399669afb22637288354c9d745ebef2e037dc1ac9fee9a1b9ec0f935a9e8ab8cf5668d8fe64b981cfceb064cacd5665cd22b8013fb47ce3bc2c123e7b83f59c6d2f166429f2f0bb5bec76f54570c6ec5669c613d55f0241b3a1770ee91d1cde78984f55985e48b73b1bd1036217b7837e016f21939fe32f8f655a3ac2166bd00d8a7179fc8146300e808b701e04014444e3ec06bb27e6ebad515cc681088bb05895e7e645bdd17357e49a54fea322fb65c4ec4dabf84a7d9821ec3ef0dba5b10fa3bcbe7d3df653b07bb4e726b4e68667c3ae1c86da655f829dab425cf8f23bfb3a2d4b50c924e0ce9638467a88db7e17621d110c737e508d92292f55408847675c70c264d86b4a672381b78dfcfb17c0f901d89c786085d394d078dcfdf389c79ea21ab75fe73bc5c554df38e699c2bb3d01482109d8b853e987286571c52ff2c19ce0216d70ce8d0f1b9f3853d228026ee4c68d1e808c93b32140581711619eaf05fd8e5f16772c1e15f606558bcde5779c3159cf437e2270abe87870c681a8711a7e43383e31ffc33305f2dcaabaae02d68012c7d03e0c21b06f5e86bcc28c872e3ce681926db5c4ab874219123dd2ce34bef07393f5e3b0e7b96ad94972ca4ba12c3de63ece9355ea3a63928a49dbbee40e756e457650a530566dbf75e79a8fa40101af1479cea3630c160d09122e6ff05518f574eca6bc8e91305137f928bdfda6cc9936c2848839741db258c57228bc783201a58bdd32bd9e029d678c11fd15437a83dc7850a6dc7db273edca3dba10340291f763a5d12c0a4d53e712594407d0b0c19f67ac5aa08b358716d38d0c0ef59cee5180eac86c3fab6f1f029e0cb03018191e7fea49767bf10cb77cfd783c8bed59fa81d802dc018772c68d65d7df217d2b3e164b90f2ccb9db2cf54c405556e783db6ef869e2ed00570908db1bc77daeb9b6907824c2088941579de3ab59ccf9bba008a2a16567040dbe5c8599a6c18213ca895df7ee23eecddd133e39a7d3bfbbd4087bea2c6ee8169dc34218a75031e2e208a70dbef7529e3d0071bef30fb45b606b57d22cf081450a4a73898b1a36cbba90a7618279a3261286c36219da439b02a08aed21fc7585e2fcf06e40722127f4329ac7533150395c201764c21a9ea906d1d49c7a3e3490bcec2bbe98dc52ecedac5b3cbd74b714cc08aed05a6aa9282ce5b78984ee858b0c782fc7387112064b5645a315b8a7e3b900336d69b64c68371a8eac30e72c7df62df1d2eb9207e1b0709140ca655b6e1722e2a482e379cfaab859fbdeac43d8986fe9de5eda7754157bddf80c84951bf6849efb12bba842a165105ae0147134c11d9a8178406eca8513a40a1fdeefbab60b7873f3db2edfb9bcb565467d4c1d572b0aa2a30dff232e5ab00eab9234a0e8f643e63e2c937a66d637cbb37a8cad49f4ed8a84d1813d03e043c18be582721e70010ace482607ad9742d9ca4e685b61bd9749eda5452183a99f2bb0cabf4d7e88d874ad6c985cf638a8e5ebcab1e6a11b33fe2177cb22ad0cb389b76a3cb1af917aab3197045bbeccadc64f257de6cf23acd73e93c8e9eded751f64415e8ae9f0a5b37a977ca2b3f45f245cf482710e424fa665b6aab97018061f79140c4cc2a94006ac9948bd76996d4fb14e6a0f5d09b5124757645608ee58ea0d3af4b2f11e9c3724d28f780f36db66d478bb7351ec3ffd5def011efe5318c2ef6e8ee897591071459eb36fc86cc1aa807540c738410dcf72c12534caab908642d78c573db288afeff968685cd5e084e3bdc8a3094f42e94d32f157d717be18dfec00e371baa28181c84fbb8fa21ed9ad9d07d3afb9b03ae3210f49827114eaa5c5b5c1bd2a8b17e2b286c3ab0d615b30686c2b57df69695eb8c3e58460a9260691ea710244543542b3f46505ec3aeaed8c49e01a6346f8f961c66e872be8836d489a165776ca62c5fdf7fd749ce33fb03e6d8e6610327eb0ae67c7db17af3698281196f3c62546c3e904027436884f38af3795343e03d696c7b9739a2955092b42c485918f72f5a9978adfc7683709c91856bfaa41091b615cfef5b9b1c741239512c7c7d4f4331e8ea926d1aef800944f8cd0536a6a38b0ace89f826c4814ef09a4d60ee7f4775050bcab7c53c706117b2a97235450daebc2859b6dcdbed03ef4f49e674969c4c59c3fd9e26084efdf110c373443e83c8d78e157fc885fe413a12a3ee3accf6b7614d5971f9ef0e15494581954ea2ddc5f959ddf555319d7ef97b9d10b2b1fa7ae456a12c8ca3e2d45bae1f4ebdc87fbfcffdffa4a2cee6740d22c4e8d64512c88aedcdbbb49cf850541ab14ecdaecccf21c4dc9cf53a535adb5a255611a3c14448c789a0aec0d76072dda6da78c2604bc96380189046495958f31a366315af4f2170bff012f9eb8d900b32e3de0da744263b1c4bfe886807565cf8b269518124e0d5cab94fe092515a55f3f5a947ae4d933e64324af203e3880d0290a89add75354a3934f141a27318870a0e948b7ac8e604897dfd08405553c4886c32fad0391c3e8486f5b0d502baf2b792bb66c4106c25c8fc71fc1811215f2c352cf531d58a1f60472030a1abcc409b6423c9692e755c9e38206f0690c3208860149c12a8979cb9b318ad5d490934190e2d8907e4379271b2ab1e5ef54e3f5889e03b52c2cc185912a9ea95e2236738bef3d0bd1bb2dbc4d3ca1953ca55da56fda7f84d6bbe660e085d44195d7d7ffec400276513b5f1b601035037996162146925538ddac2b2ac1625b2ed927c665d2b942b7a9d7dcbfc0e45bd20c34579f80e969f24995fbd7ed17bcdeb31fe06d66871294634230721654b49e5992b6a0affa52ad1b620fe6b2bb637ff022a0b260e6bc32330a408d48ff37edbe39867a2763a960719a72676481936a7fe18be57d33398b5ddb1d937c84d11a86f4198be55dc85de7714cfb98ec0f2715183e4d291530208873c50ea5628ef84803670ba604e05ea1249e8c68b6b226ff039e0c3a3110095c1f296dbbad946c055b6f71df7f3cf027decf89b04bf18c637162b028b29f2a6460846034b4aad233f7f8af2750c074d31f267b20f6c2ef77e4226c94869e98caf4693a01522fe5ef8c27761fe7dfe26e38c977ba06ab22c7990a7822bc55c8a09403eda66b98b588d247dbee4acbf34f91f92a35700678d24500508fd1863f608db83a87a6d1dd9ea3455dd15db2e5295c8e3adce6619838c7f8deb3aa409bf0afd48c246fc9e1143a1481bbeb55fa844ff9558f047e6882fcd9d1d3ce14f8044fdeb76cccaa5d83734f29c73d9e8bc0e4414aed58ddd77b2cd6481b6e64a807d3a65e8d628bc9192fd38bb5cfedb3677317d543383daeb252b6d22ebb5da653877edcdd8e4568aa5cb2612a0dc2c8ebe8085faa12d08d6e02a010ff0685d8e516c0cc28ca1e9fd32026c9ad381e415c671c51de083b5715cde5c6716b27412205647c1ee5d7fbdc9da5a8d2d9da90adc9cbd186c0f19e2a9387409501c6e1256578f2ca06ec7f2272a6111c8b995d3f7707bfa313031bec6a57c8ce4dd4c8d41bda657f8dfe582a722d91b4911c5c6a300912469424498ed8ca6d590d0ae9bb9374ca7eef38af1aba44ee3140fe8560c9194e0634b9c6ca994f53114f6bf16273955030aa7f62a1bbc4d79bf7c1426e41ed5477aaf3e3ce82fce90a6ca4bd98a373936bde3d7464b194e3f39a2cce16e72bc2036c5f371b1560c63d6bbd58504c3142113134fbd2def657cd601c3455e049ad8dc2e9207b2b1c200f429735881a62085112bb4228b170110ad94910d71a7759532c2cb70fa9bc3975c56538a05a81886ce5c017bf48715cfbb04c07b16a99a5a2cd9c349fc2efd925b5989bcffa3178cfe009b7b600970c8b90939b8632972aac2cb38956ca323a3846d32e213f0d77a185abc516ae9efd9e6eaf6ff5c091441503e6e3f971960793e66e6cf3ca63fa16a032f89e3016f0bc68d5253a7b9430d138bddd589f83bc11c77f2d6060b5ebd9751190a2ef7b7364dc25ff82a83057ba776484e62af727770848c131329f2274c180af4279bf25b2c997d6682ed79a02ba545294aaf8a4bcb517f2e01f8669380c843cfed9921e3dc7f6a73302ecb1340bbf92bccd63a70b568a699fc3697322be860e6f7785e342c105d53485250524c9a6f71fbbc10d4df8e146de92a95a076fb9e56b3ec12ce1df28593cb925ee67aefd4967aa5b6e78a39801ff10d04432157b33e538b5af64a1c1ee29b719acc95004f2bb04d1ab06cc8f8298cc2b4d79a1fcfadaa09e0cd333832ed9cdf3cb860602f97f8c18179cf7e65ca91f80ed1c20c8d7852b860ee09696d4d71d5c8dbd47325fe22c1b37227dfadaac33398cb527efd807eb3a7ee613c72e0ac02988b115514d101d5cea8a3e053637a73a9034caa010432947049763b0ec7a2ee28d342e7c8d5303d3a20e014f2697815c599732d3fff636ccdeffa46259eba5cf0d1e0d0c7ed9a00b0bd5427bfb798b21481bb403dc9a11437e2f9e5b00d1ecaac980086e0c7758d19b267b9028f967e48c83b5914b854c1a545b948043edaa88553484bddcdcab0f77b079cf579e5383b0797671de38d4d2bea2883d403fd76adaa64e545124d134999cda35a5cd32461471c7e4b687e6c8c490f5724e653e96e90fa92e21313f502b468f0d3d827eb6bd8e7fb74abf8dd8a70df9de5e12912f5d74fad6985fd11499c04de7e5eefb3bffa7103990c950269e3c00dd0b3f22f4df674ca5566d9d243122ae8a3d0e605fd8c6fc3260d9f40853204e4085fe11c1eb22ed495c9b479af351a565d23743ae577bae9fe5c9791e6e4b619b5d336e9c7cb5cb0b09972e6a54ad83c08efaa9e4bbcc8a0c9c94a4baaf1200227e21c96817ae18fbd06bfc64d2316ea8242399f1f17190f86f230c782815b8a6a113ee9ddb5dfd7e9ae84bf27180befda9c0f7c7a3a5289119328daec3b4189bd27aafd8fddf4ffd43631bc6ac53e30a27b5d0097235ce0979c56ea9f968caec64b1ce0bd3a300672a93eb522ce9a5ffc18618a5b26937b23eeda5dc86fc6d3a9ca634837412b4fc9dd9890b1ae179328d1824062c57f96d6d31491d109e46a630abf09f07621e1081f400eba84c062bc7c4edd73116a4d65d096ca2b3ab85e99ab25df26c28b9ed59004d0cac26f3a8ce4147d7bb5b333f3a4f26e8f486cd755b8223f42240538e0bda5c4a8fe605ea84374423b78ea85f4fa06841f5c0993b3b84cbf649b7ed67f2dbe7decd4d7d6658fdad477edcc8a0f972ab208d3d2ef065802bd672e42ad5cac0adc2391e69d7ba9abacdc7e17f6673c89e2f6846e9103c03e2ddd91e91cf9753128b40acb0914f02e48e574eebd1ec6b855aac1fd3a907027eaff6d434151e6164337e352aff877c26c7db5fe8f415475d439a15c192f97fb4085a2969b376cb806f643cfb6ba250da60f19c2246613258d8a95a6b92ec2ff56e1f57abb6f153da151339f6c2db4915f0c952dc804cea202352815d7c1bc1e143f8f9f14def28c67ce2bd7e0d604ce2a5becb0f50941053be45d211565f5be91c4452dda2516225a85741a913c3ff97cbe1f4ebcdb0322b24e1317d3d1082126a9075a3ce8cbdf7b823ed1d0369d918f4bbc3e654e5986846e34472e5eb32809f1f100a2bed88831f3ecc247946fa43e5ff38b34bcd8459ca78bf1163e9b6ad6d68b5216054954c91448cb185953005fde3b764415380e187fbf6abe52690fac1c7f2c5ce6deb879a9c9f27454edc197eb9ca6e6a1ca33f5995d3bdb31d1f4243ae8c5d29b3991877f2e1b9d762957bbaeb966b5827dace15049583252c06cf2c78b8c0581319537740f52d28d5e2059ef6f832426f08aeaa5b16eb9bdf504c6ee150c76b23be8198fd9d79d3ec2e5290332b094c19d74a852cf9c6e83fa05d80916f58f615407ad42b3bc5dd2f3a0556e96232ae59327077ae05ea2ca96a76c5b541e8e6902e41209b324d54bd60eec010b2a0b0adcd21d11e0a129f980b8db71529eecec6d2771d6bae71fdec23b8a89ca0148fae6884ffcb55bdaa50e39bb61f9c96cac313b38bce65c741f3620b9e0818ca97f88bf84b7c1c124546aee3b7af7fa8aafb2ad478f66dcdf43f7807d32ff72147f984a3ccdd915ca8add76f9dc7b39136ae66a94d1d128f626aee5bbd89abc341ac44552852d0064ffeda16f1eb14d1866f9582bc7d8e70535e0549964591b542c7f7d4efaf7536e647d3eee3027143b0b7d9a819d663560081942d6a842d7434177da51ced37609e1dc1f754157ed78901b894fdb8f47a1a392d461be0cf89207dfe09ad90bfea2a179bd0e66184439c1ef32e6fa5b1f6419bde89649853e8dd765284fb5e9d60ec373f833241dd46ad9a2e9599e263e03f46c68a2ce54c3fb6c33f5509a15d4bc024c512866ff95813f7a61a2337ab84a03fe91fd80b545f6d4f7b4e41b208f2173bcf262cfb943dede33a1b1a174cf362fa5cc91d2aa82941d44f3a2bcc3659d049532b6a989d32252404a37e53a828b3e2622e635169210930dd9ce76b1f21b7624b1d4c7a0f0698cfb5a651aec48a840e1a31502f4018981addbcb6bfbfb9de25d64ebc7edad93efd9bbd93d741b280fc816088837b1fc9f07a4e592a2012626977e344c81d10858dcb54102cf0f80053349543620a54aa862b1cd741800e337c9f01cc8b39f6d6ddaa6758b53cc07d826084c5190b59746e498e012299c3cb9f5a42b07e914378bb334f10e49141812f382cbc7c63a17f0dc02896e6dd7ff5b29ab6c5450c0b884eab1e048858beebef83b59df6f8cffab0a3356dd04f89751c5ff432ba4008ac2194b0f03ccda9636378abcb6a53a4be9103a62ec7fc45e58f53faae215e12c68650f4572f6b49903b637047ccc48f3b1dbb210e1768b7e3079f70a43505a49f1c9cf26960c91e7327632eb6d87fc113fc57713f3d5a336c71f1e23140718c0989706f66a389ea2512bf1d1c43ed3fb541796386cd68590af895ed277a4145c862a3755a55efc0a79f45fa189a6aff44e30685003eb40904e9aa8d28a349717baef791152da7d4ad8a535f81aa47c8bcc088257fc3050e81d2292b3a58b363c743cfe307495c0fd24169e46a61c7c2f36dd2d520b574daa3df89c8d640efeea0e8a984bef58c30415dc8eb595c2ac99c050edabce03ef7feb40513c9771faec19e6de189e4a9313bbc8f4e13fa291a73c65a7ba7b31c9c832b9b79257a0e4162d705e9f1ec019a9ef981b1ab0c5ade913e4f0ccedd504570939c0e2202dc008e181e7b300f95cd2d7e95a5afc5f96227d627cc767bfa4f163dbf3b6fdf015bcb75e90ec57cfc5965f6d39c7197d3142aefb0824c9892237ab391ad01b1f8d553d068c468c587941720367e8083a3589449955665a338c892af2501b47b86e60ee08874e2ac43e084d067c74c00c97d9d01e1cd8dc0e429314fd300f844a5d9919e43306b3c3aeb73bbe54f4eab29f6013ef29640f907c275e7d1eaebd5a88232ac0ed5f7c337b54a4fa5b432e426cad51c9e1e84bae46c2d48f5047f54143580488e33bb90b1b9acc92961feff9d37ad27d83dd371d8e4ee36a7712dd4d2f798d1a1b8468c4ffea1193ef2195fe8fc59f5aea7185f1fd8d263cd94af51d5d99c4d0e0a0f741bbc54ad45154ccf091719c29e9ba3b6afb3e086367caf8fedc9621aefc2262c32fcd75bcf9301f418d70cf8d68d39798c532fac5ff6d7925bb69abba20f66d1c8a05d493905ab345dbaf738895d80ebe6d27326bd568c93bdf841183c198cddd3c3a3837b1c5a2741f5f5bc7d9bb0e141981234b10010d48a9df25fe4c5a4b21d4a894bd921ac0467f7318b3ea97fd9341b55fbe8dca2ac44c207f0072f22cebb61a5df3e670ee5915e681203a375f339fbe68e7e5fca28e6cc73e467eb873569c30d7171d2580594c299bad15e998286b2f6cefead42ab2e1876177dca57fb0d3b7af921db00ca2baeaa94cabf0e7d33beae96973f3b84e76c1eee277a97c597d0b37e0e057d5a29e8461da5fd70b383a3b06190a0bb19953d59337da897867b3716b738143239ac5523233ba23fdb1cec8323e05db3ea76987564495674c65a49bfc021d615345c10e6c6c5364af3fd47d900f5fe1013b180d2ed6bb47518a06c33d8edc8cd52da6c2dfc36d8b071122cc2fed63f4bb3b42b50ca9c178cac1b44d09e46d1f26a4e311dd5fa2f342d287af7a43606a1694101c7a8ab0e89db8bc41ba737ee0e25236322059580891b5738134f66538e3881d6ff66a45333f31f86db876c7fae9a249c60394d228ea25f68141b2bbb522968c5b8600dfa5b88cfe036db99dd882eb61cf31796d1ac4cedadcf2c022b364f3b5e6b11cf47fe816e8863dac19c5b655fbf19a27c6571296a1bc23b55291b8c176ff4d79eeb66260393f2417dadbc7dbee7bc4f21c41b4e049ac1659a98146d6e03c1d62d2bb7a733805696c20f936852afdf33a544bb78979fa4a61929c58e859a588a35be5845fe56819adb1a83bc1ee2331dd28a1a52cac4c28dac383b191e65cbcaa69de2460cef4e25cdee1a3a167eaf00872d8cdb62a9baa9f4ebd35d8b59f95e1aafb038100a01b65b9a439d0ee0ed6bb25a79188cc1022b2d7c178a48ac531d220158cff4d015d4e29a6cebb6bdd101462f415ffa9ca6f31c931242453923f1a2e64260adba542760978a2fb3b6e7375cc9bf4e05c759e80d61a100de337cfe07878677811e7113a05f56809ffbfcde6983df552b5964e49fc6080fc8b83d55da2382538dfb6d0166a1210bd86d7cfc940b0324dbd0d6674b3c97fc6785193af0519b98e10fcecec52a3f3b11817503949eee58610fb569bfa43c3c20161df14ebb198e2b596d9e6e237f09f77b5564a50956a3c2cf45d263a47f4e41ad632c667a12a68b045bb76efae0c260b2e080bbccc004172b30265e40d2be1c0e0f21c3cdf6bf0a21e38eb7d5ac9881b2c220bec8e1587059df62d79d09dc5013bcc4a2682c36532003c55c3fa8d8e83e54f7b1d40e35c6cd8c2a1f06faff15a0a7a137dab67e286961125811eaf8a3fcbdc66cb1cbad8fcce5c5e902a25fbe77089f42fb2a72b00be733553f48d34d108179de78b12b2bbec5682d30c089e39e178a7e7d07582214257bebf6406ba7eea234c1dbb050d866c8afbfc719a798ec8cf903435e2abb9c904f77c8e8ad9d7cbe14604b64da23363c3d56bf448e2bd19075f17b692147096850a6646c519cc317209db0f5973cefe1153200c73ee44ba7568f7a12519246de74fbc187c4b8c0ea416b13dacec453572df6a3f0ddbb62485ffeb088a3b531d847ad99209cc7630c0509c568c12915f3cec97c021547affeb483059483fbd4195846d8451c18a06dfa2417d7be8f90319bfc4627c13711b7b2c956756a4eb68cde8e2db5f73e61aea0f02290f18ff06439874c2aa27b3cf9f198e4950031344fe4ce517c788a28e85189b6431eb0751f70b95749629970e4dbf4e0f54209530d2d318074971d87b93f2148536e2c8dbdb6044358cf3dc95b1582760fadba7095febcb97c0158ea2e33bef6e477d8d1cd94ea624f86528311ed7138196d2e7ccb74466039d27c17911a1e51b177470c9d662744ad0832d22582cf722b243f2e9d6f4655f6c168e666b4417d857b5bff4d757999175e741b48a54b6533b30eb7d0a5b42da806495e88958dec89951a73d80b74bd8b938c122425ff6cba814f0402ddc33681bd624e21f1f192c6475d6f8e151ed059aee5f1311183dd160fc604a6eadf0aa35271984d3896eeb8c36bdac4d63a4f7b51dd17f877ccbefc11631d6a33654c206ba9c3fd922757887905560c406e729e474d611ef060eb0aa26e18d6542b0d8c396281653e067c8f042eb314b8810305bfd6ba06c7452cfac832f807a639c1ead2d1843490e5b83df1ddfa8ae3298b1f530ce68a6a4be8334404712b3e51dc42725b685798dd53cf94ef073d9629cb59ca58c6676af5a3e10c62f4e249e7fc36c3e68b792394319cbae0e2d577e7813021ff8f256f711500afa5e820d5b42e3aef66ae91e76dc0a263b09e8ce30bfc1d37e880aba27e223ec4514cc1e81c3a08985971a6e67443a4cdcf9d5533242066d5aecbc4a67313a25421edaeb83def3d8e3a7b2c3e52043b1f3b3985b78b41b97c763f89f2f48694641f874b6e926885bc4e1688c8e4e4917a5e6adc6989debaca243c3e49e9c28e869671497110c47b39de8fdba013ee020b6fd00e5e2e5ebcf0c0dea61dc9eb6bda81ea588a8f34e7ce50f799cd3a4ce570a45c5a799526207d446a006cc0cb5e6bd8caa8718c1304cb5092a8639d86055edc68f608a1e53ae352dd465e60acf16da48db01ac7f5eea4259de32d3077d2cc71c65dfd618d97e06f36492a4c3893a617740d75c61478da2afd292738ed4c003ad3c355940bddd072608563e48dcbc885231ae1c3360a453fecdf2eb230ac5dc3b2fe7ca572d2bf82c685575fc0ec40534b748160ccbd23d6d0d89e043e92e4910eed485f6629a3efae9bd6c1c721f8f101c938369bb12d88e90994983a48dec73a9dfda7b78f58d161c850e0a5c3386402d245d4242aa578a6f59987fa5d98ecae3053e2324860a76844d3fa540a46cbe5b3ffdd24d60043f6698ff23cfe4ad79538604d67d52d58b30507044a9d365f3c65b014be9b23205d18d48ccd8c6533daae05d1cde5d5e74ff70718b6e8e5d0da3a57903bd7cbb4970b8d611b8f35effbe5f139acef341d53e0d9dd0c16de328c1f2d09c18d5878c7f2b867b733f8f46f8fe6d26b63f4376c365a6cec24b02e2f0a1219a5d65d94293e4696d6a281154c1e96cb819078f82a702ba1028332a70364ee2b91229597213946453f7778453e2b60fb737d0d29e815d880c9ac5c2a5ff48407b00bd1933d4475b2382551778630f7198b0c19ae1343a22d8233fe37ef2f8014dbaf5c97bbb1bd9e275f131993f355858c410f2ded25ca0a7dd8360546371f886ccb796487d146a80e025c82954b23036571d8500aa571d2db780ef5ea120d977923a8275f41479e7da7de51d04b519436f7a108e105642ff7eb3eaaec2822144adba2b52976fa12cf78b07dd22d287882e2ac992419d699dea3d609a8d7f56b52db77349fdff07fe484a050d5a620badd7db85b728bc8f711079064cae6c7a24c4ca7133be964efd3d9e92f85115a7c815c853ff19c5659d22f0f50153e37ab84a8538ecbd3aa92af45102cf116e2d1a673f3f5ff2b547a99f531a14c22031256fd11a9bd440df88c61f9c9cb1618ad8cbe4e7784052947a6d146aa8c22de31caa5db618233262c66c3c115be13a58d75bb4f959e59ea68eee26a6f61554941377c87780f1d8bd0ce18fe9703869c3ee9523db93131956f39eeef2f63f46c389f4a3400a5e8c406416186f28f77a45c9f8fce32b526a9971657a911bfd86176b54f2e880b6c2f7bd882317e1358be36b26829fb01ed37ecdf8c269c451749100dee4a45cadeb188d09de836e8c40dadf2c6f3ca311b297a1908ef8e481b547f35644abafd10985ba9ffda7fb726f5c959de24203b80601df310622351d44d225a552f18fad7cd593ffbaa406f926e1d3459623ba8dc29db3a20aceb19e6d569695fc1fc9a93ac1b84efc764bf9e2100018e49b7a8ae5e0803d28d7c4df0887412ccf90a784cc683636f9e35be1e19088a42a9079de46a1fc5baf2d9a0384e8a9a26c6082f21aa454d34eb1e44cf315afdaa6be0a8be0fedcc1388186870221e9049ee345e70e9f199d177a51b695baafb435372c7b1f76ad85c23e97220c4f68e841fc95b8470f596db474459d31060e9141ab989df80dc4d5fade0e057f3a7320fda983d00e9f6dfb39b0142117a1cb1069704f5ce52a1cdd73672fd4f9a053d7395917af3c741de12b81ab0f366caff34899d1ce23cd1a9521a35538d34963f20d4715aaffae7ac0e11a4110e98bd4902848d0f1be83d8940b8d2a367a71fdab87f29d4407a1faedac27397380027909d76fccc5bb9577e3994e0b1d716e08274097a22d2fcedbdf38629b75b97f4aa8231f253801dc78713e6d12dce217419604138d070e18ede7a953bc21eb563aee65100c29129e0da503356fd04a05bd2ae85bee49622e67943fdc7b134a5e754f59310b1d03b6d762b5453486cd085a6b3f19c752fd2dccb82e08277e75b75c0fda51400ec6fe44d72d8dc96aa98f2b7374667a038a759cdb96ee9f0c6869d108fc21ac01a29abb1996aec14dacd8c364b5d1a991570b41804c818e5579363a8c5d7f1f58db8d9643e2c0dbaaf72059cd2f0f23445d08324701b69dddb9e49a6f51cd373bb0735765625166efe90e28f4ebf299afebd0f4c63ab890a50f70dc5ea8b6f03cd5a57c46acbe07e5cd6a7ed44bf13cd1c1f7c36f7e4581541103ea88251be7529afe9aed6e96529e82f677776c95d2e465752fb47aa7e998cffc9e7dc9a8b1ed3ef3d709e0554344a7ac1c1eaf2332229a9d1f869126f911ac018f61f439d8da9b021c64eaa9c84523","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
