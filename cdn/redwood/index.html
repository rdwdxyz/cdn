<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4990b7904118da1f9afc9d4ced9ecb716061868295e4a33047eaa8d4b99704a1577e4e5bc9941b639169b2bc70bf126c2ea0464aabdc76f72791bb79ee7b9fec7329f04ff02eb3bde3de7ee1f9a1b40a10c387e3cced69e73f5b3e6f37fcb966c6123cc301cbefa0274e9e4958c402c7979f2aa98a8fb9eb41a4ce506797b25f660f39e4490346cfa16c64631d95770e0985d89673bc7d41eb8b25c90a6c1c699d5ca009c0b52458115e1267365000a4334b656c3810e3b4cb41ceafe0c5e679e78e77eb0175ab343f54fd6640809fa35b4407a0fb1e81d1751ac779d8ac7b59795153c043fa3e6c83d298e3a118729d697569926dc963760e5d24d3672a523d0ba772132452212b258a4597edcb42d827ed52692fae3ba4b440350bd1c69bdcef18d95a5afa70b9b1436f78d13ad69f570a4f44c1bbc85876371aa03416e675e8af26e13cfdb66d76a501ebb870c6073333789ff618405e1449cbb6d137a7ab3c48121e54d185bb424a77ce0a62340e48c627e2f68853a67fa77898b5b04c80dac998f1fb6b209e5d786c8df8794f2ee96fc272e2324358d0c718de0b6facc3b7e0fc7a1d511733b3eb13ef4d24399f0be589eb210ac378376d2cc6a20166274e8bba89e1c64443b52cd8e8d112b699dd112f5207fc41b461738eca47c01dad33afa75bfc9b01a8fdd30643b38b31e7c98dcee12fe2609cce519b59255c9757b764bd44392962c13b164a14e24fcd561f0f955934b586dcba771d8019517c861a3025cb406c2387ce8c35ae3e52403cf6cb1d9e0419e1c80feccb512bd28f553e14ba72ec13f5c992980c34fe39595dea6a3b6ddf0369a210cb4cc2e9a5444133cace57300d8c7d4be884a96396d9128e6030a7fa38496576bd008fd50948356589f56a2431cf344910ea263eae0450ec72d9e664caaa2eee7c8166e72ea024eb857a4ad1fe6e82c15248a80a8114df6fdf350c9b6c18e2445f4e82103c5a8c4aa7bcc80b12e870fb30eaf3aa081bd28fe212d9815ba4f09a28a25014b6d53cf9e55a783ed9408e2310cc79d82468e1755984661f0d0fd3c6b7d9c0fa8f1acaeecb5b82ef32e9e2c2d479b53571f234f908057d9ec48725fe74ed22c0c6f15082fe2374080f5216210f7b6305f29d3179ce614b6b9ba0143a25dc7ec11b00cb88991e79458f41b8b7d50b38e411bb9210d765516e20400f216ba05c1a554457031c4bc63add6c9ce88a171f5306767ee3bb3247700bac264080bae2223271ee02a984fc9326fca323cf58186c5631936da8cc553bb85f2f8f4ef4dbabef25ba389b6c68336fa6705e5e4a0124a08ea21705dfeccafd9a4852137371902a7bb20164d7f2b37f45c15e56485a08cd1acba1583d499cf59a8f5685a8337f0c5db7e6d64db94a00d2a534e80f93e66897b099403be10aa06113b26b8c6462049447afa7272f9a559ea1eb133ce50d73d99bdf5370ec9916fec89be6485eaa95442df46f7c5f87e411ef788c874f22286a295a0a5df8c7aa761ca21af25c7751fb06947ef74d497ffb2f5f6d2cd412e61d769c290d49f61835f7cc1b11fe59655114d7c26ba340e1fa5b63369ab0a75dcd076a51340112099c94b2d2277076e00561687621f7657700064d83dccc9c1cef03c19198007060eda2c8320d33f44c9e0db808d8e6689d8de99d5d7949b12da43967cb6a8e6496d752d3fc9034b592c35f0c4716ecf01360aafd5c3301837a4f3c0fc3d0d61cd50e1f7d6fb117997dbd70f7ef68093a145748051af307ac6e3de74a3cd6cd6ef152371384ae2bbe310e1eea4f899afdd1d7deaebf4bb3971fa6efa0c09d2dc8133f380f58de83b66aa105175e661ca7fc8cd59206737221eea9b6de535e49fe772ecf82f8b6160884498759d76f308323213e541c7762381ac12f595cb86d2f70e42ee3c186391ad5022cdf76afa3619bde1436360d51c4ef9d55297813a93bd710c3097d69e0c80ec08cec378aef45f769139db220cf1d5570f0d7bcc14449ad9ee8a6fd25034d64fab35455c43a000b866484da9ae9239767458e29086959acef2e615d53cb52a43b1a9d44db0b2c53b914c829e81b7fa73e1c837c12645756ded92bca8c7e9c9e7525af2501fdfbf150e1571acf616118e7a1e9fe325d32626d5420427f63690c1dd622884fdfa5d17f4039d6644d2683377e15f89a9abcc9ee4a4453565b498a68c455ec9f781968642f9da5c92cbae46de23aff771c885fdfe63003d25b8ae3a57c4020bec10fcef411a45dc09f3d2ab47c227f4b52821d27c57f1fadf3ee8eb55116594a156e70b3c4fe1a0234944eb38be84cda3d608514dd50a36d4b28a78903fb6418be0810adf567a1497437f0dcff026210f26da18c60b4d893747afcef140e62a4446a37d433e3dc773e2e9ee990b61fc6692acc30373e85ace03af84f5ed42b204886de9dc471a52f8bb7db43acea3bbc429d52491fca09945c8c9b1a7c5c54e225a6e3f531f45e75dd2f2154fc724292847659638b759eb47a88a769ad041b7ec0bf9df142e8c40bdcd67078dc1e425c3f207bbbe958104da3dfc02bfcab2f8fcf72ba1ad8b9b8627a38fdfc7b748f10479ce41bd79550ec741b852995a8810051aa8f05411d99b609d3851aee6a378c1d1b70318ecde51937a12016b2cee32936038c4165c16b187b33c9fa8807da9c37f244b4746b56a0925809801e9a7ff5d4b466f8e35f945039e9a298c04bd4c739819e0ed0bbabbde7e2735a05c6923e86861476a6e97ad77529dd443545d82dcf452ec8d5bb9d6ac965a8d5057ba0514a2f4a96a5d8b306e0ae5fc4528273bae7d7be14fd2950d0b5eebca84bcc6c30328258f1e0c32c63aee27bcda433616b467d8e27f380d3d2378e6c82d3263d63a9b97baca26602bb07a97aaf93591ebccb8159485934927726a9a7e55adbf1e2af396dfbaa9621025a4f336228fdad13d8ea82fe19338ce15f2039bd9bda28d073058a70035dec30c63c5eea1e1d870aea37f032babaaf21d76a6642ffe7ebccbda52dee561fbdf3745893feea06dbf30d15d9e1b436e11e0b6ec969ce9d6c3a5a0d46cce5abd8d0410b4a0990b1593c5ecb7649a86b0260955b93327261af64523a02865213816fc24c65f1c1d5105d1f9e306b17251e0df1c9d7e27aaa53854cd145cba5264ad07778628bf49c12e630f0f787296096acd96aba44674389093280458186407b60dc73479f921f8ec3868cbda361f2040f8ecad66bd0ce1c3fd445e91aaf346dae0ffd4c145554c0cc208853ec0d53855d1787948a7a0799a131558872aa5dd251ee1190592a7bc5bca5a3bc19e5dfe399c6868ca8e1ef22d66d448a162b0031ca5aeb8958c348579768e4866b511992eb1125d2830cca5d216bf671b137d8decc6a110dd4fa51c94d47121b103d960dc69fb132b2a7ddf005f49f9d958b35ba924e823d8b9977b2dec538536bcafa5011b762c2402b6b38c7fc9f3f9ddaebd5d15354780a7e7bbcefc350e65253e99876580535d1e4546badcb5dd9f0ef58e94518d0a54045a841b51aac529826cfb8359d505a3fd899ccb2dd419a487a4fccbb91540e6e1c5688f30e75256201601c91ca09061ad9fd094816f5d44edb6bbd52822343f80482b8d5324bfe163c28afeb560449ee6677ba9f040554967f9a181c48c46d7ee061d35c1884b41674bbeec46a285d2c46e6fa86388f9da562ed77144a2b23d37470cc1d42a856801af07fe16f19683a2ae041238020a9acc41fa71ef2ac8a9c09aeb6aa871787e6d2a0cfbe60afb70d63e9f69f7e590a7e221fe970ae692a8dea49f38baed0c20ac9313abf4bb2109a23c68abc18b013ce839d0d7fa6becc587dea4175f3a213c5e9aac38e0083b7f14b4d21054738286fcf92653b13f8c34436da21ba8af801ac706a5d3a4a2c41c2277313db696fe2cf92a17a84590b8e03a5d4fa12d153f6c1259bcecbc6001fa969aa37c2de5f2e2091c597bcb4344483e54399e602ada476c6d2095f3ea8a4db140fb30755ac8a3f5c08cb6a5c5322d528471d6e9b79ec4e63b8120623761e37bd74c06feb69bef53cfa648eb19097ad8f5626da16a9be4aaf3762e392b9fc39b8011ae55df0c4dc967223e6b628ded2442448251291f063ba056febe8e946661ef45d1e510284b69fa1c82803d7992f9ed310fb9bb575d2484c8c18ba76545c4c9312075627118224d8c1ea6d3365782e22e1ba09fcda39ee258760ed4f45c9bc4110a57ed705caf3f5f6f1016dd2fd86f95f1dc6d95b7fe61db375c9fcb21d2066494294a3137ee69b8058dce73315cbecf836f1019e19bafa9e0b2efedbf67a84fa0bf61da343de72ea048c81630614b81f2eb1faae9e95bbfdb666bda0862d20139a1c9f6d1cf88073b29fca5a399495ad858474709fb9971005d19eda6c93638b11fdf8476f25dc4c99a10b07fb51da71173f49b282bb0ed2d0a57d711cf7e4a6651432bf30fca27ef9dba84bb750c2c74dd82ed83149945ad7e2eaec367ae7ce08d4cdab7f5b175366e9d469b3a0c6b924aabfb887e737b5139d84646eb2cdb43874f15627406b58107f8c9fe48c3ebde525be880b8f0707d111b273df17e941f0fd8a30310d8afdfa24c6f9cf48f9fa3109ae950b113cf78d85d3712667f08521884f0d92c4a6dc4dabf4ae5c9ffcfcd14413e2c99894cf8df959e9b7fc08f4a583939fbda328b58bb1c45ba60e805ddc87ac446fa56a9fcef6d50ca91dfd2a95d35e0b2abd8b1747b1c74786133d7766e1912582c2e52bd94fb52ca7e555cb254b7b859ed95624fdecd401c5f48d2f0301d3ba7e115c1214ce755ac7f6f5694461a45db1c9ce3be234e19691f2ba559934f5f086ebff3497c3a1e3bdcbd660762f94223441be7a297737baa4bde68f8a2890c6ebea4b48ed154eb72d172adc93cecbb19438de0f20199e8d651583f1eaa69f97a5a3154f438bf8143c736618e380edbd982f20056c5bf4bf3a45d2c0ad7af96813c7a63a00c63fed8b3fde37edbdebf58986aae808ac11130572b090f5c00d832b210dc39a6f3841eb6fc73867c75c7e49086eda956e0466af372aa2fd505b50b72dadce232bbc5474bf887b20cdfe99fa2be9e551caaeafffcad0f8a74f57b98e5809bff8631484f27eec7fd8982bd7ac390e2e26358a8fa1563b921c58971b5444395b4083ea5bb3b7983c33706293add334a816778d52eb74b561f1e6b7a9da43fba235c5fd83092c36faf77948e19dacdd3704f9143cdb46fee5cca6f6b09dd4a4142a7341221ad46bc4d5b17bf30cf0864e028b83070a9a07cf3ba32cd3016c34a43de23269e6d9a7d14351091cc2596478e7c74ab8d07dd7b2041d24987d87c5be57aeabdd5d768adcc0d061132063080f39b3413412b63508649322c6891ff074d3d5dbc540a46b65fbdd3eb73461ac1b5f42348f8306eba9e55223b8c02f5aef9e8dee438d6f22913f52be5711aada426c6114cf84530ad08fc2d054bc96807848befd83b36c1d9a690272cd5b55bbe05d9ca1aba0246bdd4dbbe2be5089117aa94e1454e96beaec9a77f190ea0cf667b4b99131004ccdb67f65167e7a9f4936cc3c14c68554cecba307690c6781cd9809f2870eae044069ad6cdfcd88abdb26a1f9943276a10b1aaefb081df75bb296a412464dff21196355af8a71594f1a445edad6fb974b7438cebe07903f87a284a2493d1a24531c1c54a29723e084ffbac5efc46dad4ab73520462ed0633940f598201c3cf3ebf8b448af305f736a1734b8eda23a9b8316add2145f249fc9d30e371029634657d306275b89442c4b8761f761ee65e39342276e24148412c997d1d87c1a837fe4cd2bdc8dccd836e13be257717546e8677ccda466c51b8820708a03fe9377e046d594586387d1c09e495387d9a22ce321dade3f4ade79967025da89cb8894337f512dbf7106283c0ebcb95cc1e0b8f67c603d250231c929a5d78ce6d48eaad9c444f7a3ce6fa029a649a334742fabbabffc7e65aeba50090ecc86687033a7198ba251b2682d5117f5edeb44da5dfcc5251f68f8dc004b5d24708f3a3515e572671341d0afcfbc685693e9f400e83374856d9e17a4bf53c7f430004d74a00adf4838697ef7719939f51409079cca7b221c37857aa4c86464ee9a92baec36c121ec5b8e3b689c3d3dfe5d9088ee5d1eb27f8a21674afa09c353c5c93e36d870fc03569862b16f72a29ffd96ddfe8c2375b39c646e8f1183d57bbc20168f0e39abe51adf297dbd2702c487d41a7632b1a152b39341862755a6cfe5a12e32e7cdee335451e9ec8a3191557a382a0cbf698a1ff4bc72cdcb2bdae9164ad78bd826a834e05fa048fc70c32c78bafac09a8f0733873de359e4ef3e7bc933c127d2dcc74109f3791f2af3570195f17fcf13da9a9518b9e3b7386362ef988d1c515e2c3317897fb39853de7d450faf98f194e525a6cccfa24aa0628ed1ae3235f4e5d0ab9a1ca76240f2a8fe09f6591fa79a5b72747871a7c16c664fe1cede29bc00b0cf2928466f9ebbc66df939f5d24c66583a615f92d829035a205560dda8b8aa9e234cf024ec01deb3dec862da9fddc388d4fb1eb72aa47f59d734ee92298ed5af6bffe293dc329e297a331a68a0949b786e410b1b497e088581d39f8c533806c884359cf20919a5bf472f54024d95e744accdb1d38a60e12805bb75e25f19bbc4d6240b1a173211b8a21b440cc0fa1e6a4504ac43073fda182aac8cee655a5b65c813a954f68e3f8b3c2db55aba52fd3023a99e51b1c87299b7486278d560edabe746cacfc3323028e8680e1f4597d080121d01a82850cc40b2f17d71ce5fe16055aa83c973334deea86cace87997d39b7fcfad29e53214917487ff3b7be089430f41c79b6f9df504f9f2b01efc147e1429bcbd76c26b6aceaedb4e3415d96474858a73d234cd846bd173d98f3f640779f7a6076f155844a6ad4864afaeda4ae60f252c01030b130fe2fb836cfcda32298fbf8d1f84c8fa1d95e6ebb2ff8ccac87177a90d432fc48be20545f316f510171d0cf68329f15c44806b6fae78135fc09673d9aa428689ad422a561555e236ff1e42d83a0153daaf47426c25a956322e66b119d4ad6ad8bb4d141c6a5ed09e3eac1d3fdf35016a00495e1e21125b3e35dea196a3fb93086518f459f26ff7ebe7b122f06a0f6f6127c6461a6daf8f31eb2eb7ebaef7e737ff5d96a47a343843aaa3ff96572a721e8be344ecbb4dbb64783860d4b098c4e8a673defbc0a1f7f2cedb4fa0cef24154e70bc6bacff012dae62f17e6e5c83d0c90a0c38ecd037f7922b2b856a2a15ad4c5c1cdc12c750f785126938c88b43dc7146355f582c6ef7dc842f43f56f1a40126191a3767d525e1775707af18caa9b76ad622a98adc094a6ff7698fc21a8ba268b974928b02a33f28d6819d05c7ad7742e25c60578ac9a8afe9ca11a7340f804a54e0a124e0d1a1b61c50cc32f00cb4da12822b7cdd52d26446786c813c1b13025ebc3526edf1382f883b6cee92f456127e08e421b5c8250694f8c06f569ba5158e7ed56ab9e20a60703c7bc717887ebcef8d2ceba15ec708a13118b6d44b4ae132e963a5279eb4340d0fd140a7e8e48be1cc90c024e24ee0b02fe9039ead21956f8c2bea8b03cf84d8ffa384e9ae146c3a6aad6605f79537d9990e2c1782acdc9610713f0fcc9ab9460896d28cd18afa66b1694c16df6148f94ffb215d9ac784231ebc5bdeeecaf6ef26c0959a1891b058ef2656123ec19538cf29a5f22fe5169dc240ac60cfcdc55048aa874678fdc6d6a4336728a495eec1ff5b6c2c45d61c0dc888aad15c08d116e2cb1a6074952b0b0c3c02d4ab454d79af1af5aa5b565cf595a34410c740f8968b0b3e126ee387c48f0245383807441f533eecb7fde43075c92c62fbd279e24dc27d583b66717263f00d50578cee42b0ac525a0310c2ed6653722ac9b715e234034f36e7de93527b6e909349e810568b0e5f5ce0a18c98d6c3f92238b7b943ea813a7a7d7c2c554c10d0d060f7935364385fbfc8f7949bc99edfd1e071df40259e78000552e6e1adc8d3befb4a9d08cc2bd9c1c7a4d028261a2f5b97fe3afc4dca81725eb6aa820959e5feab8a75974996ba683b288290a95b18fa355230e10e7d446eb4db6a7af1cc6fee75c92f47544f79a0bb8287b65826ad874b4c07fdd5c4d09acc209d47ecdf5d2b18f62bf4a66d80facd1e1b750401b4f0657ab7fbc51cc44b4807ff32d0f42270f2dd60036f3862786994b33e8d4050636e322612ce5f8b064769aa5604629d02a570f6870f62ea0674414cb5f0c147efe92e7f852843da4651c0616b116c37062cf71c01407dc52e318ced672d8c591c466c27466c603a5245427df7a1f045685085f704cd134bb22e00c1df9f063ece9c3d25bc759e8ea8dd201eb7176c477a62a3ec53af1621221c84ea7dd411d1e4351e8c4085828e3d577e928f90df56d3d766c174d58a53d543f68c3516ae6da884639b995e80c058ebbaf0ae4d92727f60bdc7be8ff9502e1625cd0bc0c3ee9a48fbb6ba3fef20c9db30b8e3da1c3bd005a07bee1e626b195298c63e88123bc9fbe98cbb218e99a9cbf5a2003dfc689b2d4ca2fd25724d277142fbd6add589487ebed460abd75d5b046ff35401c9d1b965db66bee0e18d14ffc029acac31a54492870a8a392b67baa291f84e7d3347626a7617630a0d1bae8d385831baba755893d46bf0f1af7e6a4b4dfa0a956e30dea3dc57b3d4649c7df463f0323864ce18cb028e81620439b208b0f03b8fc9afd6384354efdcd900fe7635fdbe0eec90dd989096e2ebcc15193133d7fb3671f16bbd562d3daa6a09bd661b1a3bd855f61c83695c128129caa211e373096884f5c9e69776368d2be0a61f1d9cc7cced85547153fb0f0240b3f5d1d9bff623d98071b0a8927bac53f9914d5d642eb840234eea4cca4ab25d16cf1f04dc3eb329dd090c2de081d87656c2e3296971fdda17f8b5380cd1300feb0706a25cffdc8d238beb1468d2c7a6fbc5898f2974d0692d8fb1d3c84808ecf811c51834e5011c2ebdea20572ebcd250890cb80dcd859c752ef47e1223286eec446dd129c4fb89f3812782d557d35167f90068be9e886136648fe266a42a011402c92be1ec4050f4306e8b9c94a0b403a044e483fd6bca1cbe240c392cef1cdcc2a7959ba932260bf76a0af6a07884b7b70310fc814ada13960606855b81fb6e1ccf062d3bed282334da89205243235073af72b7e84122f32915ffdc3856afbc82ae7e22461f55cdd783e9bc8bcf838accfeb67bbf6b2935fc1c81eec74445f1e0e43adfd482d027267fa9024c6f9161fdc7b7e083a43d426aa68c6eff19098853025925625a87aeca36e123384f23fb8a2c9d2323fe9f24b119cdd7dcf5924003a3470590be2c3ab21521efe637eb5b341bb5e76644755d962218776c12e3fbf2363ed35ce7fff9848759a0edbaa1e2ad69c0cfffb069cdcc42d2dcdbd59f8a4002acaa16460ec4b48d49f9899a23ee110a17c66f84dbeab2d4129b5e439c80330881220257de3def334ba3028a38051152fd9d4fcfd817c71df9eaefffb31a810cee289890ad6f3a1408fb7be0d82e4f3eb8f068aa00bfa2311a97bddd8733bc52354d391035a298d6197c1bbc5bb51e518ede7ea4c8e1c48f19d4514f04b219f5654b43333642765c427e5cd26365eca031aa18b90d89a4bfd5fc19d8315df4ca1e157e20a20d27adcf79c3bcce0a1fc8f97baa762cc1b0ee5cec664cfcaf9343446f4556173dad507fc336c8b3a20255d37fdec3f1373241c818c509a5f4ab1ef2a178b63b2032fd9752e6d5d371f4f5354bbeda4892398e206cb0b708723837c8dfa8520943da126d9065ffde5cedf4c3046ac854a006df54648d212bdf8033b4e428cb9ccc3fbad5f8d94e1e706e5df4197731b9e0c5b28ac0a0a6a6dfc1e5497e9d146c0a8721c31dda7ceef18c389858f175806e4441080e5e71b4959cacf89ec3f41029844f29e5f118713f15287ec69a329193992e0616eb1b626fc644d6e3aa0acdae7559544a2da76cef9454e5ca11fa6a756d90cbc535e21dc81adddd2a29696d1c6f67b97f11fe310cc0dc1687b2164c83a19ef49cdb6bd76e2c55306f3a8ebc25799233afc703e8f67c8f93a1c4b8f1fc673a29b760f0b4e0e5ca4dc907078c53a0d76f4fcbec86a64b0d4a835111b5533206c27d0fb316785e0b85b00e3dbe9aada02fcd6129fb8c5ba2bd06fea8918e570e27efd3ae848405fc265cf64ff4ee309eb7530e34d9556a321f3e39359cd3d63727aa662d08fa3f82528aa234734a7b09ba49a3612de7ad08f8478beb5216a68b60b288230e2212e63749d9ab3cf9003632528da0e7562957c8dc273c8e295ce9c09004d229f0eb3f58ad7127a098d6979f87d3f0ce6887edd7deee56b7224bbef1f3a1f7f8ce1398e8d873f5e3329c049be0f94e29d6202347fa06a65c8a18454abc2e97ca1a3711d6742cfa9bd4fa54b071845536d85451f2c9af8271c4d6a113e5a147611441bb014395249ab66f9c673eaebd7003cfd54b30aea67ef54a604d74372d74e3e71ee5deede0d0f4048106a546d0bfa052ea1fcf84049c51aa0454bf972dac0aa557215cc88d92d81f14fe80ac72231ba7375510233c56a1935ba576957a1a5fc099f1f11744c29e99c62d42f0781c44e07bb7ee88a4a8fece7659ad85d00c81389745e85d0ecef23d726a442a118db81918b631e38573450e1e464a80e8d28f0b5d794836d056a4f4c940bfba305b550dbf679a1756f3b33e9aec48006662d238f49f5c27199d4810cae347457c8fe2d0a7d3ce797dce0a44eb8ac552302b81f48c1ec43aa57772f98cbdba5047e58d1e234880c9fc4579ada08b37639cd2b753457bc29e0f2dcb82e3d1fe5a002c52966c34fefb0f7d91fe3b3899144df2a4fa173914c377e87bb2900c9e6b2077051b5165ff23d11ca94e6df7a9b257af788ea962e09e6e8b3080644fda2b9ef3ae8c85805aa36e65de7bb02ab2166bc3d1aabce1c69b3a02ca23f8c12d27d3aa4eecbd156799a9179eedaab2d7497bf1ec7a02be0bb22ca8e207d6ec06872053d0b4465e21a470601eb0f20a1e6d72cc122905d9cf1228e3b924fd3c5d1de8a3668ceb172f98a8019220574e789ef724e1fb4df64250156289e29043259933f728fc6734960d7149ab35f7e2cd0a61df9ad1f0fc37c9ec51410fd980500dd1d2c6ffb4e932892f30ac6aeaee017b6c829d08e6ca43fa73a0fe6f6d5af17327e6ed7e73ec6d71503f786017d2c7833dacdc61698c066b24cb3ac0717ec746c7fc1942c4ee75e1374bdfa3f971ebabf3359ec28dc97ae1ecfa1bf5bad891efb1a5e37f25bceaf488b8c3de3f79d923f4476b446c13132c9e31f9fdc6e9d8dca38c053f0d1c83aa2c883422781dbf420a654e5ed8dc971c521bbc13bbbe44f42e3a7341dae4d5f859de12f3840f58f3096d4cadfac4a696dc84174308a1ffebb9882e8d19f2c83f5236732b7397169150edac924f1b94901aa6103e5ce79cf8a3fb5b0612a93288f2c4834863d4b196cad9113e903660bb43a54e74ce2af3ff5ed03069ecc426d545d8535be1768598d755a45eefa6a7cf645a5480a6ebf438b19352763536f448f91f8481735912eb180ff9eafa1081bd6a84478f94ba5cab2530b33ea62fe39fce18a16182bbe4aeccde007917a937bccef68bffab87c49399c7d1e9281e086323ec4f7581cc7847046f529b6a7759633f1022162d1f17d4d58b504355dcd119dce7e0ab4958f2a4b709cf8a667c70dac6af625d973a22fee6ec17fc6ae099f55f7aac2a663384a2869c7fe9d0bdb4fa4b3d6f3410232de9dcaadac881bc8cbf0f72f00350315822e4221eeadbbe3539706acd95059bad71fb057eaab7fcf5493983ee6d9c86c226124139eee8976fe73b00e8aab6a9a9efa8956b8de17bd18291e3158499251afa893a545b2617c96f49927c71ef1be4968f14c949970c0bdbc158db4c53aa9015cbda23fd3ed68f398f74cc87372d7c1455543d5bd07f647f295246238c01d7ac19a423528128bebaa4826f6c064d5f412ada53288aaaefd4238246fa074081fec558c55885c473d675886dc285ba35ea32175323de0e96e4f79098309bdd0dcffb0646a458deb54ff5f30d754107c1d62233512bc0f24988123272260eeb551cdc3d4d05fd3ada3a527eeede10dcc022b67a0dce9a4c34c4c9ab1495ad22023ae0d2ea7f2fb9713ca53fbf11d44567d6ea3ae82ae099cc191bdc724131a91ee61183638c4adadc4dbcbc77b19e594774301a26e97e26a28c9004b594a4ebfabfe5d791292424f08bf3675806983969a9d1dd834ce670d596bf7becef79031eadf0de01423709f6d611fc5f78d22a7a15dae2e6beb4945cf5f78e25f50fa017fe40d4b7a21398a807fb7e3f73d942ddd37e6276d419996fdc3ca328fd034124d9e4d312d6a285a42957e720388e3798dcfb3a8947fd3adc177e89820cb7ced11c62338105bf629ce1e0a6711beb5e8ad2f5f4b19483faafc896d37f5451e35e355c1007d4d605e4d6c249827d37d1e9c13a4e65a58560615db56a7696d7bb0ef2ced5fd654367f85eb4d59541b2a10a6b45cb9d07f559fd89263bfb017646f8dfaedc15fbd34bd61c85787542df6c597b81dcd5f8b60925c1f6c7948034450a7f0b72d615a10e81df84970f0928b60779e20a283032f6821b72a856a319af4fcf8f432f33dc21316adbedee609cb7575028d23ae63ad4e7590bdc3d338c8acd2da2bd8aa29c1804c02828fc4b2d3a8fb8eebb248c60652b2394fa770a4c4a973c84b1574662ac692eb35903d51fa689db9ecf7df2042b746e8e12c070c5d31a2b7d7cef3e0673662eec5716d975edd75a7f6a2abc97f9dc2ac7dfc1e569fbed41951671e8b501fb3425760bff747063815fe3456d81df93fbf65486411564b960a1bf02c9b2ddfe82a310f0798229bb1a2b741e08af2ce7ba324c667928b3e76b91a55fc138bf1b9369a0648856afcd08f53f1a45492756f510cb84a246f4b79d6822a8efa4d787ae0de1136aad03b23a86e8ed010645ea371c4d6ee97167dfe621d9a6928bdf23725b0ab2de0ec30832ca9a509c77a998847ecf65ce216f5490aecf1e1eba74ed7523a5e9467cf7d719391e2669f0acf2aeda27002563eb420fa827753ef12d1f7a5d58f2cd1733999e7a4af1794a01defdefc87c1f375897dcfa2a6e8f2533f1c9126bb407162b2c9e1e073e416fe8276831c7b943bfeea871e078a3d254255220b737a311a3e0e2106d0f47109395a11336f462622d0988d80918f8887796bed10d18b4a8e2ee77e1583f58ddd1885cdd06f482fd133b54ef13139672fdac6a5aef6a123dff7a37d16e0a3a81bbfe2bebb4bee8cf531e8069e5020e5519f9308dd969e020a4154ff91c52218021068bbe63e02ffe60eeb1a8564d35c52b568dcf7d4e04ae18a8053a6b9388892db471b4236c90bbd48346599e6bd28d5758b6285bb4418b65df0a9a1fe99416ca0adeae02004d73fd50cb0dc0c371156089a03860d876cda6b1e89c8d254235a3c9eddf39701a6611eb955b9f4865df1adbc5b1465e78444952a181a7b60507e4202874a1c9e8e354d41764918dec2524ba6fe9d678789af026615ebadce4aa54f94a9572a877ab689ff8fb4b7cc09ad5864196d1076e28b43f428d7240a4f1992c7b20dc74a42b597459764e081db06ba303837896fff01f604a8a820a191d9dbbfba1a2ac69d165db3713ad73ae62d06b362598dfb1cc64b86a78e29fc695658c3f4b0c9f46b16746bbad32809c01785fbd54ccfc6dbb7234695a7c3df4434ffb4a14a37e5eee29a104f9a6dd6ebba55608ae491ea930292f8e3cacd69902e143c8d83ef3ff98ef6dc723dead21c24fa0e13931b7b4759cf68d16cce38f189e6c43412027908a73adfdd820fd2f713b882ffb201a9ef1417294e229d8a2e422ae862bc5b6bccd26dc0af50723f1104df51bd51056372a6bd03949cea5479e53435e1efcfe08bfe720cca7d6e8425f0f466f525dfdb4c2510872254b1ee7ab0430d972468daff1283cc18bec1614e09c7f01a0aa281e749397bcd99a51355814ec80f7d8f7236099bb04d907ead0b0c15f7f150bdb13bcbab26ced5e5c167986250e978e2fb456a233920649b07ad04de273f226640d621ef2d234e3441622f38f266b2ff611dc24a6eeb2721564010d28e8ce34e71eee28ef096be151bdc96a197dccef56525ea44cdb2e50d51e347bc24a7ed1d066bac36558872f274b95a8835c07411ed2d2b8bf1ed5478669c236ddc06ba3e4f58ae83d502d94d1e71a147ac86530fd299410ed22e1c24eda0a3f0e9b68169c5b90822d2a9821874d3e74b718aa755eaad932641c4a29840c6938b5deaa875069cae11d406ac86bfb50f7576263783da2ce6f9247a4954cd0c632cd74f39a40016d8eafad5e18305392e05584746f95a4bdc36b12d01fba668504c78821b46721a1ac0345771b66634ee5a98de2e81cde0ff187f67c77583f6e5f926ac4d64b74ec494f090bddbe3cdd400e2b88cf81aa48f235c005421691e5ce19e23f7f1ceef407f1191b0dbd74f3c1c59eafa76a4e7dc77a278fe61f3a0dbea0c85ad3863605f21ac5f53b2f987206b033bd889fe9aba6918c1032a4ce05762554231c0168adfe1a473bfdb13dd3aac71c16f80419cf8b4b2744073af86206b686792b1837cd7225684749eea670afa8f955532b191bf48f3146b702cd798329a75903354b79ff0c1140a051d59b4b5802e97f34cb49dadb524524596e251c04b4da6d9ce2f94908cee8627125729919c9d4a4cf034dc366c83011241ccaf831c07b9fa49579dd68ae47ac0b6cacb5bbaef8831031827a09692e024f321e93d434acf5d92086d24450a48ac5265097f91f4840af7385dd3a7db91c3eaac569bf984770693f77f4137c8b8ccfe8199207a775eff5fc6a22f3d18462f44dbdd0a9d4578967a36c2343a0bc2957f5a39bec495ec9f11fb3e3f9c8ea457fe6b046ff59e39d16417cda3c76d455274e0e76b4c031c5618f1907b574c346ccd31c1f07c17da9cdd634f8aa804c9ddeb3d3452a10e85566fdd9d35285a18170c506949f7e49525669dd2478d905856fb2ae6107f2e56c1e1f95354fd31627ced9b8375670296b1e22189b9e43badddbcda4cf9298b808549a5ede25c7b0f85574d66a4b79e9555a30d9043ac19e728b31a783fb7cb88176c096b1074548d06d92a7b235bb89df699d26af6cef5de5df06dabc3f3746b8eefe33fa830fcc5743f41116971556579e348033ce6ba3e8dce3dcfeb4c31ebf9b601792f3013d02787f2d8ae8abb6f4572cde83ece0fa9dca37c3d3d7d95fb935152c4eee7ba22ca5a40e86c29c60beab3a82a6c86d8efccab40d19d10a8d893a2321c97c866dc6f97621e00ec0e0db7ca0f698071a3d524e2b1ad87f3b846d52d1797372b40275a80ce11ae87e28e283d930390aa039ff0fe1842e3aa714fbe09d8f5cd6e236979941abafee9fc8710cc09020b89c38ae9587396b09f01224d76f2fb539b6c7d4ee0f04ffb5e230e7538bf61081b4d21d3aa3f9736ef35c897fe5b2eda88737b95e1a9295f04a68e61570a7ba4adefb2413852fe2e9c0403c65ebe64f72f4e340c6e0e6c0ee968f0709e646c13db9b94117bbdcfd73ff79062f8349559bf468d01ee6879812fd3728e4199b99f719866126b3b5666d88fd1d8838523c746b45bf9408d7950d96312d5808558fb0525736f4c582b332fab9dcb8d303089886442c6165e7779726deb40ebdb14d23d4fe934eb945fe5553087ce882d7255774dd3ab344a38a4e43acbb7273817ce2b73031c1610d785427f7bdc3867ff0d99225c2218ae19c62cdfb97ed5595e68fe63ada3b040b673896fc21fb4609fd02123b8d2317daef2373b47cbb8935d8fc13c316c5d45cdeb253f0ec4e8fed2c795bfb4f8ada4a1ff43dbefed5c9d59c64b7e6f57670ff607956550e07b96f0c956c0f85d4c99745e55518bae2fe386d8f5bb7a5b1595edc52fa0b4cda3f43cf3099e493967b90940a3425230050d4e3a72521e57b656a2b4c88e47fd6685ad822cbdb3aafcb5bff4a9c517ea0d96ee2540ef345a6b6a96d0068713562bd7bbcf087e81d66ba43a131b7439ad18a374159c26ed03d78be27429e60a23525cdfa7734cca7d6779a7ffa17326113d8849c54957883ce2cd277712e5f6c9cc0589846b854a37f0892b7b7c89e7300f178e07e9814eb29074b99db15318134f1ccee105451e0937cf789e49ac931c6cdb0dfc417feb0ed3150dba59a2ecbe2257f315bcb23045b8c8117f9d06eab25e72e41035c1ae2457ee619e0faa65b413cd1a3058c8b8ae182c40d6619cbb035972bf1e87d29dfc18195dc0cd8ab2de5432441ba7822990e8d0d4966641b0a80f8e220ead2bbe6bfda6c38d897a7142d8f45377d46509bade2906252c0991442685d86204bd6dadb5dcc24976cf7c4ffb95710559157b4db81310069bfbd4902e890961d7a3853746f80ecfd34592c29a8fe32ac74f4101259b53d519ef40b066f79fa903609572786825b176f1397d562eb182b6089179277d465de0213597fde01cc22c22edce4941230a84e6528050187adf06db05d6876172a8d312b8565121d8b8469c9b57c991b234c579481ef0695f366d37ad9872dfbdde93b018b806facbb86561aaabc56633c008af1cf36ae23bf593562fa7671c9ce64f4232f1b6023196f52e3161762c070ccaddc7908545be8b04b2cadc27bb43cbe57f41e6a66eba5c6c1db494dbca034175b9b9d1294de9974a91441cfa91b2613fdb57ea6208cb67f3829b3099d52af540e8995db2a90a3ecb768015ee31d3c79817070e1130043b4b0e02ed83199774cdd66c44c2a1de5bd0899b17441d2dc0ac6c19bab2214c7965529d04fa15888a7e48b565504c578903920da9298913e42eefce5f8945eac47d6ef6d54caa2225130b7a80f0ed45164f7ef54b86b6744695b9735191281ef7680c0d6e2dba6dfb032221fa7d4f03d1d619f93edd433d5b6d619e0fa364a0646774070d419d21c77afa0c95d3191b7664bc23c6c2e2dfcd95949d2971246f3cf41bae1c6fab8062153e32f6056206558460318ea38d5fd41ba261d22aafe9f093862b3aebd60c90b2f532aa0c5b31769ca92afc7fbfb9048747a4a8b7c83fbefa1ab7b55254942e5571b6e0d1cb16e90161d18f3835d7650172f5b4bb9bd10b53e25cffa220c396be622931ee291a931cf64a294ad9bc1140aa5098b5a5d7509723bf4bfe1518aff87d54895aa07a9210264f29c496f4536163f5e112ee57e2eeab97585175a5ca56ccc82d0350f4e4ca27aaca5f83bdac7042b7fdb7156a4116a8ec2debf525e6d11dac10c304df6856d763f2936f2c30bdb82ce690c01a70fe69f932177db784d019699ccfa101429600381fe042e5d2879b89b0ffc4e091454623f7204f9d456f43ea21524445b565cbd868b8eab1f17e381e2d90b012ed86efe6beea1ccdd5fc4c9735c35b182db83b8f07d393a7878aaaa437a5ad6c4a80353173bd9d3ab79ce068cb1c55fb97e54de870f71a89813dc22141e41d9af2e6fe539c6ccfdfef69910f3a1df2e5bf809ae9c0195e4c4e1f24ac3d2e617508d886bb543b0f03264c06f48eb239ceb39b1e13fdbf03aa7886992153d2355dd66efeeb7498d644fae40da15a88fb9504db550e5715c5191c8e5a014245ff141b6be5f2bdcd20ab67469cbf6cba5dd862bc68b2e42db324e95e05aa467ad97be2f981b580cd9cdc9881b7c3e7a109ed1cad3e832b9aca8712cc2f4be4f34f70bc47e5662e3f28c9eda08accc3a230c82e5c87163d733c6fc53778c11c80baafedc52680a118a780edc570ac971b7876d5a656a10abf4c6edad611ea90ec55319fff52492f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
