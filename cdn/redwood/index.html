<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aabebb6c01f2fc02949fbe34b4952fb7ffe930350ebdbad84915feefe64f9039130ca014ced58966606d4ce265af1f45b100288005c109a6772a23bbeb9972b5b10f54e9148aaa6d89694be8080e32b43a69f05265515034d5d331f9d457a7fe8b90229cf7debaac042250dcb85afe97257ad152752ccc278bc9791a048fbdc04f63e6b74ffacbbcb5e73389e9597574c671c66e7bd79b2463660d518dd4cabd66d8821a0d1f214f0ed91e5f758309ce0dcabc5385922d20e795e5613117c4a4a847c52c81cd52918c5d66b1da2b989c9e44a879566c45cd75c95a1e44d275ef947e42dc225722d4bb8fce36587ea142e07a1cab6fded67c3d211e4f9b0ba892f98debc044b953b4d6376b14bc2080393b923f648570acedea425d1743a2b86d9ae71f47d20a365d600ad236407ca26f5f60671d9d7725dbb5068ef8a1f1d16a5b95dd81c16784ae77d68de2f929af2de4dac32ce5860145330be50c1a55768fc58ca8d086052ed3e2e817deb7e82e4adcb1e1e60d56318888a4076fdb2af7165b6a2aa3c3928e334dffc8d1af46f145e23108079e565715857bc711c524de2373794245060ef050411b89a604488322408c6baaa4d76ac03fbf3a0f295dd190ce3a6c40fdc1d69df23a0f12e46391289a5a654d2133a9ea47c8b8faa69b70f029e9d5dfd9f74687efef68230e515cf63f58c7822e1b0b11fd42bd6a4bb59a82faacae5b6f38fab4b3a88c94067d6c52074a20df2c995d1670b7488c1ded539c931296ec12999c8e0d45adc8494c6b7717091478e7668e125650433bbcde6627bcd6aef6708e1c93f5c875e366418b1690abbd157e68e306646bb1a897288027d89745aee470f839fe8019e88a9f700cfa3228a531e5a4d2b2318e9f732ea703a74f94710422e6664d12ad417143adb924f00a0807ae10c27b7ec9318816f2d48c19dec2b48ba84775078f22a0db0cc00105d0891764857baf9e77fc8730715afa911c16c3d046f0d2a8bd30f6a72c994b9ab037dc738bd8006caee8574e4680a49fc54be8f8ce690226acc41f132bfc6c672fdc2f00867da01fafe4b9922ae4621959d670c7e2be857f0fa96d573ea2af553128349d5fd349d39363701a007926db9f16c51b394070718d75ca1a24259d268f52b7fa2f4cabf83d1f6d585218079f1a669a2590aafaa844e60738a6b9ae5dd55bde6a9b7f64d0d3df22e17e1b0a7acb94cd2d436e11dd852cfba0daf981197615c9cd252866ad565db9c82d1faa091a238d57f95ac0c7a9f709610bc1cc03062d880fcf4ad5ec7e8ed3731a7f7c25162e51eb1eccdb24657c673eb29dcfc3d6eed880744bbe1ac9ee867a4ceec0c85e6c89b20ce2e0a17c3ab5f1b5db621882810ae13129b75f1b3e8f8a399ae72611c578508c2a9a5a697dc1988bfa8fd9d31aedd17e0a67754a59ea0230e68fd8c397b6dc0bdbf7e61d5e533b0ff1005ac86ea7fc670091a49948400d68e7f025d2dcf05421c1b0d8e4dd14ec3f576cb4a7f614a0d0d0eab177825afa43e96495a49eb984e845839a4221090364d445b5755b532f6a65073557a2171c0fcbe77218f33ae3713d0d978cb8c2428b8963d1c12f87b17a58ed563173a17114d674a261be3b2d0d6a649442666288a06c146cc9e26a2fa9982d6fef5780e5a0cac39e21b6973cbae7b0dc0a9f83ead7003e98af224dd241651a11984f6b26eea43585e172bba9ece255ce380826779da9a262486155f3b9aca5826ca8e1c21efa31136cb94844fde3b1c8cc0657128491c851014208f30c6f0f8a590c16fa6efe89790aea63587cc01b91cded519d475b29cae74561b92de6821ffae30c73e43867fe26aa63774f02946be07663c33969c17bc6f4269771047c8e45ca367793436b99778becaa198cb4a7303f8dd587705747d072692efa9cdea5aa6b299cab85e29d94e82d84b34528d66d0e718121b783698d6de3cea3ac0eb6d37b9c916c2c07ebd32501b0e187b65996bf1b37db9486097051d91b86bbc5230220c042a7ba89da68479b08f921f3e0818bfd8ec073f3f92306328451742494959e3d299b81f86d06cdf6203ebb56db05cde4fd8e3ea0ce2b734810e2f5d76166b639ed069aacf2cd99777328a3430a650e209dac728c60f404e43a7ec2489e04745dfbd3e475ad0eb95634c6c502eaafb783fd67b0787552329f82847dc024f5101e19736b39d5e2c0899a1dac97e6003b39ca0f2ffc0a69a8b871495286afdc9ce49b55d080d572deb8deac0a05e037015f1e844acd6760ae20c9f58c982197401a27f83d06590ac6439d04fa9db079a5a6a0fb429fb2491888ff092bf7fda6d56fa019fab3711d6fd5231908ec4d04b89502b8d1328c4237ee320f012e1fcd0de8a5377447da741342d5c43a9fe0cbe48f58d15fd5a3f9e063941cd4d1f97709c699e38b39595bbbb642349df73465b5f01c2cbe5da686bbca6e1a540d1373a9d497d576f45c63a63c9307223c54b50a0a523173379153e5d64e2e431c26010fd1df1ead4358871bba63173688d040f5562b8eee272598d8682aba569c80d06d57f8fc6cf92059e1bc4f5009da0f7e5356380b9c9afd2bb965775779fe918c2dc84b89d1bbbdc0c4aac24bef8fed4a1403ef67a9260d6b6eabc6b41ef74e5edc3b44a08d28d6ecfd6ceefc913a69d57ca1fc0f93d558c8f874780b93092b2b49c85d13ede5fb4dbdf4e4e7a8312fa1804a99db6623eb3f1f62c44d3735c86713ed533dfa9ea491422ddaf98241e6c737f56bd6e6c9ca5484882fbcac996f6851814a5baf950c533aed91d431b8ca8f162faafa5756cd2ffc46890d9e1a1aea5dd2bfef206dd523692e3fa7bed3243ff5f1bca6684f12f9805c42f6cd168d589368c55773d67bfee31005651bd58b752387ffe3990736e547040f5cec918e8bff8a47c20093d4d4e818e87f955d865de6e6db8b8efea7ca5fd9f931933d691b1935ad20884740672db060b6c5d05a556441db75faab27c3ce42df313a661abd897d5b759ee696bb03fe8219dedc861c7a4dc4848cf3b557e3c5286d5df7d699056fee60d26eaf9f12e9b159d7a7f97fbe9af7a57958b661c5601dd536d947ca2f925b25a982ea05c20ad04045e1040de9e867ef050580a5ce47e23099d9995122db1081a795aac484bdea1194d9ca803b4bfc6a904cc994f30ba56d9c6d5cd28f287162992e0bc70a36f9db4617c2a2e7eb7340b50dafbae26a85c9ed0dad33039f32324c181c887985d25dbe5b92f97301328bdd9781130ea1d2b13918de488591da70224bafd295ae24ce3f79227a70b522f35f6f397233751455413c22ca1df7a251f51b0ca7a4ec70ea831be4fd8e33dea4bcdf4ba10ddeddcde306ad72a332ff0434ba84708cffd441148177cb79ca44fe5914f919e0266ddfdade1d66aa2c619059544cc80b7fae7f54edc97641ecf51ca3917081b0e4799ba1767b1a38eea5ca9c9c330e3e0a1495d4ca91ef19d2a37981a297e380bbdd59334eb6b50b042aa41061bf0007a9ef9610c000be203fe76ce0f7f65cead9732c9c8ec412ede27d1482221a719fea816c7f549eda294a539dd2ca34dc31298a06c48db0e4b5d88e72335dc693cf78b3aa5ffcd8df757784a2585494873bb95892472d3de0d1ebca1b6bacc91b29648319d268a330430e22a07e9f3b13d653ce2b2716c29bd0e89665737e4e95376774ea7b86827e8e77976a88d4a3a090ee7e3b671a013cc49828f09ba80bd4b03054343eb9abcf351604a0c6c887640cbae93513ef7f7c55d79a91c0d8e165d40f97d214dcc5b52a9c4a21f4d062bc058bf6167523cc3214b4eb6a5166307aecb8656d890b9ae11cc6766657f38709054310d1fba52d7b52ff0c573642adfc5eeecf6b248605de99c479768e6fcb46c4e3ae3ead998427606388c77585a0873d78c0ee71f1e77c5818d09facade06a44b0b00c81a611c44786d7517faecfbd81ef5041358fa5ef12257fbd51dcce2fab974ccc7fbb3318c7575d9f2dcd819aaff0fd38c5b2da1352e368e99380345b60f65adc4d6eb5ffc994c3b34f7255c0748d47c954e6fcf609bbdddbb93d3b66cafaafa3d4cd9ccc7df956013bb3ca6a64aae906affeec69d3e412913de138cefc45c1bf67e9cd85242566c4c8af730c26ce9340226df9bb5259592a3411b84fd1f4a654121b2c5c7097d060311280103314743be2f58d54196fa02fba81e4aaf6120234f2d9ab2e0803d7d1eafdeaf9362eb65426edf5668b55a7e7d0240d095688a54175fbd8369bf029d1cae160de8bbf7455428b3e691f0cdeae89230821c60e3de3d9666ed35545cce1366c61f51b6a218b84c46a5ad754e0eb2b9d003d2e273b01e76a23fb8c05c4745293306c9072cb27fd489382905ad3636324f6a0c16d8387d3394416e24dc2eee6d7570f41951a9f1a40a1ecdd74b6a5e15d5cd16edf9e60bc6ddf3b2e5491d59fa8f0b2cc3c0907a9c74c2685710a8ec413fadb79f18ab0a08b79b5c8e5ad6e9d5a79c64f25f90be89dbf3769323917322c5a7197479b1b6f1ab3c5bcfded1f68e1ab2ab62f9d8dcf0c4f047ed62ec54ecf88d8e334464cb20181c29f63f9d07aa9dfa0b65b0e3e6392aec6b26e7d06b0aaa8e29fcd7f81e62dc026a917aab66930e7d652e1b0d91f70295cc6a88ecece60193368e0130eb04006558f106a1aaea139a8b2e582b33de78121200b557b7cabe53f2e9aeb1654711b0c3fa1157ec8ae6c1320af3d52f81641d182d48e2301367a974cf9ad150cf6d8191dd5097e6083aacb3a472588937df857cd8706581ee58080876633aa2064743b3018404613dfa69cbccd0e07e72b9b8f1342cbdb27e975ad147d07071cf199d612b9c9366188e5a553a5cc524a5ecbed0412a663319c4864a93e188204334429714d6fd8098872124faf0bba405c82e49ff24dd8a0156233a89b7a0d9197af869b8f1875995a2421c790f9ebe3ddacd2901fbdfec4cc97039eafb9f6085871f96b9463000c4b964d3c5319f3bf262912945e75e753beccfbe06887610444e9c50b7eb7059fd55fea338f73d405a4f75753835df2985306b0621a49e2a7b86c46534398cd62f6a1f8d989ff9754cb7cabc19f4a6dcd0e108f67193aea3828a2bfed9b334b248905b49f982676eca42249c4d36e3f59966e0ce5f7343c616f0fd0c62a4d23bc559df0a5b6794caaed0fddcf0a29a6c1d81fc349e121306413ed34b946f6d231c08cdf3b47f43b49d6786cf47efe19605b49cb9928495b396dc3be316f598c0b7eae1464c0fffd5279eaa975ceb070aa257b43f036cac97580617c39faf22cba8d2895dd615da6e44afb2328de60f6b9b36d0290aa65e0bcc39729127ef13ed9632a4e5060f1698a9c7a173c13562b71634f1f07eb1201488d19ba782ae729cf586d75c98b240dd8b6b793ca8772b2c60efc0640a41c1069922d04fc11d48170359acf523a42b76caeb7ad5b19d5c9aef4fa68d67aaf9a51708fdf2a76956a44de502e779ac6af148cf2cbfa92826c8636e9b546205c762ce707e00cc2261a00d6c5d2a65f6f9e83d073ad999e6eee6bdd3c88c9d1412f4a1b902383fe890eec7f22d00b1573db5fa6924c7bfd1e280f0742dc1baa78fe9d90819e976a1ab0e801c3481809f2ac156e0b0d7318fcdd6b3df5223f99e9f97f50db71dd1cf3ec9097d5b1c129d2876e8d1886aaac4bc86e96fd27f923bbd337fb4f7f830d61fdd1a3f19377691501fb629b540e57f2e4e33703cf48c2ceaed3b8560079994b9b26307a6b0333b3ce5ef8eb6dc924f4564be3eb09be7e0014716ff55bb98d6fce8d136d949877fb46d7477a3ae8834341651d3d52aca626f3ba42b89f96f0e2f7bde4d0b3fa115bbd8df9ee6819d685823c2da1b91f3f3a5410b230bfebf5ccb0875eeb3e2327e2c04793cd025ba757bcf45ac75eb6072ec45220687b096f84bc2a33a34bbedabdb984ddbd520bf092dc9e7ce8b34d4d543b081a8e6128aeebc9831eba18e020acb43cf6614e5af08903ac5bfe543aa80eaaf62e51040c339290637c44d488bae287b9b267654781fa3a3570dc9e1e4e7944b68656eeb3d9167cc68f38c5aed110c82fff6cb7ab72cda8d8e006e9c070e4a5058006a828f8d7d909431051d03e02951ca03671823f9436bf3624d40a538ff1ef9e2ac64a591fdcc777a84f07b3c7fca849abce19a8a368befa4da21d51509b2c24be93e6b7143b73365fb8a29b9a326ce023529d8996afd4cf02ad07c2f8572e8234e5a313124d7a11480ce7ec34a86f217b8ba4a3f4775c3c56bd78d993ae14edcbd74c4a34ab0f05963c462231ff560070993eea8c5af569c2e87dd035bbba1d3bf9659e2520793d907104a2597dd239107d8ef7fb9531b7f9e226702d9e07f14105846ba1fdb7d675e14cc985b403c4eb2d7f7842ea6ef1fa3ae432faf9445e1fefb4c88248f3d272504aa3f94fe852737b17212165f0c036ef3d8210031c7c35525ea0eb08d78f9354d5f77a9f55bb9769011f05e4f0dea4bb1ca7b333983ad548465cb6d6185e3294341605574525324f69e325a30121d3b94eb65e939a7a2a812ef4e2457d2f63e62bb4ddd3c19f71d4a22bce2e6051d7ae73ffa28975e7e1efcf4c7c9d2d3726336ffc5109cb8961b1622c478de56fdbce9edd77fe75bbfff4996605d6bf4392914793628f067c15c5df7fb48a53dfb86924638a4932fe5c1334b6f71e1d8cf206bbfc6a7ee6541bc8934ad661b183852690c24d88943df781aaa6fa2130fdab67e485bb1d53ddaaf2ab992bf45287ecb25d0257c6843547c04fdbd2961a989ca5b31ef9e34d67aeeac77e64a0ac2690ce3428ec1cbc9c42aed754e4616039163afbcf9bbd0cf12e66ed4e210adfeda1982f65d1bdc87687e083bddca622e643f52dc32eab5b0e3e5a88a58ddff8bc40ccc5f748986f27b06ad3a58e1d89d32132480c5dad3a54398c0628698a40c431179f90dfcc4182a163407891b9711df9575655b57d2b46043655d04c66d04a74551edebb0d4a8579d116ea7c82a3a531cd3d8490e108826a276627428471621c042539cff6a29bbbc59f9f9acbcb47a628c4e69466741cbc948cfe9c994d1f2d8ff70b8321b23ec010a2b868773c69cdf560e711d49a26c891fca2189df491fc0c11065dfd833ae5a99645d469a6784232258e04c4434b8cac2301eaf52b10f5e64a114aa5a1b00f46f3d63f8193b3eaabd9eca94a1a3b309c49aabe385d0181378616a8df2c852b6312e812617f41f2653f0500306874f10f917a98b33bdc6478d10a7b10c1255d74fc9370c8e28ad71c6cc394ffb3a766c1e692b458ebe4976b1734cfff3bffe72e6cc777fae411f84602174564867ffa6d5e82c13729a0d8f906c5f930702feea827dde30d828eb1f8076e6466fec5d515e085fa87ad01688ffefd72a098dc648c4dbc7527cc056574ab1bf8aaf58f7c3a2a3ebfde6ffcc74c4dfae9bbf0fb01a21c7d8692d6df257c2fe82d7c736782c292649965f10d615c112b92a361430a0d1868388656347337d7825d149434a71e55f7a5d7915921d5d2e0f873ea71a23b99fb7eed1e65cd9f8bf43e0bb7f7dddbd14ec5f82b73af0c1a760104436bb32150b507abca9157a73dd977ca9d5f1cb344019063f5be568a7bda7dc4ce5af813b6e9c1a2b3aa37e42b87e6e1ffea605153f29e2a7edee2988e948b36fc79e27df82095b405c45eae0a93b92138da633cabf46aec8956468b88a6b7c95128abe0c985ce7d41d3aa8eedc3c6a945ee132136f6212420e5804b436bf02e02ae3c8a0e0c00b0f25d3c599f79c069464b026c4ab175ab75f01a1f48765fe6443a52e90dbcd29ea14ad586613c40f0c1411589fe94b7e41b64cfcc168ce781c16652cabec78fee1ff161759fc6a73ec1a72cd94338329981c2921f704c3e795302fb5bb28c92c56dcf8014149609f3f9d9f399a00750c7240ea8e4e96d6283212a6383e478e6f3cd272e05877ed646a6248eda55ed8fbb1e68f7b737f993e4fc3f21544c55aef1809cc0323a9211c2dfdecfc608989d607f96be2b9b3b272937827d0495ca1ad2a6e7ca2ad6f34d97d69f1af26a5e6d69d9c8035e172db675290ce13385e838f03b807b3c502e5495bbeaf45ad34949e5d7333f5c3c449965af8d6aa01d85d9638a1b13a6ef0ba30da1f69787c452bcafed7f4ccdd159804338d8cc93ec22ac5d070571a7737533738e1992f231f93a4938aec4fc6b3103d9ab436239bb644ff32242eaae26dcde39f07f0c5b6e64b0611e453bac0105d53ea9579a568cbf98128cc8cd76b29228e772110149f44e2eea0524bae13dc59ead0311c0fa7fe82bb36247513352947a51c8a6ff986895e4557470317e0bab11300f625785df8b3115c11c4ce58fbfa41a40ffc6b57f039fb2f139fbd334f25e515b500a68fc4f13d7309ecf4aeb09fa40604ac7c41a085880ef9052b655db3edb71c2809624ce635242c650b9e4f2d724a23e8f00981b4a182e6ab6dbe4dae0b473973f83e41dbba7d195d6b260319ccc4b002b3be26a7f0f0647a281ddacaf7591ceee6e408630ee54a4715b3d7f31314900fff7c20b4377e0aa6344554001c1fbc90399e1bf7402252d05ac5155c1afad7ec3a25cc9170a3c627abbaf5603ce20665156fcf7fe059e2b6c84e879cbff4b2fb09e8abd82447bde3895d54eb5c0ce4e3de38549d4fb11cdc8547f7c7f1975b20e7ac7d1f75528deb92e6c0f99b564417ec170b42d6410094eba1acd0083437da30af65a0084f1d2c8e1247833056b1a524e82f6ab4c7bccc06dfa9de21a4418dbfd00fb949ddee1da4dd5d00eacb6e872b7a16eaee7a2693b79f27549c5ae8bfc7db77ba508a6a7eb731b443221dc51e55dc0eb6a6edbb2a40c1e29d7755922e3e8e650d25926d9765d6f51661efe2e31957aaf39a19c3094050d784cff55092de7f253c03920c1e6f4f575dfece99c417b645470e24836892b990c2a1338b8d2549eeb8fda80d5b54d6b68dbb464a4d5a04d4070b0ce0088251271b8d27dad19c77f6519ab9b858aaa535cdad504cd3cae07afd95388722ee9ee55b0776b54f7a87d50567fd58cafe454cbe5c90b92b0061aae40775b6ada63f98e045d4321d7563c8029f65c75171bfa399ddb7e1331928b71de4bfebfe543aa06bcd1ffb3835efca04f07031f7303e7fd087c16a8f0460b744c88e75aa04ccf150f788d96fb358e9774959ea5ae634e3fbca93778a1b9c40f009e620d054f5682c8b041505669877948218bbde69fabc22492edc99285818abec2e244701734d0637af2319b7f1fd2f4663ca78ff97557714e2fa7ffa8f99021bbf9a8e37d52c44fbd25791a67b03769fc23612977602af966f36612f18f5bc0e5ae0a426cb80cd8cf856b161b02da9192903676745a1a57d01c2d240edf6b2d2f737848c478ceeb24e60b358ac16a352ffdb0002f4c0cd3933509e7079ea3f10fbe066171f1cc64fdc9c8dc21324b879ca5d1c7d9efb4a1be85ff0e5ae8eb1012c31f172030b769e8522d4cd737f7b3a6fe86beaae73f62a1be832077fdeffe913b9eaf5e6247446630833bd6c9e1e4058fd01f707045e9fd91fdf461d3fae5718d74a8a6e2cfb2cb67affb457648ba03a38acf0d963f9b7c0375cb940881b237d278f6b22e0cebe52146349cc8d96f58fa55a5df5e57e56a176c2ababb780f04920e01fa3de517b8b6f1759f224c33d16a20e78ae5046a779cc7c6e978bd1901f296cef49b96834927a95961c7e87495507372ac4c675ff93cc599d4c2b040e6fbc110d8c8d8cbf3880e88c1b6200832c22d4df10f1e0cee1a17c4bad1ce95d2467ced31ab9650c916f1f792d7a3149f3cd98aa555551ea54a6d739a7e4d47e958f0e714fc993ed16e7dc79414d61a5db3ca51535973d863d864820c1d259fd2e9d7715760f25abf7a051d1fe57a1bc33e5dc73273c8f9c2bfcdc9f5e0c7d7a5128afbe1928f48c084fbb96f6ebb674ca6c938e342bee2be9379451da7eb98aca10dd156b8f8dcc6104f28226f8acd837ae6bd10da5e6131012a99820aa47483cedca643b79042ecbcf00fb0f03c31f3faa90ce62aaf13fc5a790097c6a2f12bac6bd188a7a8a8f6366975d0f465a3643f39deda7c2a276c3756ab2db59f96339f902adb2c42a8c11f68ad0d9198bc6f901da7e1d853556d62e4d3454d29ef57b7ec390b9a52de4188a14bc0cf65a6f0ac24f68d8c52ac22efc443174fd2d6c682f9c9d4d4ba6b74ed478608c4b354e851515c8a6b0433bec5632a66b4e42d0b39ce27a70b740e4acd8eb9a48533751df7777d442bbb0e59349d35f7e4b96b967d2f6c10e55a0b0a518649798f24496749566bad8a55d4742b609947be02ed8e2d76acfcbe3ec5326481a388e285c29075748a395fd7da7ff55c4a4c28ca7d0e467d1b8cf150a2eb2127cad41c31afbf44192e43c8bd771c0ad5bc68525e75d5cfbd718b1564b637ad433cb699d65a230a88642066d31793908483cd143948d7a0ac33ca5f7fc7dddd554d6b6226bdba7326796ef942617d75ed1ebaf3f2b28dac3198c5b42a0bbb405b6bbddc56ed64e255d8ec1ac47cef91eb87e26a2b86eee8936489cb10a88fcda8343f0bfb39c56d8e2f4ec0fb162f9ee2bf1036ae9524610f0174a69899d213d379e761e48851d651b7d92a136ac9bafb7bc713472ca7be93616cc7310c4420efe95903a0632ba573e022e50bd042e4af58087ad9d2b17ae98f6959b00649ba5680ce1b10a3b6351dcf895cd241e96f14511388f82c11e8d6f60e90435a5feb87a8111b391a7743579140ca8551783d0b9f8085b57067a0f3fd3f6568db1e7c5eb2d1cbeb1c8ffdc12325a76f1681507e6f3f81c9b6a0a5acd0d7622265843180b521520ffed1c93c95b788871eeed51b10a49e1b051bffb631cd89491aeb97d8be61b3d4378869bb7797aaca9427f5f4c04e3ee7c4c99fa73ae85dfe54dc0b8e403505f6e63739dac5745d4bb183d77b23b639a0c68bc2da8d05c18685c302a8796647d88654d1e61e88aa7e2d6cba4f3b4797c5dd2bf414ff4d23f3e5941eca063f540a85ae4c00a1090889a6acfec9d134ab76758cfec3718acbb93939861391b3c5c98a6a99feb63673a6f82d921b617d829cba5eb92d00d6bf98d0d5ec045a6ff62af2a121dd73b99f7f12a806d1c584e5f059a5d1a60334d0e643a8df2dac4159ccbe79e64d7cafd50d019386f6deded6cca1e47175db4c22226ef37be0e8cca361420f0fdfdfe2f31cd125eaedfe424ad558aa82e9dc2d23a549f8ced1aaad4d01a309866601e476956e03da485a2e25c4882c89394c97de00541e4a5ce727c215fd9270b9f3d679932da0be4a420dfb74fb43ea40c805328f817a2d80a1347bf5809373390e818a1ca4bb189fb5cc2a77b00c7c14e0144ff2e993f096227bbace7551ef2ae4ad1014d328e0706e3151d4c17648fc555cd216d132f9e7265dc186cb14cf41294b54909adbe426c2c674b91bcd776aed4049d0422a7f70cb4f9ce239e5782c27775c2c210bcbd11e8cc3d375391f6ab4cc84229b9f4b166e12b2d7fefb39d5acb189d57ed9f080d196648dc8edf29ee3811271b92361716f7a6c5eea49f8040bacd1b61f79b3887d09045616c98f763a176a89faf46989c43e6986fca4292e8a724f26c25bbb14c62b7b2c597c6f5709d3b01b84624cb08065f7ba8ca843bdc4af29eb6b76ea90f43e29354be6a09fac65aecbb0b99d59fe586f1f63a321cff1965dcf3968562659d46a76f12dcf5b394da0de175d5ca6a0eb22148b9eb5b96035e6ece0c3060d1dcc81d888803b4c6307daa5f45a5e7b4e120d814ab349701002856e348d1924576047cea1d0242b5147cace0616304a9284d83457bf9c784fc269abec543930048826be3cad93e56303530c5bffa0b36b8baa3e74eeeb22e0f72147c3b64d9e289f9abf15970f4c047c075b6c87997d1e9e9d25c6479d52da0487c535b4ef534b7129dbbc500be1c9717ae6d6e4b2e5ab582c7f631e5a464b4194e9a727565587463f9bd01f9e9abea8e7d4a7a0a6d2c34407a52b298c3c17b035de9dcb67ca9de6d53676d16dbde9b6e4b6185c8d2fba5bd4c0dba049c87688d6c2d04ecc7075292397fc486449b08359fc9a8df9722f57430d2621c79e32ef558f9bf5487f0ba6b0eeeb987df4b1fd7c5573ad0b80d9518295d4f66a39bdba64de20236c48879482f87ff5c568e644f0786db6a29f144eded2843167529613b9346604563b857a4014de484aecd8e2106a8957cfec8ac8fede041f66651bb7f39601c554d1c977da0dbd06c3d04444edeb5ee284ba923565d3cca13db0716364a24372676bbe0c747ac0d29a7c77041b498406613fafbf80d9eace6268ed09c06acff228d611787ec998d9bf9cf4b3b9307b29f568cf8075cb9adc8434a6384702b8f2d26c3c3b3f46a813a91ba9e175f5d37a769fc1e684dc14cff8d4ebcaff3f65ed3a4ca7bdfc9106eb8298b8ad72f21cb1d96dd0043f79bdb0c95c87fe4fcb1162d2e892c5a107e9294d4ff347b706359c5c56f8556c1cf5b36fa1aea0904924cfadbd1125337bd43adb4457198163ca9329517162fd81ed84bb35b60283e841cc06d233b571aac13c6cc7fb6ffd237ab69c349aa9f81c2fa3a813293bd5be69ab14470f9ef5088bd208e06b14e6d52432c28cd5facac1053772dfd2b53d159d3de9489d660fc27aadaa1976835f72737577a0e0752d73c9bb0592c5ce1c098dd82894db3e7148d425891bf597863223f1b64223ad4698e3718a2531688007e6d6c5e8f921e310961c310b821912a5ad601708303602109c12f1120c8fcba93d142f7dbc0b56ac2405009ebfa6bb8840197aa1a373dfff9457086a155cb035c21ae1a65251ad2582b5238de3ae084daf9783b072719e1e047b1832ab58140a448072cbdbedadae5fe9774473af1d7dce6a6b86fbe4eb9cd4bead4e055d633b56ebb2debc96d41519e498e2f6dc3488d3b3a689f91778e81615fbdcb144c932d6a7ed600a1e88b749105bf0f9cff0d05b0e66ec2ac0c5ccdf655b2088a0aba14e7a19666ccbe4675c4159d972c78e21b41e7ed688725fc1d0321ca19847b87e7c1ccacdce412338f4bc2a104af197ec93b0e20d519bb0304bffdfe6b6f2203018ea920b5c638bbe835989ed3b97e71b180bd7dad0356285d48d05f572fa603c4c7a393bdd8608b3928c6b27c23eceeb68246d1e9723e52a8ca904ef82b6bf097ac6e5aea2c6329e582f27ea3f1e6d716ae0de5d70b92bd02c996135018ba24183b46cee7b7ce78b64f4ebb5a07cc7fef0c47bc09dc8289c421f7503cce5fb006db272019d8289808ae212f7086f24f5b76a3990e215f00efd71c31673ae97ab3bf1d2f9c9aaa5c66de71430d886e549ca413b3623842c2eba1467e640c572bb3b7b6671a945dee7ce06fb893a2ce1b54132e5d6e7e554aff903c7e7b63d2c7812efb9937a08a9be86c2e6fa35a98251ee950f80187930a27c0efcf9f533c265b9a35997c64a5229be88ecec086b23dadeb0a5eb6a42f29c1e2300bbfca8adc9fe4b3bf94ead71a16f0c46193905bf40297fa11088593fe85da7b47afa4461156797f813703c898ef0e08851dd2ebc97aa110a96b0d9f2740399a58c00fdc08aed09cd5bbd59c36607d2b323966bc959cb5c63fe2d811486a531f2173c6ac1260b5015fe8f1f5dec97d3ec0bcfa5cccc5c64499e2cad6c27f0fa48f3e399107f0fb0b48d25ff6f8ea8520654603ecb96677cf420d44dd054aa5ed143fe32b7cf1d0fe76a4b96f61a17dbeaae0338291f86fd378091ccf8bb26359d6fc903fe2d5a0acf353d4df86d028b5821330878d6c59cb19e28e35aa98870db968061e27299abf6b9375b9e95fc05f5e3d31cab4f2defb7abef988f82fc8185637b22fc5dbd0c032a3902ff67ad3aa7d57dbbd2b3b55e14823ecdac422115f56f5f27b4813444be1eedc428b35f7b874413ab602033b2f7eab1ba83d51bc204d8882760a8b41550e197fd0c2210b2131536d40016c95ed7a9a76bbc53904e1b64a306f88d8a9f1c5b350a9678e6f7f7adff8e9523b7f04073f86a6d26a2d15bb133a64eee2926b94f3e893880df58b41b47aadaee8cce72ea10aa24e4b3a6d94b455173e9c6b8e40e5d4ecb08f658dcba18334e70a542d037297d87a266328895438007da614364a883a4f749c36ff639103f09be018594ff455e92828a90760bbfff397ea0ecd0d2a8754669dc35f8864b5415e7380f9e78cd2d39b06f6d7038fa4fd15ad2dadae8644343db1f6636b993fff7ee5a5a377419001359d0e8571c0f11532b68dae1f972addae3ba528bf1ac7abbe0b15178b40aa712b25b2d1210f017a2e67ce9b135e06daf2171e3ca13500121635c06b1a0cac5ea9a5e501453950ce21805ac2b4bbbbae94c5f9c0fcc1d2a46536cb0d74564516995d0fa3dacdbd6340701fd39e7c960d97cdcc90439ba10a6e16e0896e812efced1a9d30a38cc47ec1abb351dae07e759eccabaad468cc6e877ee293e4aee9f8ef3245766749c4a70b3baeb791f94aef42f14d33b0d144baa7e1ae3ab37a7b95a6cbeaab19f654c4a5799e789b034b1e9606a39df6cb1ad0a2cfd27b321e3688696442cfbd00ae420a0d0718bd15af05c6bc910197114e10cab72385d1d05d3b010a70b33440a222348b44256f9dce8ae0d6ec43a8189617aed8518e5e446b6769e4e412bae1b96d9a3b42543a834ff0d4521ac2085420ecb9b520ab27b68e9eef2ce16e07cebbdbb40dd127014cb295d700b765ff40c994069f177602fbc2035622555bd010e51ae609ce124b28a34217736bf8b34625a307906b0557319dc736843257624ae62f5998a6516cec529119e71350742edea2778e328b9c840e99d3507fab69eba74276c9f4202273785d6a447fb924672fb12ac16c5d1fade23ba742d42584ebf8fe4d4f2be3b21a2dc3b997df5fa29354eecf845e3be0bd384cac01825909ff0d2163c9d22afaf312fb23b676f7b949e48ad4544008a243e9905b7441b05f589751853acdca1a6839e49fa09645108333e7c621ace093472ffe81ad176a71d09fd522ccabae0dfdd4afca2ef8a2a0ffb83e474b9a5d5198df271a2b999f38a578a4cc26dd0a07ec99dbb3a419737c94234ad9374c78eac3582b0f45b30e06bada9976c2da3b90e96ecd34d0fb0ed088308b7e49516f7faf4c2d6b8f9a80acaecfbd1e4c827abfadf6385590ffcef725832c46a9fcb1fbe20b3ea98d2e1eff0877666e141f6ce05e3bb1b1bb20eb49f124e7c4bf771a23cc55d9a113b8fa347da474fad52f00ace20cf119b7022965cd297ea302381d4bb369d8282c9d90e8dc79672a849bb625fa4e7123ad3ba15155886571a821506ec1c36fa045db6e8cb395ee23f98bff65c4eb358190c6a1df5680511ff96386ffe7330aaedb06aaca57dfe3b21e31f4cd38d2534125a4d28fb6ef4e6e81333566f8ffefafaec280fcd2fcbcc7ebeeb995ca634f6715eb553cda81aee096d459b931d6d537c895dd9ccfc4614d1a13d7ad739464ff0490854be3c4cfaddb0a276a93aef64ea37f1363da65fd328d0bc2045f4d43d786f75cabdbeb314b8494fcce90f0e7d0e3cb322705345ad8b091d5ff887937b0abfef227b5c2835b4ccde077ec30dd1e562335181b82ce72766fa82f0fbb2460d5766826e932220adf0763b2679fbc470d8afbe10853960871c52dcbb876ca38ec8e3d4e74f748296f7fe5468cb5e960ae552e90bacabf55a95d1a7349f40c4700a929bf5c9180160c2cd52923295455890bd2f24082583598c5ab8b21536a5ceef0b78174d2c3b7548dbea12353f5ab7eec8adeb4686c7d2fb1998af0ee02c9f7c587ba4927401b3842613e72a0f9ff034ac32518cceb00f208647c59d9698798f45d1ccac3aa7ff97a60ea089cf9482190cf83b4847adff56aa0b6689f11864a4dff74d5fa2e2e12520ad95b970b991e0d11220b7adcd9644872fa70da16c07542fd1aa58784169843569dcb7b167f92ed60229898717ee39a1d75a3e10187eeaadda6afbb278372afec2455216c4d565dec59cc74e3944e9058ac79c4d4b9223259173c586c0821fe36527cecd13d46819a03dd27716a3ae5ce00883f59e3caa294386a7a8eca28cf7f1f7e1e5bdd6cf44be1d4f8010ccfc529f60eeaf17ea669bf560cdc923f75db79fccb1f142fc01db112ca386cc5741066150e8bb347ff62f32bc0b824dd21be66f63a6e2057ffe69a3905dd51e366a64039b61ee8c9249f7e97a7f0e23083bf475cecc23741b13be201ac6d762dc40d90ca1d94d499e30a95e00654e702eeffe9d938736fc36ffbcc870cba62112c25d64182c9d1aa57307264897b9a3cea9b233b9284f1d8e1885156547b45205e103b28ca87b57ef071ccbc3673c9c4318ee3595de7a3c76e10473801951765121b3b4310cb89937fc2f005b26665957b924efd9345f51da46aa9001dfedc627d95b9b1b8de49b4e9f0425decf2e2fbc96b04681d42ee99ef4a460f553d1816edbd63a803d800bfa1885405ea6c46127c6ea0b422c07f5b3bd8413f7f5ea0e7a44bcb06bc7c9d4d60c3eced037b394c34d0c6087b052fc6e1cc2e05bb2d6353e69afa7dbb4fd6ad0cce6fce0460b8ac660f27c3f3110a46c7207dad14b3dd9622b54b0fcb060f692a3d3660d3282e27c45032a2763adc79cc515159af3024b5347b2997699c0b0b90c10290d5f4efa9d2d131c0b001351eafcc1b66f869c131cc3e7356b3ebf2c98c8c6797940cd50cfc05c79ec55b0a5b0e224b793ded5dce8e390aeba43a8253cf83e97f6521835fd441ee56a714bef0494a53fffa15af080f6d05d6a46589690b26205368fd96cdbaf8b52b7f38a7eb6d0a9d2cf4a1ad60ec44fd0994bc30dacae9ab01c36d838cad5ab0fce694276e2d2ceafaa777843215cce03e572ccbf83247820e881b8a5914c80a16a495a07c72a41fceb4e0230894f063101e137687c8886c23ae2a9786437dee9e25185ebea9e9f90f14d09aff3ada38905ed14353b002a2f80aa4cd76d092e7eb8c9e8df811e401712d533779a624449799dd10fc7a7074f7ef74e1bcb5ffa6d78a7b5d364008cacc78dc5d7927921315cc408417674bddfba25db9ae6b4d399052eabce1dba3c595abf8fcba1c337f64de6bd10bf8b42f19cc9a464cc0b890ad3bca6cda5cd4a87bff61745c42655b6c94f04fb4dc9f31c2c88945c0e90ab780ec622ff6845e278c6d878e5c1674acad2a0ffde0aeb003adac1fecee447c200ab9ae40feadc09bd5197f0f0b5380d945ab80ead477fe92be36f2111517aa741b49fc20634e39bc883981c54ccfd14713adcaddc41b05a6df4dd60de89dd699e0d0dbee605d67df127636e5bd2ae189f3162e6ef55eb33366266f2dcd1225d5c6aeca85225d43baa5e926ddc752921b5f07c038a6937ee2ef3632b5ce20abfb402ecbd26ff7a3a39b7da2be8b57d98ba9fd56d07b9cdc4fdce9825a9e3fb0b227c80fc60fb18c53735a89e04e872fde53da51fda4b4eaec989cde7e38e23c93cbb8c7d55836e51df4b189e6813abb975d7b7aaa111e87f432c51a8920daf6eec6b9387a131446b5f2a545172e208f1fc0403b8dc73f25245fdea33d48939d66c97ee54a6bd5ca01ca55a45ed683acf9868e7d81e2da939f7ae0431733d5c57fcf2e7bf775c12d4e2bbd15f174040f30e3ac48d916dce1d45e745f219370b34d38cd19595bbaec39859f97a157bafe3f0389bf1ffce6218f0e0209ea91717408099105657a48da5aac397d6f48607f40a6c1b762f7ec46743097376025236c490a2cbb37dd7cb8bd6fb9f899aa6dd9d022fde6455b9c77abe194e85c1a8746e9971ac10fc247caae72b31ad17b4faeb1e5771fb75ef7d963b936225139965ae33db2c35e87ec83bf4f942e26767188b2e02ce630900f1012c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
