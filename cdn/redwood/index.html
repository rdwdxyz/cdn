<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d6a31c9e967e45889026193f8f9344cbe523c71312ac73fed9d4eba4d1d1532039f8f0fdc55380a8daad3331313d146982f44c0679ca67038bd273d027dc7cdbc85312385785e0a4c20a604383046bd350ccf5a8070a2ce08e4309eb0ec92222f41fdcf68e1a995be69a82271738460cbaa7e24c616a23a189676659fe363dd4fdbe998334f5651e3a97b0324a4b12259df1487d7876c2d580c45b6622183660bd9b1235eb18fa035c4e1354dd9f5723ec094a451509d60c458f2d6d649abb6eecb24cfcc64ef1b74245c2e543ee90aedf3fb71fa670c041db3662035d6a1ea3f1814cb8e7cbd1ec88a7a0c9b83856c422c31786b84bd9e24441b7ceeea67484c91f0cfd6a137ef7c8a1a7b696e520b38d53757717e948e1f8a744b7629c29611e5acb8badf18fed180432b5e0609b36bf537d2a394eae42b0b1bc3a943d388837b755ab8f73a17c9cf06a190bad439fe84ea5e59640516f649cdb379984b0f051bdf963289ad43e2f494dd5325e79dfe85e91b2db44056177343c8e97d3d30f20802c042464025b8cc86960fcb726c0ec0dbda67f88b71145ec23c4dddec36ff3691fb6dde713f2535df516a9cf45ea06bd732423924b968605e262f81179fe2713bcf6487d1f342892cfbdc06e4dcf883f10c750776e2ed2f9d1412d22c78c2e8bcb8757be4a8700f2ff10ec2e2cbe5e08f99164b3e59c2921c30109795379bbadd232abfaf57dbfdfb48afbcd1a376e3b82b18b1f4d590e098a676ea069cb89dc7a314aed18777f269501b91d2febdd3b9f0829e99f196da9ea42dbf9c965c143c002cdb9a926ea6e6767aa31af757e4f9efaa46e1476b5ae2fd5e941499ef9a4ad1ad862efe25e3c38903577bc693c149082f9574d090362580fd2db3b0b667e7b2c660b80bd9936fb5f1a993e858690831136856595995f7745d32b0c5faecae4397bc5aae32aec20e493f58f4166740b79ebc963b7a989eb93826ff62f36ee7ee6c9d104b6d1186f4c37338cc1ae4f41fad28c178e5603ee51bfcc6b98818b91259045eff2fba3d02df8d7a61bed8b283daf29bf52fb1ccfd1730656a09711330d3847e915896a59c9daba8d8524464431030d9fdffd99413f84280a1207895e89fc0eacda63c8cb391be69333911de7ed220b7bfbe159e1013b092af05e5378de7bbdc75294296d9451fd2b1542e17089c1c6448010cf377b7ea4364459190793cd46e7dcd16f456e503284b4d2dba7ea120cd671135dc5b8449faf3fa9d938a5126c3e52b5c1f5fe83a60bdde2e4129570f67dcfd7f786bc4fb89e208636a478c9b71d74546ca377acb62d3b4a515f365a0227f6c01c7b681d92eac7e70bc30e461df1ad74317e10ee135ea24241f3f4a6be33be5a1f6344580de3bc69868cc0c8391f23e146c35b6cf180fbc20daf284561d8860a08199cede965b5e0f0c7cad3d550db7b3bbecf725a35dfe0b53e7f87592481568af67f144f359588518a974ff614e5fb6cb7160f4aa0d4fd2b0e8fc5d5fc391f36579f29eb6fdcc303b0808dcd9f52859b343851c291fcc828e565adfec5c216cf1518cb7072f5bbbc809b8da1f259ccb6c688eb5f4af6630863d23314fa0f435e3b0742ad2ad995fe6f56be78ee9b88d817418e251dda7226434ab24fb024cb39641b6cef83e3d1711537c2e229116ef62040b5e867e9714ed2fa3373c84866b45a159a6f10dff657c9f4a6f1ff2242898af72d1bc11f4e73fff5798fa63aa06d5053b56449f527af22dbc5e40e28a357b17bb148ed0bb712320cefcc37cd2b9017c2d6133bf465bc09394a613e38ed65621ae3a5e57eae4ea4561d60ba2b93976629eb884b7d7412a3411ed0784d3daa0ba641f7a9ae9dea5d8fa8e9d4d1064ef3e0fe6d332f9e233fb5d3d490ce67bedaca9bd52540f1f7aeb5e10c001deb47a7b06f5702d614490befc38e97fef815554882d5be8270a986f47afbd96c959abdb8171a5ce4c2ec6786b7b64de540bcca95b0ee77baf6fdd2107e1d6ca37085c5e2cb34744d75cc5e41b2e229c7947ac1e2162f73a686d8dff696eabe4a266a1c2168fe3a4e7b7dd79327f76b02e3db3ddee1a07329f2aea22d313dfc39ad6dcdb4b57fc8c249807f5a165d7a1197b9139a8966de533c2602c6407e1c2ea2bc6cdf26582b9155fc9779d7a1967ee7bec87ad3ae65b52db674ea8236588c357650ce6f9b89017d859f2b764558c9c34ab74914d65f7f2721eb6338d39bfdba1ea676ee2020a9dfa4b41b6aba3f4a2efda84c574201e036948b561488c051842cf3e04c95b32f8bb977ca8effc350e9f8927727638986de3e09709a05725dd49a6d13976d8cbd62e6ea4db96e8aac3d23255cbf7d9ec81f8c411ee624308cb82539c75beb77457e0647a7b65931056e31dc8962f23936edbfb40523c95a6eb9fc5a1751e158bd4e2f1ab0dbc5a112a0ddbc21f538a6f00f85aaf7c27b649c324d69565e25ff0850b932bebc27d32f767b5c74184b225534203a5008a145249f96494a76eb652d5bad5bab66f0547d5b3a648455e20210062392e39929e3bf3d7799daaff88128d16327d488e6530112c8a7e5edd7984ae224f68d91e0de72d190696519ff6ab5a7ac1b58e0ca43ca1f1d807f2636763c3d9219a983c6c2865b3950b925a5c95b6cd5cbfb0d5d458df4e2a4f27766c921e5e331419d27b73455a6e22926a122a884cbdafeeb2f81dbfe6790b8a7814247b82192b1a30a0c97b057468f94421b4a00c3ed34079474745e4bed582efac866a496a0f3760e469ee21fc46e87ff8102504f3115183334bbc524c3bdb947aa6e4c04904119b17fc0a165261b08123d275fcdf7d648ae2d84a171326b3b30209b678dc3f5a4cc9db6eeec185cc78f6d47669146faa6ec572b9ae482c8ae304c6918f639aaea76f59427b089aeca404a80f7d48adf25f5d21fbfce801343471f38f79ed0cf09c7fcc6a3ddfc09220ccf14459f22b775be28cb7a9e13911878c148157bb269a901dd24fb7c75f945079bf4f433ef456bec57ca8d7b125d9e613bfcd0d29ec651196c958a1381225cd38cc510abc57177aaee77eaecb7819369ed1ec35488efcfa63ee3c4326593d8eee81d0bf17ca8d373c897f976341a644b11819eb0dfe392e925bbdbb852f592508c71980a5dc910d7d0a3ce3033c6907e58316f9daf09139b60267e3544dfe1c8b661f30ebe5d85525fb9b89eedbfee5bb46ebab8b87fe531e2cdb9302181f381b47b387ef2f4a05486a65c6aa36624567af20ca0e6ae1d6726c816319a72f92c636671ea951c0225bbb635c2ac1531f900d95c3d165ebc8d984466f83ab0a9a081264a67abada78a84a06b04670a9be20fa4d758862c9652b2115e3b473ae71ed688cbe3ff844e9aa35a00127eb80ca8c46ad40194c75527c185201ef84604bb67c3cc9c6211a89d82e0cb0c39be25f8ee359fc9a8c82738fc8b44170345daa471a40c402c40f408430fbdc00e09c129e609d6e04e70e57999d74e127d3a375f80a5d3d6cd4e11a3736b15d6fddcb875ef4e32c1496598a948e1c5716226d823d268c038084d4408d3b55a62fef33c9128c4ae9346d52f10d1e8a04f0ab99daba16387a658ddcd86757d28192c3ef1d1859877872f2af07b522bfc8f98e68f8cee3f28a7696ff34056f30c5d852335582c90ea472402f3f8a22f6664eddad3baa942f482680ebdb3c399642103566a4f702d229c6976085fc0a99ebfd2912dd14ed9a5446c87343617e9238704f3f37b71b76f285ed094c6023cc07eba3c83b598830d4f6cf1701fe0864a730a332382dde566e6c106dd1a10fa296b89f721983a20a1d9cfbbaabb5671a7775faf5d52673ea3b50a0cd42a8a8b3e2e54a8cb0c5df17d3e87e057916e4296a61fa060efb0f392941d24b23dc5527a76061f552c746f467070622ef1838a6595093b64646133c965d92dff15a4b63a06e22f46dbc6efdf37749596b7b51dfafa2f12a1f2579b8d9312f21e5659a5102913ce7c5234278703059cfb2df13709a553e6cc45ff949132b83d7d9dae73d80bb133dfb94149d99dbdf4203a9a164b916369cca1b93b6d5bff54d6f7f2f984aaced72313fd7e2e4124cae9295d7ec845f87994dfa2a21b72ee1afa2e4df3e59f7ffbe065d20833e3377ed9818d6db56df938ea8bc38bbbf58d9ad82a8cdc5ef2d9620a80a75f59556677d9c8a079bf8eae4d7e84b1a5a2ada35098d9360977c90dee0720052aa92282e99e04c161c6a8fd643c3cae96c814067a9afd7d9fc64445e9c7ba6c6de655fc0dcd1ae024f9cdffdaed881567778da91cf5314900a71a3da243e82f1eeedf489b83755327e08ea42c97943821ccb550e91b486d63c47e72305a6d1ba28bc1178458d667928fdc3c89305cf215035bcbae12b5fd43457a43aadb533239c512045ea9b2ac74696f439d22df7c3a83c35318db462e509a580a36a895d022b255f5edcf024fdb7ec0f2e7580ed719a3bbf11f256940507933fa619ae5a986254dcbd7891123eb9092d1f40fec9f1991f0c4ecd7b2b6f3aa21e5ed5883b4b2f9f80f132b8c87b040f274cd8ec60766443a5997081528bcd1d1547509d7819769f47d4027c8fd6b5dc2e553f67d57fdf3b67d066608629c71e8c6b7c88af26f799e8d011623e74917a856eb98b4bcd16a1a995bae5bc261fb6be83400dae3c96d2c5705ebdf07c76110420050d03325e2d8d067e042e24bb043496f51f19f884fa37b151cdb8595e2119947f40649ec76adfc024b5add140ec22987792724b1b8080b9704ae0b2bc3477d57cb09d7799a4272caac0463fdac93badc6c22e66ee4c3683b439052291d5c846087540fd07a945ccfe7a25c097a47e4d5721d3071e1f32b079e6d57e76508db08010a20a63570fd9fe928a28d7fa5d33bd268df79dd2abcc12d0ecaa3290180fd66638b93349de858f6079a30611dc4684010a576baafd6edffb05b804225b3689cd92fcaaeb861b53574a95560d8949638b519953dec2f31ae0b9a92104d8d2149575f932bf69f6adc30502f85cbf32e904009f3f748440d2d8ec64d7b251a46074c2f235ee81cc2389463ce9b57ccf6ba58bef6890e826cc95b55921d6172a84db82c3640150e7d78774cf6fe6eea7949af11e64bbf4d43f4fd55de3f50b07fbaadc330c1a945fd12bdb1aecd970c816e9e90759986d0c4d57c74319abdd8164d0827daa2dc0f585e24fb28563273dff4cca6c503f1536399517391468dd936c0378bb0336a5c81e6e2475a699596d419b2ea6c054e87beb4d4afc6aaad754156b31d0ca7d339b699791fecda85e32f6405dcd3676477445946100ce02b0f7363b8089288e09de4a3d5be170f179568244c6fdbf393ee8ac24fc18fd2beeaa363c0b5bcf960a1e0c199a934d730df9b8956db4bdf102497b138ba799801c29ce307a4d9596c45baa19d0ce891cd11da9b096de8e7dd6b2d775366ca9557b037fcedb52305a68c1cc9e0d042597c11638621880ed46494e0a52439f87fa52e4ea3ea44760ee1ed8ac276c88ccaea1de67435ca68da11c9d1abb8f4e2805aa6c2cd2ad4b1e00cc85070231d80ad0d132776f12a0488d9cf85b1ed8dd6514a8fcfc2450ca0c512cd58ea2e0a6fd90f0bd1ba89c0d7d2c884032af12a10f6418876af6c6ad8c31b04fbe54eace876d67a2e8504324efc7cb13ba13c65f83937ac88723d6be7299e42cc3f76c11bafbca73800fc27d754eb4d96e62617d392dd97cc111b5692b2283f4584977faf3345cfcc2172936ba9548c492f00c5bf5403876193e9a281d631da96ee4a76db4f018da6bb2fada799c1d0bfe025f40c3a9b1c1244bd6b5acaf235bc40a3a91df70bddf70ea4a41549b5fabebfa72c81314e35637c7c98cfb6fc032b6f47e6352032d149a029256970d339206a2e76a30d3232cd8a957ae5edf7c73c68d951820ee174ba81fdaa255c341da97ee24b6df3af36edeaa61aa7a9dc446c5220cb61a02bf71c1120515bdfc85861f04e0518076b44cb0b8cab77192794fdd17566d98af7f8bcda7442e233bbd85c2d70ac5ade6f51857775f87e4e0787a689cb55c59abb5c3d937f7f929c74a490f3ef01764b96aea72f3df61700f11f642a2bb43120507d780563dd3193fcd514d1ccea95bd74f05253cb0c01ff61e767433117770d3d107cb60cd9ae96e658a9489aec49f197674f13da3da5208681dc4d459890385466eb8f8b95a1fbd12f0411fbb1e1a984f3870ae419d51ac250d6a587f31e1a760837f9ee0f8120f4228f24fd7ed984c99b7ee86c7813bed9ba93bfd98b5bcfbe3d198a755204befe9e9cd8e2937f4b641553451ba2450e49c74df60e90e376deb9738a09849ef7ec3421608736bd10296442e55f618afae1c316afc32f6142e8b494d45742e446d39e10de3bbcebb495020c99b8d251531d8c3367224db89f4d148f90c04ec9f326314595bfcfc4eccf988acb1c8fa71d0ac2326983d326bea873088e947a75d4e27af21f5e99d69d8374c51f71c7e9391a826d64ff93192800e0e8de82321a0d9b226f60d08f528c11d03b77c6e1d5244d0cedd7bbf674c53fb17e3414baf226c560431642dc061216fbc703a99032c67b267e77ffe719c84ec4320e879527dba83f1af6a869222ccc50a62e4e30d0fb4208c9296df9954b874b2a950264bd38c5ee3ff5792a554fb47f46436dbfbca4ca87e3c60faf361b10a154a1741ed2e5557ea07b58b0f6d30f911d1504b43e21e947b641e6e45558c8716ad2f57044deeca2e0bdce623410babd6ac9d66ca335eb814a31ec23c3bf9958b9da603e422184ef353605771f5e4bdaaebac9b41257b799a7363ac36ee47859400c192c272d5bcfcc9c2c9ee9ae27951b7abff59a010e06ed82136152fd35a640b196c1bbb1df8e768702e2ab3cd1a6f7ae86098416d0e236c7b9aadb7b8176dedd6e737b37e42c12e8d3a7e5d26033fb96ded61ae772edeb3d7f7f52928d7c6322f5355a91abcd75a6b523a2caebcd8d15f1b4e20fc825d0d27f4a403581907526265b7ea37958920edf1aade314b2e78e80963b5eb70719f4ff1c0e0eb56703155ba2387c5afb7d856b93126502498384334fedb8f67255e255ff1628873f69d52179e4ba591311e19af8addb153b65c770a9dc02cc82c98e0d98d8286eb3fc6ef709a1928a196b36e5746b290b35f895b861c4a4bed04face1822c0fa98177b1671c9d5ed9e56c4eec9f619c49a6f72a822beff7aaea700aa8a1e3952c291d7114900d4bc90c21f33b8d39459157f44b626d4d8a2c7dbddfd38c0e5c5a34b2e26e10fa51893c2448425389137cf99bc17afedc68191206b1220377f92871443c33eb47e4a1ff17804420c3f7d91b2d94a63e938b59fdc832ba6003a722de2ee58d4e98d9ceac61f35ebc8f656e30d59aa0f5cf8b586423eb4581ca3f751e60b09ef5c3efb04c4fc54d2827a1e83e93c290dded1cd4cc292d0c1a929f2b8a65393669f7bf5bcb54ea29ccd00e77b8c6e71515d5aa14b46a63eb11394cb7d99fe2eee56346587fd4f9cfe3b05d9e71a81fa56e301891cabaad330fbba0097d2264fff55c61529de89cc67f10f9e7769a46cc73a31be4cfbec26782f3f8b05b5d5bdfb313878056777590f4863e722f73f6e149fe4760fd98cf1fe0b086120d49c9d3cba050a2c160a6292052968c2a642e2ea1b81c6516fec04162eda9e790ab13854e753586e5b51884af4e4dc6066a11e4a37ae293f911433abc7d6e54f3146e2ccf01e4479cbc646504ea27f2340ca43b7830534c672f8298a2d143bdb11b40468c6b265f8ad5eb00aaaf2f82f88e16dcc76877b61c239a408c0e36b721df053828f9d863b64cd7fd3b78ce1e743c505d9618bbd5256eac56c226cfe2dc157c4c6d09a67174c0b4c759ce39a54c8d98b21c9bbe19582e8704c2e706b1bbb4a09ccebe90c89575ea30d3139a6eecc982f5160bcf75df8ddd7bca3ba0389272f6ca8866d1b14891ffa1fddcfd80e12ffc7b42e65ee68f7b14cc133198ec84ee476ad3ded1988dd6ef59bf37015e7b81507483d54290f3ab1d2f17f2d8cede194afc83f574b1db7e9c09251f6511675db0996f5359356a6050f868e76d536e059c85580c579e01259ab1357b373d65b23de390d1f010a242491abe918ee03b3e3d7f752cd14d559e83f92565898dcfe0fe9991008153cfba363e04ee2dacd585947a4a68788ab0aef6bb6e84fed2d71c1a6db18b9161f0284aaaa4c0607e1f38ad0506dec9dff55ad736990a699f1ffca6efd48227783d22aaa24e1bbe7e9f724bc83e8feb1e8639d622dc03c17eac0f952695993b803415d3ba97fa34b129e798b5fa065a026c1efae66585bba2ba41b6f03c4288019802af311f9f81ab1ffa86281bc3cfbee67998f3f998a7d5fdc8b2a07ac74bc1e654862835b9f30c669955dda71072e6318b4d3a6c95a36c544cc6aa598202c01b6adee73b0433d6eed7160afb1d094eb52f5f759c2ba169c884436667864896f72c7975562804cc8803990c99ef7f8073d33f23b9eb9ce55a367b60fb9a55de9f91e8108ea22146c8409a04a42451662384334b17626fe3236fd035a8ca68f09c7de135455b152f2ad0a4179b669eb0d0e7de6486c4c640560ea81df924398da412c26d4461e45eecc29a49a6c0eb614032ff25d6717e56b397595c44b748c3b77adee6f14f0e3a9de14ed02ad3d4ae6bfaf020ef72feb5d4176d40664d3d6d62d9285fcd2bec65ba2e35ee39ee85bdafdab453cabee0d597b8ef3469207749a9916d6eff08bb1c830b78be1872be1869cdc32555197639d47364d522c5f48a501ea87168e3a228bb8072f1a7d50073f6836d6c2d16ad5059d04388d3995a69cdb2d5d01a22bb50464fa848396c03d8af6d0c48771b953743332627137c06f9105ee1193a70ebce00bb51ea39abb3275b4426b28dec5249724e7957f439bc1d6b70fc51beb2693dc34a6c20942ec7b1dec186f3a56165bcf9eda18dde247f58b60cc81a97a34d43bd05d6cc82904103909a614a3ca50319ea6f757fcd1e9b72924458a94fb02e611621dfea35f0b212c6cdefccbf2542cacb35194526fb95fd3883227196e1a870321e6dcadcac6e76789f60e139c8d66a584c08e420591b8e4d14ffe295172f4e42fc91b19922ff20d58f959f24004c8d32b3a3f975eeb8db0127b161db242bb7a442debe15d34899feba7a4253c508ee896f4b90c94b5c45474d5d093c2160f08f6b28a7889b3bb2f155b42c1412f8930d61d2700d29248c1ba9861ed16a49ac3f2dd441d9dcf85c71ab55bee50c579eb35e84b5db08e03958a2ed9d0c46b7dda09ce642b7602126458af20d1568cfd1b74e439b7d80b132d3ea182e14c627fefb96881ef026934febc78d309c4f99a349184eb1f7f95234cb38dda44afda2e315fb0325356f01682273f60535dac5e98d2e4063f5b21a0e5157252fb9ea5052339b8015911f455bcaf1acc7fadecba7966759465c9f9ee28630bfb0407f5432111968b077e4098ecbe94e891bd6d7cab3619a5e0a4670a12257a835a4207689cbcbfd79ad5646e2b211880c3c6e049be6fa609e872822d4e66f23ee04adf3a83be4c32de1c26b7252de972e04f0c1b7628a1c1e6220055413e877888436a1ed11aa9327e3d6bd5fd0d1a691920d25312ad739c979f8427374802f7e69a357974ebd55cba705d50c560b4c0bff81ea9314d1bce2234c177578e35b74a6ce2fc8363650c0bdc874182d08afead13603ebcaa80c48480e5874db5658e0a46594d2011e67324a6cce49ade4045b3ee52909632d8814a04e602d432392248a733cc77b7036345d675fe4840e5bc4e9eb06604571e40cfcd7d434f8fb12baaa2b0a4100e9c3becdb485b80d431a872c0e431d1d95e1adcc753a5ee01325e747b3eb4d763e6573c3b21c99f40676078d59ae7c143bef94b34ea6d9425e98997df456c3e78bcd7db7ea9a0d0fec4bc8ce942e1b1035ef2286987b549833ffcbc8d415a65550f3f874f102a7cb46941f2ca532db3835904961cb6e1ec6f9f2aeb9ff418af21ae6f09fe374753b122cb6a0f32bf31302d4b4e5b500726c0a6a3d120eecdc576e7bc7c11b34ba9b015a797146dafd3e8cc66d5cd8b91272bc20457667d5323cb333e1365304a2877c0ff6a0adb42f5e17ef68209f6b77db6af6ad56acce078bc2321867b38ca09715d41ae6d51aad3dc77e6fa6e1c6d21dbbd7f45388d1346b41dc057cdf00d924c34ed167cba36be0ac269391459ecd30c8d71702df66b5f27b1ee2130f68d19484b1f4c1e3ef4d5fe274eac565635956e7725252237d1961ea1318e70dc764e9315d3feeb91ab311e562bc40ec59523618197eb60ac4cf7ab9967a9176e2cd9e2984b2d5f031ab5399c76d7dd86c1374acfa43c01c3ac6ff7fcd316f74451a9bc67a613d6b522a208d8c3c6c3a9f0323a3a3b3305e623c599c67a98aec43372bab4449b3bb5262785f56ee1f2e4595b85cede8df0524f6cfad78e6f8b4aa25f95cf729537fec184908878a1fa9dbdb8769ecfe5d6062909a56d5615e395ea544a3dbba1739a003321556826dc43665c3e0e6354a262665d6d3d9dfeb61398ca3dd5057d83aa578eacb2c0c398e5874a201953479c300b51f3e4fca3a7439b93dbdaed5ba7b6aa44aa1e94721aeabf9845e02b90bf2936099edec931d842102aa36f7c727b9d7ae191bc041c700294013deae319bb691a824ea8d9607a892e5acc3933d2ee717a8624b000b7a9fdae9d94341f1503ad8e0288039570133448e37d075f2f31761e78c4d22008c7f40de4a07f2d9a2d4f87f37e444a0f8c53f95b9042fc2aa4a7bf6adbe9bb4743505cc90d38888284a3867c1d625a185c580bd1396af0ec199ebf37ea1fbe0696b66d1d7a0b376908a76c960269a0fe8f834b884a2448499b7058711f0a6c93345d411b85068f585efceeca543ce456913b42be6dda98ed9826f37bcf9f02f3f793f176c864859735e24392a9c86d5175729df00f1c8d8f1af87cf2ca058bd63a80d472597409bfe0857dcc74a033be3186035652004b727bf2e47c516c0e37b6aabf2be08de7994552086d81fbc5bb31bb1560860738612ad42f66ee093c72e5357d871c7399dba970e62a3e80d0e56fc6cb19b197e944c3918101068c25942e968ac7b5240e323638424c45b342b6b0fc7dd327b4f8b163a16b7586f09dd9f2a95c08415e8c4fad6c7cc3e75ac55547cd198810207e66f992a1cfa75f3729bf831eece393d0ed040d16de14293d121621870e92dff3f8096027a0d5165cc372fbc2e8eaa571defa58fcc12c2fa41b48df84683c7df354cc652961aea28b14fc1152ade5afafc37afc4cdc3d29e06aae707b7001aef112b178872f67a8e1519e5f8fa9122b529c68194567a7d374d9da63ef00bcb3b04f16b11f09f64aeab948361c89b830c996e14ddb5111c551ce7bbbb7c7bd4b9797e3a4a0f0b8558beebab5feb9aebd783c5bb637da49cbe02554c1658295eaba90037e33e0f749fb5dbcf04568cc3f159ac4a6ed2172eb0b774054d46f844de277a1b6df2b6f144524d28cc6c967f6b2162e759ab2ce1dc1fa2ad69f4446f0f4368a50e03e1a37fb947b7ea5460a0a01e70721d519a41c2f91c7ac3670e09b4b8ce20ed0cc939da630ec11539b9c5526aaa29e865609a3d1f68206867156dbdaf005bb4a51d1df82c21b63fd0e7efad3e5093623ead1bcf598b35cb66493e8948c6099d722799a079e1e2ed839f471265cd49369a834a1aed14b5fcfdf6ae59907bda4d86b1b8770126c8c174e39309564d3087d28a46740b19ce7289091ed68085c4f4e8a085164f53a1a212ba6d186f0c989c0d7f640ef7ff4e2bdf382a91894a9f178e786b5ff613f1321bd4e822c79f92657d55454c50ed9a0ee21efcb47a3a872a85c8150c17dac713ce9ce18100a602e0bb2eb8e2ecdc638b0b037dfcc07972fa2329f76115a413dcd2fc63e15eb2a4ffc2be9ca6b1f229dd5f10774fa4476a6ff49d452e96d05b8f9135b03c798269133b3126e33a9d427ca1e824244cb8480bd9ceae5f6f2a1923d36e0d03c2cc22119216ba015d5dd273c545d178d918de96843489256c21b81fa2a49667e6e940868dcf4710d7ebfb575628ad76887a851d883b88a6bed205123feefbe0c05cf9e2fb6473246ef95fba942fafa8f39aa47f82662bc97bb8e80edb5775bd5252dd754563122aa0c1035c574055abb8e5628c6259187aea1826999fd45690c40fd8342b60b7105520607446a8ff5e3291ea3a6d690026e2f836ca5e60974eec000a67e919e7cde9d17ade4b22450addd06a52bd1d910319e40e16d78f388ef87b56316f2fbfc9847a5dd4091db30bb43db0eeb5c649d9951aa04128a1fb0502a7e29d4156824f27b8c66282cf08759131418fe6718cb2c4677539c29b41ff21348997e3a0594a1b9194892da4fa6766c7eccb2911537125184b0e95ed102b614de4350f23234dc008283e2807e7977b8d2aee811ce65d2878c31563cd0b8fdd8dddd3cb2cdd1ab2b08b9095dd5bf6bf9adda5cf2f30fe0ebe7f87e72226eb300c567125cbdc8601937e4f5e9541cb88dfb4450dae0291e4c01020a9df4c7c5a47f51c8d91e92e898f58eb91a3e00e1c776f59870857b25d44b506268254ab6048ed5607476c5a63331a7ebbb8e0d432537528578863dc5447de15c6a779d15099b26544b1112bf71aafefef1f43a6c821786e44d78490548f735f7d1735cd9876938651a03038111ae75cc352632bd20db57b6c2e6bfd4b0ba2df548963b4e1ef454f8a62c097090c652b78585d0e6c39a6f21e8311eea3b044a6fd1ede00c7ad8371aa214593298964b0173bd1f9b177402813139b4544ab9450ec851612e2da0a053f6960e28fe205cc23fb9f964e0cbca1ae3167839b13ad4e328056c1b44b5a54d02d8622c9814e5d318a8962d9b85e9f139d6d3545a3ec55a90bf494e20553f478aeb80d547cca670628679a1095c6fa0773e3d8740ea3047fb772b67a08f70f9481409755eab05576f8d0b68a3cbe63979916c961ff7e55f69941ebf2b5638662a010031c964f1a2cd41ba7a5d12dc97fdb3586eb922246633ef980ad97e556f2f25386619fd1664bc4be08a517415099c8cae20a170f83bbc1510b3aa87fab0aa8c3adfe03a953109e5316099fd3deaa19b04a266659fa1385293d59e2a155a360a8e72ac242c69f8dd59b72e445c94d51e890635bde4605a9a4bbb0d33b55b6fbd80e7429fc9eb80899924ed987bf507563241d27bb903b62713271e4180a1e65d4c48ddba8bfab5398ecd7ce56e51490b46d421b89bb4ced1c88ea884b051a92ebd891ddba34ca09e36837e14e103e199674d7b2db71a6cbbaa6d89cc4497d35568740606a7d0a9fe8594973f2fdeed2b90b83f18863cef4f1069cfc095c6b1316ae81c8fe24879c8cfc5e12e4d30d47f8f5519a4ee33bb714850f7ddebe90f6a53e49d71b344864a22a2b281ba116e90203fe04673465d1aed3cd20bed7257ad3ab249dd5a59f70151d14c625549882c3ffad8ab0e72c5ae22392b7162b214b7db01269f746871612f3c62e6ed7b25c438580148eb4d94903944b8db7ad4c5d45ae404ce598f6c055bb044a01d7ad86700a1fe7a0315ce8329f0e5c9562777e5ea70a60df2d277c9bd03f821ba8584ee8f083af0be68f0a7564b565803aefe351f0d7ed7928182ce6846b5af67d907257cc2bd539990bc2a0cc33ad2a48b46a9cbfc8c686f3f6d8f41536999daefeb84403a044a40492f1f15478ce1a5e81ebece2587c21ad02a25ee855ce53e78a6f7f7bf1f29d39521a27a76b4ffd7660a844d4fca2c7de3e666fcb2bf45a3432bdabaf24e7b444d1b4444dfb8fb607ac2fd002ecf863a4b08c368fcac56c151393812a3d1d9738c4e676ad297f22fa016554c53268cb54f349045ee07b4788d4e412566848a732ccaa3c269f2399be07ae6928b88b7012a380984a852033162626472428f164e5312aced021e936601aaa154607e42404b31ef77b0a61025808579f6aae411e00fc8f34ba990a2c046353af8fd7daaaff355321b03392aa8cb15be51ef533850773c9c9764786431a7e3a44c0b5b3b1b5269b6d8f5980f13fa314c2ca162237110b1298866e87e1789608197ee0367d4ef78e52a51cc728070f3749050a8ef7cb54f6c5dc5c75587e3d4f0b335a5bc89a6abae6c83a7640b7be363b4422680bf6e7e96a9730dd517638be96fb2a0164e4f5acce70bff6fafab2e2e9e3db3b6c391cf2bd9dba29fed053ca585ba1efeed6e934b616dfa2a4d833e9f05829b401acf009d373f92337a55d0658c47ea9cfb9b9ab9291f444803ecd4c3b35c2cac7f8912f11e78fc97dc9a020be20ec03aff325affc21c73e58a21738779a5689d6e99963600088921e1e0c6a33601728e4770ae8fc71aaed0f001bf776fca74bb953f09ad76f468cf087b44a5227fdee4c8c59b1616c153833f842ad7e0bafc3609d3806ce32b64f9e8aa1e68f5eaad30d337eed747b34fa6a2abcae4fca46cc0e778d7f70250e678cf76c09a94078a60298b50855928ea40681a0419f920874ff91d98be9426699229a504e0d96a95c539d158f9fce23360ed3c9d96604f7d657c2f1850c8558bf0e91dff797da9fc91ee5a6e304b45af12498e6700daa1f87a9926eba77194577c0d15fba3f465175ebc744ff7317545923129bab03193c0bb6f2ab642f0237eec75c44ab343d46850697445f7672f82779cca9f0e60e4644cf7653a19853c84eb9c619cd76646230ad2c83d14da73dac3a50caf1b5088c6265ef4ba66a66a39271931fe9e0c97b4765db8fa379bb82f5bf998cc3f76c021064e0e42f97313a413f72946bee6881553c72a3f13e146400bb3c5c29ff85f41bcf4bdc0ff382f2d39282e7ec48c700a4ab1a085f13ee93a72a0ab7ae83cfb1aa8d82ba58a1841b1d0bae12174dc770ea7b2fc9a21d71936e6e62f5c2a7669c693906703772b9923811fed3ce73ddec69e464f742e2322aea84c04643aa4da6e31891dfe11951cdc142f5c7d9aa9bb93d6805da8938eb4386ef2d09f9f80253eb8c1608a94449609758c50787ee5aedce50f533561b8838f48e8734fa942380063a280dc5f405ad35c06435bb489cc972a9d093d0051be0c3bf726670aa1ac9ff5371fc409674811826dd3fd51ab5d9edb35cb3bbcf5c0e2331d1b1dbee485b374420620a65604a0ed4a4980f851181d169845ebd5238bafbaf1651f613421c683a74fb8e289b0c36ca6fa05c1dbd9c160cc71660bb5eb19303cdb927b963344921d8fda1bfadafb367b0b1123195c0254992995e889ab224a6697d9761ff52a3485459bab4d47b1dcb1a9413039512a74106e83af194b8cca4f29953508e233c4075eeba14c87dbf461ac97a895d87692f546cf422b445e37339713b63238f4718f30f8ae067759444de29d7aab94c4fa4895542d643cab0dd940c39531f5fa393b82b6a9d55aa87e888f10aaa19520124925ec1686e7cab43669d37a4fd76d43fe2a6b871499b21db34a6506994e5ee910b1bfb3bc653c76637f6eda63193e757ac7bf5c48476bd81ea43b8734f43382fef63d7f3838cc1f881063f728e7737a748acf08b79a62ecaf5ef4983d0023a2551c2518e669b58ad8abe35d94227a9f1e9587406ea5d389a3e1378f7a3c8517456465798885c89d283a2b52c050874c0097c17bb3ed6c533528dc9d222849cfac1782c7df5ccdb2418e0ee45af7f2e6a681f60049382c91f824eeb520725ecda4278e17adc1fd1d9ef03d46c19548cd5aa6859a04de8357304cce7687eaf329b32f49a3ca647e0f112fe68b9103f1e9f1cd52ce00e295a88afaa34f6a819430f9ce7286b37937f0702220e9e147405657356a339398736b6d28e16353493d580b54c021f743eb0aaa65484b5cdbae15e5fc029c8b64cabdb2981d36f67e17679651e902145234aec5ac87c34c37e6b081612f8e697934381e4ed22f3f982dbda0688ae0bfbc2ace16f1e13767c4edebe83999a0c795ea564810a9435ed087d056655c8208606d0ab6854e02cb80bd0339ef234ff7fe5c861769ecdc5aeef859f3ed9fec61aa2a0657fbbd65b467fa31080011fcbfaecca53b0cc427cd712a0feaf1288550b72a8607d395a81689420320fefb7ee78e00ef4883aa3ecaa47e05d006beb4cb78f30da48ad9cb1c83f1025c7bf58c67d85d3163a430bfadede0dc839a932ea8c92940fafabc64efb0058dd3f509689a5a1ec8ac4ff12b5a9f587ddc24a92a0b89e2905b240b5ea6b6eb14c8c784a1362938e093aa3eae629d3006dce7616ac3a5b08de477465cad1cb6cdf8854583357c12755c6b81385cc8c62c23d6042aff940b9adf31cdaab4a2ac4b247bdfaa6d762b4f92ecb108d25088e281051a65302d027dd2e4101a1b881cf18c29284c520f8f14243403a69d216e8977d506bf5a8cd3d8404eeca060cbbed64a3d65d3d3c88270b6252ea0b7ae55c2e72e644eecff93a4af0988c14b95adbedf616619621d3f62522b65993bc2707555369abf2fe33479280859bb4ae88e003bfb6b41777d8ec318dc8eeb821111ef28635e9d0a05982213c670b62d27f855f46fae1cf7ac33ed50843f960b62ee169af2f0984db9c439ab971793d8b5f6e8e40239c3083474e9c387bb63fefb83a9a6e1bf03f458932309d693fc2c2df23fee485f75255c05f7bbdf7d61d5135dc281b2fbb331ea4901dbef6efd58f6deb9d3a4b6954a77a670aa9b48ba0a095aecde711a50488e4d2a44cd12df6fe8dbf36512a88cffb5c671d919fae6054cd8451da1cb0de42f760b2234a514bbdbbfe7231cddf9340d69ba1fe3b7f477af8265dc8374df6679f7e3912a114bd3405e291b6f0d1eb48ef35a252995a18e7e797ed6be76166d18ed6f323fcf6dc652aae0c0e0b0f8b7042608f85f21c0a83516c15844a1b6214fcc5be5ea9c908f958af376c2e63888a1995fd1ca40a4e1015f4273d9690e7e3ea6f7c968bee510e30e55ff828c061803548b23e7aa9465d405b669438ea39d1aabf0fec16742270dca4f122beb7563ccf1e0d5f261e776d101079b0cc68adb3467d05cccb4622af8aef673b7224f87b5afad31601c961e26d64488b80c640d5a2fbcdcb038802a61bc89170903349d45a36a1836a47951dc9e899c58d5fa266146e78fc4f88e076b12743639692c5a91e22d86aabcc634cd20a8467362230564efd82973d3e2e572923771f2aa239bd6e920180f35b8d3fe2f3a2e1251573168d9ae39b88e565f72037445e3942dd9b66b53c87ea03bf4ffea296df480a9a28426f78bca1162627d5aeed86bb4fe16b30b40b61e74be1940880e2101e518ede212db167a7e0bc0c05742f120dc5eaa7bdc84520dc3e5faf9a9a0bb9636f0cbcc6de291fce701d8e595723a7b9ef98a15f2fe74b62b96cb2b7f5fedfc0604922b28e2fd0d688bcbfbc855fc8c5fdd395589f098b387bd241c4ac731ddd919e026c0be9726979c7574bd2cf85bbb2f0027b03dc7ece12f01c564712c9b43bef105fe237763c6259ad3360efb4c67751c656e8bdcc3e467dbdd312235bbc528b54f8ac858352a2c382c81320eedef8c42fa9fc5f31ba2d2dcdc7e7d9258ea51808fc5110475ea2244f6bb9a16e5da1d9212b69d3cea788d1f49eacdec1f50bff2fb03f3f22566a5ab21832270d9cf7bd1ba3ac1308c56cd3a809fcbc5231167290d17286d24b7b889e5f73e364d9195c9c845ee5eab3b1f345ce11b7e103d2134a7f14c0ad05dfa0373576b5cae42a321dba3303f572df6e4ac372bc7368243af9156799b1b2c9186aeca36d12a6f5ed1c5c7aa3e630ff480c114e92ca0d7dd1ee356a4fb91d29e679a694071e513cef79b526f0ab6de1a9a288a5b9807db61f4581b07f552600d50cd69b857505f8b7062dc26db2f7568bbdb869b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
