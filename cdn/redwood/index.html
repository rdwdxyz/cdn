<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1696e24e13dd4a9032534ef3dd9483eeebaec337c791d7d734ae517a3eb3c254a6bb21a71f52722baa494f13389401820fb44959455c9f1b12550ee969730c119712bd3dbbb453f7fa73400463afd88cf107bcdadb8360f895e9b51edd5383eb44739b89b28bdb9c06421dc848381ac74828a7b491ef4e988416419e4a8cf298161e9e2491f3299c10c581b5be8197ce8392bab7533b8e86591922cb93e19facfad40ff74c943053474ee523c5ae65214a802b02a61acc9157563154e32e49de335fa2bfb3fa5be095f6ac900854b3b72b93e6528a940fce206a6954b3f0c5707e2207a4bc542697926cabe30bf044efccc39d73048a7afceeb8b0679b1be46f5a2861006ed81a171023401043ad8f46cc27240b00047547226356af1cb4b7cc9d444cacb788f691973b5bc02fe772942f9e6bc4ab4209f52cd79ac026c63fee1cd20cf5ed788a959419baddb24cbe80534f7281bfe94f5db433e49dd9b011496c42a6dbafc2b9979d09dbd83d840598b2bba8b9197935522e484c056ed0a943f6b67bacb0afb86887c576d09bab8838f2ec12dd6848436099244848b5ecd55742bae6e5580a1ff18e7e805f09dca2444e6bd3248723c8137eea3b2dc3165a436bf3b81ebdb93aa63a71ace0ae620892a43da58d9bad7f39fda6c04d42f12d02f82c270d925c25d58575bddd80a6f899a5dbbcbe0818ec6a61ce7c1d40eb561d22067ea21aab9376c3ef61015513fcd86437b4d0a881227cf5fa8bab9519724995d7bdd0ebbcc3ad09116687ceabf37532b0a64ea38bf01cc94f13d1a75b179d0ef6ddb284fdced6fc0705fed0e5a3989ad039d823de26a96574c42dbaebe1cefab33478706178cd8e786725eee86c35242f1e8220ff41643301d80fc3f2591c4a42d8f702a1768d849dd35a5b3899ad416ff8862170dfdbe98d6e9a4c166dc80651a68221cdf4242674a9eb4e22865aae7fc7250679718180c43d684cb4c128769bc2b9bec1a6c388a95e6ab0368d80ab23b53b5d98779fec13cb8f8a704f1ee57d001628c26e2fcc68878c83dc649ffea8773022c854ede9dd82b3267bcd22f915337bb2586e4a3deeb69612699a417cd31657e04fb975438641dabd2df710f477aa19b117627930f9c2f5fdc0ab5cb239e6c1c3ee4de2d8bbd59c8ca71e93ae3efc648d0379a65a5fae1f4f01114916d62ed213aa8a0443abd4dc8ea5ab3149d10af898a2dadc0b4f568abc178db82ae936403f84054aeffb1e282468b946f3ae52fc784b193b38f22079344413bca5b4b10c4834a288c9323c951f6053235d39d5680fd9920f920fee3a821d23b2f52f29edba0ae19a35cbb55650b851b6efc71512476edf0a7e21f3e0c67398961ee9c74e1eda3e32720d6ef578b7609fa2a7c29082968bda77891b4ed4710ddb8033dcb330bf7b1fe3582b4b666b7236163dcfc6f4bcf21523a60e6a2c74c04c0689be98aea5c16cc6b3a4948207d33cced4a53898e2347093726e302c155f0da0f628a03b45f1873a8f16f546b36012ed67421fad0d2d3b0c71f07a8a7f69ff0e14fefcae03b32bbef3478d2abfbfbf9a30d34e1286649c3f95485a927b29bc4cd5d96e00deec0c601051a5814bcc2042303c3047289ebbf93c19ec9561311e7fea587d9805281660bb73af77ff5c07509a4d47c976c74973b805301fae2af1caac4c1bcda06521c2ed6d62bc62b16cb7e7c122fb4413ddf907e6902607b1280d70841092d6276310ae8b83051da9746fdfbd5ca878476de7746626d6f34c0b6a9a88c03949c9952e71cedb30454661e4520acd2e85e31d2e5254d0390fb9eb734d62509a18bdaa371bd83dcb6beecd52f3a4140ff9a41d79e87c6a365d9f4703fac54c888c0559c5d2122ff7fffe7ce239fc5d576c8251fdfce7e31bb356e28ae81dbba89ab04530df349c00f55a8a660b5d0547e21fe7dfc093c552f2e11752d557458eaf7159403b103836001fad7226acd057adfdaa88b91fb481920fbff80937a38ef31db5fb8ea4a50b79e401479bbe172af6c4e2d653679e6edf942bd39b2526a7a4a50f3e0bf1f01d885d3eca2f002708163dae63c83ab9a7f804183e58f35726d23e02853df7eee0ef77f25e7ab2c49085736c4250f09064bc8cfafade9f96d6f7bce3255cdb6f0d4b7043c3b3941554e4b0ae0e23247a5a0f266b4eb936e5e812be5a203d9a2bc6563e070670a6a19371cd00ea15b3cc5997cb68abaac0ee06f9822c035f9e98d5007914f9935132dd355cec26e6d0b8e32e229d41b795f78c10e22b0149db51b026b8c048fbacefa39e3221e34f64c8f753ed6ba0e479d7288ca5a510e2841f2966cd5260a54c34a5962510ecdec546ab9f7004d14518a592f57f9c699fecc5cfbc37bbd5eddf31547dbbeed3412bfb422a3d99e7842d48689dd6c157d3eed4189c5a55c7f3d1813335bee6984e42ec6ade8049e5b005d6b56f2adde19fc4b990c7708dd444b74f1572387f9c0e5626563937f50ac56b70f69851d8ba6a17f47dfa801f4a3ca55d39fa586440f3e928cd2510a546e4e882361bb0da15e896a1f4fce2147e5f439d237319887fc15984728c51745460b98ed3851a133f76d7c37e25f37b91dcf3206ea0ffacdb6cbe41b64545d30512f938e74f8a1d06216cc031d13247fc9655f1cdbd85e9d93d8e4b42697ed6a9d0233a8c37bb5c30f1643c96e4c08c01f37bfb9ed6378041c944cc3976ee56b3617e8e3978de7f0a9a99dd12a95ceb8c30418d1e430eb0559f8445a17e8fe10eef89fc059294725d6fc4ac16d87f76774a03b0ab83f7b79f1615220c9e4c4193df86f61fd9a862fa054587dceb97879757069d9afe9609676cc68b70a77cc382ccb707aacfbf229c3ab46e30be264abebbd3e0f8e2c430fe460ae9885a793f54afc85d698aa204dcbc96c61894ad90d42ecf31306f154909583cf5a1c4ad3e6d7e91096f0e6721347bc698417eccaeb30ea90838bcd102c1437457c7b8fca9ebabc1c5a3759a3ef37a1ac76c66553812f4da646745cff2e34bb34393227055d50642cbebac596e57d49d54c3c554b189d7ee30bc3f054bdd92903cbc6fb6ff062e5e563bd632cbc23d4effa3adbb745701026e64c666ebe079530071a35e51a2a8aa8b25ec683cb9819ae779205c0337f4d8bed7a55797e3f06adc1ba7a48f6b0123325e4f44acf32e021e672edf8f5ccfcdcc64af87978e1d64f0f28dbfe3c92093b44f05d3a72c07392c58c0abf030770b270e15767d66b4be4ce88cca83bd4719b8bbf0327223f1eefcb1d2a45c31ddf416082ca8f9b011b9a37c98c87e79ec344f4282abe814386e430a037c32374e7646678f156610a211c096f140793c977799d668083144032226974f8898012c0a4595b80d5b7bc0b4e54e37708b372c641b60a8a908a493345aff5e8c92ad29bbd744718b741abe52d451871b598567f6ca7768215c78b533df4fb245e85c4a825b9f98bb96b1bad4a1540222ae3589c3ed420a148edb055ea825b8828cc5d00cfa46430a1a991e9935999dd5768945463a39f921244bf5da9b576e17c4b8f599402c8e0a2c0fdc6f11dd1e2d4082ead58643a41e371b2569c8fa03eca2d2bacb3e535c85b8e2d171d66e17cc2e714a717220b7ded865bd8011446b3012422e9176b2150ae3e66879f1ee1ca405ab61dcc543dc3cf959d33c05b4a5ad691631ced2cf260f9ce88c7eca4cbc6557f2c294f1230c5c45e8f2c89a0d69cdfc959ac6ce03d213f868b0a8f687899df47367cbc7588688cd56d22c0d751bd04f22ad76bbed0da75e596c860e678c04ec5f3f8ef405c1e94c4d4494b357e72a29bd7e344c285653a93b82417f48fc73677cd5c02413f534e851d4b227ecfd678595c13bd6a2b9907854eb5f171d39afb7616268ac958e0887d3a9cc4ef552b20438330926991efc4eb09c6e17397608d54726be3294e2fce983957625a0470fcfc5fbb1a082ae6d8d973112901bbca6d852508f0b327a73603ae9b9fc6db527ddc29a4ccbe2e03c64cb38a41e9dde2770dae75a69b856548b00e5c4d3aacbe39d72e16d71b14af28778c1f6897e6ed972e1ef978d209a43a52f9da18c455fa51f0349d685c23354cffbabfb0ece77b1cf2dbadab36e46368cb87bd3cc036c4d6d0e421f6d258658697006702c09c1753257138a1d1d3bdd0a91c45396a41817bd9fda181c82f5b8f77f1aecba35eda4ae719f6355c8b6b396eb42c8e9f0d45a9374d8e20b4d2334bb10a77519d7693434f2155a7bbe10c196cef3c4698efc8f0d96966788b78c31302654cd4f6477d65cafc6f6e4b89a81eb42b2d15c4c31e8c35eb757f2d0c97575adf6cc965765a5f8ad265ac63177e4f1361c80259750cf6ee9fad1c303b6e4a71fe8ad62be506f6aeaa895b3569b3e0f83ebc69c0724bf744cd9ea8fcb2a6f6d5271ab7268c5246d8168650a13ca20e6670a1cd0d07d86eb21ea836015162de0dfbc7cdab1e36bd6a15ec450375419e7e440dda3e7ad253962b6a8b383f8881b8d101d8ffe125b093ac833c262058448178fbd2b7681f8d501cb9cee2ca93d3bfd9656df75b81f786a3a2b529f8823cdd72756a6c9aee467183d195469eacbb671160a6e7326e84d56420a3994e18c712d893a8a2cb1cdc25faca8900ef51e37880cfa194182594f241686aeae1ac4f1edcc9b5dd85a953cd6eb9f959a9aec90747d0428b6eb844f062316f3794a1c4c196623d826adc2761b86b6b7e87dcdc44ec5228fe7526b2aa514d0891fbd2a53ae0d451bbc6a36846e9376dd56bbd74a011534c7d126d8a0466c98bda36a2e1d34cf046e635811c4ac6e4af00914a3e09796658045636a6f8b2c24b0ca228b69e6380905dd302b86d58345f4bcc7261e63b45e4c99b61b0bab41b12bf16b729107f4c7c11cbf223410272d7431f52e732cbb16f9a286af8212c29db74a53c53628bfe9c0114972ddde642bc4770217d1a6626d5efbe5122844c0fcdc0dd155edcd90a70e8c84c07030c4af1bf073dca90c607c0713d941a6ccbe0cde200988223bb1a304cbb838a15577a5c8e5782aed4fb514b54a7aa5e2e09427c623a603fe14ed8cd4501b7dc4dff0a4f77959cd3d2c0f1d415b0f32731f52be72bef50fadf8966eea085b5226f20ecb80436e47b99a22479bdcdafffbf03153f77f173facde8b6644b43ef456aca3ba8d771a2318b583c4b53798917b234b7efdb4553e337945da62ee8b12a9672c04e38a6dc5a04722a9a913d9ef8768dd0ff8d8c9313f3b2ca7c4c2e9ea94d32a5bff66bb2a979eacda229795888583a79a604b3ae57fe5f893a8d5e6810e94bf76e3b4f062d415ed7005c577742a08f5bae0825b61d411b1b429d02487dec728e2519e6590f97f287df024a7fb53ffe107b02a9a2062c7c8df592ca6a51a5973c1145ded84552f23147e9ec4be5711012bfb00400befeee0c447573703a9406fab3d7dbfba2ab3789a34639bf741a9ee8590f17759d3252375c3fc2c5ad6c19079cda8919af49f13ca548ac4b4a4e2134a94be10791811a6ef10f56face8ac32c7f8f510a4db13559fced77edc51f97a393033e0a8feeb722f5b077ebab336fc1e8ce88fda81d132d2485328d5b8f29fc2316bfb3d6567aa642643dc16e0e78275a68e2bd01b2ec306a8f343965015e7857555945ba4da923cf4871218e5c3c682ab2ec49f4ea579dd3fe89d683ba5753ea77905af6126aa1fec6a5427bda6a395203ab9459de7892e42dc715606396d838ad05beed0789a5518ac88cc2d9393c2e0529e5103899fad92cbea6eb3e735179e951796825f379f1bbf193e14a5ae66737dd1d08e3557418c2a635b3308f8f2ef383287024243d922523717bb4d803ec3c7b4c9939bae2c8e2b461baa30cbe7f31869c70570c6569ccd4c3ba105a05fa082db1e2a0fd760c124fba3ed6f8f06189c607e6663592836551ad8d11e1f47bb406bb18cc61a726967ee82d7008f29a375cbe325d75278d44262c2cb4148c71a5ea3bd4223bb616483f55b47e364c040c13fd2998381547dbc576da1eac10f3a984d571f15d4cbf05bd438b7d1ef9feb5d99769de4eff27af9baa849251dcb6faa05f5dd202d4cdb340c7938fb6a87ad93ad3f4d32d738ef4159f8a59235ec0e6ac82300ea12e5dabbb1c6e59ee1fb50898158e490f0d5d997d1ea14af21e26b1b9b7fe6d8568c87845c527a41ae92c89fbb271ada03a0e9acd02b0752930485b0f06a5be0235130c961a43a8f6cf75bf4f0ffdb5997c45ca4b84f47a6d00ae8b4fa69d9688474d4c3efd8c4205b9ce5d05544229eb535b5470f5a4b51feb415aee01e8b463fceb390ecb404c472ad7913661b2505b70035e7b3bbb067de6671d02b550f92ac808c3f6abb84990f3bf91640d2ceacb026cc96104f7fe2f1ac6194f725464af5eff57d6cbe5b465594bffed1eb83b09f24a473de3aa2b709fd6be1a22eb3cb27a39b7ab5454d3b42646c186cfe2238b1a262cc3471913871d6c262749444e1ebbbee10032e0b729a74acc2ed29a93ebee2591576852d01d246f24b502c76c577a96986c763cfa083898352f30c767872f17fac4a04313cbcb177083a8f9d7e503dbaee39b7efdf92ac766c7ede7e7b22ce243bf8115a9f797bc3720f26fa05cce01fca7cd4b67d0071826cba6cf975d9ba4fa5b08b5f336e165fd236e910a5e72b863bf74001d0f792f8f13a5f6748be0dfbb1f9a5e8290bb366d96e0a83b6ac9c62027e2b161e3f5a36fb3dfdea1173a5fea03aea9b3d768f48ae72ca98262ad2e3204dfcc6493462c136b20fd1e9696408509f11faf10889c3862c5a8acbf2aff7878d4294b44515c45c63e0b48f09fe46be6b718e43a463291319c4b81eca0ab1c01deea560901368fc452275f909b39bce8e836ec5b7be536c7dbb1c1942eda30afd5a2477f3d124bfeda6a8e765bcfb0d0c59f648c895c15e4ff2a2c069552a826bc103c5ace3447ed0865c54243978766f5962c6e0edb4916917cf1daefcb80771589e9c4cb9934ec0ef6d0c53532cbcad5dbc2516942b4b3c51fcc351026adb31db87984d70fe8ad0f16b7ed37dd12e7334f5bbe3b54faafe0bb4a9f16c66d7467983ea6fe3ac40da1769dfa3ceee05126095814ff7b57e22292b3e276883f016f0e671fa4af9a6a24975d8691ad6f6c21a1933cb01fa842f4a669600ce16808f2cc4a2e8aa49952638169aa61ebabf5728af23fd8470737415371d8b2cd889028644299d6680c9c6ee8551a83d81c3bf7312b36bc1c7c4146eeb930ef5d730a6e90d5781c37acc690dada01d4267dba9932d6963b0f9c26fe898d329c83c2915ffb35f7c2c946f8774e9877456bf2ba9950162fca390d023d3fd5bf3b408e6dd6ae7763b97222820f3257871785dd462bb8b67f890e54c3f3d1cd3bf820aaac6f2194245576d28e20722c3da353a8baab244ad74ea0d7b62e3ce744225cb5cd48a4e985ed5a8cc32880ed307ec9663f3df86766bfe1daf6d692b9c6e024fc5d804febc8327ac5d9e9d59b81832f4d822ca89de2a68a0906575a4d6041c16980204b546c317e40fb91b45b83e9447fc574b91b047b8138a5cc63868118647eeca9ea34fca886b3439779d365422df1d0f0b03a52843091c83f4c727862b6366d501b9034698628acdedde0e05347a8f989c7840392eb34fbe393a998be81e8027e1daab09f62bcf5d91edaf9b2ebbfa67dab5ecefa4729e270ad4d1b51197624a26938171671ad10ecdbae76b661061b86124db2cb0c9b83f3ee7f106e3dcc62a9603a51fa893f2837500c59b9b93635be7944ec4189040eef80b7ae3152d7d6108560bccb5fd3b16d937f672ac4549b9a1e0cd7361856c0ab79bd6b63d712fa4928f14bda5a9206b251cd69d306ebf15c30a6b3fe61be9bb21e9c72071d51ac26ad23c99db88e080d4ce1705d2b21a432b0863a3b8835ce7218aad11c1713676d32ccfda88036e5c30dcfe20580019674cd73f5663f722efce1eca51c6beab24e39b17d1b47840ef8c09fbdbdb7ba777be22fbb10cd3e9ea5d0ab257a10bf7d75d35b1bea37c625b05c99c560cb18bfac534ce8b474483113dcc68345818115e11732d284b96ca3415cbefa3be0b620ddd5cf60c3cd446e167ddaefe3ee5b468704eb257191a98c981127e6b7619c0f388d70cc7bb171d6a758abf2a8610a2d517f916866c45652b8e0c628a44c220fde048d092696a20577cefc07fbf798524d759a51348cf5300abb3786d61ca4ed2824ae80672ba683b5d23f61dfaf1f9f837463836623a2a017a5a065e9f6f00fe0a27cd584adf13c6675674ab1243d8a8ce58323873c9aae05badbcc9f5ad4de9889b0ef341abbd702ed0a062cacc11e6a878f5121530c3d88368def72b77931c9a9c04d8a1e4bbcb15acffb70c92eb9a587915245f21e79f8349495977ec844eb67985bac8a0f509826bbe120980ba40dfbb12d22a54cb9f038e3c2f56082834fa6242b3f723ece9c266fdcb8bee7419f8e0817daab42bea85647d120b8f7f18715fa32c6e154e4f6b4194471f2ec1315beed006466f202c599dcafd8f9de6b97fe3887da00004a758e37372c0814bdd92aa302bdddaf6319369e3763dba7fbab6deb257c8037d4eb7a56a09704c34042c1a07fc0047f15fb260605a5aca49f264dfa47a99727501db97a76adddd09326ffc22b9f761df126e8d794838306e2638fea702a9c04d1bb93ec1e62666aac3baa607400f31a06b4a0bc154d28f8c57a08e753e73a922175e5f384e9ca04abe8f43789e6c4e76c4bb2b598082db34a9ca414c1bb17776436d67d80487ea4f25bbe336fc98337fc23c6374608270aefb7b466be52d8eea68347700217aeaf2b550dad27ed59d402bdaca33b2764ebd19d2cc9be06b4c50c4c15f0e80dc22098c4507d0398285b6018902790370825d5ddcff5a6c60dcfa9b672acc762115436ae6edefcdcf49e51e49803d3e07f3ab5dbfe3303b30145a0705d03943e043baa36da789a0b4e395a49326b488e27ed342ad3532718f8877659a2719dd1ce481bf232784fcccdab779760047869421f7fef25c0707f403e8adc70d5e8beaf2ee3a73a8ebbdfd6de6737047676c8104a68e1b3029682b02ea20ac223315af8ddf5f5343007fba3ed9ed24a8dc1c9f00871c4ef79e8ea30e654ed3a99b3264415503e87e93feaeb6d2d0d185ae040b8c2e9f41799c46de624c666665e1a2a74d45eb514e81322b05c65556ed6eacedb2d2a3101e5714ae447e900f0db864b958e1d2d4b61fd621eb231b3f0253d297549770c0dd24c4550a25c843eebfb129f426c2c9268e97938f64aa0de3fa1a0939b10225c5d426af5cd7c0f5276575f9117c140e87220f504fd84cbfed5533bc063c508aba56cf6c8f1f8ab47810c4268faaacb7b362fa7bc362a65d0df275f81ed8f829d4a06e05bab87ffca0aa224d02ae93351f9bd8944c9343931af560a6285afd7088655d9d3a466dd36875e67242191d52ac3cea8739926ec5346338664fe344c0d7fc35b93eba3fbdbe0cb26198cccd88c55edb25767709ea2a2abb0bbf52a107ebff1ebc22833150e68071f6be6bc5e97da987af87cd2e10cbfd4e5381fa1e8410a45fe74a93b86561fe8bf7245d603657e69da874f43c5a10ff7d7bad15dfff9ad1e061801498ecfe87c7b46f068b7cc846270f08ccb24af2ce1544887d0a4e9b985c852a6515941e6deb64bdc603598946014ad931b0bfd5d7ddc16afd3e8f39a92e42ac60bcd2cca5fb7285e8f3678fea6dbe2ae6e9196751bc007954a3a871341dce1627df21dfc6f4065f72f2b45b95835005072cc5f6a578f64a46c7c31c7909371ef7dd929554e846b6701c325a00418ae0aa5aa0e190d523b722d9c5843cb042f60824c4f118924c7455a7615ba9ad520ecc90991ed2fcd45e22d4a43ddacd1dbb84816e52f1328da69bd0b943b3bf59791b2fbbefa928a28b9bce40f94890154f09513afe3883ecc1b86888f66b6de8164e91a6a6692338797cb32c25e13359c8e9b6a9ac5175074bed3b4ca32ed33296f1e826d486c7ad3ccb3bdd3fd488c7dd7bea2755d5c2d21777fed51d14d879a925ac095a62e5d917bfed2b0f6e8b4ab0f912903ee5b4fe788f53e7a6394b3e4a4623fefdfd626d8ece4f2347247d4b4aca9a6220dd81fd1ec7914a6c0a6b045d027fb2dfaa717ab25800f5238e7bc16bb954ebaa06a5faa67362d771bac973e401edfc9e82178351a29bcc08e8d2c1dc6d70d0067569a0f490ae31252f2a6773ac05eb2a7bfe42a60ca65138c55b5fb11c58e5ba3e54afca58c87f4338a1fe3dcc0a8c514a14f5765952b76b53897776b0c54cce4348b54e3dcfdbcf79bbd3ac655eab49a07d93e68b37457c2badf14d184c927ecb2016c506da40f8a05a987801eef47fb1121ad9538803a5406f99257a402f3c19020dd238a26a5dcd3ad0eb864201b7afe25b960211d963fd72bad2263b8f77561a2e1668bfbc2ae3b904a9e12e6e76f82614f51dbdb614a20aceecd5f722b1479466c214ed89134ee05cd47b441bf0a109a520b93a9711b23777b52837c7c2d6cfb0fce05cc6787d143711372de8562d1b22cc181e28e7471f82168e7171c717549140996eaf70b217b17b0ab5246056ab511e825c0fb827f774a82e67639e0c10ed6da7bbcb6c1ef3ad4059bf6d1595741b193b7eb829bcfaf8de1943d2bf6da3eb221b3c258cc7aeccd951a61eac04f2ffef679d671cc33aad04c98eba171d229ea288674f358b70433546061c379a98f76cd399f45d9606dc15c6c601b184beef1ef3874156000856bdd2a6818f35c7baab33ce1fe36b867f62ac9163f71235e499565497de225f39064d06b8a41295095bb7278a4f91876ed008c19ac95b3d7346c3e6a0ba3b20b7fbd1e97612f21d10693b5176f99b7467b3b90c2d7e0719ef753e2d23c68e2d111583a1db60e6899f04bbd71f091e863b62a389013b1440a451d9996d55e1d4aaad363aec28c6d7c8aa2e234b880dab1efcd4a6e9feba382f2774245d2d883b8e811beb152b5808f1b9d95f633c65f8d879b6735e595062f965ff0a877c722e4e5694c9455f348d8c4df83efab905118c465007ee55b1d05883b452441f53924b74e5271330e8fe25fdfce8653e125ed0285f17ba40c16db994b8e1233970c09a97559bf1ca44daa5b41298f3ab6193295cb1e0fef96fb8eaff5f59719f3457e0ad56cc0da31c6e57cba2ed7d25e0f14f34a0b31ace73eee4956262d8c4993801bff47147bfb5debc7017854ff74ec0d912a59a097d9689913c0066b76c4e2e21ad6106da0cfe107731bae2640b2e4df588b2051e12b9940890c0ba6b1263d7a5f9bdb14bbb1291aa29c02e350194d64e64592a0ff94065a7558901e8def35034f48b752c647d7ccd682a875a49f2103b027e99f94f82d41e1df3b235d98f7270717000c66fe8295ac41533436304e44d2d120af50adb6dded2ea61795a2eb3ee971775f6ab4491b9a978e14096e78549d8045f43ffc630b41de5b13b41939803ab2856237dd5429827e16f18b37161e41a2148d74da15c224675f7e60a9005cf85a1742c16eaa666fb4249af15f8e7a1e428913943a2467a4fe3a1dee802a8eed71599a9a1efda31b991c7939f46d520d81779906ff4d2a7fab4f0a895e19e5fa4935c23d828a67ab42a59108780327fcbde6be100d5ad4941b20131de68af6c56eaa9494b52735c795ac3a634d9debc8f7513d1b99b98054dcbdc2dad448f9d5ff12e006f652eb2c40c58355a6e4304f2fba20cdd067c412d12b5bfeb2c3ba0c567161445218e05dfd5a31c1343658b496cfbb4fdbd43545bea6670f2a6fb9e2de73e0b79fffae59bf7fc2634b4969264c6b9abf85e2c03904232335590acb79968a31a13e6b669d27f2f7767e5021806f96c251e6df29a75fab385a25a32dbb8d6374345b5bb198aa3feece7a9ed639e19ec3aeb578f1c109942214647d614f3da4c7de93847763987d442d3de06678359adec9a1d3756602ca76e271ae92130a37c57f31617e5b17a0c5aa4c1b284c4c12f4ca4405706cfd2265e448345f004e59e0d705580c0c02b3aa84b7ada6092690a86f1eb0077d9f92b4da29089b51448a46bcc3a3aa06696d69ab6183d355ee168f6f3def6a4aafe416401d46ef0e08b71d333a697d57bb5e6beb1bd19be9012e8df06f1bce4df9128c1ce02142e7fcec808e4558c299c9c7848bcc90b96b806e4f7ec4efc97976e366501bb588570d29003799f2f2eb5b7c40c674878730f5137dbd80f5db6b0d609c889cdc3042035ad9c63110ca945191a85ea764de0a0aa918f01d1299fd8081192f85d6e4ae19c17b7dc0b42d8bb6b5513f2535de49a3daad2e0d99fc41849bf47d778651d8cba99345e20f217b8b05e080659c747c7a8e6c7aef44431d370e5f51fd2e508a681d7f027133923b98793c27413690111376b51b98c2ba8c81f0fcdcc84dc39b469bda141f9522f13879efc52b09f0a187d7d37993862f38480a4ccdff98da811cb1cdbee1238e0926c214c33e7f60bfe953b4863be985b13ab2835dd23cc368df1d015725ae5dd2f1827676600f2783a64c4ebc31fee0e6a6434230562bc9aa3747c720a60c675b861445f7b79a5ebf5ef6013cc709f6746ea08c20dcef073e411d2f56b35d65cd05037de0dc9aaa4da8983f7d4565be8088a01b1d86852e4b6835e7914a782053afbe006dd169e245df9536665237687c664dd89b836b28916c8d2c91a7099de63036bb26440a4c5f0892c4b78afcb50f6a8e9b2028ef873eb0881a1ab258911f742399d32dc1868715a869efc3143c9e6a71cb11d34339642571bdb6d9f67b178aea823bcf2544a273f53916c2fc30de811e03be91d7ffdd86ca9367cae014c7de0e75177b37061d033a563d6d3c5eb0703282a4daee3fed46f4ef650141f924fb3de147a3c032a0832386a0f8457c92fcadc514074be80872ee76e58a35bc359ce6dadb46eedd7fa8435302c2ccf2b7bd6334260560eb70adb6184e399483647fcd3b7393d012c9f201d7146390c37f5d500c5e528588de31e4a8b8ae39e96a8a7773a26106d5be41a35a22c3e27b0fac58d02d2b1987e9fbd7ffbd30e9cb8ebebc9bee62f955e0997621ffdbe5b2d7a7c455cfcfc14e99c2270905111b555ad0cdd82a9755d46b1790b58038b00a2c9c1e05e0e1b03962aecd9fa07f4913fd25df2b09186aa06f5b561998bf554650bef623713fb16a7148858012defdac7294cbef6b8da4a950ba623ac12cbd9a7b9b1e7f7d2cbacab8e82532253e6ca2b3c50950f3e7301a0955e8bdb68a300121a58d7930237d5aee75bade3058adc2d5f8f4c7e449cbc9f229afbd53f1795e688a5b0eb2c1784e1c0236fc278c38d4ce9da95060c041d3283ca7b0c373c30412d2b39cf0ffdf39979810709ad06a3ce2f61c10a661d81b16405840fa0621b0ee689800d73ec36c20c5a5273843307b2b30ee6af2b74267cd9ee7ebbdc1fe8a524916600ff3655b1ecb7850794ab5f401d817bd61ca1cc67de99ed184931cad624a5a35c4705e954a8a1d5f5a65f1c9f26d479fc2e0639e1d1280c7271f151f64e97161b3d5bbd992ae41d17fe0f99f582ca2362d974b75cee148a14dbd94af23aa92601a466a387bdf4a488a1fc75b4eb6a70bad3217ee2254c53b831be39a127dd6c22e32f631085d72b7f635705a0f82cac6c942285cd04a83020c56d925e062cd339390527a93efc93156023880180762ae4387e4ab837033281edac047918220a4f2a787adb243463bce2c4e3415d795946c9f2f2b71094142b48dbefb5286bcdbaa958890854b269f5e907f63a8d9713c3eab3dc043ec46aa0927fbbc65ea9cadd5f4767ad9ab8877d20657401cc9e8af9c4abd897d3c6bed15c5030a5ca643e161ee8cf83a912fd28b4ceb1270b72207a4a819e2b495a8300c739083f192a227fbe62356b041fedc34f17950ec35ee3a56045c043b796177a3cee173b2850535a3e82525bc279c6e058b23e00833d7e50201f9f42fc5dab40f8cddaadc26caeb311dc68defa0a6fc95a777f3a128477fd6642419b884b5f2ef8bbf8cb804b5ac6a82751e877a1512b6b5a8ea0cd7cb6a9f8389cbaaade21b76c511cf7e0d2fd320e66cdfce907280fc59580edb8e9a256a448fbe0f90c481d3750c5672e50c6cd18ed4cda6302f7faa7cc91b348ba4ee1db74f504d56eb54d9ef493f0e561237198456b2ee89814a3e7519d234eed5950825441474e14f724e770e35eb85d9e89d2ad1d2fcd5fef2f832b624fc50329882947cd062e94e251224a8ccfaf8eefe309b0145aca3fcbfbfe346d67a3232205a6680abfc5707033754545c784aff1aeef62ec27e30c76d1c6c5f00d4d8b26c4772d813f3fb8c4e208d2ac7f4b242603b8c8238b4ed97e3c45710ccdaadcc144c18e44b614d65a75ac919edf7664718cc1d5f2e905b3f1218aa6e236f410a4889b5d3260d8d842e6b7f5cae96097604caf9fec2af62f1f097413fe931eb81e7837568fc07ccbdb15a1e8e7734df45a42e88163bac0f67cda3f86e7bf0d049fda868bcc04a756bdf93097d8237966cdfb730a5f8e1e769d85f3262516822f5a44625b722670a71f8491f8b00173ca66a107dede227e2d0518c415456e33a8ed8d4254dc33f2dec5f73f7e9fbee908699180e60e44335627960a798120f124c3495e8f4d24876448736b29943c7225bbaf764718a841df3eea217d32999a593984ad738128d2370b50b1956d7bd3b0f85757f236536e1af6b784930315d7d2d30078e351d83829ad96da2218abe1fcdbb3253a6adce19a8bad9275a5adc371f68ce9da7c86bc6f6cf5848666c94df6f5174eb2f2137710f3b9795a81bd8d9355a7825bd7e473407236e01448d954411175d13b2a0ea03875033bd88151dcf38d7883c0ca802fd5cf998f5470bf9e2544a3a1f1cab1267db2ae6718aeb75e32382f3eb82ec2a920db76e4807526d053b7a2332ef0b56e182726aa3649715148ccd4bd298d1d42a2e389fab31d0520f04a7dec954a1c155e9fb567ca63edc89a59a1729ab6c3c940b2b083d72f8a8a55ca45b10da11e96f5221dcc3d2353426d21b774dd4856bcc85a427ebb09cd271017135fb4a57fd23d657dd58f59f8eeb79d393bc4f60159267ef7960069dbe9ab9a2a1324c510912b093cfbd2d7012ffa9f234a20fc6442760bffd389883fba82eb204c54121162881e38282191c748133121c49a0a90ec4bdca5ae3add714fe0b402fe677640c5e52a39735e225a5f3641cea0133513f82ced7dec433545f574e47e7601b3d28a69dc92ef3b135441b39db3da1e4aede3856dd10815dad3667abe7ee206de333c2018c1c20886144ebbdd88e8e8ccbf069446a2ce5d513a54d343e985855db19fc35e3577666dfe114c2995f69ab65a3504067238376b7d17aa9418a70f0140e0a50e05df588d75164223b395e491f22b47f13c1807e769bb63a5e28f505187df78394337929f8fcf92d368e0bdfd474b330e961ec79605ddbf4f7a8955cc97cb752ebe28e32befe4c0ee1d695113d7daff97acb248b8a0b6a543024fea7de31169626c039be1fef4377e5d470a41148507a15009d78e87c270d114027ee0f4f56defd35687003a13973fc0f08aeeb8b070fcb60b3cb6a3607195cff9740765de05de1a62a059b52fd62ec6a9d797f687b7e6a5d870db6f8d5c95dc4724970850c7c2ba2a4297c17ba035af08aebdf61918cd138cec5b14eceeba8454e87fe36ff53bb671e43243d6a5e444c291f9441937f46cf82a313172505872096e35d8ecd702f4f2cab4a82aeed59de13bc7cdc733043cb61717865f9593c1f7625d0c10489a8bc7ce81696971f32d44b0086cb360c5ad5b727484d931db358328c8c8397070d0fa90e95e58d8390614cf60108032539ef7d8485b57071c7dac5c3f7d1d8fe540692199fa85d3c394a07acda556cc8f9136fff4c7cb931be51dc2f2730de2fa0d7d4c38b59c48e0074ebd31c5424b40ca6c041ccbaaa2e2f6afb17ac529dff3f2664559b4a26718ab5ba88824fd54ebc453e5757539e80e5f113ac5dcee578ca9c80db6050dced00d2f88bf12c60ecf75e3894b8f4af919f7f9ff0a1f068b1a410dfb955896700be2866bd10776f07cb3a91877d95a7772b701bf24cd08e669fe8a89b0f93a901363582095e067f4058882b932895e72454a1b9f7e349d073f9e14b41ba302ad2ea8365af78e469eb38f66812fa7e789946dd484fa316fa27ec7e9d8f792fe7ef3e63a692e271f92d5a60a96147ccd5163c3515bf19852ee90ebf09314d925aafc13dca20d4cad669ffa1db5d73e4924c1e5869d749f514c2349c604298dc91e53551304f1c68be4c6950cb13859490e95d49b5dd66dedd3029b2d874632825d772099bf3386412e5c70e4c3996ff3d6aa1c2e56054e959bb2ba44856db4b129e46c87c84668a946bbb984d416b31c08682a7fd89fbd747be00c3edee5ee8d65a6f96527884f8da66e05431fa7446d20caba0c6f536fbe3ce5d26d6f568cae24725d830960e4b48725c1cb1fb7505d05a0308a3029680bd0409f1d85d379656fb8488f27c415c556d553d87973e6dc9b35011c6af58eb97548e95ebdd8ecb0a80613656f9d234ecb79450349ea7dd6ce83c3623d23ad37cb1cdc54fa6cbd4b0be7b096dd5dbbc57203a02042be1534200d71be9fe66f4844d677364793c453b40c0205bb529c19379d1509a0a056f33eaaf885798d90ca3f61c400b99a00a1beeef911f136762d4ad3e5dc430c09c56c2b69a4347c65053cb09f6aaa81dbae1f7b331957aadc13cb1c13c5ca97e11ec6704972c343d1fc05152e42f63d26a76239a98b134950c695596834e4c57494cdde117084fdad86bbdeba5913c6a0424371a164802b0db988f4f133d54a5a5ba1540c92253278457e7c52b5539c29271361d552ac8a58e89720890518e960bb1eff6521c2bd329021860909503370b5b1c87161bef133f7df0f5a724ef97a35eb0afbfc9ec174b9b4c20bc5f31e51aaae174f4ecd5a001a4c1f66a2e8ac6d0088287f4080007265e83289ec9497be41f8ba499358bd8c782d43660bfbd51d7f60409b32c25bf7f9927bf63b3988719e08ff5e292692179a5bba144cca7442e905b3164aee8fb7b7b2b7734f56bd798dc0d5b4139c5c9be006e0774d1ac2c2cc9db7499453f7caa79684236059f5f5f71f57c627479a10b954b69bbade2624290f1cae675dd8f85ae9bbf0178f41809132d9145d90f1805a4f977bceccfe1a5b84654d9c9abeaa2145b708d9163f8398c796c976a5d32f7252f5e6bb8eb7a2469ef541fc7b328f38fa730765cbf80c0197bd9adea8dc685f69fdbcc0c65f3882c54423729b0ac97a8e921060969dbacf220bf6dc073c808755f79503a6aeeeea52094fb2ddca9832c7fa7d196de4d2424983a6d3b5608e65ad40b385fea2d4fcb540ee718640b053f290d4b81d9c6e549d0fec57578944390abc3827a824b5d6adadafb2d68e2487b2684bdc7aaaefe2ea4d34deac51ec1d85cb3357ef8be29fca1f2827c68ef0cf54f626b33ae1008164291ed0506584ef49268d21862ec5e664949a8172f2c44a6b2a317be287ca757fb224a03a14d6b172e32c9cf1e4f40d2e7c74918a7a2e7a8f873735b8af7d2bcb4cdac9ecc82d6141621ac75295304f81a030b2e7998817133e55d579aa606f3c251db654ed49767c01ae53af5b7a4502f89b4a221dc9dc9b0ae8bb5156130d0846e01c0c0b25c482f7e5f24f5a4d72524d7d96579e405a13553882733f77cc84c60d5cbb993a5a2722ecb9af2854672d8384f8b0fcb5e35e561bcfd487424f4230cc28d0301ce9d30dd501ff29a952d07b4e7349f0c37ab29cb0385040932e84a0671f2b2fa4ad189881055898d3ec9b09fd770f42c82860b2dee00e549b7194aece20","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
