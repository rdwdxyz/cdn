<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54a11a34057eb9ecde8c4ba5d6a6877bb943197bf814adc93d91eb7d4bc4f9902e5d26d32e8f4c026813a8f706ce90813377b9d9435b36f2cd43c644f7663b0a41d8d26bba3f021a278c2aa47a0afc46fff2ea689d20478819b1e5f5cf804e6bcfbe23a8b84d75761e0781b5673bf7556bbe968af1dc9cccc9a2fe73ab6dc760d3c86e19c11464f0372f9539ed0247f6f9d12d3089633c552b6efd979a0a22caadd45ada6d952f46b848c824ff02ea4e1a5749c6d1726b4423b1b8d7f417df4444c88e119d7fa310cb8e7de00eeb5191cc90535feb80ddfffd2e82881e4bbfbba0715a24d91b9bb67677e588bd0417973fcab2042200f1d8b5be21e355c7db99f4dc590a4db9be9153cfd62046e83b0f07dfd7388049344a1bdd1bb2d97985d794e85bec2e790c5bb3eecd4cafea70049d83671fd2130af34648b76c802047567c2cbe47f31cfca23c3973add9a7b5c02a1d0f0cb7c621b0e9c8331aef08c59bc63a9b59bb01a3197314ff859a4b8b8f060339e0e9dcc1252da92a31f44fea4a2908c5d7a2ca78bb3f50949c0b1afbd747ee2be569c6da119a493486c9b8ec4c71fc42300cad7508ebf30ff20e8e706693982ba316307747a725cb1b89361ec6bd921ce0d44f118bdacd8cfd9147d4f22a29c2e5e58da95166aacea4521dd0f70ebbd4f80bb1a659ecc818a9adac5b4d087abc443d5e1be46256b3cabafb7689f75f2e324c5080ce84ce9be30d3e84de67ca7a7af36fc852e31dc18278061de79681df27bdeba338c9e627e94ffdbd016d677539de99eb198753f6a74d043d7f33ca682e5de96dd9bd61fc1f0d6f22ff877f4d45dbeb8f8f9a23d6c804e655f01be761f8f32cbb169f3ca2486d0d8e81ac246ba9835549aad6a1053f555b2a66d8874ea9d15606918eb48d3f6782845523f53cc35b5f32c8e60d1d2a53c7b8c05a38c8d1407e85e1ec8deb63ef8c1526ef39bab5d0ac4c55d0ba5b435008dddb773b85c778b2c6b1b639d7e6575e0cf7f9d13672844e766047f6605ca26a4db50784ffd7489357eaa417cf7834637f8c14dff8e14bc6b4682de71c71af60ac28ca7715cad20c757c4f31396469f758d31569074a773e9ef35e8dc996691e70b19ed343bd6967b746c76aa48547130f8e1bbacd899b2a594a3e15e6e9d204479678cf0ad001fbc6c81583feb4337c2ef97deff9b8b16a42dfe2c67c3a0c0ace9919558c4cc45b97edb16f5b025601d3302ba839f30c34dc70f1ff6018581416a23f3abdf32d51e5f797eb1d142dbc258b7627e74beb56d9fdcdeff893439b58beca2b415a6f3685f24a256c023bb8b2a1dfa666d11ba1a54ffb8f05a93c1c36b7279c4495d07c3d301fb1da115cacc7b6241fd041586af9eb4b0f2f29f4e48d6051796e9a0423725b4641e89e5b31584366756b05c0f02b1a89e2065145504657a1cdfeb654fc4400b4c36d28f869b192771daf754d5aa57800d06dd1207f2b302b2dc628c249e537347eaabf276f7f407c2494a7c5e777a98366ad3641aa950f69ac48afcc83c24f1aaa1feb07f615989f32abd1951f758694e6282e8a31bf5e8c37a9b87d705c155b9babfe165fdd46d0fdc79d0882e7bc02b2f711c109d1570c5d43634ea1ebce5c314be42b8b22d7c651bbb5595e4ab5daafaea1543f4be2c6ad803beccc528e9e116fea59ec5f7a1f6207d56370ec7a55cda2934969798b98a1eef334a8d0b172bb6ff68bc33c80f848942981f9e52483b0adc92061bf8ad068997fcb5b3a37f005207b534feaf2ab0b2a58451ee6ed8b6bae9945bde8a59d179888acbd57426150c9a60fc39c40c531ffa41e5adc48d643bb9a5e8666ec38d04d4681982db821dd61e1da6f03668f96e9efabfe5198dea81a1a0324132a721fa524aefee623ab2da32968fb150001e6c80ee069677ca5a22466a9b53eb090d316903fd7449f72d830c327e9f4679f7787730f77c63bf28a9f007eaf4cae1b7b5588ee51e0d308aed81b8e897bfcc05a6f1b8151edff40a99dc0175197c2a1203bb9df23333703d0567223975463d37871b1e80192b1b994230ad24801bf3726a173c3a218ce68c35acf39135a66f057de012815802b0ca64c8a4151d194c19e553dabbbce498b45cd22ce3f0a11758b7de20244515c2bf398ffe24ec40275a32d9c5f5af355026dee1da7e74c85f62039d983877e1b98223686675da7727f43f0d9270353a3bf05a743fb6dadaf351d04b09e68a9569929ff921ff636b68a84187697df3ad0cf5c6365ce3d43d2fc1e085b0f1e5b5a8cb6342e244f0a0ca3f73de35f533254faf19c90e538e87f2fb02ed6a066c580cab921af8b018f3b6ab9df5901b4fff608323d7de2ce630f7f536c46da8abca62426ed8949334490c66ad522c7d54c704d36c5daab4bff0137474cc871f76105e0daea5fa47aa181ec4be1951538945b72e4ae00b5c0d66cd0d02746226e88fbe53cb1eb23f47ca2ff580ee21063c776f80aeb317e8da28227e40831c1a2e42a21a71bd024af7f39d3619e0579b49835ad314f5b6d03b6120fcf28364dd557b137bda46bd78ab55e5a666776c5f3f7b9feaba307ca5a9d94fdf84fa33b4772c5e1bd2989a5bc2bdec516e06332097a2a25b459762f437d030bad52392fcb974fc1e0a59b69d26279ef8f712ceb58cdc20947e8e3675ac5bf87fec7d785079e5e7bfe6f311a0ebeb4b332445e9e7fc0313ddf9dad7e59defd3f734cc5a31d3056c100f6501e8b43217e2e60498fa16330fb5f1a6cdf826aef44e3a8fd495824567d69a56432a7cb3706675e5e3e014f3be4830afd2c50d4fd73d10f2a7d57dd66814a5302def7b1784e02d15c023cce9de6573e6fe39ce4c90d0d1bdf7855215e5ac84ca6d9e562e2c344f765876b3f778615081dc3337e11367834ae7efecbe9596716fcd62f7b9cd517e9b8d110b5087938b01f04a397a359a45e67b3c57244013390016687be81cabe5490ac95fe0d316cbd11dfcc27b2de658547440b2c7778ecca3fec2155384e918db99ea26795442915167c029725b54530c3294f08028c1346614d9c8f76d486f3d3d6b2a3d0b93d8afbaf220312808a4c9e3103ea3e3542144ff9e47497e6c6ce1f922a0eaec69be63851bb4f6c4b52424f544c04c6c7f4e6b7291670214b5b7e9c296f4dde6cb718ef0fa276c51f67e848ea82d802fa1754e2b7ec884a5b2e7ea906134b59d7a7b65bbd4669e622bb2741167f3cf124704108023051aaaafe1a81dc52a6d085a292d7313ce18f8cc23c828c855e28385d86af126b36f9565d9418e449c443e5523dab7fb0b94e4f910748d00e8bbccf876b16f7e529d21871562aed0c518c74c8db65540f2e9b4761e31af6f0bdad424ce2006131d71e467bddb83bfea1d0674a7dcb365d6e416c9fd9b1ccca3f7a71c657d3aa122b0638551d672518613588ae3c6185cf210952aa42c9dc39e0f7b2b7d9fe871fc6af170f38963503bcc61a80512b257c8fa0e2b35caaab3bcae8e013339c4ac68fe3c929341d56004cade2ab7bbc306f7fbc24daf292f8698b93cdf93c96f049b764f7fd312a8252a72b1b72293e4e85cd0cd4e50966c4e0785ae625f57b087465b033d0333c6830f1ccd1b518115cb3d94864dea39533a35f17f9c8f08e79457485443e52e6c8c47c812b45cc05cf7b713844bd9c0ed2ca685e047393cf5ce622800cf6b33ec440a288395a710376eb977316c582f5fc73e519777949ce037f82e48a1d34cf10fedc7d87a8342bb09e085afa760615f291a9144a07906b4da1ba2b26193b18d1b11f3536334651775b27735843dca74dbf51164df4e1a34a83c52ce395d13e35b1f735dbc52026c0d5090fe8a4798580ef57b3fdff3f3b6fea17dcb6cb6b506d2dbbe6cd3a3f4f4ec1c13f10469e368e7cdae704490464da0f3423ef2098ba7adc28404d1fa8715c0da7060783bc5ead575478caea9eb90064e79a35d0dce7a0630ab915c3ea30dc74397643e42b6de7188f3d5b2fcda0141a13014ea226e6fb5c261eb85b57cf8de9cfa3830875e32a5b3d506e39f3e0954652efb28f35f0694e21996fe4fadb2b0a855b8528c9116d54f5c57d7e3421883f4f36435772ed9714b6db259a7a747b0b61a2cfd02ea7120c288f47c2af66da8e6d0e110db691ae608894f90538f467094baf32742c27e51d7a64f7a79b42653146550a7217fa1b657c522aaff89b210c636204d02f646ba6d5889b4c02ef1cf7891b5e11cc291294fd557b90f3aa9e007111f6ee16bfb21ac23ac7695702389f5b83bfd330564cdccd4715a0ecaac37cbf38c973eda4c2ef4992ccbbfef9de062002d11a65f4bf0580db3caf196c1b4925b985272239aba0a652ef903c6052016cc55623cea2f6e1d1fc6a73535ea7fb473c98e45d6691cf7f44c0f7b32bd4fdffd0d562ed4d88a79fbf0954fc1b3b3ea1a15222e4ea7df49836a8c6f98a5caa34977e4a1ada5bc066869f2aaa3beb8e5320bc6e15ee19a44b27b39857c67c90691816da20464d2417fe9a2aeceba8fe8ae452909321e246dd99e5d5e29e8f746ee2f4049f2c4efe87f485125116b513d8b58afadf93d04c760cd95e7bc47810a593a70f049da16861069ba17ceb8fc6e76a5fc763650c1b95972fa2170396229d71bf7b5802e0ece169fd874e068206e7ba1d6189196efc9ce05e5e4dfc1b2de5290761b473820e21a26242a7fedaf6e491296ac6432d69169a6c4ce809343f13fecd1d937c62e9225ac583e78d59c82aec342a1cce39c4741b9a590463ee59f3d7fe0b017830e74bd4e04a9e06da2648f97f755ef53941d7b3531354ff882851ec038a367df455b98eb216a7026d44fc75f9765b33bc4e1f48948234e7fdf2ee33cf312e49f9bb537d71128726bfa15e3ade723bd3a7e00249882c1d15b229b4f4fa1ce18c69a0a177c3b778d7cc2e024b1ae822c033bacad8f61ead89f85c78aec93227f05d59ae78a07ae21ee1201f5a85da2175ec31ed49d7e4f682a0107f38fcf24b00c59ea1bb7dc0c6cf1af8d464389af60156f32407ff958ba7435105db670db682eecac2ce8fea440290b86f41fbff010256c94dff386ebaafc42707a36fd2f51e293176af39f82bf518933db8530437abdbca77c4f20f9f65e27ad445c07e14b556c00b16160237cf29f9d8dd32419eabf19bd5886249fb63c2959e8018451ab550207a6798ce173c8a0885f15889839448abc64e062c5917506336ddf3fb1e6fe633f77c1ae757c8cfa1f6c7224ed931a14c24d00c74b599139ad86d608cfc06f739488212a79e71d3a6a27851b3f5dc687c9a7cb8ef516edf197db5fb0a1e651e8e816e598b06e2902023be9de7ca246ff9d8964760118d61ad221e35307b31da3aade0adf8008ce8419a97105576bedb795f5e3e2dd2dc8247a14bcce180e0781afbc4d271510765ac34bb17986f3a6f926e2ce3a3b0df005f2991903134464d5b8424b2156ef342057d8abf18b96b4f0eb88fd83f3e83e57b22ac2ead8093868e69f5b331141e0575b294fa83b3be53a0219ec6df18b16b9a11e4d41d91fcad25644ae17fd706b8532cb16883c86047ec2967771c1793c37ffc1e0e4ce6c98b6f62ec407777e1d2017a2155b4523c10c030b13fb300ba46ab1e2d3e2bdbc2f3d7aa88685db02bef2a1d70aceb2dac1693deea08288c7046fc076435a1b40ec3c01c10ce5e16658a007d15a47e103906ea8a05905e458ba5cffbcaf41e77da93861d3e6d8a1c88e5bf12b4a0d76ddff3e549fdfc6f3d8cddf95be7399e59ea479f1d23f31d84d769729d3d1a6708442f699e2cda90a2ba61cf102e74e75eadcfb629e0dbb623ebe768c89b41dfbb715ecfb7fc66da7110811f1bebee29db55f1e2e64ba85fcd5589e68abf77b351b17de01b20c855a369d24c6ffb57ffaf53be8bafc7b6dd3d30fdd074c2f86806e11488eeb5d7d0add2c2ecf6483403ca0cb28c1eb6378425c9fec68dc3c1186e267216be9a48ae9c92b4dfcb12f8f8ebae227b2510d437154ad8e9f5c8f24878a7491f82170e77a2bec4a538a41a90dc0e3700064099f4df4f4aed82eafbf6bba297064c954ed4374d482104e2c32bbfaa3b455b9a411bcb80978b09696a0e88a152eaabee6d152729338649d08554d027446ec606f5b32a3509225e7677a492dffb8f965cee6e360091c5200e607a20a29d06326abd49964e2a40da26579c046c7759d41092dd8522e91e83bdf413d3ce9465ae09734597dec192ce79ac73c80d99398eb68bfca15566f1306944f5f83debb9dc60fe9b4b946d029d7ffa2b4eb48fd0490ed22b65adb7c77ebf4acd493f48abff2bc821601c1cecac40fed1d935d95c93fc60188680f7b26e2006fceef80edc2f73c0b8922b71153f13dd9e23d3ab32c8323ea72bd5c06bd048b64c14360fe7cf7855829bf7abf9be79b91689d402e1d0760f486432b9ac7565f18588f6e35db324fb36a2c96aa3adc31a19c5e21efa961317aaf964c60c4755cda593811da51f62474f96c9b74cb60dd98c9f6cb23181ebb1e8217b25b4e5828e49ffb98cb1cd857109cb05205fa6f5c853640166dfa168651b2d4763b5d1e5fcdca60198ff02a1e0f3a46dd661fc0fc4b3de8e7b3ccaa87ebec92f63ee074be675f4ca706089d73637eee6e8955a86a6bef166b1f2377c7890574bfbc464a5d5a6769eda3f6dc1d52c87f1fa03ffb0d464b3c6cdfaf189a2debd9c1f72a8193433e5b76e1de76bf1fe2aeca59e3f63fddb56660ac3407395c5dda7b8d117cc9b9b7a163c7c46267d9e94257d4aea46462cfe44b1f25ff84d51244f1d1946438ec14b2c0587b55f365edb5c687534ccb698b4b362ebd40d434a68fbbf0d82198aafa75c7cdda0ae123dd14a755f3698b85e018d5b388ce7545b3c30b348e4c70ad8f777fb558fb03dc06e0583c77a08646c2694c70e71bbf89ee5ee367dc84f70a9a1e79c2ac2203633679fd0f459e7935b0c50677b94f2ae77c3490bf236b898756689b670a82372c3d579d37ea91a2c076447a8a2b9c1bea7044bafad17e7ac396912e793360a5dac823c0bb8295ebea2cc7ca2165f3a286fda972e12cf7ed7c83d688c40108ec54399819f6788c18bb9ecca28a16779051a192d2435b033878721553aebeaded5c22c516fa536929514032d21c4930e2d7091a376e37e92aeada3b132780b66f2399252aeb090fc363270a5925b7b8359fcf002ca765e3d77d5e3626d74cc86f0f4331a64002b7e4d7137d7d4a9e4016a84ee0a6c5152a58715d4ed120d9a5ad05db039c4f9c9da25e14e51493455ddff4166dcaf2fa35d3fc5144035a15425e52fd58f3bfe93b0e5f6e2c9b20a181e7658969fe297c423a21ecd4bf09adc50a6a5970919e68f0ea21e2cb6c65d133ea39669afdbca746981aceab3d783a7752730be2bfbc6a0c10545e6f9a3884fc9c5f36e14cd05cca042bea8ec54c30a6a6f78f58631a0be4751212c2a60651b6493a54f4568384419d8d2ca00e027bd9d6fb102ad1026de080823d08985c376f67aebc4c12d7b39508b662ae776767012edbaeac0e0498ac514154d23dfc629cf0bbdbfdcc8800db0b1007bbfd019d7b1e18957a3e145df508c1fcfab390d74253e4d6cdf6982b84f1f77d510bb15b916bec66b63ee53a64bb961914b8cde11af14da9ea6fe7e172b438ea609cebd16454eaddd250c2ae6070ceaba824ef62b3621337209f7949622567e65a0a24ae158b24e9c6a9e3b9b7f7e6c400c6c54eb90089d95c3cdb1369cbc70efe5f51f864080178f115f67154ae21fb560c15a9f1e27b996272ec2aec9e1faaf18521ca7489b97d9be287889d584fff765ddb9c16bd0fadda1346fa3fad49a176e26c5b0ae617c9d91c68871bcba958abab32d219f441b1a19e1d379d3ca18a3c7a90c1cb56cf5333c45beeef323aca63ac65935514f60d2a58f805168cf2d8ebd4069f38ba872d4724d3f5da156ac7fdbe46c299d3537933157c5d3b5bf158007b5fdec8b945f0d4048e2fab3b1dec885ebbe23c4efafebd925ad53570a64609dd3adc9e1879c299256f4735a129a443b219d655099aa9c62b53f48070187740419242e23edc26fd89dfe4ab6df443517a852499a7a019722eda74e967e540e0f51d444942086f00dad00918b101940f2b4aaa086dc5c0fa374d85ecbec4e7fca45fc26663f0c8e3f6c644f6437d561a37f227407e369df3fecc9e16f837ac22875fb766d088b868db9289663871763ad6cb8bae8c5fad41bbfbaf8c55981ddcfde46dc4cd45b9fd3c4f63718a9b4c823b24c0e294e17fed57b2280d921754273e2b06fa3f95a34e1a131331c37b2670af70a3885ef072b73f616ef4017c433af70e5ec445830c6763d6f9ad11cf8fce1e61e385eb7c46e4c33d3d3a89e695e0d34aa35484d2ed52f7ae75590c1e1d9cbf23c942392944e5ec6eff000c27855d9bf29dc1a93761567d5a34373195d522bcb4635860cec16848d3f4e37c3afd52d4b3e2ab4efd04ff304cf9973a419c93cf81996a036f9349fe40dff46ae8e1ed1400d38c6c5dd921d49c2f75d403b24a8096e65dd80e77a034c85cf36ee6d7cc28255e55a649c093772a979a4d49697cf42e55113b3d44cf9932052dbcdfd45dc46d5bd0c37e2c3f9279e7c49791b2c7d9b954161ef0b9628c309a51f88a44cd8fe64c63b08700a6a68fd8b6e0393b0724556e330c3f22eb864333cec2c6eed87ebdd55f4563a170d8fda2902b9b1e3f3d90c7a06d84c33e0fa7d186056ca897640bed74ed86e03202e8616239c795a664c5f370ba42d3be5d044310f3d1df7887915604c5101e12b2db5bb1db1cb7dca9ecfcc55b9d0d407d24858e2612fa593ec47fd51131e5b232af3b6106f07f63e45ec301020e6c6d4d97d742b2fb2665bed7b1fc3c6272316c9169ddb8d7c46d936a72d4f64a234228e4de5e9803497ba42117b510ae45b87ab487e04dcdd335e8c55b12cf630dbc7788baef800d99c764b2e44e067e452df5c9e327aa89c152ffd1b959c39567c60f78c0f1a07721d2adb454342f9a0b7a0e19fa0c25c2cf9e356afbeaff31b37ca9e49395480c04db3e4b0408ee46643d071cbf4fc8a88848a878cd8b89a03bb90a8cbfb216156f92ed83b8fb4c050ec9d983ba572928ca63640883e10397cfd5344241cae610dae8bcae227c1bd420fe438512668bb33e1540d04814d84214e9e2c84ff254b7a80087df0737a47d3afbcc217ff04285568d2d29a67c883c19f2a94326b3659ce789ff73430b833eebb461d4737ef3b457a57fb727178014169474a7b86083c6934e8422d013e713c06562bff8c11849988716f57124e8ee8e2b4aecbd3906373169077da3a059e91d5661ffe6cf195480faeb7f51b0e54bc2cfde66ef7ce62efad00e3eb7a9ee503ab7e85ecb31b0ffff0c416480f99e3f03b2c96e03c266e52386f47000be6e126251799f8104d255ef0a5e54cbeca80a3172d9bbcca2fb886d2aefdfa07caa2f91bdaabf16d6190b24a1b4c00e46beb230f1f97d7c4c1dfd9d38cfe03358bc5bfd5ed6f255c12d13a166fe763909c17985e6199be763213f9f215abb9506926d937dede4550e575d931924c0e98d0d49d447fbca700aaaa80f9738ac3eab0b5dea4ef05c375d9592592658a66465312a31e15c524feb3ad1b6d09d0f98df4aeab8025133bf96ecfeb004ae4342e1233c46c374c05d2082b851b35b5891e7236ca331d8c2eb278acc46db0d8e00985267463d0231bfba82f7de688506a6885a2543674d6689b02f30e2338a3f9595521086943f01d60e7fd09571a9cd63c822f963a6747aa3218f649d01a36cb140e13728b119827498ac08ed463de39a721ded11b52cf9e1cbef78cde36c9a0fdbed9b4adb2f97bdee5ab54a42d51592634359af23d4ec1a7a8f7e1d532e30548e0c1b1583c62cd4feff3ec0b6e2bb004ce2925058d3ce6b48f03e129c62d43d0f3b1b206204a27a9260e4019f9bc145bd59fe9a88157753c4b91e516fa31e05026bc420449f517ba1ed65cf9808ea6db7a37da4dc87f059ae8ad1f6791a3e89ca55a8a052d8a1ffac4e4227df0d669ff88a4da3b55015d4953f06002075429a05b8f5cab5e921c6bb3e7f57c2bc2d17519bc9a3af870ea7eab4c3fe9530bec2b9435781640697330c739636a60576487ba33ef79c92c7c539eaf7e67800ed80cdb679b207acfd9bd944e31e513a74e1e2f27692339b0fb2abcfdd9c3fd5d0796c58c93f11ac585674497e71ca6747f2c710d6c4f026566da69ece911978bc2170818defbf13dac9f641981e0cf0a8b3052645d74963157a13e2cf0c6deb39e4223f2c027d5d0049e64ca241c9106ca3bb753115b3c883058d4a4115f00b5ca78196df9b12e52437e3497fe84a6c946653b7cdf4c611a0092bef59654d8f5a44ca786c9cdf228694fff213274b106999cdc6f10714442dcfe39926f9c586fa5fe76f7709ab9f32c33a0883035ab474a51eb7997a03a0710c3cad62415cea0e8f654e38222b70864d4510b1ce9d7c36e4bd6c50852af71089364cd13f70be07516efac63dc1199d56fbbe8a6eec3e65435cd8d739cf52dec2b03de19424dc741267b4533d89527a16f771f0589dd5842cc8b1fe3a73b0dcc178e3b4d6b5813eec644be617d88755d88959adc9eb9c83dd5a4ee480a6bf40503e4cbe660d96ad1ba923873130e875a09c75076fc8ade533bb012ed896433d8440607758750ea14a92567ac325d61b10679c320f219eb4d6fd9be0a9d4b5454b824be38af614035ae59ab7703c125c3e001651fa871a2472da0e99fabdc28afcd5bd156e225a10dc6dbe1c3c94e874decb14965e29bb9c0105bf4e6affb10b6958de8420e13eee2cba1b0296dcb84aff545917e1a3b2d62c05cad499bb84e18e535a81b4dcf9da8d57d84ec8f7730b89b06011dda3dda45d7839fed323453c713da2d89610236becb493b92751a73287bae5e4abffa4677656ea77c1a3f9606c83174aebc72d8e197d4d18ff980eadef9308727902930c2375b62b3184a244de264d25e73b403df60d39e2734a5d52c67a4e1779203ffceac5e05b360d2d8a16181b2e8b1da85e8736721c5f885477a6b73fa19d190acada6a7942b95b1954daeba85871ed12f18b8601202ef7debde5c082a18a7c4b9b4efed3f36805958a11513f49251098f0015dbf89bc6669af095b1c53a59aa826e94dcd7070a87e548b6fc9c855cb3a457bc53dbe7c308450394796f5c4f4af9c9e50c0b28dc6ea72c119be8f9b2c5c7334aadafb6755de62e67dd2faa498b8cca00ec4579ceea6102c7053615d79d724fe3c35502c8421be5449ad9638d24a4d5a68bd98ace8b3688af5bff94834fdf41a2d0874eefc5a7b51587b0470d5920479debabe1db68fd572d46a8520a5dbfbe00f04eea2455ac52a176975df05b880724261b7a1e275e4de5978a3af7985ac609fb496c44f2baddbd275f8fd6ed4309b6743b434dac8c55fa72969a9cf9b1e3608f4c15247aaae67ade47804649bc1ca1c630ad141a7aa55979f6f1e7aa748e3984b9542905357f617448ccd14d434c3ad85cb54f35f6c0c42eb827a7c8d5699765a3a880e17319308df679954d5d639cc39ee936178442cce9e507720bc8e0a2bc0b1d035c05a93f5442b346028e479540627256e3a454ef040ea00c21d7887f2fed7dcc858c8b42f6226f001bb1f826404801ef0876e9b532f6a2b5792406fa76d7303958def86ceff0ba36da37ef15921457e237fa236b3d933aa81c33e16e51be723c4757ee36d44608625fd4f850ea2d40dac4be634dd2292f7e1591c1e0f139e59f4cfa40ae91c5628684a10cd6b7c732e5d0eb9dcf19f0e3d26431f6c6c115096566b8875412df8d222ff56e9f8e87aa4b4dbe67531bbe699d3485479530bc468a0e65f288743eedf0ac4c0538c4a7fc6f682d58db1e44838fa5643969fd1743e72a73eef35ebe53ae0c006a41df9f5c95e0821625dd284e515cd61189614c7e862e654890e7951e0d0770e4c02f69a0bc79cab154e9b8d264676dec473aca0b5468407330dd7eb06f3a521525ea617eb098c47f2b77e0e8177111932c8325b7c984b9aa519f0bdb91d59624859380a90ea34200c71968d2b5442ef96c9ab73267c7cadb9ab6e78284f17a2fa26074ccf82597e6f1c5105a30b48c81677a59e091b898b6ffa0c198735f9c5fef0296a43f7e5caa27f76b3a76377ecac8654aad51d52948d8939248ae5ea8f610a0b5b4767ec7db6cae4dda992d83de9b357ce93db938df9c777b06f2e36f1436c0b886d8a048a1f9dae1d82b83d9ba546b99549dcf02864ee2cedc981923a2777338f614d0d8a4b2e69070d182bc3f1142c9e97074d0346941419f8b50295ab992151eb5c11d7a309ed407505b003c4a0be31a8981c68a11e9644d7de482ace2ba8b97d9310067585c7d7121b8523819d71c06cde4b5f5be4e97675d5cde6809c43a61ae60043984e36d1ac329cb81d0c2531a1a9d65e3652b1d738a5c1b8b58bdc30e618239c233e9b728838bcb6827f2c39cbe0bfafbdab821359fbe1f62e1b8a1debb6934b5a0bc91ab5d871ac78eda61ab25c05067032ecf2494c8a6dd71bb22446dc65560258f9c4a1089ebf38f569975dc940282b8322bb9e373eeca2baa4386738de44099f93dc5e28409d5c7200eed58589aeafaa41d9a1dfe417b9cfce96f06dae800de05907b573b100f6746a1c8ea2b2ae5129276b3c4d9b8a80f0ee40e7a6bfae7edaf0e509d678eaafa39bcb3cc2576378764036b959f3fc0c6555dc651cee46cce731fcf2f781c67a6c10f185c956c28f3d2664b0b11e493469374cb717037f7f1af2ab9b1958742cfe10406135d21047ff63276f70fc8ed4ac639af83b982bafad08020e71fc3b5757f841c6dfd29985e8da94c3834644f767f9b055e455c3498aa1ba1d176d3388a7a895cdcc81b513338cc899123012ec14b190249e1022332ad0f60bd157131345a32e8ccd4d25dc122674b9aa5994892cf6dc3ca241958d588c30f2ece90edbc4a1351ada9b01d3c48e3d0d5d7eae23fa25c54d592450e1b93dd3f9016696f5623973e2c2e39ce1e262bfe4b128df54e8001f2ede36cf0f5f8e101260162d46040e2bf20a611cbc7b9e05f07d8b45cd1e3deee117aefe6edfc74d180af56685b69225281fedcca61e8deccf75a03f2cc2dc95e2bcc10f370e33998083d74153bde50fbd4c5fc701c051c613f9e807e378082ae5e5f177cb81bace86da0ce0a3022d0d27dae9b0a3806469e1351b6b376306ce7170d6a9af56116df3b6a70d28930713180cbf0fb096e38491bf092e514ad1a117fe0665c5cc645a0b0d1650b4156c4745d5f655190545afec4352ddf90f1d1a5b2610bc76cac13d609a930830ba5feb4e18ddc704045490707a190df4c9f3dc0c0f93dd69374f625f3b83e30d83a2e5f86207c49abb86a136dfbe79d81dde29d2cd1d14e1fc201988512183bfb802d6229be110eda379ac291c591f5f11060b3c74440eb581477f51284d7854ef95a1c00cc8670ac264d3594f4bb002ba02c58a742a96c0c9ab203c8961af611d591766f68b88505506576b6b5bde2c966abf2a38879a3d77a0f7a7f33cf98cd34d382fe0c7235e4741a00d51525f82607aba0751ec0519c23ad0ec64d0e0ce3dff4ba8ec9d257e39c697419d4f7653a516b915d1477fa9c448c59e11b8e93f98670e708c06c011f53bb992e804bd478c6e4e1d10d65ed6736eaa2b4dfb9f7364dd7f1a4f20dbdbce9ccb5cb105494e01fa3f9b4e56d94f4227a8861e4331c68df7c81361658fa0e9747ff5a60861a4b3220a3377bb4b73bb62a66ec838e1413ed0e3a617e2bcef70027c159abb4a8ca99b1f9b514ef9c168462255fbc212a1eeeb60914df4449c3ae8d90bda0e082e302dbb645bd92f3137d476d83911e13991166a151b66f2c6dc31bcfc93c78fcce2500efded10042fada2313fb12fea4539ef9f6d4509b7da826304580691367e7fac308d55d561a02286cc83a83e2027e0e8fb46d9366b6933adf84387847820afb845913230f8ced364a5269746a11f99e7e72c10eb1f94a1b1c4fe96c1797531fd96628869d9543564d7b75cba3d2bc7280c7e2303b4623327927581fb4f880212b9b33be3b4f93306971e591c281829d48e470df2e4f4e373067a6f617f28512941670218e2390b6d910d1ac1892ffced16f5fbc3033a059635ac0a1aaa4a096da65b4cbe2e92f59a8b5d595ae2e6fbdbd3fc60ef5a9c781123cfcfa32f9306d03115b368358dd0ef7783ff696e96e579afa81840fe8de0e32a7a3f96d923e5bb57151d9ae6466027e8a049dd99dd80b59a28e99539b48a4e886af4c6f58a9cb7191cefd6d49cede404802118eab0e303ea94e9c1aab1d2fbb0a7e2dd294944d4b89e81983662237780b00627c377aa08bc992db3e79f9abf6cf8773e1bb77fa3ba182f611edaf0524dddce2a621bd230df17c2ef792d7f11e059f913d1fdd80da589b7928b20bdf4ab17405c26ac8a4f33ec89fbdbcefd3830716c708e255d62a939c2113066949641c7e483134ee63854134ccf4d44e1edcbd51dffca4e3c645097c6931d3074c123ec61771fbed5f0f1cb691e317b7102b4b19fccae8b607873627981502e1395e1ba00bbf79a1764d923da558c214f4136a4c5243d50ca03db46f4eb3cf4f91618c176411d3f2868c92d5cbbf9f1495132045e088ba46cf904e002e11cdd7c0d00dddb01455829a670993e62c5fa5eb329c4844ad6ff751e7379f64e9b50c777aa13216c86d477e2204a6d92fd7797f7c3e036613c0ec889b4fcc9ded03b81174f14bf188af189e947d82dca85948291b6a3473d849669cf4918e530baae2d7455f386c8c4f4df36ee1c3741643eeb4221d56b1d6031033e4c7551ef1ae71f57ed4387a035c9fa035c028006b60c4b2a8aa5fa7b4229b4d23620e9edec5e4a7a7d217a3fa9ab77963e41e5476869a07cd05fcbaf414970b17361218ed40ac9aac28b692fa2108caed6df0b41fb9f50ab653b478307be77f5f451194c9a74bc7afbdf52396cb203e8333c7f940fadcb29989c9284b95bb3e1daf7c94198ec98f20e3a3e18f9cd642700af6d661a5c82abf48f59404c86a0bd712aa1c2e74554ec7eb407165d427affc999b87ce674d83b41a9e3cfd87a059b2b00ade632a5c2d3fa51de1316644d585ffe1e3bac4ac074acda99475278aede9c03bbf0da7d1bdba22db91b165269997674a46ae33e54fea66760218388fe7d9648e505ecf22c43e243558075a23e151806fba5089ea5ad3ad08f24b0aac6c86c1079118588682845ce47e569b4ffe5df16e7ec427035e74f888ccac75e2a59492ab32269836d2d9a90382b4d3fb36403ef0053436f3d242ee12a1746f72760a59aadca41f8c49f7f54a64d759336ec7bfc69453b93e0fca167cbe0d9868ee324e58c0e334e238be2e52fca4f947566bcfe3bfecac37db559471318506c6f2557e2f6c73e78c57ba86fa038c630a649b4b56d177d313c25101bded047cc85867605d6d2e38637121526bb5864bd63ed5b296520ce5e2635e493ea4e47a29b527926fedc4232a7603eedb69f8fed9cbcd62ae4b4487930ec053faf545c694b692f397eb55c20dddad41f9cd2bf4e77e510a2601ff09f2d8965cda70fd3f8c6219f4bdba21d5cf6fb8df06459602f9f7d537d97614e06c1702d9839201861f0e51734c5241bee0c900935196bffda2c86ad7f281324b329968f54a955fe41f28ed0925c3f246c1728acc9f28098245333740912463b1a11ed334be2d7b1cb664e44af94e35a08eebc31a2be4041652e79bd66f7535eed859f526f3cc4e66a600a18c6871dd462ccaadb65e12e231525f666a47e21915e74ca78450a67c2b79d5c3399a8974e80157e72a347179f5759e2f83ae34166642f0cf6ec792d19c55709b11fc7b00d205198e02e4a0448258fefe5db17c16798fc80334d5d738aa38347a07395d46ef8438d44783e0c6fb79907378b1255a100084461ca372e6946434b699ebcf6c84a72683d4eb526456395f00df4b6b44d75475c954081d041419d37177ff4b3e1d9bdb67e396b68669e2c9eb3ba57a53d959fb9b65d0ceb29d14040036a322136ea4e5e8cd2670d1c159e325f377617850d1fe36c41417dbd3408146c711dd8b96734c8eb9e74b0a1b64dc59e5b50744dffc3b533f451be60326cc9824f5b2abe0d299717f8b44413391c31b91b863ebee7997b443e0409567fcda6ce409fcb4aeed3537c6ac41270d0ab8f334fd5c40aeb1549c96d5d1572828bc675de097039111fed9c036883a0c48863fd792cc3a044a219ee417ab4d88b990f15e5a32b98b4b54432a254c25b1e8e86396befc29657a1625fe79d8b38ca79114396c9e5202264f454c19cfa75672355ab08368ffa829aa7f5dfcec9582b243a0a57a215e3f3759175469918b1cb4c92f8a48ed10f328c3f92da7bc03a0914fd3b0cb6618767545ae55644bf6d02886bc49714d4ba07f7d57fed6fcf6309cbcd28aef94093c2874bdf1009151d4b616e6af53829055af095a7c9eb2153cd29528401c76787800603c6b69b84c8052acc4652a8714b16c095a3c3ef654b8a809b898b1dbc88d464f2801434288f42fca5859f9eab5dce4fba26686039faa37afd4d99e75edff7951894b077f360dd0f9109449f00984b0b5a06323091582665a8d63178d414367c8a1db86faeb6a75de1ad59713cdfa61b7400f2c2beb4476fc2894609382f2d36780bb7723be9c29c7b1740abadfe067632a7f48ff253d50690ead0cb36635412d0dce858fbaede72f71182c0c31363edd16f5451392b304234aaacaa8e9258dd0b4d0b7dd229e4d84c81d843db23830f58108b0c93a46867bb20ce762aa5bed1b7719d5fde4a4a6a0033481d9e57d8eafef0b175007e2ecd02ddbb67831358358675ef78c47113022a522d7610187d502ad8288b36c6d19ad2396f2e1f11a986e65cbdb583c3d539a96574c5ab1599dbcda5397df89f603044a504e1fcba3d6518711aac0b76160b4f5126b903837e92d196ec256f50cb703db132186c832e9d4bf827bd5337b048592a0afa8f810608fe6c6429bdecbcb2f0b230ecb6b72ea1a44714822b954362bcc23b3291c548532619fbe835cce04e5f141037826a15e81f9d9a930d711bf849b189476a2b7a96c6f1edf364a6e601b3dcb3031908e0a1ab2c0bd9e8333c65bcd9f8073d08325ff3f7560b175d0a1e642eac2f9025ab5f7f5ecbfb35a542563da08742ef0ca290f55a0931f50eafbca5256d6c9087a6945212bbbfdcecb98d1e38392561dd77f418f8dcc051ede777c1c7c8b50e57ba09b8390c6aa4c0017ec9c261d9ab426eae9655360622db932ff0b00ddf200cee66f783b15e2f4f5974af2d6008eb6cf1c150e986813967aacb94c569759522752cd5c808c78c76a1f053e12c0bd711fbc2b80240a212ff3102deea5533df5dd55d1aa4f07e7686f5b4b0f91b193926a31cacd9a0cfb2994d5f7835f8112c85daed492796e9c1f21fe5ea7a969a7a5f82474ddd70c6eb1fab9fa638e6587ecd63f5094fea2b04cae846be5bf472cc849e8379dae3de77ceb60656863de62ea28f0c4c451c795304e471da7a2d562fb476c8d7775518efa91b07d619b2e2e78055dba8397942b9cb1f06e31499ebc4a1b18aa26893fb6fbf9bff5eb0c32f2e990729c5c01b189cb12cd1947a21c42f6abd9ab6db3f589b379990f9bd1d3d810bfd65c634198b9ee31e7f934764fac8704840fdb1eb90a7f90eec3c094510b314352efdb051ee2b4570ba545778c1fdd052d1610941529defe43392789c58ccfa5020a9fde4381604cd6a9ac57279c044c8c8f54a03aa160f556ecdbe7d3a9193218f4d232f783650b335f57f98d1a74ed17a9bac1a9e4972244dbdfe1f7df9475309525794af64b0aa45cf26b447094f964cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
