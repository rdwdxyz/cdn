<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18e414989b39a1ae30559a94549df807e0b93b9a7fc5cf3881fd40e84474ab0b4263128dbcd580e311ee85a02a99a69b5a54963aedab2b585c3f4295a6904969fc2d7fdb3b2c9a66a1a245826b2c824a203de0251c013a8b93899f7c0f796581f70fa7de1a102dd528068e3dafa816dece02c7449580b8174de13d05979dbfe87a80020923c7577f9755c59426ad0e538413538f5ba3908caf96b10ff71b986e51167155af1621a7d11b16b774da998c6ba32b25da5764a6300a157f63e87834fbbd26d5095708c2dd4e4e41645ce19108ee0f2895a8869b1fb9ca2a1d1a9c1ca714e4aabbe4e51b109aa0ac3161c42bbf9316d14215309994281bbbe91b44f577dc01e228d1482733e7f888cc07c1ee7cb97942bc7ca826c34d42c646ea64f6f725d1dbb01587c6d47927f3d2c94a3de375bc48c7541b892d7363cd8fbb2cfbffd5b3d087835095c53c7970b6d717b6364bfcecd8229c95aeb21eea30dd7deea0b784b6612fa15c7be224afa34de68b26006f5c9de97839074dca23a4bc1f91f7c0621d8e8aef8060fb51834eeee2c41fa52a81317f4ffef3f2c50e2d9816cd332c43e8f12b3b7e19eb75a95f1b9866e86923bbf426d5fd5b4a5eb0f5e341106fbdfcdf75efcaae624f5b5e26239a935ddb3abda234bebf0a3f2700129e6eb74ecc9c77fb38dd94b4f5f6ac2cb393285e19b0da54301f439933d8a389826a029e13333680f3b61d294f66d6834e9e000241b996a87b3f32d6b7bab14853f37ffb89415fa3aed34c65e5f30abfdeac109f9f77dc06581559077e6ca59c34a6a50e25be705f7be03788fa8d91f28d025f07a1451a73a97ab4d8abab6f575ddea54c360eac19373c8bd27c0f1f0c0f4db57733faff3ec6ff95e20b34a1cb8e3de0bae78299c4c28ea67295836dcb3d6a03d0f78eb4edc4366baeee10d3ef77f85969fe40a597043425f6dc17375cbd308361592e9898167d739fb4c15a00696745a4c85b70af2f90e4e5486b2a77ce513d13781e90d90e53069e1a855eb12b11900edb1ab71aea58c10186eccd8f0e23cc52d44fc9ed71ee444415960bac0282b70086aa28ab7690be6323250d06255b7b167ed35b88dec3a7aa0ad5bc73f384562180209144d77fbf855a54354b3fd7eb4170de8629ef530e1e0238bac20f7e9fc6b008d36073febe24021b03fcca44c0b0b00fe6f033e6c6d3be74c5a8fa1714e78de05cceaab12cd55f94fa47131e3777857f8a53cd18cdf8c1eb4c712c7017f33d8e928952abfada8d03e319131d3957ab4c7ff9b0ab3484290e1a4769029d446f4154b785857b297472d450c140586762ab03223a3e5165e07113546ee7bc9b65a065609cd7ec87da7e2f35446dc13a70e013318b122340666a845d8936591989f7bfe7267c3f75ce2a90310987a78861d3a31738e9348b748c14f0b1cff9e37247111618ddb872fb68493706a6c694d58e457119a270d04b915e4adc87ec52cfd25d89639bd3672c0187ae98b7026090eabfcdf0b0f248748dab02ec31aab4dc053eaec05b3571d680817b0a3c9bd9ed083f21de66b4dccb8f79ba7699f8ea133726f9c07007263365b595d92f95e00151a878697f2a9183848707f3adeabff9af0708a43c40c146e0044f41ced57c07228237ef133d76e727cf20af16296991c19d1b364ce3bfe532a718301cbbf5de9598f0f15c36478d518f246de0063f1f3a5ac60956019157ec9d871e1d454bf8b25ff8bea702a2bb9c19c8b055e099b9580428b377a7e851b1052f46afaa67efed587e86efb0f9b77eb9c02b693df48d9b7099f8042413dd12849a2e1161815763204d6843ef1ca718cbeecf64868129943dc13bf66b7feda21ebf624634ba6fd68a05db5d7776de64358a15a165e46c06f9e4456b9ed57b006b8099401640d4c930ed25097f09209bc194de7fdef08d2b09d55c2ebde5fe3ecf170ef0ad36b8dc0c532963c0e0c46f446414a08b224f3f15324acb7f9b825fa31700c4a9d5c6f0596aa46d846a4d5d64c7f027546b6e933c5c3f2cca1143612b9db5c80f3e2f2c7a64ba3fd630e56e39e5e6a16a1e64f15d80ddf4b3e3c17f00fdf132b8d91dd0b18f990e4cca4f86fa1264a06f3ace449109902c6d6544b2bcacfe32e83149e650185918b6c5b3ed5b2092657bbb91e1ca0f53148e82f5e5092c4577facbfc3c132243e92001be4ab0e4445a889d6eb8a45d31f4c20aeeb0c97636aeb2030b65d3d3a597bc9e5f980490ab6be713c9235478859ce1fff6a4de9640ceb20dc5944005c5a3c6edc3d51b235f1593dcdec9bb17568bad9240d02aacd4417639537b60f9e685321a6df1075dab0127eb9e34d433aa8298e9a8327a20099408f9e866c463f811a0342871f87513764d3b81adc79db9630a0b69473b1f2d3a41444eff8e62202a4667eb09c0b6feecd8c44b28ea40e04516fe7a29729d0f743cb726e5b586a9a8f7787577abf64db128c69a0cfd68f2273acd5b60f7017d86cdfa072441c100c3caae79535556c0480f0aa2551279cefb8602300312cbcc1d6fde8a9696196118b67e84998cd9f60671fcac3893641c7edfbc7350b7565f899edca971b2d8db761db257a214805c1b9635357f1d2db5a3aec967710ef9fa3a5b9a2f0e927468169edbf589b2a783f038ecff1b16698ae31d7f2d39acaea1fdf9fea342ea9bdf8cd2b2139a3c39c469dd3f7a4052fcacbff0c857efd6828a9a00adc8b5f3fa7d35f4ce2c7ae8b8ebf817408b0942b63ee366b8e5d69846f61eb7dcde67f508efb96e3d36c10a2e4b142b7bf09c1467c0aba443294cb662a0652c89295522aec3864095ffba6df8fc6a264e3c82cd32dae9605e686ae89d6b2b9635650c4b57ef50aa68794f01a3106db23c4df08b660e0fd7094f628362d50804ed795e0881a0fe180b48bcb42e3598de808d8236f5ab77748fd63e5ea51f9b8816e1911eaed2ba0efa4039e078cd3c73c1929dbeb4b1135e337663e5ff9f7e802b64a91483607ea0d25bf5c735b944f52ef81c4f26aa0d08493198157eee766b840a036d5344a55dd937ab1203ee1505d00df74c420b17101b35855f89925d9f355988fe9ed7fc5e80e432fbef915bfd622e8ebc6f31a45a6823eea491b7f2b8ed0e5f47f862c421d3485ee5b43f1c4151d0c4e48f09d11c088abadae04824a9988b2df2844ef93b50bf412b09555d8ce01a8fe50f00b22b14d384c35d0efa25e3e99626b166d9ad5a949fdbb6f2b84c6fde5fdc79026ce5993362ec2c1709edd52a5e593f56d5b59a99a25c2a992e704ddd53be2a221659483eba425370ad797b42b682d181589f4f15dbd93fc71b0a9213af06ad263f9d5347ccc31c1e7977da57b6dc506ffdbfd9f3a699582c45ab265793660b7fc5b7da34b31381487353ac3269af553d5f32e608efae6ed6bd14843eaa4fb26210b13cbf14f629ba14b249b6d78aa7d92f1439e94f6a2346a841f6eef1f890c6370db3c49e1750d67cc623d611d4badd971c18e7ec652b288811f5d341f33b439bd4b76cacbff32bbd8a09115ce2992432605d00bdf35bf123cb9632c7795a931ac70162ca64f74285a648a36ec968249d5d7f1840ed06e5ee3a4e1bc745f06196111f7c2cc65b6f5e6a483357957fcd73f758f4bd4f33b1613a1960c6e351140fa3d5d9c4fb23044c947608ca96e4e7b772c247617eb5d1bb7641c108c3d950a7d5a143ba6c6f1f05c129cd889a89918705ef40217103f3aa32e4f2901021b784172f4efc4dde0b5fe2c14a5c48d9a4b92c5f57e7911a475dad2e2cf5d4857e90d12c28b32257d47d5efa67be2e0829cdf4f4cb85b85a2384f4a262cbe43edea0edeb91f0a16309c76719e0660cdde4e01c52df9aa1bae730a3ec88e43d66f17c5dbf872df828e7b429df381bddca8363a599a6b46592e5aadf3a793df1cfe9c840ce7e398f771a36c79fc28425e69d8171c503b201b7df1342030bd72d41ca46ff62cae002e6595957623b6345d7f06fa02b73d09a2a6729462d6c7e21eac2b0ed910d03e3dcadbc2bf2aacc6feaf02f5bc721387b44fd3fede9b1f502cdafe72130cd4779c145bc51ab69b36364b1798fa491c6d7b685baa172b52c37cdfe81a28fa962813e323f1a46ef801f13128110847aaad9edec86053d66954c076fb973d82765f5bd62843484849719181647f5b414deb050a98e9e19f1306eac45d5e103a7b92fec64d222e7dc595765c19764491afaddde7321dcfcb231f26368658cd90787fea6ed8229eace36d9b693ff702eb72089c2c565e33afc2c6b08ad5ec55325d905423baca19121ec221491baa655020644096e88e61d15ccf7e5f3d2fa0244fcb904a6e8d5ef29e6c4ccae27626774279a96710fbb7a3e12aff790d62b693e9e2dbd7db7b823b5335e15a8225fec3bf6f56f7fdac987b06f459d50ff0e0de83f0dec2f8e88c87fcf4e13411f08de4fb74565237b93b841588accc54bb85877f201f4d9b4c46411f0f628f7e15e00d184f41467d553d06a2a45b3905a43c89aa79a6fbde60b04ed166eed801c5dc9e8c3d9a6c50edd5d849eaca85466fb052cbb8f1728bb09da708860056c43de0d4ec3ec6cc87063e859541abe91197e32b6f8f339f3021246e1467d3fc2b8dbab4c9f7a2aff60cdfb8488a96add54c57c8f1f72a77bbbec6efccd2669033d0a848ce2a6e768a810dbcd5e809d76071664eaec9dda5a34c213e157e3a9631a511eab3e951de206d38a99b4fe4d6d71f0b92059e57ef7b47bb680a98fc579b393f2b492bfc928a7a6789ee44d22f9bef367523c76ece545a86cf8143a1b192ec54d58e33f3f62ec8bbefe4af9c59fd3545cb1af06acb86fb22be7215400c6046dfa047397c7a68599183b8c47ecc91df60b2dcd42ab00a28c771955412e53bb0d2b516d62bf8405b42bb1cf4cf2a9a742be638f6faa3318e2fb3984ef719ed0289895203ab89b22dd9095d056b9cae1414f99192629df2ea14ec497fe12418b18465dc642c655b6543d9c498516358446d60273a1349ee742fe090493487149327d490969fc0785994963f0a896035d0a4c1c1d65ecc2e5911ac7d7964b77c53dd8453cb7f27f201bf3e0f032df3d74db02891745c6d0a9f344d3d7ee0ef525582a482c0b5e063bede60ef7d07ef015accd0cb5dcb09dcf1702b3c80306ec13c5de02e5cf3a483ffb15aa19e3732983877340e95ca81fa671a2da96cdf9da779ad420d08bf9df807c6d6f64f4e2e1befed738fed140905267962d513e861a15b9fd2f6544a431a79ae02223864f3d22bcdaa3b9408b50d11ea91b4fcadb1ab73390a1c1f49e888ce24a939c4564961ad13599b36ce541b4f3d6121a22738abd09c73c70f75d58d0bb6490877d38f526db2f1739bd5dec8e9ade24253709a6d520ce395a1e49d77c1ebfa9ddc4b26a17f58c0b39e43d231182cd61913115df778e478c59773cc6b73bb5f7cdbcfed0d5f2e0719ecc20a9165f4bb71648293412bba7b683b06a23a25b5115fdc67e509ff2ccd3a74b6c3dcd1e27f966952d9ad948196ca693d2f7feed5b2c5e8c739d7cfb53ecf6351e8f09db87216acf7f1a92acf738ca9b778c198f076e1b30fd6069e57ff9776a5e34c690006df2411e844867998adc2733325c4b63885b046b88eb4b5556e2846c05e40b0d4c7ec470674b360062a0ef75fc2ae7ca2a927bff92edfbbab4a19fac3f673ad4606192de797d2e1270a64db446ce88cf828cccf333c26b089213848002717066a14cbbb40a49ad2fccdb9a875c9f57edf5424649fd53f620f25bd2d3133b61b563b0dc29a366197ce6fb25b754b29a7686c68875c355c82226606896cd33c39808b3ed2212784920e080b10bb9b89b1f72eb73555cef14f1b396965d3fe58812b517b949d5363a3367b67cdd7e90a40070ec4b3c10f2829757bbe20ff0bf7c6c8587d28d2424c7db5a40c4d32b435b82113bec63700b2bba7d33355139d24b252301db891b78b78e41ff1c6632b48026c46e3bd129bfe7e4455577668fa53f1b3a476685c392dd1df37dc55ff8a4b0e049ee48b22d4a4025260818c8b83639cc6546ca2c235041d03cceabdcc58ed6e99d96d099ecc8cc85612e7bea1b0703c484d05b67bf3460a6c7dffc1f1cd8bee66874e1d5d20952e6ba11b5d26fe404e8041796fdd809c07a6cdb35b8d66cc1ab1c9f37ecc50e791aebab9e1d8174fd2c25d0f3487a86a13c45bb18cf9026ea9662a7ff4724c8cf5b4ff04d99fd7be5f03cbd39b8d45489e222e22c6446cae0df8d9b23238a97804f9d07890e473f90681da40710af8c9ca9f439d9db9695f410889baa95611fce3ab5204b43d9c8a96f60ddd51661d0757b6a7cbb7d35fd4eb61c6d47a449c064336f7d64152279552f454f6913beaea05df0ec89be33bac93f7c65dc5ffb278314e17f7fb06975865af502325dd5c87b08c47b9655ec1a00445a0223db1e15fa989cd61557bf088501daba8307be092105772a3c3c13fa3dde4b2d11850c10e60e552e8a9210039c863cf8c2e3a911cabbe0e5d7d46fe9fd925b416ee51b4cbcc3819c16fc784bafec0b6a3ef2af2b6fb5c843809f6b42c8a83c3785963df3aa32922cd12a3b1bee919bf240ab49cd7784b6a2941908795e3fbc8db3c82445201f567035c9c8bcb7394af05ceec7533e79e9950db61af9ede96be399ea9fd6967ff9dd1de65bb064709ca11e2670ec5198c77075da15f2c9a80c80fdb241717f5989ea114c7a59fe725dcfaa9c249b4eed37cbbeaed2c34e5c437fd9eed977d14698150c8885b6fcd1af9d3f0adb1387e089036fb9d107a4387bfa5b3a0b63a596f2e326a8c9b65291510073d92dd1bfc6a93e0d0b9ff5b1a05a3c8383e469a748f8b378ddb773e626b4dce734c9b65e5ad953511c3bc7b2e6572beae40da267a5830804c06685b1b921a9d360d3d3111e0f7789787110663d17d70f87d37fa675b099b8fa5f179b874bdd34dece3aceb2b1fa914df254b565c533e0b0f96ebcea1ffbbc79221450d8d7687c2e67881e97409e3aefdb7e88a0a840117135a544b6dfac99e5c4fb5fd46e0cb863c8db6c3ae13150e19633f4f8bf95eba10701dc1932b1962e2f90748bdc7dafc56b12eddc83a70d7ba52d4195e2de7366359cebd56af6ca1baa0e16e13bd29d056fe0e72ed276eda46ad31657a576e1a24b0876e4a94ec4f9c1d101bdd721017462b6d1e391ffd80bc6f2af16f88822f296f129779a978e21eb54cb27419021ed1f2856d4f886b686a8eef823c3cd47572e1ffbf82f9d917495463dc72aa98870f025a46df2ba8bb6541df7287b2bb6e5a9315743892e18f7cacdadacde98e682dba28fec22126641d7661db17f62746a381fc696560f5f955710a689133b25dc121fd157609fb17b4e21804ce90c3c77adc3ec7d40f2224033166f58b80d860578ac20af2b6844ab6fdd7b598c10cd134b949d05365d90f7b32cd5692fe786ed4d1291cfd2bed13c46ea72404da683e8954a1648ac15ae19bb34fb9cf4ad36b90ddd034535fb0de74fb10013171281811729c744afcaa1e2c2ee3cae0e6c8dd462c1a0e7e0bc1d7fb2681de4392735b58cb611e5de78449ceade8cc3372c851c5e33d01157b5e51a4de2520fa5ee727f2b610b82c73660e1a9dbc19c768570fe51ceee51d2f4e5811c8c26ae112d354d2e54f1a35bfa522f9e1e7eba09154a6cbab74fc9d8f27d23a9841a5bb116680e53652d2292c32be167aa58fbe575e93aa7ceaa9f967b4d5fcff9fbcf73c2672fc13e943526a61c5f5bf5baab304b2b1a4a53bc6357aceac5a74f0a94ae7ca2d289c1dcf06ed88e3812e7a859e99ec36998ca12ce8705b051da691feae0d4001478879d7b2a735ac7703070e99fe56b651243f47740855c11b9aac5c87151d94f3c7a03bd5afbc8dddcbe53dbcd17188cb695d69ff3b2df1c96988d894ee20194d187f9e955d00e73055b7f5206c0ee3fb58c8b9113c633295e407984c5fcb45093602439f5e92de24e447bce523bb36051c69ad43bf42260acef13b6d9424eae7dea9fe21c304fd4acf8827586daa71676efbe09433dd21c0686b38d69deda375c474f31804a02bc3bafbf6ad41ab83d88047d3b51220950092ed4e3bede031b95cdcb2e0fd9e8c303a59fdf7f30de9aecef313d461bc2bf0b89acc345d70864203dd0124375a1becd2e7484b520785b58842082e24bc7fdf1a11edd946b4160bd50a0d637c7b13acdaf1b66342c4a6d476d1f9e1403d57bf63f17144a3e8be5dbc11d75b26e72cf52fb6e2d3719870ff731f7c656fe89fde854a844eb8d7cfdf1b5ac0ad04ffdaa5ef1b89bf0dd6dbffd91314d55d18d6a396b56d0f9ae53c7abe67107337d84c87fe954a9dd83bff426df9b3d0d352e0869f4eb853d197ee40a7afca51a4bbc782f9efdf2146a5495936e3c2653743ec73aca4c2370ef052461ef0442d8e57c04fca4e5bf10d95b24d23c41cb166a64683f98fcc4523199a6a736d258233859836f3442f5f54518f9a3c718b72c1e4e5805805d563a92be4e8784adff30b66a65d133d4900c5e028cf59ba5977b36cc5199367740e5e9ff4ff500065b14be340aa824ee1ca852ba272949b22c5deac6178fc472d19c6c91ec30230f874b31be0390340863e5d17b21339cb7710b7e63371973e7f486723579ddfb8d90f8830e5e56fcc4ad8a5c4f392d4dc7c1b99f5fa65ada9b5d264c3abf5568244d7eb7340f5964507adac782d68c037238b2b30ad57ce9ebd6bc738ffece894337870db241c9474ed68d9b12d05b05ca08220e0616708d47d1b1d742f64bedb8a2d4d6c9e8d441a846585e129abbb226eefed490bfec2c2a3fe27895c72a2ea4f68f477230ff6d0351d7218c5618878b3e3ab12f7d0b434636cf00805fcc9e59d97e492e5bfc7246d2e2dcaa7fa513043e31e6c44052cc50907a94044b517977cff6941763237face2cb50bd18545b394936b383c54d513611ef67e8229aa017ffac26a5de9ed7f92965bab306d9c580a15f4c20ee25f680f781ee31f09b510d12e66188791471cfb53a854b8c25be3af2093af3c974c78327c606fdeb7541474027dca81eca907315c2e1a57aa855e65b134e9a06e12006f83ae8b67986e2883a2c00f8eba536ee52e5b61e7c3e460448da5adbdeb918216c4302d535e9d4b58e56cb25dcaccd2a43ee5d5965208f07344c1a0020c993b2aafc0c7ec0423633422efe86972710bc9f987fcf23ac3e263ac17ade26917c9334657cf24e77309d6a73ac524e070d9bbb9e3eba4f69a1c1a99d2394f06b29212352cdce9ed76d559335ee929e30b76c95756f3d3043f4bdf1b93ee5773817afe7723a4d41761701fca976ccbc92cae6a7b3828daf1cba21e6647053a5cd4c48901ba4fe3508801581cecf37d36557887c3aa24e0aefdd5cddf733d22f2dfcf926ae2fc33efeb092d6086ea008f68d3541562b9eceef4eca53e6133820996c66a01a9950a2d467908baf5d0090d81f57d88e9b243597fa4ea9017bf122e6fa382b975c402a326d57c14c724d1b312db99ef216d8a5314d5bd8fa698950037f5b45669d18594f4723edac4137bc79fb84c82c7c682ade65d28eb2496b081455776a16b28545f5046e8b24044426c049d163bc89a32b40f9057aab6d51a55b02cd41ab39aa6a7171c64e22a6dbcab4b537bf41b56e7275aa855048584e401df8a8f07f62205d39562673f4668bd31937a1ae595ce8f5eb5ae20f6216fb04b156d39adb529a3d12975055b28af991dfc5e1b6bbada0b94c9a36f00113b4ad56809dba5805b2e035e9c6ac67932f81aceed5f8a525e637633d90002b4545830eb2166888943bc5ed3740cb6061f3a6107b9e37df21cb96461f7186e9d69a05ee3c073cef302e058470e0e9a602b7ac6f928b7dec521fefe98cc2fedb0c846706706d1873bd23e5f4a917a94fdeaf706a7b34564f6334e0d124a167982247c342b19ba2ea0357e4abe253b1814df4beb2d76bbab73be82b7102459adb64c9a8b45154e5a2f69aa0b37d7a5b500e01b2ffef961771f29db4a8a6d3c5665c157b446b3ea83a76638b7785ec1543808a54fb331595519940df19b5eb3200fd00c3ee2114be9afe5e6881aa4908d421a6db7558ca6ec1bc6c461b88d1d847b1680ed89f083efbb1cc55a51253286ca1783250f68ab1f1506cb22ddc6e33bda7efce29e8e6d7089d1a64fa9ad65b4d49b64741deca310ed3ddb7352f1c1210c82f6ea209d6acf89dc66fed5255e6813a7be494919c3661c4a67f7d982a67e5d63dc17c9bc5d1e38df60d670afd7fa0dce5368606dba61f1190d34fed5e35583498fcfe5f10180337a089a636069df71e9f645c89a2683b44af391d8a54411de56b54952c2631b38aca1185a8a6d1f70587b7b9dae66458303d2ef2742ae611e34b1a5238269254eea21df2f2f92da8d6dc3255786d80cf6d6905b863b4d29ba5781452690f37f93280b7d458920f6c519b7a7d807c00b9cf500fc52f81ef8ff1de5736d8e28d1184d5f128f2ae4b75860a59353c0f0cb49e3bd9670a6ef2373d6e7ecc59209b52faebe2d92a8246e6461076cfbbb5e3cbba4d0a2a3039a5f946f1744fcb99e8c82c52160e66f461a1a4e23378cd7c8917b88bb12418599bbe3edd892569d472032edbce43b6c6e206e25caa76da5a13a51440aa47a7dc05512301f72ffdddaed4115a6c7d8d8da5a7fa41d404fce03ac91292586968d1057e0e951dcede043b23191575c824a36bc87e9908954e029cb7d7bfa767bac0757dd1fa4fa9829cb15c93d1d37deebe0d07d84f317baee72eaac607c26af4fa6f7b9ff71a9ff93ae0a5fbd8e3c6abac75e834f7cf9abd0c217793b0e0767bfc042110fdabeefdadfe0acba26445354e460cc5825ded3629f21c44de67ca8b47ff22f6e71d1cf6b1049a107dae5d571db18135260dd605beb72d1e4a4745529105832e64fbedff05dac406c5fb09992ebb33af2c81f6f106d33ada879f6ee046cd46bfa4ed6aaccc4627c1b12e879131ba9b7ba4be9cb3e69c1cb017ce117904f0425a50718ad8a8acd9db4e575a9f007624c98346a60ca35939cbf5c3b70a87a34fb7b8489d88ad2c13b206cd27db9ab2e2578c9adac9b66fcce98425c9336918c8740bea9494d664331f762ffe9e9746da83a11e27b30359d9fb14f72c648769eb6ea4b7dc5b4083549ca12c8d5bc60eac8b7de65bab62448b87af78e7069f90fb8265cced70dc319c8e48a8fce5f04c715aef344ce1479e0f5fd9dc8e047b3ad338bcbe8ad78acb043991f9c1e5f7516a366e85b3c5dbdf5422b0bf01f953518abc223e73625b8d3d5a72deed8bc04130b6aa1328eb58185591cf28420c82e675f3b7d3c21932b89444e8d6157caf8d3cf5bbdda7da6cacc02280d96ca521996fcffd7b510481e22bc43e3b1c415d810e25b25d202b76c652cfc7c44e97fa915143d4f63be871b92d1f444a2e20bb44d80f0d5516ae5a0ee58853ce6a0bff1462d82cdeb12a4a5e4ba1739e0599d0763f13a54c5aa45fba6f4d9bab6866a0452e1cdfe44727f1dec1ef0f623b59acc91091ce350f4c68dd0a383fe4b298722f78b02277839ff1d732f456ea269f788d1f9af238bbf186116d8d6a179bc28456982e2800984ca7d1a083e6bfdd1d2cde694bebdf81f5887439ea356693dc144a57ad9103905bed36bf5287dcfe6e0af6e32f6421f0b2b47173b70772a09ca8140829e3c001c6676d20e01cfe60f310f2676103f442d4f4e49cf50d4f46f28b756f326e3dcfeb5baec7ef2b67b0dac4635d245db2cf1873edf519cde4aa564918bc6918c65064fd209cde69e1933fe207f69f23ae8077481c6d73d3815b34f7b35ac07f9e4dddd5cb752a596f45c64bb1bc589be6227ce2d9208ad6e002bd0cf4b1706344ea7391bd09bf560b968cf5efb61b9dc9c90cc2cb33fc2ebed0c2e5e444296b95ff9494fffaf043dbe59ea8f1fed515b125e5eb0db7136319cda75165fc476815a4df9895ad3a2adf0fea3442f266dcbdcd1d01c0eaf4801cfeea2e00ded167839e9c0afe9b170d64a4b1dbf041be36c80d4880f700025bce6f9690dc4c237c528c319bf8ceb63506368539997bd32b6d13773bb0f660d018fdfe408885273da7627dbfb073607fdb42d619e6033a31582d62e2914aca04a202c29204184024c7871c0ee006ff9b2b00ac6b86a65c5560f213aba2f084c18bdebe5f7882816a877565e4e0446d7f0b01c1ad7ceeb2eee4f4e8bfcb6f8f5736f3811411c56ba923602e529d7103b8525f2b3c4710f6f8c5c1f9d2ebfb496842b32e1b1d82676d1794b9080baf124d704014dd83ab1e559b405ea105b09e32342dab507d9b206ce4b569b5b9491393edd77fd751b473ef646c687b179739bb631653ba99a194754247a6bf93f5352eb7f1cdbbb033ae6f96ad141899547e6243e6f0a93acfc02ff91638e06358c300f0aa8dbd9e8b9a87ad685b785a553ca9c4f3da8116a7949c239008911d8d4a30f4be9546b045d4f2a73a15a83603a7690063e6c15758113ed40fde561e9602ae32fac1c53729d74417c48341dbd55f40003219bc3c817690e02ae0a0d3086b308d31b24ba7e98e169c01e6fb5384871ed780679b438b3f5552ade6ee809257d46adf888baadcd9f79cb2c463093ff0237f575972ac89259259b39f3d38de103b9e3502e88c41f830edf722dbae69e42c5be69dde790c0e872418bf4c70a9a80edcdc10953b20e2f8f044195e1b29fa002828aff0cc7b04a884f75e95cf76e76cf2e833dbf0d982695857dfbd85de02232c615c09fe00137d536991dc9344bdef4ca25c89d6204355ce1cd86cba419e91d6fef4d7acd9f67e6eec1cc1585d7c7a886ea1141b262a211d9e10dad762635cee3221b2ab55ddf573b9ac66ed59034022604688c8854a800f71c74d7df04fe1e9aa560a6b471a3bbf8fbfc34d41882489da8299cc929e8ad146271a49ba4ffbe73baed0ed2bc1c3ee41191d2892f34a9b003a2a59a3f68d23aa8e415480dff3a3fc69f962a188957392d45c57f291639611b6390abe7212519081282000ba432239b2346ee8c68481dc6bbb7f478959247c18036e980aaa80bae11469203218e20cd71504183f5bf4baa96f5967d1f9f1105bae3d87cf9e0bd8ac78ccf25155b7bbe5bbde39479c975c4a9ae53f69bc2eea099e82ac1ef3d25c2703c21df43edbbf897ef889f9369409c5550e94c771e485a4bcdfa6231341e4b72034421cb1ba813227d899f96f3936c6792f852eda8165a4cdcf19970db76b72a2ec80d3b20de9fcd977ebc199fd831c299ce71eccc40a115a76015dfdde5d616b0147719d99c5e25b9365075ae821e5daa0a8a5bc3db6494afdc0af071f49365fb09082e5d28353a4c2afc568088d0996a7e3e833eb721066bc0d683ff679df6f593b2a50f21c21b7e9286628ffc056060d6da088d9e32f22f3d20896896498a2be175c08cf2446bfbfea0d890d1dfcf55584d1162cab2e3feea21b89b78e63c35af55e0f85b3dcb4de57458956ea0afc76059d9395a05c156ec67d271e95cc2e33dc85efa41f08680aaf74f295a71f8bf6ad17be0ad2adeb1e0f03c4ffc909f22c2373db0f0a6e910e96544f48c88325a4e8c0c41716aef334d27f3520bebe7b8075d9a33b05b363bc6e6f4bf30268418d9f6828d2181a6137d523db25e11a52e4f8bb6f5a5724b717434496b5ec62b27da56c221ee93ba0aea3c65c23e283b427f408ddb8d5341385a1f6c7d0eae065a2873fe28445bd6adc264fb6763c1c5e90157d1f722785ac8ff92c4e37b06e6cc54026c7d8d218bcda5c0f7a2471a1321ef5d906816850a982cce976e0610ad0fe9b9ab74d23e4ac114733e51c6b24d678f8166df5ad4a439a789af9f3ae75374736a3411b94fdd13797c6d1bde5bead87fa573e2b3b647099cf08e89624f72d87de880c2cbab9c45bca1eb9282eaffb7a9dde11bbeef96ea3089d2a2f82d4335b70352ed74ec8fd3e3cbbcb2c992376ee9d8a6ecc522c9d01f27e1ee9c240cd24a678099591de42c4b42d5fddf7757a033eb24f2c543a7e99a217e41e3fe40107ff6646583c455ca724d063ea0002a65397128e31da3fc41e812167a0307f8b0737ab20966014913d492d09c8c848ef5d656ce9ee94ac7d371b7108318ce6a4d53af314cd2e065712264b6cb399fa8a030d791ceb1459b1278ac5dd4945ad7aa7ca05db09fef2effbb23cc3b10368d1aaf6a43aa317de55d054bbb8442707c8ed573de9c72df4662fffd0ba932d210404a5c70f9dc0a41b41deb17c635b4f60d643c3db73fe0780b08f989e6193e1d48530b41fdaec4b3d70f7d34e82b10adf57d96f76ccff61796c81412bee542eac7038cc2003645f981829176b9ca7072bbe71e1963518e6ad56eb25e2cfc567abdb5200c8292cbf3c34fae1d1b2adf4517ef202330819d5203e77ba22718842e019f3586b483b97e1293f354eb7d3e24d4b40cb1a13c0fc8c33f49300472ece54b4f38efe7c2c93c08110d8f76d9c4506011b05fd7e5a1daff74c1904467d08c1f3fdb15c411aa4d7597f17c2adbd82d6c804b8a95562416760b79abb988b8bac84e5f34e8fe03eef77fd69a69843ea3e453d7c8ae3a2ca966b6d48e0d96bf5266d0aedbd92accf3c9406310167ae1dec8e335bcfddde9846ff15c6cb02dcb77be396906d0f2484c61d7ee1310bf80407db46ca087fafbdcf8ffd894d1f0c5ac2586772202404e78b049685ba6df425c2a63b500a9518f4bdc710f944eb6a55be8e16cb76802635ada1164352dd545de688a8afcf1a87812ff6a479085efa79b1df699134feea9b929d014c0470df6e1e07c61e8862837d3daae1d19e8bf99723415fe85d92b01e0b21449b9a48379997c2311031849ef726c1fe63626621e01585cac171c02bc45159a575b085e075e279c2350a2be61dd140bfae9383c7c2a6272f27881ab3c180ec4671b194195040a3265b964253e4fa60b85ba8b5367e8d164cbf36066c6a1d871d33630d8c1b67969d5479358cc9e10e2487b315b57008","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
