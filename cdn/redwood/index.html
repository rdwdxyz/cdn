<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62685fbe95c86b616115183fd69d992e0b892a36d894a32ebc6b0074a9aab4adb048c03a0c9cca633ef41df79d4908c289c1c3af5b5ad4e94e447d6b7f45a580da9b40b5e2ff16e35009d9ccdf6568aa9f96243eb93ea5d045925e3944039c28fc225cf0d2f63b3d45cf64324fb6d53206dc0875d66ab2be668ef4b485603bc6371af5fddc05ce04ac571fc0ed1e053181dd90682f2108012a6892383d860fc7c4ad388f716d422d5c1450fbfecdbb45430d7629ebee12b4d3534bf60e029bb094726350dba91043eaa8cb004c4df7db56b53b6f26369739e1a228070dd811b52677ed66fc22f19f1f288da5fbe6ad32d24308aef864222513f39bab133a9d84bc49b4fa47b761e9deb4269d0b88e7f1942265e594022c6c1d9d68215e712590952deccb9a1f9bfbdbbe63f235a5ce156d98c7ed1c57545705ef520d934ff727d4c1452f83f2718935948fdb0f62a399b05fccf8b9cd313c9393fa5e64fa2b571ad42b76bc18e8311a56ae13551e35289d17227f1c4ac73ef82c0007f04945d4275869e0562ff30a78c14dd4b26d5e6e6b46dc3eee3852fb97795c3efddf077d88fae15cee228dee428c55f35cbc506d1af8ab6be8566f6b6ad4dfabab681000cfad6f46e34fb77dcb5e402636cde4804cef691acb2f40330964e3a6d34c59f84385536da5b5bb774816716cfd4e224b271a05ce747f94756d70e043a6c865403b3438ab6db1cb14b8b1b738e2e62f8b1c3637bfbc24ece0e342386ff81e573e454de99cba5113b95747a98fee350567ebfd84ed5dc737320ad93760ff9d36deb0baa622a459b2d4669f8ac26c6a7d65d7e6ec465e7ad174cc14b3596344b8d428d42822e31799d5916fc9480e3f357bce3b0b8b5f3aa5d84cf6dba726bc1c7af4b2ecd953174a0a6470c8f76860583b64eabde223102708e380825daffe7f88e7826a909d157c29bde7e6b4e1da00eaaf2e244346cbc8e09e65580005543b763eb922eab9cde9ec35c17a2e68d3d5daa5c4966a335f801dfd4ff469ca55b8c3c58bec7be6b5ac617ef64c2802345728aa8b2ceaa02935ad598cff15695d7948a926de245bd6668821259c7b29384b910cbcfbaf9237aded4acf25cbb8f5d8121b70c57dae88de4ef7ae4f30a639e85fd315280bdd2dbdcf484d021a9d62bdd515ccf1cd415bfbbe1c6a4ccf9cc78bf0c98ac9b078de57c41c0e874bdb5874d0b8e6de5b1964c719a211c982650df15cbd4a23df3331882a8feaee185ba6857bfe1784fb007836e4f4c32cce13295cd358407ab8e8cc36042416e5d414787ee9f0eac73b0ceb5cfc778e3931bba6465e635250144a50772efa1b14279fc2ed8c161c2940061c0b722896432c4ed49fc99ddd00881b7a1c7c1888b7489ea3e4eaff6b3616ffe47f2fc39d984bd21c517074c7d575262e114dc9cddff3d3a8a47bdd473d724011b336b3b617dc2a9e6e04b88c6b7f7a0264ec586843895d3720cde598012ea751ada3296e11f70049efd176d81ebfdc947159bc9e8cdf6c59f3dd52a07c34324a0c8eae7519b59a6f6090aec8584025687a81b73ec88b054b031aa89f82c1d2bde4526b392696c6c5c2d213d071a6cff4f26183b71ff07a1db2cc30f69d309134eade66c90a09f373f3cb0c483ec27778954c0ff37a7fc8b0e1afea8ff02ea8b678912a1ddddbc8dc000ed0ca0246354681c3390f41e7fae35e5ef6bcf38b1b28c2b947c02c7af1f2a78f04e7eb5c42262cabb6ad2f49b01fabc4872de60ae3a00a7ba25df8faf51579463d65157ecbcdaacf4435aedd37a2ce65805ed83622aea6145a78b459c693b84776b4a5464c5d5d98335cdb958f8f1ae80ad969bcf0f456ad034c03a7260e45db3577e01923bbb27f2caaca558c65256a2a233f11f98f4779c1a4cdd39a9471fcd21ce71790173c187910a94d5549777040a99b43a95ee98b91fb5cc552c560df7ed128e3f43e3ca5d4c6d68e332f2f6570c1cad5acee1f04646f3d462dae8d2aae28cca71f01a9ce98fba86d00d9d5a63a144cf532849b6719e0d3ce64b66e96b71408be4c0910120748b40cca4824d7000aba3ac5f0bcd2c0cb70b9175202abfdc7203b8b27f53197efe77d12efceedb361caad4e84d8da089c0dc859a1855676b5c7b4a1585abcba85d0b8f69db71183b1bfc4b724b7ccd54f930e9985a237fb011a0e9f6cab2bfcbadbb2026ccad9eb4561d9e85b58bf8e1aede00f57ae7e7c25cb6f0baa894bbaa201e2508101db79ec3f9d4ba89083eba806467a474f1b63278af984c85fd3c3945ac3e0fd26b858a1220e97142f060438c9e421f6a22f29bf0422f524c0b4e18324bcbb5c768a82a45dd06445cab24855f2765a06b4b3cf1051944ae701f514236ce7a44c4ec37a3ac15812797b9aac2c2621172f0e2b9fed0990ceb799e742889d6c1925378301b0f6cfed170f17a31c4ec02f2e6e8e96628748a638561d430a8bc218699f627839b9d9ee520211144d897ac1d4e26604ecaa95fee30eb17ed2fa84b820465309780dfdd5e4d048fce97d1af5bb48e7585c877fb8db1a1da5ba0023aa108b91b30b387ee44cd065d9f428c36d53367ec9eacb719c5a1fef62e7affcb8e557ef133cf049f4165f8cc5da0084f14a759bc8ee98d8aaa5bd8e7b5140994831ac3e3666920e0d5fdadb8dc3e7c69056f4479b33365ebea382be321657412e19e77150b2c01ea9fae50dbd1b8c0ec2b88d54db7ff79820d894a3326a5bdd0f941a36b5c9739e5defc1aece1108bb4b1e6f77942fe62ea1706fc766278f79dff54af4bcdcd6a225e12a42801da2d1500e94806dd5cc657a1160612242c2ecbdf24ea13b38692207c814056858278f78b8fc742d9baaa0b3bb80129c77e7bd72953aee8cbd9f969d45a42adade8094e96917a728954dfca66fd8bd981de6b1329093e8a4007f2eefba0a7eae07cff442a176dc5fb1cef59e0e23648c05c4ee6beaeede7d9fdac108c484a36d7da98a580c4b286a378d07c9c4f9fb2ecc22f584e697f0d047244cfc55db8dfed995ce39b3e7c15b1dbae1f9b53dc8938adcac4f072ca1d207da6f4707ff2894c9ec058535a8607ef0a2915b34601bec91bb0d5d697a390fc0ea2c0fbded92f5150dab8ada1cf2c6083d7c256016977faa75f50ac3bd38c3b18dfa9a42e2743768b0f2482fa4eb363ddcfcb524f3796c29e447271ab89f6fe4048da5ae1d7301b4845cd5d6f0aca7407d2a189700bb3641bbcbe8c957a8bfd5c39a63c8ebf3ae3a6bd2afb0b95248c1ff20e11f9c3677be109714977ba21f2e898246a4e27b4f4a6ee861e4f40551dbed244d7f39290a38615804752aaab238db9e1da766aa68ba99e153f9b68561eb86cfc674b375902a3f4b84e0c1636c0e1fae2ca9f4e19c03a4fb709cfd376ad607d797a206cfc095340df3e319eb4fc2e420298c49792910f81ff7b820e5806136179590b5d7cdac5d4ae3860e40d3b12fa37d581bb672a6a919887c1ee3d7973ba2464fd5affac81493fcd063e3b5386a517a49341321ad15d5eb56ca70fd37466a3181f82cbd24f2087c7c615dc182ba6eed5f7b2145cf1359e62480debbe977c110f483a158e84b5ecb6b23a9ef81bc2c8fa02caab94edfb1c05521602534c8791858d24d55afb3cd74c30b7045c3f6cbe5287f1a7e9461100af78d3825f4e05392287743673de48e6e9aad18787d4e8e2427f8108934c5c6b8af4dc0aac8c331dc77dca8693fb829349d23bb208fdced846b7e91623921415e4e5b0d718e4ec58ea4b8dc00783e14680853d2a583c795e66ed68bcc5a2db80b196055c3990e72734067204f0ad794779690f9ab71b9e9c2a23484685ff9f8c2956fee6980e44b27fb7397d52c6ef82b620fbc5000aee524e6fe6c5d3bc416ab48c2ccf1fa2a4bd38a329abf3c6360c13032562132c5587ae232ebeb6bea6d11a8a6712935869c569f816d3a81d0c1dc0d639a093e0ee2b8595c19d552497dd545a73209886d2fc5210f95857d648f67238144b5a71d82ac26e78fd7c25155a2703dc0f2f500952d1fb0c6a4da96e40a22f47f5894e2157f13ace3407d597be87443c8e31ae510916c7420256f215cc3549645f3ec8e6ea2c7865c1b7742dffe420528101f26e802e1404e741c08881443630c58a2c2eee09cd65e68eb8552ee99b1a3eec0681b314c126ef2c2cfe24b26761eaee2b39784abd56d22b4e3c261ba7261b87f8f9226e9e25024e5a86b561decacf36d449a09e4a4811ba1db59167399d35c336480861b15d99311eab74d79d3d10533734c4b02f103ffc588f908512b3130cd3af89e0e2fadb13faa1afc88d8db6122d395e7460bb42a108ecbbf58e78c1efdaf777e2766798c23f028852266bb5c68357f1a712da06ed26a1c817a7e61645ed9978a599d06be61f5b01b5fa02812c4ac7fee2861ad51b1881ef5aa0db4978b40a1896cf5fc1505f7aefe1f1de8ddfb6e34583bc5532d7b1c204e7ab6fe9ddad7a6c7b7f8257358d5c790e04ca156a043c642a56fa544afa81ed0989717f0c22c4566c17efee82a82c69b7407bcaff7bf8dcd55f4f1cb83fb797b3195ade334700e335b5f8af095779db949339c27cdd442badd5b2272451d15ae68e16b689d7638176020c13ca25d296c212527edb744f95e6a038475e316b20d47a388918a630149d308de91a2e4f0f13601bc055452e51dde151c57a51aeb49c815c65030e188cce3f16511befbaae9632b6e4e55f7a16ea19eec08b78109f0f4bc8274affc2d9b1b4e8a5ee3f6567e142162051543f7cc8ccad5ed4ef711d25839a2aa94a648f5c9487a4366e5de99f56e2feb4a9440bfed759b7c53f7b8fd995199e1b5c456afbacf6c04153adb38bc8497400abbc07c108a45ce6ff601fa34423fcf798978408d8499413325ce792c463378fbb8dfd2497be6baaa5de6166d51e6a2cffc80c76f0527c94c772570b7e157fdc7e2ef80a0a3a46fbb4922d6b65ccfc6859daf8116e237e5d1855ca0827270aee137a5c721a2b91278d77b3f84263c3eea19886fd99becafd4bcd6886ed7d37de73385490062b7ab0dbbdb9e871ade903286e7cf791d5893c9515bb5ef7b88d5171641b9858f36872a331950c3ba6e80c39e6be0d5fefafe93b83e104b42d0e2bf14c63c735e700b0b9e9371f7875a83754a48ffd044b6d8759c42cfc5d95063375421074afa6020701f2ee6ae3eb11ba1e349a9488aa92c0354be7e2d1a91381e4cede87d851ae0289de685a53e307e9fd34c15fa6c0d53f956fb036e9d1f89002463a7f7ef0f83f6a6f34dc9e3ba20cc9db3439c1e0f7ade30f3bc9ccc8eee117d58deb759c77e021467d378746b4afb1060fb7cf1b4b450c83732e3d260de7cf6087258866fe613684c8fad332782efb1c0baa42546067714084c0248bb6a89b37300db830dfffadf74f6fd2518423202d1adbd3eced1753e08c08dac7c80425891e73d5179acb2551670370bc2123deaecbc4466a4c8e111a1ed66cde3d352b7d5472bbc5243d2e3bfd307307eb08f941aeba5106197baaeacbfe04700b4a34de98482726819de6f7c779fffccf32a8f620f6d8bb2f187342af00a7d9793f30557c3ed4032675c0a4a8d90b8f3a554eca3c28ec4ab5c21f047e9031ddba5ff9f579abc3e8c4b049e2748b0aec89004453f8d7e49ecf330bca1fcc301e2830c8786444bb85ba5be0e8b3013f26d9037b9613eea3f6fdb00c3b235fb748efef8aeab39e55a844fb8f1cf22c18201c7c285c230bf56f4bfa6854d2efa9f64508238138238e97fbae7146b22dee154d4bbf4e757440c79ab6bc3df946d62942ea50d7ae411f81f1205c03226583bcced2a2bfaeca460987b92e607106a405119e55d5905b67fd09378733c505b7f3c3276b86487f8335c9329dd9051cc5796124af5cb3208f8143c3b6eeecb051079eebd31037c24a925f1df9108bf2c57205211f0f5a64c6f46874757c087da33811d7662c31e85cc751363b28f06217fbf148c63b0003f5eda428d0077f5794f519e511d2a3b29c6f3578628f3eb1c73ad7ed27e58c2d2ebf9efadf57b2ba876c9cd0d499fbcc2bf036c948584c80ba4ce4c088c953ecc6972994ae4fa8a90ab4e685237fa1c6e0551504e48bf556a25981f632f12ab188d667c7481506ef0bb9e404f18057192f659f3f6f8ac1e042fbcace5193f2a45e9f178a1ed75693d20f5ae84ce6596cc242885b3a196ab39d6c5f2e2577902370a7709e7183b1c8b3f849df1ff0ca48e3f1a8b877a62eb679f92694c1ce89fedbdd9b75b6ed43156693bf4010be6cc917fc51ce99b9d29c6223a21b657670aff6972d10b66302d2fa96fac804f08a05b5e055dea88eaf602348bdd602833bc763bdd7f8ae7b9053a88c9165c5e5e4511f3386277d47b1bb56090ba7553f45688c92cca5bce37b1af5821bb6a9a476f7ccf868d37809878a734775204cb316dff8e8bb99923cd66e970a238d39e7b9771d4246361dda64b7bad4ff7779825f4da2c1e658051a5853b76b46417cbebddecabcb34880405159e7e063feed8ddcbc15732b87a7972a09f33bd8f877c3c6e0ac4878167be9876482a2e962b4f9369b50591842568be32e41242db6a62109fb0536ac4c1c815b1f2fc5948ba5ea19dadd0921bfc098847064f1270e5027f3dc031e4ed212ea3c7237f480df0f141d2bd6ae7432db639c259b3746183bdb0c965163cf5ac8f705342ab71ca3efd548ba5e7411c01662229008d2d8b8fef8baa7fd454141482f40e923e86cb112fca46d8618a4e67d1275cab91eb1183640d1045114fdb9f68ca4413df1936f3b89def2c5181893f29e25fb8175d1612444e863025f7508a295aba2865fee76f24522f5ff92f3caf1312ca22b49e354a4b3551e5fdf5b7016ffa6176578d381e1d240493d2dca7d6e33c9634053e30bc8f7ed2ea5868767873a0b2d172acc45ff8645e2c413443f41bf0e25ef9a8e29324a4213a495d1ab7b10c4e06e44688279caaeadf2774f4215074b975407da5ce4bd82b5724e4c983fd0ebc42806a56d75cf08885af4d16677e12caba10086def3d79e9fa331f72d355c45bf90b65b1dae94ee4054698f5c1b188466d65e0fac5f999307a77796bedbeef442dd143db4ba8eb6dc8d50c2c8d7a9dec9ad9fe86c74abec60c8350ec8f06d8f2b4be5120774322a93d98149e3d3d315498dd1c68260d807b4e7d20ebd908f50120ab7f43928877f3a9d79e6e2baaaae8305baae514673d654ca8312074897b8dd7ec31738ce2b9e928958cb2670074c181559084b571e39d8e391428842836a5af160f04af7fd9e6c7d35f0b6079123e5ca205808f69bf63b50915d2a50d9ebc9ec24022cf27f11c88df029fa458b9f45bbf40a1ec309e788b68bc69a8dbf62607ca50ddc8085dc9fc7950bae34765dfcd6c43e313b85f2ba9788badd4ab296532f18d8e9ce321f2470f5ab723c939a2b650010a8d2f9f193e75d716327bb1cec48ee681caca54804f8d905c89f482e68fa2ecd829bbebb2d52ad81039b6d3c93ded86969826fb08491d450eaf73b052cbf76b141aa5e62df61725c929f79d8a3bac2d82de62aa946ef99d00a36dc08f8afe589cee39a427135bb0741b1584c97bb7f32a6d1d82969e144cabc3113f75d3afedf2efe53c592be9e11e2cffcdf393dc36dff9c665d1d1f110209168e76105b88f173346872df4dabaff39346ba3ea6453d72231fc771b11e33fe2f942e327b80c4b8873086c2bc47b9d7cb2d3ee218f625a64ed0be06beb66cd3df2d8cd15f5d7ac87f76beeeedb846e9b169829def847d9f6957316a7aac3bf72a7099ea972d7c0d03eb21e9c6be4ec6cb1a83a06eae80f65d36714324207147764f5c57d501d091761ef8a4c0520db38f709e190eea1822413f1c0a942ff58e51f4eb6ec5b4674e058f1ebbe3c9754d4ecd0e082fd80f176622bb9baf285a8d2682df0b9e989150cf4b6911b35cafdce9acb2ecfdb7531c581b3fa7730cd9ef6b598d2905d693fb82641d767867db113f1000aa18ed3210a3dc878ba866202b2d633d97ee602f27b1a770e30d66e75269f254a1a012a76762716a68d13547a191bfd0121616f31e5d59c7d5a1b36389a0ef67bbde1551d7650b11400188f8e2b88c2bf6472a51943058fe9feef6803542c9ed9c2575d3ae91c02adb581c2ef0db059e70fe1fe8b3441f3076cb446e9f5cb36461e33d70746c7084ab53c013650d00a62c4d506994d2eae116859e21bb2e6d01476fd731d7ef699fc3d47e9e0e6eab1f8be7c09a485ad7d37603c4b02a47c176fe1f5486eff5e4ef531cb1d76dfcbab4b25e624fe24a8f619662db6bdbb730633e6ed38902f2fbd047c1618f0ddaa1676f48bbbde455a060471558cb7aefc7db6a78fb20401504fa7ed727f948645e475de8514e00e6e23a7bdd3302a120640c93eb473f2c1157973aa3b6370e526dc8e872f646021f4a896f1dc352263ff8f14b6bc080a58698cc048e00c4d6695d2263e56f894d9b5974bb6ad27128f0563a37231ffc479d74950dbc378b4fa660360a6a34fda4086e78dd902e0361e675ff2c0d1cfc378f485436c30696d3b10cdbc0925c751a8b6811b69bd4f943f6e7d8f72b6581558e3b38dedc9a35447f9b6988be1bd895ebd3f091d0f0e1304c0a5903766701046bcfe5768c3359ed1a6473021a9f91439880d5220090ed93b6c40efc47a422870c615d6d6c1a1e0a3951fee06c066c4ef69e1bd1e2a482367fe899c20f7bfc0e62c976bdb9fe59fd54fea7da7cf834c298d8961b24d22ecf433b48b0e19bf2169d9cc97621e9d71591be3a16f8e2f1b1f38a96cc9a292acd837950fefac4589851321148e998d161d8387fbe43eefabed1468c91332bdd61d221fe75ddb4d8ff4c7de09819e64d532d9205a4f29fa164e59af25e6ef49955b74edd428f68257898b1de6518f5ce6619dd7d4e8aec6379fe8f91f6efc773a484d9b3cbe2aa003a2016115d451f39d83302bc0e16652c7abf41470e06eac102659fd9dfcd854a4320f6dd572a6c05d7b5048c06ea8f2ba4062ab16bfe5bd1a7b2488b8b3ce4092ec91706af9b922d3d90c875b59e67eb8aab301375ebbc2f355fb054ea55859c3cd9d21d18e8f3f65a6bbc0bbf3dbbb8b486508dbec0b43baaf326019ca96c0931f0b301de3e46c4f1e73c2aa2cca594f36ce01be4f4c92f9f885193ed80edfac47b7ebd4f14833c226e6342f4e343e03c87766d509251702603e59c5b2785e9858deeb23e8ac92d02b4d1bbcb4f86d04d04d1fd2c4413455efa6c5207b86967973745ccb36150eb1673f55bd8d61eeae3d5898d20eb6a45683b6ddc79cf5171afc215f181460ad9a9deba8145f8b9e91dea4d3c1d5a4ff88d3f9bb9ea486981f55d68acae6f12747e49c1a71dcaf4c1bb325c2047dab7c4185c36166c8ffd07fb61b66c3ddfe8d0cd8ad412ead5054b6546cb0455339423d5f5fb0653fdc80f3be5d68bf32949814ce0b72589bf4912a4486bcd5bbfae6730aa9c67c370af85186853107ec7f7afe63f8d71d8d73ae8346fecff7b5277c6a1646a2074792a3b2960891640abe8708dc554e75194263da1931f36162d35e420becfaffcd549edfb574e2cc88053bd27f5af5d2ceb670c7f4b728106e09b069deeeb7e158dff2d3a329c57ce32e220eecde0bb4310d71e520ec07c5742901e83d711a681f804a4dcee064b30ac5e56cb95d2cef032ce9f53a7c96c39ca39f332b72111196ed591c8e234b2ec037425244388bee3aacacd4a3846526b97151aa530472aa31c680e83e150b205c4e4d4fefbdfcb68eea6cfef87fd9bb8a7d0315b9b5db89e77069ba0cb721ac3701c2e9f5be6435ef8e71ce96fe60234bde83526e40d29e523b9aa7a5c215da38641ed1ff356be8f2ea711307e902895a156d23d5676440b3a07f2c9c69f7c51f27309ef2fc9cd70401840302cfb9445f705dc08bab8a9a8c3635473812b1174463322763ef0ec635921c62a3f60726ff046cd2f5253acda126e53cdac4e474382189c0a38dd124de56998a28e0349614c38769d823acbf3018b0fb7601e252617958b0d7252d4896f22b96cdd9a44f3fff7ada0f8d1c658ef186e30e72a8f968d30a38df77cfa1f12d1b7dd75a8e9e33983a9d9639b7edb0b1b1b67b4c25c11d9dd8ef4148642cfd10977a41f9a09322f853fc2e569e66fbdcc130815346e1a6abf517e1e559025cac3dac81e1b1ddcb867f8977fc9a863c764ba8d30c8498bf316c547117a6d0df602fdb509d7f6f479370fa55917229ce33f628d188c336eb92940bf187c7e977d8047c5cb2f1dcead17b074b5df8030dae3519685979c1039f07867fe15cb2744270c2332d04f3214d6f07d97e7b69e9b273747ec592c20468e8e8a7856fd4b4817b69c229af52bee9389e1df61524c30885d95d2fdb339b9b68328b8a233e86e6ffc92cabf2194167c41c866420439978558d8752a67fdc82fde31da72f8684f559ebeac28f68ac830fd969b84d41a8a3ab2207d4dd193f828eb03ddc78b260ecc270b536b46b7fc69c4cceb1e0e70dcfaba6f3c4b819455f32a8d5c688477694725c4cdc2e8fba54c6886d8958af6edf6aac97d1c1fe924b3c537334ba76109afa0c2646e8b596b5699fe24530601508b43e58750ef52cb1117fb8c9099358d29b431dc07303f1da3bfa8d10da3031d9551efd018cede1595e076d8af758ac3fa6743a726a5deedac38b2e55d976511e004e4e1261b167d726cb90f774aa43cf434bb7177408bf7e603242a180f8aed7675178f4473d00c026a4694b9690a4309544bf52008d095d1d8d83c8526ddf14f17e418a13b1b5af6fd98eb435bea42a7dcf20e1388556666f4285b5ac1b61accf16925ea9d62d79924b3e0bc1b6f2ebcd9d299004b4ac0166f56188d6816a865aca197123453e263ecca988b4c1448d5f0149d8b68b076740bee2ed9af3dfe6c59a54c515adda581ba2e99297ccf3c9e96417f9772c2cfa99b2771baea07c174275ba3db649af0c43829c3d2d1dabb7049425134fbc4e3201ba1b8df719aab9f2fee5034df16e241a8bb69ba0ed6c72edf42344268d5e5b3dbe005c0c42c0380c2eab87f9147ffa2a99964e8ad018d054385252a16095e5206bbedabe175180acb814b6afd8589202343862ba74e7154324d381e62df153bb0fb35106e33ab61679d79980801ff8901ae1191b9aa7b7535fac074ec5c07e129471de882e8747ee7e333f6d3673a64a246cdda54c981336280e24f7cfcbde4f1b3cf153e6d5696e4390160b3056cad5612f74b31e798e8a0bd166b0f6c886f5af98dca05be0a79ca2cd272f42ae4ebab5ffda37192d7ae1d224e984bcdac84bb4fa0a590ed623fea935c912b8b4bb310b18f1ee05af7bf7d05e843a5570bb7c71090c0c2845d37b7bcdd17b68bbbec5175841e8a2858522b646721c8775e58539fc5db96b9a26dc47beb4437398ba924da09e28a81f2e10503a7859a1767b71c834aca4838adff99bcdd2acd0a36ff14d8b572a9f546cd2958a58ae4040bce402b190a3473c4e6a243861ee0335831ebec7b685bba83f7ef9ac1e3419856be4c6993f4f7ff47e64899962ef9a824772f6a0422fc18b0f56f96dd4ffc1b30b7ca95df4677614bd3bec974de9a88ffcc9199dbcea58fb8ec21f02e9cd8a672f0895ee722dcbdec603e36f5f4d49fbbe94e6d9939e874df4b2cbbe6b70e4d12d1deb6ce1dbbeb5168ab18ee79cc01b49b825259517c053ad8cb7d635e3ae246c006f6cec6d40e6b118fdaeb6ebce5a4ddc4da0e90edd0bcd306b8d2b154009830ebfb932a22c2969ed10f7dafd4de692ed94504365c8de900152edd1a101c0ee9492b74e7ce62db4f7467102de73eb5c453bcbf4ca7d8e201992a12b44328bfba3de64d78d9a8ed064d1437d6b09da7429b3267357d4ac9816d7c0419100b7f30a92d83881a0a5be3d8399cb73a29d0be140850b215341615e54627ddd7f6e66f2b386a424d985d60fd9ce16b107ef3287066f88347f617287975dc10c0bc4b3b9a7f150f9d7148781e34b72f18b56a63e0d1cc7954dac12a8b0ca5b75165f190e2547a3ce231b719fd32cd85c671396e58408da6f7cfdfbc0bee92c5a9ebf985876c8de33c54d7c19f10f1a22cd6a35011638066d5a3ac5b29943eeaa6f79405961cb837fd97d3872cab447a1c7095481b400ca23ebec5cf07048b639d3380dbefdc175dc378e54d6635b5e49a556da08486e9fe0fa9328efd5b9c33357fa3ec303e58928542dcef920c84529e57aa3907d65a022f3a82e0ac2ad612c6e51208b43e1adebb63c128d6026f26d7fcb3f16f069b2ebfff80e179c981c3518cc9c9e319a4999a465d1e333f93aca4c13d276ba17256dad068682e3bcf2adfbf97472cc45256ede888615de67310eaa1b8d8be4bd87e11b2f069127338c1df6b44109471ce26159f37d5049155913c5dc10c6e1b9ae85128a67de2b1a1c730e576a05967c60fc98f5614b79c9db362bce5c3e8c0ffb89849cf2c9492e599fcf134e02b48f2787b98abb278b578afed148b77e912a9ede236827a02a69f631ad7f011cddd5d2f9b1ffaaa16bfcf6a6bdbde84b2b068c10bb8afe3e5ba924b8f1d259a99c7b8c6e2d275d3fd3a38c8b43c8cbc924f8c852ecea952ee62a82b373ed1ea12161246c5e798dc6879f20a77806eb820a1245c10c9048e1a938fbcc0a1d3f6ee0c2a56a00070a7963dc59c123689f5f8dcf7155d06c397d151d0125aa641779d263e09d0b501a6b6663ed35cc45d968f8bc4aa9001677f5e3083bd0960eafbfe908ad45cca8e0a055104bc3a94da6aba8eff655e023a382ef9f01a261b2ade22fc4ea4a7c94e35214b673a2282181377f7fc3d43fb2a377d2aa4e4ba25b77e51cbf5a6d8c9318950ff90e754cf525d5dcad67a7ba74cb0ff804189c5ca17d38d73bccb4838daaa443184f1c7668eead59097e3913d4bd17bfd8cb611bca5e14b0ad545746f4703dc16c38c198ce29f6bbf561502d8fa86d651faddaa78d41dcfc4d266ec7276581347606432b14c2aeaf3fca5a9edb32cfb5b354feee05b18b84110837f78924e5456d1f061464a71c73ce2441979701ea6e9dc80f65df74da02ca8a8fb59ff95096ea1bea81be179cc77406c4c58e4fe2cce73c2a575b79dd171d1136665aa50a40ec0008331f7f2acaeea8d0c1c62f790102d646ac77d978802c72d530e13f0be0bbe8afc90b15bf1da88c183e44ea92a8e453620eac6668ad7cbd9f10fc3cb4f9ab5a9e319af3c8d02075c1b95dadbd863d01e05937343e5702b376ae73fdbe538085652a0a16843fd79796985d1728dfb33217e486c0dc06a9122bf7479f5cc5162262808238ebd6659e42defec7b4ddb4c15abaae2e41faf94040438b4151f3ce13a56fdad7ff638a82937cfd56f956549c827c10980b58fbd9253d1fba9e43748a03bf92c27f3e6976909dc82e01cf9383dbfaf0515687277227f36dc5a634124e2085f65b9886a5d815b28641210dc7d674d76960f6f7b2a806925d5ab282a765e556613ac2b56b75edc2a9e0d730ac9e4e4586d365ab58b0af6b8fa3911e7d484485e95bb410cb52954c7f263a89a8ef3f8167e440f5f18a13887b7f4951edc9432dfefce4251cf55e01353dd456909e30c5920e9f14a606a2575fc9b3d56f7ac672c09371e0ca038dcf009de4f4ef64b3bb5412afc0168721e7ed79a4595d69e338787787ba0e5651da473e2a317e279f313f8c4581d1c91f5520013f89798a303b953a15748ac1d270de1a5363ccabbf2872998b5150505a19aeb66ccc743595506f3b12853a52928f50c8afe92f0e787309acd41857dd96917b7a78fd9cbb5078d326bf53bf8cff622599de6b62406213f17bfacb71c6b47e470309da6b68d819d2543b532464a383ecbc7c27f9b5be6fb21174c4a166a093cb409d2a0922756854cb6a5657553cc8b32f5ccb7d152cd54949c2e44902050500c2420244a987236d85ccbed499a6bf83c883dcbd463c29c77490467c12974f45ab4bedf5aa76187e69c992f16d546dcc12adc752416633223f2d174a8be9be0d130f2015c177798060c500f15afa1369512c401fea7116e5d60d5025006285740b15377d6b09e6650f099810dac23f6ca7886b6bd5aa206eb2cc5e6144ab0e97732fdcafb341b0e3d8f97bd1b2de4384897a339a4bbfcb650569a8efab43f78836c5ddb6d60e69c9310c8c608969d7919d83dbe1134b78bce7b383c5b56ae23fcabd7ddde0475e32c8bbb89532667043b27a100ab5b5b9867b1b1c9ec4f2290866aaf29e4144af64003241e47062332994c6213fcd2ef26e9da0733ab11ef3f7cf62c0b00b45ad929ee08ff2064b230d8132bdb492f4fbca4c1e951f02c6ce03f70f216c42d3202399840afee39e9eab9d6e130d8f0cc407f17c7c5a37032f189a253202d7d82e8afce6da595efc83d4788bd035a6d456bf746713bd80a5b4f5ae0f0fbd0f48480fc86fb37968b577041721137651d0bfb84695b21a6a0844215a7dc6789b29841419b9c8e54eb35fdf63b267feb5e9c4b655ca90535eba419ad65c8ec681836dba2fbf04db7ac9f04d787295b96001ac81bd99ddcedffc5d84766aef1aede8a1530ead9bbf7b9a4a2f8ff45340d414e275b5085e3624d150fc0b2fdcd9d22b102b6ea8065bca60dfc482a2f54fd7723f7724b2002f27b1a6f69f2a37620a7c73fc3aa6b8ee3b9a5eb9b8f7f3653a03208eaa64fd78f226167ab75089613d9adb0a431db4cd292192178e3fee4b69d9ac2f53d58f241117f1374eb0087f698df55a88e8691503199160b25acfaf45a084359d82fbe7f42633a7e7319e3252adaaf13726e06771bc0801d191cd5972baff97ca5d04deba77d4c886c1adada61668b4dc529ed1c5ba7aa3386ea8dd6713835f0fb3d749d63a2807c189afe997f6d7e097ac60f265e39bee50ac417dc0fc4ff9406a970fcc48f1ef8654ec78ef1bd4e7c0f26fd5b9206ec04e6a9eedbaa54cda75dd8a01944c3e34ef2a42fcbb45659f1d1ce3f8629e0c9cc89f741cb0f0ff560e4ad911faa985da33f20b005d8eb19f9df73d3e8f3b61f1afdfd75d735a54b483434735481d1a7c635eb6ccdaa40aa37704e108bab6df1580e92a7565db5f77c24651b1a3bb8e3127074cb8f42267ffa93be87686852202d7608b4cd09be5844003c3cecddf0d4fb5a2afa9a816fe5faefe6ebe5c17ba0d794cdad468309cbe3cf2047cc37ff7c926a9c1c026b716938cc8ec513baf35519539b3c034c4b944e8e3d1b2812f367c78db1c4c0798b428fb3a848a4411ce049e56de197b72f6a95038efd3ed137f69161600142eed208eb6c4cd7a802b692aba8ca44bff06b3d44d76a98a62e8b326f6c30e18c56fd5d6fa920c273da0e2282297d0de1a280f9c5346466bf512b58c6cf9fedb8c6611c9e0ff8ea1a739ff6bbc6604aab636e91a74aa65fad5d4649693e3f800e3fa83c2101d3ac9b0ae089c9030c1a68d6e75e6cefd7bced206e2a069f91cda212ea28d39767a7079b6432b486674c4836249c42ed70cb4a42f30ec90619c28eddfdbea19300fd22739aa380946d82544d0168a500d4b1e81e396abbf3bec5a066fec23750e6aa80962642b168ef9d2979a03d20953aca29873d7298281073171490be1883c32172eb73ec595640c51c5f93a46602d4bb2a58cc98a919d24ceb6a880dcb2ba759e40faa8225ab568cc38698fbd21336de8be64808b1bcc0cc1d5fef51ae16988c022cbb4cb1b99ff5b4ab174bd87479b6145d131aa900d9fee6ac01b86dfeafa604dc6e30d3caf4382e1880787ba91e646c75da019077560e53a535b49215ff39336e6e74b479f58ffc381ee747a10cbe3e20cc369fac53afe487e8de2e816ee01cc4ee8060dc7e816b544c2e774cf1e438c3580a4f5c8f63f5da95589f65208a90645933dfc368d630fc701cc7d082c2384f89b8295892a2a6a1a9c7a64a953193fd46cd90d068ddbec24f63c40982a630a61c97675b4708ba9be3eb29cea92643b751a0c576992ae18c817936b87481b4ca3fa9a378937fa09f136d80e04770e1a615c2146a6ec70ad78221b1b8f0a75c0a25e504b6f3a30bacd5fab99b5943f13b292cd657e263e2fc0811b24a4ce7babef7b3441b275380dafc9b3b9d966a0ecc4bbb2f2ff6c50f3635f0882f40357c1623d4f85e027b5b808a46b26b75425e74ea730c13194139e6d923188c52be38d6845305c3cfac7c707601c42561f896e97b467c2cfd112cd0594b11b16742d9e8e1685767a1eea276049a56efb306867ab902af193223d160ed5daefcf25b0679a12c1bb208395b473b24ecb3646ec161f65457ab641ebe516459254ed5a65615ca53e6f48ec303775daa31009a6ce81cff6048b898f30dcd707916223465df12fe8f6d94419d6b2af3df7adbdda2f956525fb6fa4193247088e0f1d43f2832c261ebaa97d0240afa14cba7baae7d96aaee338dade4f2427c019173d2fe1c2c48ab7cb8ac90ea9bd7270de1c71dbd667eab1c064769c784ba8885323f91ceffa484f8973fb72b8610dcb1d20fadc9f1cd775cea3e81e4d790a9365e49941bde5e135e269a616bb550a57de71401662a17f9a5cdc488010fc6c7a671d5ff97dde4c73812a8262e96509fa1645fab0ec39dbdd80c307ae41b91bf686c7efa170d61174a5898c28484f8f4c2558193f44b47c426af6439a236bdbc8c6a6284d1d85082395bc168c1995fe99cf9673fb241111153b87ba2a4745e5b84f3cd291f1e741f1ed61d2001a287876186de14502655bf53094ad23865d019a48319b539b7711ad6723cede4123ce9bb62cec10ba7dd22ca5d3a0efde395ee984808f59d42aab6cd19a047ef7f5f2028e52b0e36aff91d4ef4f423867858bc6a666664207083dbb95cb0af3eab9bffe428de42893e2aa33723dc1edd1c14a43239a47c8316794e393c9675dd8814f444ea81937ad0906bbfd56f7a90914b5b78c3b6111712c771f7630bc6185fb36ebaa045ce917811599c1d0fece1d5f225f6df6c4dc6daa3ba56143d440a8d8056766f13133bfc7aabb6a3861227409d041eb048b0a2d449dce131bf264e393fcfea53adef0957bf89506b922c08a34509817af0b7cc11bdb7728836e7c7fb5ad8234bb7e5c1219bfcff6bcfd61274a37e52b9987fb7948879a4665f37f511e0555b677bf89e99462e8a1889e2dc175872b0d4a66912eb4545f1ee689ea2b7522b065615db14fe4ce96a9224216a0a9f88d7d3bcfcb0d800f6d92ac95b46de0fe09cc3ffcf4bf23d1b1c9450755d197c4205c9674e888d506645c227e80e2bf16922ada19b7efba3f5d80f436ef84a74f9f4715a5142c3a5c0cb13202458b563d96470c21b1a1a8f7d41a859dfa301fafe944ca67c61c31e0b99545a33d46d049290e5fbe7b9fda7bec3747f8ea35878c1d3f9727422d6d752b1069b7c7a25a66b36c00293093e807c1a97bd6dae444db86bf4ffb84c9231804f1c9140a188af98317a38ae75bb2ab5e30a14933979789815c84546c2172fd7a57fac1e7ed001bc84fdfd47335f20adbade105e208cc39436c814ee57114e720f1d385d3aaeace894a65f2cc52bb6b45d06a050b69bd0d9e6a35e2f74b9aeb38005756178e15e2086b46f2d38cdf2f598e83e6331ac87193ec5a3eb55f2700b348b8d4083a4ed1c320948c19f4b76125bd135fed65b46b704090cfa9c65155e8cfb0c5d8b16e4f9a8ccefdc50deeab8f59885030911c2471eda0dea2a0b1d2ce11ba00a26085bc672aa053ac07c6d486f6396895b7c39a6717bdae8909c50ce4681d1da91c302a95344212f52bbd079df63d38ead805fb7fca5533e842fcd3e6c70e55187813675036676f4cf37cfeee4cdb1c689eec41a3f36fc44c0a863273abe5caed20c95604852e1231394419e20b9e05c43f813c38e5a3a4d01417395cad48fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
