<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e88e42d8de86b3b9e1233f8cf047ec19bbc0021a55dbe82a0e282c52d3052d548e6ac4c5a9328b19131e9a658f7465a2a582734a7fe17d059600d0e6b7be773c345349d9d6ffa95becdb24ff59c89b873ba4da1965113d4a1d945562baaa5a5740b19024e25ea83676d082f9b7c9e0689a4260943b3b91983b49674f891c45ff49aad676e8c68ce582677ba62b2dc2d165eaa1b18eb8698d81652a25f33c8c28a3d33602c3445050fdd3c95235849e175f052af2ef5db55c0fd5c705a84f43aff9467646327cbaf147fcdd29616a8a5ca610dfc3263f7fbb3bdd403befe71e93ceae82ec93486823d4c3134c4467ce1d09e16b0b47e868fd90e3fe610c260425bc03a9b8f183e1eb5807441cea4ef82084773a52d8dfbb44a72945937611b1a0e5bcc5922265b15a455eea89bc61719aa34cc84299cd886ffdf21b4f1fdedc2c31cc8ee50c850f4e856488d63eba0c17abca160e7af3303987150b4e295f8a9994c2c0c92a22d733db00e8ed18c9891bf4567b2849056eb6f82f1b2ae07b0dec222be0a2a3a9faed37e1cb0265356286570a5f79f43dd7d6b3fbe340c0ff0ac694de0c1852a565fa74dc21e7b1491fe8d76cb86f0d18790ecb567dc3de512dd38bef37f301f10e77435cf8a77fc56e6d87df47e62bacf9fcba5f1235482aec4b448f9455f36b12bbeaeddd32529976641bdd3c0955824c463c9e868e877dabe5079224aef4982b3cef3c2e83cb6329b9ace918d57744c1af0ee7f3ee76a2261c295defd80b2b342090b325c247fff4b9b12c992493c2139057bacab37ff9bade4822b2b32aaf9cec119309c24011bdc610d601bc6ee91580023da0399c7c4dac08857616e286c4f3a92ff24be52b8c917a39e20d2a0d276446b8d09cc62c755e0a3028c2f8c6b44ab42b7d1acbe9702f7720fbd3caaddad510df5183c5cd0f6f8ad6f7b675cae79758d6cd6a86f4795811360ee1e3d76c4946933a621a2802fc5ba276c1e49d89657f068811005b9fbb53b5d816b814f63f304e66c288ecc5da07555f48119a5686256471993e07095870bf9d1011d201a4be7e672ba8f0adedd6e1632755b0bc3fc6503bf5ea67de14a75cf75cfbf8406fa2822845e78f4dd167403f26736303250317068a49a802e61583748f812e8f01bc28c05388a2029b5fed0d49960085084d220e1caac52a524fe2886e146e59ac2b19c4bd60b54efaaebbffd8b5198a1196f1d8983096a0663927661fa4c096d96f6c049417b943c88a8142448e6847a180d8a07c75b6b85f759eecad255032186d2d4e8d88fffec1aa2cda1ec602efee25c15a377cd9d290e827b6ea38219e9c4b98236535f7855023ad6748336479b61f0b844ebb219a14a8a0adff74bd68392720a7638194e9b95990c9faefa52b22da672463a5cc54fc936a3d1eb90dbddb680b61c0f82f43470f4f69bc0911ab3994fd313cab0ccb7bd28205fd07f414ed50e9cb4e9e1c2aef6f7bdd3fbc16db4bd8d3ac9c359c7b349d22050daa5f28d6a0abe3089807e4dad968180c907170b0479565e6f5bd42416c4bfd1ace2156496d4db62ad5794094dd66af078213c79a2d775015cf4123cc424d6b6b97a7a5ade6ba71a93a95e1ca38a4745f91a95dfef83529c89386326596388e03cf553e72013467ac61aaf3e39b67d0b913c3ef44c93f62e5e5409df008c1339c4fc75fccc6b12ce84c499ee1197704cdb0a51db6c60d3c6f3e2da572d0c6f21063fc9923a3c354b7d92f9af6b029a98567a7afa906445f7dc73558e2b926463d904a860a9327688f856ead53ef9433d171f4d933338f654afb857646e6f8a8d0cf7d85719cd7b69780cb1939aca96afe8037b4d368feea5831a60fd32fb3f63ab2df637aee280629997e0a73a42a15532e3a6b3cc42d36329997a6a888dbe97463413d4837a57d4d012cd5e5ae142a29ea14de6877544cb873f9acbed5a813c2cc56c6854a17138da4063f61d60e3ca34abc362cba2f54c3ec79fd477e3898596df756dc3b5ffb15071b9cf3ff80b50c957a358b1a074e0ae86fb68c9ababe9767f9ae0bb6ccb9a5f9e359cf5d509d4a62ca8ac16020cc465f8276d9b63dd77622a947126a8246aea877b183a1c8eaec3d096dcade0d83bf15407208445f018914bd882ac7106d2704565dc84c47f1f2ae543fbe439a2c07a54730a5bd2984b655c252133db5e9bbc0fdb21017f42e0f9e5c153fcde7b41d63432f74a6a688a8cd27c9be11a5ceb5c879baac3b978fedd67c5cd99de6ea1cdae0cc78b9c427d82737ea0f3f9c8afb486ecdc48fabd0d2e3f7a1beed9b5cb450a6e7d38921d8808c0aa8e5587f0c6df6c0b9e27033655936c1b2d184aead12b8a91a3ce2cf5a2d03d70ac0c02756e65427f80f1e4915b8b918f632040f71926069992ae4842f3348052dce32de7c0fca3ed77f65a598577898442be22d244a38b323ec202c6a88c13c84a16a9a320f1bdfaeea6c8fdfa6155984029f3c7f2eda67384c69158879b0a0108711311e8f59f83aa770db8439f2bd35242daf2b6ff61d97571f8b138d795cbebe4192ce2c5c9a64cf0cb25d8e2426a45bfbc79c42bb6e93483e8d280fb7cf950c17ac6ecbcf19b94543bbb6d2988386764f87b74a82bfd8a32d0c9be524ef44de8c5b1cee76c619fcf816a3b4ec6984e889523aa2ecffc1a27fdd416ba3392d7d0e75ce3072b2392e22c7840fd991e462c7d9bc4c9cd581b575e4d98ba10158225ee3de75d05d4d89a596a98ffbf2187e2b674d1f0e5e7e72bdc33025f6a70f6de98fe19c54c9d5277bfe6bda1f054dd6da61871518ebff593594cc1514e6f96dc42fb04a28b826c6549f9ba88f650c3209f51ddde20c48921447a0a0b6965c1615eadb77baf342f603c7e7e4d382de04a77c7b157d1de9099d0daea9ec2d64e322230f12f45c61fe9b5c1e673d4ac425c0d7b63ca6a492615a86147317a4818862e3e1dffe2bdd80708344018dfc8c6492662ac9f6676d6097711dc158ef9cc88ec8001e444aa4ec4d1e67d18e1897c4810cf7bf94c011555d2a18178338fd877edc744c1c32f06054f120f5d2ec2e7a9d788ace5dc035ca989338dd25ac800344ceb160d1af04ca3d7db319f9e24d951a02645341fa77fc32d35fd589c8ceb92c9972bef0b820073e8d90d7c432ec43ab7efac59559e68a3306d74650e699f4ad22d3aa8f1f90cd9d06a50043ff8c76038d1f862f9309801691bd77a4f2aabc3ab5639c611af71c81b55f427324c836ddfeef44dd0be9a4a7f9fd3f086f756e221b125a53b120fdf5597e05928b02951dd3f4ff6ed741a7b1c5ed3392b7b6d3489bbc9baa3e28c11e323b6b07ffcfa449f38769c251cb31e14a648ba59a02cbbcd8f18d2ad4c1e6742a366b0a03c65ba96ffc277007d38429cb4f26608c1651774520f9ff63e2f0f9bee72d8cb054d195dad2e50fa652d4a9a920ba368993c52950ac2e56e23e23df1be37414d359756866941e2f080389b203101bfe48f850953479688365988c426eaa3082ecf981abf1cd2782e4cbace60d0c005e7a1a1fc4a3516f94dab75f3d342d38380f31292b4317b2437106692a6048e80f0f3b01a55f31d04eeb044d7ef04d7cb67e38faea0f50cbaf72f72b902fcb7025072a992239b333e94ae2f491c9cca514ea3497c4d39796988e4568b5bda56e79362b1f99ad4706dc09fea62733c7f5c5578a4dd93fe4e42d52af5a3ea2ca30650b77a239b8419401bdcaa54e12fc5755b26992a6dd830b0fd8b7186aeba448bbc1360e0b7eca10185e4050d544041a5a133d379ed15ffc4cf0ab0662e3b5cc1d8c4654c5a241855c74ba9b859cdef7c48f69d3d1c8eeae75a2cbbdbe06ae9500f1f5fc45b64f65e6fcc589db9935c5e3f4faa9ed8706cd57ad17513d5d74f006940b0da44481cace6813a7fd89107877c86af6270a8d898bc9c8f88b8f68b9303aacc81156de094f94b9eb283efaa98d6ba611d43b71c17bd3d911d9f037e707d3da2c51ca951a5b36d37badab45c74e570cf8c2dfae97c2406824d7c0bccd713ebe572637e2c160007a95199ad3a07fa32cab8a15923f27790dc8a4b4624545993655849674a86832367b5f70feebc15e2acd9c6ff7a313e27c94fc103022ca1db979f60391f7537350dc835509c537276da525efca7932e7a8d2d36c7d0b10ce362adde8b3729ae1e92662b2ee1aaf17e568a14ed4da2cc964e4fed778c6f844a7f9d8402a940f2979d5015fa91d934f9d83fe324762e9cb2f602681305d4cd023c468bb178c1af09b9a841179476f86b1703e173ba076ab2d0a1a7e13edf3b86074436f625e87f178485e96121ab775e95ec6af6adc48e09b54a17df31cf3cd07bfe8ef772f518d0fe90efefd316c12329161705479d27ce05ad8f22a7128bf3e4124ef64b6865e0030ed1205cf392ec2787f667ae1ce253f93a378d8c483e508387b756e335a18f5a3df86fa91cfe873460074c1d81757e3cc3c5cbf24e900f6140cb6ae121443f68e40437d6745b6537687b2109516ad24b011015dd67bd7f51d2e0325d83b72fbee00f6fc85f835863f493e6b56eef7d495efbbdd2df2693737235b2dc38d3b541b0d55c3c1f5c68aa2a20e1a2a17b70d1b09f774a1631c2818282775e1e1b34d376601ff2fb20691af309bd61f69a203f86fd2fec393777e554953482a9317b25e60a53611a1fa1620f770d9654a094726e72cf45ce24cdabbfb04ffd24d9a098dc028f7597d4e0e68d6aa7d79b0c39cce1ed6150cf8bb438fb9127cd7d88ecd853bf9b83f46769a0f6db5c8a403642432423bfe91d5f19780bc10d7c14e30485a7f46861f791c80c05b293767585069b4bd38f23df833c6dbc7d6bd8fc8de7f0cd48bd6a46cd2e45efa3ee9eef1403d025425473089a7a477f9d6bc1ee49cb9598b089e835229fbfec523187525bc6f98e35a06bfe174ea1c966c9f6b6c87d8f37411c93d77f1ceb9e6c2d32a292bece69cc67ef7708f28b00aa7c68cf619f8e862dcfe949a257b2f47227ed3fd70101e3f4a0b0dde2c17312f6bc4893544782f22fa4d46b73fbdeb56f590cbf7a44f690e506f045375d0ca0da21b07db8563345aa7b7b27bb2d997e477163dafaeadd5933be69a7b719b4c47bc7fd55f916b3c3318af8ac4b7b5307faabdbcc21c3b01483df1a099b1400847b8cfd1e5c087899eda4c86517780256ff34e03a58e016800c7ba8398a99ff638537a23a50bf12049f03e7c83664e462cd71a5e45e01f257975d8c8eecda14944cb52d30a8839976075243cc6757689468b5d4f3d30868f9a1aa456df6e00047faa10cf694c7140d528aaee3b8bad51affd26ea5805cf740e61a496fa2387ecc81ef69ff77f23625e2d470a6ab6f625395f1ed5dbcacb59e11712d3cfa883985df6fc28ecad9d4d17e20cf7595c3dc88144be043a8b86a9fa612ba387b15fa022f1b10bbc8ddadd3d28b9093254856dc312db9de1c449c30328528259ff4a42e7c2d611c392e8019d2449b88f29ae2579a97b4964df4f9154cae077085191cf397f490576f66cb354379a523681de9e62e780c33f76310107e179cdb32f54d78b2c6715eb7e8c8cb9b29ed81a37b59a0019f0eedd4cefa4fdde055031df081a3939e0aff908a1fef63442249cfd3dd8c86dde8d2fd86d72d1e7a3dad5e6a21221dc9c431fc3108969fbc7d93e879fea154bd6301d0c561d5c5b6f31a897d2fd61b5740ac474469026bb31538b58a40ca73965de70eeab3d0bfd5444a8b2724e706022e1ecf1c643e8428b3c182e158e4842330fa95af2e32cdaaa1a9ad323951769fa71e8058333f2e1fd4e0b2c59268b933e2989d4effc738794e1e5774f6a1a723b73d73c3632614dd3d26cbcc5dc7b8e87b0d70444db80aedd93b9b66c0a4af5a0f0d0b357cbb8af2b685b37814d57a53c1371c427e72539d3124df6ef50dc12a7db6b914652e4041a15d827a903ccd239ff804769fc30cac32210bf20fefcb0a005dcfd304d8a9617f7feae37c9e70bc8baf980b28ab82a4162b63f777f5037c208df2012e5236c405ff32777fd4d0170e02194b52417c1e5c07273dacee687efaba790106d300d05100e6bea9d9a68a8fc60b03a1c6cc79afa6b61c56bee826c4a9ea02af98aebc2dc7706ef888b81aa1f56ed9c842115b6b154a8daf57a027c3815af17e4992f5bdc6ac381239259ddff3f89095fc16fee61536c4cf71293a1581f3c6d6b1320f8eb4083c95b1ece9a47bf3ff8cf7164db8aaf1103b2c1158253279f16be539ef341592b3c2c43b3b19ef8ae48b5e59b9627b99bcb9be8dd939ee212d126f7aea034d45ca64208b88dcdbfd17c2d5d0cea8a4ed16cb293972193d3c14961822f49608aad16894ea515b77003f04f4f1409529215df2f20a164c4003e1744b5a8c22c44075d9f383097488e9ba1f8b00b939009a15bf441ebb2842deb62c6239b931914f20ca821590da15abada711c96569cbdef729bf49799a0276e0b0a549a509658ca49a0eb543faa1344ff1c8014f745a7bba88b501d4aacc85c055cb04828991b72795367bad206413622c274afecbf16a42f8fbc83a9f8e89edb076f991c4abe52b50406e6ff9c013fcbe9031ec042d8af6ea606592776d7e844c9e6db57334e333a660505b7e51487e6be9219cca3f5ac376dae34343c96be69d0a76bf401453a5695150a498c95b6c1437a697353f838f986d8db364f2f946d80365551b2d55f0a9fd513825a1ce8b38323aba73590ab249195e5c8d334a8fc3f0467b77159233ab3522394d786e0dbdaa29f32ff72cad9207aa21b8a40af5de8f8ebc62de2cbdffe29bfc2fbb4223c3765ed76d1283c9523b66b6d566ce7dba2998352c0b716a67fb20b84375bad023f2cd291dd84b59bc89ba10eb2967e006d492c3f8e617189c4041dd6c67f92b51cdb767c00466c1b029a974b95f6edd91ff50ca03e1bf20b8b3a52ebe18cc1c5f8e67c63da23a5859872a4ac8e9404fbbc831d790a6ccd0ad6e2dcdb63603464a5af4706098dc59f95845a4281d3142eb01329153eba0adafb5f0d68dca4868d3ad23743bfe480c63708682b03ff2628b84b1c95b891c6cb733e660c5bccf412b89f405d741fa873e6f2dd98c410dc71ba75763f25c60c040c62f714904bf94a1ceb8ad22afa2b0229eaef27f3d37475db590a880053098d14058b338d7733d0e9fdbc675f03fd64f70527124e5ed89078bc63cc87df24feddae4a33d429fc3c59efd5f8fe9b6609d78c528a7e76bc0fe438cd9499b8f6b88dad5f632f592424161600bbe7d142192063f31b671e473e6b5ecddac3031420e37b2edf32d08d5f6b9785b8a943df98560e3ca185ba8a82d3e61e75bee4141e73223af1dd7752aa0c08081b232138e38c05cb37541946f71ad61c6cb322d5ddc6b0aae326e07e1ecb49548c2b4fd15ddf439879f20c27facfbb81306e885bd73d79d23e57d568bb305f45fb9af68f1c33a41b05714703af525b33bc1da688ac7ac8b5b9795c24d7f56a3df387dda99506cf7e7b7b6840cf0c378ee50da5724dd94b5cf2e670639eb97ccb5767c1c9d5fd89933b27c1ade13d96a9140678a3b6d3f76051204781dd1291821a53f01e6c9acec56d8c3d4024c4a612d375481bb6b187e8584ec0abddfb79935fb35ccb2bc93eeca236654f2fb9ca933ae7c76b8c80b2203dafe0e657a100e79f9a615ee1e46378d29238154fb38e86751f3e025aed892bcf788d867acb6bd7b077e791fb1bb42f2e434269bb08ecd5c7e1afe0f62a791d1810bd8d2a832bfaa6f0d40984bef711ed466a4d91da71697ef8dee47abc40b4da20f75608f16ae520f9d48188b613005425d26739f129d14a7c52a923a93adb30a58ea576303fde5e98c81b8732034e03ef1ff4fac9518410c11ae6ebec2251e33141428858f8970f77542912357d777ea00d1d4c37379eb99b6abb4e3efd72e57b82b38e6edb8e05a58f313f92da283a834689b09af5829f508f31884ae357f0be2e5de962eb5eef8991c6d3e83d6ddf81a4518ecaf03d302699c9b35371679296297dbef6463dbab17aef99fb725ee7ae08d1ec3a6e5ebe570e4060d89788803f47921d386047590481eeef1f49ee74b4cdda271b82c15ee3c213f18761fd46030a0d949949fbce6bf7df1e2a03309018eb451a44894e32c0a5c542fc4c58d6d7bc2ae0867f8a113db5f11b5c038610bb9425842f8505f63cac9c96a8d4f0102817500534c557625ab2bc94ef06a143d03961d98326582128223f9e21414be45971c64e3e6005111bf10580edd8464a4783bba0800a51376b32ed3a0acc3892e1bcd5a3a3da89a5db6442c99c59d6c3a52b63e915181214b4ca9f98f15bf5158044e6b83329c1a97676500a0f70aea8a3d7e9508faaac7633fc4e3fca82173d7476471eee974fc8a3a389fe94ce85ba7cc425ec0f442928aff4225668d3584d7560a6a4dc2223aef58257fecc51341f902f9f7d27e432553be27b4346ee7099452101f2e05587d6a27022318e9b9b8186dc545947c866e4a97f5f9cd97363ee59f827bb4364982f87ca84137d8916ac6cc911f3e4232cb3b5ef38e1a090805fa30a382d65d88f0fa3cf730beab3f65e4177913702ac044a0d3b347b55ca616f21724f1706ce4cb4fb695432a3c2b8b3f5f988bae1d7e66f459113390a3095d22a953949af47d0796148af74ec19cf42ced6083784fcfe455c62540e101d11b01cf44f34fd346533753d3b8153f0acbf7dc5a178e81f3ba402dc95cf2ae0a3c49df9e0e2223cfca822f6db03307bd6eb834887d9f9495724f76fc9042cb04688fb58dc2a1c30975b9be2669c49badffc21529bcb1938c576928da48bc507fcf2cb77e0360afbdad998b778b212e92b497fda1cafa0ec3176c91759c3a29263df95526b9baac2545d856f22b3d4dd15c28d504fb175756712585422f645af31878d9557d49f4c7fdb5cf1418046c571415724b1f473f29c64a747d5ec60f0568ca19381f52f4b8d6dc22029e7d31100962bbefd57027671df7e1df380511dab91e400f63114a88dbdf9758b35d7aeac1de0b66284b65d8584b51874046ff078011b09618d2c5429fe0e526dd6617fc6aae0d87350f53262d9a426edfd26de505030c07dae99fc0e209bf04e9193f88aa380273688994f263e40b3905686ebd53e24917439fb7f050ccfa4508b21424e63f1d659ed0f2589310bc69ffaa95a87b4170f286e2fa1b80b71953e30616f2a677011e5974c99d02526f6414fd7a4741425074ba620283d09c3a56c805ec81d12b543feb7050aae6b5e4feb51ba8b35ec01da207b978885f1cb6473a575cc0f4f275b117953ab733c2198389f799fae30e9ebb21f5d4c5aeaff44098ee88e10580784e770757c41cc5c107d5e9ac21b3700ee4bd93393e6122878b7b600f90858d3c1a5ef75848fa04e1dd99f0c6ce4dde360c9ccdf22fc167d6fae6c1834da86294ef4d1f1352f2c313392154fc03af281265dbe820416321ac9c3f31d311abc9a131cb8c5a79ab691c2ff9862c6f261de4feb86e97f1416efa0412fad3de36776e6ac84d78f94295b850ba31f1b9d35eb73a75e34f33a28a65c16acf7288ea7b8360108999ed78bf50dbbb4be5aea3b1179cf1c0d619faea64acf53a71f385a0a1eea3a264666bdbd96cacff093eed1f3bbc18d7a63700d9635b3f6df1e9d443d3ce84c1d988f8b8e4b8d2ef2680e41709d971870e7fa366d6a9d80bfbca1cf7002a9c21b88e3a26178d4de468fb6c54fea1261afd9d53b3a6fb45a3cb84300445bf419e909a31c3456a1366ebd44fbb0716da17321378e95f82ff7542154220d89cb48f8233bee1d61342e1778e05d57457ce4ffffaefec170c58bf24cd91bba43a4f1a1b3216da31d1d125848b61f6e7b70676f3d1f51c1a05bf2748bad053c60db88daecc107f3f1e3884a8287075cd5ab0a73f00500620b63ecca369635b7c53687da402e6aaf33b75b9a1b0c9cbee886bb5ad1dcd02e331b951cfce4c22081ff8453203d8f37a703f36cecc80d3d9cfcf1c08e29ded797fd5e5ca8cf4c490016cfd96fd059e211902234427e6a4f820a0592384c01c877e172ae3f86fde3b0c77dfd8e3d41e8891d59ec2e707e1ade50891e4cef50a7c9bdc68d86d9a40cb51d5095bbb52668fbb1c890b19a44764934ff6f49c95eac3dbaa832cc28038b4aeb3ee335b4a693d4c1727d90d6173e44a0a94b432ed64d96b4529cc5bab1da13851c41fed447eee370e7c99846ed898d1036b126be80537706609770d34e4561f37e1fa65ddeef86966c92abf017d9416eef215cd1721e766b05b8790a6edf5c84c0ffb2169558309b3e097c20d8f621948d718086344c6d707c35371b8dbb63b8262d48c524902301ef11e82d2497c82d6cb91d2ed43a9d76354d351c8599f4dd516b796a1b88746b2564a5a23d1ee8726d4ca195858817f512aa17f0787130491b0171a290dbfe0fcba173b0138486add6c070723088953a70a62e7ce9cee195846d76f2010b1df3423020b23a20e87c2e24e7a73eda4e4d8c10c265f2c3dab2c090a6c94b68a00845cd800255e15f852e5afec128e023832168addf2896d7f51ec46473792fb4484b268631123cf6d60ae29231dad9a7452103ce5dc9cce35527ba85f942d178a26cf74e571b68070868f5295bcf7599c11011e313154395d2e49a26052bb54a80cd5408f3ab904c04ce346af8a04117eb2ceba40d494c387aff79c7ec00a3a028302cc5cb1c851ec926401fcb9186fb064a159c209e608547fc526e68fdd30126c5ab33eab69c990985cd2c86176afa4d3ea39a004c622958d178825e27aba38b32dfd52fcb8799986edd7432f9b8a5cbec8f2b4dd4afd3d05e8d2b06eead88961e70e29086ed128dae83cef6d0506a4b9629b5321db5c725c1ce06b043b5d02a47e70148514ca22915013fc4bb4e16d3dc90ef2a6052c21d213fb4fa9aff78fea2d8e97cbae64f994b01f05ac8557f675d809db1cf9126d31161ce898e4e213155676aefdc05e1ee303aca240f755ba69443103dc53755a6cc9d95478ce904b0d1e398013e2e026e7756d074960f5b376cae6b08df2ef89e2d90ce79c59c4155adc1c7e89cbc00db66b30c48137d27db2f9e22868891139e589bdbb70bd7f57647df24958f122500a6a82b379be9d13045ca7847eb7ce15913252b276dfda897a252f1a6a47c6d3a3e78db8e3fa1f4796cbc7f721dad44da14724c1ac868ccfe61623c3f99ae2935f6e6d31dd38b23ee453168f6c220341a8e18d79892b21f185f84eb0e4462bc65257bf62bb5e67571ba42684b2086c326dea92c229ca746b1ff3ae072cb49ad2908a6a8c218d271adc4e9bc1ed48d36dda624984ea60b60337fe2a41207be97a8850c740fc6b112a575d1eda85b37cc70f906519abe46d5d2a2fdf81ae53c575968a69ee68ebc10c1b63d160722df5241650ac1896ac3c91f4bed725a7d07f589865e752faf24158c26f6c00a77871c73ace7d071543ea5c998b5271dcf3e179e23bf6479cbd623f5ba4fcfa5ae15167e1a806e1a6644e24d757a9548b84dc4253f0bd97ea7327ec929b38a700274b4f515c47a918dbf4a3e245746dc3c2736e587edec07f9ecc8e638291bcddd7478943750a86f5385d96c4dbf22640e3713a72ae4ba0f8f7e18db3b211492d55897114f78aa7a75fe28c4009bf36c2bbcad5e507567d5f2de5ea4dd1707a89413dcc7084fa65e2e4fed0852cd7be3849803557ecb3a4ca644f759dfb7e1c8c49c5ec94c44fc16692c0e25cb597a60eb942d658a7e51446b1b9c354d52444638e1d34fa4a4280f7920132b9904fba412379d9f65394ec37a70d457122472473011889df7084328055a134cba9c5e427432d1b507ebe0fa561027b1dc4eae052e5c2dcef8ac69429bc46af0264e8a4636157883efe8679d7156b923573813893fc13dcd75d06ff36ac6a60adacfe8cc255fe594d449490feed948cd22eb7513b355baff69cf371660c5c19b3e100966a48ba5b57166db6ffbf8265dd7d012f0b01a53a8ced76136215197d8fa29390b20ee2342e70f580d1d6ac2fa9ba97155779800c9b3702ab8e0fd169631b35108b15876765f696ce34727d7fb293544e8e5d7853c957b386c5ba194cc285f62dc94beb4e45411fdeb313f747e39207a22e0c793ee93250949006efb09e7e68c34ddf41345f4fd89e453fa8c097b21d9ef660b33b303e7dc30365ecc7310fa9384746edefc77b57e73ecd4e48124b834242a740ab013ae3d40f9f86efa603268473eb4d5765ff0a2b7b6c5e4fd1b4c390d1b01c1260c6ccf52acae3a49a5cf3e3956ce6a42b180541f3b706158aade4c658d423b9c410ac3e23174e7d617ad3034720538992c1be5edaf63fde68bc65dce44db5694d2d43419b49cde6e0625f22a35f9368e51d8d3878578143b03cbde1135058e1ea7a0d1ca0ca012febf500f491b999bf42f3311e9de7ee952276b6c7b738c2eadf05283cdc75412ad11b32685e37af994c7de9f5d7cb88adce6f7017c03905216b1fad1d19f72b1de94a6ede269427b931ad689d390ac7bf17e21bfe5f38312c6f72d9fb01638dd5f95529ce5be9582d845636fd318093da01e5c1bd199b660e91d3ff214424a9124340de77ff12b645c189dd8dc02ce4d59800f7e483402155e09376b451d8c6621bb96da6c554ecff5ebf71fbfebeb60520f9470dd3880f1f9f9e229e40b6a34dcd5e6dbc02a63e5b4449d4b36c108326140614c75e8985e10230a2ff7fa6689b0558a2838db94802924d98a6dabd4c058a2c5810e44ed5ec10d1176aad240aca83eb75f0711ed57824c38f02e20e41f065d9aa3851e20a97d4e0991e0d22f09881971397ded2c6fd08729bf73ba41060c422d3c147ebfdc682e18c92b29ba6ddffc5537ed1e037b2e9bcaba4c8971e3fd473b4f0a5680293da3f489ed7389322f22272d1eb697428f8e7810dc6c7ec18b50383b926595856dab54e8aacbb9738a91afde3f15bc093e6d3052477b8d5d755b64c790af95c729e5c9d6cdd4ee330429a25c31c4f8cd6249c8fc112d72a61baa8e39d82707bc8242c5cc6a05b7ae3c81842676c8ff5b11f45a4502b14f92081ce2e22d897026b69895af1551e7206defa49ee815780885332fa33a458c53a14a816db5a3b505518e372ac3406443f2f4965816f2fc54e380221ec847731e07df84af8e7f9e8f505a7bd2f672e1c08bf769899497ded17ce73eff0389dc9aed1ca2cc5a63fc0a210029720518085f5c8b46cec2dc64e100ef207012dfc53b238350b0499ceac17220859cfb76035b211aad6699d072ad39e77d844a06a653e5a2eff7340d66865c61ee3fe488a93fb738bf4f87d09b6aec3f3477b021db60e34f218a73dd7d2f7a1f368480f3f4145fd73196d7ac55121c5cb70f691bda7de8bb7429e7217039c0d18d57c0dec60a4bd60c42c9f036f35771f334778af8d0890d488ad4747db41550b7b86a6bccd5133af9b9ab77d4e37c06d741e123a0337bf5952a6d06a6e8e4eb0ae3d1199617c7ba903b64d6ceca1d05177359e0486b96b4598998c98cab23b0189f42e7f7ab76bffc0c4c684e9c746c3c79b71f1184ac6b3701e7b7aa51561c4b52201e8b1a2c2e7d2d3f18a56744f870cc9bb62367bfb12cfdb45d2ae3f067ae9c7b28d29d3caa4b04743ddde498ae0d85778e917aff50972337217b681e50d82893f6ed3eb7219dbbbe93959f0cd5bd3f17e730791e0c1c7ffcf681ef91b8a9a0572459745566a5d9530145eb8b12f990385cf8470dd1a057f41a6c01d92309dcd94c380e707150aeff93146428a3bee173f67bd30cf1110382df6129fd3f6166df572128cebe0cba5dd21184a35616770d5e2ea92ee0e74cd1e6e23987fe4518441da1a77fb500fa5cc726d76c404bed6a3c03199e5207de2e412c4fe8b8d3e2e314095bfea4459ce770c83578c257ecb632ed6feb3136ca9a1180f131b8072aaece768db58402c060a12459e4de45fad5e04f8c236e751e8cf98780644e981c954fd9d831225dec57014a3bb13f49789a6cfdcec7a024042abd5ba50232f16f66c7e93ce6c968e103cbea2797a72edf634c06ee60fb3c8bd52e25ca799cd9192ea21fc2918df26161f84c6d6390c3687a9ecf1509d1d10597b5a9c351b672600d01417404051395c6bd9975274d3d58190e58b29bce7ec07ce9e44b412e05cf48283a2ebfced5d56e84aab745a5a0344ffa0ac7139423772ca816a147a09ca039ccaf19ef17c4d09caffb54ed977d007778672369b36fcf8ff67a67156105611b71bf09dc3217b3f3a864b5657d545c4d6edb48b8a5de7e98e5460d62a1c5018f34a4d557bdc36920eb2614f077a09581d79dddd15681d79969e561c60cac5f1f6f45293658970828a8a0b5f71ffc249b5986a17afa35fd7d8026c7fa8ba2c622a013d8eb91d3e2f7f04ee6562d105284ddb531c19f0af6cfd31625c977fef610f39fa57883cb2ef836340973dbb2ca5b2ed212d75b5af320420e1555250be1dcff594e50332decd75b0d76baa4753e1dd7531a899c1b7efed4b7a205dd8f5fc900725d28c812aba4c86d3305d35dffc574daa0f2e7afc60183834b4a5e6a2b5178fd6d14d4f71a303adda056c7b277808d1fcfadd60cd64487fe9f1218d686475fc4be144881f3009d2cc57ec11a611423bd24cef785a8c360a3f8bce890a2d2d84809eeb30e61ba7f51bbbb4d9af9d494aa1731d425d6b18226101f9b35e00d69916ff64a00cb742f12e5cf5e0acafb681df933aec61fadc46b3e02da0de6614545d05266ef52d7c58651927f99b3e048694226b03437bea6fb610d5757f179702f6778115636c94c83af3e0f8183cf8f5946bfc44971b401c47e237da2fbd12ca210235e3f445b256f11c8c35128ddb4ea6f5cd60b69b582de6798536fc0a595dc9bbf081bb5c2516cb6ed72108a1fd007cc159a809d67354690b735e33efa4162366d1354a2a2bcf9991786ade13f9ccead5eea4315b80b1bde7b49fb920a93778ee3a07fd833f5bf22a8d6efd794a4b9436130785e95fa2bab2146fed2fa06232d3a19c3325d6049305d9e04a188a3b2975fdcc316cf07f091ca000f4e10d804ca019ef49171645b028651dd3587219652cbc668be520582af9424fc0c6e349ec04c88a93e3796bfa63a921e2652d2b83019bbaaf6de7c4dc67401232acb36bbfa51012cd03164a1486e6dfdbf8236cf84a1996d4d0814de211589ca72c4a148897879faf4974744a5f6d378ba0dcdfd3dbe5141874455d9eda63bfd65faf684bbb3da952b7716c20b04d941056de87c99bcf8163068464d19b4f1d09835302dc9269d0f9a4c0ae30d30b3828af60fca48adfb0942eda9c9f1a03165c85781e3f06edd7e9e82135ad93fb01aac94f9087c7f59ec432e00a0b47e2f7bc960cbd9307f4d51b1afc3409aa3d1d0ce6d5f32d816715c5f4c4a93c696e70def5110c684f919b762c8df38c35c2419f0f2bfb2edaa1e6d30e0969e6550a01e4358849da4e97feefdd4ec991e6b1bd0f4d25059c8f20f4646c12e062a601f9154aecb998f53ad3769b72b41475c75a633ee0415d8bb1e2f138998f4e5ac10d4483d25366269c6d2e1ead52e6f8135178c4e4a941133092e98fce6305954282905db34371a73ae52ca4011f34f5558a87c3042c3da04af28269ea1ef272b924d5692a6b68e7009d216e6dc308d4231598ea61370ac5f18b238579cc48972fa1972413ed12b5464ccbaf37ea9a61219d4b8174c5a61d18355468fd2bf23d19a7fc39e38033f53fc31a3cd8f1faf871e71fd3cbdcc38572805e1e56602dd3d96cdb7f3b2fd15547d88ca7ce022009b1328cb339cef9219707896357b4089b8f6bb99ebf304933956c416df093c4c30ce5dca63e71e058c80e4cbaa47a3af94c1fd05b960ae57a73711edd8b199dc476e458d55420ce9b36341c917e08ccee646c5ab19dca90b52a4686bcb6801865a23c9e4b8e07eefb7b5bd12893e3c3dda9cd713c11a8d9d467ce9437547de8b0740168bead7de56fb8cfa83d4e3106e8fe54d3fa130549a5c6547416316311a4bcfb166613a54ce24337cb04b1a521db4b2a661a4855c53a07d5aa153e6725eec43435df48605a2669136c4a4d1329600d5b93faa6861ad00eb50dd61cb74b6f1bb7661878a7c55b5cff49a23c9d0a6e0db7d0e3ff9971bf3cba85106e6da60e09f1409197c6b6dc030f2dd1a9ceff2a5dcf20b699442d33fc2e9698cc12b4c72d64c74f32f5ec6dfea44d23f0e9200a06d38b476de5bd75399036bfb7267041036f5d92a77f0d47aa91c55d4edfecce92d88a9ab51dbb94553d5c812d8a30622c379704a77fa7168030be8e61e107c0f8efe2c2b8d05142ac95762f31f87704cb1c6ac30efa9cf13e66a7fdca4a0a66a7adda944ed9b59da4801f9aef9866274eebd0231c1a79d0619fc76a826a7021aaa0d25b0f4c3f5a86334213811936481e297dd818b309fced5ce5835ca72f04ed66a2e1e710c7b8153f9803048cad81d2d2d0b65b2061fd9f4c3702310bee9dd186d6ea6f29666c3529dda23ebb1c7fc79c03bcffcc3e1c65d07731934c6effa77f02fc671169f1da351a674d5609beb436f0dffd0eed62c1662c8f627695fdb44ccfc8ee5b562cfb14b6d7677e56e713d3b0c5fd6014036b5450d7cc502e4b1974537a987b8c9ac63f0dfd450bd716f00b6b0cab1030a33926162e1d69430b1763f055ac4d942d00ec96bf1d105eb59fc60c549909637f4dae3bb03a4faadf2851b6f3ae5e0bd946b66727b4253476406f7105042bc0463c1de1d56a7a98581d8602fdb62e6af7cfb44613a38d99e28f093e4a5e70526c9b1b106eb3fc0b3ceb7c251f078ac8422a0dc52e77d3d1d1d5aa3a1e1894c0fd360e6838b5826cc347f53bf7fc243fcb39d7fde77f7f19a4661bf833e4b3b256211c213d6b0b899ca801fc6d955dbc8b4fc39b89430ead62d805f6e19aec96d801f33a35611012402c3cdef9f027ff7cabcd7d62ef4fefe179e82ee80ac04545eecfe8284e0cf5a04c7fd70dfa2f6d36a3502012c0ca1009253e5711f18f117e6cc6b787120818e8078e8e774d71b60d78853b4959dc0fd05440ec2b313e778e875166d1ef4dda6de1502330f0ba1fc10639c101b1691f9bbdc7f264623ec2faee06a670f76192bb0b923e282813472152834dc3b0e3a45e2185bdd627c107c5484f9004fe845ce37f734fce9510defaf4fa45ab4cc8e5ee2c0343520db4de0e8ba1433656fdafb8ce4800fdc3cd8971db80466be9f4a095da020c4ee5cf0d9b5dbab0912639697368cd4e5e7e3e02a4db11d845c1c103ca9d91d2ae24b1620818c4ab81f8a06f553040bf5142b5348116cba49c293276288499f26bf92fab854b9df90216b9db6460da914e9ae86ce5549b447052984c90ef379dd977d1c082db93ab7745f0060917b08dd67b57799bc46345f5d6add82dacd2442ed5a7cf249d5e7f64f30c91e0b0b95878ef5432ca951a0acf11d840ce7f01417e0d32ea6d322a74f343f7d18ee2be744846e8847e55cd6cb219c71fbc6e347d77c1a0f131ed2aed06cafb2b64efa4bd68cd76d90d22cb59085600dff04c09219803b9c40c9127010c75027cb8814d19d41234edb303832c9cfa48cc15d6778e2e44364c8eec0d454a9a8ce415986dbb1ef1c83d3441dd37e87b6316b883ac584a7a1263979c246c7493cedc1e90d54b63c35859b19477c989abf0a7ff7c435223976e7518491a29f3ab62562e4d1114dacbbc58bcf6a36acd7ab72523821052b1b7f61c2b6f45724f7a0215b7846fcf3f869f6304b350939dedaf0c5a4b2710a84aa455b9c35ee0d5f3b6987db49a74d8fef46c8228e4e15e7ca0cc8197d3d87816bb92265125bea5067af2530ee7a0f86527bab49fb9ca9a9191b0e49c701bd7c19b9df20351a0f329bd59491a43b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
