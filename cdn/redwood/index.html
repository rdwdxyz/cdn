<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c414e118f15f33fa798de8a88cc4b61732663062baac6fb467b0add7fc4ec731796e6e11fb8942e139f10a9418cc6e4a8413081e03d8b77cea3d6e0db81fa7ea0c5b911c7cce1e492d6075d7d8c1a582b5ec4e27c25ddae22959a641acb3ce7e7a2919bc89f2d2b7da3a2c60e21239cfdb9c4137cbec9d7b2ed003f59b20babd74e1fb9e6acef0c7a083f7d3eadab0c0fcea8974cb8a73767ec4b59859aa4cf62774609581174da817826fee01054a68e0085406642fe1e621f599c3b07c753d0bf7d2c19f4ebbd2675671b7fec05ff4f3f603122b9aece28cfba0ab99a291e0345041761b99c4193e45457021d9e3919cde995cb457a181d30c468f01f8a60a482f83c6923ff0445ea5c3917031c048a2081a7ba9fec4aad6f2fd2ee079db2214fef28529925d5925cede1bd6b4da63c82b3128f2f07e6c07cfabfed53f17426bd84d7ac78ecd73ba29d0c0f1dbdd481df5d14c8ea7419def3255b5c4419bded2cb59cf7c0d91c802f9629c2d260bd178a68978ebd193d1235f77d81341271e32d63d04184669e8510789b05cfc58f5113b3c742a1390c09b0b1fb8d6df65c31427db5184df1a35d282aa14f543b59fb47dc05e75ded7a8926cca3b739f1f38e8057b97fe6afe8a25fde795b99c608e723392b21e72b5fef85fcb3e52e699a1cd72a5e2ab2345fe310a58a61d87f41c1bb652e6841738e59d08f575d4a41e6f05c1304ef648df4820abab6ed4106e2f3f7d19d74751b7edb355cfca74152dca56098a85a27bcbe1c430eeaac458dd50f08f48f6681ccc7c6d1ddd3c476b371df3b243051c3412a9f53178a530a662c7e5dde482ca7a875a4d21888da789e72ba2af1dafdf761b46cf3e195882ef2cb1c96eae493dff539b721a6b9d84f7e4b03a2a54ecb5edcc6badb93776e1034a92bf2c7e0336a46a7ff811a23dd34c2c6c150ca5bf82b620c132f13f79c8f26fc6f117d23bc67309a4452fb27c4f45b389dc257bc0eaae9e0429fc0892a74d4eda9de29315f921a294ffaa39d7218aac688764493788007935c32de8c07f5b5e878d28d836ebc13ff9385996c0495ecbfd95bdd48615e0ba375976367fb370fa6f62d897a09a25164486eb9cb6a8388d9608982a9986d96f2a51760f817bfaccf7f8b52491cc0dc64b364e2868ee4f0e168503bf517119d5dde8732caed4c50a06958fa739af2e925397c09c22012794cd9552cccb9155893281e498bbbb81b42d1afa2602052afaec6bb6a7f0e44d28beb11677e8d133a44e8ff58c89051d77c1ac164c5b0d809b0eb7425c942d825631f33f5689a33feef85770110ed78935c05f50aa7291a402408d051c1500f29677e50402a561272dacfb0c039ebaf70e76c8f8d93f05baa4edd7c3d92de837a963bf7dbb63c7fdc54d3a0bf1dab3ee3b525cb74a53a2cb4ed4aa02bbb376d0ebe90b7574293362498144523cb17a537c5d92cc47cc53d15004d14c81e1fb3ccc2429c4d02504f3f309fdcccc19d6f178e2b1c971ff8b9add4bda015c237f0fc7a0d62c873cca3a12560d1cca8e73bb2614e1fce368e4ed2ce504a76be5e661345daff2eaa1e682ebed9c05a5f999837d9efb0cab76c9370be500d36b7fea7c15580a48fb27b2e488a6dcf689b591444097c0122343b5f10c962e72caae1e9a4c7345f70ebbb5af549a65808b6d50f8a2675daab2d45514de5e0883b73a0e31ff58886288eaf4ac1c1a0a631ba8ee49c772be6b093e83da7b148b8273fa1f8b8d417206c7599d6bdf8309e08ac3a939c731420b6cf524d18e50608b0f2b8efcbb88f7ab805f657a539451df3db1d30f9ce7ecf6d4eb8d47d0be44948ab3d88ef43c26b2dc58ab0dbb74ca9508b26c2f358bd6cf965a3f84e72dd0c1a00ade5808669bef818d40468902750d0ecd77b330c25c0a0eee602e8c9c0a7e0a4579a5f252503b0951653f4de8e29787274611cdee92ebdb249975eb7ead8854bfb13972588206c0859e02e5a45b7e2a07bc690a40cc35bba1e9937dbfa7135e25bc34bd455eb5a9a500e43cd623ce4c9f52216914910bfc7c36b3c1de8c930fefc25a63b10971b886f685c6d35b8802d157e2a3385a884e40727cb9f80802f499cffb1770d98d779ffa433c0f1f4ad860067d6f90b6c76b6c6a23f7c9b99e4bfd062b9930233ae3fdfa1fcbeff07f7c6ef6085c1b3aa8da9c32e2d906e24a8a277733bdd8d4e6860c722aa839569d15adb81bd1925cdfd0caf4bb884e3c20e11b021258ce3754fe89af251a55b074afee9943216849034e777a938b22eeed62927dd8753226e4a6240902e6393d92ac37d99f00d28feec032eb3cbd4f8ec53b956821c30859633d807c30892e74fe3f2ce3b0ff67f09937fb4b3ea86da68e2a3c23bdc6e96470be74c0e679b41a566e6b5307aa388798ee7908ba251acd8e5409d7a281cc2ac15157df42db5d040519878087d272e8bdf20bf87f96ad7f040f58de2f7834ce546cca8f0f8b2977e51763a190530a3e5f0c13bad0f5a19ab9da23555a7dced59807f42cf8e14baf0a6488fc0066c2b137aa0e093e631f610d6893a28935200c4022ea4829bb2c03f891f38d87726975396631a2eb5530b187f7f28cec7ecf131df2d81e33ce6e446993a9f303265a54332b5cd2db9aec2b24d23976e24d00241ca277ecb000913763d159323d6516412531c2652872d241c69bd15badd2016ab724f5ccaab5366abc0110c8526c9fe5b90de242b8b1c56ba8a79aeca9cdb88d03014c180cc18a84841da6733384c0d515ba70406a949b0034efcfa4808a7ba35b63beb2e71a4335f76d9b44dfc1caf4fb516b32e54a41f0384a892995df8c12cbb2c53a98d17457bdcf64b1c0c95d47ee2125f3061f59b64d5048356c8bc62b5443b7a7d7883d249816a8fc7b0bfea75b6319ad1d2908f540338d957320bc49fd323b06c784f1855d2dca476f3e91eeb2fc343b7c425ee881ffb1b38c44150aaa512af677111e145e5ad9617302f82b86ab123c5ff4757474c8c01b5a7659dcac511e79ae1408af52836a4662efe5b6c1c1268999bff64014bd715d5001e6085d0342da4142d476ead4413ae2becf6b40713d214324615deb4b20f565fb3f65d4064bd4a6c49d1daee38e45284b0274239cfb91dd0ad18f4c6d19c5f8dffb0b03a0642edf1410c5e58dfb3fb003fdf82f5403d5a8ca01af247d1924811c63fe53b2cc1e2d6954e8e33fe233543ca8361e0b400d9429970b1a57f5cb23ffa5b962edc08220577553dba30863b638d49f4598b29b5ef95ff7514c80ea93e0bfe66149ef827bd51696a8c10bbf157e6c5066ca20f5d0ecf8f1a1c9529ecf6222caf283f77885ea7dc90eb2aeaac8db6ffaf411edb052dced81bb858ccbece520839ac9619dd3cab6e15dc0a8e5340d89e63ffeaa28149caa7312fbc2c365cdb670710fe50ae126ae504f228b6a80075a26897bae5f4f228678661935b08474aa09abf5ab80959aaecd2be11060d58b1baa85336ab4adcfbf1ca411615171238eba405acd716b668ea8c7b987b9cd0aca92813d5223263587e69383cd9dcdf90a475b54176d70a5c190b4d8f2ef7505cbd5cb21199a9252f984439507e16467977b241116273947c84be89c030d34a74a251e01aa0bbb755980523ba189a9f12fa79495fc19ef0f695887b339bec6616ece56e6941ced1a16f731777a59a88ffb007bdcf2e9b20cc174c47ef20d90889aa65964acd8f6843a600f0baddc4be6b9aa9b482fdd3fe3290ac5db5b37595a9ba65556bff23993fcb11e24479acf600da854eabfa4ed519df3791028e272c834b39f6a15ac494ede005572c8d61c3449db10af22202bcbf922747be23a64793609df2837b9392d3b93c53cd9f8c5c0555ec1a8ef1c5cc6db7d671e09d2ef3f1f7cbdd403ab6f2f4c59a87fe6cc503fe9a17b874e3d0f0bb8b2c5ba015075b667bafa7baf586fa68654c4ecc5dead29d73c743a3537d1a8f475c0f90aff3a77e87c5ccdc61c96b136928669f2c0eb3e438191a84e34633dda4846ecd121eef0199965c26e7fc6833bb234db22067ffc019f67dcd1e834c314c00c607f94d986ce85a9196c01729d45244586ed63693a1d46e5859d7abd67edc4f0310f3715cfbf919fa74530b70ced1601eb042b6122b51e83e0f8d96c82be8d1255c2ae8d39a633148bd5c9f11573dfabf128c1d4216161aace7786a364d88d0fb20cca743e5545273caeba97aa8a529963adb81053282c5d2a78c389f2cacf6e820f105dc5787616d79715361d40504ddcd9f1d510863997e29da5b1afde15d77c38060f5e745da351b228e545f994e843b88b4d92806594fa2a1118dc0d0c5f136d56830fd48df1a817e33e3344d81fdc00ba728e20973a1ba2e5b857be62f1ddf15bd06fb57483b5aa997bcf995e24ed8df0fca2c13c85fe1907340fbb33a83c725028976e3136e46e6dd2965d7ac75925e461fe6eed30ea52842eb1d7fef6e20a17736aa542fc2eb4b0ed38e59c7b9c04fbf77e698938f48a18d5771863bd121a5ddcc6506b960dfbed14b8e66659e3f44134fc0b19353945ae5faffd9ca3d0b12ba74959d93ef1cba8a92dcac3c196e4a4e35cfbf17040c0f7df83baf80eb3fbb3cd789cc792dcfbf55f320e99faf42dd3f4f3edf63cb19a42dceb186aa19a76f2fd222ef5034e7b06e8af971d5bacd2b753f7d854d3bfcd8ef7a2831b9c33bc49080940f6b9fe58bfab6425cbd4f5a3aa08fd4334e1a4609272f823f107784650289da02803612a0cf364038e74aeab727de8bfc2e0188a9c8f14ef3d512d02617fbc44cb58ca2fea0a3636b9b6eebc161c9b7d60ffb5f0ad3f08d9229aa02822ba7f8c04fa7fe799509d94fee0aa9811b77df2be20afb5fd632bc5de8c0a9679932d0cd1698c8ac03fbd33ce059f0efe59b810fa05644a95f828c82c92825f0e0df9e1a835ffd225bbd59ae835a5310fa04c877581d7b65f3526e39b0fe0dd4310caa8cc95700352dbc08a0900a43b8c7222b3ed3463ad8802b99ebeb2eb904bc9a6f3f2c7ae8422500aebfbd34cd08c2466075540c6adb9cfeb91a550e594150769f56740b90bbbfd5ee13f8258b297fedc496b814f116f8e947db04d4f9e00a4d27cd6223283d74e6e9ace8b721452a3a34ed72d2791aa874270d9be319fb74ac014b4a29cdcf39e3183baa4e3ee62b6a927943539bfd8dea7da6584c5182cf25dd150b91bedcac13f904a9264391699729a064d939c467ae6855ffc23f8a7fd2e5b8b174da59709eaf4fff0f49ac1f14fa6ca6395f00e0f9d7785006aebb7f2d2be1c34b85585dd6ee7c0b03957506b128c9282d6288488b07559720801a6a95b3f99843a1fe17afe13ab342dbd52c0078ed95bb77bd594f5355edd4a5a859b291f7c19da3a762d41d94848a91aa6d5a93acc51dfd184e99cd1ac910a4c44e968574f7532f1354de365ad5b2e16c8213fc944367c37215447d04462e2e8d5ccfae770e9539c94c5a4f6913b9277777be77d03db4e140c2170b52c71ce173216488efc8bf8f39ed4993bda3b455f53d2f7c4b376284e713589ae87b3fbd0af4bed4947f55602c4e2f2021ac810ede3ca04acb4599a70fe2bd72b2df50f7a6392c5f3f6c32548425fb8030cc3f411312a19e90d379d4da7a8cef9f8470243b438fa2fb0d54666a7cf90215d5eed9e591c01f84b8681f140c2c425db28fef0e3036bfa06d6856a1f04a7de9a7f2cfdb7af7064ad881a8fea52302b36c0ac3355c1fee3ffe7debcca24d37cdcd54e120cd05e720c11c166c483eb9cf28e5fcb7114d54a6fc5ebd9cbb6adb902f845cbdc4000721775c1abae573751b21e189ef38098fc5605caeef869e9b8071ce51fade7d0deebb862e58fdcfc61a7902ebe45188107b4086a8a91411b8865c9d7e9896897b98446da7454b5e22d92739c0dd38d62961b6b1ae9d94627368e563f33522a176eb4beafef54d4df6bf09b71dea5ca0e5bf65127f3d623d3faee413dbfda5ffeb63c28b8f36a3490dfe0da1bea7182935a9e50fae9def677cacb01aa4c89c3d09af5cb169558d6ac35e3103b7783bef34b169fc552219a65bc718dcd06efb8b14d91d3eb32710a87d271d8429201ee29e6284b4eaa5c5dae1a6213a0f5e935afbf6f2e80613bc12d9657a0bac3b7586e130a6c23ddd665649ee24413c878acd6d8dca588f44eeb547249554723c5e9c87f1268367830c2c00058dc23f950fff8f4f18a84cd9d89c6ec75406ca087993e5f68f383f5eeb6078eb1770a1f2fe503f1ff5b009482e0735bd1eebf36c21d01a42597b17682aac806c7b21f81d4e9c37ec8fab0dcc2301d3c9bc0e99882d11ce3b65c21ef6372572da66c92509c021ebaf89b5c044837b38a2420eb3ad8e594e3bb9c46a5c30ffc68542fe0409013285c69acdea54837e70420bf739ba39035495b0b8eb040315f569b4c403e061dab1709b11303bb519eab9ab2b4cac6eed2372dc6d085b378d97c510276466e3a86b5c72d5c94925ea0ea59bdd1edd847a22774a95651560ddc5143573422d312257b4fe9f156eb7b0f518a6b365a1767d0a781f8cc199060f75ea635ca114d51d51ce02943b4d40245b503aace4096629ee1fa53a9a81e819664a8c0c54049ee40e77890c78ad33cfee2c6a98dd6d7ebead08467f98c64b5164ffe79ed54031537c8e8d8361541a4ccf4a9220f43e903b541f92713770bf27d1edc7c00903806088adecf1a27eb0c80ce016e500639b2b3fd0950acae106dad892c037262ef49d512fde05d77351c31a6b1f0261ffda893316ef3c9f6df7b461d0b64689bfadbe48edca5ab4bd6bb467d46c68334e0a43204caf1557547246d0a03b420f9373d0c99e5d31fd686a4d098f1c63a9f393b700970a1e62b9625a69cade75d3915c2170769c6c05905a8fbb015687d088c2115db8429b35f5e95fa2718d59086c7bec95350690a2bcae77c7526f2b8da093a6a37a1f3a36fed935f07b7b5492b46cc195f62906c4ff873d9613d731567b1d23fae59e7b1cfa4d7eb474f497cf54520331e5acd93e722c75bb7ab1aaa0535760afebf02a8eca7c53508fb38cbd0b502ddad73562fa3f8183d8a237807e6428eccb1c5da8d3d2011330c48e0c4289d68aa5a4bcb3f295e093ddb12873d72f3c6dd7b5a4ef8d96f8e5eb9dd2572148b88b262824ded35541fe24c95c9adc6f72a71e6e6bd196c82df45ed4935d4be0ef8cd77db7c67b6f6a38a5bcfdad3f7362e479b4fd3308fdeb1735fe32f6f6b43fc749cbf5f0ea1a4375007a817962ea59bc44f8b27235054eb33787d9093196a7c95affbfa80ea846d8025ac0b61b78a4bcf93467d7e95d7e403af703f36e471dcd84d00283f4cb013bc2ea82e382cccb33239abefbb65931050f627dad21ecf21b29fbbc54807d74d8b376cd3b27eab6c4aab1b9143801c2a154640d7add6f6173b20f5b7ffce2ee738724b2a83ca4128c96c33d4a5b641eff69031492cc1724d218c40761b4108a5b3e27e83bf6249a5a00deae81355234501bf5abb602212eb55b410854c21417cd94a1eafcfb9dfc01447dfc422eb076418d4f17f51aa182605848380ffcfa0df232d30677a1fa275de8f39ec7192d766a9a89c297507238050396f03583569b49937539824902aea7f911130a4f3e38c4a2d7066edbaf6fc5781f2c32b998869548b8a09dff1134af58f8588141c64b88e0a583ef86766cd06fe017a6e5eedf5b72a3aa9e48be3fafd6b641c6a836b17ba0b1cd23d5aa91b113a16a3aa689b178a024f482f910fae29bc038779665c7863a535b2d38f58981785f68dbff16a91e3555100647db9660676978c744c2c603bbaabfb9954063ff3e20c080270f4dad104bdfa4b11a6aacd4fe4aa3c5cf2bf3e297788878123d4043f982a7ab26d4fb55dfc686756bfd17e6987f01169360034982e6abcb3a07925b2bc75b8c8bd228c3de280259fd9086b8f99838f6f1195b1afe7058e36ab21c57fc6185f03fd0872a3fe2f71a2841605a5526fef82140967f0ee52ee7a687d0eeb3dfa7e89ef9630ee090bd83a4de66fef5aeeafd5af5318831be0044cbbd584e8de5a3e4072540f041fa0c2f2a3173a06a98c73b857638e61a3e26bd2822c9f9fe46597281253be535e84ffd38f9c0e1c31cb80b1a0a728f98a892b00768efed0c6ca85efcda967169b00701f2c729c863df00a8a1ba9effa9fbd5f60f4295fbf89f172ec5e351b41c9d3d96cf89b6da196220eaf5cc1894ca783bcae58b07f83c1ac53b7239a4acda0941a745ce0c48ac424a2607e0c23286971f3f21eed57e6c9deaefe27eb98d7f21bb0ecdc459bb71006092eddddf43f98f26fea441c9f321d5ededa8cd9dd3e240d86a9023059881d619d4dc520a6d09ac54f53b58e43eb70db86987859e00fc143bdad25cc7d29ce9ec4193ef99a05ddf3b27730494740122597c503963bd80e1f8237ecde633a91c4e3868575c21e32b185b52a3cda528645acfc2afdbef6bc5113681ae6bf3d8f80311109b6640d9cad19b2e103e21bbe076ff6e87259cecfb697ae0da2c17c5ff16594e9182a880dc9d565d5c4d56963207865afe1e86e37c6d94e948d4dac79a8d004e71e5e381f26d90370286e31e81b7ec6b433b31742c6ab0e4560d81dad33a0119d830df3b3d6f693a30401c6386b1059dc602c1d9fed5fee1bedb215659361cf4cf73282989235c7266e674f9fab02e00ba8e77ec99b9780151bdc03ee5b95bb096c6a2ee5152ece14de1b8e098b0351b2c70c40b202d167edabff9dce44eb3b86ad9786134897cc4e98cb67f073f697c5d29901b85807e9deedd0e842052002c903f84dab199e86c6e929584f8346c292804d94e244da2a471ee5c7c26d5e0c0499799d60d1b8998abc30d1fd94eddf9164f796372fe859d869e988a119f31f87c7c0e2f32e2e1908e6521d7300d404f54798a8329f67898f82527789c64593ce6c533b419d79d2ee67c56d86fc5bbf90f62065400b61353305f3add67ccf0012b2638fd071e74a9d674f446f654103b9ee483d083633305ee2beec21f19b4d397f3fe70433d0a6d89ce32f5310bf4390afd3ce7ea3899079a446b6cef2fb1b33d004502c81c7978660783dfa711d1e26eb356efe90ba31efdd06cfc93303a7d46ccb699f56bbd7d269fe32cfa4764abb195275fb62a009da51e0a46dce2003cc882f0dd2e3e92240aec00dfa0c73df4fa040048002bab0edc45b189c09edb20bb7f517afa57c09b57477f9c55de06dd2539f84ad927248afb024c12bd2d0b49a289aa0e7622433c0dc71c82f23ef7c36619ea6e0b2a343b9a825e68a41339d818a5723f158f84cd3629896e8cf9dba9f877c4510ead7d51d70354a8e802af3cddcda92cc723c5a5671d60cd4e0f2305901e1ec7a7b4af7b01b599d831b3d3eb1897cb2148a18cbbb6dacfa5338f4983fb86e7bc8ad4bdb05b40e20313732d434cf31e8d7a3eb2268fd02fb354c562d42115406bd0d47058ea831fa73d92c9f88dffa99f69817c3f8e5b12a71c9dcdb0c965b4d45f07f0fe697e1556cecde367077f158196ebee546a0236ee5a923d7461d297e37f998e4e45a7cafe527bbcb1aff70e1d1c7f7f4a5d359f52897c2bc72803752cd98177feb1a5ff71a208ac74423238457e000ad5788e3dd9bb0299206c62d3929169d33ab1233ea4947ee65b342210d6b3760544c99c122c499027aba2cdba200e6a1b6b86b5302f24b276e79ac2763f329010d7098610f28348f90f2ded325026de79089360407cb467d5acd882a1aabdb9bf2ae9f3887e6e98c0d3dcca837aad21a3bdeec390917cd98fb7e2fe5f20a15bbb91a1d081004dd3e06e006b2a59ac1745796991fab1de1492adc7b816e5873340070596a58bc176e5c59319ccfd015c26264833e1397a550bb2a93a6868318d4d42131a459e4a71162d00d249890b986d15c3ed1fa5d13481574aa58e507159d82b7b383558151d8d709175ff28d0e41e702f6099503205e663a53a88d7d930f7d08b71ab6c2a319c52eed74ccad6f80f779e52d9fd1429c76585182ca71101d4432aec0853403aea2d1c38af7fd0bd0838f78607504be64fd2fb80b1c8f2c294f6c7944c1a6f7c9e51a287cdd88948ca5bf45c3332f132b7bb76fd78032b94749d309a781ad0f8622dd4d72622690f69e3bd53187027fc851f6b5f32cb017c00d59652cd9e4dd39a7bafa3bf2f422d7b4e8e6bbb168ebc61758b85a40356b9ca54530158d32f486336babcee40b783a7f9b2c0c8acdba1ca3325af91f47de7e87390be1f265cdf750a13815d15b887cad7bb9a5d6d6c21b5f28efeafc7a9ae539428fce1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
