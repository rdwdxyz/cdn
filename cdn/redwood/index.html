<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"819a20711f3d83080f2d2b6fc7931d047059f742a18462c0c768771793c9ec4845f1e9f75a9967cf2c15b349522539f697c9acafafc3e2107d7e8fcfacd6786df9e19529f89941efaa4f5e1b11a9d62e3358e68faea30352f63b17dd988ed0693985b513616b5195b58733b43face154e68acdd0a38e7c953cef6c7d075fe54fa64b2446d3f612467a5ceee81f88b8ea89de95544d4c2117dc7cdfa599ba44ec38ff9fd1aaff429fd391caac44474589a014c5d2d0e3cf2fc531bc84ef8c4a50390beddc4fb4e64d06bc053aff83f1575006caa398b828687b1b90ad37e3ec2b4c9923ebec6b58b985d36376f5860898719ca91aa57b65c3376ec28b9e3ead11206ab0d277ae217a9026e74980594af4a16e500f69c3924ef67b9a0e00e327942e8980cc66c4b5bf93695b53b4dc252c188b69664d5642d065b4f529002d5dfc2b7edd05cda4d149d8b23b5ad4d0dc33f9f321bb67763f934362dc8d3a7262923ae455fe8c4a30b375d90f9123ee1c97fdff07c69070cab4034b9bebd7266d667a143df082944538c243966392d4fb7b3a333baa4d089ec3cc263738e8ee7f91e520273f503097b4952e0ccaa770754cd83d7fc8c781b937fd5711e502cbb936a147bb2e3a81930db0f75bd83d81f3f36514b668e8c70926a3cdc7b1539630ef5449c1286829b6155a10b4f484283e2ddea1072ea1a8b5488c316e808b7125ded9bfddaa04e7b80827f6fee2703d15da7d185c727da73de10bae3ded7820f801e1297f8e85781196830fdfde50f7349888f8ccbe4b2957b99a4cef680dd210e3b3f5a480ea305d0a9d436daacedf7c5cfde736e8827ddeffc80bd80c532949e1f87b6e3956ea9f8a638133bf99d2fd1295984b27facb8c2f3c9d55a7e38e07a83eae6eea85b431f8d39f2c9bddafe868724012a8f5d2193f81b2646532e0a2aedf707f155315ed3627fd67f53175a0ae7521595568b31a09fcb0498ea798033bcc8114e033fd6a09cdcc1717eb75c2e13769bdc8f1552aba792bf76d4f487d848c6f2fb9228397f33238b2f0dd71cf60b4fc2fd9d01ed5a645db685c11d7469e8625cd7de3d486143c1e050d7ee050a477f50443a94d51a3ff996b2b6d6ae433b1ccf866b6b3121a7bf94006d81589d287575139ba12176efcf3da01899dd00516405ee0698f14b47569385820cd0cb6adff96592867963f17434148c1f288fbc7f7bf6c2bb9cf76d20954192ef8a891ea05ba9e3870fec22635f40fb9ce521b30a7ce2ba1e5b6bac91975a1bbbc572ee67e90edbccb972371b2b235a9cf1a84ca95f1974bf45d69aebd25a92f631bce7ee6743c9e0199b90057804c75c5bfde030d04eaa1ef50d7d2bf2d36d7164ff5b6aea6b98de1c36814a62f1434d7a3a1cc8eea87870cde7b020cf7a2ac03878d4e8125c683e0bf6d1ddb4eeec7168461b1fac0622fb4da3e3b7437f7b28ddda2e7d633351554fae3b41c037d30f3faffd77ba3f7d9da4fb8292e5a3f50f2725992d5444435ada510113b3d9b73c296062f6f52d6b6eb1d6f4a80db38e592a048fd8e76892d1b37bd190565293f10aa634d68f9c2fc38e2c794f363934b5e798c6500827584c683d4df4631a0778b5f1e3bc718f0da1f310c708c103f1d33631c87e3317d896e16c92eca05f060a92d31d9adfd205976e95a691e2272f71dbde16125b52613cb3314de16baed8eb92470ff35e504f2f0eed5058ecf747eccce416bcf0c4d8ea1dbafc074bc06a87126774dc1bed907cc55bf478cb91798c3739ae396f678ccedb0538106737d9cbf917ce2d1fb4207e282aec1fbbce7e206385355277168decd979e5efc262cc309ac045e2accf6976c6308aa41c260a5bda2fd1fe5abd1d417e2f69d13427e44c60a431f5b296ced28c388b11f3edc57537f05d063e2b2bdf06d859b860028c720312e26b45e13b98b49907543b839aeddae9e76899da06b64531e3ded9511d926bde109eda23a1428ecd688322104711ad88b15f1b74e1f4ea6d38fd9187988b1214bc64a6c57792c791b83f1e18861f32cf3055b46261b66903d83033d6e925bce65aa20cf6c442fa116f17b97206e1322143cb7fa729c089fb30ec46745bfad866cf498b334ed79c88dcfd05ed971fa440cf9a262aa50039bc0a972159a90a83eede99c14ad8be0faa441f17770c60dcc965c0ee33202a979f305903ae74b2aadff3790ef41991a9b334af5c022ea2b94ea31fc04576430b8084e2a66eb640957fef0023df2c6c81a19e99889e9a7845df371ea86e95a6c4384bc486c79cb602c9ab8bb75a04895db2cee232bec22059dd9c4ebe685d68d2fea61f26555bc69ae7f0d7762c7acdb3d3f9d32ddb81a6d61f9ba4e7dde9fb8d7d75358c96b541ac9375ed233e268ea720d3abb6d18a424a57d858eb2a02081e1408c612c5eefa8369041897851cf908b8ee360a103dc225857357a673b06df05e3dae741d2abb6fab8773c0e56b489378834e520d3444b1c976e4b1516b81577b535c6486b878aa9ea16c094d5466f56d138f8736985e2bd9305d8329541919e02fcc020c9dd419705dc6ddb1799a9925f0b338fd401750001bd84d8f8ac17436c9341872f9bea22052c081c9c3f8c91171ddf17b92fd53679dc72c0ccedb10dc2100281780501df081a219e62c50c05305c9e95e48e2a68d8d8f53a13dd052affbad4c8a92af6eff2aa2933308cf2607409c87fdca72634bcd56c13fb47d95908e1b409ca159b515a3fec8a166c9f5fbd6603f5e710c34034b95c4456df21ee4f472c69149305a61937961a61ada4a73f553d30b8f3646007fa391968baeb75187ceb69128f8db2154627fb4dd55983835e4ef730ecf54413e401588e0ff72560d8164f6b953c3b9e963d4118f4d560286e90b63155065c5157732bb6eb776d9d8ad8231bde22a1fb8f24882a50d083b5871b5fd474fc4b4b017c443fb8bbd6e641d60dfd5a1d9c5b90e7f5ac24a853c31f67adb5a83a3f8bf00421c9d4ae35163c9d4f43550803d17fdaf61cd5ec51e862cb268ca0944815f9a317de9709d6fa381fdd3917aeb64c967965dd36c5728e4958aa996d84e39fc4e1a931383996bd4896d4d37aac1776dc2cfd8fae3cb0399c501be318988b6a46d9eca484f1885f70cd9f112f2968a0ba71af06099e8ccd1a36f4c795f216056a0f98b5ef307f53a0250818f0720a7a2c6e3d1b1f70a77ddff8a5e4ad100d54fa1206d4c75e0fffb7e2857bb41031b0f1e0f0784cb222107f34ecd5a8744439c6e4a1829e972f5997202a0a753c94fdcd29603d5afd65ae73a3f2255caa9960e507c26d2c01f2d4bdfb56db8b6a41600e9d4dd805bfaf202126ea575b02578d5ee98f9e3f5e8673635835701401b2a9de6b3bdc82764eb8136cd5789fac63d58d03f1636735dfddfa853cc22b1fe1aa21df1e5cd976a704b4169817395a1f054cacfaa0e0f0d963a162a4fd19aeb7f4ecb7c3dd20e7f8ab474ee62e3e52f6fea700e4e87fedb85b3bfd0b92e105d2b5da68efaac0368f122eb339a9545c69d412ab94298bc972a71e626893478807ea6c107be5e129f2fc4f1fe9e4834f2ea587a15febbc8b6f6e0d0869791768d3e5cbec363121b50a8d508b8c13e8758aae2ca2de0a13e4c2e9c1a05f4d8b9ab5ca417f455f12d156fcfaaf80ee0bba3e175ab53317ae1842790acdfc034a03a2a40225d20a7cbbf9d188a2f53edf825e34e986d10e401f620302c310805b8f64d4b2dab83c1207106d2cf3b6dcbc504b4c2046721a15b852c0c60add18295451904258678ddc5148cd66d54e4b7b3c143c76afcda51f15b3251d74a6abcba7eb4c8f868f4710a0006b65a8d9f2732bac9c00d4fd9c1b7e8f4ba6b2621e2d2cba51201218682ecf77f9cb7dd4e044024700562adc1580d035679cae8945d45bac96dddf4f3e3ea5e3300cef23b8be556087fc1d1497aca694973c6652e61c15b2971dcac8619484313bf1346b6b31387cace465d606068c625e7862a4e03416d281afa7eeb3587efce556af20c3985b2f3ff79aa854319dd118c021424160cb9ef5b9ed6bc72d47c973dec6b008ba5b8b5aecc96cab3eaaf0c8a0923f39f54acf74b853b71633f53b5c0afcc644624d383200e6fc9aba882cdf09bcdbfa02a3d00ef78ed92034a956d605cca8c517a04e94f93416cc4c8a669db44fda2d08984d2ef9188c1d4fd48c028b3eff2989e1c6dbdc595039f647e438e17d97dbfc9549ef727aee7b1f0d16c6c28a5c588b9f27ab2427f1616573490fa27b7e0f4b2123eb035b15db7fc3d5e51777ff75b23cf5349822e67b59483391858e8429f9cae259aaf38d477014a28e3d8fc66037f31eec6c450f6ca082aa6c6e686c9d784cbb84e8e2351f557f2aee6ada9aef8ca34f08cc0a8e92d7c4bf9dde49790f80a9b3d8740773e83ca374e417ccf94eb0d1cd315da4b76c17854a94d7c8ebeb6261b4687ffb3c02b270cb06a606bb08f00bf51680e594aef5a65524d5a7d0d3f9626b295b7d1b8d4cf8bf39df7320c6338fda1a8da42cf26c902367b113bb818cc8583fde99894c792a78cab2f9a7094932c9bc18b80f2049808e22e89bd058e433bcdf9486ed6b6190315153f130e0bb1b3271e9d351357d6eca7808622f5209ecdac0a6512c703a1b2d8d856cffb768a26a4ce69af7429db20540a809293bb524929130a8bff6ccca433fedcc525a3723eba6c5818adbc01be7b7ddcaf86916ec98e30d40f28255e85e759fb69c23c1fe00e85225875693986c12a7267630ea3e1c09ca1c985b60ed5820239d88b700baa586de8e35ffd78ba1b46abc48f788bfd9876120fd756b4e64532d9e0daee7cbbbf396e846ff65076dce738619bd6bebcfdb395813a58fe04294fd342cd98e8f48dec33adf44da530925537eefda676bb773644454fe96af226210d7d58d9b2e372c7c97b7749d88eacce6c32130571c7ed0e1147f003bdfedaa9ac32d3ea2cfa99c91f78476abc7ea4c5b4b4daea531ccaf20948ce74edaf0268de87dc2faf190abc16bc6c743a5b261630723c7b732ad8be70b3ea01c382ad763338189ea0d2290fbc7e4c96a5c1ee0075302369a46e42c6e013f8cd32796812b1e99c0c1d3141860cc32cc50bd4ec65f798a81a392619d874c5e3c6ba4309e8c50d71b1973bb0123bc83b9fa77ee07145afdb8704855e5f86daf88a1138fadf86e4c8d94f090f29ef27312916ca9bf3dcb79e6bab3d7c4a9c9e89c8e557eba6dfaa51f3b0bd92f890de95c0c07ea92218c6e73f3725f7666f2d46b9ab10a743554d5af174afd066ab9a8ae3a2c9311f6815a11d4df158af6b66fddec08c12b2cfe9550ec9cea9accd1f9d3941df200975e3069476b88bb838b69b3a2154138b33f13a9d9d5a5cc3c3bc01d437ea6aef46c9143ec8b8db16182e8dd859cfc834462ddb9f2422833fa67652781372592ae0d4876857712e7b215b533e320c90800e87c8a302b1f91215877aa4eeecbd28f8aeabd8430898343c0caa502edb42d199e3f05b2a254f93d1cbba1aee4811dc4f3abcc396af044f01f68c4590d817ceb57271292dd86c212eb4fb76d7083f5802e5a1904f74c79915e8b1afdab6d42167a735ad3d34bdd19f566d3fbdd3f7e915ebc9ad3027446551b25c206537f4a00be6cffed4260bd65f80ff7cd05ba80f15fdab03488fd1d819065732dc8bfca95ab6393a750ff48459d1760da6a7f6f97a3df3443ac7c7f1bdf0e009ac2234cd1c052fde90df7c278b53f1b09a8851e3b68bee3b8f722184700be78a0ecf96e88ff7f97154c41042c7e304dd3fe4e8af590ab8e671efe26de74bdf9104a36eb6ae7d6798cf3680f21937a01eb6e18c07a5834fcab74572d7de820b66f4391c1258b5c9f93e69086f003da0b1d9291a04822955e2aaf576d94ced8e35b64268cf940b3c50fd616bc07f1792609beff4655e1106dc8b1ab7231499f3c6e2bcff9c3c192047f49672f2c5d4748ffb8511e0b77282d32f9a498abb599bd6a66f49a7fc5415688a6ea29a1ea8bd58d5f86387bfd2f4f8eb929a66ca37f8265f932f3a19a5812963c2223636eb6c12045d75adda7f22f4fcc5ffbbb23eae77353479cefa582d63dbfcebea2baebc22cfc8d1863000f4416b1020adab7d0b09577d1da189b00462ad9ed07dcb468f8ad87ab0e94ccf3968cb487834223ae607f12c7feff83efc549b024e6de379eb839f7d996f5097df6fd5ce726b06e6ef965c62e08462b119d8fc28a5adcc19bf640db9788360a1f8ea76b2d8bd8098aec901e9812ea9a7b816a8ba7fbd0e952a28c6047449dd6e917ab88c187a06961a35d2bf0f02efe38722c44b4ee8325d26805a3669b4b1ba4eceb2fa02907501f229e1f74d8201d94bee2e108b86537bb3698db0e4c0f02b9074546dfe8778de387ff3c831f710ec807746b6f8e6bfba99ff70cc36022d06cc796d546c049787b1c8e984b6d8d4767e42f0ff7735a9f0667cc154f1b77e0abb41ec03ee1dc2ec8622438e23f148983ae47ce13eb2452775ac1a87c8cfd37882b99ea47fdddb9b7dfc50c07dfcf204607200e74455f8d444a2f1b440135b572647203cc7656c65d4f108fc9987ada847f585cd91b862fe200e161022ec4316c1f934f91a576d114a6b18cf10c132fa07051e847149da4d62df6567d895fb69d13c92bdc2fffddbeb95fff903e7c046ddbb6f9e747350d49e5755e3ee00b18830f60fe48dd56fa5e39b6929f2cad27c4f7cdcf9d72772b49e1475e53adf65b78a7fead22918da458c2d32541535bb2693d61ae574e271fbca4f613c7b9bfbe17ad5bdac2c195a1dc4616894b82be90de1d0c2dd6dfcd70cea217c8413a34b98bcc8374bb06860252c9ff72075556060c5aee6702dd2d5178fb49a04da116fb0ad057448d8ca352c5b69871ea2f3942488c8f0588dcdc26b0db52b255d6a4de250761f3c3028c821a791d33dc42b1f0a5f697fefd8e2883b105516812f9b1baf719d1702592d4a107082f035455d9b3e10677cf98d2dd8519da1831a1b2936cd4366991cf2f65f0140fb6602878fc87941e0959b67c40ba4098b0dccaf975321487cccd7a636453d78151dfbcc5ae92d9ca0d734b9f756612cf1765cfd72696b927da441c20648f76d7ec40b880a1d3dc7fb53ae618ca8f2d0c6777ecdaf318f4103a3e3e31f42d255c2ea2bd22aff95b6213f1066d03d4062aebfdfc72dcb3819025f8a113e66ebae647b88869ad79385e1e8dce090d08b8ad2d2e8176de6de4a7f744327d8b527d3a24953a4ce097e10d976c6d7903295def478a5910578c76bb267559b3a60026e090c895012a7f7d7ccec09f73eefc1f58c40223c0e4b4a584ce5cc96cbe3d42ba30812ad2d5b314cf4257d10bc5b66b04e156e999d047d699a5bcbe47bb5e8a7bd6517dfd8c35545f008471cb108f1f4e16bac4641fc3b4d5fbc4378a6d98fecc1fffb221d1f0214b7d9aa29fc3cc63a160426ded2ad720f06283f536c16cf9db56dd43f0b2ea3ba2738a89992a35cea0c93239308578f9f624da3ee5ef901b6a3915e4f7f04f6a8aad9125417ca63c5ead975341625e127cdfad6a82649abd3d5d010a8225a88f3721cae3c99c6a3fe4a5df024fbb0e58f1b23e219517a226fde14ebdc36c11948391a6c819e986b1964cb5f6043f12dc81a6f38cd51276b695e6bd079b3b7aae6259d91a06ff6192d222e448a9ae63a4c27b08a118eb3fc467bf0aa980ff981bd18256dd55d33ed38c24dddea6e7d7c06377fe0d02e6137aa9ea5af5098bd1cacbe283b149c807f18225cbc1508381770a1691d997e9e1857e79e5c8dfe427445d8f5f3063650fb9495a2bc5e08fbf7f4dd28f0e926fb411ecd21acd7509772c62b1a8b9f3bb6993c443580eac0d3040bc92aa99bded6e393763830edecda4d458f7feb19bde413e62d9f016cde225f8be59ebd66e9773003ad29cc31e16e7162ec93761607f20615a81e5130075cf1ab199f29193dcd7732075c273d6bd8c8d7064b0d0af2cbeaaf19e4e38558b36a49e25eea87cb38a23f24f5e8b6d6cd89d791fccb955243c0cb3e8b7567702211aafb871903f9f6b381dbde2e1a2e38ef9c2ffbb7250156e44f96945d886566c32a850e8a2b07ab0c0627721d45d70600cbc73431c5b42ccf6b46069a42ed1845e1fe680541e971f66cf85d09784f0ac71423c2af8cc7e5c5e98d26aeb492a5c12fc1f1a25850af0a04fef334e2d1b82d3d1704ff9ca04af740ac5cdae018011a918bd8efb09623da3c041e65ce14fa00e214cee51920e2c2dc469103feba8fa253f90b582fb5579300a6e9b6140b6661372291cb3dc6a2da1a478886d92cae7eb1e331312b1ec21b9cacb4da60e6dbc6b1f6a3a633d68622a24111f07edb616c5022fca22b5db3f44374265cb0e02c33438dae20cf764765ad09311b49d252054ec3cc8899525f4ab976e7c93b0140e2d3ae7b6f248cc05df16b67a7d39bda42f9f85a321b96a759bf0ae43ba673951fc31bd0d60523a60c1b7c1d3521a27798db837dcc7f5131f133dabd34fa11b87c4338ff4759f574831987769718ee09384c481fb26e40d34972ee356d9269cfcd743bf9c29c7b6b88a00dece322252aaf99488bf671c6acae498513d9f06f2be9745ab9ac6a0534d2d01a28fce74043530f196e33031211d2b5e875dbe6324a3451fd815b7d3dc161e82ced797c613ad7ab8b5baf5df7ee2241dda93a48371622adbef17f3d41b250f88435343a9b7b1c1224ea7b3454afc11a74707c566cbaa4844341f0114925b07803b64ac08f637315cee011519b48836c951bf65185e5a120ba78f2ec0d1879d96d6ced99b0f453c70f0d1944565dbde9b3abda8e44251c09fb19b1e9f1ea9d9e80fa5e90818983b2fe7d47373bdbf546c661dff8b12fc51c9b426a26f1a77cf6b0263d2e7acd30d23be99984a0169f4f2488aeab149de43a1479b3413ff2404f6e3d20905ddba72be32d4dc76d491c66651da38e470e4b5422da60a113543cef85840ba0f5b3b9b254731b69d492fba3b8ee31ac43991b88731cdb256dbf49a4dd7dc90aef9dfd7d75947f49353859e007c2e83de19c5235f6a68562adfdd020fa50955f39d24aa23195c857874dae383e2e15aa2ea9eaa997fa59ef5ef5fe3124c3de8ca0fbbaa278db5071920da1d3ef185bf9eaa633ea7741dfad395206d246c5cd23517c7d557418417ee6dc49ca1c47b901bb834702eb68b1c5e4a73902a2d3c8266a297ceb9d3f4ca1432bc19561b060de748d862896854033d83c65cca23640a5add1a924f50add225691271567e19a0b84f8b5b2a62f6038ef51a287e015c13fae6d47d4f433b567c227aa793ef9949b5747c3b56df6a54200eb9c4b115cda6a30de38e07b6e0a6e9ed8d6a6cf04ed512e9098a117542761318e59ed99894dc842f26a3d23f8ca21b9ae8bb71c1fb30c8e4c7dd9235bda46b952c9be87f0d79de0264bf872c719bfef1a8b833119bc86a062dab86054d5fb71e464a6db69015e7dace2803b5d5e71bef49e8ec44868325f20c4c023ee0047050ab134942bfbf764c7b6543cb6078e79d449c780db966f8dbd5f220b0fdbac63700a2cc08cf069271de744639f7cab2119717b52445b0d9434bedb55da4c69d0c8d3d3ebad41b9eb65eaa654cba5fa79ddffa0276917acd3990be0849fa035b74965dd2da55fab56c5cd678839ad98126dba1e183090ad36b09b675d4aae82e7ee5bdc4875c628dba4f465c74161ab47c266765b6987544cdbf38cfd40eda2962f5f2f9d871bdfd9bbf884e49f115740a06b111af20ebda17fa3ed11b381a008de934baa232b0adb785bb2fa93d332b67d87dca63c153e35376898aacd4d46f2ebbe0f1e1f55f150fecba5c687d74ee093df48db84abc04a90fa8d63d1af6535a2d4e65090a2ec50c2d10c01c5a33d66c48e71bc96525977c9a46fa72f033108c2d3932161bb39496f7f3203de078ddca2bd1a85fd14d8035ac72cd4397b84078a0143db6cd8333ac2bd50dde4a06d287ea32aa5f5866eb0ce6abfa394a7832d5058cc0cbf7921fefacf4741b9df5e57b562c37e0fdd8982edc84e6ea7aaf332f794e7391ef5145e500b9e2847bc74e5cee578eaaa117747744bf8de874593513562fbebdbe6f2562e141bef0addffd4a37e74a1e26065c64f8de84893ee1159dd258f6bdead9705ade048d43b897e55d14bf733dff574c1948157378668d9aa1a406bca84f4e1cd7cb1179ec54d60186297e06e857cbab0265a57dac388bc21568425807bbf1f1f87c02650841e2532621804dfee531aa811be8fde7f6bd1d9db51628f3aa6c9fa5408cafe128588b0194817de3b91d721d33b4a38f017ca4af70c16f28642d15a5e58e5a8eed3c1fde539f9c2d88c6e0c73f34a614ac0f82a69cb092dd6abbe608b4daae9254e0f7adc581512263722919f6c823b76f2823aba603781b70b556698b6e94c59ac87caf7ad77d0aa6e0fc6108f6cc9e411904722161758d778fecaed9eb53a3941ffd82e307e13a88b9ff3f629d5415df340cf359abef209bf695312b4c74b93a0560912164b8d24bedf073ae5920e6ff5ecdd36b132273a307d0162be00807f019da2e1ad2132fed89bb80c7dbcc6024ad67d50f71e1540345a4afb82fa019c9c8dde104104efc4093f0c3b02e2dda400f2889e38b5109cd02f305fdd00c23a858eb4f18b8107d9d8acb54aa62231a53dfab6fcd2b1fd20467e9f0cf76458b0757a5d2c43e6ee4508e7b04ec37ad987f7e4e1b8358017a77f87e3df9b9f0f21c8eac96d95eb675693189bd3cb3bc547a9e83a25d2e87936c2d84e2a89db28193c159a57196bc1cbf69cd2c4945c7af4f2c3ae04d34482b2372a5955858ac6ab3e09c92d7383cd2105a9289cf77cef8c1a834ac792e23a7696a87bda6dd519fe5a54d0fc7fb7d49c8ef20120fdf584a9ae37d0c29473f3df24151c9616ae40325c7ba6fac07b3926785e34b0d8bd75530d1b0d96e8feb89eb76fa8391ca2c46aeddf78786022fef50a9142c59d013061462564ab42d4ce48e9b13104745695305edca56383b53574ca14f89307067348a95ef75d178ee47f8e31fa1b8cc2e240dd1a7a082508ed139401a292da39d8ac709efbf54563565a783578c7c2d2a4c75f009504c8698237bee37784f23149a31c6e9af2f48b129501463ddf0a5e6170ea1bd7265d81f30cdc54544e69a1dd6f113810e3fd9608546c9846276072bf06e539e1f10b5c5c34957a3a8ae4cc3491163de87516b2102f289163c6f4d63fe9c88cb902467c6f69a380ffbf9722fd81c9eb33a8bc25a4df30eae7e0c280168ee0ae538a10ff07e61c9dcb1bb63715b1d14ff20a7f4ef5d8eb33060da2de2e88a0a18cb7d2710c6b7596b5c85c4c98b16332fc2a4401b180982d4c91ac2bf684d688cfe74bbf147e2e8cff2df32e83f8ea2467b1abc181db96ae54a7bf9f89b758ead5326c3e3630805c3fe7ea24dd9d92f3702615ebc700be09de688298db3542dfe351bf573fb4b7626c25fdf97ddaa646859fe20fefd339511b831d882bf954b0c1a15238eb2a5f2e8e0871c0de2f11031d64de08639aed8b42549ba3b009c3045d645d58038b60a450e3d2a360f7a3a28ef76e84b438d2d4ed45bdd2b982559394d9a92b719d0e5aca4663d368cd301896a8698e73f828a25c6c0dc32e2ed2a82c4cb9f2b8c80976a733988f464fab1de6e9a288b95f8811562c0d4ff57fb530fe8ad385feda9b547899f789ed4e4a7a78459ba94e3820ced90e31c6cbfe5669af83f74fa7d2a90e2150638e8aac3f9481284d842a02d92e0bbdf8c40847c5acb2d5a411872c409bd6c83f49263f80d172c9195c1734ba7f111d4ced055ece3e776bd7101e4f1b3a874ed97d0eca4e09fe2517918d6163d2d2dae464f7191ddede6029c71fe17ae8544f068a39f879bdccc504710d7266e5d871ed2238c2bbdb8351620c36a15c8c562e047c6258838b4da5f15a995b3b08b46dfda33f78b50493482ee013c18fbedea8dc8274164d40e22c8fafd2896e8eb57a9eb5680bd93c5780279a49d536128b0abcdfbacf5192a6fc47ceeadd7b0fffa9b13799a70261d6778be51e8af04ccd774323e0b84e979dd156c61f49ffb799c19bc1e94908669d813b5b1728bd1ad16f639b361c636303e944c4533b40cb488bc3562db18322f4ab0ae91f53daf06b6e20511482426a0d7e3c02574302ca8f74a71d0332016472a81cefd47f13b66870f2faca138b8a422b9997e871c1f14b5a97973a96d1cbaab581196add39ef76fd1fc967490667b03847d125ad0ba9631858bf526896bd935adc02d0af1ec8f9a8da5d2d0bf07577f529362c26ddbb4710dd3721a9473579d9a68bd08b1694c73f8befb3869add12b1abd1a58c08e5f8301e5a700bbb87408258c88542a01e7e788da28033dcf7eab575133a0f2afed2e0495fe8f2af585f7a37504c91a6eef83010f993a22bb2e4bbed79a42f6446313c9022a513c75ef749b170ddde49f37dfdc7918fbe586cb54f0f664c86629b9a70d8056e122836ae00bf4227384c0a02c1de43f3004a59d2b94911d1c00f1a5a05c297184088cd73ab3a07cde031aa4da8b107169b6b9a13da4badefff9bd92c6dbc6e6738501b7bd40a5ae56ab47abc20c214b36694c36d556b0d4d9029c10f0acb7bb97a0dd0adbbca6447c5135898ba125991f32bbd24b23499b03b04096d73b42b1692e2bc2daeee50f0d2cb2e716d79a7d7ab3ce047cd59bea79b916fd4b66d493202b87d0f7347da402e9f5f92125f14a9f197d22b482bde2e6396e731d76004e1bb255fba647d86bd4c8190d76d0ca072f533e52a811bfed638baf42b1fc1d5146539e04c6a6b6300f436f9df4236383e9f1b0b3db542feab2a8b535c8cefe8f0f7ee13c23a394442a851de4caabf61007e1e538acf094e81a847f094904a82a81b7e57c5b6920d0b2a849abf1192fa2e27bc2b281de88bfb9f1c8746112e26676751215d7be5dc8b4a59bfaa676a8846c0a3a9d857310a47e6f0db6e4663519ec6dd78ffcaf962c06a235692a5cfdcd8a2ebf71d0edd352b88636bb6e8dceeb388320091d5785f12bbba97b23603867e399c10042233ed877356b02af23e1d38597908d0fa5a1f55de037e2c8e6579c077d5b35e0a0cf0f982acd22236178a9f77177ff2933980ed5c04aa3ecf3312e2fbbbf0e3adf73ab813197c5d1425750c04a4faf8101790bfb60e2b4ec5a703ac36285be819d7fee01f07af2ecd495aa54cb6c5674ef6d0db521b0285e3c8a5a5aaf1e7c205e82a23baeea815f6a1ccb01f708180b3e27ddb412e76116200e08bb9fe0bade4a55e3074134ae0004cf8080cb08fe24d468b31bb16cef06d784d5955b91e64f9ff75e056dbc6c0973cf4cea80e5776ff0f8f145c5cd7f5bc954a81359038b2fb32909ee42cb5119d7beed427766074f74f2474c8b11ecd431c75cb14e5ac5161b13ff05eb8176e746b4312c90bcb5586f3c343c61309a018ef97718d8825bc42cad2b83007341b36d1fc2f824e4ad47ac79c7025871d28020bb743b76b6fed7fec7af4e1e49d224018fea7cbb27ad4ee934af99059e28ed96b8ba8565ac598c496c692b00c7a4858c06c5b4ac56c52b2a592cd98c64bea20f6ba6d62cbf6c307798c226d355fd3556c5459d2112fd62efc70b6a924ae9a70bd21d9837bd7611e41253d7d7a3b976b853fc128ab7ab9803da695604ea9fb49629e2bc558f33bb241be3b4479a132e0a60b9837abc66c6d8456ba1a6c451e4a1471996825b06c456427a1fd0936ba3610436956bec1d239a8861c096c8c68536a4301026c2bc04ed898a283b836e6c477e9bb930641065db116c3b28fbd85aeda0ad8a584fb76f8e433a97be4611b232f13d102936f6b31b13a3996be65febbad2a38c06a096517b9080fcb6a286f5427d9a04dbe74ef7d3084181c3e16716b3e4a66e380d784a9d687bd589ed6ec402c4c155ee32f59d51b98f6b35e9eaaa4c817250447a32d6dc00c140cad843e51e3e6ad50c992c08ff39485b7d70665a0c56f0f083cfc89ecd0980d40a74c60b2205aa89223b4fe57f597fa8fd00da7ae485d7cc514fa87b730437f9d41970729ff65d814dc8a6cf62fb4d6d7fc8011c5b2df96bf3795bda0a50839cb14af4500d090b6e06734b66ca7df7c656ef2a7f7ac9bfb31ea500a079abbf1062076f1a50cba41e53e8b1dea1e73852264c5666c051f9995d2b8a581084baafccead8b46233af94f6c37a61400fbf0750734fd52322b27351a8ebbe6749333d1ad33b8d559c2b63ca9cd3b4a45ece999e82183a44864a62fe45a6ba87383a8f01a809abc01af0074edb4890c2ceb844af805ca8dbdf65ccdf3e3367937753c5c89f5e5d8d804d497e0d91217ab2cb8ffcfe5555bf379a34531e8fdb878d232a005619d7e85352abab1fdbec1431c7665a1818c823438a492b1050393c3f3789a2cbb34501fe3db048591d87da352e2a7222a54067e933caed73184b4fa5f480924e9dbb488f80d3cace1c306fe6898bf89cef7a73ce7a68d123173044f66a1a2aa72694e1aa8f1acaf8fc8745a267fbac5051585b5d56a06f377bab6afa73bf73ea032a9b735f010827711d258bdb3e95b775535334ab0374bb106858c95f9ac2554503189449d1ecdc85e2da05d73634a2bd2f3d7ea99ee3443066c07e5e14ff8ed32a316fdda888c9a28ae795df7dc1bc8d8d931fd2684c26237dcc629f68c3813c9cd29ea139aed56fd071e5f5b203d4b10fe9e9b9f62b3aa903ca61fc2289548a9366c2912bfa138508e8f1638670cd98a0455a7ed3078af2e9d21353c7cfdec14a0a67ccf13107471491d3248a42abcac56003b0ec00d6cce396c85e560c7a6325811383c9db6965bbe35d8a1087a4b96af01517f08e9ecca59ee57b14e814e3dc3a270b9720dc31a43f7e8a89e740dfc0e882b9dca118a2135d3b616fc43b33b744c04284c476a16d1311188c5561bf0e017afaee603bc4f0eb00ce43e39aae72f00dcbe8aec59f10e844774179e3047c08f986d9911e6ecb1adadc65361feb06e213165a16442ad47718a2ae64087779aee8862af023c2638fcb384171006de937fda3c73ff3258adc5081fe8e5d6bc3df30efd67d25b0ec374be90e0b52ed3b941f4144bebdaaa4f6be610edea501d4a1f547b2343fde1ceda108c001f03ca9f810f8db0434475b1857bfb5ccba5bc2934d49641c6ca7e32212344aa1d0dafb37f9e905af5db025fb1cb08c2ccc95a69d28321f3f9dfc800332abdb3e8c2480f9be9f3c24cb6985560aa71f7680a36d453614fc3bbd9a05dc45b8484e82f695495d282985fe0e4b2a51f696a25a738fa049aea9c2346c1ee6a67fba39eddf4b5c649f8fdd3dc27b8cc943cc87648597dfe6372d0912a1a715c4b594c61504ea2ddac713e657407658666c95ee358388ed99ee2ff6fd412d3e0bd53c4ce58747c16494a99ad1aa7d92b26570b440def6e6909635a8ae42651f3ab36d71be6d03b6b774f82ee0062bcf96b9f238f723e4eb7a4fff9e279aa0eec699222900df3c534ad040aa79dceecf270886d6dde01101adab83b44008475c52ffc68d573a1be636289a1d230e5f7d966b0cdc087bd105e3c7b4649cceb8541069d899c9316d96a5811e17251ce2b89710a365d0d42da61849befa5188d46a973e0a7558b2d20eaad09a27430793365e371bfb4742bf9b3ac30fa0ab97967a251c8354ecdf76d55248d2ffb8737b0240d3c32fad35a31a3d30fadf00a10479aaad711fb81e24fa8233072c979aada743d67f1ffe301b5b27e97afbb3dfda4e4efa3a66b9b25982ff5b1b2145aee74637667e61af422575874a779b287c00f2906c15e6abf70d375fa788c6f7ee26a2185a19c26627ae898d221ae2b390770018d7b38115e22bf15baf136fd3a3fe18d0a57c64a56f3a62f731e34556c17d86a3bad777187aa5653cfc337350157f59d0c521e4502b37562fcc68feff46ae91c15144327b9a61c10d8370f60ad46a3ddcb7cdc546344fb58927bd0ced031418ac8aa426955bedf4714815a01bd8227851bc146c301e95b45fd3ea5789b3fcafe8b4e1afeab8adcde17176b032baba6a9c31b0b9561236dd3d26bde086051cef7aa4194878c088f514c993b92233542f85891fa6565a92b6ded3d571fd8d00620b16cd1b633f095dcd31b9c3697ec5a2176ae9e2b8f8ee0c7842274d663b1086fcadab90fb63a18dca5d677c78600d5136eeb7170a303aa6666b7a240816453e9fd9e73842b7c6e42dca32e1a01cd3d025532157e582d341beac6cbef1f1782a30c457e332655305ef72bd52f2eba650e5b97103ee5afb94cc1675cc49a9d401351b218fc30c3e2b6d40cc94ffe18ce0d4cb5999c2a2ff672a1dd1698b1c7abcd63b4ceb34659d8f3c770b2e4f4e25d34aa706ee9b79fa904a3133e7150a3f8d672152c5a643ec872599c93013ebb52c2f5d83032ce88c7010b666f42f3b116e2598be7f856f8654e74613337eb4799dc9752a8f6a57cf82c42031435fea87163c10462bd76d32a3c6497542328836407888ee151f354aabfa519f5284b0194d3a6882ad5ccf2aef8cce850eaf14f2c3af70b6c535212ac7fa3681e1c59968ea036caf1a5d46dd73354821a8a2a5cf27b8119984502df47516fd65ec3363150b30afa2b78179261aebddf0a4c630097a0d3955e7c02336300d9bb8aa04fa76671b1d29eebef5042f0c50a39749a1ad9529a2fea878e4308289f45939275aa4f2f6bd7719872827e0e23221ab84ff687c8fa2601b68f6c59523ffd7984e6c8543ad005f1aa5ef60476f6b7347bc19c77d6bf5a1897f12c611bc8ca89b215e642983484704a19f349e68b6f2777cd2a5aad2d17639ad6ee979206cbf1f91ad11d8faef9b4815a4371b3af3a93d507c77587431e7d9456167424bff1ce862338e18e58f9b84017159aab54e48a00c65393fd92db6b4c7fd447e1dbf8df98b65203679e483b0c554fc6d993c2c26e174311a5ebe45da72f8a00c3944e63b4e7144f0e4eb6418af1df1c604277827c2e1b71530af5cc1a487cab747ea032ed30ec7390b6b758a60d7168cd737e32226e1510efc687a17c604a53b13033007f00a23050f12a32178e35826080e36bd0b74e4cfbac5e7f5cebb004a0fc6cd7642d1f8e6032d30a0985a42c4a4b92dd53a0b4a3809224dfa25e705b480718ed608d535fa26e5ee50f42ef944774542dd10b7c08a27b15f18dd36bc28660495aa0298ebb9f6ae34ad7cf78d8a7126271b271c66d1af081759c87db0e318a1d6f02c620f398d83511a46eeb955613357f46c6c9af128118c53367d7414dfc1dc8997e83a744b499131961fcc55b5d16d717fef70b7fec1f4a2077cdc80464e67f5e4ba71931041b9045d46ffba92e784be521be611b343aebe5bc4e866cb7c6a7009013265200301870848102444a963d055c05cf6b4c5810d7a0b89aea18d03167578027042bac573b5ff950850715edca2f4234b1be17704995c287b748dd0483cc0ad5c0fbbb5366a94446fb8a2dc7408a8937e93161fafa82d010a98d7f5f5274c48d20cdfa9a6ded6bb95f29f7391fa434eec3b0f69b25a5c9e91766adc8b884a330ca1409c8772bcc86da27012dd74f65a65caa8e01caa30cbf01378f75cb2e743c5265011040a6ae31557480df3b03446996f647d35c03c9b082c1db86291f2822774ef7dee44aa034b185a1ad26b001e33403734db654b003fb6f9acb049458fc6a47fae7453be60ab74f781c92045bc89bba2de93bf604e2a84822d5966006a99ba35ee5022773460d54dbeb758684461161e360c4af3c4dbe0a73a9dce9a92a4a73fee92d7eb6b671daa818ad01fd0013bedcc8c2633733ece7dd709a1b0bac57fdebf9d3fe83faf71df45b96411f879da23db9339fa506c3692274e027e004f4d6628f65548b9d49c933fcbedd3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
