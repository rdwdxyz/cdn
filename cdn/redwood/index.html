<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcdb5c76ee5cd21b9cf9111283975cebd57d0697d45d57c1e8e563444778fe7b1a0f4fe1e167fae80dd90f6035ef822a273695381942f4feace1c09403dd956956318fecd129e40e94029d42b8c27bf327fbb5b17d84cf7d2d2c77e08ec5d7220feff3b8a0c95b02739a4b0ff3b9383976166ffac84f4bbbdf39129cb0bd7685ecff5a00014eed8d02062f1da19056757962c7221a9be9336cd8829e14f93d2b8f832d9cef89d762c8d010d122571a76dc8a5e5b4bd726a182540dac63c0d6b33a44eb45303e71773051c4ea5e9ae5ba194ced91b6a195ce972c47f36c33faead3d8d5026d60e5f7db22c80188c0599628451f00172c434a1c5de768a6678dc5bc53323f3bb289fca1195d8c87ac6608207058ffed518ecc658bc65c00c182f01ecad446112f339b87f9ee09304f7a51765b692e5b53ddb7604bb56f1847918ccf9d8d011622092ed89414585e01ae3bb007f29bfea70f1c53d7dc66cf05ff0d02118fb6cdff0b9954156fe18a7eb12c9215247aff3184c4eb95cc48e169a280faacc94d586b88d3755c4009209ebe920bce9f02b9d1a8773078ce18cf15c744e122ffd77d43ef75621186388b87c1d69c696f76f5f5675f45864bcde0711f900359d6e7022446e7ee6b1b12c8fd9f52a0f82f4b2e900df6c9a74f0f5c741546a1243f0daa104dd59c59762748f8b28a40522a9131fc6bcc1e5421fad84314e48459ced8491ea0327972c67e7feee6846fc7111aa23f39cbaf1e7df61146d3487dffc9b5d324d162aa3838a372987fa8caf060f4e1f6bd7d2352d74f9836112a22f6f292f143ad5c6c034177c792c3b656452db67e399d7cb11491829d0085736dce91cd08c976c1fe5bc84167125e239d751c3bb1e4958b7699b7a8c2a37b70cb39e33a489d06c77f02c81986cb00c8e11454550dc766e817e3d42cf98230dd4a2991eed7b3f118e1d2b89bffce32a86bb524286a4fabd236f0916f3b526a46522f0b6b185076a21ef244c6b30a7b2702b352052f47de011a49ee74f7117be97e734a9b59bb186be7d94c3d9dbdcb6ce346956a3aa997ddca2c4216bfeb38e1fd5c05196f0c7fc7966c0bf0ad873d8403e11d128b8dedc42695d6093a918996cd210107817ded75be98427fd64f5b3ed35c573d6c6d2823efa0fb1ca1ca1a34f159653f7ddb02d37ad2188d7dbac7cd0a8f983cb0c3f41f45eca54c3c2d1ca46b32f84b8b120cd6e0f52ebcd1e12340bb57202cadfdb5c581f6d587a900edeedaceabe501f7d71db02b2cec07388530898a6b21a3b459153469dd408874c1a8644313a513760718e6dc43ca3c6e608691f6bb1b506d00278da7ffc22d9b355c0d575e92c4019027b0fe7a2d5f10698150626c8e467d766444acae43910ca0954d8487342a78988ccbbd0eed0384e8608f4680c0eb6170304a227cae4656d182baabdc14edfda65cb8454e0a9497e05d432e0bcdfbb651b4503a3c44248758d411fb87b7ca1e8a22c57425d6d42758709054403b589553388e5a4e38ff19fa94277951aad99cc996425f56718c8e03742f7c9bbf7ff6340879c652f5cfb3d8d01ddfb39e68cb56b69d0facb8b4985a211574d9196bac1393a2e7ce8b055848d1f12eee16be4702c83aa97f59590b71e36514d707e17e77eb0eedd67350c5ad47db48f8e169edd21a7fa10e071284978db57590cb86b754b7e081bd364655e69c1e2f0269631edabd8b5bfa583043bc26a6649ad7048c7145c731526b682eea01844935b1caa2bd869d99abdfdb99ec5df65413a1cc0b5bed4993de2abb78b6343dd5fd853525742acbf1bb17fc609ab86c174d43f78dfe438b1aca41059b17ac2e8da7c4db0dff68f479ba1faab625d3b94e1f7d17d3d2f09a8e62146d439efe6decd6f700df386517a9b6986c2ab12a06b66e58475a172e6d40b9d05880a14a8fce6da3b199514a5b5274183461afc20f94f399a9757c473f044953e879af10dead6b17810c508f562425461ccc46eff62bed7b0b67281285e09843a7dd18969b18b919176838d9b36ef9af09f1a1db057f8ed7b2a525ec169cd74d97de2f0d4cdc995769e7e47b6b555de292131127f3ccd15d6d808c9624fd7a243fb020875905924d23da24b4830246972c3473deeb8809ddfd06a8d2049c1379a2ad31c10a7b8c45234f6f446b3a58cf128e52794282efd86e7d6910c40a47bc0548a74726fd75c7d020271b68e5d740fa5c9c3c606e95a762eeeca6ae899580b1b7118c0d0dbd5d0cd55a1f9d1f637c22cde00ec2567ddb8817c60d7dd0f3ed02f418d9e40b7cbee5dfbfc721f3e15b2c8a333f64fea7f8a12c3f7d3da1c9553769c3cbf185d2e297eff033a3b8dcc9e3539bb656b4aec50b61211e234a1edbd7ddca2e17bc53769b0074561f51061577f2f274adeeab748b3d755681ff728cc5f299ecf492a156dbb9da425e3d8d0aa45f8a0a9ea4c5608c7d282005e487b932f0973dce34401d61f17796ba380fb4ba4a09d2416283e5e3c2b534bb22f9715cef0799177beb2d972a618beedfca1a4211588b67a45cf891426182118294cf758cdc7047ad7d536fdb1007f6acd2109732ab3db6e5ae417c1bc3c6970af18eac5f4bf2832040b3ad7219b4a9ff7c6d7253ed3b66517f678792d036a65cb9f4250aeb394d838a4a1a62f10182908ab81e92b9dcc2888c8e661e419930b06697ef50b0eeda0866a8c9ff3462a35da60055c8a48b8d3da2b06dd121bbd1b8c9701d67d13e9d78c51942cdd44a18db980d4bded79161867a369fe1852d239744c760cd2ba6f40a77409208612022c3729a2b6ddad499b1f024dd5e9e6b53f722638083919687dbcd96d0c52b8ee39d0796d449c6f171d7db4d44178c2cf75c79734c9b006bc7c0e99af01179b6b499b80f0a7224e2b3518ff42bbd5626d76af946fca0fc2fed5e7ea4cadb3104432509da91520f4f1715af92eb3153ccc5eed6d00a4da0f8fb05596e1fb4fb9f5859116fc914fc5cc77169b982cbf3c8243858436b167b27bf21b24a658b3a6d2450af3ace9e1d1ee7221312d87dbfcc156a78be311fcef6c507e3b7720e586795b3b9bb4d8ff42b59f98d8331ea9eeb58b48a0c97efc4ce2de4a68302c99b47a111b082d786ae3934a3dcaf82714960e5ba94aed53c62b5184e23268d7310e3b1e1a3d8380369b5df4981f5cd487190243b57d3c99e87e3a9b614b66ff4f1b8cca29c096bc1c76fbfbbac4b8dc5d8cc3cf5b0f8267e538c13169d90c5a0d0510c5d6b6974c7e4a97599de281c14e25c4bb0cdc2c7fef34a66cd51393aa4849cf60aa9d4a8562815c0be0aa7b119fd0308cf9c3f7c14ece0a8fb53ef713c2c1d183200c4a860a740bfd464ce62ed3cf01fbdc4e6f1f8a4534061272fdeec6dc3bb269d623b143e3200f623ca721774cad9e7667cb8c06cf37914814ef2ac91d359fcabef257e4ec07f058f2528da54101ce07a38801d6ea5aef4403622c05f44519cee070ef2ee84b5592917f11f179a36054781548f23430e9f7fa9ffec8c2209fadfda34df2245344887f1577de87caab5d39c30c95cb42dace211064f2a04163cb5831a7a5fc78214f337c5bec40fda85f7cb64b448ad82d14064def56d0bc8e5b875b6ac3c2636e7814053b519e8185995f1954084d4eaee41d0ef47afe1b50bfc0df7efe81476031ff3ac51524e274ac9de884d4f54d7c909e091ae56a2f9effa6cca883a25798fd664d534a2d386f9f244e0d98b18c27ceed9d7e2e04ddb65a2a21e50967d3bf9b48a75cf45f35e98547536ed43b2a2403ad0f5816c02fc33fb15cdfe6c394650685b69ad21e133256e69d99fb66a936ca0bec336ca6f39a0a594af07f9af238da205b8e155f75a25c1b758621623310a136f223f7b4a0a0760719625eb7707e3a35c294b1d5c7ed0956062044dd924760899de16de49224e20f4c6e6b4a4e7b6e2c2352783f93589bc7d984a56ef83fc5ff89f40abe0f2fa11db626af11e6b7371e5e96545916651b02842e0786843dbca0c22fe0de9ee1f4c87b4bff73ca2e0f33fdcbf4d4b117f87d53d193b1e412e8d1bfae7e2fe9e0f12a9326e8b244b910c4ebc74fa94e0df74f481728e1e1b929b8c58b8f5d09999bd85b167fa398338f591541cc61953bf10d717aa8ae08cadf5bc6ee0dd3ba20a0c57f178fc035dac38a3d0b820909de6194385691379a7ba6df9eef4c8f42513ddb15981a9c3502198810944f58f64a25de65538eb6e80c72198f89791543ab6088e753feebe8f0ad4a0e187ecfcc951e6dafd06396e749ac2ac74536c0a2eb56fb9470602a3dd4e9e61a50a329e87699f5666d133e3ed7843a62d48b18a66848455a56a498d111253f43d724e4dfb50a1c5a43c0cd31c22722d3abf8c5a733bfd8b8c7e1f7fcb0b5f7c6e3b41c9af9b2b3741a0a9799b8d608220da8895b422bbf1d00fdd3a85ebe697dffe67233e9ba1f544a4ee6962c3852cc2d07f82c4e26794828f3e0d2f00bc8583921582c9fd9c79268939778574566b97904ac963f31726217602df86ab13d25bcfe1a6bfd207012e0f182c66b47d54e5fb6d9bbc549dcc0e3b7f0b853d60ae61d3917287b3cb9c5244642296df47a2f743465bc8835911faa0078a05efce35fb7ba3629fac1dc5d9b24e90d918eb189a57412c95f7c2651f1b9ec47ef43927615d036478b0bc5ff9a9db6c99caea9c5a2d12e40a35ab344ff89aeaaf2fa4ee0513b9bc0cb98773fc72091ca8afd282da97d256ad12c1b1b8682c28ea1094d4947384bf38dcf8da8e733eca7f7f160bb3fc1e5db5d230f3735d0d0ee26f9f176538ea51763054515e940f7fc6cfc33572209f6b3dcfa8de3c553765b4a4df865d51f3d7b1e70d285174ee56e371bd296183e94a2aec9e8c80b3a7009dd2459d1e3abb77df9e9c6b8296e4606433457ea86124a496ee4421635b81f21a9a21d9de905d250f0076578085e53c634a30faec9c7806cfa5f3ace3f22b69d5544352682ed041771b712e7920f6e05bc25574613e8cb2c928c33ef4d0c673437236f78b6d4bf4b4aba1350e71ad3dbc0d53eb8ffd00cffc9e053043a049acf4f603f24c94d3a3a7751c54365d7d360f4857fead26c4bdb3911c7ac83c7bc774ef5bc8f836ccbe92956a8353936cb8f16ce2114cae3aa4ce71d2c20e48bcdf9baaa4bc0e3ba442d69c7d291f62e74307ebf5beeec563171b9fd5512af8a38cf2d54eebea0739f4680b344d67e1da48003816ed35800e96458d59f0a2af897e02d5fda95684a560520622f23baeea7ec2015b96e2e2bc618bf0cfde6055b8536a20caf09ce1e174709f04a8eb9754622ca07549dbec5e5464afc236e745b343b9f7cd23cbd27f472e520d2d39a5a82e3a511f8f56aa574d842b11d67d3d3152a5070cb7d634f364302586b2d99e1aa580e91f71a5daaeb745639ded5f7dec30854a1f7d91ce185a14679a39e048cc41c64d894a2c2cf65528833d58425e8838cd4f02214fbd199aee215eb9de9661b5d56b0392d20c7e58564132e3f5f362e19df3692c75000221d3b0811fff968a911469a7cf9fc4a0e2c91099f4ba1778dca3b83279801862e541a9cd58812805c4425a83f9a1dab7792c8fc4c878b465b817bec274b6b5fcf7516ef0d8f5370ff6816894ae0e01f68665c658ad9681f597fd688e0b3be0d3d20080e0b967bdfadd51769966da02eb6705f2a60469e231afe981af7fe7f3a276260c9d5f2caf1d9141423f6a0f71a36063b05bf1617813ffd515f1ca560d0390132618cadde8243da7ae0c9721d74a184a0ba58ea051d643706eb7dba335a364e1a3a70c611b9c9a2ce1996a51d298929d08a978c8254edd753044512853a8334d18106c92de70d7089bceea597d9757ad23b213fc8ddf8476ca018d01e5352e2b538fc13e2d00ed936073c8e25736096dc50398d1054ef6319fe32a6fb64daf8466384d26332a0d1c69d2f71d91cb9b14bf250ec8d17152418bac120a6d8f6a0750de6ba26df43462889a1795f870fa9bf4bbe94840f028c76378f3c089605307490cde7486decc659e10cdfce42852e2aaadf9b9073e4fb3efe15ef28983c3a6a8409376d5dd212b275497bf5b1efcf45b108d725b1c770100e146500609fb36190d24a3c2b30812420a3eb3e0f729cbcfa2f30a48629ed5c3024d4070ea1663f8309d0c81d0f5d2dab6fb06ac07553380b8ff52edf4f27c84f1a5f0263b4661dbb7305cc6680f85ca1341d2a5d8e1f7cab746b47a467cc8729ead637eec82751cf8288badc01d803176c83409541f83b5fbf7c19b598ddee7dbbf2affd026e672812d942e3e93f8aa3fffd40571e2811b1aee7240376171094f3b0e047a8061558582f93679eb52382736f5dd23e737f29223b75ea2fed4b2eaba4c6e4e89e6ac4fff732615b5b068dee2af7565835d8515ed636b1d33aa6ddff52aba1cbadc314555f2681e66591615c0548ac00b50f0d7b871ae13978d56ca694d440dbdc74f29584811faa40b324463b669ccd232aa02dafd8ffcc557ff26ecb61b48f7a423cb7310d79f30258294bafaab91bff2e81ace8d91db725872d5e2ddef4811f7fcd8131acc6c9e2c95a67646bc6c4cedd0a9ecd033d12572ab5a582a3fbe99513819562207fe92a5d9a1a69d08f82d7fb054dfdc95b9d16e8243cfdd44e665cbcbe94492c287ade4fa95041888112b38d12db9ec022ce51a72c885b62c39130ef961cf5645f1dea3d84699116f4d21b890dddbe57078b5f3de323d8097f749f73e380a54e8cdcb465e4319b297b214feac531f6be55b36a3563b55d655cad1ebec2dc8a217b2babcbd3a2daa978c224db38d2dc34791fa04248b86dcc5da672f8ec11ab18143798b9d4695980eb7a731ed8ef1f04b6828043dcf02ae84d7913943d1862128a61b9d899336570bccbe9ab835fac168db1eb23dee77169bd41bbc65051358c0078192d0b301610dbe0e13930957f6f7e2bb12732db26357555899bf4936b091758ac9db4ee6fb37f5e2b1826b3023e3ca8042d1a50699a971a25091748ce5b560670d2554c40242fa471aa06819bfa84d1aa818511b2099536f2bed0b4552ad64457e4e67b3784ae1ed59458ef8eacbf05229ab5dffaddc9e53a63e5c720138c37c36dbfa47c9b82c94f52d4a6699e2e3cff2c624deff59464a829865bb2e803e66f33f0b57fe92715310e7fa15e75a382f5e4cd0485d0050077ea47f4cb9a7cf99d63cf4c99550a4dfc779e44d3dfe8a425c1fd47d1ccd126864485511851c20fc3b704e8990ad2a0c3f3bf0a85137e0696e0678ff8d5a0d4e39a956448f2ff27d75578b527a96571b01ff039fe040e769deb047aea00db1067712b0095ebc05670dc440f6601f7a696a65024a939dce9802ed4075ed5dbf4960dacf6fbe08aa7f68320a14b6977d5a53f534e401fd582d06b8d50bd5a43901f59db32096c68943b4dba3f9a2535e98d4b7f72609477d5b5a5c7eeeea5d4b733c729758e9ea9cfa55fa45d30eba1adec7b5c5f24ba2c05a0808dbdd0279bdf075e376f68e9fc0daf33f9cc4ef38ba77cae2628117706636c592e992ca4b29bb14cf02921daff7bd362a0ae139dd9f77b161f869757ba058f7a6016d4d69a256a34cbd1049f615897504942dd84e82b9ac2a6f0b79f379e45f597ac6327e4d858d7674c515507c4ec999d7ae3866f619a959c52741df45be1038614e1070bbfcfbcd4e382da0f7c4a5cb5eabdd7eae876eadedb86d1dd69defe22320856af1b819f69ca38701cf443abdd81f233daf0b4c9628905e616a35ee4fc57098e15a537323b9550ceb32649cfd7ad5c3f75efbad9a4d6802b6b84b75684fd3235db6c3c48949995b709affe20a4541b2dc00436b380863951aee0ebba737d909e2d187630482ed68f90624b529c016e424d32c6f2f145d8449bf32b954bfd182e1bb476617c4a3daebff41fe77d7b1ebfd1620395c3cf195abbc0a5157f8e4c5020af2bb9e9068960483fe9de063fa225661ba92308f8c0b8403e31d78c27467ac6f9f7fb052eaab00be3c64bc9c8f56664999af7e8a33fa9fea6083501d8122dca72c23d15acfb404e7ba77983e3d75ec226115b607354ef9996a81a0381bd423d362a8be60fe3cef486cb1a1ab4af5ca0cd7d8973899bf8fbe91b58fb24162737323cc7c306e14acb9a8956bbd50a7e1ad2bbf93bde73fdecce1c047f407b549d1ac3d3fef0ae12d711ede1e29534f186fcde256aa7711782c1109071ea96a6367e107d6ffdf6ab169055f82c37ce0aa8e4b775764232bb30c0a32101b18e40533b76c7a3ea9c17171248de51e617fa490878c534921b58c169fc7ab975a4177614fbb2a6b3630399fd99dbd7ce038577290a4b06ccbbd60c200287220236f56dd67f87291c67565d655530ba9e25c4092878ceeb38710f073115fc79c3501443a57b7cb4d1767f25c44035718484b50d274cb305211c6ff014c9cfbf21e0f31b86d0a0907428b968a88c06d2bb6be271b46c64ca36c0c9d08725965e35b23d0705d24e751013cb253fcc7b551be1add7845a56c7c7fb7afea20dd2868626934918ba0295b6dee815370611c6e13dcba170377c90f5692130f66009e20d4bd41a72f1af79289c307cd754cd0f9599ce8fd8738347e310040571bd74057c7e30f825c43655997ccc783a823222b363b14d458c2f1bfb9b2e4afc88caab27026fb4b59142062860de775c12ea3dcc557b84e53a3500d2651a178bbed19671d01cf13872737f5a8a765f2ddd87e6c6a973c66adeddebc195eed17f9f2ddba0501d1b4359a29f4eb9c7b4c9ba74d5b6ee27fabc03cf8568556f20692cc2240789418e4af3eb8cb2dd074d8f496b40b870dc9f095b96541e4c2e48b74e586b03304aa79a0aa82c623510c8252a4bf2947c3d2df484c75986f2b683aa0fdb3730fd3dc581a67ffe208256e7fa8cb76535f30f6eb033ce007ff61bfe60524fc91ce2de6937e1d3da3fb884d737ba43e2406e7193eefa9c739824f1fbc702f493de90501cec024213e8ab299e0bd869d2897223249fc1c7aab7218fa9cbe7b80e0c1a86264a194f0f684b997ab3df706bf3eed2091d976792345632b6bc24516c0c8ec2ff0bbfb3633089018c8ab10bf724cf4003a239e9fece4cf34639fdea7ff99e0d55b8494668cc524c81d1bc84cf1fecdee96d475894f971e3ddfe659b5ef67a46bf452568fea794470ea86c2fdb5acca620bf7eabc953db5b439ea983e52c15d5d6eafe3068d7b490f7fd9cc60b4e2e7fe3118924aa9b354609c298e78d4717d88f840a4c71d766f081552e263978b1db782fda29b19c0056053b06b4a3027f5f96b65ac2b23a9e22a4c70cd3ab05874dbda3b4fc8f3d417292d3298dbe4ff290a15c3e3cb0630decc048532aa0916582d5ced6873738648a38642172d46c80a8b03bc17f59885d4bdc79577af36959acfd71e12674f861e8baab0b82d5d7a6b606c69fecf43108c52769a5dd601e77d369180e87a7c93e74e01b74595cf7a2f09ddb3616bfd1d97c4752407691f20d67f49c6c16a6273576087c13cc41f8d74dd4b448f338da0bf4101d7333c132e754981ca0976b3ec92771530ec019cf0db7bd2ef050b4f087f38fbc69f279c2eaaa8b3e1885125b5c3b2cff1274408204a02630b6e43b6a9e6252f2f3b6d723cff6a75ff68b0fbe231aff85a8ca477e27868a44cc9295b626218092c267abaa91bee23ba74833eafa038a45ca2cc8cdc1d8b79412ab1b018cf7d9c887cf250e293efb531c2d9af7c3e411b8621acdde47d2b7ce88630917fcac1a10b2f96ac79d108a8f47f2b7d11a6c4249eaa8a5078c5ee9c928f7fa624414c87b5294aef2775963d62ede0cc6cfe22d8b41c6aa3c200b6fafc6e1ed4c139b1dfd133a0a13b4c97cb073e749acbb8e27f498940c1572df2563c76722b3b2e296625ad51fdaebb5baade51402998d456fd40edd746ac2cc4a9a358d16802b9dd62ebf8a88a7e355bc0beafe01cc0155ff6138d2c4b05096a0f09ac8c783facafc993da28f98b4c38effb303799d3ba3ac98e68535689882eb2827c628605812ebf4dd4a4842119311af6cf4802a87cc9f1e1989fdde8567d949a87f89425054e7409a7eeccdfa2f63806962d9b63ee01c2ea3abb155ce5c7b20e0a9b7bdc754f1c9ed26588eccabbb9c9a962a496945871cde5066325eaa9726de555e5a775f798ac4e4c6e4296514c1cddf156814f69e3714aa3a04b68cf2171a2d7efc4ac83f428cd65886779113b6ad8cabd66073bb8848113fe7606e889e01ae5de2880bf9e9727b3124574e29528054d831df43b6c71bfc6636174e10407f7047ab80c3963c1fc992e56b9b7e492479458049c9e8d95e7090674bc1c66df74e782663a8f3b5e84e1fdee95bf302163dbc327e39e05e83fcdfc274e0651711dbc2a7fd36a1097a97223e541c3ae33bcd60b517aee00fd249492577083f11701be8772bfc5504773adbcf691d9f948d8234ab3e25a604cac17061301bd2f19b9944e614e0f289947d7fc3dab96a12cd52e4e8b86a43a0e2e690b5ccdfe81eac27592e59a6ba23a76f9991b154f5480505d4e15db7d38a6a3e55728c009c6208726270237958c568ffe7d3b2743cfe3e9450800f3b8f157a3a8c650ff3c52bf5de86f118ea3fb905dcf527acabbe3bf0d1b35527caa1f7f184fe56dea9d5331180a8f7a991cf9ecc1a68e1b364033992d6e55f85f5ef5bf90aedff3970a87d9b9850856d43b6c8a3bc6229f2b043f98fce8a2d7af3cf19d8c9abad45a069dc52ee63ff9766075a8405c413274e93e4fa0b4893acd30f06d75b67aff8742dcde146cdc00640b37a01a7b73cb8bb638bc1b11b8798bd5c1272b1fa62f66d048507d7841b82396b1a7d1300a1d62e6681d9e96b1579edcb27158df732a9fdddd9bc570fe99f7a477220c1f9f4e4bf22491d3d44e57b581385085cd2b187d184bccac26b6702652155f5a22f37ead7959f44deecd0f4f71942ff0f8d56a24c0aa3b3c89b0706497f85d0889cced9c1310aefbdb999ee0d86d90d3624e7c991479f3aee484e63471bc7708712a5cedda3fbf0e15985d5933e4b93b1fcde187b6f5268523215c6d7820233a7c47c2c1f247984f4144151831e912bab14064a3a88594b9a8569dbfca0fe880b64f9ba9cfb27aa684dc852ce143336351edf7a857ac2225856c653f69cc2cbaef0c62d7506d554384da461fe4d42592a5bb98ee99d24dbf6148d817e34f0e9e2a33873771d8e6e81bdc646aa4a6113f69fd6177133ed9dda17a00cfd34b7011487a75fa109c80c039889c652c7216d87a2233c6cc613143ccbf344b1f57249601622ae312f6df42b400af3918d42527977ab6e410b32993a6ad369dafd0aadcef97308cb7e2c7dcd50b3b07590aa27a07e662559c8a58cca360d98ef733a23cde9c6602de4b3285800cd7a33e088e26706e429ed4ffd3f13db93e674f5b6c3f1313f98dc0b4009c6e9dfb9a6d1ccf108a4d2e62f7fd8124b18b6e56d4ccfaed4c61ef65d98dc2ff5d15325fe6259742d3fabf13eba5c59cc7b735f98fd4dd0c09c061c981c366185d46947ea1b3c8507c8d5aad3dc69a2bfd46e4c12460364d69fb5d3f16aa2e944714ab37159fad822ed52fa2774b2684b777702be71d946475ee2965ccafc59bc24701c0a4462b930e71113b5a1f1c8ed68e683573f86661ce0edb4da961715b95343a8c2b32e75070a7f1ae0ac83c67829f91a0b3dd63976be288b62efade06b4bbfb59122cb422dd7d67e506f08e6de0318bb21a591bd04c2b8be95a12e06caf3fe4de76d7258e1607230cb25edcbcbda694a00518886401ecf7628c4a52619225214fd8e1d466c004449ebdf55d1bdf9301d102480e0dfa727ff60437e79bcf1c7797d8a2f35c5c34f0dc2c8d16e7b60aaf84e010c226dd362f943de13655eb97303bce60cdb5967958781c24d81ee87d61e287ea414188ef10e76ffa01fc8b7ece3485abff81090c0429f080738833746deb45fa10736018422a363a7a278524a73a7d70eeef19fd7e1f1c7486a9124f9163cc15423c0139ab396947fbdbe03942e77be145cc7ed1e5052376d5155f39df99b1fdb7dbc298d34d9e6fadae92b61e0323724d51e72ef065b4d20fc6469cbe4800e278d02f602cd45e2cfc34172603cd8820a8429a6fa2d17e95a5248c087fce0c6d3a548f708d4f4add949895ac959ec8ea56139b2f62b6e8228fe064887819e492a748a26a1801cb3ffa38e9744c33993ac4755aac6383da47cf200ec3449ce31f5e5604b435d231357c07811e6525ca98adb08df2c427e91e61aae9dc48f6b15a8e291e8b3c98f2a731567e8249e67c253e7fff57e3f1b81929a3a005e4635650bc752413aa36d472c406b36c99736428dbd1bb231ee7bae6290f0e7a52d30c6d4edd3a86aed943d384ffe7ed28724b1af07e3eda8ca86d37b5d6bf8f0ef4277bb40e8457d900566136da994a4a26ba16aff64515dfa815654aedfc6fa5e0bc570f5c87ce6c2cbf0d841c130373ea4bbe59d25569012387ed2a7a3e2eb005717c72fd961d865b3a73abd90376b3ea5744f9a0c8320f9e0f394ebb61c615d183fa3f3e8bd979df9757a927874993f802e20d156736a5670e6333c6edd24872e058bb49b7c3b698375063ea92810ead3241b0fea0047a5f26aa7da27f3a1c5e170be94d4d2c2491b2ddd5cd9c20d7388400c837652215b46bcdcb35b2418fbb1a722d4b8a2dd52913d9953b72f89f165b43de182b4094bec2b9195d02b0057f6d8135aec56d8962204eeff8c9c35b590b7cf39be635dbbcc769a95600fe6ce7872a8a1882a36e7ce22eed9f7850f83bb0c95f8e9e801174e8449fcb10677c3a527e4bd9b5f53a5c977fd462edec260518b65e87fef2c4aedddcfe620055a8c88b2eb328e8db1a26799c23604253cf31c07a6c297725a5e736dea0d2c26da7f1dfd5816e10e48c8ef559f48109ea09dcd2170f5d87fb59e1eecff66e65fd19144cd51c469f5dd65e924a206c52fb364a21184e488fa69330ac801fb2a400ee9c1b5c9c45c181ccdcff2e0198eceebc9d2fcdbf0ff29e77994f0f27140d32fcc7f0d9f5743412414ca06b070bf877a6efa69ee84ac9edef2fc53f0d12b98ade9502d79cc8022dcc4b046a7c17612d64a5052350fc168f74219d0a415daf63fd826c04236ba6c4bd2ac8006583012618a5bfb30913c99f1bcd72abcc786f008f115dde859846a76feb945ab47d4225351dcc142490285e706774379cf42612792f93a79c097dd54267f52aa6bbb05cefa33f3fad572635a0a44207bf2267510ce3448bbf05c931bef4644a1e7f434724bbaff0b17c71c684663c7b26db0580e5b7eb0fe60ed81cd289ad5d7fec4188e8d5a2a6b8453de997ce440765f2c9da04a5dc9f3cb898102487dd63dbfe2fad3a171a17b86500dfc102ccfbd8e4aa45776a34dc3e9d1db21adb765ab9cd161b2be582921810ab4be24d1e8a41012f50e394e5e7dbd3c92715044a15ece2ce929a14220efce219c4215f95f71ec5bce9533cd0819b6b31059fe77d71da53b42804a50919a2aa1b354b61772a6918971a830e31f1e738a12b5597acf67af35ea7b5f68384c5dda3317205a55f9e3d4b3d8a6bbb8a57dddc4feff9e741a9b1a0dffb43619050ee334e132f3de646fd266b5f513dad123a0e424211295920f692e6e9c20063b664cdbb6f009ac546a2e04daeeb967b8d41bd28ca9a08c54b2ada40c447099aacb41fd0fce6c2c00b9cb8009c0ef7a0eac45d0379aa6cdac3ff44a3035d78b7811817301f419ab85c84628e3b7c5a82dbf4e781165013e993cbc32c37f82455c01714278cabc51a901eaac18b8431b62680ce17c0375fdc03df25aecb3a89c3c2a9d310d64d7f86f48a15a3f0b21d15c1b382dbdf20fb1eb097b3a87bbe994909933a9cb2169827f648207be837bc983b37f7ea53b17650baf2dddde4fe8508fad9888f8c72308dd9422744550edc2fae59a825d85eeb0089ffdc2f0c956d6a91ef0a048db839f6cb823c0a03937316991ecefac9bf23fd7d75248696dec07ff0a556387cee0dfbd6a4ed5895ecdb37f9f412e6e7785a059b8ca00c5b610c6130d72c26f0865f6cf5c34486ceeeafa78896a0c3c4bcaafa77b3d5e3d2a9fb6f238ddba4b3e155a5b50a46c90be9a567d6ac739f75d466e26502c20e2dc5d26879608809a87f4d8a7288635fe114b71b21beb14a387e5faed93889ea7a0802a485017941a42f3213c4bc79ce7bd8c1368441e08f1d87c0cbfbf349eaf12b8f34d5f059ee6bbd221abdea2ba1540f087c851670ba2b3de3e92d28458e76566d7430d4fb011a2aee758fa53f6869e78edf35ede4d5fa5c862e1695f32079fd1235133e28a6b7f10fe20d4194d5e9573adbb72889841168c386800d2418193a30b8b4ee9e7b3e42370bc822509412bc80ef385353162a55428342212519cb20df885aa6baacf6f999761903cf2e367f74abeffc5f7004db77110d72b22e08b6656b4cab2e9e0c2116ccc143d2ec5b42abc4c4968879295a99fa2e4bbb90c671b34250019ca3a87d75a1a95e3aebc69e36d8467ddca4e960be2018cc0140a19fb3632276e0fdc69d398cd8e6e2f085c844a89f45a08e5de04e06cc6906fd40775482b83a4d953d185b6863948d6fdd6ebc57894f445a08a26236761fa2ecee4567537601fc793c0b603dbaa55c185f0a6361539b34136a8cdeb4585f89b2f6dd905a0e3c25008f4ad8e6b484c704be9c8d4dd3bb1bd5e5310c76dccc4d04ca5f39f789a46bfcbb1fb3d6e946780e55a13bf40939af88ea6c7cf0d2d92662981ccd7c91e1672905d89ee33db4a9e6525db387378e81ac81d7b371e39566839e089451f4443a7d95b117943a338899ac6bc0cafdd7f56dcff0476fe676be9f89c0ea3711352af93d72a0d70d00f18852750ce35e7b94cc0fe3f2db659e989869757218386ac8da5bdd3791a9d84670e81c7421bff7019edbd5fdefd2cd23aa2785616362bda006e3c0aae3a301ea9bb53a916fcf3237532e2d3a1080ffb4156c75dfc767","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
