<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a250fba78938bffba07b53637816d2aec796ce11e33fba5bdedbeb90c384c73bcea8c8571ef4d397c46813dfa074357488efaa42473571d6f9d4129d3a089b5961d1081963bc1ab6293f79431036b1efdaf02cc6ccaf805a5d7be44a0a67155cb5453b44d84ff2e8e67b8da02cf6cfc41485e2776a909cf5eb780e7c833a63147cbeec1b0628c596263ae511497226d92fc2426d013d7f9fb1b9cef38286b1e7c798e9f753c340d8956cfe2e04a2f420e330673c9e1e1f558aed939f01b89aa35efe8250d79472e16e0c1e58429a5304f49e4dd9cde212e0836f183c4153893c72870c265204f18c3f95b4449d9706b779406620f4e744df53701b17bb310eb644808dd75a024902e1313186c6129fb9cf9bf38bbb903d45ae90c9e693e7c83b8fa69fd657d3429ab6908b36a98f2e9909c5dc551745694182840079a02d8f44403702905883f08552c9e66cc223792436978af996cf50fc813114963f7c02aea38c5711608967cf049ad1f7c0d5bf253584a3dcf869319c48b18db76181f41bce84305e225055e3170a62c64e5b08878cefc5c67187b4fd29ec34373bdcdabea28b21ebb7fd91b5fdfe1a4d4196a555a5561095d24fa17fb2659fb0dcd11ce35b2af265a879f56c56f6ddae23cd59b6fe6364f1cab1edc283267577f93286263679980d75e80f418adcba412f6ca82a3612fda0bcbb3fb1794944e5518f27bf3478a344d2f7342ff4330ce6b265f8cb8399e75bfe5a36b194cf095619c89dde5a1de37672513ac9774debfc8042aab4c37b9b2fb238187e15f6d1c40c838fd58b27c44fc1f8b502a8dd99fa11ac200c7bb0dde9de182b568c0661d2873cd078e0f9bfe0816f08f71a5efa2b7c64b8ce579a641392203e4c7ca3e422bd0cdf6eb998fa02d60a250ad911b2afdf22f62eef5e9f9aa60163956fdf62eb3c555f832f06d4e8b10a6c901fa658cfc5a4831842ce3db0172c6ad05d4688087d46606b227e7eccb1c71cb902753311690061181f6ba6a61ff8803eacf91fe7d3c9db3aba243c28871ea8db599eed59c0f9f8489744099891d20a953ea35fa12c65bdd54e2d558cd0b1fcbdccfa0343d8d34dbc96390d09c601ada535423179727f9b6552e332351b95ed34d5e75177aff4a64a45bcf284c217fb421746f2d0906ffa3392266c61a9bbfcf9f8f92c3ca315cd680283604a3d8bab133d3bfd3d5efea9288a539a3c878c027401fa426ca1f6d41471d73e64a692839db87256f30bb585449c82af27d36d062c3919b242b40ac8ffcf896ff986c778f55cf8388866bcb67beb7bcc70a85ced708e5df73b382cf22e5814f5aa06b96ebd03e800e56050d1b492e547d211f4358df7cbdc5bb90526d6b5c8dce49ab685087f3ddebf96656c4fafe6df338d9fbb92ce0f2175af81dbe59eaec2d69ac6f13529227fa88022185d4e42c38694f2e8e65106d49a1d1439e0247ca9228048b6d6e4fef63cceae58af8f72daaff3969b8fdaf4a27b7f4ced074bf62e87cf368f7e88e0aff499d7d199a99a6d60d3b289e9b0fca432f36f4a574e212ba2223ab244a2d9b3bc0ac8349b6b3f9fbf9b07240cef2f7947f26b7b2cb6758971a67e98f90ba60cf200cf1365ef2460f95bb498d573d204aae19f8de1bb9845a55708a790d80e19a2a4504e66570fee1b244bb63340b509c3548c09d899af37ae395455f38715a4c50d271e83f3a1038ab50809799f0a2e60922072173de2ccbbec5f5a80e979a85040365e03ffbad7c3f2d1bffd4986270289a96b7339cfc9418f590bb021c96162ab1f9b36f70b938fa6f9d6b159b91088e866a85d84cb8bbaebf459730ebb208b40a847c70fdf1c66bbcd6dfe2381009b62445f1579944773d354d0b030a903d041f25d7005d8083e65985b04d3b9a09c368d7b76104156f25d024cafc6d6d106f81e87bd162de434e31b4dc0edb5ca9448dae604482baf18dea29b5d63608d5dd21fb1b832a21e95d78e1cc0f2c7bba1062c2ddcb2de7e0c2f61a8483b8199ef74477aeb742282e22dff904fc238435ff8f883edb056c03a818773798a490e6822a3a62c3ad36517727ab2ed1bb342122ff746205e98cb25a7ecadd99735a8da823be07b73926c92d8fd92706220fdbb0915222621c312817cff6064206d57e872430b28ac22658fdc7b5de1869b93cdcd9cb27f529de204bc3f88cc60d5498503075b007611391c1cdfcb576183445d8b116e04c8c50ad95c82025c8e9af3fef76b80fbf9950e1dc838e2a9d7632d3997ea918bf3dbe2374bb4d8ffdb73fa135b9e2b9cf23e44e9783d2fdfc4d858541e6247ccc0ee046c7c277179e0db71f113db54755b5f1987e1ec5826b306f7292709f98f318bce5186af08a796a72db6b8f443ef25e4d9aa8657514212e2dc79ecf55b287cd90f97fa07e11bf01f649f8807ef7decf64e0c7ada8a5e328549c726bc958b75bc59fac70678f19dc44534f3520d129fc5c95e7dd09faf7e8f894faefb4c50515c6921ccdf20371915f49dc5705a2efd893110d145ed0fe7c94ae7b94f79432915df61bbb3d7ae859f5689c1595bdbba369c8b2c5db38d366d8f7288a661af23bd479a5cac10326ca4cfd75665c750430270d36bb7f9849f0e8d6da6d99924a00eff4bfcb6dca9459ec0be112854cb21fb6479557c73a5bf4151778295a089f35aac01f4c23fce45ef35db9a91f7343081c12e2dbce3872e585ef7fd658473d6c96562db87effc4175290dfa1f1de46537286bdbba6390c24b599407386523a3cb315adbf4e4b69a0081757438d1433941365a444ce0bcfc97a7f15ffa8c2b491b4582efed8cc786557732b67b7d4424e517f8581bca6fcb333f526174c36b6f3d4a9a88e19a171124c60cae534bb8ab4c7b1d6aeebc94e596993b2c8cd083337745d2a6311087790306c21453eadce9546b8c4c7147a29bb8b24ba656699c65969a5b4e506ebfa087403ebbffa664296f2ba55dd0fedc35059bbd2031ccad66066c306f5d16b25bf4e5f29fb9735d5c16724997bd0e30a8785b8957b63e5b35970c4c59de8cab9b1a1f7d151355022ada93f2355a3c514951039cf8f74930df7b020b1aeabb1b0b1c41c011a030ad9c6ec2cbbf7d485ecc6bac5b491b19d81f10370223c39d9c373e8ead86abdc2b6ce698421460db6bb5b954ba4498218a80a8e667b10db965e465a4079e40a5a298b6f4434d932a238f9da32c890084a40550e21f9272e2af1e4479d6a96cd11b2e7ad1c5f8a8dc00896510d2c16be2532d38267278eab80b5a621292d31b0b074b87cdd099442b3fc5df3b575a65781a72fa0d5ca878759093d084c388cb926061edc72ebfae75466811ac05c01a008da480bf86419cf5fec3112f8073f71456943a5f03e3ce827dc6749941e06be83e41de10e62a2f3bd57467c0e17dce6615927e0149bf5e0d2b0e6b986ad70a518a9b8f05fed04ad3dece174532e3023050a6d9033420a1a983e4c3f8e422b00e7cc3bc186e45a98df389abce66533dcfc9be06fedd6f56040b6a2b3314f0723fd5e592ac14e62aa6e9036cd27611afd0239ca7307afedda137d4524fe9ec2b67deb882ddff99ba5f1c3e9d19b37832042b418036b8b9090b85166285eafac29390135ab3c23c9b818053c2f7ba92cf4624cf33460a3451ffe19a74f6ab3d293418981d21afbb29ca287a7fb66a8740bb00b8afb175c28b46c3bcd539c7d94cd89379176a0d1fe77c04915ba1e4f0274d705061e690ddc07595c5b8c374043b17a321f2a48f0d62d6c55ffc707c304f64ac90d5f49a6c1cd8763d73fc28434cb3123dc05a8615f4d25def1cc127a7b29435ff37b9e729b674165602a6ad9fb29112308526111114a4c2dfd1ad726fdfab9f565e532c39033a27f6da9751ebd9c392c37f1e6abbba93941ca91eedda33e6bae96821626a6104f0a57ae99c118e1af1b6d8b51d794208f85d5281885719ef8ef242db522176a59f39ceba9ccf4e421001b61924a163d2dd4a17cc885955100f6cf006e1d526e359ee3bcbbc0fbc05035d9c3fc53cec11b7c8c3af826a9025fb89a817705731dec2b8bf72ab1f176e5b2643ca7f3f87a17c18f577b5aeb4e7d04e7c4045860dd939bbf6f7af3449e7b1f7ae92833b774d81ceacb1c4f8fab985d9c4f90ccbecacfef79965e408ca636f4b587f162f03bf1a7af7b24a713d46dcc3bbcd8d5fbcbf369a7f3d0f2c50588482c331f77538f61ef6d0f1e4f113cec24385e1364aaf7a7502f706fa196bb8c09ab0742cfdfc00f9889b50bb8ed0eba2b27f20b3722a3ac3e8ccefa998626970cdec1e335876f90d714d543be0171dca60cd53bf1a9fb0f160ea158766efc6492070072206b4d843ced6228c37b3e1da32a961268eb8cba4fa3a5b9f18e390a0f3b84f717538567dd212220c071806f8219b22db6b4ca3e98a7dd48aed8720dd907148130f6f15d8e784aab1114ef4e10b7e6ca7d760c9ac51208b180f330551980170c9db1d656ef47a404e662949adc4a5e08737ce00fd819628d6ac39d185233c73b5917d9e3b8106a728d2584e888c657179078e27305851fe4a24c615c40dbe6bae4e9bb8ca67d171b2d613e08c6c62336c038c790243fe510e6db98a375ecf2bd3d282ef2d79f054694ebc9f1d279aeaf9c8db5a1621fd2f04cdee678463ef8d760bd61d4ab462f967799ba37e2c97460d81bb8e02a426730ef7d4b622cbad30fe31037a731b4259e692fb6ab8db93f186edf81c2db341ff40024c9ffcbbfb3f1aaaa6301f8bb3f20c3ac00d62baef6e165e55e2e03045f420302f056cb4c53b7e0147aa6cf28d8484d29f4c7fe89e668bd3be48965d569f21c28065fe9a29fac3a292f4724d195efac47c88bbd5189bc5bbb331f421146fa57bb65d4f636a9ddf28c94c5d1bfeb3c61df7fc386eece8cce706d07891efa6d627210aa48700a08292eace0879efe3baf218addbb55d31a5f4ff3d6b62d645e2003d52481f9b659c08f1794275ea416f9d0d2b3d69936bdaf817eb61aaac59c9b9daa79fbb8995bfb7c4f075b3eecbab9471e15cf7f6dff25383fcade1bb458da6d6afd8aa952d0a1f47cd7604e19b7cc30cd365cce1f9aeebee67d39359979f1b58c96bb6230dcc0786f3d5505278accdcfa90781a8d03fa0c74ebe92d4a35eb0dc5ab0c992c5642d9adbeb4097299deab9778058b606a049f3bcbfc81c0aa2ecaa926fc3ddbfbc3ce32c6dd1becfb9d52eb55c1ffc27a098fd90a1ca1af7d2ba322275cb19f7fc900b5c232750c79cc184a449432222ac89fee4a40bcdb05f2fb97b15c7f7b1a607d501f8023eec8e9c2098b6a09ab8b6e2d8c9c539dbf36ff8fd5d7c27ba4b04c2168bef6217ccb5c91653bacd234a6741dd313bb7dc45aaba16c0c3adc9dbe655e977550e882404ad386a6fd33c2b885c14c323f45184771c66d1a140788d1a7721e002a04d1edf322fdf56ae37f4bd661be6e114c7ac8d7870137e5ffef337acc9b41a6157affbc15bec65c6a8326d04b871c0a5fed8b0827fee3bdeb55d24cdc663f80efcdd42103298cc1925bcc9df848ebebe529841484823aef3887e22b42fc9ec67117b7fcd32435c3fecb2f220cbe83336848e505ebbc6c2610a76d99157bdc03fe860bf21f0ee0f3406986408aad0211ada874927edd6254be16e52e8665785d2e7ba4f390aaded0d0cf00838809229f9644565fc0d8abb86af13cf856248b3906a83b04395a0022378b8c4642e4c4cce4d0a131a0eab3243dd298608d87534152a21c371008a46899ee12de12ddef0b8397d6886f4e8e09c623afa1a3dc926b95f851c96900978c9eb245b1a5e786715458f18bb36bfd3ae78841d3c260fb821c9251a235d995c8fe86c89dff8d66c952eb956a7898be3d118cf8bfc172ff0aed2447aebc398f98f1cb80d2ecc658d8609cc909271ab06893525dd2ade5fb9b961d9f04543114a87b01bb4074a3aa867b77a5c3f4f2af9aef6d6740e971b0a3492ed0b04320967f4f1bba8b8811eb0114a7efc6d39ea81a2f185fbd62e3a6ccd82cab81ebc2a57c2c44131457c71bdd2c3bb9f41beec167cf5f466a4a2cceb093d3357c16d7f007a9c0018848a8d85a27366c1eadcee6bbc95802bcae6d1d92d2a88d4ad657ed49364bd64865a924900d37bb18c4eeb237f52b4b897368f796cc2a3456dff466ade0a8ba8d6e613aa01b6072f63fe00df82bae6d861720932d4763efb0307899d3ed7fc6688e20d94fa1f36994dd5a8c2699289c7982fb271f2cf610256ad9718ac5e28783d47e8df77de16dadb67ee377af34fb052393186f7824efce7664299095f1355d3c9c872b879f8bf53c57179bd27dbefe7072537c65ada6c5632a8ef22dc90a9609d9a7ac1db7e32678d507dc73dbd47257c02203ac49210061e62c19d3efb6ec3dac2004f816f87086b73c8e124fb44d171a555520e6ec54625c312900c7703ba9971a57f68dbe4a5dbbb1693d581381b800c27fd6285c69a8a1ee8492b89a5af2662220475f8dd7a876af2edd6a4b71d313346be99c2c8d7375dc3b349cb840b318c733ae707c6cb6cb8b3dfc2b33498950241d64ff482c73d286f42633a34934e274a2ea00f960b39e0ca4e43f6345e45122301ce5ed2ecb5e5050d8899f128196f8f2aae7cb8c11739efd48572dd2df31209c3110eb19154681db20a1536e6b90aa39bfe3d8190ecd4d07a13d8f9c8deb9aea29ea28fc3d37efa2b2fc60b7c79e0a5a836cff4ae3063916b80402287b95cf44d3c35a4ded2b9319082dae4faf7d5acf8ab75abe06fff415c41093e19c7691388528c07ca54e4ae1a57ceb9a28e82300c1e4e7b229d73c30a2bf666938df0368c25ce9dc3153d98b707e4564927851f8fda0156de51342c82b285ab366d3207eeff5b522f97fc5be02907992c1287f1e6424c89be75226220accbcdf633bf07fbb5f6fe25a8499dff429f1362ec82ee46833972a7ee6c50cfeda298afdfe998153ea65159f92153a6122334d8559114873ee0c8c733970d1ab322873d010ce988d2edab330ae63d991bd8bd01cf493d2416e6885bd9abe92fd53baf7de056412930a8b3646538c9f8d472545b8821d9eb26a6c010fa13e35b2cd50799351918e8d5a7573871656d0d395cc5ec6e2664fa17aa5681084da1abe849422e6b4e3cee9098aadd0beeafb6d7ce3302e913390290b5ceaadd59fcd2d14bc7459af91cd878e67f312053ae5ebbf4dd6f7808f2ab503dd48ab5938db390a51d219fc70146c762812e0d3e8d04ed224614675b7ea06deece688af6a584b8be40e2c6cb2e429a436d8b1806bb2b7243e664a7536bb4f8a8c723b8cc488006d2e752e1c18cf6a99c80d389175cd49a75e0cf6ba2fd0df3fb6fcf6ffaae1b300a8ac9a46362e80129d1a9f6252aca06408415bad751b8705be8e25e71d7761a21c30868f69d300fd477842757c8138e410f5ed2078052e1c9fc9d016fa362e78b842cb5c96c1158a03daf2ba3516209f94067c24d1fe57a4488826bb74f760bcab60ab11db32fa34d3f0ff58ce220207bb09b3d956b4fc1b7826371380b08e60fa1516b0ccbbc9c487e091400d83321b05da9cb8b5f13a97568cef38e06fcbae05130783a21e17e33ed6f3a91591c50d3775ba8fcc7f53a77205b687a89498d70a67805c535d731b165f0ef4a8e6e54c60269efe862af2f0f8dcbe7f856dcc48fa267ee7076edfe01cb8c598ef9279a14648b45aa17d88da7ffe8a2623c4c5c7f9bb4765a7fbe3cb49b8a9ecae5ae5759dd2de382a30ceddbc1f5a54ccbbe5322338e4742cbc95197ec45f9a05513bcc6719cd6f07c98a03fae85ab837bb3042650917148cb88128c2ae1c7d26d1b1891e9130886ce05f99682f4f45636f8475f464e3361f9ef9ef9cd3e8c3279bc2d910b2667f1d934da103fbf5bbefd443ce42b9f3ae7457a681d68b174022f59c0b2506e75fe95d4c1b5435ec55853f1f012963d2af5ba47183458d5d068fcadf291940032d1dd0d14497ae30910cd42646d3006a804227e5602e814d115dc456044cac1937e8a103a09fe27b9b8c82d0840c16baf5d22b77a74c24b092bea3fed83ce4a6a7cc1815aa0fca3bd77e48b36bdc2d4ec046ae2c26f365c3627f1d4cd446b47f6310c52757a4abf9a917151ed34cdb7611c9df1f066d029237ae1838f296ee1d4ad94939631349d9e17a27053f09d1cd8557ccd8ad8eb426bc95af5fba5f801319ba0ec970bd34f41d581bef5a6ae509248c76a799bdbb77f2c01249b70c75dccf1d5980edccea4895e65b3909d55d6d2ffffb4fdd454926d10582b511bfa7879f9140a9b31b62efa77e53ea5cf764c23e71ebcafa1e10b494b7ca3567ad9ee28eaeac9b933bf3ede005c55ccb2b10a400145114433e382f9c1fe8ca13480936c09a53fa95f44197ecfaa1e80c4593adecabfdd8b490d2482abf7c6f28a360f987791315b9bb4c68202b1d7413e47b362be06681df79462b235cfe34d3f081863a1f800e4d58c0fdebd0adf37c3ecfc3da07d323150f6f228ebca4198e1dae6c71568f40c20bb191ca116e5edfbccf646cafb6c5a57e0b301827de30e8e33190d46d66033fd141f722e40cbf5987b4d1c8dd607f664910a9ddae7afaa2e39eb33f7dd7aa44b07bfa861018dd245e6a304ed765ed45ede7ba6c4372045406d2cb9a1495d97dc7146aaffa3031a745936142ae6120a5e85a133ea1e8757bdda41498b8d930904350a92215d5ffbf9e3cb277e3469df47516e52ebe85c3480d5bf763b0ffcb0afc8f1b0ee7c0d00c5691f3d328b1647238a7b71177a5f7d1347a747ed4825ccadadbd527d70540c22261015a9c4e1bb7ec1af55b1b794d2253b0a45de57e0c17561cbaefa744c2256c2e721994eea2a12f439fe139f48f87781bec275af2008c7053f6f04cda592103399a85402a6d2b940b849d5b69541a34d7f42463027118e6bbeaaad9456d27bc55b94dc4df7e74617543a1c028143d54b790c9105371f5ecfa810f8acc44bf2abb12b5355fbeb66cf6391825cf224d24ead1e034f2466213c33856a8ef931ed524fbc24b9f1f3fb8e236e5f5b21c1d5435e5ad54f89dd5554865164a0fad4a453229f013c91be39d26e3484deb09314cc4839fdc7d99abfb66ed004f4f35c4d4f6ce590d4604c0d1a43e0f3464a424663783a908bcb3c3c001dcc83818f93d343d3878613cdff45f27c8b7a8d18bfc8e469124b5a1c23f0aefce9c45a0d67f244dd2f62554a6d3e304a6da7222052fa21596b06c7541fea072f41f9d050e2d97e61e78dc43dbbebb52dd8b901e9e9a5b79d15f1551548c5bfce9591bf86989e002f9d47d398f8388eee2a45acbda0d6958c93419d7fc0a3610ee17ac8e1b3f6e3a7fe92059226893ccee99d16a89a083692c8f07600748c2091c9d20ab290ef8d2b436adf7ce859d3b97acdb67e162f34828abc04882daab89a1892ad866f583e1ebc34d23f2aa848a8a73bd11cbaaf7dad80ef0622c536f0a3e985e9956b8407555e4aacb513ae05a5fbb9e971c76ec958ac64c77d22304506726e97c0457039897e9576f12597c8a477663607ad4ff66e008623f8e52ffc2f1b1eb473fb8e518f56dd3f55d70f98b2068fd9e5511b452cff1d6401b1177ceed44c0535b4ebf803ac8b4e26f0cfa04ea5556bd94624a77136b670025824c1427fe34bf570817c08557315bdf9dcd829d9150fbe9b487447fb6955f01e13d0d355977971db2e31999a5303dde7a79e8a2ad12237bdcbb0fc1b2da1463dc3388c209e27efe93a589a064ef9897faa8b62f1f9c939ec1c49b29a91518442887b386397650d6342f93520d6204514ad10d2527a2add33ced03a89f70ec37aa4b98e3b21dd48ecf11c6dea035a3cb87d3cd5eca2241c50e86707f65aee13e96cec37c41e6d06b0d4c514549a00a47444de6320a96f042125ef9510690909f8d637f851a7a089f9fd22e95b7fa9194280dda8fa3207765d3995a2bcfc3dbdba5491436e1a47db1a083957b98ec3cb9771bc951cbe6a6e6461412cf0ca68d6df29ff080d174f26122f3cb6a9b904fb4062af18d15af42913188db20d3d4fccab0f20617cbf261cb5f17b73bfb36973f3db47e877095fff61581c8c61ea3e5c65cb693807276b203ecd9fc3a23f2f5ed0306c8cb251d50969391e717c25201bc2f4e956b831192751079fa3619085571dda4189a4f7b70daf05b32f9adbb6907ca42df97f3d62990e128cc4a2532702869c3165e33fd556412ecf6cf6d54d3d3244152c6959903f381a21573829a9e8d5738ad3fab28a2119a46473382dcc57509aeb45e753911520b54a4d6b0be9b78e811ebb85525aa8ee9e1386ee416ff9aabc045aa14e187b69df0fd6089bf6fae46c4430580ea9c0aa377628d3e0bd171f36eb552bd8a5f82b6c456bc6d58fc393a6e5f16e085cfb945460966307171fb5491a5f4b87ed03054cd365422a4eab8a73d981a03dc7cc665b26676e08f3765f16310acebc7d8f298aa258da15aeee0f5638dfec79887ef4a7f284fca30677da62d52999d782cb96ae0dbf789744b3fe3783b82e74a36f0f636c03ae8482daa9c9f350dd738f414197275fa7cce5a6d683599b22f4af951182a20293ba5f721037cb63150e6bc9eaccf7021eb54b1a17c174725df6746d746bb5a8a06f0e365b3e8a45de05bb42902685db28e009b6fe7012d856a18a256a7730d56f13f58a6aed632914ddde0749837909dc5b9d8ca5a974659a682a3746d9a70bef8deb66261bf973dc3b438af7eace7d7e09083369c2e610f3c89394d47f7ed87121e637c28537e373daeefae4d60b7a3f89d9ac67309cec606c9704ba026dd11f2fb552c48fea1a057f24aaebe6ccffc027476c487ff83d3176b03ba718cbfe4d567ad95e5948d0de316b80437aeb57aba2f487f264f946b786d62d516c358467639712cdfa7e5bd83ab7b190e7bf4d3af2810468072556512a73f0150ef7b7af07e55c58655edf7c1c17acc215efec34d095ffa30da7f6a299a5ad8e84f71fefe4d0b2a15d41099ab535a4df5b5e4f5556e55a79d20db465943cef77d9fa7154bd30f5f4722bd387d9b83f57d92b875a64663ece9e7382e4036517ce52e39ba03ffe3caf50a06b1d44350c11ed6560d24f02cca687b3b016684683e99a9a165f09ffc352f757ea54288966339183c5cd14f382ebc2b2d86ef273099c52786929a446df0dcb8ad0785adf6c963fd25aaa120050d0508ce8382115c4c147370b038405883021c19979ca12babede17453ea3cbc4b092864e25782e735d734f0a609c827133b3c0d61f5926ca8bdfca3bab06a1ea13073bac84e8f1a21c70e63ec0b8c87481f052e8cff3789536c56b8310e310258ac22a22c705a98261197baad2fb03ee233ec8452e7a6a2948490cc35dacdb8d5a493ac1986abb5bab2dea692e7299b6f85fc3502c83956947b32a0d29b3f938659c8cae393698ec43cefe3da49c14d020516f4d906ea127321c98fc336b5ef154e07e319a2544490255741cbd6a519d6359082f696ed3089aa85cd69f71b1215ff4edf87faba86456e4dcc21f2e68fe40465fec4a06f575fe1ae85af2e04de04d5011397a781b0384c6583c47f57fd31ec0e9a3d69446d172367b94a88b0787abdafe52ae401500c97f8247ac9d0cca0002a615bbaf502bce588edcf6d7ebffb7e2581b228ecae5b99b5fc72ba0bc138e42c375fdfce3d091eaeb477551a2ec29d3e8c27e4211fe285fecf45a24139aaf8b945e2fec8b96e734475f18cc666bfe7b3eb7ff0a712d22cfa9f82f92295ccc281e330e29d1d52c5537f3cba6eac133cb9021a38c85ef9f449b4d8660db318d8589623904423bc60f013da8d5b1c0aefb8ad331e738bd5ebb05e56cb6dc2e48c2833142a0a2c6291fdfc423a8c659be29b81c8640bd36114a37c830b91a002dcef31fb126e90f6e37b5b325f61927848fafb9bc5607b0f671359647c80993e04c0dad5a41846d549241c73102244e76d8e3f707e67d74220fa313a0fbfce02040ad3edbfdeed3155e9457139f469005027de6462e30029e6eb50fe58f2c04e4e06714cc9ec1442ba1a24e5b839b7f6c9f31ea7a4f9a574c854f6490ec471939fb241c5eacf5cc1dfe880ca2fcb14400e4d8c781fceb092c1faa78a99751428c7238c1afef65ab9faba1fc5b4e6cb39883eddb909393dd357cace17e1237ac4d77177cc603e7b5ca9a0b02229024e8e209b7802c62094e00d8ee1093d22d49a41ba55e14c073f4cecb1c8d63a4c14420ae3efebd223fd16268b89259df2edac55e391c4965f39cc635d43ef7f5aebdec7f228039bd876beec3523395a749e2b121fe153abd015b76c96e810416f39981ed10838dfcfa5b02dae24c5ef0bc4cca4c13cfd09699b748c2ecb456410f7442f923550a186d02f7ca9332bc2771c69f33d17b590df9811066f5e6e8c763bf5ad144436437be85e1b448b121a28129f2ae7b1313234b0664d4efd280e757166874b27ed9f2ad60871483936177eb69354ba6f201081283d991d2c378e67b3e97f7faf38c35ad21901fe4c62817a54802b0446c0a7dd7e8c7c0e72029a499f2fa799ae3dfb8910f01599303bc74cd43b0882563fc61956bb91262d6e946872db81ae2e729d6604419380031cacd6ac1c94bceeeb37aefbc01090987a2c4b96d3ad8751138e92ba290ca6ef83ec409bba5c1921b9b39ae6b9523e9be259f8bb1ed5a7e12974e482531266b1a9a0af85f26837abafae186b5231f158dc12d7a3f4759ce42c8c756a069ecfe59bff3584a66e674f8a2697c65ce720e2ac91276b4023e34d5e72ed26a1fbecfa62aacdeb08bc9e8b38dc8ffaec664e4a3fd0e2afb29e9b016243c38ffb70b091ebd683f6c9e120e5a294793655da3142905c896c2a14f6832244eb4bdd25c7b3391b05209a3f433c7e9bef2899587ea3f5e5f5721c236f2f05f74a9552d5cdd2c47f28e648477c006656d58fd1a8f9816d6036c90378d4adf9e4d1a299110438d40c995290201e392e0c976294477ef11c050fa853160bcba4c5a8fa67cf5f1ce33154e09b01430bd1c7168d4f84962e13c3e727c4a7219d84b33ccd94ab59b0fc995b9cd830c801b68a9f545393a16194f7417ea983533f1f5bbf44d81743cc0c527ff103720e8d3d3a03be5df4464a0c772516d32fe6c3e4bb9453cf069c83ea7df9b4df4a6f5ec7fa02e89360d755d5715595aec8bf086873fe926a7f07e758496068fa19b0ee9900ce63e4868a0ea6f33751201b951a58104e37b8ee9369a512f23c03f99b5bafc6389ef26920bc9601778d424d14f0bc9130728cdf665958dd0c3e3331476ac6fdc5acc8c28838147e521221036233c208e8fd0a1f287bbb7f7b3fcf844d0f1457128bd2048908b73d102470cf7b8b8264a460cf2fcd865c260917bf3ae4be1b395abcbf1e04eeeae2c3649c728c11cedae8a6495cbee0c81bc24047c1b8aab8ef96d7b995381fc593bdbadbd932f193f2d9b5751782d05d12d10c8f90354c6c61b134d3bfae1d5d281eef47afcf09ba7b86ce79897dc1b912e769816aca940743a43225ebcab12ade73017d3f658638e76fe624913d7aa8258a24f20914779525eed61f0b527558d694ee2f4e56357b4ea149cce59d7a3080ba98a01916e7676e560ba9fa95cf6961435e8c64992749abf5b870a0844fff4deada5345fdb7ba031a3606251ff87986075c9d90890fa21c29bee2f254e5a4cf19ecbaaafb24349ac46d32c0d1d59504673f6e062f267fbd7fbbb955d65113d9c9d4cc07c5de81ae11633d811248134a7682a4d35356c456b0c11229a90e570886aae97531d67df050695e621fb6306fa3a1b559395f2c997c369f1dc9588376d511c50470ff8a752fa8172536795f1079c9e38ecfc097812911e574dc66e26c292fc26e91d2b3fff3a2648def48e511605670b0bb483d246a1229bb9e3ce34785107d2422d71f1d5d0287f00025e147a38c119755de1d7dd4473ee4c2105f509040b0f63127db2622924250e18528f076a725b256a7b1f5315114d7464ad975a138b23bc3e201abef4f2cc0c9c19c21f6a8688fbb3b748ae64196ad58fa7c5135dbd4d2d449f22d038efe532091bfb922c7cfc20de91b0f5583bf648a8d8376e4d04fbf4ef17342e513671781097a946af71e39357a2922fb6693dab21c2d8a939f6d44c5da015db249da7d25ef917245395e17c7c6ef89fe0098848506ca07dd1fb929fd68ac6575210bb75e67491fe444cda7c7a15cfd3560ad1c7d4f57ce93942cd40b17e4dfca33ef0883a879468bd4763a55d97ebc51deb5a8236c8ffa19f7f6eebe3462f35b9a5cd537763e404e35bc5b609dbf4beeac3c403f9196f17e58d52a54fe3344f3dce6a02abe6a480d7cd501e55dee8217ec48ac79bfe83c195d65989515dcf1bca40ca05a5701fcf7eca0161c8c0b0e251eb8c3b502d5acdf19c7a67d0c90f529d5b3f2659ce44a0c46424d0f8beb3122344d608c05d62f642e23a5e21d7ceebeec548c4a84058468e25b90846a8f7d67842a5752961e32d114f44581026dc993fbad89d73f7a60c8396c67b2df42d59511e5ff536cb30432170a2e1f6f275bee6c3052139d7e93187c2c43135b3743818ebeb71bcb708ace84b691e92fec93bb4db6c754bc812e39721e06c8bbbe0bc7e1b04a09c674c2990da9b18184ced5b98a1257088c16131b280f53e63862e9d74c70a9e68d6339f025abec5bbb729d2a3329a62ae6643a06f5ddfd03ff59e9063eeb5a538529798643f3ecd63d7e71b5bacb8ef63c507eb6c8325feee344e7fbb835829c27c1f582ecd2be68eb740685ad216509fd6fe4f33b27e3e1eb2763430095c00f0440ce2374b87b905b8bd91ae1674a25b3b2646db7ef826a0f81d0aa38c9865dc09a1ce6c24f66a1667a1c63138c159490b47378c016f41bbf15c3da757940ba77e5895e4798a1cdb0653e6f565e2f96c0285db9d13c92c48b1efd9891a009fb61575228a9317e6e5a17164819e255a73da558b8664866ff2fa70281e84bb4ec1afba0685d5f8d7234c57c2f2f6e9c47627c50d8e15816bfbc4644e591569e428a6f1d5edf378b7804c8b8aacd6c42f7634165593817268fa198539d335da6312e994236f00e5281104d6ff13c4c72d88c3272541da2523268fc5c02262ddf6e5bc1f7b73e66c23f7465684224ca0f733f4cc20abdfeede46b5d11de6451409a411e231865dd3bf71f8a7c56e32d357e2ff4e65abfb46954027b2c48b9c14123ed7948114a090d631349de06e14a60001000993e3a59e84f621b3b409bbf1899d526d1ba42b041155ad55888353be7afb08ff686ded08ff5d923f7218743fb3bde0f58394be1cc51a899b079d1b8528a1fa969d4293efd07e83dbe0ff9a011a919197d94d8f2fceb1e686e81888e517df7f30d2115edd37e5f4ea1f7b4d94912f3db8fe07bc7360a732df3c4ffa85844f4adbf79eeb2156046af5824fdd5a8e8b7f6d0c0cca519ad56098b04e1e0c88f319d690063d6497232df1100bf68c7bb507a15e4a14cb6bd45fba4b9c89d9ba8ffddacef1631264f854050743c27e69f3c6c5109d7b89c5bf2dfd89457a95ab07149bf8adad21ab675ba7251cac91b74be99e5d9548eb3e40cb5a4e7b58c4b6a7a8c509749d10f3c3bc0c347f6b30b72ae35211261fcb1c135af01b284e2d3c73ee199a94293fe390b7f7c65ddc15471fc0dc0d0d6e9d078a07e38b7c8c6281e8b61adda23782ebd79ea44c9a573e293126d9feaa9f9ab29f288c0f9b60ea244cdab4ea3fc8dab74c8dd91fa52c9e0f468dad959fa28210d1b436c8debeb207f60e72922aefcab7af904fc10e38e3390b07aa9e51bcc283842ef511d9e5bac0d5fe97aabd5cfccf562b69249f854db2a4968c74162c880473311a4063663bd1b3e008835845b9d2beddad1facdc747592c3f779263d11f4eda9c69a09fbbef88ff7ec2647855fa698f776e9ee09863199bf614e1a8af552e8ce96558c52ef935fee607328df0918832643c13e869c24a91bc4347f7506e18eb37c55e70ee645c8415750db9073567663fe7e42632d3e0b68f7926cf4f7274e0128e84b3d0ff3c99ce090d5a9bc30dae69b7a17d342812ba3d4090a8dcfe7a600c9f7e48b9ac7f6d4fd5d15a215a084f245443519cb0daaf330728f7f41f425fb4f52e0d9639947d8df264138d863002821a7a8ec92eaa8d39a34c2f456b2a62ec43663dc0d3ed8ffaf2ebd078e3f78c6ae059aed48a419d9cfff43e18f0b2ddfb8d6029469cb5e7be6dafc9b5a3ed8a861a50207f6df137e6509775a75ad3616e62f3599f866d2a65953087cbf407aa03c3ad01955d2309e10bd61c28f42c19a788e6f379ad9c9b84281dff21b348a224aaac7b4117b95aaa839898b189d6e964b12f6066f3feb39931a4c6094d5364d78fe0b5652b5d4bf40e368f39bbd404d9d63dfcefb9e00dd333c3a62baa6e2e7491447a9a89531435c06b0826a22c2791928788dccd194388ac7451bb2a7bdbd71969a47bde848ffb7d75d666db22162440d43f346ba9a0f78361b1b6a14af42c7c333523cd35386c4c266ed03b0f9002041a755a48fd7aab9fcdf5b503d0f0047fc8c62f82b5e348e9c997b0d70e49dc0edc9c272d143658df05ec856d21f5aea1f712ce661390d2d301311cc46ba273978acfa140909a83e8e62623cb9b7f52c5dc8b8442ab0a0e2fe085965fe8b66f4cacd6dca8115f62792b08857404798b9826868a44c23a4fc7bd86f5e71409bbd300d6332c6aefadb81414c65ea9d7b81e59b22c74ef949ca84dc324fcd8e8e4ad34da033d10b0f68fda0d3f541ab477bfa43cd62d3a984acb41bf1a6add274dcc0f9f4ae904c9a961bd431a0b26b1365a8602121e6c34110fa87475dd8723b39791dbb5b80e930ab40dcbb3b7678ff64a5a7c43aef731d07e9027caefbea6401a03e8af88a0fb6bd3b3b2f0aa06c29d2680a38db69d3eb00db33abbaaee5383c03d88b4c28ede5801201e27ac8a243cff1894a04f0bcfc7e1d77da986e143e500804395d4b7db21b57ebf8655028b6a7c1bd66cec274a893fd44c57c6de80050a1a4971f55196f121f14f4d0c54229168771f81ae30a35e8ec108ed290f93a66c7f8a74e5545dfd7d298bff2e946d1c1cf1aa84fd5eddb39a8c7ea361a59faf94c759d6ae5524c7e62fcb9832cefb5dece1ba9c77f9fc5df789914d68fa501b01f22233bfa822e4a527c87ab19153d7b68d8014d307bdaf108cfaf16dae7cac3a46c8a8c4a1cc65cec882c1c23d5675e97e91e0711126c9a99f3310d3824863e277c743fd8a72e0defd8ee66874eb3b1bd4968584964354864fb2076b5ddbf6f1954d72398d6cdb4a4cbf6636564ffcecae9486f588418376ef99fa8069b820e2eaa81a5a5aa273661bc03880b2a4eb582bbaf377e9dddced2ca767888b0e16e5574e50a1c8adc822c678feaf047d04cd69c9e6fededfc1efdb45d76d285765013e4269235f6939353e0ff26eee94e37f4878d9044dc9308dbb1e3145cf1507ec94725e8da373a9f4b32342d2c3893dfcd046a11723ee64c7ca625a51c1240e2a528033139a2e36e1b00fe39250875f1c17780213270cb8cb799d1ddacab32da120ff3608dab1ca5011eda40d78a6f6acabbb20da62300f046a7c468f25757579fef37a1cabc32b6901ca4dba8ae6b81d1f1c078db9f538b26e970c3905a4cd781ab876ef239f989685bdf4539c4403d6bc3bf2c7daa87ae25d7282ef999e858346438639bb2385c53844d5af3f8a9180ca8ce9d14da9bccc85e9f3e82a9544dd131bad1d0f3cc6291722d6da48512978555a3b30f31a875b3572d4bcd465708ce95b3398667f0d71337db475e74efccef818f1e41c0bd4485b2fff12ccffa6d6c70ba6131b447aa31f2a3dcb6c367197cf87942b562063db00ffd16cc9aec8a720cb0ed2c18865bb50d2589ee863009115","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
