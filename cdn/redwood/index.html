<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6aeb2ca2e81b65144f85014eae8c00d3d2085dfae4661093be018e9f428f9b14844d528b8ffd90ffd77c02e4925d0f83d86ca83c6dc441b112b2af73cd40d3bcb8cc2788c16ab4324c159f2f48da949c4e4e846fc8a0b2fad5090e011ee30b882f7138ed69d7e6754d7f5a24a4a9259eb868c3ff80893a260d5b3facb027a2d1f7536e53b07acf7bd464706efabf557b6de381d28a898c2207966c0b8daf6726893c964d1fbaeaf4ce56adbc671a3e3c922c0ed04fe65414bda78363611af275f990266a362e8301f560401aaf6bdc68e1cdfab740e3ae125b06eba60f2d818d3d7eeaaa65a38303255ad4babaf2fa6ff2d3223d806b0312161ed961066e77d2a4160602d13859957dbca9d2695675c6c354d8c1db139c00b7ea3861ee48afb8635ccebd18a050be55dc603744a3e17ca66495e10a2165854acc5c1cd8ea0d133bb92e3d7cf42ba0947a88db9832fedb9817584405d1cd88f97a43766bb505402b3f77eadefb9759d3a4901862d144e69c1c396e8bef21390702cbf8726f9289b7f8c612ebdfccb0a4f524fb36de7a1df47f3a7ee264cb6bec58c453c54c4e1452dfa0949785e31b1f40c7cb653a454f9403650371fa087c9bc2072760b932be2744f9e30ec558a0b482975085ae214eb98c8003e4fc6c940a7b539bc5ddb46b22ac5de1b9990c6f0c65cfb0f0fb726438a33168efa71d52510b2cb8a6d3c1d67f3ca67e62096e7f5ead16dc25fa812a898cd1d36a37b7670bf17c75763722bb6e61dfe906ad02e438873b0285eb9162cb2172919fd2628e8b28751e153447d36edd11a324da17c2914d1b61cd83ccc69c75cee919af663503427d7494ab6bf4786ae02881dd3070764ca3d4398673a9786c2a4a117f3075ff40dc9e0745905e65904838594e215e1d50a7444569feb3bd3972e55a5fa00b823bd964de52509532f433e8c4f7d285d9bf55d7e3e836fc028c31b90edbe06f951f5529e90661a1f8d01dd0825e05b25bf6cb8a3dfb8eb9b75966f38d817676bce024cae389084bba4fe615a2c13ddaeca5f2338dfe1dd9e725f8c87307a30d1a836ed415f6ba6e8a4dddebd4eb78278d00804cc42a2769883d12ef346d49f99138ef5ace78c1858fc78f0e45c2833c6c164c2abd4b98d71ed61ea70e089de89a5d2dd71bd4c148766681df0ac0aac3dfdabce09e9844b95c0d414917313c1ce1fb8d84cb50e14f7a061927428306bca1da9a6b34ca8267959432d09bfb9890ef07876df67566c4b6dab61fdb66d24e70f70098c3140b1113390c64ecbf0bd6c1c8934dd10776828800ceffd95cfac7dc018896a72cff63b01d1ab1bb49c885f1f2019b6215da7a7dafe3cf089070a0d2a23da3b30aa2264f0cf4dccdc2c00234b777e2bd618675f815c9df9288dd215631a466ec59a7c558df339f4b777308e2f236e9f433a3e1fafe194bdaf708c9f8f63fd072aa4fad16cf14e83f6314921e7a1370f4d948c68ecf5320a98202d686a21123007f720ec67d6e5ada79e0205c4d0a7c606d1a093fe26648165bcad7c7e02d591487e84d55be59b6183c780932fd91062066f75fe2dfdb7551bcdfc871e5ace32127d46971e71a2c6495dcca3dc6b31e992f228f8aaddab73e214516ec5b9e0c2eb2c4274289df061cceb424865b5aa9a43d66e14e244b1747e6935e4e1e68d73439172852878094797fbd5faccc51404742911e6ef6e51df350a0b14937c4ca3ebbdbf5c98e9d4ce4f62068993d13162208b4ef7408859a68406eafaec262d9b5252bc8d715cb7ef5e24bd383240fcefa3fe1a703107419c43a40db45824cef6fb49f2055ef2ef7039d9caa483efee1eb097201ab02c3ed35f6bbe573c5535bb47c471bb39c3cbbe5bf7dbeda051da51ebe1c08677443a32366c57f309898e8496e19bbb7f9af52a5a9d8c2fd68c835bb59f1ed7fa7e4f15c3077530cad7ee07b79127ad73165d9829f2189fcb73a55652564251b816418917f85fc1d0151e2d0fe61945671c7e3284e5cbe6a01400e44332f58b120969b3962e640c954cc3e5dc8865ed0c6d24cdf37b9dcf55d840b807108a46782d38e10d83a1c92488d5e8feb71e5af695cb66b7eb39149f9e8ebdc4b9175ca4e0a052670221f0576212c40adaf0bbf9a4fcce34eb594a96a4bf43dc74d439889c02fb584b7f3c926e9186272480c65967833b547d1ba08047a897c0cce9495ca015fe0686d6ae8fd754a12f57dd08ed6d5c8d36fee40fade33261bd76deb26861f6f7fb2eea5a9ca87d1953a70ffa84d204a128b6c55d03af315e8a4b49956bda79345130d3b9ed4c7092cd268b140d6b43e9bced65a0871081a5e6630fd85e3770fd9742fee72675e86cd88b12f48c7ed3de0416870a91fb2e447a49ffe553fec171ef39feb366cba645514ec8f647f33051f4f7c381ca3d0003adb3eed2ac28e2007967c4c7f2d3bc508a42572cc9657e4794924917f321e62f4ee478b33b0cf13fd8b20c257a1e619ed60951a151cee89a83ee497de4086cd87b0d6f35d8278bf9e2d5ab242e926973f33a64653ea369d0452290acb6ec7d3923ad5f5719f03d6a5e89255667b73facb65a4bba2541856d574c5ba84dc4c890e360652e9e3b7899523b7b8f9ac40294879f70ee8c0b1b93dab3add256e9e3040896eec1f260a61cddbec553468185c033dbe0d2831eae6b935dcadfa4294be5f13793b52500061c40431eebaf7ac77d37c90aa575970fb6f0b892444dd481ac36e211031362b6c7755874d80e1446a4462fa684e7226ce3ca0b30489f8f9c7673a3985d45410d084a998c9e126c677d8a7ca98ec54968fcc2892436ae404f76f6b48c953620ab3f09bfb5ba76a976cc5837eeabf49e32c563f2f7d24adba53d6a67ce74015370f5f49078623ad9a11d853a6c32ab00486c7289f17811dea062ebb8fdc4905cdca92eb982e80a1c27764331de9c9a3fb5f4664d2522cda6ea3e8a01e23ae4fd2b6e5f1c94d9e16dbf6b11891a13d4d3be4156b95656cec40ce3819c99e6122a05ed54ae123e33abb377cbc77523f5c676741faa22c65a3a252d9c8f65c9a00517a995e647713975876b01cc789767625c6672d9502f1b7d9eea08221ef1242c15b78b7cbd8f4baddc7f94010a8e3f7160497bfaabd36c0c7d5a9a09983d4ffcada79d63a1292c91c3395be26a954a8a421a51d9264169fc780a56c2947273a6aa004ad4f25b10ce8a1626aef7836c3c2cad42c775c442de0ee91560415719460feb225993d9522a8b3004c68918cc4cd40a0fdc181bb3fa9eaced0aa359d649f06b4ed3012a8ecea079512ae124fcf7285e0db2822da6676d29a0c58c7e221b947dce9ab7d9ded8be698620b9051ffd6076893609e3dc7a912be02e6f690dd0e792ff9d3de10ab7a33d94bb3f62c2e8756c7a417c05df66c98bc68e5f1138bd6da6774bb80bbe89a44c8dcbd68212c12f3aaa729effb670887cf7c8f319baf57b933bf5e5729f2183ebada07fd336909c204985c6ac435d976e2a92e50d129108f6606c23a7d06982b46e9b98ad853d9c8f8eb7e262090913b47838f2dd0b18356b5088a5e0319b04c40b33ae1c3a988c7a34106fb755a40ddf4c0bca5dcbef8241803f9ced81d8905db3742b9bd3f2bab8561c08acb3a1d677db1038d259db20ed00e2e37323ad245164d7f98838441107ef4dca61e0dbdd89366a7108bf057ff399d66486e85f4709fd641b382c2c12c34757c376545ed76d701bfdf947b76f0e9b7ac08f72ae5ec97734f3831f69e4902dd43852ba1bab9b1a8cb6c5145ba2e685f319f78bce13ca274f260b86528680df2f6f61bd59e56acd6c5f9b9f1cdb40a32ec83eb8832bc50e1235ad6113079c28176ec6d0c2c1e27ebf3a119350d92b1a68ebafc4d0796260fa96ce9c07072e5397665ecf1e7124680365b79b16e81a1c1a173da06319e79f7883090abf7784ff8b51f5038e5a43c49b2df65aed69967922134197f6c4e1e93f9506e7645d2de08a90b5325f8b9c9102eb5775126f9fefc4d0493e76a2e32651cedc031e1f8be28382a80367e791868b3be2fa1a4154e9e3c52b76b19f1c416a7c284e78265fd4fe2a7cde2a754941362d68aa27282bc00f40c663b79fb8ca9a642f4e181fae2fd41fffecc6a1dd1d5e86b4546ee6bc222053065702e2b977aea7b0eb42a56efd920e1b21ef28f26d309d63f7160850fcfa93210aebe0e2222e707159f290efce83b323665ed633b8629e5adca801c845a0b3738ab11578c56540a9c40fee7542fb81bea4b6520a9803f192716c7e7f6a065fabc182cfee7c1396cfd481ed50a6edeb97c8e34748b15c28054e6c8be084028a17f9fb24b859dc82ff5b75602731df5938c5c7f8e7e97aa7c0f8325aee3152c1ced6fcc6de9c3b3073e703d0f0d78ec8f88318ce0b85773536884c6646c8dff2cbbf986a31286761b8fc5d181d7e27f6db43ad2b1f19f6468b3eb7152e58be38807da4953874152cb3ef6e281b0393f9043402f3234fb4230fe593fae003e299b808188194ed19a4c4fd30750eebcf7dc681091e2fd41654c618bc5d7f01be77cb2cb34b38285fd9b04ea756098b24a2b923f789197683aee0a21c7d4d0965d35a71b87b5b1773df450d7bc37d9ba425318a10715e5cc28abb267283b945d2858b13b11327d8c982877404176c4c22bfb08f9b571adb43758a7bc9debb913e6ca7ada02c100a950aff4eecc539882b3ad618a67153b8b3dfc2bf040d1f6903c9a8f517642cbee056c5ad9b2de14438c8f79ac1845786b54e9faad4542878e68f7e07329a594780b3a635801fa95ea69b28daaee8fb2615308e007a010f74c0e8497a47fab1be48f43c2a2c975846084670ce56c8904f3dc06b99ace20cdeb1f6081c6d666dd011e94e5c96d93770a710ef716a7f408372d0ad2b1a38305fda155416678f232cc91f92f5ec9522f73d0dbcfece2b3e492eeb78baf6cfdafd35698d120295f27c8b9f742fd54eec2c2197ba87b8f71f32904890e10d0039c36f72868c7e680633b774a2e5051f18c11d0e51031b297d4be115cf8e115150b082784d782328c871a26c5769da24d10d6dd6e58af9b72ba585e3f590ce2dfb8a7f970535a98f8a5b161e6f99f6769fb0a426376d5cfd333ebe1c175893de1fc19e32362c3944ad2a857432f4af3e51bb2d7bde8413a7e31647d0059e46b6d8d0cb21605a5affc3903fce9ce6a455f4a3fb32064f997af89b82f817d2198d1aef3ac7e2779cc445f0ae567efce0b30965b79893432e3428092c7709989387b46224a5ccffd3f134f4909e72e3dbd4cddccb397abc8ecb5d6393dc35ee40b0fd8db622a0cb22d285f9b50f3909ec3ec97430d681a0da2d9fd42e6048457c6410fbf68835d2a868424243d7457af5061f159d54087f165e8a99a8077b63ad8483a95691339a9c0452e5f00c8fc1d6206ac3eea67f8a3bf814984277e25ea45fd240f2c9452bfadd91ad105298a6f57c393dbcc22cf6c9c446dc69a2bc02890bff53610ae3144ae707ed83e43cd57943b6983d769a5ca63b4ef1d2f74af053c2a712a51d718e14a2181ff3a1b4f57ec8c59b50b38ec84916b6e32f5409502161c2ce1711a2bbd31e532d39493ac735e5125c6082c33993b89267a1f63dba6d6298012279499594d4d98e9e03afe544abce4857eca07d9a1fb215455d0c868269407de27f42bc09bee78eeba96b9e32b9c3f7bbe2cc91d4923f9605da426d63e4bcf87e58a2508e8b507fbab156de3a89c4b5918020d7977d272f103b3445f60114952cfc027add3d92e21fe471a2e58ea635de7b61054a771e88fa0d879745a697c74f389e4e45214ab14dddb7b056888039f0d1f0289d240414232be9cd87fe4628d0fe358109371fd3180307417278ddf939f6bbe12b3d4b356726500623bca60f4efb281452ba2a81377cab3965ed8e1003fb76a9b9f156453782094044521d696834188c3f2ce4912385caa7427299828c6b005b12cdfaa6a396f2620ed1981b5c90ea77829d658d3cc13c94ca5a710092e4e299225891f1415bbfe27dd4acf6cbc7beced4b77e291f26971995aae561dce828d6be787a052d4432cad469c8bb7ce6219b80fbd43ad8293fa1e4868b42ebfaa0619caa014b28f765995018376917a373688190a23ffd1452ac90a9741932aa59f910a606ef2eaad9dd94f9ab89299ff429d4c5aaf22e172c30a6d2f4447d4a8910c95b13295b5dbf6275f96c9e542a24773458c5992c72356b30de0afc61faee04ebcb40e7cee1df4e296193b324723e069952d4db0013c47f361f933216e2092bfecb667ef1b9173e4aefea5a4e0c17622f3b4fa9628cceaf195cc6516a944f1f3cf6e8d2352db838f862ce4745ed765cd6d32db0495ee700bba14ec9d53b960f9f3d3acfb54e000092540ca69de66b8cb9b652dd75ef83c60fb5c425a235360349ecdbc7b6aeea0023e8aae74363458eaed63b1f40757f702191cb4ec77e4517157e61d64486a9114700f835303c47bafa07b9ea040059cd1823980d3668bb2447a91a1806f24aee37b4596ce0282cc860899af745571be047f83af9e6b74dc3d64c9f1685cf201779debf70a353e597fcea0b5621aee36fd5db0eba94586811c9362ae3b5e196378434283be9f65018817e7b41626ce91b46547147758361ade41f7064144cd62fa501808de128e636987bd7f9581d224c25c9fc58f56f784eb7619c68f14943fe900fdf1afbec15cb0ea3bc9f4bd93186541d4d3732e2597b38b641abcb68f8de8b478538220c97285f67e5292bb7b920e08b9a9a9255ca0a0f7aa36fa1fd160912ff8ec2d1b0edccae983048a54c6b146f75d52779b6c097df181fe55e92fa84fe4c125a02de22f1d79b99bd064e7716baeb63a76fc96146a77be29b37e608efa4cc132610f3b94d48d488e04770355b9c4276c08e99c12d05c57e4bb4dd601876e640e762400fdd76351b307279d538ccc674f53b385c44836ef3fae5add8bc0008381ca20eccb5c671ef6d995241624c837e0639a10f3e468c0911b9dfd55a429e638ddad6c6a419d133ca2798c16de12c008e1f4a97f6e0ad1ffa3497814f5d1fa4b57f5f71ef95eb91c6675e3f77f680a05fc4e39069141b5714eee626b527240d78e910494fe3df0c22b752a491569313c7827604044d2b28d3513c11e5a47834424417d5caedc4860aef3896418a34f3166f672480b84021260beb9dea86932ad08cac00757cbbc2dbbe6e102df8b037cd0ba6b69ec832ad00ba7663f9c37b481201d668ac4814476fd73cd810451e5adadd4c104c12fde6b0651bf62076512f333b691d2d46ec9de51fc635671528a46f1a644f3946a7e265b6a64299bf54fc178aef90788673b6013ed2bd42a397d46a0fdf1425c0f02dd97a1b4b9e44ec3f42f0203765a0d9708bcdb95b50915de04aa44b46444fb846d03bd44d0c915ae566c5819cb28ae59e0de1bd1ada5de696ad9398ac4e522ef06d617406f4964eedf606e927db51c90ee0f2f81e4841bbdf628e912b3357a1b449ff6c412028883c74c30b2482f08c65f8f23d11489011d733770433a2f230f725ea8737013f611206f9ae997c19d709664315836a1acd66dc7fdb77d9711bfc099eb4c4fd274ba7e6fcb1c2e8aa82925ee70238a44d56bb969b43fd8dd3d92169f406133e724142f4bcdef541656f2addac08866a0ab19d6f2310dea41892caea8f4655a38960dbec4d7fcd4cd05e1099f5ee4865a0b7962d40fc6bf88d69549ae070b7bd6d9e8c06c352ee8c82a6f14b4323fab00ce83053b06af58ccbb21c199286f52697e497ac23af4dac4c9aeea89f61cbe5d52e19774ce0e5430712a29a282c23f0691b1d41080943f3379e471af93d628f7197b0eba44426da3efdaeac4451c0116355a45065db4527e051f7a3fe8436b52076660ce5af83499ee3319d3d93eefd50569103fbd60d8caa1b0001ff6237a32fe3d2e8cbc1dfafdb6bebfc99cb745dee46aa675d8b3daf99a30cf637e6dfb3a0798b9fb35a28f779809a1b076aacfab43fe66f679214d70e15a10f93b99992ed588fbb4fa6f6c404e572ab08ab3b60a87f4488ded4f54054515f31e6a9720421afb452ca680bea38b7f3a0177fe1c2d9bfca90f39c0c50e30e19a8183c413bc8c1e26eb739181ce561fddd8b8c50f050be555ff43b71f3d17669f354994a6fdb9ebc0ec563322c2dab08a5940f6460f38ab72f5a56ec77a3fea57d5c0071b482798b818faa55a94b9e57d7aeef8a67e54aa677cb30598f60ce6c3864fe3c7d2fca09e4133353cbe9d550fe8d9039cf13e8844b3088bfad9978d4c87e251eeebbed80cc370c3d48e82ee7a7e64707efd461dbbc3443aec1bd5bcbaa09fa51e66f39bceb4a5a1dd57d809fceeb09b504b5609fcb31150150b6521345081710e55973741f6740e3734cb6012d5659c19f047323379963be698f4ffd42795187421833fd99c6e006c3577c7a07835c65463163553132f43fba1a1dd10c53d40a60f4bf656756491d6fe7f652c97c9d8bf4df486a58c513695333ee13d0bcbf140b26bebad1222722fb91ec36557e20e95ce3ca155aab6bdcb9cda3606ecea5a29d64cccde4f0bfa81974f1995a3875e3d53b8575feec8a6c5848eea443d64d5bfb99a3dfb12677619cc86849169e924f138f80ee5363d1e23ae1c26602dedbac26f3579a14a8e9ab02812cf41295dfa97ba8e93892f26146945ecdb6b2c22aa94039a06a7341e6e2aa8ab26131a6f0bc21812eb307d8b4d7b3e511a018462b6f8d14031ded7b20055fd075020fca42e11a7acfbbeafb4f5639e072ac4c570cf809edd422de8eb86b0f7b2a98b2c35c4233f64da92a8500d32777426ba15047b5f4ddb93830f2202c1b494aba8edcddcbdf6491677f04cc53287c16860495721ea3e5372cbd0fa93d442400496badcbef778a0d3467c05057b74b0379d8ac27f352f2161a7a57f9b4955f515c91a175a5cf24669797f0daebb5c40e688e30ce03e9ae10caf886e0268df43f04f98cd2fd2b864f111fffac430af1c0de64d2e292e61e456cdf2f7e2389a5a30c2232ebafedae6f7d818032e45d1099dd01ad559642b9868c376d32fc2ff5aac4d4edea75d760997c4c2023cdb1d08da206405b47a12c454f7cbcf2283594cd70aac225e8bcfafa11206622faffc4260483e1bc78a9ffd8ea7491b6814c1271e6eb4c5945074a59df87d79a32788ee5fb84643edf4b82f92ebcaf9bc1827c1c0e90371cff99dfdda7a993cde6e0cb03def37d29bca49538d9f8eafae85aa69437bd5196513b7871d034874b8c52aa83f4f7ac16bb0a7e1f12f6756c41a4ee74c98f663df0c7ebe2230ceb6c47e6d65a7b1ecb8f0c6e8c6c31f53d4e22fda6315b94fd5f71c9f8363c27630b83b07c07ed731015b9fddf604b86e370d63f3201dbd1dac2dfaa67e54a1c6e926078b629d00e8e99f21be51afef56567755ee2899a01b80c69db0d02636cc2b3f5b89a43bf42125307cdcda018f2e81750b21c19be1324dbf2cf71b17914b867054dac253f1bdb0f28ad50a68d94d2a318054b753d041bab2a753092fa00962958d5964eb086ba784bf8d7d611047398960624ecf5ea7e543517f08bf3839ab56c40e01fe90eecf712aa6cce3b09f97437e3faa2250b3256d8b2a5b11400468c32e22eca46b2800a06ef38f5bd9c79b22a3a7ab89e25468cc7472f4346e4d9d33cc1c1def7beb41063494993b22cd98dd8238e8876226b9f0c619b98f7727b8628f38144f1ad86aa26f2ae288668e4dfeb6292da4ba1a5eaf1691c333a4d821ded5e4dbccf1d3372b3c1cc8734d232922415828d66078244d2755d208f81b84c1024b0803165a74f2c4a4a01767f9ce134d932e54482793366089f3d486320f5ae2154523134468f6306b4000b89058449ba34c7f174e0abd3ac2fe5a15107e9852ef87cda603369d08fc31e5c9419dbb14bbc804bf431a22d94dbd24b54b7c64fc3048746ccb677cfdf5e01214299f8beef3091f82f20552b677954814ab6837b3dd4162cbbce2065569865aa67900e05fb923b58a0d485859cdcabe1f3107b92743968021a15ad8052d5751c0094e303a5ddedc6ce010696a96f9296fa187f74d1b225154ae85c5ddddb36c6aa8002d6b8059049008dfce7ecbce7dd1b5796a77790ea9bb2c597d41c9f1efd14337bc852329b8da7b2cec5de7c46b37fe1b95b7c26ad267127298d5a2ed3ada84e0448d7b1d80fc1230bf49687a33efa8520462376050f86f072e947d72c75ff2f0aae3247a0292c7ece552d6b5e0036ba7e3996515d8a785cbf0de210a28ef40025348d9653bd1c76f52d15f789cf1d2c41f2aaf6dd68d3776d396331601badcef98767b5e38f780160d0482aa11115b240cce97fe716ed9d42f5680dff1cb2a313fd1a7c8c09766494fa80f23341bb3b3aba8226e9bd8ffea887ee3ee2dbc7265f18d4057b9c939884872a2c94e9e5693796f81265f7c66094d1754d7aa2270fb85995282b231031659baa57df0a94a8ce90f74ccc7bca8374d6a3aa57268cd00790e4ec4981b2dd170efe6711f38ccd5515147938ac4ecc62deafc4424cadad46d25a9b9a4933f30acf2912c18e3b694b3e13b0e5c06ff9083493e3927345cc724418d7248844d5d8942f134c528447d11c5fbdc649acba07d9bde8428231c04ef03139b203837341e03398460f5507519010014d47723a43f19202b85d7e2feda1025f7283d84ee8ef3f65e9e0b1a624f106030300ca89ae75cfa741e19718718890340b19b0102703e1474c095c8e8335ef14ca5a562fd9d1e9f918eb8fb005b6fad5c0f4d1c05eb6aad81423d0049579bd54ae5a815f14c517951340567edead06f568a6fef65e4b6c850de30924a8a44b655bd7e0b47c9f9796dd30cfaca482ec7179614fa1f83f77b2a9db95522111e01e34331f75951a98872e13f6957be88cdf6f2e88faf5b3c91e145053351f7f81a4d4962ec46c7ddd7e1ae2daf0ef9ea3628eed61ce3c7313fd1e9e49ad56c0eae1a07cca85b2ffb142ca416876d24d60f9c5fa9da7d0704216b3788f8c48a122d0495695f734817779a492328dc02b562441fb3a7d30776cb81e209722fa397c9bacaad4db00268bce5580c6d6609bea60b0092bd5aa6656231c4fba78c3b6125d1fd05872e430d94aaf96040a23ae836886a5b553ae3b8242cdbd87d08f84a8974dc9ffd513036f4264abce58cf7869682d97e737dbd7278f67e5da51249eeb95f73cc47288fa0db306b97db13544c32f4c50319c2474bd7a6f74d0554109e922dc487599c8de3a6849debe1d32ae9402511f43ab68d44f1883fc2e4f95b73ba9d5307b84f9a909d4bacf75ae6c6055a514ed85cd40c1168ff251c35e827c3a869c97eb452d192fb66a2a80664f7baf57a8a81e45b0839c72e9cdce49adce90c11a71d41034c5ee5ef8f7736cee0d19929e233e46197c502410eb0efe86fcae5629ffb8f36d4e23fffdea6dfa455454fe890a2fb64c8fa52f8d3b1c1d55e36b3d1a85187bf61891b8a49cb78699153e55b66dd2bc7b505544629a31084d45f4fc0a5056ba561b970ca4c139fab1176f94155853040e53dfdd727d468e4ccf1a6e7c0606527dba4d462b4eea9422755c97ee5168dd05d005e0b967e9dff144a0dd4fe9dd969de6b64b16a1d16ab724563774d8303e43137f60395c8bea1ac5fbb93d08d6aca6c81734a13b6cb92c4336bc5f0db92615abea5abcdcb8a391be49cc4c20a96a32bc5b428d5ffc493c151b5621a42856f3a48f9c35d084df422a583d6d84869e028c976c77e47d23beacd6049b7d72f3599b928b6577643f2661daaa5eae4ea53a713d3560a4aada4497690a55448bd07ac0faf9ce5fdc2f04a11fb295ea16e2d73f74f611ef5bed0c9cd04c124f4100061d4e125d03b19e2634610ae6d5f98cbd8b0432fd523c0b03e0eb1bbe633bd544380a459bee8ba761fbce76df3a4168fc24524d9c68ff641aa8fe90da2422e3e8179d745c33c0190801ab0fdbb2d94cc26b7fd2325efea67f7baf9c40e85ab29621fc4e78e1206bafd79c117d40a43fcede9388c1d621357310602411389c8e766f9a3b2b46478bf3fcb555abc049741e008eb2c41ba4fcd768e39d273eab52ea6ddb5b08afb44f828f74b48693b54f8a9c87904dbc01704df906c0f0aa01e0d1e462a24a53e47ab780eaafc6b828b58dcdd5c81ab4016cde06850d2308c4c3a30455e7e342754bbbe0e61662d82404e8460123b5f77006e194c168d84f2e80c1cedfb9138514474bfd98d36b9fddfcae47f2ed5fabb810e08f7c74759376d44df6b5ec1377fce1c4f833c50eabb52d21a7b576f9386a0bdcf7fa837c99557d8fd83582ed9783cc833367226554c66b2268853f918e329f3b9926c9712d4e81dd9119acbd13ea504dc65d7b0987265feaeefc218c7a9c42d33330cd42cade37a8bda5d11665348482cbe63e6e740432fc64c09477f50fe4aafb98a67fe315c1f70bef84bf1c6f7758bc77e4240c3833cfa122242157f080d55f8527f95489c4c612f44bc65dad489903e7c77881336af753cf939dd602ad171009b48c2d7561c00c1dca87ad4d2900c86eeff8cf6038de2968ce9afb0428f96a03a5bc1abab43c0770b9bc125c5135647620d38f0d0773393c95623687767b0cf73a60266f812a1fc219b64003dda34c94bf71884976edc447919777b8ce52ac6212aa9080db9c1abf1a71c05723c824673f60efd8a9e3b99ec947d20262c9c771c2c2369126632e890a8dd36cbf75639d791d96f87f7f4f43ae73125703fcf0e879cc324a6ba1cc077b8de8ab38bf17cb8df7be73b44aa99876766f1ce04f668410c8eaa99e3c7a359aba12db42d49dd3f89d2bd8dc79c6ed651360ed5b1ad3975fcbd360da744b746deb17901df8082e3fbc2f67963142c0d35a98ff2c9ccb3d31fbf5d4386ba717efbe395411a74c2ff41bd492b5ccc8e04b596a0f7db9bbf2b6ed247eab0ec58de4a0d668520d82c299a7235845c97448a720e7e43947100384d541d1817b04a7f2bda9178221154218c9ff068338c96f69892c642fa4711f829db65e2d957d476c63169bb4f994bd8944b1b2e7291dd71b94f17099a476bb48bb42b653707d1647c5dc4f5862fba101e58d42228acab420254b496f30a5636be039294d5a90b845d736e3182771d130ceb925ee8947d84304f0015e3dc983d4096b0523de2409c3d913bcaf15ed15b618194f8f85bc5f7f516b82c47ea767d303c809548a4f36222be5e7a275e0cb7df776b74538f23d973b24646514e13cdd368f6966e6df1316a7b50085f7b37cea07da790a33edb3b412c3ebdc4304f651eea6fab486344bec60d40ff210f5fe2649bc53486746f4320880e1ae82c7917238d60f3284b1b583efce3afe4eeea41736483779e70b206bc3b3914b67c25881b588a8eaa993433fef7b57d82f9827395dbc4b7fb9ceb3c9b5e14cf4cf8590159f4749c259d6a43a84d39454e0143642d3c3de7182c2418e3f0a2da039c1a306fe1cec616db664bb9038a8dd4d3e9667368792c6fa2dcede4b6c6e4975fc19ff66721ece150bd1f987e365537042d4c259d3a0aec085e7796a49808f625b3744817bf6e26cc522d9756857c305bf6190a9b79ea114a57450d4ea750279b3fc1906b5a8a61da94268e7ec5fc0cb8aff1c575f1e8a3e21e2e1c9cfd5cfa5db57c15e83ec17f94f30e8574ef772bdf4620b21377d42c05aae349fae49071fbe18bab37e2cc78d0f947419eb984a03b4f4721985fdfc469235013c85eb276ac1269b23d02116a6c3257eb82a19d82c957fb82cee1b0bbabb1ef07361cf9e2a64fea6f1b308a7eb0a80f5b8058a81d19bd7abe0b574a03b2dcaa2d1f90ac7f1447486d9a13d2bfa2b27b719e41d30634feeec400d55f8e84c12163937c669229cf8f4c7dc38af6b96f590f9e5fbedd9e66b620ab1aa419dd36d6ac88a2f87748035913ab58fb4dd7c6da3bec1097eb393e708d2f3f9dd45187a05ffa0a1b79907dc6e71e7f3723ccd8b129867a6c6a6ed6cd34e002f0d656cfa24e9b85a74839a1a5d37dc526aedcb913f96708f40a36970e923fb481cc66d82f468aa4b203c22452d4b37553c1f436d1407824bbf8043592fa86fd65d5d2ea308f4f35eac424bd820dfc845f51bf2b6a261afa0853189091cc88c4cbd523fb64a8505fb8e9605b9efdcb0d1950e7e5d6becc638e6536127d9590c2839996fd8ab4e9d3b40ca87a96cd039f804e956b5b0ccb66576807402eb0ed426e82a253d02e63b45089c77492eb5c16136d88072e157b06724e4d5d40affc5afbd53b718bf143943d377df3f7bceca3490fee11e4f6b3de22ec217c4faa4d69c71bd3d510edf81e5a237500b5d0192d1eb422d9e486f390bb3ce2d5680db84d38dbceae1d55ee3ea90c390da52979a0830a80b03b3cb12cd292948b51df688f435b0d73c7c46e60bb0594e73af7fe18fc0e6f5e2778629743e555bab55753917e202afee76f8ed46c9fef885b677a3061f12d5b08c4d4ef9cd005b74f63bb16e42528b6d5049e4815755d34b0b73787f86ea88640790912a3dc401092f5d6e44b06e9d93ef6c053cdf9dd90f61474087e888d3b82330193f48db65e75b313bff43742da1f3f0a301d27328e9510fab045140e3d43a95bd9cdce01e3b227d4487dcc3d1fa35b9a8d7678eb9573b46f921fa636e019855f1f3a1153d7951bd4d1e3233614b82da7d556f3bb04a3430078cf9a28441de70a9472748823cc1c2371cf8012a21b412f9a09319546f6d2d11256351e33dcc72ab00d5f145c3fd2a23f56ce3f6d844cd6be428f9e329bd078be68044159b4788eb811fb26d99b50f6fa9c6bbef62faf17bb06e7efa8f2f719142135033e06ca2d2f3c048562c72353681b9171baa07190875ad9a3d91ffe771b84752bfc0c1b4404b8f3802dd7ca1c485505b5016a08c78365f4965348bd697be212651be0058390effa43506213c2ad4f36683cd829c33e7706cb915ee2f3962f09386f4a5031966fdf02d173d40c5c658a3c7a79f50782c6322d5f17b0ebbba46d87ba5650dd3ee1a5166133193c115174a983d88ea680e67b33f291f1c5abd25e007e09eedd85372f0caadc93841c9386121ffc49f70ae84ed1551715fff7cda4c8391a0890acdbc042ca699deb43ceb77b37544df3145c2789ec91eef716169937d5a9c00a9c45b096461067eaf78e4204d78a3dfccb86710788f7bd3fe1ac373d293dbaa5c56aed4f9af2c973f919a7c1a50ab3db2f2d706468b4f7053d6637786b5198f3961d0167c0cd851c8d9fef6a8351377e8dbe0c297b09ddddb1521e73c257e9b25cedf1ee238fcac662e70d5e96e1af9738713c4c3860c10710415ac9f1fcb3f6d5fd49e685e6d794b3497109261dcfc97cc7e8416d28a3460f7c46495cadbf0eba6bb477e2c45c3073e5644ba5dfd567652d576cd948dcda955ab8cd4f1569c1cc10bf8227f77e3065eb7412b2187aca5e90fd0c8d676fb278578ff66c5cafa6c42dfe9b2fc7366b12de5ebecfe7d36cd95a44ec58cfa613ac72ecd5b79ce9def1023a3bb6419c2035b21761555f7b8fd3b3154c1062c6890fddf8b2e2273291073f8cea1f701ff7b66fcb9c80fff230898cc90315df7b2b38079e44ee57d0fdca5a3ed3a5e40136cc33efb6978fe14e50efcde7a41e23f986506aea5d590455e811ba05f338724c9963fdc8e74d3724466e773a0d934afbe6e5765ac52cf16f2bc943b71b18f0bcd14aae549e3db379779dfdda980ea1f558d163282fa362bd9c95fa69207895293e1dda9bfa8bcae7b2c6d5976b5c4a8c4ba03d445292f8226331c49de74b00189a282ff053fbd1de26f45e320f308e77ebb66ce3f27da99f3f11ae716e42a37cfa23d9768c1e376846f5a75b8ad838d6e2146d5cf19208c96f10ac61c89ff55d0eed66d97170858c87e6ff15499de4d3abf1a4f9ecc2514ac192e22279b683ab11c372589776133991626b818802a6c335a719bdb61d75d9873a67626ce5f06ba5de8318fd87bac07e0cd1bd5b768d304384c690911510501bcb0816619a38b8062c82f1e9e64f90ff44ce7c7fe1da4abc688172b56ec355308cc4e45b1ed5fb3df34c4591eb47a770d31c57524f0504ee28439b8bb5b979e92425b6629e8a14ccdffa330754d461c9b0e454146797e514148f3be18dcfd927f4bb65bd3f2fdf31330a04d19395eea17f3f2e868bcbd92d55177a65e2922a6b3d12aa92e9c3ad20ae2134139d9ea378fc89e8b20b86d265d7e6ad472769c6cc1022579f64721b89512ab950c0806ca2d05ae0a90c56231bde47423400973ccf19f92cbab87103bd36cc92613cc56e5e404ca10d840a7cad4d95edf7147c672ac56e6f373bd6eaf7b82b895b2619da8724855dc11b0a29eedba41a8ad7d810072807d3ebdb467ee16c1dd3492fd65d7676d261584a803e5be3d8f13e664715fb277050be7da06eb66db5ba68d1b0c122ae071b4683f32e25000dc32cddc92b06023a186e2f3ca0ee4d159b9e5f0c8168d99ea8280726c89ca4aca66efdb9e53dbad95c4a3467bbc91d73ac82b02cfb79ca682d4f48109c578db4eedc4daa78a2545977e5fcf33120b6d2084487057fcaa2ffc28979e98cddb796bb473c3984b024bc147eaafd65019bb35e5ed3e98e2090b1b1fd4cf724893cd1b6819702e7cda33fd1745fa9f7e63310deb28f2c0fdd37b707fcee62ac00a2025058276c89a5a99ac893b309e365648b0c51cf5593b416b3e6fb92d6a5e29acccc3385b0eb1a75e91c5b0afa263ab94e06a99797fb52f409e600edb0c8cef6129274f8b073e7c258b4c63e8831c2acbb550fdc119287d3d68232532370c08e8d9f5865c79398911177871f66b753e09fc95800b722c7cdf6e79797089429cfe386ab7e056bb33cbaf1b0e194252764bb6743a12b393d994299f2d231474e0f81c2d224adf38793296dbedb031e744a4d0b05897b64e904c7fac71f75f8c0042f1109afa04333178cf9389ab6df1f493f8f39db7d40f74f299afd1e0ff50790fdb9ad73177cad4f61eafaec6f36fc8da342628c6dacafe43d5c5d218cd4b846f169b9c2a90ebdaf7b4b93303438ed4d9264ad6ffc57c2f4c0c87fb67774cfd07c7d1ef1333b83b11b863c9ef4bff1858f6d45e2a99e5afd4affe13fe50700b2e4e6e8f36d677f750f5e289ac1bdd03f8d6da8af4a64b2aca78b6818cc89c858be7e866d54ad956c4b3a73c6b5e07f1f559e7a530bb6689ac36b461379e1073dd2d0d89e6fff0c259021d1222d0f7cd45d891741d84dca630fc6590ff265a4ec9ed997128102e6dce7071ad64b57dd23999295f7307dccd745cb1875af21cd83c208605289cba79f749d490f0fc6781ca322a86c8be5eefd022445a12db566545f79237c1e059ac684a3a2d00ddf202e335ce630947b92e9b841cb9e92e2c19ac22b593a439bb3ca90a6c2b4433632a0d6a6a224777c739da4385a893df7c4bf78a31deefea57c6228482b5937ea50edf87d74567a39defe9140677b298ddaa56a4e340a024e868cf5ab763b379ec4fea5147d8cef9aee3c377ad0dd85bb62c334593cf8a5d873255d26548654aae2f7f9d733fe7e63fe26e49ae82a7143629379b0be9f5fc0a4c95b3b5406afa0be5a8b75d7a6fd5193c88c19641ef66f7ce06c929152e081a1fdec3b3eaf3058fc3ca0059027b489b36d8aacdff438fd9b610df1b3b33285e6f3c080c9f9db1d835d83553f26ebe8aadc03d681db125d8823a13c6c292bd08b5231e8153d72888379680d30880f0b611210e982e12b8ddb84d025ee51dfc7ba0f65cf197c099befcb572ca6e09c0c44c5d39aeb554ee3d47eb08b998f407272fc1b640c4d789979386aa65332bdc1569d0cec1af37c8d0a8690f32243679c968e4b19d6bed0df0d93465fbb2fdee86ff5627819dc9abd6d344660","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
