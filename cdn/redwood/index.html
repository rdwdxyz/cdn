<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c6a0d72b3956a20b2e3e93ea6a7e7f73ece588ab027d371fb2f0b7459327025651abbc40e4e79318e81b0330124aac69ffb024911943996f747dbe69f07a688c1feb90dbc64e7446062223b014547da6ecf93e846255ff89d0c68a35ff5d2f0c1c65915867b46f8d4724772ebbc4f581ed54a701be859d91ac84c58cc0302823cad2a15f5047ff68d62e22213712554c5eec5f72c00f56524ab38fae3e3d36762d9092fb3be83ffb15daafd2e74fdacea469aa3950d10906593e5cd85a3afff3011f4ca4d8c8d20fa60094ca2f9d2fc60dbf678328fa3fb14d241c67e921717975f6a22dbb071e6997c9de8711981e9d6fa7cc0fd5d8e0af8d9b67a4d780886883c09283254dd89d5fea604904c88a7658f8cdd9a71dcdd8a57cc62b8671c29eda1b48ba7c84f21ca910c609e874368e8d3b410d89fea81c5749a5b96a4ae6a2ad5d9e76acb4a0018f646a014e847e5c9bf4e395ae48468317ad5ee5802ddf0fbf99fa6abf9d5b8aee6ad23f62992c74f33a9088a3c64aa1972f2a936e663ad0f0eb01d5092f8207916d6b7f63bca774f15e3ccec9c6daf61414431637ea9a9296dd8f45070b9d024e5bc3d71b9d5ccca7d2c525b009a2283086dfde0baaa218718a949e4eb74578103318c36cad1cedb26b993a1394bb927e980372075e8b84e4268d445926a2e020fac37ee795adbc1681ad55cff32592fa909a8033a84988a47045963d03aca7c12105a5554851cd7bf431215520ab1ba40224a0b75cf47f6f30ad68ec5d1b4ae7bf67459e32ae7ce2c48e40dbae8febef37c8d6595a3f1756d18e46967f60b8e4782fe141cb9ddd2d28beb3dfc97ffcc8b6d2e055e858c08b260bade0e205de22726e6cb39e6139f3fa55c1423b1d98d19faf3ab0c5bdb8cd94772e9dc4073626fafc60e8eb1ba7170ab5dcc53607f546800c927e6508737c9b0f8f62db2c5a98978c8fe0fa6fb495cf5923b1d1e53cc8bfaff882a981c7cd3aa008529d18273bac472c2d7fc3a03153cb86f9d7f97d82156ad7b7390a2f188f04e16ad1f8de47ed4dea6087aa4e0b7f7df2b10e251f842b96da6bc52dd875dfbb060e2f8e8336d56b446ad312d1264de381eefa04a1b7e97e57ab10af32e74063b003850f71cdcff396ad957eeb592ef9e365b86d2c9ff36b6a07d32283a032cffc16ed919fcd1451d96a6035d7518bce16aa958798bb4fb93f0d7523708bdc933115c605d5a5b8736741ccbb89111fb8e13a5cdb4c43fbb47a67d74d4e778a59d43cbbff46dbc150992f603028123343a050a94ab250e531fd246b135215bf26798b6a402d7b0257afdfd5febd069b974e6caac9c5120966408dd4b1d113658efc871449d3e3e9befb2001e0064d0c4f4d59bf0f8667c0bc493b3346c890dbd9440ada58d0d95152a98e97d6de817f7825a8ae4b17ead3212d9a2d16ff1725366a6891403c26a9f17e75f86ccfe78a7f62f843a99057b9fc19527cb1ec69299319bff56bbc79bd11be955a414256eda83faa6e6d88e32747fc525ecb0c4bd2fb0a13d836a6d5d73711815bed770b83588dda6d194bdf691322b6ffbd775a57188c4a570b301fdddee4393b754812c5194e7460eb1bd0a0d4d947f5cf545719fb348b1ad203baf24bc780854909ee36af4bf78844fa8eaa53629d0531cead99cf1c6a16259fbec83d6dd3782fb05cc5dd9758f8f9afc22e9d906273cf0c54d53ce0801517becf1b404622f546ac26298b8d9af58e9eca1198e5ab3f415ac03589f9b9578e78d3b5e2da21a9c864e622060216ea52bd534af422b5e4f3ab191c985c5604c6b3bbd2526d96462653cdaa7b1ecb86a83c0265e00a0cfc973e2b286415115a872dca4a7c79cd1d2018cee24e04e1c9e55412a2cde4f0dd7d990414b63446a1fa77dd44894924c1d286ed75c40ed672b6b5634d3ae2b96e24768e12da55ac7f534166ac1855b54c28802d81177461f9a65abcc89b7927401a2cf6bdf6c9a8fc35ebe191a25da7c76660d520f2bd67191232a19eff69e93de455c9304b64fa505a000533b3f87e3a72761c2a0774648186e416a055c16fb418e898ffc64cf30dde95c4d52af285ca20f0fc3eb1b80de6d838b7cdad237099b4c77459aa2a9645797dc8bcda53967c43a57e3fd470e34eb7da33c45bbc68473fca512c3aaa7dba233a874af6baac25228de9996d3f6aa3b8e2e27ae61fd7cacb9f9f5e73626571ce7f37fdaba1ad1cd9431490ea4f15e2304a69a116613041ccd5068e59bf4d14d119c783efb1c93610f83404878a83fe81d4d397a706927bbffb7a9e8a305c80af732608628ecea80ddf9d7185dff6f036f83ce346c9229e512799e24218b178328e325744517c6d01d7c5cce2ba75fef3696d7b2f66210f29200c47987cd9091ed022457e263da739f0695e49598776e6872042cc03701c7a1391f673a48632ba60fd15333d60b8896f201fa009135ce1b33155279c411f2b81613f950a37288ae00bc15bfaa7aca732e2e40f97745eef03f231e59906451c9b907714051193eb6f1e3a2c2ee88c914e76b73c47be839f63ecddd94de5646e25a5aa2a77d59fcb0ae1c0a88f2a11e5c85e3d109d682454e5e920f994448c6f074c70b0c34c2cf38c8daf754f293ac1e9a0747d85604c2e3b10a87e5c63863abd4c58d7ad8c198e943b64b8f765f7dfeea556532693dce6e95298eaa93f9161e692f47ec7580bf1257514583c0d4df89c3a02c991ab0de077f97b9ca30a1f16a41f854a2ef76daead16eab28410e2ed4f3a3f1768258196862ab81ffd7e3c7be798117cff05c3ef27044e3b4fcbfdb18498f837f70bed0ea2b3d0bdbb6fcb3c5a239fa03e5c470d78c4038d6b552903c26b8cec505e3d564107eb5719218ea282c7843e6cb6a6895c35c993031ea4adf6726362cf3d43df116a87e9aab12f80a849a9a2fffed31324d083fc95ac3a832f0f97b8a2378273f69aa72b1e5877a117861a36265c936dfecef67fd16129d6a992024585d8d64c69c93cfad9898a18b62382dbd162e82629ccaa23a6c35149990ab758b72febf3eeb495cfe54684fc03e0359fc439f882ac98ffe42cd86423911187ff6c70894d4672ecfea5f50e1bf2f73294b89bf6177546b1e3d23b51f3bdb696d0479590e6ab9edef912f885d1927aa7387b0b02813f86f7160f4588d746a61208b53c38624c04ac96697e1278fe8507958ad162e9a8f46cf577bacd93c0b9c7d5f88c2ea15fdb9f3ccdca5404ea84eb5ffb9b0fcdda7ae32e66487fc898f75ed1063275bd6f9d00dbc787c577c37c15812c39428ca733c55f97ed6bec1155ab805b642fbb6fca28dc7145b00a64758d24ada6bdf90e13cdf9eb00abc3bbac4e04f441228ecd71366dc612e110288f8d80caa89ecd3f6628f7f8d9da50dd441d64f9573285fefcd6764d1141bf85b9ddabb4aa24049c0a7dfe4976d3082b1bfe550a7820c75c5b8f9a2fa4f62bc4274570ab4c2304de0b866bc471f485a980254023bcc2eeda4bc08e8488667f270fc7f30bece417f59bcaa2e96642296c33eb7433ea7de40056d5c01efec8d398f4be8185bf51d0abd5d7084e693137ae566d9bb0520297202a97bcf3b0fcd008a2abd2cfa0776bdfb3a9fd9038339df14df7387a3a4692824fabf4eb9a7238ec7dfc661d547671f2784f1883f7cfc073646ffb727e5530468fd230d5222ef3e6477641da44ef8372b1f5e556a46b21b2a632e0a78cbd24d168e734ec980c1c8a900e5d3ee044df3028d5fe1247d0139acb276dd4526df758e2fec4a2fc978e08602051f5c5c613a2cc481cecf6a783e6f0bcba762aef2f7b4e5d1a12e6f187c6166de364649e9ead22cc08540101298a4ba37a1583b1b0e551fd8ecac7b320e32c6821e2a308d700e69c9971a396f437ce08fd9a262f152e9362ea43d9466f3d73a6fb441c08a115ad3cae5c6cf67db71b661fb7b7e11818923a010acd589039ebba6fe34206c91cd0e0d8b6fceff080ec7253d4b745db361ffb7bc7ab986a89455e9170582a1cd4f7b970d94b8049985febd3d1b2c605e8eff8b981a7e7d406fc1c564b740f8c97f1a7d8543c128d9ebdeb81d13879f1d82ae2a4a9cf41009ee175707640e75249db601f3c76da9a9b8fa8597d15c1cda2291204551384a2745b79333c7f080281477ff875ed3868535833dbae85c942a584bbb92093962a5a9d161478bcb46f2fac069baa2e398cf399259b0ab0a2aebb1e48296b2cb6d2e65c1bd7f2e14a57d6f28c31af281aae1e0bcb57ca485baefea3779bee3bc1e51066c103e0ceb2f21f06fd5544841518aa29216316ed565dd5e0f5e4641694a6aa2af381043ab27fc4b513a47e58be129045b94352fc51928b2b0f5b1ce034ce43d2d86487ab760240efcab25bd8cc95fb46146ed330774a046226b7ea6881141fc997dc62c27b3f1d6dab805ab5fdd642f35ae496bbf35ffc1c42479bcc2b6f8dcff523391cbdc742f28272a18f4d20912fe42626c5e1f72d54da464240dc1968e52de9e056b39d8ca3b34fe23d49ec78fc3d2f1d1c598e141ceb1b1c4a4daeeb1af6f5858048afada72e876f7991cd70581e9845678668c890f9e227636c770446fc7de20d2957912445f4554d44873a4802162688309579c8bd77d2c839cb18a9c1bdce102b85a0e9bc8bf12193551a548d6a3f1761004e1cb0a5fa505c2c71a8978ee94cbbbe15799513779d4edbb1cb23ee9512d77783110ac292edc2558bc6d73b5d84fe2c030ba3c9ec64f49a6e2fe179494e76f596062e8694b11a6999f76a36717ef8b94a941f11c92ae7de28018df935a414d152c063474c5d532a03025a30c9c34f1c3e46dcc548524fe0a8406760bc34b27b51e547c37e091b8ce8db0948530546734bc5b6c18c9f2d24c322d16df102450d3e47e3132aa832cb8f96bf287c30ef878657250e2175460eededdb03ca9d16f8101fcc1458821cc2385669de840f266c2189a0c328f604ae6256a2410e4f6a47678a8aaddccd1b8ac727a76778a23f51830c5d667d253a15cc17040a75726b65de3bf7bf0ad7047a932aaae747b61c6600c4bf77bf422f47b22c47cb39741db9a402bb98720c8901028a46dad87c8dc353a782f1917f5ef9068a904d563f697f316127abf1f94b9ba1cb295552217e9ac555eb4d885fc46f2ab7e647ba235a0baad2ebaa144052db5ab148879de37cb5ec28a4f7c7bcf638c9aaacb20cf6b7bdab8c00ecd1c79b5afa0bfabbc0928611722595e65db861512189b5e36866243dba38504ce69c3b2c8a6d5e886d4e3cd5c82dbf48e2289caa34a08fbf42c52f17893dc27083edc2d2aee8d90cac0e76b7bb1a22bc3203010371332a87d11e7110bb6245c9613de2fdac142629b88abf81ddcc9b1e2f400ae48e46293ada8521b0c31f8f53b109d7602f8954cec3c85c0dd90aa72e35285494e8019114f3f386f279ebb73a1766e567ac7af28a4a841cf0214cda12870c40f26e8e2ab4ef550b2582da90532010ebd7633bc80543c0800dcab11d520effdf702498652a30cc53a24d622e8a7b26c4fe65788059b9235742b2ffcacab635e383f0795b61b7a6a5bf2efa80e51b3315a4cc45b0f250dd35413b74393c0f720e998c449a1a386e924e6a602fb9faf15275ff7ef0e7751c226ac041bec870865988e24ffc054ffdd1902b0243a067e5f52d3431fe45791394da56aa7d7f0eb6c8485ee3fb08f49f9df2fb18080544cfb03a3072e407f67383bb82e377293c95181b78c61e76b2b3f29f216549861ccedacda3328ec2573c90c46f22579e0f7ab4a5938775188295562a1cf77174a2d4155060bfec41ed9f3f0c6c11f871ebfc0181c30d227f5449715b945ed23a02fdc31ecbd340e6697c40041fbc86db57bff5a488953dab02b4e3ffffe6bc164b5f01eb74e710250294f7a3a8b992046eeedbfbfe413d59181f423697ac2b6f7137b1b65e0c239f7f0e0a8f89a5e50d754bad38298fded18b4d5d43fce9620ffd6f8a722adbdf679f9ccbabeb63a49e353a8552c7bd9c413d0720a455b6cd398a44d82de22c18b66f164a6ebed1b2e18d04fdb63e5955d56a8c04afc9d22eb15ad20a461bb7011124619b05b43d2cf73d358fe42416597545ba32a0bb31c367615872f8f46a2fb032d537a9410cc9a21b8c02145b93dc7f39ac5e38ef6929c9894915c35460c3e19a89a004e3f407c8d4d8754a3efd13ff13a4bd8091a7d45ef5bb557c09f90f47bdb8ade4efc2ca905f55d9843d51a9b42ba9354e9d71899e85ec92054a32e4328bde16acd5037451ed077a0af5f0fc0e68ab6c0f3685a8ff92a811f0f91a802886d11452f3bd5d33359ad3f5b90c3a0ac6189541a8c5587e37493618ba83cdcfece685d7a80a06adf9f78416b867e4757a720bcb94cd419f8bc7a192a4c95c9a58ac7868f1408721b406a8060d69c019959302d67848b3d8d2780d813f30afbd24e44f212aac4beb191318346b0b7218d6bb507d0f7fe980f84a768a2c07883efd81c02e0f877ec1e546ce289c59b410484d7f2e9170d9618a6466fe7fd890d5441257c49d572571046f60c7b943b004b9ad93772214be26b5909d855bf0fb9c047cd5fd1fdb3521a14e6cc412fc7e428f2193d175c8b00ed173a7c93786b851f5a7b0b7a031f7310bc1c2eb9c8648547dd26cb7ac488d9cd1d786256660eac6eb6c9aa5cfdc725944b30f6770d3f0ac109b69d9fe94cfa536a83c1af157b7bd842da1bfd3100027dc810cae3e81b30918a074daa020bc99aba1ac622098d0a53bd3a3e32887ed4b99b3e380feb2a8e41d93727635be367eefd5d0e89c21df25aaaec330f16778adf51b98f99cafecb97838fef348876f4b2ef5cd43f39c25949a7b2795262d248f016976ef38dff627a6257df43c308cfa54999cad0d75dcfac02d8c5e11c61ed776a80113ae26874b111f775ddd0cac0b75858c7482aebd3024ec4463be8646647e6e1169bb819fb71ece041350ca0f0992dca0d6874ec6d45d7fd2da9e3c1d2942f23424d3c98054dc6fb8fc250db42311d8d70d73555f8bf9fe036533e55c64c9965c3b3ef5073983f3fd156576561e43262a7a5ac1eedca162949279fab0710028dea697bee356912b01a0b4a18a50259be06cb77263ffcaa64dbe7b64a8f107dc4e254cfebee7384bc8b33ce7fd983f33a3d3c382b6ccd34ce8f48d769fbf1db0489876784a2cfdaefeaa0276db948c1dbcb845d32e604a788f7ed2e79a205082bd4d480a9a3268da08bd24cc6e0e45f58bd693ddb6785ab6a82d7453ef0fc9129ea86b9d62a6cd7782e7c23294f79567d403d05a8777b792736cfac98d447c5e950303292545d9051196af612a3acbfb29777aa1f5f12e299c9087705d62b6ec25a1776c40c45116c43c89ff04116d50d8584d51bd9def3a1e0ef562f41ae126db1f932ce45cdf5341b04ed16bed2da0a4eccb9b20e1cc637f5fde3d418b549090f10f51c8945274db3b4f36d4809ff328b941b17fbfe74a79718395d7e6537bd158c6c12feda88a2727bfddb5d6ea34213a2453f64478c6af1baeb9e95f055abcdbc3738377fd86a5aeeb7ec2567ea7b9eabc732bfc2bbb33aeb30981dd322c04af10149c0c2bfdee2e60ab6dcfd10033d7bd135e2fd29db58a2a0954a58dcdfb245c6138722d25dc8b00b107ebcd20e07ffb6740d96d042e8f14e2ff59283c624e79cc0c3724119445e576969f1d21b12f77ba05ee5e4db84a457705f44a1921f2b1a95d105864ac4d4e359597dbe041dcbee7b7e6bcb7adc3639869922373af6ab020a785294705b7301c534909bc690f67e92d18a19572d2dadfb619ecbd30ae231dc2eda1d06acbe4ec4bf27544fe28236a5603b9bb14dcfbbd9f73643f934d3906623d99541c0609cd49924e201fd1bb14c0084c94bce145a3f9992590d28aae2fc7c0b3d2a3b422fd2e021aa4c808f751b84521dc8cb5dce0c0d31b871c2f8752a523b044b5577fc796e92aa5c6aeefed5155d024af72549c3c01c6b8a177469d77ca68c3e87eefbd5b4f283a6765240fdb6c4e1dea56f17042f3ad7b94b0392b794e769cb1a847d2894aec8ed93f423834fcd4c723d3b7e7ad9d4f46c8d189f4bbd98d273c019d4c9f4f4d35bc877171f2c1719c818a82b47d29ec86d2f1a94d31e58db13697bd6bd0aa1495a522d5eb23a2d8caee2ba08733709ebe8b266fbe8fdcdd8b0dc7cb186aa62c4d5b01c654b02109b73a69989561a668de5aaf2dcb50d7c86a922c6d97864608f56f4e8317926d6babcc6ab47b3cea29f41b71ac16eefc54f8f114ce5ddc12244de47a1b53f06cf93c439cfa848fda4e05ba02970586dbec18c3d74033cfbd699a723623c37e54564a95075d214c9a0e0efbb4525c6b01a893e44bb2800b9ce2ae9841b22cec62ac66c012c68b383c6269b8b063fedd11f8f3449d62989bd2396a94fbcb475f84a2e926562aeb0ccdbe6cc279437bf45f03663b8972c76ec4bc16cfad77a8ccf735e192b2bf3ffb43a47e7bf6d019dc32e9b7fabae854ed0a2c57bbc6661bcda076df2562c7e4f425490a690fb1e12cb9783500cbe74c101c7536141232740ed9b1a3c21efd7769d8ed264939611cf91c2b39e6ef151a26567c4b805d6c43e017b74af4ecfba4180c88400398c2a8f75d32bcf26aa922ddae11e935dff8a0a7cc1bb28d96a54ee344695da4ebeead09ee234f2caf0a4e357575da3b6727a0a749b8b3ee9c20fb9bf4491aa76a87de840f2262c3002146e6e9a7efbe274fb2461dcf7382aefa5ce5582934a10600ff4b3a0b1d76debf79da3327419f2aa60d159812d88efb1e59cb2d45103bc4f0fd17428ea1c7fcefaac2ae6640f144ef7b0364205673ed1f0216ca774d54f0a500b5f560db9f5a92168ef71143ef59ce6c4cdebf975660d30daeb4eed5191c8c4f6f0d0750124fc477f1d76c09ea1ce838e75c173100de69edf540fd8b0c02c3f54050111386cd5e9a98eb9923b03065caf184304a89d34e9e72db6a1cdd09750b1c558eec8595346c0b1ebb036b05339bb2fd0328959956d61821b42018323f1ba31e31f89b2bf037419f6be25c4f1f701e5e1642f23cc0c7d785d6c0d6799eaf4e7d31f3f3cbdc15dea7098ae4e4ae72397a416f573ded587a4b7971e94f983492822b3bb6c625e16927945bbd85204e462f4a877ec164d7ff1e5bdb826144571e6224b45cee7133dea3aa7074fcde6466a8cddfd3dcb5a42cf745621b68498fd8d488d57024e40a65e7706edf094dda414b6a351cc3828f58bb0155d4ecfd2e0d49bab3cb3c24d94c75c2c1ab6a72e5c08e9eab50080e7e404f17196782ccff59b252e40da84dc940bd1ebb9f70fc1ebe3e532667280d269306019f0acff0555e7c1bafd67bfc37bdd087956f5144ec033d980da38ac95ddbdc237c89fbd54f6758e8c28e3fd79525ba31176522b2b92a80c516afd4d6352bb321114f8ce5185e67e6a47191efc316bec64c56da5921544edb905009eb39b0c7fbd903036ef27fde859284f7e7729ecf1b78f4d6ac86607f3f752ee3f3fa3a0702ac2ef1b32f6ec58e9f790d1977080c14462711d83b830399b5c9357e6e20afc28133e4ddf4fb47ac4d3ce4dfd1ddc8faa94b6e603afca3fec90361677959c13a6d8ccecf5ddc6dd688ee1c795204afc8b5fba26f104e4b83474e6273613ae0bb9c0995a6d79201e8de32b3325a133340359b1531554be7ff4b72509e0ceceb8c7e09eb6907c25a52a8ea3f63d8031e8320eaa539215d82413f508137122bcd317565e51b048c8a50bfd58451efbbc41b9474de6ade8817e57088fd451af24261bbe62dd6837102a404929a2d28862f72b00c9211a8402b45eae1c90acbaaa613ebb607d41874f20de3486fb55fcc97461744050d3a0f6fddc2478f71a41c3c538cafdff796c45d0813a9175304530100363bd8f1588ea55eef3f8328d25004855123f89f6d2472a8e40cf2d8ffb61e5f0c98c42f7e614c9090d9d20276dd9de6127504626de7c119e7f8cc1f39db3c5eacd0c3e24cdf107158e9672bf28517e227c19b5d2b8ee766f15e9255ddd1fc8edd407af121886c3cd8ad963346178a3028952b92dd649f4857fc4e7f0d1ae44710eb7d018d40d5189a6506b7a420c96519569a62572750bf729b6d783db4e2c8a6be3f43166f591ad8acd50fb2b37af6f4e2c46c84af4057afab58b53d695d687956ec40fa960942c1dea8bae2201187fae57548420c8b337464ef3204183d7b8c40fd1865f82f212445027853f37090a9983ed8fe7f2e9bc5562b5dec19c9453ec245e77dc65c9f850046c96f3d4aadf7e3867584554620f2f01c09fd56323a888b518c3f7b1f4eb9b0e41688018ad2f9d743971312d6aafdc2ff7e2e43dde394a70dd055cb671d2e5f1846dc8953c8a8bf548a1898269164196d4a0b75e3d028c878b7b22b8211941bee95eb6a9e6ebdd3cb468b666e9849f931491bb76c8ae2d075f27d65c464997fa445d2dd5dc4c331afe992bb98e905a09d28cb03b9693e27145d1fa76899cbcfd2859465364276524de6a067caa6c302e4aee2fb15d3aeb8636aeda44cf98f3bd63ebc17cf2b68a78c743332725cc2b3ec0b4f264b8cec87f4697e29a031fde97d564d9e0297fbee78ca1add8f46803221dac2f5e330f227115eb3beb663ce6fce5d0627949e19dc53d632de5f720122d6d002bebe36c8232cb2bfc8c05ac6a2c111afa0d32e95aa0753ecce928be141bfc365af49c705fd5fd57fb79e1cca72215b95ebca47f3de25286a8b4a35c1ee63023b2c7da04a22b1ef84d8c1ef9306f3f3de576e35318ccffeb4235c898295300f22b9393225342bd7dd284d8ce5ad9a941efb281a3b2717072d24b195e648f14fe3f8ff6628774b4e1891d35f53d39723f6bcd81d0cb74e255bdd23c981b5c21646d99bf689ad9e6ab136e4a07b1b56769149a0f0da450d8cbf4d577967a1e7bd96137926d6f808ab3fd2ca7b854723b83396ced9e06669db9c6527dc76a6fdc7a667f49e03af3ea0bbee8da2bf3a261eab1e3b6eb9e8b9116ab82e54e537540819278ecd5595bcb6836987ebf4a4f0f79d193bed617da6cc9ba7003d0292efd7b92dc8ad107042ba6060632d15ede282a58da759ed1e69705e24b7bbe63f47de194f48897b17df082d27e1b5efb7896414f883b679f6363f0841bca246c8dfa59fd286e6728be79c9a4d7baf7420024083bc0481464fe328b314a5135d82b1390f6b0706a3fcff40b131bfea81e7ce6484d30f63e3b3c6ce930fd97cb5ac57dd81220f02274114d18e6ea94ac6f549578a402c8b84ad139f213611d2b738035caa6e7976704171b9b44b007210ae6454abd4c629c6a2ba0e2af8477d2bee76fbaeb54ce147e652eccb320ded91a8d7b9aceff1f664cd0457e239d91086ab47b1d19164d5a37dc34c6d5b3f5fe707c921f54934891717eb1d40db9565692b85bfde7895fcc8797ad919b443742d538cba844fcb7ffef91e6ad05d286db1c8d6910c0c1e4e32e8c4ed3c158cd552e341534ebfcd24c805fbb5be815fe8768d823270286773a02d15ff353e84d5f937c1ce311558525207a7d1bcb2cae280d001479383d9ae1f12f812a2fa4e83b668efe3324b90b4ae1eeb2b9be6a063734965fa64621e9991b11586da8074abe18f3e791e85458120d1766d9b6f35d0a71206a3ad9d9b18c4910f36d4d92429dd5ab1eeb3b6c5deadaa1f8a4ba20ecc352ba098feb8ccf416c5affc5cfb093c455fbbb490ea0b1f264cc831bd697de9b17a8af7c5216edcdecdf680ac448a05343534b5db69a21ebc084c1efff7b6e761a48429d03af0e1043e2b78b4710dd06c91a96adde329afdb52ff8b3598e3ccbe03633c06533d6d9f21af303802a198629df9a51ba86793faa8e50ebfcc7ad100d31aa4f191c5e774d5ecde2ce920837012babb33fcc5681641e790132b66f1a45815f81ca9283329af20d0458ac819bd8cac4b687f30c944d1d630a9046e337783505e8f9c624bf55fa692ba3c0777b43665210f6bac3f69519aeba861dbc512f1ed8f2f31ca778bfa653a9b354b171236baf34548263a4c5b6d0f9ee43480b280e54b8f18c3cb69a7236863b896e8c147552ac2590934dc989ba4fb3c15e55109160ed0d38b61b2fb476015e99c939f37fcebc557ceda80d5d085345ae2cf6e4b29c20b7f163d4ea649c7d4821d46297ea94008d77e0a0869cbde625fadec98a37a73beebeda45050373ed16559ce3ebe223e87570882747be26b720b7757ebafad0a9845357876125dbc29f7646404cf19f83a4b3d8d87e33229ea037b497f033667f333df19e9354b8fd8c788a7976274f7d4b4bb8f15bd48f4b7c00647ae47713da04c79c01640f6519a60673840d37d0573febfeb91cfd2a6cfc0f5ed309d6ea936ab097d18eb78334c56bac93fd12fd1906d444ff8a9c05b71361425b7940aed630fe9ab56823a97c64064012e4c8dd8eb008d88e4615368c01fc6e3af263e26972b90ea89cd31d607f315a422fbe33f4785ac7f10a4cf032fe1890cc6c712f5d4b8de95db4a38b9df37daeb468fab844cccee5057b5d1949519ba5d5b946514b69dd95ccddc383e80f8f312d3112d2d1827994d5ced5a5cb61da14a4732a022d9be6033b037838cccf82eae8642f4667b3e2a33312ad0e6b4f9a2f1e3f60f24405131d3438291af8f4722315ab9d5a61a039712c570ef9e79cff8f2a37ea173c3a4ca49293480db770d83586835b808a7a5190a270ad53a4467456b20ed06fd0b6badf274a4e7c501a757d3b5bacc260ff43ee229532b1db4c0eb4f22466d674fed2b012b0c919263c6689f441b98d172db8361f200603afd58a0e1e156a2342aad28f6a8ce4fe0cf4cc0d96c1187f8d260da0a5654f62848ee793a823132af42098aeae7387f22c989590c74430b5066d18cb03efcaa1c126f2798eb4a4e3f6175d05fb34ef493b62a8fd11198506fbb9ab70f115481dccf657d3c63c0508e4ab6099f34b6ef7f73d7c6c3f3a44c848e1b9d38b5b4bfb73261b5151bc572f958295dcb3afc5a97a9585cd601c47dafa1f32ffcf0cbc49a3545e5cf59948bc48665f00e9a7c62857e987aa150df337537b71b1085d3f89529d996d129f1968b4d38b14a52b7a28571e14ea5989ada8e17724f91a507811c0195f8445660a4192ce8ab77dd82a0dc386bdea8253a0369d247c9654577e1124ae28d279d61bbb017acd012ee6ec39e2da551111f7886c921e5dbf60c1a91b2b138afe1ea7cdb7dc7b14db47be756420d0d2fb5e8072235e04dd890802170e26fdafe964aebbbfb471ec2deefade3ff96e1e01f80cafffc5a8b59c80f7a72c77e86f30b7d893ef76da0b0ed0937868cbcce7258d0ffa018aafd067a75d8e997b64d3a49a020826abac698d20b0fd624eff6312ca27a8308b94cefda9e7bd49d480fa2d6dbd564acb242ae34b5adccc4059394a8119dbbcf0c059c82e10d9e71fedc73abc6be160c5c9ba057f4b7b60e3d2f19ef858126631cb61fcde38182f46d65119c22ab7be109fc07227faf4213725a99d4a453c7c5e17f0387af0a59031e67a33b7690b36fab2d4d26f9ee9f75468ccd1c622663646f4de637a93da81f507d3d36ec706826d3d25a3f2b65d86e0ed065013a5f501900050d6d6600abb7835af8918025e31389b163eabebff99eb6ff87047e71dfb5e63f897fb3060d210955a332248f1db4c6fcdbfa0da2e70a7cb552bb367c62d9b642737aa2f11f179fb18850fd3f2ed37c1090b4043fc66b78b3920ae7866dfcf238a0192cbd3a129ac6ce3ecfa37dfd95db8f934d9cc48a7dd85766df1bf4130adfb6f56a99444a8fe50e3f8655f57223210d4afc6fc80f35bda4d23d9be5f125822809ea609c1125dc81ff68d00425f05b705c9209c860d51f05f7119e8c7c8861d729a565e7ddf3e1fa1918f18536b7d90eb9f274145f992b7b6ddd9393531ac2ddbaee68b07910037e2e7b9ba1626005459b2ea50c007f97b416a3ff2f5754e6ddb2ab835f3e424c571f32686c6c89319a97f6f4ed2d84b2e81a3edadf667c1a17e4ca452b264e08decf8843ab3dd8ea994f340555a95a6cd492917a6c65c79e1fcffb8e847b2991a4621e93115e62a1b58254a864e09926601e770ab0b80bb17f76c08e2c9685e2e8915fb5c1e7c58e3168e5b870f7d62d1470bb0110f1b4041d8ab631e81312d3364318115ed84b455653dbe7b63f5305b40fce68a95528f08ec01f13fc80d04df8d0905ca8a4bc8a1064038809fdf59fed5eeee1805f936d92dfda87574320a2a738e8badb9714528b12dad5a38cdf4dc7fac607aaf3b48eee50f718c04709d858d0bb72eb2394333b40a7ac5e7fdc7c2600a643f8c4d582abc429ef174320384dd9130b59fcd116cbdf50b038425b9abe18c8caa0e2feeaa50f60a36e056ba22f33a3b1512832a113b7806b456566331de011fd54cc686d28ac9fc80c45b1e7ebc5e34118b5fc9feaf208e8008f1a46e8c7fcef30f4be8e3c0ed3181a7e4bbc7ba32c55e0f17e689dbbc9d1319224739e92d844f7ca1941c3a77afb0cf0b759c773a41bfad4f3c74ff87ca9a52876e1ba704ff52481d3f63e08a513b75aefc287489048a862f32eb78797ccb8ae7ea4fd93111788e72ae5f6c5e7bd1bc777470dfba6ed0a393e60dbbd9ba33e2e7e11da13bdf58f3e81df683f0f9ebd1d338f6b3ee11a39e6079b7825cbfe00249814d2b2d31d80372c35029bf076a93069f660f9d2d8907b253507eac047c03862d224aebce6a3d81956d56dc093cf912d47fa0d7bec2f8f5c05679e75954afbc220290a9a1be034e8781f9d96bbb392bf00220733631fa4b253406d3ec2392b908b017259fed879f9087183d851e93f570eef27477f1c822ed00652235577d8ed2366b7b3c0682bfdac119fdeacaafa6237d01bcf32b480cbe3c0107cacebfe8efaf70c3e990da50047536705440297cfd5d17d24a61ea477eb604c7be7ea4f9140a66c7f1afe647420821f6cbc3d7b9e41b98fbcd606369fa95541ca5b645067562fbce43207965c9eddefdc2c7a043eff2f30f1ea99e2a73d3aeaf9a0bbd7bc88643037defa4f5e7a9995701a141054098453d6a40f8e44d51a185614367be495cb256514d8bb69ebdbe28319e658c1e75f21727d9d3517f2e5c78af8176f7136c01e0dd166e36948336c4b97590bf73ef9dab2dffc0684cc8ec1136e4168b326dbadbee7c5e2aec1cd3cabb2d9764b2d574e666cba2a219911cde58376dbdbcb2488a595c9b2b299f8ce3dce0dc5c9d4fb0632c8e84c0c9b8566d818e49911892d84f5b3a2ca5bfa50aa8d0d296b2de1b673877ca31b431279d998797d9fb9c1a289dd5b26b85a2b0bea8709993e137fb738b8f6f873f21a43db2aba39cf3dcee3ce89cb95800397bf89c0078d145072f3a884afb98e292d27b6113a59f830a932504cbfa50f03ec7e56e269c08995a63677168f70302e46ce090383137301960eb54c2470c8dcb2d15ae899e91d0df36b4512d5fa60de66daee487553dea60086c24697288ed404162a81832d09923a4a3e7557ff6a7db00a098f0eba8b7fddaa32b1cba32ea7536f50e248e4f3cdd41db99a5ba9cd3b5a48f51a450bfc9a474ec315647ab5ba1769cbedb176951a483f70ba3e71e52b20d4f6d76a5ecb56d8f9524d00fd771ba984fd65ae50fbee865ea15ccb5d097d48ac28014d92c72642c65f30247601031eca385e39b4603021288cb695f56ff635f8138362521e41f69bd2351273a2ad91b05f400782571f5f6ea79af3160886e662097b97cd2382f208084e7b2a1aea35e0546e44a764ec5665eb8fb83c35fe6970e09c08b38f9700f6bc6f7c753258cd6910eeb0a76689f486e9792c4346c1f8cf48445af8e96f3a31d14ff1b6d1a164ded8016eb572b4d96035e5af9ed24412e987fbcbfbd77b185c82533f0bc3321647d4b9f9269a01d54fdd0a36e3c09597873c9f6fdf86cf4ba3a31b15eef041bff87069a3b33e9645dd4e86114a61ca1152ccf9e55b0085dd28098c9a9782abc2309f317ec1c312ebe3a835b61c2f12f9886a5aac9aadcbf7c3ef6126b21de71756fe4e997a2f57753826bb2e01bfb43702a416d625a5d760a9e73959069f9ce39214f7968a826014257e0518d7cb1f745f2f9ed874522247f5659c8aa6a4af650b962c42da0c82c7a1983ef67055ea14ce8abbb0379d8fc7ee0efc06e30f21c5ff87649b978f00929ecaa095ff004ae50ffbafdc4405480edd6be5fe8f37472f477d0c5b649e063d23f950c7636173677f75ce2c04e85c501f8a566066e34090145a27105a09c16c95342ea8d73450953bc22c0c6cdf481fc73ffc31e97087e9370aec487d5abd13d066317f1f165d14107721a9479d965cf93bcf6990d660a8a472af75bad76ef4ef6ba3f39fdbd529a86e8c1c1bcb98742fc8e644686d03a49292e683170cd00271d826c2a38b1f028d16c82f2ba45a4fbeeb9dd75e047ba859261e9d108c30a88dd83a78047c93eebf3748a3bccdd83cad35fd3b9aa4c2acf26603862661c231e42820bb007d4db7c1686664acb1931c27ad4d84cd2faa1558765e3780e21b0fa5ef38e33c0ba9b31ab37d39e7fff40c4e7f5bb3063c588ff886407d5d9fd0dd209200e00223e1c6d3a5d07a4020fdf415ca6849a2619df82d021dc0cc18a2b873fb6217d683c7a8a513a54b205f262703accdac1ec744d32a8a32bc83e2be6a22d9721a8569b3321ce3c19b146e8b073d114acf89ddd3d3e0fec23b3257f518d45b66e887df35e91dff3d0529102746be9b8c1820eef885ca23ebb79f0def1525e6d2d54cf0e7b90e9d975b00187506f1692096d1728f1724d7691e9736339d255ecaf41928afb82fab9f0ef784e65e985f884ca5a2aab4505550e3bad19705cc9b7e1ae8d61cef9d349b612e5843f6762311f8ac5127e92a7a0d530739d148143d3d74d6655051c9a1e4cf3c4aa118703e312a16b1389d4db5e55191a1e163e54d6bbdd723f60528cb834b2f5321dfb294a293b201fb67b15dbe301df2204f9566b68624f96043d3440855756b69c4d5f79e6dc098c87caaec400653a71caf228d7faf4d6a6184155399f8bca21b48e364b716db9b325f828d15bdea319e5e8439d472ee8e98188fe677c4c6c36a802ae01791ccc95a3bcc86118094e20ead44ae007e204eac6408a2df8100c2a2e7c1c2c61d0a4b0cd0de5767e3df7d50055e9f7c243ad9a61c376463141f7957ff969a5ce80ca156042e694b22f14908ca33be15138cdc907068d386fa94c3cb0bdc0f10254ed7399c4dba7f094ec8596e0ab46ded74e8300f8b364e957f3a42e29f35a66f843a3dd8fb83fd18a06c93a32b6edc8714867d380a892b6857b3bdf1bde56013af4fb87c1bff5e5f923af14bb7794c7a970e3c2823ec1421511de7a5b6e7f8ad859238dac9947cc3b1a23dca2831105dcf3f65d91885197f5f27eaeef78b492ec07e2fb2815869b7a0528ab90e712d603cb98baf8f074f919d2b6025a115f697af80102a44483132620e20e6d92b285a2765b54c6f64879bc37e808c79b21a7e244852e851e112aebd7ea5a49a3609da4bb355ae52fb1927919005163ce13fb0832046d0077d3879174e33062f781b28373559406e04e27a0bf5e67836e5abd9441959fa9dc7db03fcc28110023291392965c897671a276e9abb872f35d69fd78aad8c6ec99764c3b9dd6a49fc15d1af080295fbf264aa4e8d1603745e98994a9673effc50ebbb8e18ae23f625ca208a4b98a86c798004c8cfbabfc2a3e5085124d1e12e16184c1a9547a05406bf100c52fa1ecbe9e6e88398daedd35b80c8de6f2cd2e56e3c57e8717d85bf01e5295f0a9cf0b3c9df4df44ca9cd2cec3006acca310a30fabd641809cecca39b9a6f580941903d22b4ab4b6d0982aec31ad79133abc8c7284121b3d411cbdffac46047d29334efc9c0da6600e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
