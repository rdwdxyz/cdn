<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"469ba05a3dc6eca3fe9f6b2367e1837abf456c326c356d488f8370178d96fb36ad331e5679d41b9323e78a993a89d6b3ea2e67e84818bdb4844ad9da23c8eb54d2a6df6c117f9d20c7b1b924e65102499dea62a40085a3437e229f064d6b87bc912d0f621b0e350ec56c92f46d5c3e66143d54640e55216188fff665cb3f9a5d30c7087f07c376458cad1eadb30eca397051810c080380fae346a4261fc6134b0d68b4f8e8d4945788e0713545f340fc6517c5b6390a914f608a9ba139c05104e7ef475e2c5ff9a1a665d14c97258faa3168c8e02e49e782731147353ebf5dfc9eb3346195a3ba9f94d310882480199921e0b0f75e4831b538d1d27eb10cf91fbd43556c2403cf428a7808f15964dacb684acc4a58e555edae9812d237b59825013f143ff9753c2ade7fb42ddd07596a3d266d451776f6404e076a9507f58d0ac0b3ce58e786b5e4704d0daca3d75d663798607adfcfd0b01ef2a63416bc0bc28801f662dd91742afc089a9d4d1d2d87741a464cc666c1d1bdb4a5bf8fb4ecf570aae485bc2d254627c55e5c9778d6e4e06b9d791eeb280d05b203fb0f3f177e87ac34aa5a2c3ff179ce5ea65ec95d90f698256e5759b3161a2fc54fb5f2bd6b1d9e7eb01d0417e373f1824a790b8d354239e00ced325b679afa640a90360edc546d9911c39707f6490a02c5ebbc717cb1218d007b2a69046fec48ec3c827cce635f75ea0b27ed4f62daab4ae94d15896d7b84e483e256706cdf4ab6567481d986d16bcbd3defcd7d9d3d68610ed4ea4e8e0a4f8368b69aa9ab187103b73fad70de11568229943f5ae2cb997f7234a8407b6ed49a16541d00775af9f441251f12f23c6cfbe63512d475e7625b06d9f8dc0dbf107e57e52db40078dfc692f0a0922b379a397f1693f37ca2b8a96d93854fd60541d03823ce55495766db6513d9ff58d8539fd2954b9750867c019f56c69fbbbfd3be377ea04948dd65cc16505faa1a0b3deb78e5121393a80e02ffd366df003348efbf8fc8735c1896c35f3775a44c518d290df12dd79ee4d85c13127e7cc6829d13db22ce80df439dd85dd633d18c102a872551ab4d53aa772e3d01e177ab49d17efd4aa874cc3bfa10245276a8c697ccdc64f43a814a85dc07d14303a9b3533f598944399f1ed86ac8a603e27197f05f28c4fdbcdf36654662bbf493529e1f345e762997d5ffd1a97d256a474fb373fe0376c9f46252d4de08274286d92a180e54324e0764ec8295c301a10187fe84b5ca243d5ec94901318e0fc946f871c3da8a23768877adf19664d24c6690358ec66b5db69bcd3b95d0e3411d6d9f7800cbb8d8cf810ff7fd0d8f3e4936dae0a44972d2a089010a38c2a8535dec069df8a042848d9d2dd8b046a0d13934991dcf37d7c4460c24d1e2591b385e5d0f8cf8586bc91ef33c41100aec8a1ca0ebf2f09c218fa242bc35de871f5957def595ef1de2e85c7c108768540db5ad6bdceb6b39366890dd4f18307138ec8332b135f8daa7e7ca00a06971b93c8cde524248ca6eacb375c945b5baff7df992a7dd65eb96d56f0cd675eb49a40dca61a0d94a14e84fe52a58bd3d24a871a9a0ca1ab4b5c9fd6187d7209a8b357713aecfac016b145bea6b3d7e0f1a554e35a895439def09627324845bccff5fd4ef0412e286522ee63177a58a6eccd3b6a45fa330400d773dc35fb8c894f8e750a5e561a82e10643bc4adbe79e1cfa9e1b760365bffbc81bc5689c8834384715d70fa45e624b735d0ae9da897144c5b203da21227133b431224b972a1bd40030e5834f055b0d06fcd2dfdbe37c5d5e196b2ad55709436e71c94451399dc193b215fd0fe98b512d9eaa63924b1164056bb0d750eaee12fd07706110208322cd0e8f2e4ccb1483ef7ed46ca3bc486042d1fe28b6e8786e4942177bf3b43d70526811d7ed3d6398824e6eea1d040d6f866ade884be964998b2b8bcc8676dcd4c79b1cd57bbfe02813054e18487d74f82272462b365cbd8a2988546f7ba9f13a09aa5aa544ace7aa3e6b9518bc8b4c15fc8db823c57a9bcfbe2b00c471d51b8c24838820e3e381d004394d948df434774e4ee684850abc97681a88fa3d5a97e8d68675f22641767f96a3e0f25c0e15d012d32667323841521aca1b0c743383fcbefd3c317bf6ff58ef1e3a88ae04c7a273f14342111563d31dae2dfaf2f7bcbbea7c1fac47489c1dcdcc39471d0d8e82cea4fed01d8acd5e109aed891fa018c8b00d0229c24460587b91ea88ef85a658dd92b5f0c2e7bea504207f6a6a9ade4d4af510e3f24fcb85bd4e46032d51bcf3d7bd5ad5807566be1eaa7148f6342c399a88016d4fcd1512ed68a9b2d2878c55657ae12198c86261e85980c6473dd859e6832b7dbcea0dbd11b142a7f2b7728dd7956274c6e3660e106a4d361597179f2f681efda00b81a560a39035975cb608adc6f35ea2e0a1b520198372f523580269f20f4d95d40a0f3b6a30025575ce8992fa386ebcd6d04e6df418cebd74bbd52753f810d3a79ba757240bfd64acdddf1d64ca7618e34da981332a56cde7efabd63b7d2d865518e985e49b632ceb760d300ad7c7abf1ab2fae7a0d684c86161a1c07b67ccc57f8c8b3b1cac42964bb91af6e1d03600ff2919bcdea7c0310ee406a02e71f049971ac706791f2b5df086453af13ad1f5c728eba4982536b7bde6d8d7b2dcfcbc9fa016bfa6a73a667c88d5170798b045337d5313b4706600142a5af98d0552173dd7e33361bd7bdbb44bc9def6887258577522bb7b44af7475e3657d98b209ce0b1ef0a893bbaf84a9efae9fbcf604ab37178d7d08e296ea34b5abf5f504e2bb37ac23a1972299952984b4b7e08d966a2d13197f35224bab81b3679c240cc603b2305c5074318585f87b45342d8b7489aa1f3a80f04657c5886efc322089a93932a4340d79cf2717475900269288c3932d9b4b14b4a53dc503bd5045cc188cc74206f01def64577bdb91021214368fec02d9bfd738c1000d3779a1603d4216f9bda87215a2d8dec88f45854611bef6891e37b78a9f90f38715d4a1790d0c61ade793d3dd1b593ef68fbc618da464b43939bdac51ad98194a5daa42d47b4ae4afca6a06a44a7bd119b6df4a520ed1799208179e3bad3b6aa636eafbd182a0d3f38b39925ae1db0237a95c0efe993a1030c8bdbced064c9c61cb7500700c1037fe8d324ba950e519957ede0de85f0b8ffa154802203727d6f903090010d74708da9c5de979a9bdeb4bbb5d5dfabfbf1a44d5ca39c37b378c265686893989cbc46354551d815056ac59e8dae56fd9e9dc45e18f6ca74e4a0a88753aeb03b3f5ae9bcfd8b0f26438b8bfe3c45a218620b21fced1061ab5db4f2762495915c7ecbdc72d43ea1f830fa1a76906520536ec5ed29f7b028669c163c8cd5080cb42ee6617023ed74e66812f689be2c32002b167b008e1373e6283ce107fba7e4a26cf4973a97f54a54ca5b14c23a4cefb58396ce11ed2c7ebe8d640b82dd86e9f4312cee1cac91bd2268c85b30febd4b8f5035f6b8bbdda94b4e676ae7361750c4406212fc6944b340affca8f74631687e0ecff07f4a273fb687c80f7bed7d9933f1c8065edfba44394a7fe2f43d8badbf1fb358bc345add62f7367a9b616fef19deae4dba97917c88b91ed902c80f39e16c9c88c119cf4a2a0e7b614610c49f8a1bb3254c52a74778b351d03716530291f43028aa807fba2142bf74150f40b32369cd3acea0c52c82fca2f31d882c749af30b8f31eb50d718907374d9d10c200fea02da21e6b1a5a428683fb25eff020e5ee6ae800c451588fc41afd2fed8a4bd842ee841d9e61fb4dd095aac95bf370a1ede06ea8b5158e708c173057bb74d10af35b10623e9061ab73b9eda561c067ce8da9b92d4452de93c9cbc8055df72ae767a6346f97cd5e836ff75ac5a11d017b90d037fc5e27c6715685d4ac9a6878f2f293b713d8123d2363ce75590e693aa8984355861635ac93ffbef905e19cedfb2f76ecb1fb5453500395b118c6fea7d75dbd02a4954b46e78863f7779587aca853a95653447dddafb4f7b749d95f19d1b1db95f92ac797bcb82413072837cc8becede0c36d8f6f826a3ed5e6bade698876ff41ade2dda0a6e7e28f85596ea97ebac9fe377f56de01856aac2199db4dbdd663f3ea75f106dbe98396e54d4ce03eb1351de26f4cc9a93dac2af937b0c4a6ea84f7feb637de197e8f4170f836723784606353d20626a6dfc2594c952e7269df124013ff1bf1f126b02ab25ba3de79df3642ff58d06977b5be31e945bc9810008314c8d26b5b252c0940a94965fe4e57baea9e6793dc1193f7b0587b4ea161841f05ef03f493310d8add53f056043387ceb05359cf4b4bdf86030367fda1233d3158cdcedc15ae08f46f7df7b88a7ecdbf84d4bab20615449b3a3458aae05a0524863e976c07ded0147e78ad9514b5f1f8d0e175a8c96187a7cbc26fbf1e869068085dc11832e390de6830c102b587b96c78dfe2467756fe8c08bbef67337fd06f04dcf0c7a90469be73d227ff882073e49a3571f4853a7bf02a37ff4b1fe222f846cf7496d8a095cdab8f3cb3847f864259bce83cec016e84bf423f271a13e436400a6dfc4c461a952b68bea9e89d73af8f9f6a9a019feece23eb02f41f9584e7a8d61cc2ea08cfc18d5e0bc36a10401665f14cfb326a9a4d364457fa68a6f5241f97ec1820b5768c2121dad603201c3a0ccaa3c7caa265f46cee471153f4138941bdc2365009e91c00c8a70b33327fef58d992cd107c6d40aa25745215e8c25fa4ed54a169e17e42d153b05c90a077c34b5955ac21516101c8b94e8693020bdc3de8235e1dc3f995ef2735b6959e4f78791757bceb11fb3e33e1e98b64cffe2c27dd7ecaf534e379b1ed46526035b6482e6859b9f68795d4cdaeb0b9afd258d93620f0d23fe947f4728f20a8ffe80bf002c4403cc4784de1725255de6fbb8f3cee48ead23daaa4cb1910f55d08f2b9eca6fc4a7edcf1919321b4c6d8c73df78bcab00b7ee0c18ea53cc60862106fa748afcb13d1c32cf99fb065e93c2da66a15f50ef50a2c202427b1f587c3d48aa4eec051ffa9658588353522fff5e122d8570db890e1c2884b841d163b779ee12ea8a96fd5433fc0d81a041ff598f7a835e9fa6dbe77c8bd19b5eef85a31be18580d7e393b5358d740c51de310652dbc9c4f5e74b3678986a7a973b587a612055521f3130532c7aac2b93e1a16326dc5779021e1d026d8e3d48352e89f733df1186c089bfbce7ccb14b7c3dce67b4cf890c303812dbb6d00e4744872b9607f1620b0b7aa324bcb0fdc1550454a6851a38bc8ab6a44e34ffdd326225a39cd1bafa21a8f600cef27ae7f68d8a9cbcc8d0e944ecb8ffc2d816abc25699abc91662235982aa7d6f735bb57a02ee42af6468fc4f5e6aec75411f7585ab80eccc9b1225c60df5271a6606076fdd835737beb6c6808b05b634fe580b0d9e7acd5a0c30b3e27df41275964c5b8bfd53186af7cf51745f89c9e3211f9779784760f131e93d798de9577f6579da9c33d484129766a0ce037c79ce697be4b071fbca3d12dad3de5c85ce189f85a1f7834558430475a55f51794aa1c9352a13b2abd4e972e55b9b7af11114f944e9252b0de936bce0239db6897ed970246287620b4287f5f3ef971cb3160ed83fcb4487c3d98252ea819c9dd50bcfc934ff7ac3918db9354c782a1830d9f76dba587277fcae869474ddce17af8256217bf2b4620f45f6fb8e8d960aca26fb8df6b699d5328b6ccd44cc253e04fbafd36f20291114db8eab6e54134cd8b6ca3610c3500bd22605691d247d119344851797c06d1b1153d40586932812098a17481fffcd6186c8f41b489e8b8a873ae47502de0563e99991c924c831e611a26b741532889d10b1694ac78b12c7840f2d2cc1136e9668405560aedd3175c4e6e4777d8104dd18d5a2b18c36f1df5f97c866f2461b7c02bfcd7d06f6495b2b76ee92c4a016c377adac8d766e38ab17683e08286b908689fa7121f89dc272e3f77c260df39179953578be0a96f177eea7d2dc65d919c5aaacb46d2d6523f3b28316ccb92db1e96c365fb957116ab4f55bc677fd234950ff3f838e9e91d6331eb9d366460c6824ebc26193f40870bc14935e4bb5362e60f4db879ae50bf1219c32284ac82a4cf18a4182378ad708c27d77ddfbfebce46feb6335965f107bbe121512ba541d1fcedb59ea0656733381892c44c8bd0c0e61aac5be98fce0ff838eb02938e0b731a4aa6446b596f646a3a8713eb2b035e0177f633fdadaab83d9f210432f002ae056bbddd7c88c22985065169591d46a9acf481fe8494de0dda2f28608e8b80880335eee72b85266887da6c5a5c45e3cbbf0c744b6410abb2c21db8a3b868d3e953a1ea134811ad0ab8d894c2bfa17059bf34f9a7a6261238c0aa1b32e999ed4a2b3ed6b1517097fb336fe224cbb33e30d57d08124bfc56a1d9c57ffebb65653aa055bbaa542628cb415c76d2596358f9bf4b1b5d8113ae23ebe32f0fc76e779925e26458d4cdcc0b0e96a0c9bc7cec744c7f355e1e7b6da57bfc71af2e44a564523d16b6ed727cf2330d105013106d4d4559bf0bfb721b0a17ac6706518f67c3c670f9c40f82bde3bb0498c4ab38bc682dbfbd5a6b741e899e878369c6cd8f88e8b7afd84f3a4675b828d0668607f8c70e73393ec64c2f2d9878bd4a8eb029f07451a4be5276c01f06eadfa53e07c2769eac3a77ce2942615dc7b39c0a13b8b6178413aefa36fb9af242873bd921f287696d191b9937f265fad2e4e263aaf83c3db56a3339d0d3913fce768d477536fe827ada6d892bc76b396c5bea2d7af2587ab8011ec9578fa143eab472b3c97d9d1393b36ddbd9160714f70ff37a9675f20f458a47f0f472596a4c2eb03432a29784471a7547a032c845fb4ebd76289ca92b2c77e335ddc96e7a796cd84280b69c9232a2180ccba940994539986f9669fd66c75cb410def9295dfb32b563647dd1744c8f2b3cb3298eb9e3e74d9db6f5a00131c16fd50ea653a3521ff60f7a7f3cff6ca9c6e45d04713056897f12c17b4ee660fb7be3b52de04dda604469fcd9609128ed27c474008d90190d5e6be433ebb5bf5e8ff52c18755878f22723a78a12aea1224284ce79ec1124c0b3b15226676da0e56a79d3dd40bfc4ed8e48afe99d93a2a376b5d5fba7dc81020d24119ac71ca0d2b9095f00e2ecbc2b65a638bf256c9cf1fd28f33d5042f074209f706cd0d420e3931e41768c0ace07f6822e411cb0c34a8372279402ffced321d048f1f65228d639d9337aba54983719d8a42561a2b26b8f9c62bbd7fcefd4898c33ce6c2c501d72da5bd607aa32260715556bdb45c40529df6389ce76946ae022ef954b6d89e67744df665bf3930256cd0ea5c589256d046da2e9b96a35a7ac22a401defb25695060fce196ad38dd081cfc05a5b1d5f47575c7db2147210d102a302a55c1abc120f2ba75c2114e06616df2426a308ab049d8b33421fdb6fa2d35e13fb4e6d374de8768b4ad165109c77cf95c4cb318d1fa17e6ce4bfb95a1509d4b109cb01a99f3351fbaaba019f05cf3f1460aa7d7fc6f5835701797861a5873ebce208e04ca32b6b2fbf7ff86df71777b64892d56f2d462f1930eb93d67a4af02ff6abb814d0c8312c3fbf7924ecaec3403f4529619f392d25f2502215d27ab1f05ee8c2fc55e57f151ce2ed70c6fb8b91ae236a1c607ae56e64f559e10e0c209afe8bfdb4e426b33ab2ab9a24a49155a98c238a7def366589316c8e19630a5353f9abe27f25c6ddaf321127416aae7ed3eb948260d79edb9c8c0bcce89f1c8fb302fc39e50cdfe0c202146371f7c0217f9e02f3c067a131d4c8a673cdbd9b1be1cc092714de1c34b5b91f11940363908207aced79bc109c50b434670d66487a77a8798f4e324ab58c9f30a23c513156b5f3d701d3feb34225ef9661919ede99071159c27d55cc278d91a56bd0ea30f676e928fee3a83336b1d95e4b32283c630f287fcc01c5b8d8e079492e89530322a1125c9a5405966fb2a762a3c74f776ec66533489fed4314ca80c2f2bc1b12f39589b4d5e8d43db61b320886d64b17ad96c918ae41bf6902d9bb974e192c599f700a157d1b3563729d3350c7482960a16dfc453ee02055b8294c1423602c087cd275e12ee4cf057e17a7804e385aac7fc0b1ff2f63ed68c2b89309cee765f024809c9b9ff37d6e416a4c30d1143da16d700970405542f77268583e4409d60ad3e3b66000ff628c092b8bfcad129a4a5acc5e1b8a73a493927f0f9d1edc2188844ced7ad59a80eecdeab30a03fd08a8bfc3e3d7852aee5ec0c2a8a37835fce328763666fec7498c3be4e3fe951b8a3ac3774a8add042ff8972839402f9e9add10c2c379b2acd2a1ba3ac6794080ed32854f28fd2fc702a0d215eac154b6138ac421125158dffae4177d14b04f8e079b68ce3309349ecf29d0dd17bf81d21a52a965adc15d6210f718fbf05bbbc6833d6381924fd91eb0cc14e2344696b4ba9310b1405cd1fe5b5617093c538764325f185d42e938502cdc95d0dcc24d753e16ed0a31eb38bd950f964d72df14df3b72e71a854694b8e170e9e1c46419ffb52d1c46db80ce58ab217789125c968e68d7c263bcab3b230a175b77eb62198c582d7f01bbd6e40b77551d159968638df6ecb2b9feb390b72395ab4a2bafef9e3f7f86081a229bfe78da16a37e3d7aaaf2acd30a43578f66158ddfeab244d76048272d27fb7a68f0e89d013912a311c36448a6a65f24520aeddb1b574588a081f1287437430c750f9fc40351604c15421b859f8a141a6e2c50b7926a670d161332594b665bf7a0e5c63c25b793b8625da0f66a1066df51920409224dbcbddbe24e07f5a7866f9f2f8c557049ddb78d8e388000a2730c40566167de32ef7bc9f67c5818385e5c0fa2b753773a8afd43f2d8434cde555831a582e85a88a783ad4fc866def8da966d76c61112db624ecdcb86f3ef142dccfec3e9a9fc34e439d30845cd0a860987ece9905ad9b6b5cd8915abbe1c05b54dc8602d232c373305ecb0eec69cdf957c2672b383c53c9e0692f824bae17b34a2108d242084bcfe25217b9c977448957f74ab91196f9b6921f756a31caedad72b49565e6a4011ea5b73176a498321fc4bf36836d4f7081cfe1570e23da4b81e3e727c738656a72ebf021e16a405aa01e087878d03b8972a12fa7487f7b7468bd76def7e0c239c713c2c48b3b53cf206bff677aa15cacb9cd0f534da925062c52af7fda2fbcc9842268fc8551192094ec360bdf711351332e40e97e44989062a3ab531eceb310278174ffcc8c84ceabced274084450de82abe2278c2a0878ad202d849bf2728933d796427f1c0351fc04e1078e6bfd9606e0b78f756048750b6d97410f27cca1e3f69e72115b4ad7161235f1876a1a4d6d09305ff26eab694e434123aaa82a243cf7743dd3bd33250644cde3f04dd23be9a0cba9468e36a4b8ac83e7a0fdafdffd102fc3141875febbb1247820f1079fa38c6a29eebaa3d7d467ebf046a7ef674acabc369bbd73449e60ae59260889a0240e25ccde027ca09a0fa960679f6f1c0820a20f8eb12892428d9207396be40d34f5c11c248efde4769408e31057735768dcef37aa98d149d7f67cf39eafe0ca8a060abb91b10ab0d3250a8c03ebd75446f024e00e405e3c1cdfaf1b142307e905d5f766fc5c763a8739dff24d3b0e335dbe62254eb40c9ea3a4f5132e0610e4059b574b74b358c886049033e6313afb521aad378ae40cbc2de5c4c7ab91a30a60ad2725fe7e09a884bc3b922e0986a55a5aa06222506f6b1488a671bb80270f87c25c7e3f44137c7aa8cbdd40216e28fadbb655f76ac234f9123dc9d840f50dc7dc37b798a2257986cb2160412c967132e9b739a2cbda3f5e46c6db5276b3020c478477b9238bee5850cccdc8d3cf4afec28786e06f59f5ffe6bcca05f24d794410970f4a6b7b62d12dabebc349a68e16fc202a76975a7ff2ae57f41e27dca28e025df2a920988772775eb2bcaa7196eab6ab970f039bbd14f61a187927317347835cd0b6ec490895d067be7d7e5954b1e433d1ff58b2e095ce70fc55dc0b535de92430b71036271bc07be64c0abcd108b374e1c79020e77a5aadbb3634e7d650ce91b7b9bd5c55aa5e6d7f0da7c17b95eb0dae096e5143f26233b26251ac96740c9df5ca6eee3fbb7644b2842fc49cfdbeff7e22579dd77205582179e62998824e695f9be73668eeb7b133a5a26b27ec57611d01eec7891944105e0b11d27790daea94eb2952893fed6f153b7c7c9ff722176f1a2403afa6199197ecd8b3ceeaf525366130cc97e2c17f176701413acda1caebecc1aef6f102045f07ba10487d0ab42161a0f5092ab83626c228d320968f82e570fa71b348bc20ab84e7c6c43dd07caed9ecd5e00e43bd4f8bcbc4d36d63f7615d121505afc01c5e0c169d3966b19d0ae7f641f6654b86a27b95ecddabc3e5a030408b1215db2877616b2ab89efebe969aff29be3157a99370006838d6fb15527e308e288d7c70c90bd38a586d442b099a75075009b070dc3d33d2e81384d23b08e5401e906fe93f242281242f89b39618be9b9450d655e7fd81d1e358d229381b48a96520cfbd6972de982ffa1776200eb3a1cedc39ea40a41589f24417ec99b05c598eecbc4b6a2e4634df51f0b59a4b9f9704b76b4405e767c2a0d57a66ae935ba243e95d1bda9fa004e65534296c11ad1668991c8dde345ca2e09e0b2e3158dbaad3461af1cf4a422941f6d720dbb136b85a0fe44fabfdb3c84502255c78bb9a79dc19f7397485e68e4f9a2923d74f67a75c3fe5c3155e2c38970b8af38aff320482e89a856a846c0b36469010fdb453918ccb251281cbac21f438763a31fa0de2898a7c9f87e04aba41adbe471639d3c20ef2c6334f7277aefbbbc499b5098110d81d00546b1bfbbecd3e5444a85db98b06358f484fc4431d84b1c310a1af8cf75dc5f0f9bd8de9eff754921e8e93ee423a28763d07f81a26f3d020f5f59963c4efbb19d5104be12df529da163a28faf3300b1462cd1e2e607713f9856fa728916b31ec0fd35ecff7b49c7b2375e502b32b2f31156bc094881924486eaf958cc341dffb165ff0d5caae931a7a1eb47010e22b689c1cef83a36b3819047890e0c396cfaaf2a37ed003089a011b7314857263699ecfc00e82bb4e441969cc4444d73883709561560cfd8aba3c353c60f0c6808c5b3780c5935525111ad3b7a86f25edc0f3cf0bb8844902bd7968183e6edf4c0aea78a21ba97cf0e81f2fd3952214c2c868db44506989314c00b838f57ca9b5658afc36b9642e61fb9049eb01a67a6b29967943ac5815f1fd3d18086147d3d3dbf5e0ce0f577b270abbc8365badb4fb440c846edbfa3fe97657e7ea5a810142c5bef01eb85507a88277b3d903617fe69a9867fe5d41c9cfcdab63b7af031b6cd05948c77cbaf21fe57046e990c80e24cfde18cd330a8a118f6a604f7d005937c8d2829ea9865f778a906b4221eab9ed7b5fbfd9be57ada879dc7e1bcd116a83744b5dfffe1bf482ee420b8ea4656afe74c8b5dde1e60c54b7f24cbfa7c7786197c4244368c67e1f0c2196a85d610398d8cfa394d79cd2d321d0fd9afca4b297b511981103f0a6028b58746bd023d5499a6655175c37ae915f9eff0f31c695c4d3a0636dd33856b54e123401fb3712b152aab707adfe0097f41bb7cd46b9636aeb9d5e583a54eaa7a867607b47b9804f5a02fb6c4c3b6d2da8f43a2fbf46ab1c57d85474a54f70808d90b4015f81979174f0584c9a844ffb31ee7edc8bbe0cab7b6299cc85de2a6510758569b6b94ab6570c6f4f4d05756bce15bfbb89cc8b6e8bda9a7fe76d6e8eaf90732603eab13decd857112b4f32659a1936fd660a7164981c15dbbad73c85b60cd232d27cd60987b28e7c52245b58980d05d84644dbf9338fe2119fdc12991464515838c812853ecfb5c77c36e70d6898f79ae0a85fc9629a9dcdf7d4be44ffc6e3944c559ae4db5277815d5dc82e30f249c00c4a17b4253708d0a5e3ca4c4d02f080d2ad7fa135c94cc7fdda6b29c42c1d808a8dd912fc5101992ddafb9ec98e56674e3e74c695ac11e9dda3cae377f2c082c5409084756f04d9d117ec51e5f82d49315d7f35391494921f035b35c91569c6b5c2cb2fb800c85e89f3168c1d6c4ebdd54b12f738f2eff5243f90b3324be6a6ac9aeb20e7890f81ba787f024e3b202601eb717c1f904ff673eeec8b19fdb1e57b54c9489474797c1b1f4f97687ea62ddb057873bb7aa16baf49974e7669797499800dc6917dae8ac06e5b808c92f19aa1caf8dedd671b219b7b0510df992b022ee884579aa24ce9055da0fabada7da4504129c43a5dae8a9ef772ba06110eb1322596cfb9656155699581eb6a169c0d445c4ca385f93b7efe642f91000f69f44cfc243a83e35923b1e4e89a2563ea45680675946688fcec0c0163b80f0b68e405eeb97ea7e6e4735652f6355ffaeb43d619bfb2ecb5278087865f261bd713c6d76f70f1f49155aae61f37ef44b376203fa704bfa4ff43940de88ec2d623069c93216e88799a83a92e2381481808a9a9eea099e86cb2269eb96a2de6120c9d86703b12598cfe8dedd00897a129fef75030ee7129e844ca46151c153ff38e7e68bfde46954498d2d8197b95de44c20cbf8c36b599f7f0c8a78549e4b6e70a4c5c4ed4623be32beb21c23d0c50f6f1a98445de89341eee41da3e5abe2c2a1a9a886b9a113ad526a8eb18154056ca32d8b7ad61488a15a8ec131291cfefa783697437770f2f58bfa82184732fd951d764506c1fcec1fab69da1477c0dacd4dc84ae590adf9524b736c4979d69fb262fe631c47809c808a1253dcc7d034e846de7160221d9bfce512f302acf01b58cc3a64db24c6c0324723c0dc7d9a0520256fb7f0b2dbb626b8e36481835c9eee9df5d80b457ff7189b2928f62027fef21f36f0c29000b1ab2c54d5c69b2e9f1c67739e02bce5ab477a66c0c6f0ded984b43dc6b82295126165ed3a20b208c2489cb7a64d0252030d317868fdcd6d5d21a75119ba9948344a4ef86039457f0ea721d129e33d26e2b2c84aa77f837d187c3d0a99821d56de6cbd590f66882aec1b23fd436561b68cba82725e30571fe54310968eb01d4205ad173481ca35e230c32b6bd11af977dc31237e1e12423d27018990923c152a122130723d1bb3aaca34a2e8671bc57042f12bee2ea03f57aaf6f85c3f1a614c6967e90950c07234933c70470cecf80064ad58a8be4d03bd76d99a562bfe11828ef4771d7ee641fa9aa81536a955f314ac9d999dbe7a4cff9f688b7636b917ae641887b33eead9b35733d1dac8a3afaa9c3dff01040178f9030f1e3688ee4fd91ce6cdfe59b6cc590011b6db608d1a8793c69e575736c49626a46fa9258d4489bcc6d62db54076f0d712600a9fd2d9013d499378ed74fd2575029856ea633389df11cb90ad55cee81f458dfa9a177a17034c6f0c871fdc992dfe9ada723e3a2c0aec8831ee76b307a3182c3aebf7d420667b0bc836a5960e6bd910d65d33ad1f871762de7b8cd7ed94369bd5c4510d134b38a1121d17bfc082ee0b685eaf124386fd32cf6ab41e186832f811bcbdd8af44b0b8eed9c2442d19ffc32c8d72a79cb8a25580c7476c65349d45884347c2cb8352997cafd018dc6e37da59ce90e5a412694b991a6f0cb6e355df9040028a6914103c5e9fda071533f932757a7c93e99ac6814d7693a2f4b89eb1ba778e150d8f3195aab204796fec9bfd7810776ac552bb93752ff472fb4f32ef1590598fec849ffccd081308be0e8ca678a8328c040a1520ccc705a2202c27ab1c24d6eddb6e1b419c0f907c3fce8277aba95b6911688e2bbd614fc408c7984f041044cfdab4da4b4c4bf51fb90345a885954ee0d0d406938f54b5850bf65400f54155ba4777782cf6ca693841d92b7398739bf5cc7fd183adc2564c21e68a2f542037d19b25e5e94a70eb5ed0b05ebcf248d2fbe0fd4499d9c966190c41e3e72079391b98d13f093b7f0dfd938f9fcb6dcdd2b926b66421a53be575eafe59a837f00b5c2c4658ac388373e05c2d7f068186c823bca0d18ff26eec4b4c0dc8ffbcfee99db767d76c3ce2369cc835cef403a0a781646f8243faeefae8dd5b81e354a9c37b547eea1e10cfc63be6e5641bbae7e93a68db4228fcac8993186ac7f2d900e08fba9a5b05d4b836ad0f4383c6b6286df6d1ef3d0ae3bff0d7e34d0bdecee5b35eb07666a05cfb90243aed07b7f1eab88dcba6f72fad4b6e3c9d9eb3877fd91dc1fcab57a7642475b23f26c12ae09f16e5af2886075f8f0943d672ca08720c3ed6dd2988197614d2d5611244762d02c9ff195fef76fd6edde9731bd84f80123f378481c3049de5107ad4522b5963ccb40ac3686416e4b473ffa628e94324867dbbcca5994df2e955435d5a78b1588ba24f59120ab0ad3a2f5b65a38ef80374e996ed2eae8e854ca5f8e4c743794acf24907c508b5bd62dbe6cee72c6846b872198a47700bfaf7675fc5102d85d1331dd16004c376c60bc0da7f29919af4eef324b2eea9397de44e749c8365da08946a4f11367084bd980908e0b64e099a16dde6e2697936eb943a9e0316f0ee637f60367d8c62f7a64dd0c60eeef389466684f46ac897f2aa79353b036c9f3d6e033c726527b994f3d17d32f49c45c3eb44253cd13a3bfdb1f518da177ef1f65390b28d99f48f1d304554558647fb7917436aa8286e1cdf14f739a17d4d2af12d77d124747ffc069eaedf5ac58c6c445dae257981ec20651a9e7ebfd6c95ae0fa25a2f0d5cceb9f3dc5d3c0c323769cddcd5a82feabb8dbd55f6eabf467e229b4943837245bd859df079b361ecfc71910c556d3f0cb59f0048a23907e9e0e1191fc2cc2d8df6672d7d44560f12ac9caf40c3bd4e5f423b67e67a88a2db1aa4baffdd76fcb5cf85a5a9059213c62d84ddac9ed8a335d27b5611c36a9d447e6097d016abd22ece0d22747d9343796e34161130052492213fc92914d9c5fc6f8b659241e547f2d73d524bd930c7db180b40853ac7ee45343bc3a18d74031db5b1248bfcd2840514de10c86bc8c83815f7890f1d2dba786cf3cf54e7491abcddd938cf0c2de58d5a5131b1cdae586fec1306f44b98a39a7f2afcf3b05a83e4aa0e0f72326d103bf50cc665b351db2396c47440bc5c7bd435b357866146ec2c84aa72108a46177b0aff51d320e1e84c8be353c55dfc5a6221b6fcca1ef0e238e8841b7a53941a2b45f0f82853f94f889f9ed0d4fbb01cc28b7a760ee3d9625193e2d78053e2ffadb925522793d0250c2fe1485e6bc191941b0363fcf155a086f65b0f47458c253665e8504693e9ead59cc931025b4061626329b2738a5a978d9a0a6b8b3d9ef31642dd373624d3fccd1687fb627dfcf38b6d0db60554c6c8f7a1bb69c6f6951e94397c6de7f655f429e99c63b494c226876c08d5a5efd81525478cf24c8e91de4a0e055e581c9a61f4402093ad28a056c1aa4621073790b181e0a01c3028487a834fe1bfed7098144b800606c738afdbd309418cf08ded32122e0ca50f70b4ca62f53cb417e2639a10c3bc751a74224ca92df7a5ef3ffd1e4b27a91b9e7acfc44b651143f45171d494204fc68ec0e5206f4121e2e044e1090b5b77b3a461a8e9f34afaa8ae43da0c7adcec35f8336802409b240b606403382b2f99ba404f940b5c33edf9b14105148acc4cdb47a1f80458e94205a52bff0bb5867761316b4601979c8f95a539174681756c120fcbddbdaf43c0422f10b80a30f81fd7df7bbc74ea2ecce3d7af16ae114426129affd7ec16b06769810fd04f9b94defc2bf7618c1567fb839a7dd0ede77bb1edb8c86e8caa486eca8156f6141cc5db13fe7f40f874761681053857f4f2599767c7b0e60e9e31e34e04400ee0c88c49bcc150b8b8918768392b7badbd73c29e1d79a6a01813a5b20ee96ebfd9661b0f9d20b0e5671df50abdc12cef8871142450a4981b3d938e052d34d36c7f3eb1dd949316f820acc30a44a6d3e68a017c14f7caa071a11f3b8cbb7076534089079a257ec560157077b1336ebb9546c2a3bdb334fc0fc74b60753301bc7d180807a5b5626271ed79b258620880ab5280ddd6d33fbfc01f8b9e582df954d55480b343fabd6c922820e221b40dd74d8d00ffb7e34d7757195bf115661e6b8b74cabc95619b7baa7d9571465202fa46f8735eaeb426265b7a052927cb305b0e9cfeb5f22e95f7f08b4fa43478934da7951255fbf55dca6f089b382bec08d6ae9a88b1392a3a698814b19eb9c04addc6e392622d8071a32e8c9aa68045c37d0635b85c5b2fa0129c74cb5bf29e28d99c1a07d468360e55800268d26cf0c5b8beadbf4aeb0d0445a0abe37a348a5d90c5cb7045bb81fd50e975d8a84d66605471d2c0e414d45681b3060eb81f1aaa3210febcb183a15649f377283dddf359cf90e69a0e1980343805a870986d44946cc8d11bcc7f1e2c1a878944745274a7568dfca525fbfa8dc112980056d364b848da62b657d25c2dc363bc48fd96f4beb6d3c8c7217e17aa89a68fdbdf3f6cbc21f4a6aaae440730fb0301f4fa4e37ee9f44a275128949dd3da093d0062f1e144d06aef519c24ae3e7a8dbe1ffaab1a7dfe02e642f813d523964da6504c87071e1e67bbf314b38a7fbc55aa9ac7e22268c5029ff44fd21bb73f3c9b4d170380c6ce896aecf2395b02047fe5af991f0711e8cd5c406a37ae74980fac978cfe34cd22885d7c074b10b1b74528847c0282a2981bb0e8c65aa157d6e967a1608c9673bccdbeed8a16d41f5611d70ee0c7e491dd4ddc42b803ae18bce7cde950a25d583b3bc8c23d20e95f29994a5124a28e7da834717709e2acd07e964cec529aad3691bc0924728a3cabcbd5f28c2d33d06690cd319582a1e6092669805992312dfd33a7640ef455d190067cc080112146bb58cf4d6d8a3b520aa5d9ae167df9ac513fc192d741b1cbc9cf8a20d77379c77fe052fb2ba503e685b3c4552fe13e2b83dc4b828999e6484d4b660fe9d52d6a001d609f1e07451f6252932b2cd727675f34f6a89420733d1879b7def177a84d3906a770b0239034137ecacac08afa320168e0b741f8f32b715fb5c7161b439e21184baeb3e890d844be9f215caa21fd1646ce7e568eb628f6f51150e2c4cad0dff2c193da44f537d58781ad2cf13a5638a8553a88e2463a49370b5fa4d82f0fd69c56bb3758e4fd9fb8373d4cf2dfb17f542806af4f7ba8357b00489b42a7586648b194b742572a390ef3dc8de7943f3656adc5f62463a4dd6763cdcacacaf523be3f955d4f75b3cda133f306a0be3a2cda64bfd60b083ae988b1f2c17b4b8749108bb181d1e006366c718e0d8af924dc002c4c44c8a6411d8bb4352337f9e650d790090b16d0b016026e26c2900ff52db09b3f2d8a54ba94c6923658b8ec9c423dffdf6cb9b8441f7ba5a6d44dd7ff06742a6366e8508e12a8475e3848b7e4e548f1dd7eeecaf641110593d55c6ebb4d8bab880050399b361b731066803d4b4348db8be797b0890340b3b4cc799041f8ccb5ccb3a273e7e739d14537d3ffd36d6fcb6ccc87ea95eecdb2ea221e72cdd3eeac151a728246f5bef0ae1f2dadac136b455833c03e59e54fa71f196441b8a8735345ed13fee80a1beaf68beecf6cdb40205beec87c5f1dab51c0a1ee8eabb7ea7258f216902cc3c2a30c1873d232001d6cdb981ab4d16b52cba7fb83f7d3db1200398e0b8c49eca8127ddff0d5f72069a32b9c785c0a6bd9f55acf330b8163ddbd248fe0cd53f6290d07ab4a146ca6a594583adbb2c0d844575f84c47cb99aac627195f52dee448079248a2c80be701d157c2ac207e849357","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
