<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d03a4fd3629c21e19161c5ff5bf5d83c5b3e9bcf8fa6b90c97875d5cd583fdc9b8ba70124952a3de39f7a366944dac0a759a1265d10095b88330ac6091131df26815a813f882699f4f52332f6203d73e866beca9b5c1d367f39656a033e9e1c5d41adaf6e810c723f40511b75370162092f72d09bc208b32828db9db1e3f2eb257d4e8c58a6571194822856997d097de5323230ffbbd5990b62fb60bce6f3bf4727d3cbb4641bef40874c0cd932768210b05b795755009957342ecfe9b5cfe9f2b18c56084cc42d55b6610600ff47c24f8fe554c026d6f2cce03c1d1cec4183cab86e86d9aa6732b2fdb2a997242f493870cb181be4c8e775647a7bf1be7819748b0b7f6f6f57bf66483f1f99fe4245486714e01a6bc1f4dd77ffaeb0d5d767923fdb4d69f7c2b1d8351e507fa1725142c2cd13b19840264ad097008701f6a55a773ec7fcc9977209b2f3c9fce1b73760e0df37b3ebb2a449f93353c4d1b5e5d7b380ef70927f82f73e89133ad8c46553d32504b7477c00f28bcee8cadfd6cac9b1d9f72120d861f3da9a7d29a9fc96c7f2a090a945fc279494fe601a2fb02d838c386a243a0a72df0dc7af56bf142d8e03dfa555f4f75b4d172f9a66d8e8644e75a665779626b8df9f705c6328372f5e73bfa7a7b216331b917514a2b039d0715b5eca7568971f6e82ded805a5becab37ed67332fed6108068f714f47e41c00cc3563b5d48ace8da5a1bc41fcd4ebf8001f7f1870deaa1e07a3791cfb94fd8fc8441b07d50afb27875ef96437884baef684a1a559f84de7432fec583b10a7929241a80e0b12057fa0a31b8b97ee0c4b439f4998ecdd7c5a2e7ad50de8c5bf7d7463f88ccea5e9421c1e0fe50a8a79ffe6b3ffe50f7638db1b70bcc80ab1240699f2d2de0685d3180f447ece3b1d22077adacf53362d96853ae82156b1eed10f549498645a215a958aea4698e3043851cba84be78ed74de1610f49875a0b297923b9e1d27677ff1c3000734069f2abc737fc9e5a082ce159cb22d7af44a837cf89eb76fdb5d08501b068fddecec0a8fc7efdc5a62f3be9633cb33f8f130c9e88a541661f4780daf0c03af3a2875edbc4b1294a1b79dda118635d3e9862ff59989188965d6fefa138ab8be57cd8dd899a402af951564e7eb72876a6b9adae80df889132de3dfb2f149aeeb95f443df0201e2aa1503d40f95b74ff9fce9c4372e956ec621f94474e1ec1faa791b7b065236a7324ec74d91fad405ee73901ec4bdf980363d9e45fcb800bfdef9a87767d3aa7d995f7db108caefb68fc84fafb664f0fd7243f3f35c54cf8bab00327bc726a90baa0b490681effd243767904a1f5af5a9c6c98e2b70e40c476fade9ca084d92ee8ff02828e93efa2c5ab0d5a62044f7f8fe8ab90ba86ce26b0ed0bf4faad69d9e87459cc1b74401de63d23e04c2f38c5ce6c01ebe0990236c34eb7c8cd80e821eca821e8f6c3538c3940b247995885a90ad83b85c87236539c625373bff968575b8ead3cad815e3bb59c5fe70a736e5d3c69f5c0ac6df6baf620d20444b5ab8b86d5656f796657685fcee751aa6a446a3734f9b049b20c6a0355b4b0ab127b9a3542a9535fb295f553211d2158eee1e61eeedf593e17d0fb23f7db485249c6f15df816ef3aaddde35e1f99667df67a1386f9e1b5515aaba4589f7a4af9504b80bd7eb20cdcafec5c1bb6ae8298653df0a048fe3a3d4828e4345a8ddfff293151f3ae2dfdd94c03df54e6db6dfd961110b7500ce05d47c40f377637b033349661acf1ed66d757e799b32b10991d4ab0faff0cf58f0e2720a3acceb5347f8e6d052aa171bb62c48e733a4698ac9a5db11ebe041a4f7705fa4612085ac6ce8aeb9c569942a548e0ec77e8c12690ab23012573b2913978c396bfcbec43b9bb2057b6bd0b8205d852db7617f17e76ca1ad31ecbe2560f0a4132702d900538c1795e8df6977a9658d5c1facb39b0b2f551396b881a99bf43ded14904adb0e89789a9f507d9eb215daa6e617c8bfcba2aa5a0b6aac1f90f5c1dd50213bdd330a2e7a96c7381e45a217513a607c584d93c7661c86e884a96f79a08a16146a5f44c0638f7153d71af55b501dfa8379ba7050ecfce5d84b2008024e2c8ff68c25df41cde4842c9ca3903431b98ba74089b8a389640f9546ac70d5766fcbfbd31d2526a85572ad23de72ab9f8df4df892ef81967921e1cf6b3095ac5ce5512887d09914d9c9655422ec2171cd03cb85422bb541dd66e9d7a7e40bf796ca1e699967c50fd1df8cbfa95edf7f10d57f7f330b6675e348d874e317774e77e15c83926efa8fce418aa2602d0b273d43274ae04569f57d6dc54e1152d7153ab66f75ec541c64934519c4b87f90ac9338a04383113efccb4bae1173a322a4ba4dfaef899cd09f16408ffc3f1d9b60570336c3c6bd3bf73b9aabbed512c5bbec56603055d80da46921c9a7f37337db3a22362c00e4fe9ba61f56e436d618e6eedb30def66270779a2a27883049ed48c298721c69d1a8619ee95f60b8b9acbb98b2abf9f2b8fceec00d824eeac03f9249447106b36209943d0ca3f17f10fa4b5f692e20b4d7c0f256afa77c13e3fa5e464dc62bf408e1aa5a6a11c23ccbf4783758793752b093e71379df60d60b5d8bee8ed4b1c731d641f7f907d31ffb5e1102fc9afa5104f789a41a69a63bbb80d4d82c2231a04f47303f4496a8fbab186c678bc6e92f5acd0954368cf83588a746c825a4e41d805721fcc225eab80a653555ca9b361fb8bb26f17555eb83733279503967128aaeb4e9b179d2a1e9c7335e01c4280eabf91a8613446049c81af003160cf9c201cc67f4e0c85be03deb0bdf604719b10ddfcdd1933babf96d92c812c97e61a43d9eaa6e409a099804d32ee52e71a8eae933fffc394e3d90f5f9dbd02019207fb456dd7626e985e5460da7fd36770e6ec3a864ee1cec27a565196c99039ecbcda8a78c09407187147579d2ac688c1df0e9b66cdaf5a3fdf2e28a01f388ad2a3a57b6203f96f669cc348ac24c92debb42aa4c1a8f5d7afc8c78a566015f495d368f463ebe42d3be965aeba21b6cb93b7f9dcd84f96d30581858b0f3d245161160e1808cd78f870b77e15788af27d05d45e7528645244748fd2be7e1f2ace763e12b4fea3562d2d949371d1cf62b8053977cab473f19d1e44c7074337d67757a9c64619a665bef8c0ef380f3c4df129cd989799f89324f47890fe904ca2072730a67f097b3bb1e381fa79a141d097c888cb772188ecaa9281581643f578f120ec94cecef49c14738f203fda6a88a166506a3cc345439156272643dfbf67381bc5688d77b6ff5a6785681936e09af015372fc5603d003602f55d5c1b1d47821bbca85e190205ceb4862d7169c4bc79322017eddc5e019947a0b8d7114dbb9a74cda9bd6fdf1a051103eb43cebd8772d92bb0368b63d90fc604861a4dbacd07a590e85a9db6ffeaadfcff4a8ff2a0c373ea7ad7ec6d1092e33137ce4b16bd03c434bf165563b342169226ae2f944c7a736b88c4455a705cec23ed7cae3c0a43851de9298cb0f54921104c35b8ad9508ed536a8c78541aa3af5795b936fe4ff589c35bb2c66a9193f0529c926df43ab132c9527b928fa5b9d549af32bea86b75b6c6e456f1aef8741d8e802999d7c2dcdbadf7e6ce95332121e94a7b9b6a6a1f4c9047a2b9c3db0b0ed1baead91f005430f9eeb60b39f4c25e1947797ec9300a43f5868aeafaae84ec3391d78b46cdb480483c575909f7965b49f0e92dd6f29c676cdd885f6d813b825f874b4324544c3d5283f8709fdb92044d438e05ddd016c1bd90ab5e95da571618223bfcb76d586e8959ed0edcc47eec9d4f9eed93df291d22c1b005a04e42da50e49ad707934a7d55fb1a2403cf30605fdfa15ba004def8eeb5d62451762dc4dca29c93aba4f0df67a8e61f8682d52949116c2e54d67e17bdc19c9e8fab1f9db1d43f24a0e69406c0cd2a4f9e6d1dca7168b1b1fcaff67a106c953dd70a6c6916c26261e2cbca81070276dcdadd85a3b7c6152edc71adc58a28cc1e63b1fcf047c04d74615ef28d4ae0c0c697229304a9a2943b73f85f23d40c3d6252d615b390d754debbe0d304894e539b7b4f3f8e13abaaf67aef49928c7337790f72c690c8a8d9359c0528f9a994e440f1dc2326e3356d6b7ffba19ef16a9360ff91c5d5e5092ae888a045e697d0c06f02df7536c9d30f56aeba4f2dc82deb751f2c2697f37dc4df905ac90e18b7a2dd61e62780450d48ca6d96905b56742b03bb41a5069ec45a793cd511da040f7be686623cbc4269b520030bd7b1863ad1ef8693773bddde0e0f7a837a95ac67c7ee0b2f1381d15cc91f0d3c2919d0051243d7b4b5ee2bb0dd8b6b177621feb46ce8b82d9e19c4c8ccde0a7829611b560ab985767878d894cd84e4b8e2eddf1f71a9a99efeb9b32ab576a2dad5e6fc2e5f20249f04dff433e454297fe8c54f08187e8c7d0cd431ca29c1a1e961551ac163179cd4760a4167bbbfb98816f8b2a5f5d613a627135108113d1829e1525f08997ba063c7af9f8316d472387f5e82fd0b17a1021aa19cb1adbafb32438b8815f6ef39ecabe2690baeae59db61ee180e2f5fb765db5a221f90f130a09f229739080a5b91f1a3fd5abc6b33d7a9f1f64867ab1c813e9b047f0e03c056323267c1498b1134eb6d17c65a14c3096bc7453fc08a20620e53e2abeaf749053098ad350d86b4f5b088fd94a558b5f05b5ef5e048bb2435dc568ff8b3cf1edb72fd210e5d0111e05154e0c4eebc602a476d3216c003f3272ed82c55e36d1098a88817e0a4450ea6f760d7e69cd3ef5083d76cb917c16d51e66ca084b10797e2924a9822d2202f2d7e2a5938eb29b735b67e5d2bda5000f53cdc6865c84540d1fb03d623c5dd950c59df68083323c94d095e35b6c7dbbd26672b580c6a7e50bfc51a98b751711cefc4a2b6adc9df52d22f53515afe7e265bbb5ec313c3e2a19d876a972a01a08c5d9d5f0f320087ddaa9318e70c9b462e06e601dc645fe28b5f03b4415db11e11aa4c61813d2e32b307371a158849d80c398f99ca2ba05ed00dccc527ed4d0f682947c930627483b0c36d4821a98188c3f1f5c7d9668a43d555cee387baa690bc480da2f5a4323141b230ed265df61aab7bdd8fe4aa8a573ddf9cdb423c069cf97e2b1ea9b1ec6e6df91ae15479a6ad428db5c936d882e21e715a6fbf17c8a390156a528e6bdef63c31d07baf7586f86c5087e0e82bb2fc782901acd5613af991dec5e7729411d08922317eaa3961a816b610604af2c73f1f65c02b9e332b0205ea1950ba5eabd784afe9e5e6f7e3aef57736049b9257f693fb16f1cfaae3f05b59b718715c0230b1b26dc99b1d21d71d9c623840aab815e672c09e4ad66a0dd9e6f1cbdaa24da56bfd67e5ab13c648318124ada925e1de74463dcee40f9b48b70b3f2170344946f769474668ab2c8cb1182f23e967bc3185d70aff0d9ac4847101cd5478a371b850a30e4fb5ad08ef5905eb66d779999a8dfd256b34c0f2332487dd1f565ad2ff0a60f98ebb2eaaa013d0a8c24802bddd062ca882349c71eb360d295ba45dda361fe02c9bdac3d3f3742ec06c7c7522bb177d01f7b5e1c1aa3dc0b25d023d49f2500e2e235b3d5565befbe4c7070c13029c8d899dd1a602dd3a65e50fcfbb8bea9eec681a0310d38a52a1a9aeee88fa0c3ad7002134c0a64c4bf799549386672e09e593364583d5a22203a5284cc28720436976d67d5c3b3c8ff4b4499db8241b15ed74f0955fd815b0e4545779c41e41cd447a648bc3254fefe3ce758e0047b6261867871305269e6b39f66a0ae9b3d3d55074d3c1840b9651ce6d4c624a6050f6de4d3d01fb81c0b648931f75bcbedb7312e490a83c0d6e34e6b2b0cfd472f7b894418bf8b297cb7f4da202cfc2e4c5902a6c5cc6235a9ad9355640fcf023128d71973127952a07d829fe22b636b2467c8bcd66cdf104484324caf760185c70bf1f9cb7fa57db635561163ac06e31a66933b5ad4ed132fbc9a09fb7b18cccbfc8573b5cd66c642721ebdfe3d3da7ab733a2960825a21391796bcc860a787e14be5a0c33940f81fa62f90770bb8809aab9593cf558812536b1d4c1a165a955234a23feb20220cf32d0d696e221e140bb245bd2740a9ff0f308c5a7ac1da8002b391fea6511bde69899548ded4e5f727ec93906aaf8d1e7016b17327fc038f686365a17c63a1b1f05916cea6408daa171d6b5dcdd18b48ffa04066fbd889ea7e6796d444388fb4eb7ef5dc49d71fb4846ec45ad40cc70984e80a5bd147a80f7b41005a6cb749b7a95457da99db32b3ab9748e808bd8b13a1d1ebfefff362bb268932f75621d13be61c5a566ff2e394b1cf0e7f5d5196396ac90aa0684d5e3785a0bbbe3bbafa383097dc7831599593efff44689a195ca38d647c50c0cf3ae44ff43e731560cc6e0d2100fe8a07ec9e98a57c86c292f9766068e7a66e8a747c5ad0e34633042eb922177893ff18c8d3e1034288757e6bf563cd367a6977bc816e5bdc4dd1ecd52d1472ac7b00b82dfbff970b5b985b597ab18da25bb437c3bdafdc03ef358017a032a5fb1126a8cb4ee23c89ef41fdf43a4c92392b820cad74471834dc913d9c188c91505f33ee509513869c1d2d1b70580a03e31f55f11ce4d8bdcc9c3aee20edd1a0d8b85ee5ee68967ef2fb49ada024f45ebdcc9836c98501efd46496b5141566d00e1a9339cc3606692c8f71f0f1239090af26619511f0ab910db54d93cf9cd1f624df1cff1015ccbe644b6656700a9c787d9a3c6fffb97740418d9213f0c4a93e2c1f29713ed1935370c9d6541501ddbb4698c5548b84e8d91693ab5d607e9858fa8ad6d7877f2f1c1a640c1d08e4300624481e4e7f92af691de1e1cd25def1c2b15de37b5b48c7b1fc05c0d7efbc2b9a641fdc2a2aeda3188089c2c57a53a8761a6e79ae7de8b7fc7e764c6cb0dc218a5f38ad354f6a559c4af1a2ffe42b4cf7c4a39880b1b9d2052e9d41b2683abcab1753cae66655423521625d157b1698dd138e69cf0a5c184cc7b003362127ab4ef84557a224cf00a313ae938ce13f0afadba4d59a59a06b19d68cb4326463d731c18b2308fbcdd4d5aacf884eaeee7ab2f1819e283ad2628e483e56573d43f452eee52ebb77ff5840ed27cbb1c2742b8e7a6aac9ca8161d899807299d92333371f74b37ed55701f40cac1a0bb3a946a4f9d8b111e4badd6f6f1c1606e0a3589038842eda586670e917bb3d5ecece2c52fdbe3b21493a02cb6120d2fc8af0dbbce47cfd82968fab687674aebfac5ffd8fd6c015490bb9db676aad794f5ec5c5d9ab19166404b7e71c0813b1e4cd0356cd5520966f12af0c52a0d0b0879251ea0a437c42e37b1f0ddecb9b734132953bbb0f3416ba90a73a7fe2a51fad07b1ad1bed54c24b92154f3eeedf1088eedfe6472b5ba89d56dfb96bf796665884e5c14ab0fc60446322464da329f10842c862b21e144d224ce94a92c38cb09245cc455267e34cff7033a066a06249b4d1965d7a260ca4bc38b8f720154b800c693c053b9985c84168926b378586a110412af13fc35931f419a9a5d4640074792e3b1faac3873a178ac8e0bacef4e97a4a209919de1b25c5564cf7e2d66b4792242ca09ef558336e14378aa5c2c73ee221807459077fbd737ccaa98c67b45f60fa6a0f608d4403819afa544c2065632f9f0b7676510fade5369adcfea766d56225b4ac8000ed3a1aaa73bd377e59beee5b7d2c47b4ba66a4951c0644c6c46804314b0f8e6cdb1746c5d8b4e82b5dc5290ec205f5e996baacd596ba68ebcabdd6788745eb6ba2b1efa65503d6a11ede107897f690a471e2744deecaa50327013342f5a267f73ee872773aec5cb2b60803f5a107444bff08f4fd3c4d2bc9cf25dd6e42620306a5eb5c4770f7a0eb5659fa913631db2836d1750da2b0eb336c0d9654c76fbee60dbf6c47a4d91d9846402627beeb0618ef806a694addff52dec6d17ad98f9fb1849e1a5d346abef9e9520f7251cdb9f65621600031a467999eebdaa86e6b15baf636bbb0dc42fdc8c068510ff907f8cb4829b928b1588e5ee1bd34289a44dc14628b6608bbde5197765105cfb3294648644d3f092b8347baf54f562af902ab28f9cf5da3b4d728d67c8f9d7bf1c3e8ae99b540bf8d87e56a655cab3329d3c8aadddcbf4321d0e55aa65df50768318dfb28d8aa9cf4baeb2fccc201ec8e1972cfda0b27ce0c98a8ab9483ff344a05a7bfbf004af17b9d3c41c3f61a5bab3945a9016281e5a776234b7cc24891456349c1ad560f0f800aba8c0b293718e98d1541cc60d1ab8f2d05f2cf71aa5d0123144be1bfaaefb9eac7dc487e1f30fcfdc2bd1f95043f8a61f40ec1d308bfd982f149f6a06db4123a13347e23a47aedba9715c5e3cbac1a295392bcfc69128696e82a80003bfaaa3fe0a7add2c919051c54b8892e675f788facfc7ac661fc9adf51c1da713d046ac4f8daf2c1add231698cf7cbfa8ef54e997ca40923dface88fd40e1b63bbb9f9346229a6919c2673e50cc4062f5c52f58593c111a876de46b9841b29642a046d4cc464247f594de642464e72e0d56686ea700b1c8c1ea672f9174c1ab50d7626d9b449a7753059e2c72f9841a85af5e2cda3774ed236b0c3455f20f4669eba976095f27a51c490f89f09f58213b6da74fcfa949ed18839544647026d34985c1a76c008262eeb928a814eed94e8cdfa00f484a23b31058b967a1bf85832bd944a19b25f219c2e89c88c46c7a0bb99b4b11feb8f169a90e7db492d6604a16c072061b7b425a82a8da0141e3c99af9422515f1ec2deb81157ac6d4ce3d1ad042868c6861b77ede20375d49148a0050e1a2c000628aebbf03ee4b37c5d9b2b07d98912d89cedf3b0cff777f28d32241793c4e7eec182f9e3604cff769fb76a1d7b871cbe505304b255e10f755e56845ee4e1d467bae80335c48093a5fb16eba05d598df4934ab1efc68f2e46ac6a4279552452c6cebff425ff9dcd252a29604e0406163916bab81714f39d830e0615120e5f705b28a53122ea59e963bfdf28c7fe1f39d9448a2cfea5df7ca3ce521be3770a3de6722626a581f8174c99f12f72c5a3c73f497d05b89395ceac35109068eaaa12f9ce2cc1ff0d03b8891c3226868639f53387d15ecf46e61b385000cbee6765f3f3e068b594fe64766db5865873bdd879822dcfeb87ef3b0da330fa54c6ea8e502d5ffe1a1736d2b8b7fb358dc89f363fea6578a8e99bb513457d6be1583dc788379f99470a80779751f032942f3fb40886420c54a0fe4e844c20d3cdb37a4a413c2f32752dc17ebaedbeb7e9364fd3aa85f8b1c8f724b79a7b38da1791b340f050e5e87d0f51fb837ae752f32f49ea32067f94bb0983b5a6ee8c9fc25700c6e5101d402c97c19081fc0b300faed78d0d8b3ce5b59ea2e207f507854ce4c046ae867d987c1a346227cf4629644702f85bc1dd48e076ea31b6865c80864a21e97a7381826b76188feb2459069c9e0aee540c881385a54b418b905d9c379014bf685f6c224812b753f6f82e80fc17d06f6d64d360a4328d90bb52ef23de4c8bfb1a06aa65d8a1c1b3f22c4743b94b7f40599061f119cbcf2d39e2e8f6579bb00b8c3c68b11cf08fb314da28a72679f103117cf6fe796f98424b911663190be116cd8133ac582b381ca3d98e1920b37dc3cf628ac9c8a5ee580197f86321792d04358dc58c5c05ed58bf0a978a509cf890c76f8b763fe0bac6dd4c8457bc1fdff1f6ad03e6db2a765e58b61cb8b2204d7d8d7cd732fe948df506920f785334e5a282985fed012a0754dcb671bbe872caf3dbfd715ca962a2cda46bc6af7c37284d4828861b55158280ee2f969234960db5e13fc7981ea2d270dd6c084191a51177835252b34081b478efec01e7a8b2b668f905a13b7137ba428acf747e805e57634936f79c965967aa0ec4b116b71951d4b4aa521d0afa822edae0afbdb7c2c5160894c95a66736dbdf55c066c6e85a4f6ff6672f506adc7cebfc924f4847d474f3f8509b27f37ce6aab4e7a9b5a57171f7ea636612d2e82992dc0244b250efe3171dcb82ec93dad459a3cb1085853a776b848c284df51a1991793c197cd61fd85b833a157fc1b9488bd4b73aee58ec91d70c461bebcb316013a883f5621ca6a8eda4dfc7713ef40ebcc11e9e7457abf53569e285d2e8d83587ec9c97f0a38ec714cb87c283fdfcca23ea57611b98cf88eb7d57243f948f1d662a6f3f9a1c8e9a9e611b4aa9f4b95fc9998f05089704cc83fde9b2d09ac4826f4c16f08b3f6ea1cd0a9d016903bebacdba2f046e23b0c9eb44d3bf3e9efec9133ccc600eba1afe967b976fe7fc4a34dde74e1552395b72c3e2db7c51ed6dc85cb32c12a3b6d8d77a96a2f9ae31d1094be0192a50806492e95fb6376f2c37354e197bf9aa9514f82e4c0a425ede9ac1877ec896a65212dc13cf375ddb978d5be927791ebc379973f802faabae7a528e1c87091dc3d36a656cf97c566d8512ee6cc990e9d6062bba42a3536a7e1e2c294107a6371651da800c201b89bb8b9d174e560705c359a4d33292357a72d3284d78340d246ad2a28b31012ade370a3184be8cf6ba4ca976bafb782349186414b6d657904ab780675ff2d8398370c42b022a7c811cde68e52dbe95fff2b0aa76515d640eab8d3a0d541e2ebe331119a087730b45fa0145b6ec664f1a746d47d923dd624aa49c5d297ac9dff013ab0bb370491eaf85dd1f1417744647f1599431382d834e43921800411cface0b1c5358875e7aaf65a13285c9a70f655f9c363a5c17956012d5979200155016310ec8d17faaf77c08db73a2d95c9878e4283cb413477f81f1d2861c2edb00ee67996c1a845f04aae89fbce84e7372640bbde79f6d54bde40343aef50df6ad5d107be8247c4c4718d659610af440102916d8e6173f333a074e68d996014ed6335884b0677af2cba7cb4f5873f6dc14355fff78eb3f012d9bcc391dd93aac89407bde6dea00a9507e38b817f0aaa8bb24f8c77a6098a6ebdd73d7f6e5c666139f26412833c20f8590d2b58e75ba4dfa1bd0047a378e6fa0acfd5a62538cb3ded0170c4e40259bc32ef2b91bdc33cf08c72d4055fa336802026ccc61ecb9f9e116cb0b43c5cad4c0fefb132d41401433815677f202ae8f6ed807478641c62db51ffd92fc3619d9dc686d4bd935ba56c06c281fe0d1b36b636f7c748971ded202e3e79023399f991fc101ce0a69fa8de96b59a009b8754f51d1f734d64bdaf0346e2612f8995c42cb238501f1966c01489d9a5f380413de05fee19a04af0e8fde0ab6bb430213460bf9bcd43e6fa3615ea842804bf546f8410f16834bcefabdb5bdf366de990f8c5ec9cd2a4749e74494beb400c02c3fa214dce0f02f2f268eff297b8e243e802e15616b0706d6a51626a75007be118b32ae2f56cc50154d71a22d7cb620aefb22fc93017cb3f3753c5bcccff776f931ab1d8199ecbe6e0d310a575e48ecdf286e87e9d337492ae8d14351f9ea8719dd1d5f24598aa8224de5d7ae111539a38298f0e962e28a5d27d53de309e420703204d6f98aa4005dc51872cc57d012d75de9413fb7510d39bf81d81a6e0cddf9af5581ef005cff59bfbe852d7db103c654632897b48f53986388ec9ed8dc8333116dfd352b1c7b36c243f79905ec097c8a27c85ec4678e9b28be351555370317bac1392d7ae7b70f11f60b19ba457dc7970291498b7d2423b4ad8e1220ae219e5d9c2a860ccaafcd58aedc56720b9e9927f113656b8b5cc599d3a7f9e98689db2eaaf6ea4eea4009345c847a90d79aebf0237294679da382d875d1de738e53a26465e5599fa4ade4505b965c7b63a27282b9f09af06ebd3abb4f949d9a754eecb4ed5034dcf894302cd97796e1581d954ebd8e490152a8ea4423b0a62a03fe4d53c4a325ef9766ef9fc4d2ad02ef82b5a0e07ba21a63da612473c4002bb6332c2fa6d9ba02fa4523442c9633b0dc3435856919d1fc11f13b3f8ffc0fb850a34895404d342468099f4168d1adae0e305222a0c8cd22a1aa9300539005efba03373766ec6b416a2b4862eb71f0f8636441ff18faadb0fb690b85da99b0a9a2fd4e03658e6bed9bc914ad4a09767a07f85f4b1f30e506888dbcaed42a5239baab18a247849d0c6f06dd88f79c2afaf7663b17804107df15b024e2a6cec13edc3ea220ae71cb9feea0731e083ed19206a3b933a7c594b550c7455305c953c05767c71ea2c584972841e059209d7409c21785a0ce4ac07aa54edbdd1c3ba8c3aef404eeeb3ec27d3bf9c262ddffeabf32ab95b62dd6f2bfa9e79999254b4aea6c61fd5c28296855dcd4c66064098aa1a68f9b99c7516ad3414d835dc9c903f48eb9ebf207a3b060c7970976c5024066c6d093f45ba160fd40224fbd356b1ec1ee128df002430d4b4a16474ee2ee37631198014322b887174dd3c1bb67c3ee8ce542feb122b4d6fdf6045176ffa51d7607777d754a7dee93b41b60fe4e79a3cedadab0722f5526cee02e37e856bc990b779c569e0f1e0d770d73525b0aee89aae306657b60d0a204bffa91ba0203d2afcf20c87321f2d6700945221c2005d17c7a27f43f9d7fd2fbd1ce2bffaf6065d8bcc852354b74e534bf6f1cb316ae35d97a5623156016921109449ae76f0c3506f99fcfb9dd43e5dc88f48f778175ccc9d05a900cd82aa1a4ebd354909c2b77d0311f526178765a5061c8464608a386e35346b508accaf9064bec68a9b034722c76c5c3173124b35cd39cb7cf8857f85482cf7a6a3eeafc7de73a39e0c9baf15caa22d057d2fe216bc0714a4d617694d0aab2b2a4e9ba9b323b079bccdf6cea5a77304f9ce37590576c3dcea0dacf41890b1f7eab6dd886d3ab2fe35786e4266a73723045b95c0d528c81a697b5a6f0e8f93f4bf8638b1b4a50cc2d0651b1b77796a7512b12e6b46914bc9cba894fe386ba634ab4cd45889c3f631370c1d67c2281e6746542ebf51c498815f15e9a4f9fa679a0df70a8d6d98c9f3e11ff4f9441af6e5a90aff67e2e47466295671d676a8aed27bb6b417326ddf1e89d9290e1ba1e7c07d12248bbed0bb3d47252acd8f058be0076a5db7cefb026d91da2ac15b9ad69aa3347dc22d38ece631e572d866824a5b93bd40527da4ab4211dd49abbc0df639a32580814f1d3053e53bc0e223565e6d0c731790893e5806236a310e4b92908d2e4d27367eedeecf9af29fb9209216061a07984d353f57c4e0882af38ecc8b39a8efeac4a04267a177be375777d5ea9caf8cc1804cfe05e2af63a1c348fef42bc1be5b4462c15a1e6c57c091b8b91bef2f907284eb6d6b5e6efd6f922d1993511ab8f7ea2d51a8e81ae49b29a8ed50a370ef868a2757b6d5144090a61e43c290d4701ad266194e4cc0da929673f134fe890b7cbff098f194d6ac524257bb96900b3b6b707a1362437be3471ef21fb268002bb549ce3bebb0bff0e7057dadf3b85ba0d4ce8276ae4929b55513fd2b63f2cfa78578e7a9605aa882cef4fe5ba30b927fa527f3629f677ac4bc518871d222966c8928c6004eae4d1ccd87fd5e8faf72f3fd04614c7254f09bb2adbeb773a8b28746252b5ccedc9fcbb61d02970df5a8aa15a9f51c0b847fce285783b1ebe8534cedd46d4b8e9a49aa728bacc064748012050f878d0bfedde8f0fbb9d1ff04b69c03add5c33b1d5330e948e249612c9fe56aabcaca94c2ac47ee9b7b8744043eb8fcc4c9ab20296e7d40dbcdbffb4f6e969debbb38c74c81bfce636b027d1009192e1bb98c95cdb28b0fb19be2b5776aac1489ac8d30c1b3bf807c3a6d2f6180c81687c1ef9b3731e7a4cd865c6f3150f24775b38b5c418c4cc13ff5663d9d4fe9f83211a779510a567000c5f1442483321d3c2cbc2aa89bccf700f5d013ffa7e0bf70b20de4611eeb2c82ceaa00d00756c4b2c13a516757a10f98379fedcc9b6c7f4382a792cd6e8749dc3c712b33403edf6737e3bafd0d84debc31fed69d2819ff915139b47b5c3c33576f6ba00074c73332c7af46e0a52384cfc2165436714b77546a9d36c8ad552865066010044ebde419c3bc781e704fc274990cde49da2a308f5042ffdb1f953bb18f011dbbd726020091bd41024f0377b4e32fc6e928bf3753e566baa73b79a3d67bb3acc5fea2315201d5e50234ede6a2387bb147c3c4feb0a3dcdbd50abe6e540f7673fac3463214ed49733fb8d486b7bdebbf89ee4e9d91f24f67dcb645434bd7439df04ee47267ad9b820ee49a3bc2b601c0692e746368d128ff1ab9e87aaa4058fddd4839799e895e816f2787c2550800616aa519aa6dd93eb055b3df962eda4d4c28c8ce906edaf49c642e9c9189063253ffa5d284d602f620439085c172d3be63afcd0ab6a5fce2b39d73ae06db75d0b29db0a83d00818f26cd185f2d75188a0c537fa87fa5af8c3995c69eb877fa539e36875c51772299171226531478b80bb5a650dd4ab4bb5a6f140cc006517aed3a29363f0adb72f137e00524a1931d12631b4c2ca0e81c29ee98996602d92d11fe35e2a21464d9d01b1eb124ae168d4f067557bd7a0d51683947e37d69d4fe1307040b391a662484c1c75b986ceeb36a283f6a46befd4cb93c6e9e9a1ba7f405ddb7ab0fc61f692b8170b15ab3aa67a859b17cbb4bf57fa4f66c846262aca24e835a53985dc8874590e032909e4723a10730563584018cfe9fdcae23be16bfa8e5a742857655ee23bcbe6488acefabc2d1f6bdbb325179b76f49d60a69e5964f0107164baf3448531f818dff6e082af16bb61de38a097c2bb62e339354a1accaa86bbdc72f7ce8b638677ea8411cb9b672c4ca95e9c076a094357ebbffc134f6deb12866585442daecd4444135ee2719bac4fa666f40c975251b46e906a42d5b8a8fd040bc48645c299b56ad653cd3f4ff3e664636829b476b90848c76cb737a976d8d38f8a7a7502ef2ac3aed554b3421d91b5f7f5de28e70aca0a9bc32d1fa729b6c94a61d6b83d425d42ee54747f934286f3daa088a594fa8bfebeaeb56508f5308a1f255bd946e6479ca911f501c66f634408ea5c2fad013d1037e9972d401f7e75bc7c5febc23ee518809002c0934af48d30b3eaaa29ed4184dbe9403f21f35f45c49e602058a9046bdbd93c59d7c5767ba97fa57da9e265eb624e5a1087311cf2ed881f2a95034dc4eaa360cc8e8d52eb0fa36cbca874f8e31e3fee01a19515d5b448c9f2e1dd8ff65fc5a0e77ea2d8e421124b9c0a8c8b84152af45785125703c55d05e09be8b81674432315440365c9c705edf24f2d347d2356b418c963f10316f3d583dd83eb51c553da49b39d7392ba0c95fa562821c319a370d070590007a647df6a588749b1910e1e1f5d440baf5b11af3f1716d1961d14d8f3328b3ac8a3772dd230cd1669ff4e2d98650c10c27e078ee3c9a8ce838b70aaa19d27cb278e61d0b6f32fe1f2a75a5b34c349b768e3a577fda3d65a9bd69a02c6e78584733bdb858e23d6da81111897fc85522b1287a79757b6c775e49b648cfa1e251dd32dcc6f2cf46a9a06bce7bd5545e40751484f2b9d0ccde4de95bb54151f233037d3ee87fcdca70e397dbc5438a3e883912c9c733dbc881e649696fac5206bb2f71b914cf11c24b935acb48bb29cd95740cb4982842cf25d7beb7b463dcf8daacd10c58222246e8bcb1cc4b134b774d83b1353919a1099bfd1ab2a3a756e058b8c849a6e1b2dfcb3b0b99423f3326d3708e51fbbccebb4019813039ba33b3e7ede69670d9bbf82657d966375e6a6edcc4465707ef4f29d89d94e313c3e770cd834ac22f51a0412140e0ed1b937dbbb5a1c5bd0a19ec9fb462c8f0d97aefbf28a80e56fdc84a8a3cd30815e8de21914a25e6f52fc9d3d88c2a59f75a02f8c4d6e86fb3a9b098be4252ffdf6ea81e3b6809a7ad615d44423f51ba78334ed754ad39e665e6780447f0546350349930d1bb2821176253c9fffee6b77a58b020b8091ba76d4cee0013377ec0d7eb95e030295ec914a9115a3575bfab3a22c48b75eb2576073805e5592389fd6403061d34396fc8b306d52fb1e8b6619912034cdbaccc71c2f4af24ad58cce83a6662935a2c3d6f12eada86dcd1c389123824a9f9eedfa5bd29e365b3dfcae0f1cc7f2e0082b128418fde028dcb58ced148084d054a272729b7882b725d7f3796cb17b3e4a168c22a2ec66d8c996983800574e39851b1d129dd65beca350ead7e3ec75160dcedc0f6377d01f876e99bcf7f6cbcc5951a1e626509c089d521cd5c355bd4c3f36de1c7fbdf48dc34f6c5e109d2cec039acbe9a9ddc6d905b54bf5fe3373660238309c3e06a13355086c899c0407de39fece2014a76d28555fe12efaffae0e084ca7afd4505f22ebbc2d0ee9e147e1650ab75b443faabeda54d0c7b385ac8fb4329e853f7eea7067537b8a4347ca768d1f4ebb9b38dbe44d33922b23bedfbdabce9454b4459cfe798e6fb0b8b1a98fae89de754c6ab7e0d2c34014ca165b581df0d084f2e4908201d550dcec78dd4637e58b62209352c154a7cd8a3fb4f7ffd285aa2150df1484e09e2cef40ea404ac7f62a51c7aa4f6fcbf27c3454326aab9f724da32576a3a88cf68baf3cbcded13dff8c5d4d842ba85eea0a5dfc3275cb6446cd1c4ff7c1a9700ca0800f90fd1ad98f3f0f20b21313d8ab34562eba94f7f6abf83655f7849251d21e2da5b314a97606611806d37275007ed32d8b990b5b286c5a832dd675f5bfc502fca15a9498e8e3604545acf3c8e611c90035e618956b2c2d403bcfb43f989e84715a44b109400fcde9b12966e18db7a6edddcb754632cea2bd9f0f4587c0bbf71d2b0cff2150cec3cd6ea28f75ad4a7a03dc6ef697c1fa38785e95caa3bf72faeb59b22b4c6df80757afcd886cd709b5df463adc4e785c1836306090e845423b25eb96b504f5e5fb3ef0684e8e2a896313dbad2d73d303081f335fd6ec203e7e726dfd3646522dafc6d42cb53c63ab47cbee480ec4cfbbac377d23f6af24ad56c22803ace3beda524de06a6607d56c7dc55f4dc1c69dc23e26aa80cf43a6ea07eb57907412ccc3f344c137817f86a1864900d7c69b229089de55280e63a29b074b49eaeea2b34cfdd5d89b36294db02b2e112fcbb4782115bed0fc2709301a91ab52d4b4e30435578ca3860e37ec78e794c0f847309096763737935030ba3529bbd7c68c1f2615cc88baa698c70178f609f94d37a771899c07c1d3a21f9945c61ccb3b7306417f74046fcf9a8a73eb59110de86325a938827059ae7d51c841e39a3dca89832fd238011ada843442cca2081360e042c71bb6b32557c5e67dc01293a6794e5c62b87c034b7f07a0c712b93b1fa68c5b41d68ac37c5fd807d8d470cfb0f8b49c86a1cf7ac4078f8fe8c4d8a86b72604589534b30f091a3e54b53241b9915829693d05b73c33fc9e3e800d0c5da36c5ff651210e9d7f0a5327ea40272d7da687f7929445f4c39710afb4a74fdcc8fb4215760c80c41c6820d52778afa487ca989159eed0a256f22eeeee2bc4a4a22affdc335cfdbd5dc317d9258cf2bbe7b51f66654253cd49c87e94c15c4e0dd2759fe35d77e5fbf3d9a9feeeeaf94fd50a489f0dd1ce3d21b30a32ad4456ab51e0b973dbb37ba88972e8f8b64c171bf2857343f25440946bb3e68eb861076a3886a9d51d0c2bfd5f6b14d863f80fd13481338272c9035b37980b46482ff0dca40a85a4fed119b5c650f4c843d2554e95a892ef7f0afca9b7df641d3035709353246885fa320d46234317746e9ad67f272ae749cb9ce04813c56b8d7b724ed62eb9916ecf9fd0c1a159155c90f0ec5e71aa173b6a3a74e663ab25b2dd262dac67266f8a5149d47e4f26f2d21ec8652ad41edb1a935395a578ee75eaaa6bbb6d06b0dd858a9f4633c7e04f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
