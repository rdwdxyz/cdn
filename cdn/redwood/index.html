<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f697652f48d7ae0014910eeebd06e4131c0f3c13f06d25eab20f755d61be42961279da6ff72f33e01228f05eb565f4a54ee9896b35eb2098d81cc52f0bb8e224394725cfc7663163d3c3e0d8d846ee101ec8a6ee0322db182c9f134119cbdaa68037648483d75d150fd6fd3f2a821ecd956a349e5655f5647295379c8a54a3ec3b632d5911ebf501e7fbe3750d1d9450310e86afc146060a13c8d9778ed7c0523b9ee1057fec71f0eb6dcd58339e478563ebb1d4328317314a61706e714bf4f0386b24207040b2692358e0edc402756c6e756f269fc7d60feebcff5bf3bef5ff630e636ea82193a93ea784e2c7c5b3963b4fd5aa665cd9fcd640061b8db1e4468bc77b6db89bdd2cc609a93e5c7e07e8473e0def3c1ada8c2fd3e12bffe6538199c15a253cb11dade9a4981153fe0b0b4e899f54e7ebcec9093433512aad6a238fc4d2aba8d4241b884840e8ca78e8e8f754707d454966977ba48205f563f1696ae316d280c318a05c8984694329309f548f237be4a3fcc07bcc7f33fcc67179f9d407a14b3bbdad4b5a5a9de3d30d5d6deaec5b8992994b3e03e9d85dd76e9f21e061da4ea99dbb84aeefbd7bbccaec09f66c95e2de852ab5ef4178118c78d1b37398dd53aea3a558bdbe5ea69a9522cc6daffdf863fbbb64cd30dcc45e72026c16592f3d9b009056a02bfede538b9424a5c3a61f2255ea9b4868b2a663bf7bead6cfa1bb66cc533a2b20d0122f7d5c31f5110e0fa7993aeb3d96c076df372d1395144f5b64d54422ae29dcb0b536f8d15e36b27045a7b621d662eac73e6a2982611d94bb6f13ec2fd518280f0e5420961a844d8060ae1c1f82c7acbb7690230f758295a1ff7311a582f16184a9b5eb96615633af8512b032dc284577a29298e6cce7666f87f6da61816c1be98bc11835274388fdfcbac1745837d44fd0f9238273347f1b60412b6c2ac087dc01e7f5f6ea5268021f7ae479595cbbaf77745faf5e729197218e037fd1f8b81ca5c7c3d74fb9fb75dcb25861d98f6c2864e86df21627aefa995566c67d26899766b6c6de68b819b60ec10cd6bde24f8d1a8c30157e8351d48bb107af7cb8e3fe2021a822960aa32f6da4998a8f7b2a6339f11eff256502c3286ad4d54f6946d69653115199510fbc8b4dd5683374c46aa6da66de067bba2e05ca13103a60b73da7174f770c2dbf8f966cc52c3a4f95b7234fabd7d95e7e59b447d22d9aa1aa014609ceabd609bb6e8fe1717e46eb86027d58356ef3468e4300147d9a2f31e3734c37c4b96961ecaaed65bad353350adcf0faab34c1bfdf003717436334b5191d9038da88ee668e654a87915057375d78ae34898e0e02e3187de950daefeb3a418181646df08928bd6f12342db3bebfc3f3ec5f2736ec753830e114934e3f39b659b414ff4b61c24ae16f456563ad6fbe02e47147d07f188c56c936a35b509ab3765d90036019b23b1b02d863052133e5b0366ab9d3510ef55d46f1efa2c1820ebc4f041838cadb688e280c8f7b54d750c33eb821a00522d244d7585bf7592924fda874193f197e29892d117e3b61659196db7625a35c879eefeab1878ab237ffa04b5b587d42d4a86fd0d0519193bd291250ef6ecba81f7819fbeb579fbbb39b033ced32a1d924f85d23c97209d7951ab9ef2f1acfc4e0850bb15504a74ac5c691c092322cd03259f0e8e6d62b0bb47fad2740ce8efc2291b6bc338ccefd3d266c659fc25ab267d34001070ed8a68c70ba27698f4eba297677cf01c93ee89611089f9a010d79e74e115f293971e6dfcddbbe2fdef86e5ac5510f5b84ae1af57294a09690a2198bb371ff78da60684a758f1de9421ebb91d630e8eb1de291620a6e6ff3c931f3d7f09cca50ba1519b1402c55c9174a806fad973b45a66205b2fc8038f52e7f73365ed4a9dce9bbcab57217d70062b18290d160b13272504f7c2fc321b854b8f213bb12a65a2efded3826788e0152d881dcb0b69f3fd7385ec70cd0801b95945e8431d4487c7acce30a67730312a89ba578cd2531ee7db32ab343f7965c8e43587422cfeaf7ac9ad8f07580df0d8864d9c4c73fb6b4455b3bde522bc0b7b1672ec8a66c2db84bac631bda6ba2394d1ad585c66384e9fe727318f68d73a01c837e8336bf17e1a14835967bde333289e03fe1d2f15463a56023980955085bf9ec809dd9b1a2d2d532439faa6986b3219f18c417f21763dca6f65451c4c0e141fca45268b92f57335b627a0169f797d3c8b5e7bc747c4ae22ac673334728e15232eee76847e4a8f387c629a7a1a4074e830a298d65cab1288d533b8d1578ad4524a856464d5f17965f72e6e12feb7693f174e9e245fe70b5fc66ed8afaa58fe6d03e180112f8dbed4b4b9c7562c35b384b62cbfd82ba13d43ac96a3a8569154af124a535a04ef883d4f8b9a13dcc183b32b18c968ddca1c17e8eca69d2f76c738d7bb53a45097a83bf66907e9d686d50ebdbc026e0efe86f66817ea856b9a87cefac5091af1b2b19a5e6f624e045aef3f32550a1c64e298f5b04c61a557a832742b7e8908c58ad8f86ae5caf834ef1d28a370f1f678d55054394103138ded919800bab8c246187149c8da0e93d3b67059ae95420887c752f772c48c56f1e4bd1c6ee7c2f5f70d430dd2a5aba648a5cc069311086b033ac8f330bf7e799c199ecb238013bbb1a4c69527bb3f56ae19758c2c3fc0619408885b93de911aaa404bb5c7b42bab1d6faca5faab89b69aecc0e46fc42a836fb2eaab7d0f34bab01859f3e2bc568097b8f7179678bead7550f1a988be16341b609b993c9ca0ac6349e1dd3812820b6a26d140fee6c1a0e1a4742eb50a8daf5a5f1bd911478c41adad698c467334c21758acea821f8674c36b6c9cb7ac61a10dae2a68e01f4f59ab8aa244b2b4d7602a512a44239d0d2d5870f052325a1ea789807ca815e94d84385491f2e77a7530b78fbdf6b5a1eeea4fe4e396078cc30f82dc02a977764c5ce2a92be29bf0b3c123e3cedb655699b96e70a386ee120fdf58d1a775c4cdb58c3e115d38bf7b4779a2ab9e199ea4e00f0638a388d980f20051f83b835736b8f87d09c489f891bb41f666f512011dc1a52288059eb28c5f5c503c901939729dd774b801f3f93ee857c2562936344355bf58edf3d0c770ed42d3b4149c1418d823ed750ecbf800b826cbaab290073de57ca8a8efcd38abbef1c77fe396336735587d6e999e2c3c48648a1b8dd7facfb73d57374fd75abe6ce1e5dd3efab0e57b4136269499531ed5fca0b41a9f62e95a6c13a2a4dff19ce3ac810c73e48fd25caaf8f5cd6e4c83d20d5c9b301d623d309c32b63f2176eff6946b6ac12d8b432f0842e068bc27c56c0f7b30e799fa9e74b72ad723c867402a51609146626e52ef89a0d18597799409741512ea8f1431aebb1d2211b53dfd3ab8846a102f4e69b5597ddb17fceeb10329fc615f424cfc03ac1a9d7ab8041f3709e14c4b5e9806ea5afefe8fbebafca9e6b66b84355b2e886347711bb68e276d450faabcaae9be5cffb36cd37311326c90a277137ea1ca72e8930c0a0df50e2202d4ccc4b2532cfd0f535da5f80ab33d7570a1221a4d4a27a4d91d457469bf4498b25f27a058880c556f225fab32a6ea73b36098f5f32fb492a35f1ebb490e5a63ddc44ed1e8c8d1b6bbae8249a820b898971634b83804b8cc55e65f2a74fd5733018f6c389588f9f1871a7df38f3332b8921ca617b7657d3f3d01d4f2a080313f3ac0102690791a347b39a44a896ed85a57d9ef90c139d20d836db22379bf684b786cf90190c92a77ec51b82634e92a1d91a7195a775ed1c0b9247d97822235435ceef536dbcf5585cb63ffff3165fd38885aba146f37eb1ca58969c70e266e088d094256120cb290b62466ca8888311c40f60811b60374c9baaeccc09577dc894ff00a0ec5ecf25d2cbb8a1ab1a91c24326aa31028fbe3783d1be3894d156bd38f2f1d72ea42dd995605ba75c7f9fb472fec0e24c7765fbf2bf65db02c8f77bb853183be59db9d5e275d6897bc3da951106ac98dd9897647f193223f7f9384ff077677da847dd24d9dddcc4f45cfd212ad57558eaf63381bc6929425a50befc5344a2b6daae105dcb4d15e368ca1ccb5b7125224eb40ac6cd2a28907bf237176fc93ef093099d05bdc2a1cdc0da790044d7362297a71087681cc0cb219a5aeb49b8822d8895f2ded3b28ece879ff91b5f0bf826b84bd5700be8d42f291e77a3d76c553e6c084838832b6d2950e81f01f2e267e4732cc67075a074a6136fb63ccad47107b817c7386380f1530eb64b5f525c622813f111cddffc08aa05f9d56569a7b6b499f6f6ba59a0183bf5df02a708af2d23bda19489ee4c90aeea2c573a9d7404d792099361e547892bfd7a8b863edfbc21afdcbb681a897d6c16e49b56d8bf66d0dbc4a8c4b9c81635e1103764a4e50bcee23b535a3b0b904a66d56130d42bf6784afc20661347fc9cdaecc60d39eb2929052c1b86550796e4b5c60e4883f11bb4a0c348c816295a161ad0a248ffb56c9d4be93d087b8508f13af92965bd61a18f23b0fbf82a2b91cc6dfa17af3bda7ce0a96047b0233bb7027a7d8dae4e5cc18b0070dabe30c29ba4d7b88b0d4ef577ba4dbe2e5d154ee085da76882498f84a20de65e5dbfd7f10474e7cf1dba93430b2400f0a38ab61c2665d1d3ec1f22c3d60c5666537e6513ba06f93974395d433815dfc9acfe3d09b801b26c2cce68199e8d7f8eae60ac5b67be8708cbb1a82637cbc258a99f2d6448d7b331ceb5558e0b91410d3cc72aa5bc7283e3b095e527bda2d4aa568e5ce188352c8191d8324713072706ed38d58022944d750841dfa6ede91caf87106380f0594436912906e3d5b146ea9221fccc50369c48f8de1cc5e6911171e7a7b7bc61602a01f04f823298e910ed709b1081524fca5c1fe045c79357c3988b91f8dd7e0d672a0fe28878c7366ff8fa3b5587c13251641649dbffbd188d6a3a106aa30f5210d6b61e272c74126b569a05ad27fbb8e78bf398b23c3ec6ca289c816d78f1a2473cd19365d9e1b5244384572521554d1899584526ab83923736e1b3e36ae93678a37634bf66bfe0ea1d547871480da066d5d2a2a2ce6000ad59f3e4e53378ab5dfd41278ef7634bd2cbb640c385d1a6815e723fcfc40d19b9ad8e325574e02534cf25ad174714535782959dafcacea4df9411f9454a5435c96f51d93453fab7d10de4f1a977bd35746dec01406c677bb8ba989032fb5e1ca50e77528a62f35961b6e4d37854f30c30494a1544f0493734365a0d685ca0ba8a4a85b5949e34e67770f0739f345c996c06b2b0edc9c4401ce0b6ce1514c61728eb1454e4d7e0fb4421571622b66027f3a199aacb79155ea9c53a1c8911b52322889810441dd1cfef64db57284379d98238e967eda4b8743ec14160e013f2975aae91c2cc7d29dd08e4629caeea45b7df7cebf1d7ecaf285b19c5b8e5ef2f11f4c850f2de503af2c0b3857b24257f349d0dae10ec21b00333a95dd44ce2c40047fcf9ecc7d370e7369816f589337b22318a0a0bec1e6d3a64e366f65bfcd02ebfb641b99efc788e6891bf0a56d226e850012ec0cafce8545dc66210d645cd12120764503da5d0672553c04ebc2920c24bfeb71be8bcf98640d7f34925b390b8fcf322a28a9ad411e332bd376a829014d44221377a16b7d6f150a0865d4ae9d9f1a35f2b71df5594347f8813f6a247ceb203851a219fbafcf7b9f811ac3f4ecccd549e0c319d1d965a977fbe793be5893c774cc34b30db838e330134dca69cbf6cea93d7576efd8cd42f37923cda26d411fee0306edd710f1ddded440bfbc0f061c890f6e01e4b6649d7238e7ff391663e2809886b12370a085eac89422a6a8c14c42b3895aaa3d165b2af4d3719a60601836ace77539e46112fa53dfd7ad5161ee997aae242a9d21ffda11defeef4336134b5e1ad98a76cc117cd0b53b2a22c6a104cd9ecc70e60b8b3cc85bde5decbae4a32bb1b11d6008671abd1b0eeed1972adb1677300a67a454f642eaba04a31fc639e5e6b0af65b598093209728dbec88e4c7f7c4acd4fae0b12967305ef2aec539ce256d72fa1de8ed0091d234618d76589c79cc2faf1215924ed73a9c501b8350ad0ad183974372e12077b7615190aead3004b7f62e21352010f7340c26fa5383fabb51f74383e47fbb40d52f8ea8723b28c090bd6a8ed6dc60d56a66a920f898bbc4e13ada555d91aeacc2a83735ca802af510561af5ada82897e575b1cfff8c031b589f43c8fd4cd2f5a45db5ba806f1e5ed78a04167579f6f230aff6700bc6ab1a1bb66a1cbdc005feed9662eab7fc4b8a55c67f661065550399e2a9fa4fab518aa212fe63bf960b85364f67caa5e8aaf62d4117a7e2c12fdecd3114cf6f3826efb8e65ea6d300f67d5f4cb6ce858a173a0978016a46432472e16eaf4fffc4f54b032fc590916219bb9e6987db5d0c43f421bc76fb02faec2bfce085be01748a236b9f01634455ecffceced4198f740825d2b8edc7650a80899275498beee96af56c830eb8517704d0391d15a30753c57791d7a2ab14e273b7a75a36e6852bd4d727650eb3112efb6a3a2312f811b9287f650381d701b2ede7a46799318fe8a0def5fb699bc74b311e4615c55b531aff1361b8c9dbe623b8acd29caa3ca0c75914f8ab32da78e41557427bc895ae10aa56aed42499fa00ccd85b286d6bfba51a194bb5fe50c9c5d8adb0a9a300a281a671ddc71ba4c50a973b90d650807576c60003b10e9c4b3d4af55f68672fe1d6332be745d2016ff82de7d58c981ab789fc7a88889f9ff2f85bc631a0c1ad9fb1931da108174c3067b71e03d8d6ea9696c8ac856e789b6899ac916547b451588abc7d40fdd5779d819d240751b4dfbf36a0450b55fa042c66aa5b70e4f4b8bed3b2dda63eadf597a11d3d93b3ffdc0ac8b40ac18809b8db3a922479145d94f5a3dbb63e8819ce3aeec575884b1e8a21f7f5efa10c160dae093a262decda2ef3d6ef8308a52aadf243f6739db921780b539ee7fd1c35972117215e777904be9d2208440ab8e386c7ab6d141f565866a267d55690694041de669bc0fc9a68daeefd237088daad266454396414835a98b7a3f5c4ee74ea2038ff62512ab6492e33d8d8cb6add1e8e75ca4c41672f9ace8f2b86d9dc511a286e4bc60c274ca72e134ca3ce70a6ee5bf4c9e9c54d8366283538b5e9063c9141c16df6ae378b32ccb85f546c99ef8e7178516df6a825832b1b9ed96efbdfc58f1960e9cfc362cba9b7210478b546168c663e88f68d83d788a12cd3ad6b824eaf3618d68517da74383a0530a557ef3efb9bd9ce4ef58b2e284258b65a136f6e6c1e6f6a869d4df19f9989189b2e0f1a4b51ad91d87db897025ae8536b08a732c7328648cab118af2d79649a4ccc7dafaf6754cec923dd86dc0376f102e76ee7856a3eec36ef2cb0351277eb6c782d4fba1ea662890f10f1d2953565f4724ee1ff030bd64b7d232c4a723e711781747fa6271e495617f59572cb1b73aa11132d1c2b5338b4a02f1a55a464f887c123a7d1b2e33b931131c7bf1db2d4bc01b98914c5e52b2275b5bbe28012f5b4489f6c2fa30c7a60b30e5507ddf1a1fb1aadce38a2c7a356fcc124844d5eca02f260d415dc8ef4f22711d5a6b6e080918b37b6940a2d3851b3dafe5113eb755ad31fc0a344c1fda77117a55d981a7cd6cd9cc86becb0e39ebdaa94114cea4e73efbb4467a83a489292bd339ed1f828115b8b4e5b7fa657d09e2251ea32775153bd28e7788d174d4604b1e9d654228d624350cf73c2b6d4f5dee461de941913d97a69461f3898738c0a6dc310b5ceaf9de66141e2f480bfb15b4ac6c1c783e081d7f1bac5f76718e42ec84b0b2a0ff051b4a36bb87bab11e77cc2bc9dc8c1e4701414076beb2468ac36e087b8a7feb18308d99d3201610b1a0c8cc9adcbc761297b39759f6da2ef54e3aee42aadaab28076d0869b8872905a441d47fe1c2f678f7b9f73e3daaecdf0c2468a49d0f1722a8da9f4c9311220df4e7948c66adead62d304636e6d5b7095bd0af516faea72c8e8a7d70d69f07f3d92c909a86a8e7f071f32fd89011f46d81d2b00eabf0158b5008e2b0351c25fdd81167bc0c40ab4725796266eae6a112b70484f88f1b9ad6e4c0b2e5def27262b1a667607cf9906d25dba1b83b7b2073d70d77a9276e248654175f3a9254a7ccd1ca6c84174bf5f3396871489f976a696f3a2ff30f2f2b63203815e3808d838d3bf8182e5c6e2e9f3c53a5d449a6c102b37f285338237018d8814dadfc584b9f236b6edf7a9092b5833b04380d7cc71dd9c8e8c1eebb1b7e61c255c042b2e9fab78aeecf1a632d6dc8a2bb76f62a8dcf8aafb4c2b8f3e18b4ee7cbfbce2ccd7765096359f06bc0ae0387b6c5b7bc588d985ac0b0affeb5528c0d0b88dceaf7c8fd1fb5006547367d5aa6238a574efba747e4d649801af7b459f56b53e1200b5c5033f2665514b8d0753dde6e5cf0fd025ec2db2041dccd7d2a99f47caef5268a7a857e3d2cb1e31cbe2ea256d1d6356f36a8d5389e35e81e9ecd5fba1892db3950df0cb82e55652611bd5143bc3ae99f154aaaf8b5173c2e58d3000e2041174158ebabb494f27956bf08a37513f3dcee7198919926459c8f09c513389303cd78d342f562dd6d92b1a469fdf01c5cb2d6e6e24e36605d64dc6ebcf9d9dacf757ad722e4163a36d03b52c88deaca648b9b6e8f55ac854207b574b60b77c72fa905b3449f52794e90e64ae2076f150ea8e578d341ae426822a969415891e4630450aa8e79441cb834013844569a3b37a39237a6ad519784847c45df268e1415212f9eb564997e57dfc32eb02a7af99ec6434a2788faa83e955156a9fcc643b411f8f8da3181f260918edb2f868f0089d00fd05eb0b7bce2f0300ac940e1c59c45395c267133e4dd6e3e2ef73b5d908901fb38603bdcf43d0fa3e1da699d6d4ffd3e68de2bca56068c055c8c7409169f2c221e374b2a3311834858d4d0227f505d922f3980a4166de939669c07380e2d79bd4f10faad547bff9c695079618cce9769b3887c0fe11b6001f655277147823c359a0e5f218db208a343dbeb34835d4ba32a20f9dc64e63a422c3fd988921eed6e966e6589de684950239862fe0a00b9fe1315219a9bce74776b27c354ead143d3f01c21cff8ead7c78efb77a9729e6c9bc7f5a484831a7f1e1c48a016119a02bb8813b4b3ae337470bb9aca248d6b97c09482702675d98ef8bc4e5574942cb892ebdce5678b21bcb5cfec2ae5f39a7205aee28e55fb958eda2b5d97f1ce1db3048a58c188bb65f8132653c32651d93eb212cd695eedd11bb8fbff3144f9017ff05de873b31bc2504d493a261291f3c0cecb80b838e602130d5a01c9f2495e2fc7f89af77672a8e27cbc3ac728eb9b5d6e989e581b6efeadb12dc846de677b03d4498531e93565f9d07772a9968646952ffa69156c488f4984c46484aeb41127da3b9fcae5b2a222115dd1f73e27e3ce430ad787b55530b1333c9b6e2fe093a9a5734dd453fe2f7f4b800c5fcc4047820cad20f3ddb25ffe980f6e114992469a7fcb7dce28f5ddf45e389ac5b9443cb1cc82cc9602b91a4e0bfd5da9563bd2c597fb99e162a7b6a221710c86ad3f85cb3cbf3f6166667919835854eecbb9eb628a08a77039b5ff83bedb568bae1f95972f8a35ad303bea85694acf1db60bfa9b8d36658f272bce9d9f9d23723341ce603d11d9740d1b8f72dcaacc35c8810040e686f21e69e25cc91c38a686ee3ff979941344cc93790c9abb9151958135a9e95519422acef3a40e26a69ebea0f928beac10d26115b4f0921034b66fb5f414b0886af1e3ea8c43712fb8ed2351eb0db710cc1468a3f4f11a5f4c1b1f6760d2b6976d2ed6c3b3bdce72846e0f74a0a62ff98d15766fc2f92b84dbfa35b8c697bd41b61936d8ff67ad9a2608af6156cab890b2d07113fa43b395322c02ac6f0700325a33eb13f7ca71cc69e18b339fe6854d6ba0b7e6f5d6f19c66718a89de53b31935eebc8dc3a8118ed0fe764e2f962f62024636cf2587acff0ad4d09a31d35a411026168572c65e97d9ee2a634df8e13269fa40d34abd17fbe27e0d8cfface2e85e7de335fb120f2387805c268d328bea372aa4f7988db6cba7e5dcd7a0699ffdcdcd22041876bccd7479c7e20fabd167bd3f9ba399b60643a1eae2ced809b638700cb9b9abcd7715f730f3881fb3610c80b4ec06ebba707272912fe4f6258033db59709bba16c5d93507a159ef00c3de0480e8b6cf539382c1d95ef49fdac830afb4e66704db11b7fba1e056932958ffade0eec67274dd16d846a4b0b52ada92467c84c9b67f96943ecb8ec838a770f29d13dabf23647e2bdc3c4c2ab5616759aeb5d05bf5c85a84056f28fae0111a30b8af35c284638229f111d9b1bd90edfcca3cc0e5d13056abd56eedcbc58565c7c7defd8b8ed27ea57b950602860bf35178cdf1dff75f266d318c5367ba18acfd251eeae6e3a64a21b7f3f0935b9af030de02e3438a2f00786ee9b91ccf12c29ceeffff33fadfcaa9df489d11182c496f6705b1921c0045436322bce957075340c07634bf0ac4152eb11c25075c67a734f30dec1670d1a2ddfa32e2e80379e5bdf5e346f82e47acdecc44a66f4c22ea974492c2d2e2b385b9a6508fa2e5313ebb9c8b9b2b2e6cb95b78b8f044a4ee4755f7df676ca80ffe113e524f6b225b88217d5a75ce89ca60ea841f5d9ff2a622fbf5d0093b402823ec98c1d874845f18f19d5ebac3200e01ba83dd34ba2c44b8b853575f7c50c935000409c0344c8a92a31424b3667f32f9770fe8bc3efe8274ae96933aa637e36b8165d2ba772226c898a4493ad78f5d05783f5f88043edd3f40248f1024eb8ca74e47c97335810451918c294841b5e38b2805ac0d304f3ab9b3749de4a4258ea670580b8dea26a3088f5d24473129dd54684b0940eb159a02e5cef16652fc6a86a2544b89c0da2f94b77cc8c52a19cca889fcb701036264895171ecd275d2937fbb262a415abc6e49a476fe6353fe4e82395ac5f1663072a04393c522bd14b9583388e204a715e4847eeff5baa5eb0c57accb44d9d1655fd67167a848426e56e5325caa67b384529daa11b63c0eaaded81d2eef665a27a382fbbf02e931352a25446e7ffa6d91761b04649f37015a214120055a54566ac53e8f8e8527677ef94047c206c82c12114765ef0f76f0324bfb4f633c07cf45a4748e5efe2c697ecd58da358046dafe131b34b3964ab40ee758001095d5b40a393e5fc980c17c98b1147c9c00baa5cbe0b31eb22553d02ec54e0fbae0b6c25f436dedcc45f898b8452f0706afff689a6aab6c6e09b195354fbe4f8a1d3aae1d38e1e3a1319ef67fb42e683ceaeba91d3a7de4f5fdc06df24a30ada42321638f9bc420b923ded43bea20f37cc8cf680117ccf1b0f364941cfc25cd89701a933b711d625feb1ff656942f0d25b2eb3f4de4d1c674d3de48e4388aa261c778066aaf865e5be82c509148215cc7c44d4733e68a44885f2b52f8d9eaa46dd4ddbdae588cb146f26a39376d245e147acea186bd43c034a9158c198708df737bf0aa3f97e23cc928ef0d0f1ab4dabbade063dc7a0b1208e396e0e7d5cec00a7fb1a64a3711b711108775e964d6bff5c6421a991eab8b0b25c569377f219c7280e5e5b56480360b72b00bf642a7074c5d4696304980a901358dd3ed70a3086471613018e4e12943b9a62c0720a53aada5031b0b4562f16b7516dbf9f0fe876fd1b6bbbb027f611f1aa471b613e195b335bd7b7478528c4493b1cde665c517ec5a4579e4a8d1b7e4c647e26421248c699ddd9bcd25a7fd8b903c1c35d75db9082c061d8644731128eb97d52aae0ec158cb8f9097a522e994145a84a15cac7a4b158d2a50b5157729960d5dadd38e91497194c6c48d51c2e4bc96198a35c2bd15fc648baf18391a0888c0c18783604b42ca3beccf0364baabeea685957da6d4df9cc601f042d97d6831944bc7c0ae255fdb5e1d4a8546e80329ca6953fdfeb661b8680a10cf5aefdcf82df8a239119c5d22f28be17f273619c68bdc25a6c7c8012286ff81f451aa9934736bde008b31b1485108adc76a618caa40e30edc5c41927db1677dd2169ffad48295164f635217999998c8ed6cb8c6865d33c7b8a0947b0e86376180dde8b598881af8a7bab6aa564d85bb5cfa4f7f985cf02119aeead3f24f29d5cf0a9b73170eebe2514709c000ebed4c5793e37e0e480eeab859e23cd7c4baddf3ea382df5376b6a1c52c782a79afe9d2d26d5e3fbc2a4853062b2830696c7c73700dacac1488071a3aa4b2b661aad3e833f3c0a4d78472b849f13466ab363334d6007c863a0aaf309808f6f84a6ca7dac0213393f0abf3777d2fa471a596725a08727d1cb3f57d351df086a9e51ca7a7555e832424aa0fb410cf49f5e1d682eafb9d34fe9c48526da6812694d0c4d8bc5c80b35065d0cf91c9d7b1126e69aa5269872a28c79e1509cbf58f98fc741e60d261ac795abfdd0c3fb62511f990f08dea2886fab0eed5de22cfb33510000c07afca4b7cfd63d4ceea50fe90a4e6be2cbddae751ebe3c2237cb467481c3ba18df52a44b73d9b93227a813ffbeadd81f0c0b7993098da1937352af933737f77b9b05e65b89e6bb3e22db92452bebdb7c738ed5604f7a4246d0844759fba98f6d981aa304da5488cb28594a409c3a92008171f3ca6079f7713927344f880058e4ea38af6cd9878e466757ff02101a243857b6850b8467363f8883795682eb68a82c00f2617ad9dae87c6f12a56848e57b301ed5bd2b7aa0589822092b5b1c47da008153ead6db59d4e39ec9f95f38833e0c80fbc1881c033f32429c67e8a0230d3806249d070782e116f0466b49bcf48029e6894c3f6572ae215852b4fc5384c9610216c8ee9e3d7c12e124cb92b3222b57d749d85857a08102a3ec8d5337074620854a09975f2fdc831b9dd32e48b08c450197247292cff599ed11ddfce438c34b31aa20d67626dafb1fc51002862ea56f38b8f3b8e7e5ad34d958a2a1b376a53795f108b316aff4ba716ef68d459ef0d60d628f491a4deff46b658fead9bb4bab0524b2b05df18bda488846c59688713e99d66649bdfc1929c6eab9d26e74ce2279990d7234541eaea5d9e3655e446e485cae66da25f95eafc2f015cbb1a4e2a18f423c6e0b85615de0d6003ddf07a5add3d3f1a27f056930f223d2b7843cc3835c4f034145b2a13f6b352912cc2e737ddbf3306d8f12e7b0dc89c1684e99992a1869f1225a8a263ba6b54f726573297760ede7ac1ccc19b14098c6409d0e7b6d8c8e89e4c80ba95eec49ee6d3671488ae3883a343d6320076ada4e77a8ac608dfea38ada96a5ef86b46d01b6ebfe4506d1073d281455e8ca10550f5c4bb52cd77770f89b2c4a5337e506b87fb54b2d3fe33bf4568e7a32b4333960aae0233777e69915a22bd75a4a7a301bed1c03a0c74499c87e9487b852ca337682f29839f41ef0ab4ab180bddb3e555f63bce70447f6f3f3a5056050d88d1c53487c333646f081178e49f650fcba242c38ccc70a58a9f957b2bc12c41cf4aadb4873b2cc2754fefe6674bfefed8b54fa1f2d8458215b11215e7ac6836b463ce0d2be28e654ca81a3c009a2155902407fc5b0307c10a46d74b4eeb7b523dbd2cef098eb0e05c38f0d889089187a267c64d86e6f8e3d4cc146c1e1006fb14a71a4260635d1a2d8bb56017aa410007071acb09f9015a9cc2f4ba542a11131a8950cff250c07f814512f4c200f3b1120e643487193477da9582a81fc7bb668221d544abd8b4387d693df66634e55622a197d389ee50bd6a6fd4ab035391f123234f6806610b31f6aeec1327aba19a1e2fb84428a20d792589c1bfe733c916cd7b5a0c150f9850fffbb861ea5d6eeeb22d1ebc456be75c964c98cdbf2f0ac1afa7f15a48ac1ea393a87d41658ad36511237b5e3497d03d45de5b094e31438beab78c4c8d8c804ca8897e938e74980a18677524ec0d693bd99d7d9cbd33be70b9b8bfbeba1371a045f17e64af8981150db13af111647e36562b6f4f779974b73af407fbb45a2e9ff71842061f9305f13ee4c3a1034515c92536a842ec5ec2b520f1214d47c2c33362bbb4480e5c3c11f2e4604223c7dcd8ca7c59d55a022141cb3ccad3c85c12dd54984effa25c25c1a12018472309375d991f780f25b5d687bc085be4c912e381ce216c67ba0ad4e5cc123ee3032d7a82461cc9dcf5e5839ee9939146f4e4708a31146ed25a8de009b97dcd544269ca129633e04740b787fc772ef9bfb80dc0b418d792be6a19e0e001aa3a83a8c63191729b89d0c81713c86b12c471778100e847c704629bd8f26ce781a7c2893342f5ce03a2b25cf5eb6bcbe4af92114caaaf69d5639e2ea1392deb694a45940f81d04fbf6d2e11fc1c22a96c6fe53a267a55f2a17bfd0dc74606481c3290ae5224d8497c29de277fc688cde8c8bc79b3c9b4f63dc8e64e740c1b91cb50e631405e546a569d4f160d1fac1fe4d16d6efff33a36ac05cb577bca3dfeb415a16c5540d1501df6bc6d168b06db8403d20d5a8aecd4551f0803b638b1d7eac87ffe1b6105769323cf856d4c236f9d2781a315eb1165ff178da21f2bde5b9d252c209355a02ffe1f9adab21078022d765d54343e3aefefcb32a5f795bffd574d59a4224cc4f1cd76204a2f6d4f6651e4a187bda45aebb4ffcf5ee922e03281f6b023d5a69e5dc8d4a3e06e701782b0fe02ec000ccce14a6f51678eb841d6427dccc4077069a7e0da3428985f09cc3d549d940d3c6223161108d3f5739b47c3755da5204ad3cce072242b750ab37001c370b049ff15448478c745b9e68178579e5cc82896ee636e4de5187c272c9d307330c902ffa21d14386fefa4cbd638d212d58d65e8a80e3ff106c31e8a9c7338cfddf8e7e7d0010259de5466578872c1aa75c14028ea5d44384a383b44243b036bb1e408cc12a4669b70275573eddcaf7c9e66816e9a50229e6a28424f807b92f1a4a75d0194a7b339524e332fdbfacc1cbdbf6e305617152330a107b467f457c90f585c10d609a517fa335295cb4e72673a9194ea7798cc9d5e6a379be66cca8c3161cbfec28f5d81f748cfd8413a3cfc864f8241f90e5586f0e0c0ddeea9fbaf930a033ee625686b62cca729ab53824c213bd2f34b115c30830add5e239f2eae9ff87402a694fd592669ba7a7e80066bda3f270023fd27b8406f8d4cf977aeb17c751d5bb83cd5f9c6ed8d42fcd7ad82379e1579364671cc0814d8c121e3cfdfc0f50072ce8b2a28125f9f8f07e99a55bf61e5d4914969932945307f63b99c00c0fd8ba57f31fff8e2b00ec31e5ff1a6b61ddaa666c8929dac0ebd28f376c8cc4d6d7313bcac727e580aea6c8b0101f706003ea69a65497e354e384241bd937bdb9133037cd486bb84f42fd3467139978bafe8f793c1f2c155f355d72263e939a3128b07763edb14ee79b0bc9a3b80005aa992a24674201aa94d16f8f69c268666c2a3a4e460ef075284a01369c36c0c50091fad6da0a74f788f49b0a028c6cfe57332d54ff891e14bc030a87ffd6c4376bc0eb59e8e7554bbe5cac9ebd47c508ce833bb18638da9fa2b39fd61a640882d828f55842d351d3e28bcd05df6d77f09b7f70956b8401afe52e92cb687f82fe53640a6346c73e79d0a026d90892dd21212a279ea628c4aa9f25e80d2322eb566383a6e2edc2014fdb574303bc5928fe75e11e9aaad73899f0da68c76f7030c6a96d204b773d4682c09c3519315faa95026e389c699b403b0112edd899180bd764623b1beecc2112ac2c2062db042953051bf9c02585aec7adf0fbd6c31c6de33f5cccf5e03133cf1b2c33c2e67890cb19f7ad8779a697614f078a7e2a7e52041d5565c3226d7ff97ecdc84a6ae248c534deee35303b37d45b6ab7af9a2590eb8a3f956c77152eaa289968ef748a3fbfc8d6758ffd3b451ece8a0527de6d84d7c07a4527fbe286c2d40829e10dc0809b0f4671bdc08aff0c9d85110b6f5f95205e4e0eca29466e78aa1cd1300a123f272f67cf3ff0db9ba875bae68714f22f459dc5077ca21bb975f532a7576b5e33996a2938a3ae7175f5b6128d7e117e982de6659953d8690056679fe13b87e842c5b38fa3b18ce812cd3832912249cca72b570cabb058580f6f4f600b7926c6ea2b896145a1c8ea8857c8cdf742b1167ae5e9a67d13f2b1a87e8f8acdd0cae4faaee009e7ccc575b021984c1521f768a23108b7d486892108e5aec8f9c8cd540515987954fa1051f71c37cf305b85f3f7c26565cbef4f0f477b748ac2f028c7cad647e675b36e5db7d4f89e8873bc200c7216e42d96ff501c4012279b12588b81da897bff74bf10732c4254f43239409ec895623446bca03559d189a8c46498feea7abba00e3c55507534fbf60831c51ff8341743221e34a761690d2668ff05a70f60626cef93519abd91a89bba2aaca8650b2af0c93219021d413f511b5c0922e7ae453fbc8c0eb7e652d812551063258866047d554dbbc9f7461e6e76715cef313b10670ba574e813e57fa69fb7356bfd02d212f4a14ef3f83de35ec84cb8b85bd535c9685cc13c16ff505cac91e749241a8dbba517d99376e6e9387d686d339a76c0a4f58fa93a74ee46fdf3527b1ec1df8664a7fe692457468346119344bf3bb4d59350cb936db3202979bbd439bf70612221ff0381cba3b4963c67adf7a60b102dce9c499dfd197158e8348fba80615fedafb5ad4d8bb72974c520cd6ede080bbf67659ab5998624e88ebf45f838ce2a2f96a6f86f6fe492d76a5a6cb858a36c4e8d20882b170523937e0cb3227a6b725d2655e788dfa2edeb5e94620450b70041a01ff87897ae472784792d67264312a227f26588e44553439775ca42a8beb227fcbfb12566375b4db488bcf4721494e96971a14f6fe435c0474f367fd0bcca8b7ef6a497055d196a956c3213942fd52f6073b85dfcbf3b92b51c3f8dd7254493107b43fe2ca8a861f0855a1ae837321937824f56ec320bd046dd00a89dc43f07988507831227e504372226dd0b11db2c912ae5906afba26209a21b69a0606efe40c772ffe47b1b5301f8ab6208d6f1a85f9260acdef4105f2f5d3477e1f439902876abbad23d20d643df277ebd578f6e3518c58da0eda84851f32d2a3870d22708d1ed9d7991fc45cdc37aae3c4799159d252609d17316aed70552c98d706327219bf82f36c80c31769719456fa2de346b99dbb18f6c27834c2dbcc3174acaf98263e3dc360e71d471ad5dc5f22da26b1a56551565e1f2650f9e85635aaf4a22021ccfadd4aee0cb4be4d51c47161432bf6eaa0fd77286a41e066a3539dd2109e5583ce1f3fbd013f3b2007bf3321a6af2f80d3bad12ea2644e20e735407cbecd057762b2712c267bd157a3d320756721f38cd116e66a21e96edd4b51d45eb11f5caa1e09716a425306ff7228063bfedc560f528ddf1be6795386e8ca04e92a5b07045b1345eb02d02ec100d42a6f7b7db9c635940bd58e6b3eade5e43e70e5bb5a5328fdcb78f64ede05f7c5e29c866987a17e8c4143e8c8dfa3d2af4eaa634551de2b2c1e9377980ea8dce5714dcdc61d0ff09072979127f42c60134ad7aef2ad6e138a44f93d07a3a1fa75ec339d0bd9e2f6909cb0c234545dc36d42ead661542314521f8f896a0c49f2927d607610b89779282f09d7edae88b77520652c99199af1048e62532ba29d748c1aeb511a669941bc1ed0fadcfc12ce94ee6b3677da438dea82fcb210a27d75bdb231334112281a943dd03d7f3b3896b1481696550152eabc3e0ae36ed8eba20c6615f3b64e56fde009276fd76b3eb8d269afac938929dfba9af6cd60d15732c5c3c1de8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
