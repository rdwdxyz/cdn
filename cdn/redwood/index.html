<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"963eba06751ca42f9953a3969f7df1399997a35fc7bb3181af33f9dea69ae9ad1e263b651d0f97815cea4fafc4fb8eedfd495cca8503f3be7bd78c386f78b03464e8aac10f0187c83805ca64490b46b3f30116083bf054fd81a3aada6d7b8f790d9bc8efb74778165c83f5d8221655668c608e3d2f76ae1b53aa8d54c99d841c15ce9bb58a87b5da87b0f65b0fab41706680e426ede663afbb8af8bb688d20ca26dc44a4449bec547788255a61a27dd91d083646046f30481c1f777efd6229c09dca4599438409969fadeb9a439b37734cdd11c27da123b33da273f59f1499246a69ac25f18a9fac2ac764b99d9065baa0ba1b6c055fff15c45d60970dc8676684855e6bc70554cdd48bc67f76bc3aab9c30770c8cd1d2de8bc328712d734eb93b2600c1997e6099603dc04a0a38dcfc7e80b8570e0dee43486025af0c31160f09576a06a6ce62f07a9988699af96902b160c2151b9b88b726c3b7be85975cf9101008a1c98c652469e33068911a1c3738f7368e9c945aafdedda3b5b5378fa7c5697ed8a75abe2d8c32ab0d0afb3ff2be0e692dfd25807f07ff1ee075d143d62afa8cea5171c205cbd16b4af4679433aafa377b2adac7fb47fec794b678a61cbbb514acad6e7ffd192ad449b76ba82788a7f2363dac8b0cafb171a3bcb77b16c72e4e0d3736e3c71430bd10c96c65d4843cc4920b66c9bab2b070b7f4117fbc6b9b363b3e1f7d846fc5cab1e9445b5f08f6403604f0a6d0a214a2c16bb1a834d4036e8ba03c34ce9c2c934b6101a03ed8253adf785f1cadba03d781c5ea36a1b1da18c8f47706e1e6ed903a209736d1d3a71a24c5993fdf400deace29191aee8816cf195e2e49f562226a52464f59e86d33b843770eac3a91b218f561462a756455c74b4f23149874bb949e1b9fb5e415bbb33601b4ac97b6d2d6ac7a7d549fbc57e5bbd063ec97cdc7f20fd157d1122a56cb89334c2cc99c6b405b99ac434007ef7a38b27f1a6bf5a8dcee03e17defdeb6d2740ed8b885b0a8a272a23175b86ff8e22f4f109ae272d224c30cde006e8f945bc3f602d93b027a12d26ba078ef03ec61df17b30fd382a7dacd900242d8be4f16f37e9186af2eaee0f18b5ff3807573de0256f59ea90243b9ea0c4f30828a4e103cddbd6fca80564aa2828e254f161685181c37a58c925ce6efe45e8a2b04bfc38c03b72694fe37af821459485a98829540916b69581ca8e163906d26d8322bd2be2d46aba7ec3db54dc53df7945845279d3bac24f2f9cd90233424ba90764ccde08dc6edf62a0bf444d8d09a0432f659de9d4691c68a5159f5ffd26defccd038de3204844f4bb4b57720f74966a4c8f6aedc09acc4cd52a48e04ba560ef00e29121daa16958be65a4d2230a7de8ef2276478e91969dc842951363570f185c8e3624d4eb420c1dac90bdbd4b2aa8d4fa274cb945849291a495f32916ae44bd1524ea9a00d93b56eb01d58aad994ec13d24204de593b387a1706e8c4da4cc54eb5681eb7a6f90e1fe915e90a7a143d888fc6574996414b0a39bd1a2307d1caeb20bec090545c3b3ab873089541598cf3c144ba59b2c32845d572e27008602ad73dc598d3d69c99ce8f45874a1305772acc168f7f79a88c17e46d5debab55ecec87bb4b35ac95d05482a517e905823ae67a95450021833b26d7da79f6d34aa4f971c4509d8abefae087a29e9110a861bc79ec8d2d6364aa5beda5507c8615ec0d75e6051c614b3b86e2e9cc93f64fce930758a1f23bab3220b18b2a4256cf38300ee951f7d71448cdb514ad3331f1658d8ad47b06b394535f7b8b530bef46a00b9c3867f0c99a1fefc2339e3965e429db30fca218c403c7799a06be8aa159454be293f3818545f0d358721a83516cf786cdff7cdbd3a60c37804227259cd7291a6997cdb7c00cda7f449046da05ef687811ebb105876dd6d6ec88b80da0af8d6fdfa314e1bb8878332e6a36cb03fc40cd9ee601255acdef805189b337f69b749936ad5cb56d6b054d7dce1777fe256bd84daced33dd96acbd784389a0fb2af4ac668d4cc7d6ef17cb412dd0a75290e0b0de69414952a48a8a4727ef55eef5dddf44acd309c65db6a92d274ac31a845266b40a55811a22613ec00da1a99579210e4eeaaedc9ab0c7ef72e4f3d802fa3ee49023547a0d464aa7e0cafacffc2512b2f4d94a1d6c81b8972a7efcbc44884071dfefeea17bac9a5c51c2972abd4c1901aa85127705f1fceea8b8a23a76d463e0e381447c6852878434108c464ac86e611aa8b022707c82ac5f2711815de66424c821acc378ee0dde4f993c6dadeb5d765d039372a130793b702dbe821ee099977c408c8dad0f73c96730cea2691013415a05551b8d720f47a306171c2084b889060b00cf1bde724b1ebcbf7db531c3df650a7d704621abd85f0426fbb8a8e17fc99cd6572c3dc2d0294fc48b45bc91c619e48c6745c45ff1fb22c906a841cfbbd302fa7a515081b58e34f654dc50596d2cc224e29700685e0d0e22e3fbc21de6e4c11ea68f3ad9a95c325479fab6353c6902ebfe4000c0432eb6745fe24b77d32026198212444d0afc29f0459681b9c9f8468e8a4581fd9274cd25e33fab7191ff85aa275d4b99446ae14334eb9733dafa6c6e25ab0c34849ce5f7aef6b8fbf36210baafbf0a0d021dbc0678a49a340a78008bef3853aea71ec52b375887836d5ee2fd0430a86789f59ac4b293f542b9d6ebe02868948a821e578240f3ef4dd6d0a6dc5a4513e37571ce8e5b18dd732809c0c2f77997c23799c2728c569af0c8e328ba812577dda6aba343e36c916b8181ad625b016ee50e181c83c7701c45ceaaad6370642b7c1f3b579aacb85dc0d8d924c58128e96777c22b14eaa8f9a11373b81ee67544b5d55f47d4f369de7b7ea5d6f0ddbc452de07047319245d3a38e13f6b7a01b3172a46077bbb7b5881908fe0a230de3bed3ee595fc159f3c20794469f6848c05403c09c25045b5e91e86722e6f3aaa6ace114d4c47daff7e0e409edc71ec09c2dece7b22b00988460d7fe913f69e37c0f488583f46aa3ad423a6201890b617e2c03e93df574076ed48ae573d0ba00d8578ea3565b2539b9071d1c27f2ef25a9688c8b1dea19f750745fb87750a5826f5c3f3f9b4d0971dfec9245c2484b40cc7bcff6f2d5586ec4f3597f33e76987c5164a5c69c6bb02cb03c1c7745263a54a4a35a18ab0da1c48552988387bbc41daceeddec0c9f62613eea7e033f7708ce565f501700ce4e50a24bc1281c02ec7e5faa648531d86f7f7afca5ae954b63ba07a6395539ff37ec5671cb95278510f3ec3653e3da880de2a21d830d7e6ed5fc3c06658f2c78be312194f5db833b77046aa3d634628fdeed956d0f3e2bcfbe7e119294b9a6005086f54ea4f9feeef55d547e99a1a2c8649c86ae2d51b071eadd8fc07460c7b2d1765624395c7c76a87695189602fbe92c94c4c9c54b12eef8566d725fdfc223692b3f705cc42a528b9d311f0e3b7dbdf1d9b43bf8cd87d6b47c0e5448bf69584a3823c1761017a809c8f8e17feeffd52a650aecade0b1f73e298450dd0d1730de7e53ca93b9422489978e3604038ba74a3bb83e450d13e02abd4f51e8701b3fec31711a00cbde9b9c32694d649d224374da2e9a8566ce53229e37a66e20f51143e88bd8fbc027b168155ec7c4dbf78272da5cba072626b277213618f7179e906c829ec319cfa8af8fea0b47fcea20d43c45fe496ba04135c7b61035284ca7f11dea483d2e94280e8cfd109ed831c2751721814411dccbcd6421c2c9d2d3dc11f9458918f512f32a96e2ea0c5f0ff86e36ca72aae98aa4d46ac3aaa101133a5105244966497b02c69ef38930a4144abeb0292d7023c948d18a971aef46a3d0adf847acaa5823e2b0829ee6e9a91b526daa92e7e29566476e2701d30695dde7bdee3afd92d2d627b61421c619315eaaccd1542a7bf273cc044454a69bcd66820062c38a2b0e483d4f77518fe14eeeceb35bf1547d6127fbd767503241e250581572afd3ca04f59133e68b0d3fde741bddbe84b34829d6ca3a161ac225a24f38d3ff8542e8f6ae107156524b0920692d56ef894a4694160dc9f12a0654f784058676d59f1adfb5d5531ce0e898c829874236d0804f4b5daa65e4061ecf4361b3794466a057b4e84972f11aacfadeacbbc120f49416fe39af31dd4b1acf85a166b949b55005098fd610d003c69d4ed9f0e3ac2ba7f1b6a03c2d1d496c6ddb0f53567e509d12ca7651238b5eea5c7339dd48589979060224e19f69d6ca5a6cf16c7a6b4d5ebb93e0a6dc39875f74bc10c70ce5591d77f79be979c8f79d35bee7bd3882382a9f4df464a82cb0feb2dd659b78bebf2f19028b32fe39a53088659722c4dc32c9665687556634e58c64d94868489a5c3fd34ef0751ed462f533940fb51b66b42526e078fea75916f0496d4b72ee7ae8c1f4bcac4476f2416a21279ced845e955da3c1a288b969c576b50e8ac60b7076fd7d01e5c623a370915fbcf7d708c4f62092477498d81f23797fd36790f6dc16a1b12a70a4c79d888cb30b589aee16140a52ba45494b6ceedd0dde0b9a29cb36cd55ece7b8fb51be0e720d935dc4518c5f389ce0144493eb7ebe56714acfc2639634c319200c15d2f09617e0286107090eafb42c0124b8aed934007c9df0b0d3ea2b4ba6b140ba6c57f0183d61a309fe0c26dbbc80fa5eebf2dc004a4ccda0f34bdbbe062d5e9295c5766c38c0f5afbf5b2eee88929fa8722c3227d182498832523ce067a626555ac86b606c7dce49ed9e34463014470dc98d362975114f8714355a0e3124b68eb720747897deb6dc16536bae683e9859a30a28d56696057a3edf674a6472124fc9daf895a82d59efa0672d5d7451c63e11bd69a8c6b197947a49a6ad6f5d2911c4c1b9a49b5f728580ac7be95cb1f0ceed103c40cc07ab6b6e7d6cf4cdb9eb29ac39a4a78036918acfe7ff8d7a2163659fe45e8fb6521aa5839b3327f38e2bbf5a83e724f953d3015c5baca6feb98dffe621dc2680a0d9540afecdf5f362d1d6028373a2f8ebc656617d3c7864df14234a195e4af2853b5e3f1f1bdac7d05201f74691092a2ad67eae6cd8bc600061247f9257df18ca0e6ab64ed61be69b026ef0a76f78a16458331fed003b1ab08db2472ef9dc875c59c6e3bb3130ce45df691aea1e713d78189a74e0e8efa24f0e4823c7668d372e405703baba7754184e1c8bd7388548b63ba65200e9e5c0884f8639edc8e39f668aab9584ab2f7fd9c04f3d5bfbbf925182b93744d534f0aca1a6705be1283760e870d6d8c34123573dffb4fb4a1571675207fe4cdcdd28b1a74953f8740c1db0c93d8bf698085b47660531b098a1e9b53f63ee3a4227c824da69469ed1ded50fc95c9d4d1ba9ba90cd13946b55ef9e7f2baa5389494be99994b2ecb5b4fd66ba30c04888c6e0d909d35de920a183c5f3874b434a99564388ccc8643c31acd2bc7fec53fcddb6b32e747bb23e6a9906afa6caffe75914e4470b9713722a463d7882323633eef13a12ce64c0b6e1946cc207ccd02f8b426846fb749a862f7e28a616ff53d605f134286c52268deb984b4d462f13df46a4048b4808fcc92bb50d23dde82d06efc260131fd90a0fa0b8bd5441618e33571477da7aa4e5b832b218afb5bcf59584f02493b053d16d553ac26f9dda20e1cd279ad3f7016bc34e856c5a7bef28c3a34ad510b1a239fa5d7e3e5bcf83bb5b27b572bd3a3a10392449dedbb615b8e861df526b300bfe32bc09b72b3cc00a56fd2ac4b91390b66d35b09d214fb8e32560de60afd10ace1cb9e158f5a3beca07257cd9b553a320aebb4215dfe5951146554561c20fa19eb52693e8245d5e60dcce83b547e467ac5754347fa4cb66109be38321a3df9f2da725b6067b1616b91e7b65bada4d368c0bdf4bb0857d1631a259f0b3bad320d928994fbd866c98e4764a36dd209f3cf0023ba12ae855fa2bca63c11b6912d28774bd4eb0bbeb8048c867a852836c0de5427c2105d3ca54ede271e7363b08074714e82150e5e088cd9c5e9a6ccca8d2348044b3c21693a4dc931d7720b9f4a7c40f084343eab2e162b631f578001bdd98a3662da1c1044fe3d729874c9ad80373a87115c42e1021170df79bed65d556e2dadc3577c31e7a2fb2d0461b44017295d29ea5c2764e6a3f15274dd2a91b88c1c00b5beae2a82e7b7b57cfb9b76c1326b433b26804ac950b5633d51983037cfc96abae4cba95438ec06f1c972a46ced277748fe5e6388b35ffc74dbf6b969c35bcdee0fa92b58f72259b95bdd2ecf25d30dd2bb44affec0d5ef241b6e661e246aa7e629c50b0f0ddb8782c310e6de4a78edef716e10bda27623f7d5b9bd90075548ec4f1f999b12f4b2a693836935e087897c325c1850377e7a401568ac23fa84a6db2d526f4f48e84a0598622eb78736f9169d95f4a41152b6a695e30f5ccd37321343b1e233f862d4005de3766ef50f04caef25d2f32f7d788efabfd82baf3f43c2460d144e260517f4585180d0fe0bbbe6968398c30e13de0b888ba07066ca4bb3d10adcc85be27827781c9692713338841a40c7f40b837b3e84d548e67c3a969bcb2f0e94a8a92601ed2e9fb3972d0ac2d696d7a3f5f2f8ab85c029f19b184c28650502f45d559f979fcff2195224a7dd9162009a1db4b2d770e3d2a1e352ef2c6d76e9f337b1b6f94a675833f62e4038669e8f1b9110142c1b22724a35a8d091dc3e13be9ac4143a4e84166f4e475cbfdd04a2435146fe6d904985d050f9291d883425a2d150d66bedccc191760dd135c164f41ea0654ed9a1935c34c9d422a17d2df9a73a67120b0244f2abdef4738b4cdd1c170c0db591ff066607b75dc816a895a723c53e0818cc203790cce985010a93fd3f4262c8a13f83f4102f1171a621af2bf7f2b57356f083ea0b919972804c2393b99d9a2adc2a606914c7fa9bb7ebeed3de929725c2dd7e85328a34c856f7855c2ea06b1b494db39992990ce104528382a432ee41adc994db4ca10f283dc23e63f8b9f7bd717c16aa8d66be5036b38e8c75d1af721c8bfce76394ad29374f0be1ee45956bbc8a303e88ea19aac9de7bc722725d2447e9b94932592143c207dbb7860b228bb3dae74d9a9bc9103663036c7bd797bc4018e85dbd377627d43fc085fb7f3cc52fadc12b89fdf4a2c28ce60fc46ba9b46cd2783fa19060ef05b30f253052d0e370a41e2febb8238491926ce39fe3f501ad355c65ac3bc8077724d6ce33463b825147599ae4c0710f0e961ad5377930041291046a3e181e80c2462bb993255bc63a61fa0957a01b273b6e9528435501a81eb684a1cd441dd1a6cd866bdcc5d2fa4855a28f903292c0e575c1eaa7a7dc5bbc5fb6a3615fc3b32d6d072dcbf52b7dfabd46f32aff1765a71de6e5e7838a3d433bc4bf45f0b0575f15e1848f6a34e4bf208bb46761626293f479e859cbe3f6d9a9040eb61de26885c74a2a42f5584f9b0b7e1c815aa4944388b4ff69682438a183544842ce69e878dfc2d6237f536c6023ad0eaefa20ebf077b4a989ff753168163e474d4b0d5683468c4a8687df08148d1f097d7bddb55fc72f30566623698d4016a97adbacc3afa29e04b559255275ceb997da9041aa84be710766f33aeee2814d675173d5c5ba59037ae322603ac062a56ada45ca5d75a6dfb266141435619aca95ac80f38b0859d84e64333563827e21628557a74ac44f604c115bd574c5f2dd592061f8662fece85161e7dbf0fb368b84c829f745fc8b3f666400eb4aaa3619f26c8e350ea1be542869c51a0a933505b4d68a153fb1142b092c10d54f802ab7f9fd5f7ce4eb8782a2a3959c84d51f084afd7cc6344418bb1379c064757a9485d98552b112a07d791b3d923d20e032661802a45703dd76332e63709aa406152323160aee0a7a1f6f9d7c1d2b12f3d7c100c42e2a4f919a91239f7610964d5272799c0d0befba2cb4ea4bd44daf9121d92ba6b450d926556e6f0c536e121ca67613d9111a793a88773d0f7831951d00a0a3a1f1491452a3abf66536e1f13e817ba1409ed96e4cc8af0e75442a0dd7c6a43e6812b6857119a7df07a43d1d1316c76d5d5c92dd3f53537f0e84de656763669f05231e6be52c2ea25e675dba9cb3b213ef948a26bb12c29d49385586198a3d636e6613482a4375697f614aa38217313a7ff85ab6c1bcaef270a6ea6b619bb549be81f6944cd38a132b7fb148c96782697253bab1e1f72a8b635cf8966912020397eef108040dac738dcda707a980416d8347356304c7c53db4afbd2f24fb5afb48b76c0850dafdfe519d458e8f719b6a9f2bf0848f1b44538950a0febb453ea5335ad08a112d8a22dda090ff694337a3f422dbf9004304ed6f5fa096568a52e97aedc0d660da5a1955424083646ebf89279937ac7020fd7b286c3b9c161e79c1e96eaeb6dda73b88b07388602927237a87698cba5236b35361431332f3c90edd2a040e1d3796815e1366c1fa7bf2754a8f12b6ad7688b788ecf6ed2b25ff33a3c035253552770c6b7ddb9824547d33c29005d415684a9a7b72295bf9aa8b22e731952a41c29d1577819fe07b25928790cfb1df286ae8fc76d367fbec3141e2b9016f9750dafeb161755573fc1171554e2b78dd9db4b877f633582dec24ea937593b3629bb3280f06db1dc03d003192901f9ca9ab73fe90f16128259dff9c8b8a765d0d43e3f7fd3c146cb799b9165be433da38f172cf19d1e6c877a9a898377ff19b0695e3cbded483b430e9251a6e1f09ff3c5afa606a94475782e08f7030acaf293ee9c2f15d04de4b580a7089be6e2c0d0e4e35a3e5879ee89a3fa87325a84e6859d2d2007fe6f7d4fded8945d840296a7fca0361e7ed93917ef6bac431e50939caf2612d53ec395d0d777e5133b98cfeedf607cf349688eec2c35c302b96afc946ea9b56e8b8ca104d8c3a234e8f1a3b6cb88ebf0767c22ddb027395f969a8d74156998345f30757f4c63490625022b17e279c98a93a6b3ec27de18c2793185b47af61de1485390367ea6f2d791a42901f9abca1cad4de7e74fc5ee2394bbe9f3519520cbeae8927fe8a73f6bdbd70b7c60b5db67be659b804cfde1255050653cf2b54b27eb269551e02e62dbbca181732e007fc2b66a233b8dcf1d64abebb97f049120dd441a9c517dd2d7c5fabf708ed2d094082625d1baba5e4bcad2d26288e07bdfc0e2f2eb881d9ac182893eba7137b92226ad2551a092f0c261cd8565c48b63e9354b39a39f76200384ba259f9382f82566b191322e49689a945fefd239bfe8d0a028517f084c55e6a8b664d4f356dfece5cae54eaaf70d9def623a656040503b4fbfcc2601babdabcfea5a4f73c255474399ec82eb5de32900da7cf3753fdef75b2df732ea0aebbd9d08abeb87a84b73c90c3ffd21b9da47ca68efed50988434b315d39ee31a3822f83f6ca5dbafa9d196fb6a6689113880a9717dd1274abcf6662a12b49f55fd0408f5bf515dc577b715ea20e350adbb5139a4e99f75bbbf623f1c2a93bca1dd9cd11c8dfff8ce99d0ad3685c781d7408f374300ecbf42ef03ca307a4470f3301ffdfe47e0b87cbdf5ff0c6713aa9a0b9e8e95e466c9b9656cc8b1ddf54ce353a3efc40b5b9076bbb0dae2b92be191cfb0989990498f16b59b11da857a9521157b6410949abf5803169a9da2187b3c0073d4772eb6a1d935ae03f5577e10c7b2766cd9638cafaad9258dd629bdd21aea33e140ccf362ddefa341903c79b2cd3d83482b529c3f0c19b099c780ff77a1588624ac97411a9c58c6d50cf0fdd4681f5b5089bd4e41fb08e681f5a13c69399209425f4f156916b10bbeb9e7645e328945bdd2bae02dc46f3e610f53b421d91cf19960ce401b503a7288f660af86246982a800027d53888140a7319724da8c5ddd89141284099bbab88ae91c68d5eef41cefd0b7a6da32fa6287f6fdd5deefe1e03465aaded5ca234b98c72df3be7cf4f182c8b74dfabe856470e6eb307cb9249937cffd42e0df32ff9dfe0659fe6689e06ca92bcbb0ffacae842a634a32c2affcbef72493b85932e43d31e122279617dbdaeea9bef0c1cd70bc4a89ee83fa8bc76b1825b5d9bedfa2ea8e01ce99e79ae5eed1d7ed1d665002b6117b959453c248a4563cc7d2a72506a34626ec67d4eb8d2cbb14541113bb0c492e285bc20206beb2b3da90d21c2560cffa56a826c0f27f7d68953ad595def95b06f8c01bc669bdac542aa9e44df84981f224c019d354d1745c47e642d040ca4a22722d7a57a3dfe999c8da8e9c8a2b22a83e348816c64846ed84995daf15ccc40d280bb41b1139d12f21aedab0d453dbbe4b55c8afac0a25288182b116cb1dbffbffc6e526bf9439355309234b6d9cfa45f00c1b98f720edbaf79f14383856c3de1e6a03a32f283f5b1e0ee3ce3a51a391c7380b981c88a58b2a907f45c8a6e72da68d9615f9df5ce9f4b02f746e00646b482f4291f6bbed1ec03e1b594f16e8b8be93ed6db608a5fe1eae9cc6268077f55ee2bd07e35d42885a628642cce36938597f3a0c9d3368aed62e58dbde21fd0360af23115564aef369f07d5f165131a0a9e26ccafee7b9ede85a352a4faa0e509562313827a04a2630bb9eed591b796a7e720fe565bd8b3c30bcb4f4a85f0c22d10c3b9a2d8c11f0e048c4dd9e5fe029c5936ced88493186d786676c0d32097fa8514ae09c7cc20e2c34d6e71ef9d12fd2a85b520e2536a134600227f97697212611523bf756611906039e18f2f28bed6024f6aabd408cb92b6beff596001670498031d302e274bad6aea703fef8507b64353619fca54334bab843ff97fbc87b87938f124903f982f85b588710d60b6085bcd06bd8487b8975deeedeccbd4ee6bcd3d8685752d72c4210add72d1f30f2910d3cb9e600a8bf89d1889bd51b02f300f664e9ee80d72b37aacf65276ef6afafa59c3f444c92b46016f14462409fba658d068e0ee3310d62e512be7ffb9ec9311b658007154065467658f8d129895759fff3d3f43817065e65d39f7bdf0abc8f374f2bf37c47944fc4937e272abb279cc84b19a3f13bd055c4623c41483e465ba2ef857953c92fb3e9ec332c135ebf6891c0c2405032cb6890d89d2372fc50c26c89e5dc87c7227d7d4e860eeacefe5cd3af0187f38283b7dbd155cd8da7e2de8b1b5fced6a4aad6aa1f991788cd234b806a142883600cd0849ac5e692802186762e60886a53d633594131e562139735a7ce895ec6070603ccc23dca2a3a9072c20ba28153c92eaa4df3e3673b8dca99a7d16877718fc7de3b242e0811b14ea7fc4eafa5496c9582a9f6f03679cfab6e39a244be8e6e959f12cda98f5753f979cf94492d89f507b387865dd69448d9e77c12c4cdd537144b2c5dbb1c0781b4411b9c73716014b8d0492fb8be702ec2dd4f7da01268a1fc99de82cb1079ba01f01a0f0266af96dee6856542284cf078473bff65b9c2f057c180db28e66398cb0395916c66baca32eb3197f4652d5cbb3151b893b4de108b9ee9e0006b51bb845c5e27823b9011c4d22b6e28055d786b7e599863b4f11743011a085390674a10effb98358033ab26504b727c758e5e903fddaf098cbf7a41a1697a9b8529970f0c553d2586dd11e617c73a1df9d67a89c57e81b0f2fe08e0c873c39247c072430f0744ab453ff6e175614d8a163e06bad38cd9d637def5c3f8baa8a009a8a2918aa08d5c7a1ae24931dd8d30daf9a7a489b972390c5643dacd3e4ccf3d05611a9336bd7cec90af9cfdc12cb7264637c8028d8f64da814664d52a7afb6b6faf9366aa53cd7b96de74c97e2b99e4c72eb3cf4aeba736daae9d149d7e88106f255931541d80bc1d3294694d234be848762b261c04afef01d1d2b0ef6691bb220821c866b2b71f3ee6c30c3082f636fde4718afc7cc22ef43b8d6420f84f7f0c620b8e41fa6dd10b2fc0f0e7bae7e1550f19f78d48b47af4cf1a9919531c215a85eae8c0dc75b307200cd7bd25c05775831ec02c7488010af93b59084c34774cbf514826671106392e50d1fbf6fd15c08c184dfb892ec544a0878f5044d0ec369003eb74b660cba18872beff51b27be90fa541cd9f051fba84e2cb11b7bfaf98b7eb3858582b899169c8a49590da13c0288b46170e0866e69bab579dbc8d1709f423dea3eafd2c0543d8b7fb30a49011cdff91540f30f40365514340a2b049dfce9dd1cb997daed1b20bfb9e7aeeaa779a1a986fd75be605ec0820dbaad6810e92b4ea498bdf94778741a73995b4db47bf95bdcc2767fcc7f6c828a0878a31422239dc83251d0d2c9d0d5caecceb5d949379a84be9bb1b277cdc222c9d4a8cd6228c99ebfe9eeea53d7f271d6e66ed80fde145bac0bb8ba767fc82f57900d4072e7a2f026a98ab2d980c6cca23d2c406719ce52e6c1bb122e27a2f880eeb48232355c7f3cfa431aa0a4290f2710b407fb574ccae6fc2dd7b2b6cca92175343f5aa84d97030998603bac18375cd53ec0535ed798ad0024f76608d88066eec5d195f810d2b48c0d0f15d3bb404d3b4976f679efae584e68dae729f87f8e72ce4a2cdc5545b6ec24d3d45676fdd5a72bb067e27170bb50b2be3688c39c8921851be373b4a51fa798518279b7158b6d10af5aae2c00c6f6157fe14fb4f6ea2a302e8a2580487b2fcf25b3cd86e51b80fe93413a0b8247d39f5560f3aa676df2aff8125c8eb7ccaa371f6d7a91a8b5f32d8635837ef6df4ab1bf3dc88cb56e173b0291dcb0767f51f21e9533beb7b9babac644d9bd0116b4b55dcf4e19b9783dfba3f78eeee0685126345bd8e815cf5e8ac4f2697074cfabaf1af79d7f47871e209db82d51f48f1f37e5f750da11a938620617f6051dd8da48a4396f6344ed7db140b51a1a32b51ce8b228ca6aa94ba2e62bad85804fafc03346e61cb8ffccc04bb362c03f77e46b1bf081e1163617e8288e14658aa51bdc169b7f1186ed3a2b6718bddddc1f53d3890474b99a2d7bebf607fe43dc483c7ef93334bec5b06ecbfe69ed8e583bb03d4777437f99caa19d5d4d5202dc2286909e9b2e7d043b1e1afcaccc2ff1aecbea1fc12660dfa70bb85247e82ab631c028661cd7e140e5c05e7854a62f660b66b0ccb34155409e2e4dfa23b270e9f962a81417ddfe36c63e7fb0c0508b693f8df81aa7cf6b7ebbba8cf621f63dd560177a8f9c34352e3f9b34acc5758d5e73d0addfbdf6707180265c83a215c38996dcca112c35726f1b542c73aa641a6de1d3ca92c4b916b2b88ef1a53575d54662fdbc0da55a70294b84595b27c8726697dd7492505c6327858573e49e8b43cb9d4b4506dc890ec94f4389b7e33d29f5eb1124e9dea09674db10f5891526df1827c55310658c210520ea60d1e8819265c34ec6995c0635709595eb66243c14f5cd134dc7d05cf63fa66f8750ecc4cf0e7037b91e52a99485df3f06d8dde180c94ab951e2a70a7011685f20555746f37f99f4bfadd489d4b75b58514796ca916427fc4826fc5ee154dca855d2b271c097660c77ecb8ca29f02df88f3c33e00149e82eae80f0d2cd569e9b77d0cfcde5a9bd1bb8e1f3a69aa5a707ebe77615318ccd5604c3b231ec39e345bc445e671183eb36e3b67aafa7ff63d36a7ec8462e316d727a562c24016f1170db7ce96441d84c819e10dbd64f6dd7cba2e96e622a0891ae768b4f3f5ed9bdd590e9347a45b76a37a991847d42c054036ffc954c575d7fdaa234f20bc38bf73ccec5b5880953ca21b3cc6fc0c9e4dbc818e45014f6bb99d59b3a17da15749fb116c7c229a5e920c1f00cf0a64bb2621ed10ecdb16598dfa01e6839e47786f6fe50daf19728631f2cd8e70c10215f7f5cbcce85fab1ee90fd754065f710cf94e87d587953b25f791055a3af5caaf7b47f8b5693ffaf6543574e21e877dd037526509f816180ab617dc89339332f03c25a68abffc5c355f7138dd57021e6458c4defcd4483ec60c15052ca8476e050d43c73462205191d20522a57cd16cd61ab8d2d7df45a2d43f727e1056663d5c6c078376c3fc8fc05f6130f42afacfa9d8811a392adaa85275653102d0c48aaaa34c841216fbb2ed2280ae78efb21fd5e10ab36881fc1c75291f5be1fc08ea1a83639dca4b94feff9b7de841b0121662033ff414c1bab09c94a87119c69f390a11721807209df290d8bb816c5e2a1099198c6de272343794c9d691e0bece9d5a12ecfc95435a7e8fa44bd1943d432d6489fc5f5b2406a966109bf9d11796a1c5e1dc16e019d8def55f27f668ed912e4d19d8560f57d3ec3d8815158b9e027c0cad1b9f32735b5af2e59e5aec7ad31dc312555a6997606a58534586cab71600fdf8a9cbe976da840a77b0d376c67b94a50fb90f41d34d3e4fef3e521c96e9508d109fd7f074ed367a15917946ae080a0a9ed3fdc59349998a02d9562fb36dd50218228d7b687efcef34c98a9eacfb5f58d997f0b94325defc751ee8b80f0a1765d97d27fb49efb3e59c3a5313911ef6270c1bb039bbb3401b1dfd327d5112b9feca1a3b7f6e8bfe37637658ec147e905c9ca7a45f56d2564916247fe769c5d602e9924132b7e2c9a7388b4234fc524680114f529da839a268b8ae4beb953e8e2d24b8f90c741ed134e4cb070d65aaac3ebf5c499c9d10a6d1cef6b53a010c8afd0f00e472a8bf8884e88f92f8b5889d243b103afbb36698f2b0624c8e1faca47024320ecf20d78a3093c3f4d128afd65f76c6ec1e49920ba5c4f3d72b05b7c411e5aa54837411da05b4fcdb09a9477de761c3964238fe8fc7ffb733123e9fe38cd7a9f98aad053a7ab91ae99fd14719ed2dcd61dbf227a8abc3b9a6f4712caf0d7d5d39469f8948ea6da2f9470055cf2ba84bd804adb276930132246d014a393a475e88fb5708815338d88972a6912794780f5a0039afcbbfc15b1d0c12088b9f78814d22737bbc029afd054d80b5c0ad7b0a3f516f8469eccbdaf292dbc79259808bd50336421937e19649022557198359271975a4391dd9979839593b6ebe3233450d8935e88a57aa9a92d3df23229115c0e5ed599c613159c4f65942f544cc9a5dd40c559e0dedf580de6b3b0d8f1683e88c0dcfb282ac4a65da57d0693a7db135e66e891fe902b565fedc279b403a9bf9ab104c7dbff2101af29edfeeee4112000792bca729ced0452b9036834804ca9b8c4c531a3749c031ed2417934c546c5ba904a7022f95ea88058f9d6ef058936cad2db872925ad129aadbe566c74d82c9c66c1f222fed739ca729f024de07005113c98bfc4e60bf1e2f33674cf76ab8c6afbc210403ece27f943b5f498a9adec4460cd0c020ac3788e3e4ed9d99f74c6aa7dd14ab1c474784d58b0d936217e9829e53bc1973cf47fb78af4ddb48d52f3c58bd655b811ffd4b175611f9314d6ab2bc936a8c75d5f92341e5d142c1bac4a242c5e73a3a3b19a14ba875a789f4a5cdd065645d69adc38ebad78b7e0952e0622e4f0c27ebf9121dd125bc7d9949bd08d47101ebccc4f59696fdbc7c4c5040eaab9ed972e39d51394e64d24a2aa508c74cd09792d2792fd0160facea982cb8cb92fa7f3a83db6f6562535dabe57fd5a7c7261d06eb3e35471d523d6b6e25499ce6f507b4246d88693b0f364abfa38b97e448aca3731091d831150c059259fb7d54b89ee9dd3c299e1d44f9ef30950e74245b6e2562ffffa9a0c3874fdceebef12340e8e9f6b7f2936392688dc10629cff843685694eb4ec2c1e41d4448ff96ca97f5309425a2dc068aa2a556c60338c2a72e0d1a2de3d839125868c12af41a106793bb1f6f6ce73a4343e0b5c83dedcae23cf3faf7c8435754a1af208fdbf10e2beae39e95261e79564cf9fe9accdc5735728e21b8e2aa9feccb816ecbe618bf6110bd4178b58834e55811d0c78545865874ac2139b2a62f77327f2e999fe859125676d4795af318edbfc562831e3a44aec3ff23be5ab30f8e9b49906b85bb8644ac70be230823d8660ded0ee30728596f75b901ffe9a90ab967948195436d9cbcb4f195b46ea53e25d9c2bd4e7034c2c7c20922c160e3ac563afcff98ea6e8e1edbd9aaa6b0d6b59e3af00fda057cee346f0bccfd7f8cc333727e1473e6ac1ec38e992a5640cb69531daa05fdab2532dcc823d37e796bbf6776c80e6aa2d4051c2542b28b1b7c5f91f8981032e17b880371ec86bb2ffde05b4255bf327fec7d338988a81a3965b91b548db19f8a40eecb709d1587cf96b3dc0e14bf04adb5bb6c10229799dcbd9421020053c9e435734f02fdb1231c21237310cc33e49b02fea9f29667d891a12c29996888c950cbff95b36098bb93927e570eb87ac53225f93c59da61cdfbb013a00429e4bbed89670681dea80810b6a7c8d02d0324893fbac7867e9f5a4bee4b4ddb07c9f6a7806a3838322b0ef3a438de6f512359fc8436b3634447ac2752ae9eb0f18900537508b4127a496736da36c43107b99ce9260f26038d1003a269e93aaca9fe6d545a61ceb3c36d3fc9eceba18d724b8e6a2523383bf370911bfa92bfcd24f288aaebb21b3abb60e0488e713c852cd70e639a6b69b5c9deadc7470fe7b92554b90ded5ce456e5e13d68baea9506e3fdcb3c4ef8637d741ccf28589b11c01a1e2ca4ad5e92a3f522b7cf78ffc9d4b11bb4cd00514d30cc1acc45a16b23ae67debfa863ebafa8e12daf7868c888f1447703e41b38ce5b83378b313dbee680e56d0ad52bb8f72b99346939c4a55233ca48e75185a8b71d1ccd127964d47a86a83b23f6052ec668394d578da9b933e0f1808d159e6599acdb44dd583dd6d07d40e6ab782b805ad439c7abcad1fbce199023eee1262f984a5d8895e4a7786db385761fe665f9ebce854fa9a4ebaf09502e0c3bae56f0a663a092aa644358e6c81d84a46a6c81e38d77f9a46a36a41f3ff7b8f2761a119eb3d363037d5f17ee1636f2679c91af27304c802b70c1d6edf561130b04f47b3b63cb30919adec2a1b7991ccff02ca5b0c646e6ba3b38bd50d42010092a4b527f6c0cb08428c40eee103759960309e0ebd2265b8e1340bfe063db7376375c4c3b23404eeb9b050f0743485fdf4933bdd03b4b8acb9d3254220c6a45b1127b39ed680e8adf81b31bfe2ed2dcce703d2a56fea8c55e86cab35b16d8460b399304034c3e31bd245b9e9fb1b24fcef33ae26eae4b499e9f68421505c156cc4b2093addd36173f7d655dd9db5eb6075ffbabf4d68c6e0f41ad6e07870317e62d63bd411ca8a4f39c1a76843bc5d4f421234d53e9ea0d212270ced4a0a89566fc5166bf41aa21a9a8add453d09f1f450978d0439956f5c0550bb5265d0edd05042d2910bb52d8d3c10ae0c52943c03adcd0f7ca8e61c383e67232bcb433a6fc0ddb9b1f69b46adc0cf190d71781748136cc5da9c40603b50a3560af45f3c99c141e1af09ee8ba8df653c5a0d5f93c56ad593ff5922ede7527449a2de0e35dc561ee2f28088325be58e52cd6f2ffba2b7aef780ee9353b87064c5dad1bec77ec0b9b56b4a0c3f011b74f605c1c7f4347fc30cb581d6dac14f6145eb23509d3f561baa19b2b7c8a3d8841d2ad1135da91a31e3baac3b98ab4bac2a080528d7f310cf7b7aa517dc2e516d501418ee059e867112ff6489ee64230e5924f741fc2b2b250005042a9eed093ac1f91ea332a6a22baeaab1beb8e87250932d520f07b532c0531d56c78e211a7a3fe32a357057b24d00e6139ca828ab4cbcdf874a33c49fbe131651841d5a74a5dd8e1d442cc96d47b1bc1877b9bcc2379914f4b58850bf0e667587b39b037b6047cd174bb7c06b7489bcea504359a937dc8130da5e0865f7a40bf5a2559a5c560db05b1ad4063dec907feeaf20765ae6e8c19edf3651ab08b6b719e877b3279940164b44f35a60ecc500817386b9cf88b4ef61e692f622d1b0ff0168ed00ddae2cd1ebba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
