<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0bad530c27c3c70ce0297487970a4cf689179673dcb52edb35b7fbb73d814bd463456fc2571f9dd47ca2a0c2d1e9cfdf74b34a3b56d32603c1e2ea022a9fbea18dd25b6f3dbfccf4af91a8b870129b6799330f19cdd4ea0408d95fa04561ecef667db6e4992f5f475bcb85ce90e34cb2fe4ae1b986669267deb8ac5f38a29f8d4216908274c9415c363bcef96030ea735320feab9a4bc9a5d5ad0436d274009d09fa6204eddaec9eee6d086c479b70b39e175005c4d23fb2e9c32bb8808d71c46566db4602ed6b9147504517adc9fc9da7d1b75752d3280f89269f1e08deb620b08a9c33ff848f5b5b8894b78ac1b5756ac517098d424a57a425fdfd74663747f5ac62317ae62f4a4f2d221c8246de5597f130c82b49635160dd539ce79a910771747c40735002f4b9e49e7a58025229db4b421727d1c3f710447a7af2f753e22063bb4e446599ff68ee50db6b0ca9a80e3fbcf90221798ffd5c022f653e84f813a4e0e31d2ebaa316256e1620807469a58a972031985f3e6c3cda089e2f24c4923109f507e7e401bc5629415d150c276c99c8f6a45c8fc85046579d7ead148b8444b728457307699b9f08226975ec016fb96c05cad32e7fec9da624afc6aab9d71c41215f6e9f16da059f9a8879e84e2000f4eb1956e7ac6a6205447ade15b1d53262ee9c1bb3969c58d53c8a2c96bf55e4c2d228e065ffcea47e6b3475b69f6ca3abc5c1e209f6170615f1b21413bb7b7a09cd197b99ae8f50239fc9ad1eb4cedc699c6c4c285bd5f6f6341cf59db6d99008d35b1fb5f1c5c4b05eee095cd52556757b047bbe7a88be036f8eb660507d4175e08de3c7eac52beb5a2a115c30d085d7b7bf9a9424ac5dd015a26473e94562517713ce169b8aaeca69a6b4e2049522d36c61c117fa6194b84b767ec3eb74b70cd4420e1455e7dc609790d10a82ee21874f4c7fe5dbaca99ec9125c1b7bfd006761720f0f2be8ad3e3f0aeff76c3676593610541a75f2db341f679ae25673dd4e898643abbfdfc56aa0d1106d19304f772730a16375a627e3ca13bf105c7c85466a4ec730332d6567bf62d7334cf715842db334be34a13e482bc16fe6ebf6fd9ca69368bb56d52e3c012ed111e1609203a29568b9058f543ba5f2c45c3825aa4dcdf85eb15a0f6e31f7e68c61d62bdcc39d5934d7b4758473444ac5cfecbf6c5076e62246dd9b934b2b76f9e66b392edd935fab79d9b3538ad14e325d3580783971efb3dc60c065cfb2a6d5f6f49b95c1e1b86d51f1e527210811d8ce5a8e9cd80ce5dcfd4332c915cf61e3c79cdd91a18c3da40cfefcdec779e1a904f9f03fe4bebebd260bd77e4cefca7d9e890e553d6ddc571b709d4f5ae5891d0f7cda78f382c4d280492484b26d674d13288abcaf7e30d9c11e191705662ec5859ca7740f8077a6d1642c3d348779bc9e269057d25d9fdb5849c7cfd2a3de91af080a2238258aea8d76aaa88ce801cf8a515c8d399b35a2a1be43dc334af64ccbb8008e0854cfce269dcf7ac72949c423fde5dca2b77cc5b88a431dc4f4825396fa3d52c8418e8e3a44051da7aa9d0fd2cc62923c87ce429b7cbd73b865fb81b52880c499366f0eb1af4362de10746335a4cbb3f535faa1aa86278f13d0dc87122b53647e13145d0aaaa97258b99480bcb0898f671a2ed2badbdba183652f1c70fe2264d9e69a669b7f297e377638837eccf5cb6ebaa0cd66cc84cdcf1ae977e71737e8b749125dd68cae5db5b91c47efd6af57d285c8cb0f61b82c3a276cb92a93603d392d7387655892d01babe4bbf3725037e49da8741640857dc5c36f98f89cb5b43704ea28a142c8b021ae811a3574b75f5f4d15b1fc10112df00113c23a2475291f3f0d5e4bc97b71b97dbd2a591c79724cb57e3858faaf597c3504167dca8533edc3fa3d7799020f8854d03a9c1af97bfa394881f93ff11f1573e1c8739ab9c14ec56f2e64bf806c57c2ecefc8ad21b75ca522084ac1d4193c7155e2026018acc8b3bb46a4d085e82223f5be1749cc6ca0ad2a35dc0b18da841829ae022b0dcffa3606a6173a16b7ab46753aad965b571158afd1a8f0f9d59da20376970cd40d0496b96fe7ae02c455a55258a69c9efe9a25d820fb9b70748326909fee4345ee2af8800438832d4be56ddbed380efff93756e1bd682dd942f6c4ee9f3fac2040cce781889ebc67b4146592c9a0924055f07384022a31d22cb6ad6a9c9674ecde2980c74b07be8b33e5366217a3029d6c17600244ef33385afab3056e2fc6211feca424eaa90b0108dc3dffdead0ef29dfabba05aebd3bfd9015a46118b1b2238d18e6169cd1dfae5e5fadab088f9a8195774cbd4fb3d21491321859e22203fc6aba12705fe0c195cd4d23ac43d1a97c6152d5271a4c7a9b6ccd243d2690958cf23596c1195cdc1e7a366f6800aac023eca34be6a2f497b7431572334383820798ec03e25ef7dd4b658bc469eafa290b1ebebc1e3836df547d10dd7130057b436755d830f3329470bf2b0840310fe9eabf8c86c5caa35e948c702e52fed81996381f59a326af35d021bd899bc0e25e3e1aae90dac09ae7a7813b3af5758acd318ab321338e4c80bca0d1286552946b3eb2437fcf18ccb09920034c13404a728fa1671e1c2f0ca47f4bbffdf7d1b89bba0d937ab23eaab0bf2a6eef45d0de4320378681f5abc36236327b0f154fa6609cd61c34e6e81e5081fa6597339252d9758d37ae64d274388ac076e7f526d4ac8eb8988b56f86c2fa6ba9afd2ced331ffb1691ee48e3bebeefe05f58d5602afc8412ad6a0096ccb728e309b189908cf5132a18a655d2dfc89ff579ed21bf8d9bfc06251c4a855fdd8b1591d4348a2e8dd549b0f10db2ba955253693972e37981b8b25abeccd757b3ed499c813614ba8f871a59089eaabe41f44ff262cdae0036df73808492f228d52798a2bda7151fcf8403d042891df9e89efa1947b1205d42ca8369f66edb52471122106f148b92d21817fe2c3d988873b5bed0984075e88ca72f6908edd668f393ef83846743fde47f47e6ed9f12a1dee2938a6b9692c7248852a7a315c00185084b8b4612b36d4b31d69b301e1cdd76761ed8ce27f3b284d947ef6ec6180482edf74603157d61f1f2194d64fc3812781bdafa377f29d4eb26cc50dfb878ed9ffc43ac4bbe703768ee9633b69d813e150a0496aa2a743eed2282d430ac2e5f58a9b9f1463b3e945bc0db841ef8e5f6beca4c71c2b092c09ee895346711e474c1a719638694445745391607938259919c4e7db6fb3d3a81a8850701276d64981186df1ae772675024be891b0513a9c2c9663b8dfbf5084c6cce37558fabf50b30ff6e0c7460fd9b5dc33d501be0a3050f7d9f8d278bef5d677243b9390c01b756bc5993b56c8fed7069e711a06d3ed7495f2f81260d3c945b2770a871cfd1f1456742145d31ba45a7b22a6f0d024389007449c2765c46ee4cde38f4f0c985b1148f4b9ac37d63a064cac1f3394f88107c456128e64ba335537aef91fb63d4d5b7fbd20934c6fc9740412f083ae1faf63bbcba6462c83aa274a2087aaaee2248073de91e76773bb3f7a93162945ab97b6ab4bec0ace580670561e6b37a04f86fe9b31f6eb42439f08d939ac4b933cf0182a7982d78685d5c25f9e0972cfa014ca6c83db97492c7423ef96c10bb895430dd04f94b963ba22c9868e9ad0f7c5f1f12f254691273113584a1458875b5a8abf9ed3d9c82cce596a33bfb41550c1c31702aca1175174f00e2a374c3ab85f7e3f95b6d2e00dc56cba68d2104468ac423cd53be5acf29f2bf4a116c0947b528d7e33817bcf3bf707c4ef8351c80d8583da6481ef24166df903692bef1439bcfdfdff42f500254db97018684e988d6a9aa150479a010092fcca0cb6f59da6d78900be8826cf4c76a406f290d91e7df92479b32a234f1076e1872d871eda9f98fbcafb467b76d352b3ca6093b22f81c9fc24cfcd786dc655f5dc5031fec3a65ff9740434d70c127c91e0af785ac9f9191c25c80695fc9e2ce3d864286d87f2178b9ed3831eea9993139d8a3c6e1264aa9446e2b575df27e1317c31e278cb73faf5c1dd840de786d5d7e287a1087dbbd8418f17d07f8eb0480207b7374ca5600048479f7d31f80c2d2bed4f54ba2a2d896545347c7ae03e7b433220d50b7e58b4f5b24a481f65cb9402876649fc45a8c6e064b1cf65756b7d6e2b47ae53f6e18d5c6e919ea9f322bd8dcacca38c2e2af87141ee60d5d30adab71b12ead0515c601535411951bb875a1c41a57f014ba2cbe42b6d8d886d0aba7454bf5cd509061aa05283d584b71ee50b528c379a2e02f8838eeb00c9a7428a2e82241d4ca1d4307d53b873ae1799de44017699cdff68d0c0d8750ae15a8811ffca98d4ebf25e5b781d88a7a2cf5b47b7d8e4d4d0fd1aa375396cdc0a51a7da172d1da9d60ec1b84f39411ea421d524e12d642193addd1a25262dfffbe048596f89f211de39e2abe435ca8d1d2a290688634fe99760ebc491d55c7085446f2066608af566d6fc16f02d149edce6902204915c7de591e5f962e4d4c5da0ac5f8416c4210af9ccab5aa99b1c5f6f785272bdd68bd3599ca1346a1dc5e98d772c234f3e650a170022292b05676703d0d7e2d39d6b320fd630083e7001911426ae0a1003baa63afcbf02d077adfc90abdb43e9db9348c2c35c0d0f7ef77e612838be5f3f5e04c396aaf25f0709726cab1fd528a4b2c137567819f5a45567f0cceab31f028bf4fb726c4b640a6cb66d4e5e3a92ca113cb34658a00cc1eb53eaeb33c3a45ab977f7d346a4a9e6442bea17bf373e63a5923f0b01a44ca07a313f5ddce1ca823f52edbfe6fba20c6aa41cfb67b887c31f4de10e9da3512bbd991efc907042bf9e552be1466daf616a621816586209ab1c53b5d5d19f18511ad3467089605d0b9fa4b412198911b0f2fb330644400649dce958f816057b6296ab747137f513506e4026362a6cf149c638a5af7db438cc19b6c53b71bbf8889f972fd05e10bd38ab925315702e55ab56c5b07f8f81c02f5ce9b9a8d100a4698ea20b86280c0e242167c7fad7d6b683ff62b6b07675cc61210a178bedaed4ba9a97695114f5aee14fc28749f10e107fe88077468d8bf193e04ce189cbf689eae7bd0c50e96dcb1ad82b190d5bb12a1ff2ad3bc7ce33332edb764e3ceb7d2f4c1fa2c471a3f93360876271c1fb928650c1766c436a24235a94e05eebe69df3ceee670a4806a95d4ee62fd509e252d52ee3a362326d4b0a108e527847c31a6e014270d6b6b9b8c6a852a03b7b68223d54b385182700289050e147f6f5f9ba85ef27061b3627c17707e6be67a6b3e055f9d727aa7fa61ee329847a35b459b76a6e6855815abfa2eec1804f66edf00e2031768f0c5170a6a576b7262264d32ca0595e521614f8ae1176cce5342fcb007ff6efa3d5ae824a81844364953e6dbaff36e5f00ee271c5ca7af994422b738e4dc72af108f098c2db23dd42501c01358624be3268450a5c68ab2128fa63270b3ab121446511dfbf111d63bc00e28e68b72d300983c30b891739e4006647c38c1c87247ed76c14e1f764781018b339f09e225f636051e1d271db3ba79d1bc1ae64698dde5f75c0842932aec7119a5ac180b777d0d48b561ca32d703502a5898ea27344555847ed28775e21b86c5a9b3b47d6700d2ca2a9a0c509233438994be88cbab442b63ca7201015ed87ab85b242e99ddc8b877cd89bcb57032334369fc2ba3b9d4e87a7961d6cf0e243915d688a3e9c11a237b5dd205c433aabb387c67f488acc125429492327e945b99df1ddbde2a172e791d2c51114ac90297ffcf7263834549d7a7feda5838a763b326c0c0118b2a68d76776710fc725b954780e0e4847745d3d9af99e00259e53d5f68b54cd50eb38113caffb4f1756bd280e9bcdeda4c4d68a82d25e066b8200f4775afcefea7b365ee7d507dca40647b7de771e774b757c77de3628fb62adb020f26617eead3e554ee0bd1a2eedcba6dd7f0784e67e34d0d33293e2fbb0fe1bb2569c6bd1fa4ebdd04beb8120009cb3a7b5afb89ced63d907c9be967d956410dd22d3da929e578fb30c057b32557bd008d1119e2d540bc40b7497693b2ebb7604fa759334212bb574df0e6f0dbb918b471c3c42ef2afe4c53cc83a25ca79c27a3604eb566fb6235326e5c75fe33ce7ff3e19920385b34940b451d4dfa11fa61d9eddc6c3f2a25a0e2f3547a0c08703b19ec61fdb34adea4d3b2cd5df762def210f3aec044dca36b1bc8f498e0474f71333cf29df0f898a001106a01a9c7a49b7bf9030ab47649cf5a6a5956cabcc877937ed3c0a3edc2ddf9118a700244c681e97b111d0d9793f9b6eda0be1dd81a1735bfc90fecb059263aec8cea327372de7dd72d58e9b5726af24b28fd98aec150169ba6f35c101a28bd268258c4dbbd0802caef31c94459b9bfa2a68d83aa5bb673bfe440195ad48e50e334a02504c78e49c30687e8f201191141908a5db63f8a142d7c58ac43c86d83ed997ded0407df44722894900481383e64dbbd62c4b13020fe8e4d549be2e6282075f036ea85ab8b6cc695a789a899be88788d84164a252a3d4091f986604d34a4554be074a61a11ebca9be323bd9c021427066026d84a9e62fbe4d8df38d8defdd1d810c5713783477835b39fd98ad4252a902362278a1ccd8be24207cfb371d84e0ff1ccb98ab0c8ebdc7e42fe0e5101f33aa7411b135a7def6f3112dfec0262cdbb00733365a5b2e2b5fca8deededac10cd595a13d4d87ddc287182b27da122afce40c3b407bf5d0821e391a866ce60874a8b886a6dca08c2832c0b1973f64c81cdf539b8b9a99033a90346a9f6a8da0629f58c9614379b75d3af2efffc067a5dfed68a4d0e683c210091d6d6b91fa60243c1893f54b77588fb850a785a32a4aa3da080b222f82989539f4cbbfac7618cf1289ff1c53fe2c73d9669ea02e2a3559c826b316b40060fa4d2b93fa460fa4e8a55d1addb50331f6945aad614d7728b16610dd4b17d4541db60f8c25ece38a74525fcc0602acbb2525d09ea195bcb319b878e854fbc1cf54954f6c726b3fa4f4a6b439e6a4ce2a2dc306ade8997690e28587b073bcbc6533527898ebf6a410adc9beabfe04dcb8a84d5d3676341f9a776f9d68ab23b4af26a3ccd45ce416868f76c31d22aeb9928bb441a7673c7dfc5f0e84878b08e7bc59802226d223c9fa7f6d823d8dcc81776ce60134d4157febd880371a1ce8e8bf64c2c05107010b147752f8595e1a8692f689b9ca9d459833476fe342712e1f18f4dda6cbdbe1e0d19ac3d8191842dac71769453563e722122dbb3166dc49db44ee8e053462b1f6e92690f2532b91b463693511d296bed21a03b476e248ba5f2d9a20d12900f85cf84a27e8d513abf8ced0abb76992d3dbda0ccc1c8a4907db010d3ababb7378a5b6c54a2fdbc7e21d4f92b0d5d5741c1223875c813199e8161cc60ea1ac9266ce5f6b72d2cfc2647d7491e278b2962e021dcbd0892fdcdf6daba1747bd97d06f2e95703e7cacc584968cf6a8bd11dddc7f4507b7d450e683497fb0174f233e009e7ef99b6ff7239ed4e1beaf17f7fefde6661ac5cda145195e2ce4a947a1292b76f7933152b83e5504e99656305fce51c5024ea8456b8a4665696a08a63a5d0ae3318b8731f8480721113c32efee288c533244f12efd9f0b5cb566d1faa2aeee041f86cef217714220cb922f4d44e9f4a4176ea27fd2e1f9c3a89b569aa4157d2618c670f0651475e1e02f33c333684f52880b823c5fde5ba242c04113d2ad66835639d8f47e6e05134e53ac2596f2b12e44e1184019118457f26bf8131327867f38bdc959d63bd8b835ead16069cbce6f31c5472fd1f271c8d4b174b2721e44312bb70d57cd84d08430469f244015c2c637cefb74ed68ec6925dee002a49f0172aefe0cfeb7cb054f4cbbea14dce06c06a48578b98df291a4972a25ebc29c8c3f78fa4a69aa776bfee9f09f457c0a45b36f7dc1615f28b795164d7b2daa7a3bb31fff7cd0e5632efc018a0a6b5b5cdbdfddcec017ab37ded5ec794e1df00ba7d375caabd4c093b7431559f9ea76ed4047f0b34ed0d30c129fbdda41a4c6e3350c647f7a47a165c495cad5f34175ad14dfe5a9a342b0db7ad7d211f3dcf5901afc03641f54520f55314673c39d4c7ce5e4b17da83c1e7b09f30fcab65ea3ed422dd190f6655c160374ad411d5901f3d33261a0949d928f2bd6ff38bf367e46e41527447774c3d34a768b13af1fc0de30faa043f6602a7696f73e6bd7eb48ce5fa1ba5e9e683a5e1e32a9c6f47c72c1f889db532df048500bb4b94cd4a5ba0207899fa798232863e3be55c15389699a780fd55093228a1eadad8892be8e3d5649a0be3dae20b6ab1b30c0119b50beb423d089c6f5365a6930e24b14807da762727de8ca307267cb973fba98288748186ff38195a2d38b6459892fb52cba1c3ef45e0d585b665066037e5f404607780c21ae994ff49fbd1ee6b787e4bb5fe58afed2c9220c428e58cfe4d898997e7374e5d3ca756bd47f01d9d535e1a0652c280588ac82593dcb62670184394ad7642baa1e87454dbde34f9d360ec36217f50ca518d68f1d294413cd689147e4818518d323b15700ed972d14bdc38abaa6926106e990c814748ae28e8efe3dd75fb505cda072e7ecb3839a82ffcce2804d87acb9bce4c55046fdea316b2fcfc941882d38ca65f9d6bb9dd76ec5feaf999dc75a6efec79c89f679c2b7783b44e415a1e834ff05b70fe519f4705e2c397051b85df7032b73c9cad813d167cdd07500adfdc14e17a6125686e3fda49a41a4b7c8a2e06e645434d9fcf597a3406baeaf8e2fc9047bb10ceec8ab9dddb591dba39f4eda95fe623d004bf8dc3e55ba2728db589b06c5682358169dfa4ebb2cf48f524b99010159c77d82b15ad902a3ffb37c95d7ba660c997b18369e8e9297ed63f7302bc4333e457c8ebdaaeb76e9979f4abf020762f5e52fecf44cacf7ba45541988182313c63aafa47eb360376799e8a58b082926bf426fb1bc9c3a4c2fc9267075faa1bcf56565eb65dcfe7be0f0defa4d087be32e166b220fc9a129f4643cfc151b7928a401923f25e20270260c011b12abb0d4fab3ff8de7ccdcba354ad54b699666fd19e86ff056f4c3ddd3420103141bebdf26296766131bfed0070df822ec3c72720a6795c9d5606c68c1da935edb993586d6b72a45b8eae197290d3f748c77e73c1c27c5b4ea483e7c79b32177574534f9ca4585cb33c6f8da0e6443b1c41668ebf94e18e9a54826901342416efe5d181edc5ee3382552907db82342a53e2962d12632faa37b85037c310e53fd87fea710e95f4a86b30a477368381b2d6487514c5af082256859919dd834cc109fd4f116f0fb00644e0f50d80c2075f19159922a51ae3824090831713d259c1f9c9e852aabbcca1b750cd3c7736321ff108a02375529138b57ef4560a960dc760eb50cc8e22d55801601c2dd3783bcfb181434eea025e384686d2570f97352e097b6033d6421db9d04fa078617ff0accc4977f7b6d858ee304044baf437c7b4ff31572aa178fa1b8a73a37ae45573c38569185fc3a5a216b8bfb193c2dcc5434a825929940dbd63d4093f2b9206ff5e45e6e7e291091b3d0f1f73dce0f2a103b4d43e80bf346ca882c8e74f5713a4b6672f7455765fe26af7b1782d572a90ee2657e82d2f36c7d295d7fa95ac52da235cffbe0706e7a436de44674e1a2a55de9e7422b07c1355376a2d4d2ee29d16a46ed13a1f8288ad19f5024e39b2a36742811f6b22ec658e5fff5f61f788dfa7191271e73cb5e578b3a16282f6b0d54dcc2d43337003c40cc88fc45a1cf1677c7d24cdea9d3d5278d150197c0fc8c61630c730ff8ee1243d410e93cd5095e1e0e79e9c793e013afde8168582356229fa1e9142f615e348d3933942030a1efefd6c80e16de3ebc0cd45e80334d2aa1f6089604ba67d433183acab7aee73cc27337805afe92367dcf470a90a8c9650ae858863f4ac1b10fd2a0170387186d40986b7a75ca53028969733b32f532977eb28367148031c401a63ff2bd41efdf2a1f0c92ac22f813ed7ced8efa1e859d542014150c1c6fe66843ee51e785dee826a25467191622eeaece547fc2053a8d2861b32211ffdcc6544c3b554176f11855a5e5e43d8b02c4144b75cd4bb0d72536ecfa0747eb5369eff29e0e97443ebc060f7f2401706c0b632985bdc67ff8902dfafd025785ebc621d3f484459e26bbc9a2a7f5a1f5dee140d36e1483b8d8b97b59807484a795bbd486ba2a9ff5338523253e2e07f78ecd5879de927ae9ac83d852b30458d49cdeb4a4c4c295d35d359e5a1cceb932b72a9c64fe3ffee4cdb6a01150314836dedd1ca130956207cb79460e8f2a175ccdb38c7756f49135e10731f04d763f8bf8caef8923670efdb3c371aba3e1fecd1c8ecc1e67b4b68b1dbafccdfda2b1891f9e205694b5062d868f1d6084d93e68b9962dc16a03c4c378d983baab40383f6e0cd78b96d79d4d2d8f25e8ea3b7d5c9b709c3cbe1f6af6aa1f7e6af175f64d4adddaeaa62e8c083b15a8e5ad99a542ad51cf8cd3956b174ef37d800eda5b5f3dd3ecf0ef16de73c8ecb111c0957b1340239a01a92711e2e657861b427a92b368731abf2b67826139e5c417924f7ba6302cee590ef1bce469b8a871bbc12f3eaf75fff123b9bc7c839f6a1c663f6369c6da401ebc8d1f1b170f55c776672596110f34f65919629e67f1476c2aa93288a8ac2a2f1adb5b7aec6f4889c86506b5f662087345b23f19a62613511024d6da3d12dfb5fd4f1f8edd67092901e5915c69f5d8d6214df8dc60737c2a40a299b1c11265779350288daf808d30f6fbc525cbc8ab43ea4f181066c4bcfd38f1abdd6295ae22fba8024ea6ed4f9cfa5ccc315622c2c43272471b0fd2e32e7b2d828375f7ca880c0ec5f54ae70ea33e0a6ddf66e5a3dd0d4a13eda6a515a59eeb0f99ad48b81a293c0e42560891dccf80c46f0090219fd8f465e218dc3ffa81ec8d4550cd03f699dfcacc663d6d315d302d0865e83b4ce68a5c72d8d147450a0fb8e3fa702cd86fee77644dcc36c7f240d5b6a84eeed01b8420706df7b5b28209153e6ba0bddc3a9940c41f47957cd7e1678a9dc7a83c019b62f86c926e4fb59bdfc473c3f6d77dab8060d8e12626b3c295d759425121e10281292e7620b4630da48f63aef04e48d9768c5f06cf0a6f835a9ad61c8c11dd57b6700324104080d8d419af31ffe371f1fdc7916d4bd008250aa2882a35ae442cd6a0d976c4dc4e1cdb91a2ba406e4aa30232c38d413e96d11df9f7d5aea3f2bfe89f6e7c8d7fdf7f74613599236b24088175428ddfdc4ca60797e546ca2b7f042e3092128c344fceeac0c3e4e879013a7c433430d3e07574a3e1748c6e535ddf84a7b1b54b1b924668850942f0cd0021d21dc7bd3a961cc437a4b4a1f07f76fa78c94361a05432fe647dc8bdc07a579afb9379537af63eda1d5c9e020264dbd5c634276e10df68ed691a5dabbdfb50f92ccb9cd7231eadf343bf72fdfcee3829bce272218044f40b17b7ce94a3bb65b82cf2461cc5f7a873877e18049b4a0cd05d51526dbabb83a1ee46fd3d247be771b6fb3de67c14a1f6f97ca9ee30502990a8a7f3d82784b41fd121ab7b812f39045bc9d558c9fa016bce02cca2acc11b11847bf1830019b7c2b94d7ebe9bdba11c30a401926d095ab83d151ec3519f5fa857e7f96812ed510f4442b0c18731631bc51cb67138e93585983f080a2afb20183f2114a5c3e2e481abac3ff64fdffebd9778c3d36c87132af910de9ca64446fc7a1da5a822e4f3a721dada98ca65cf9da10671a03bf1531e282ff0623060930fcc1e64d2609ad9ca614d77ed783421d5fd7141be9546c67d51d48bbf718c0ecd14635555935908b007b29c9ae25b779128d9d19ff44abc4cf5a793f8a4307b6e8f0dcb4a561a2b4bebc18a2e23edd5cd828bdc765b3216f791637833652fa4a4daa0a058121fc8b75868641fa989ee253c91a19f6223a0d3f51d29a342b7a33a55640bf0d66baf338fdbb97f1156ec6240704d8f4635d8f4c651fe3383f67dcfeca86eb48438582d5163cef02a2b18978e1fd2944f48a5d06c8435260267c38a122c8d2aaede41e2b6241684529e762a0b9ece92b83ebd4bb94ee6135cb88592f7e9b1ec6ceb4e55a0d4e51e828735dcbab52a5de56044e7e613fa7311775ca5ac156f560845c08f9921429f6d33decf482a56c6c0f6c4f10ab5393d26b9777bdef3214b262a234d16ead50545486e5f9c1208b9aa9511d12cfaa31000e52f2c95653ebdd1563e8a378f541ca2a26c6b638775d053bba3e6c45c04a6979147c387688519effd10448ee68bf7aab0feaecfa801b345120de7bc11c077258b54b624778bde086214ba27243c2c1c12a80388c3041631492f57f24b413c224329db7527cc0e3121e348f51e167debf26cddf0b46d4a79956f947e435105b3c4d3a0c8f6a8cabe30be306dc53618fe7e9abd7fa943e5a8e32f7c0979a7fd71aad141cb2f2da39ce643c8603234668b07199471717b8e44cddeffb7539191266c656e4eae8200baa89a813d646e88757da80718c5b29779615968a658422e687fd8c8bed2bddbd4687dd97e9df731d90779329ad9bd75620acbc082351eafd7a34b83a26437fbc1d175e68a057df06c2ab9b59bfd19969c7b103162cec6dc2db7c2acc8dd640cf51a13d736069eee25ab95eac72b03d2a839056e1f023b8f0c4e2abd7b5a06cd6a5aee4cc2afff2eef5d4e58145e00eea1e078f9e09fc782f78b3c79851f0ddff691fd9db28ec61d6fd11c3cf39542c2e8afeb773bdb90bf08a4f5e2ccb9381ace3a79b2ad4d1db10f23f1b3fa8bef103bd2536cb73053c230365e873aea0bfc504a20e7316aabfae78805664aedf148fb720497718a6c9a2ca3c34554e86f6689388e9c9ca6121c663a8af93ec994c86c28b1f52326c4b6ee1741b4b9b1c1ebe2a7d8473ea5c4c506933e92f28ca1e4af82cfdce935603221b04141cebe3dd044e18277d65a52622581cfe4876f2447fe5dcd6172568d6f3a203adfe8bcd20e31b2f236c592a7a2a16ba23479f2e09fc067c1ca6d6931aa0394e01bf0214caad1e6007c94648c31f3cb3b574a4ab1ac5b090f0b9386e5812f4da939041da57c70247f95bdfb92b4ecf64835756c0bcac6ed36b9c0e5a9b87531d3347d5b54f7eec4cc24dce220ddc882bc52bb00100ef7c59f0b04587579834e962c3c720930827dc077f1601d48dc0b54015eab5f8d14744aff1efd916aad0b5c38a4fbf2b8f0686bd578dacb9074ed84c6a9653d14448f5603c0edc15820405b5758b0f9d551fcbeeb0c984169938dc17b13edbd689b4a2ef00534b6b52e70925aec4eb824a64e783a9f589a3de3619e3f749e52b98e6f7d0bec86ad8ce2e4ed6fc7f0ff7e68b9de61d95777dd9848fc915e3307c0d0c7079a62e68c2a02ced40235a6398be3b15a7d63ad39f74d2625742c91c08de505cfe5d9c921bf8f9cc44caa87c701cc7dece29efe0617dc9e4f781564dc343356454e0dc79273f43aad798915bd7f4bd9851caee1ac1453e13b08c0029468fee41ba2d739aab4083a41adfa70e2d8f62cd626867b129ae9f757e67a98888e8e05dc1b6375bf0e1f464a73797d21cc34ad5be6aaec2ee605453ba7f8f9150651ed2cf43ac516a8c9ed2be9db61ddcfd7d3abca7cf00aafc96ee05b99525f5ef2fbff5cb3369e65ba9b2b5d0a4964e6ea0dfa1dede44a5dfd1b7fbe29bd855d2f785331fe7c8f8f4e218768b5bc3271a4cd70c311cdc9d68fe0d8e823d28eeefa869a12afccbbd58ea514de8bd6ab3e1bc5564deed4da70a266ebfdf854604cd59677b00b6699d8fb0b0afd36d78358c719a2966c012b84fbbce9e74bb7ba58bccf982896ff8f3b11ef664b351af5f0feddcc3dc5343e2e7b28dbcbd374584ff71d1271d3130987d225c5f7dd732b5238b2f4592a7a6627c1f60a612985b025b2421d15377a9edef2b123cbd4998697d4914654edd5ab6b4d65c03d2b6c8f3f30d5dc2e0e895154c39e363d97f56c08f23529b04ef75dffa0f86aae4be3ac692e460ee3ed63a3b5351bc75c2433cd6a3ed6673cf1712647c914ece803d913206bdabb7c72b13e04c02dd60d08cf76973f058b4f740e86e121ffef7606a471c0ed6753868ebe3dbf50084a9c26adf4a4f6d88b951c67df45d61f8383e0fd27d940c87a3d44685e5e9b10355ccf3cdf0dfb680052c4c6e09d16399dd4bd4714ccf6d00452c935426a277c0bd3f05302fbebf893e5b540ea7578edda0030f776d3b99c873055b40c21231a8682c8f9292bb9442402190b2de75425f7d7858fadec329897cc9beb1489446f9608065a3cc33c05a2ec327dd2d5bdacc7c77b6cf71709a59854becc7c9750615bd14424a9310040c5988f37bc9bfe850b0552caca211c41f3058a91c50e6a56fce7186a6c6b59087e1da1af2673fb10113f29b91cf1e59eba08031f89b58ace0dadd84fe903d94fdc8011ff2769fe7c6bbb712a38ce97b9e93cf722430c7275be27858fcf7382a337377a8c01f4513e8a15637bf9a65c8b1b7652397f251b57ed5fa2f6932ce0bacbe1ee509cbf0f0ee10c738d40d8b05514c054ce9ee08abbc6d221e847f3953f67eca5a8be1a5550f7b162a119724da118a880a6fb5b30c976df9265d7d97565ec5d56bad8e6f1e95b2bc68c8452592c6ad71bc008238bc960f65e782419fde8333cf1f524b9f429c47dd0f88103666a24f72980adaa8a6d4166b8a7d446ce5017c19305dbc91dbd2c3cf60de350d9481373b2e8191a691bb5bab392b659d8a59755c0e6193c274bd3ac487afbb963d72ac486af5b12fe770e4cf7c653a5c4d61ab639b608132150a90a5de884c8205968fcebad03102283e0c7551608757024e7b7123fa4ea4b40c0c968c5f1ece61198793687ab94288267b590a681a5a3a8f52ae582b05abfd2acdcf748673c7f4c65e1fc071da2996aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
