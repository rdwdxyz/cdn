<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0da14d287951b22b9795f8ea4a3e628b0168eaa576dee482b5e6ca89b7f5d156606ad2193204b5e9d3e3d9e8b3865b6d9bcedb8557b4624c4cd34fb71037ba010fa53726d590d70601e21796c62cc877b1cebcc39c0abd0ee8646d3caacec9c86b590bea56ce55b035e8a2400253cae1dbe5571146a045640fe98355a09af8bf12d7d6fb43f2171fda3f62ad4df011ee185d312d3336aa6ab9c8001b509ccaccfc0ed8a7cb7a9697f541d46d6b06d785400d9f35c899eb29f437716fbc991d98a9a64425e769fdec44114914c9ae1c2c7904e03de5cc6508ed971e0ebfdf8a038360d76a29929eecba0a4830474b46cab1b0709921c2d8b66a3a3c35471fb0a71765be62a02cc782eaa962ece5721b99ba45d075a4f1997b8cdaa0f5fb1d1c99feac98e9860004be3b91e2f3cbb09e9c3259ac07b65a8fc95c73c1be0ab1e3c63e93671331659e451894ce96f72734a678b34fdca4491d2dec9a773e9edaf3948e83d55d25be9a53b1992414154b83b43298599c921de41a7add514301b22e587eac8fa1d3019cdec15ec95f391b6087c9b68a356f9c168e4ce3393713dce9655e6f6301286bc711310e0249dc42483e05f4c4aa86e2aadd0e3227c301460f4b78203c1ad58c1bbe1aba6a873d8de3e51a82cf64981b185596c540d19798026925590d1a4011dde67757df550dbbb89b8d7a44768e25c6ed8150fb97f5b55f7201bb1e1a828fa60524d446dcb9efd7f940421272d74283c9286e3cb552282e0a6b520ccb22908484f79ebce9d23386643943f6afa1ed07842c79aba4b245840e0f0387ed6b40070d7d05ab0dca996e14cca3bce069b55bbee1f2b01711393c8c8cc74bdcd4a9b212269a7ac6597981db9ed765ab7ea6365ce93c9f1e83de56d18b655a093ad83fb048d61fcbccd61573e4bfe1ef2490dea9533b499db5e0ec451821c15238ba3e35e1223a82f4476240f723187bf75cbe6ea7701f2b9eafe53fae2a4c1fcd569e3746de4c8a54b34a04cd6df2523887c8613e813885dfdc2da65d999963b7e97319e72eb18a9f5fcb191faf01db20dfda6a5f0a2cd0a911b4a7fed38027b834ef7a07471e546c36f9c906c33caa481fe2341d21d06c988f340581bb680b6b0bcdc054070565160057a1461e5033ea3d70cf6c87b8f0945a003eceaef5783e791bcba86aafcc71dc11ac560c08ddf603cbb261c00b346c52be3ac14d5cfa32253459fc3f7d97eeea342ffa9fe04eb28c8b0c2b23699d1a0034595afcaa8f41c1d1820f70cdf19f9500be3208509bdfc5ab04dd23537c9f3a9c3173c9d68e1ea6e08d61abdaf35663836550def5f8d0d041f5ccc5864ab815ab47cff2714a33d14713054e1566f626be9a2efa740756c2e79a7c98ae99e739c9a90f29c21b447e51a69b9b86034ec46231898391bcb8b866889d47a8131833cf0f66a1c90ee8b98e52ac84a842bea57f2aa1c3164f7b8675700b6cb80964c0e9df3ece00c233728f2913238c41613b219a0d9a62b9fac1934e5fdf8421045711d0b3e741cac03152b9f7544362c830215f966eeb496164477b12807c551b10043c21dfe90c76782d28f6a8e22a343651940d4d45bc56b9b040437f97944beb9b0f8de23a76499171d5d6a3e9b3364d1aa410794a76b864e9d256ff6e1b6155efdeedc1a1d1a24ea7e6abf782b936fc148a7cd83819d7c835106de832375e89d29044b53803503e95f84920354512222d8bf29f12ff931de4723ea01810938da0981e1ff77ddf722d6cc85be966aa1653546e8638adc7cfba48a33bb86239690a83510f42453f448e116c7ba134e9cadd954e6094b1f04b7b85866b44d70773f292328ba9ca722ff8c0150bdd6ebc3fcbab0d6e77567b07abc350cb350f57e5ad90481c62d43ef9667e5a7736dbb778bec8900514c1cc811410a64ba276c73bc567231fe7ad336e5cd2e539ab7adb835c8321c4126aac3c7fed2c1ecf0ef567f338047099f4cbd68c3761aba5be3999382ca7131119ec12a3b8a6bb8c08baf86943095d2f17963547c38f1bb5893b536934224c60a75ac315941b53c47830ebde6ba869400a3714371badf07f95d536f4d9bc4956c7cf76f46a169dd5e44832e7cd400ef9919158cb6f8db6a265284bb6c61703263bb40b5d8c66a0db9cc8eb4768b1a1280db659e7ac837e4096ea24500f312bba816d4d70611516a289b992ccc55c7fb206ecf9a9da482c3389114784d880d298f571501fa5e765bb3af91e294b1274dc1f84a670cb64456b24fbb0ade34f8a136ad2628bb59bb400cf5afe614fe43c2cf7339e3bad812ccfa4d3f41f3ebeb0f29722a16e0dfde29561dfa8285191439adc5a5fbc998b7499f08baec2b51809cd796049e16987b1685084a4e340999becf90e1f03b5e99e5f3a79eeb3df9165698d5204cd11cac17fcd8846d4da1effbfd1911603c58a3fe71dcb78dd8212ebadabfbf77f1a9295d1eae463dd87eac4f89ae7833de849645c30d0d1e2ec7fc78464d093760a03c325970ae67af36bd8bb1f63048af3313c647f17b6862489e98753e8e44df9b30d40c8c15c537919c75459e71f4f42076f212b381be78a46da85f53eabb0d131ae4b988dcc234c4a6a8b8388189a9cbc8418cc195ebfa7ff2c98ac1e6b261295f479a1b8ed0cdbbcd4ad827044ca95ed8fe3ceeaf41a4baf757ccee75cc1b4a10d05ebf1b2963db1c2d3fa9471e947591a77f990d54e978b501fddc0cdac6d18ea1837b0d9e1c597f8b8053313fdd6f7a8f4e3394b180b81379d603ec7d9a1466417c43d86f962457cf057ef89e3446ba45c55dfdcfbc345dce5e41a4f022e1613a3261ecbe211969e812d653fbaf2c5226a32a24cb567d6505885fa7de439a4bffeb18034b145aa672ce19927a30e1568acfc3382868473299570a6ba81f874db6f14931f8e9b5390a62a4e0dcf9881fed10ddb6c33c0157a00d8e473ff0da55afcf4d2aa177474606f3a1a8aa228eed0b50d5e83f7c92a46fa869d59c805e7ac77fef6084080d21c09e1e0085611bf027ae1581db3f9726723a3b6fc0be8735eca441caa40e4146389d1ab9e354581d44c03b61cc3673dd9d2c3cd3de552b64b59aa395cd32689689d495b24f0daa8cce8b6b0d041e16ba462998a89bbfb62eb8e118f670e0898924aebaa79e2697e4299d11ecf0332215fe020fda92ad4ee7e326623fd25085b8e8fba2c0e2d90b2f3ba3c658a49c257b24fd1ade24d8d8718f05a1fda07da0a2492493b3968fd3206942072127890f97a53e7c8d54937a854c1ebf6fd84f21bf5980b37e391a326e4f2bde3f9b15fc927c0cbe2de1d0cdc98194ee664c9a421580fc88f6b57cbb7b9a2683b15b65d651be0067236bd2a8821072e27560392a95370ea2af948acc72b0fa223866a9b311218fc63e9243bc70f20546d895941fa592f4462f64da31381f88e5033e145ef2d27e6809997bf1eb3fcf2baaa3eaa63b7c86fc25e37cbe7f1a9fde9f2c47bb18cd5bb178834abc9c3c551d1e69716680ddcf96a30c0a0e8230329e7aa479ce61510a3463720006e8e52b1f987b969d4b8bdb679a8f54b2dae20a4f1b13143c7f95108b6e0a8e79a81cb7e52cf5b3837061cdcc8901771ef3f6c0ba33539be94de816e0ebc3325242db576cb071010252ba0c6b6e12b888c09338fd433771cbd386834467190bda67e8682141a0d632e18d95dc48ab13987dfc93ad12a69d128f4f99d53cbb0b7592f4475856f6e787b50c95007d9a42d16832fc56f13224bfa3118fdbd5f4e73061dca812a1199c2e8d9af988218c222a5e29165ddc5c7f1cee476e36428dfeadb1effe82a79cd9761491e9416ad140bc27f91efa3c8c10ab85b904c8f0133fafab8292552cbe932e8153f7dd282b700735f2bd5a8cd167edfd102fa9554363f03b8b73110bb855c8dc28f78160c37a48f83e00fc44f9f778e3d5cb3745e55f71d6081c4a9f92d79b32f286d5df564738d2ad7c5f7abfffed4e93980122fa27fff17b28b90e6486c35867ec24ec7a2cf05ab7f73b02e7385f24c1c3cf923a3126290d662e9852515aada2d188ecc5219b09f9f50cd35a4be90724121f74b4c543b9e2cced3872bf48f7f0d1d3ea2db6a600bf6087219fc2ae5a3461030c70b87fc2b624601795c7a91bbc3d117d405cc5d40c0d7bd9803176f547780009adf69e62d787b55b55433106c0e316c406ed36abf82ff19106d1aa9d282bd9c7c252cc027813e1f22c410d24ace0bf1ef76a7d8c2d0bd1dfaa7da84615ea540ec4619f4cfd2daa0747a110d091ee6f31d4229c01d82326d2ae2885cd921762be6cfa88be240d028c79fac7b9a50f0e73ef499942802e033bf9a37f2c7676ca5155c55796394dd2fc9a210017d460e883575115d9055554c102ea1bc8038a09fb0648f92ba34527a03793aafcd8121bbe7d1304e8738d78b1071e58eb9b7da9aca0068d77580c5121aadd2d1aac8fdca9b30225b90c43c2f88f2365aa9739a9980f6dca76a4ca1c8445237a48962e25233254864f332b5f7abee0d4c91031b8dc881da5d6f078caa2ad93793ec6c9d42ad0db2f09f8da686c43adca77d419c12689cc64bf65ff72fd1db9817869904f4181996b883818b8bb928731d22f76b5774ebc802dc0de7c5498f099affca2b6c66dff8bdddcdd79d801fbc727673cca5312ed91e7f671ece6ab6c400e6cd50b7d8eaccc32fdae3e3518403c4bda3bb929407afb159721f1133554eab55230a86b1a58946386f898696ccf276ba920ab7ca44d4f90915d4cee2a5d83bedb0e3e764be0cb1c12b8af88272455864d90886fb3db9e384563da96738f14f087e76b96257890d04337c77aa29010e57e86bc4a83a41e8e17d50f643bef5f302f26eaa740c2023ca054c93fe866e49f76b5518624083764cf555cbbf10286e44819c8ef137827ad447f78fa3cb822f1ed9780ea7481aa62289a2a0f0c0d532f52bf537644e4ff9e36a14593871dc2dfb8575aef418eec7150ed4b3222c092316aafdfbccee61faac22590ec5214cc5fb201fbd2f78b53ea4ce1b908c14b13ffab87db8d9da92db9007712aa963afa421d5358ec29b216ba722ad9f2b9ccd6f2251bc62fe6a9f91ccf0dce739b8736f16f20ce7630c910eed3d5056a29213bb246dfec978febb1fa7f09f698656b8e6c143b9edb3c3072ce8dec13466002043089706168e3b40463ba43ef5879879228798764de32665e863528e0f5ed6e3bf5508702b7dc39083bc2916fd7b3f00c9792c36362396b00f456a08867680b8afc11494b4f8be8d64023062325188f61d3d3b3c80a71bb032da7bd90295f34c6e33166ad86cb0d56bf7c39a2d6b2582dc084826155a32fe96cdf0eb037ef5da95d96b2e69a5fca7702d71bf0d01bdbb35af3b77b9f080d7b8f288d89ccdd9f60470107e56a327661fc18f13a5b9afa387a937d2f29375b7c229dcc75a9bc33a8a450423596fa4dcd0b13075f13719a78e1cfac731fc4c2fce91f3da99e4600631fb033e8cfd4280b56502a9cef62c31d347c5eac9c8b7507988dd4316aa929fe872bee8a8fa0ea291039f093c4cfeb2f92dedcb515b43aa901d2aed8c7505a9aeb0b758d6cf9afb323f02ce923a3d54c9aa3219dccb3588cb322b986e4a04ab902663960a4cda90cf4c019eef56fd55409ad70b6eef4caa0620d67cf86639655da8a422f994a5ad9abe4f9ac1e416177cc8aed339c08f149b3376b04ec7007d91cb8499bd4c3c8c40e6f55dbe2139fbe5ba8e5ee64b49e95ba81414ebfae2f7bba865ed419e886f7c19e494224a4c4e1b7cf5e4865bba62806bf9663300cc589cda1b5976b8a2ebdca57af31e00aa78c91d6f92e0282dd2abe2dcd77107da7634c533c8dfaa644387f9842b6203ab89b6a94faf4eccc02eb951597a45da3bd87acd4ed8818b2060c467e952ce9e22c7b4ca55d86f9e78e159aec55ba546ae286360f27295e9687ae8052316cc249c718888b99c436a4812950571956b44ba7c6ceee1ca6aeb71a08f801f6a3236173301b396f23e2596d3ea3564bfa9a8712a40f4e1943654d719434c0aa929d07bd4b8e9e1aae13739e59a57f3c1ab431be6af75426e13c1a677ed3f0dfb038681aa9bed68c3eebf84862758e3590c1631256d864944e897da5ef9f2866f789bad95abb7fd6facbc7d3879d4f359e5f9b44cd41c69328a567081872a0465a635088778a91e7ea50b324a4801d7d3b6416fae739dbc9e9f9cac1432852c4888c4aee98ea31552589b4d5c9f4397109cb3c1144b18ec55c3e4feb149124f5ad4a264b7920256bb92552b63de0557b01382d137b1d22312e48b2d6f426683ecd59e15876d6dc6646ebdbea81181f0df659217197450a51d292cc25b16a9ca63eba8dbc706c77598c2e4e4336b60f7e527a128a8292d8c0fdac6dd50e26cbf53b600c51b8ded644f52bd0b723e261a5eb2efc4614a9fa987fc45d9b091206a6cd95bea9587ec687d53472fbb79ed708d53696549cc12c7118b19bde20b79a1fb8a1461b8a2eddea39e8d4953964147897f405c7d807b85bf2718f47d78532c22830d884728421af342212379a88e26132f34bda01d754ed58623ae0412252388ea47e406fb4e737af79ef7e372eaaa955ffefe2d027ad542ed0aeb4e5c6c926caa25e68e999bd8ae23240386f706b154acd9e3ad826c2421bc30c360c8990520d7e99a257d88727e7067493c4128fd67551ca6ee4ead92309569378e624a6053f8f51b21a7a442b5367122d7d8d3860ec1b4860c1c0c24d8f854dcf18d680a7f109fc04a50eac8d38569a24271d441b874e58a449c2dc76f7fb92302b5cbc16d62db44ba85a93eca010f4d5524b67f469be998803a61b0e3870f27ed7ae540c3c557bb95308b1e1a79d2c20463aae23362c700b34421bf5dda37da5b2e620dadc440d61f11dce4a63d9492344791666cb46618b42736f3928d5230f77ea2dccf826738ca33a0e6ecbec02ec2fdac8b36f19dd39700aa297ad9fa85b75b5e27015e40cef8900c09ef78569619a98591a6f838c6c3c6a12de4463bc618509bd8547bd54ffd6f033053698085986bb42e571dc4eeb5a08ce6489759f7d5174b06f4d5736aa5b736945ea4209eed45fd8837e5961ab817ba1da435cb7cbd6aceae224b3b98ae02e9813d2308b65dec8394b76acfa2add04687c1d2f2fe72d4276b6e10cdd375d1cea31dd849089ab6bc7c014ae22a01d8b3019dc2034cf9ccba00f8145758e8987da2d87a527bd7378bfe16dfdc5020ae6d6213c9ed0a53674785a19a17b156f2cab466c15cfd49c060a737d6a38e6d9f27762a663dfc771a928e21762f51fd169074aa90f87ee3a7aacf49a8aba2405ac0452871990db294e5eb377909feffa39ddf68dcdaa95326799bf8076b001501b8bf108d65555276eec3e9f76ada1887e8ddcace1c7fa0c422909900e149f1682cf507fca6470de858948e03a8d8b473b725d6effbfada90a09cf2649a0ad409eda6b35d4f08bac45c745f7389af1f2c21f5e8a567b86a122b1a614f9854048a44f8a09dd47270f11097d42c945a03c1be28e31edb224dbc5394ab3a562821ba44a5603ebea245a0760c390fc3f4b1ce64feaa6f403e31766d3e9a9a132162e6337e54de28d309e9de8a15a9a37d69e0bcecb940101ce91d18ccad557d19cde911d944d389eadd1aef605974f5606f9d7dd660509a2f90b88e7937d20c8ea5705fa989dd85888a5a85ede1d8445c882e9c1e66007ccacb12db8b9258eb966bb983a2d7e79d3a755435f4522ffadd44eec170b42d13629d9d68f776b0825b7a28ef5382d3f31019006b7047f4ddc9a83aca0ff8d88027c0e6c0f40793429a20dc5e49d7f73306a4e35d07b9b06d7667cd978d653f65a66e041181e6a2aa6befdea5477bbd895c19389dfa8839ff72ae35e5cef9a42f13ef56552fee7c5ae8422a73fe2b5a075ef8ed48c0834b72a0ff028ce7bb00f42939a31232ae0b576edb0f4d5b9b03c4c33b17a2b69972003b4ae23cfc641eba677526e29d2f454f84ddad04c5f8c4ffec7a114f9df0c469a060508e63aa2baf1a5cca63b277067cd131c100bc4d0b3807077d73a996809958c21b37f999630c245e34b080fc9ce7ede755cdf1cf6a1ad13c53c9c5b65235cc581d3e5ec85c837bedd3ee2fad8a5b6504cb342b8a9748608fdf1282944b99509ca7b47885fea52ce89bf5673c596372d6eb68b510685654fa43bea6eea2f37def18460ed77d358bb5b6e86e0c4cf5878e003a65205fd808c5e41d2b84fa010f740a8224852385ea31f7040213906628c2a57e4b10770a0bf9135d2caa1b2aeb488022c99f39f385669de28427e475ac4afedd9a8129c6520a17b5bcfec34b9c1f923bec5cd5dea42adca7e6d51bf55965abec6413ac1945b0828165f14e1b3a74209724f94c7d9460fe4b18a75e8557d1e47538dcdb5019c1ac782d9ad87b0c97e664ce8fda59fbf84ad99fb46015c2e8e4463ff480994119594d886b80617a190d3466a0a4e820ddc187cb7f67abc09708f47128c2dfb355de469a53cf15b3ce8c7eca98959842aedfe24093747c9c8ffe8bf49bc8012cb2c50348acd6e22ee57a2c8ed356434182af5bf7d3314640c8d8da6bbe563dd2326ba2806d37bdc3af8faadbd19e6e7cf284b393943033327c53d1548daf7d3a87501e6eff65cc82855788f8c12c34b661486a38d1e70a081b81fe3ae48b54ac6d301f6acd3a659f42495b02c3e08fa6a79f4a839bf276f6ef6fdc8aaff00c6325eca498edaf31dfba3f820fa338aa017279e4af1a33fe54f23579695ab6510e90113aca3273d6e5ef86d9fa7cff88368278b48afdf3a1d60e0f4a0b576b315499139751e72020db6fc67e42ebb95e650326db7864d420becc4c5f344a3d9989a8d7c8b506823f4589ce940a6483bb073fcce70061313cdaa898720245677a2b326d8b14c96a91798df24e3759390021a78c54f01df65eb40254af0fa3e37745afa65fa0e3599b7ab02bddc276bbdfc24c8d9ac8318ee4c37a9fb4a609474e43b0a39de796e0a95d18682e1ae8a15a8100c50d91945db068a14fb178013438a2d49f768722cc8d7c359605c66d358d733dd16e0a15beb803843a05a5f96b53b6d5a813234828a41ea9b1ce7504eae3458a0605581134c393e54a869719d3009ba99867d765c69142a97de66bdeb382437db06c1cd50f42e7b4cde750e8e4064e0e678c2dcf44433bfd44605f7a86b6e68e35dd358bd61ddfd3c839c08d96b22ff0709be7e3bde1637892883dda2571453fa181acb35bd03e1aea971843d33c6f6ae1c0e4a54dbd12db225b17bf63474487604957f2345e1c421f0c2cbe1f57c8b4df39635b3c89bda343fffc3a343fc0bd3afbe477e1a85b0a63425a839e45518c1b8d53bbd4165f91ab900f1c1de464532ebfd35e968d18b16966e71f69e0842c1d6fba62e2703bf31cda7f5198c8ae5b98104b6c15779355667abe1373a6162581a9b834a62a5dbc0c1c070f58cc9e6d5284322a7ddaa898c868e1a8546d09fa5784c91ba1ea88e3afe240e56462d138e0cceb6f7ac0291d2213b66c9348342fff643f539cc00c975a99015744f3fe78e332385809561e91c51ae096536be9a83b9e7cca8a141cd964c0dca4b5dc7b9857b8836af2db32fd06a82e37c05761607d089792697bb182f5fc75c2913abf490416e6482324b56385be741628a59ffd4ba8688058459a7c84c7c3a04c23330b601b3ebca168caa8d5251cc5a5631ffb70741c14793ab3582749c747d53f2dcdb42fad6ac1434d96dbfabf0d2cd0d94a788d1285e09f8a0e2be2ed7191ef41f6409b6b30932270854cdd188a713fd41599b7963cbc2a5883729a37c1df5a2223bc50fe6c82d90ab656a774494cb63f6e1d697343d24db1c29f430822903abd75c2e307960aca0250884e6336011c711b8a966acd49fddd17e87b1ac13bc25b5815b5006acf9a8a7df65e9017e06eca9a80f9a95bc34a84b6561ca4ed09e08a479c56c8ef3929f2b77164e461e343a461efcbe1b7863b88bbae8eaf362db9cbce42579ab58d08c97be93d8d64b26628f22dcef0dcc72a92782f1d6ca45242b0e962901d2e355f87bcfc4777e2882ad87dc51b22f48abaec84fd4381000a46edc6cddcf989ffc3a803743b1d734e0e38da0c86489448dabee8e91e35bf4661a8e4af8a33b9899201361cbb09d670b0187ce52822c8cea3fa9a5dcdd7abac61d1cd93b50ecad4448d65bc20290cc9980b3564bbb2e795135bf720e2c2ba8fae5f5a1028f528acfee768b2f982983ded04290a00d6b6930c8c523e77e791e18483f63810478ee9321ad7057f646297b88d71e0d0e18bbcb5976aee8c9a2d7d0a2c827be3cba8d120a7ce436ec0ee6e48aad685309e99d5ae39d3c41b9098b9965d3b58f6a2623868e7c7f788c4ffdafe26ded37fcb1f7cbcdbc6a77747c3be090fc25fd7481cfe059c309e1cb43eb02f688fcaae06b08793fc788d762245d576350c9cebde946253e22c41409da4a4aa2452d0c305f915b93fe36fd890dc6c29418861392de24951c00b6cd378cd999ad0b36dccd148a24752d81f6963bc258bff3306e49207dedb4e7d2b0541d01355cdc9eb36ade591f55a5ad9bd0254e19a456a7cfac0db1e7e239a6ded8fb38f9aad1db457972a502cefbb5ae8f11059c467c621c1daecc5f9364a3dcc5f06514ce5f3dff13984e1b450f704ded365953bf31afde8044a73b1e12746dbfb187511d3964cf0bcad2daca403ffd81fdf37f983586732a0a0f1ae0239bc9d3d5f62baae40d14b1ff472cb9c8e464c75d6162ad8fb306b09af390046361faac381e732dd41bb52a94c0916edbe5a71622dd592bd55f811f86007178a1ef0730f2d9fd046b98e263164e00e380cc738e2b30a121d988b76726b6a8a0853d3f749325cbee9acc2bbe31cd8e32d9c5791f6635f3cb604d990011f9063e69aa7dad314b8d886618a35ee726ed418e7f95f75abe448bf38a795d1685604b6293f17ac0e16545f61df7486b803c1361c63b5e992ccffd42eee2194bff5b9b9223e99449131af244c8533464f9622e3888c425d674095c4a68812f1b29ad552a9d0627d2ae972ab5a895553d0313f9bd4b5c578b375f270328978cb91d60831a5034cd2f605939522e00b801df604c43e3ef84dc391e96a3defd804085bdc59ecdbdd812e933cd119954cfe47f15c8463ec33c7367921f96b8f6beaac6b274176e22e392381a62c09598fc86979ddf817a59b4bbb7b179a15aa9dc92df768eb69933d983bab95712648d991d3e026f8d46bfad0d7fd2328412cfc85ebd0597e74280d37e4bbd7597b9d6c790a83c56e3a780d5b0baf850cc3c87e007666d078861b26f6a5142e45251a1387a8b454fbe95be72ac8247de516e45d03507442989a7b48a5b58711cb9c8b1edaff0ceec946d2d08916e81b2f01be828d145411e24cbb455b09730118cac3023e64ebd7e41842528c436acf33219edfa6e356ad82a10654bd7ea145c1979f0dda67c5be48de775e7256aea5ae1ea6c4b5fe85bb984d9daf1556a56b8217a5554d5ff605a0c48ac7a856fa6473a01fad30e8aba1257874a292248406a5419320649ea898dbab363d19ddc92928f701c932b1ed7e58be0777a018ecfb5ff67f670aa14d30f05a53c0da5488174d3721427b5e246eb237aae1528805d63e265c9ee51918ec62d4181b9dfddefdf414d505ae9cbafa1986b8656747e1c501ae8038eff9b585f7adff2ebea5839139c528235485d27bb30a11bf81b9e4054c35262179d2af0efb09ec7a364ea5f4047b87e19a1c28a3233ca0b3f0fc2d2c9b1b11f6f1339718bdb6da1580538792f65001ecfa9cf4e1f7b4eb899082ae4e0a5bb635b5c2b35864331fad91fdb62e5fe119f8063d0e9725de186ac83c2cf9fa134133254fa93c65f1d8a6970282500154b3fb309e1e6d44774348fdfd70149368b082b4b02f4da0835c54d4127aed87cb0bef5ac9dc17247732b9b88b1d092dca320f542486e9812943942c92b0a588ccb49f1b38ff7e832e841b76fb73d2f49a7d3cf0613f4e288b4fe0e6b5e5e20ec121fef6a785e0e3b04b63eab73c8995ae23924b997477e35ef6b7e06b56744d5eea7ecc8890827b4619ebe32e631a58894a96f45f16c9f9fa9f839bacae478b96f73ee153fcbf00cd25a59db63ed808b648ffb745fbb8f1df6a18fee9dd94da3cc00a9f7f0ccc39fb8be238af8ee8707c631973050709e7a3b0412690c6dbfae489dfd5dd6d5978cbbb747d041a678f4f97434ea494a78d322d06d4db8d7b3f7a6ecad49d509a0b1860f1aec89e900851b056be6b25ed01b8f36d929f744770beaffb099429e912d3869b28e5986becdb81c7c8949583591005a6278254cbb46d7d1286dc6ccbb4fdc01ae8abf1b9e79561dcac377294a232c1255e170e5607425e35569da3d531e6223c3b6b5e0fc7187f0c2384ee345326251a9b8b3070b0c8f84179244ad7babbcf81c86ea898f74ddbf1d44fb3ea11bb1a4295e7f194cf474d9bc79349d8228aeec1147c0fb4de001e6bcb51729f1808a86efb46eee71b3d8347386f7004b848ff50badc13df1e9fef82008e21adea1984c7202e8b266bc980b51db01ff44d4e8dab104d5ff3527a02a3a4226accdc75ed25dac808357ea4804f5648b5dd862f36c539f3cecc12c3eddcd56308d6df65755411eea3a59788d46cddbfc2ddc244f3bf23879350b13ea5ced1fdc06f93aa011f696a41d78c891d3cbfef0bef14786ba842c99f74341851a1759f964c4c62cc112fc1020e00f90f3ad3c8709196e1bf646212d0eab7052882ece8e52e430f342dde9daa0c0bfaa3d3730a8543c4de514ad0dec8b8ea5d81b94eb301dc69be4d2ba6eeacf1fb0631cc8696924fb725a98566b8444d7f410ffd87706d7a386ff1fc8bd0df3e7d9a767457ec633108d3cc5897f87b26614238ae9df442c5bed78d68b68d6dfd6c69d0719b9a36dea000fb56c640bca2c356a7d87897aee3ed0d9cb3e33ab6f5b96851871d19dcc3f242ce3094b579d23fb73a315530e778b282ec57b904e691a8568a48ba1f72a1f232bd92e9fc3242cb26999aa1399b18d9eeb41124e7c8b6f05956a44131c4a9069316b351735434887a7df9d58d7dec4b9039fb148ae50b8a5175ef26e960246822f5dffecb1369bcc71f18b3d3de7f157f561fbda47a32d14d1ec8c8d943f449e806bfb8fba25c4dae5a745e0f44b990f144892d4200a436a222c84971d093cad74db4b25a3a6a3145b02b1506dbeae053b55369a866b65c0ef117adbb45ff508d3d74bb0683499e79ccfa503aa72736d05f8c1314cb5958efcc5889660ecf22578dbb308f6ce85f50d6bbf5610a25eaff0a541ca1f17901559770c6a92e0201c74f005c18a5f40f0466a870607daed56e6a543944e26faf3d530906936f36377bb2c668591955626887af447ab13b0d42a025f08f83b7eb9a86282d91bb2d3b3adc51972e3c7395d690ad9ccea806b44bf6de602a10455b5a3a07e79072445db4012b5e150d2acb8e2445c172960450c7f1bffc2754523e363a26b78ad936034c0bdd8f2f85fd2db61b881a60710b4975e5108d01bc029b36cbb751280f15a05caf7c369e91babe4b41da92b23e996efb382c4fc5a0ea2dd33a3bd71b470bcacb4c6bf94838772dd6703105ab4d6c5e1f4d56ecf730c413c6affcea419e37db708afb9cbdb5f5538ae54d2b3a9c6aa850e097cce04eafb04752212268fb839583b03ca7edd4057e3c6b9afdebf6b403e3de000458e89a69584cf5951f8a8f677952ff65298a8e453e800d1ceff1ba7326f5b7968d90d44b5d116d4f89ac67bd28afdbf9ded7898473d79114716dfa572c1e1824bc0dbfc2814c7552b11a680b7339ebe4dc1660f2010ffe4df86d6cf3bb560145adcb6a8ae9de30c943c855835c3a74f7dfc561d918fe85efaf51984b258f09ced96bec3631bb132c447aab00d2c388ae449e43ac1503613a83dd2f16d8ed9ced64a44692acb5e4804ff1a2d5d4b07bb0ff1abc483283cd0e08902228ff9963391a74c60fa205af35d319154c841b6a0e616bd9b98d0425a10b5aece857e3a333806409eb35cd5d8296b5d2a0a36d894f696227ecabb10a7202bd4d5114695126c483e8dd1fec115728d136bb23b53296cdbac9ab076e289a719977cf378ad911ea586ba7e35557869388bcd9a73620966ee7d1cb559d9efed03288ab7337f60dd127d1b2899f9dafbce2c59b3b4839fcde371ac2ef73da62e3a47d10a3d2f6331e2ac676faa77dd99c66a84206b8c9b3c7272168c38fc739f341e932193023c0b18be2ba885b675d41f745e03a285b6b0503d661e54979257a11a6276bd6ef50fb59ff91f4b0f22d937af7d1f56873953582066407b485fb6e62bb094bae4df5ac2437fd82a761e06d09c1daf5fe176d95ea40261fbb05da1e93e1d7bc8e847cbcd92989af9482a47eacdf719e343e34c4f89b91a4b541e5837a92a41e7be4c8320f57a84153de46602e99c1b638388fd4f26e25e04cb071ffa60d0fb7bf448bdadcaeaff84077b4e71d20158efb949c840824773a142fb170a35918e7a990a6db26eaaa2f9bc3c7672f52ea2280eb0b6c48aec903892c85413b3fbef9a73a37a2bfcd555f8bd747659b35679e4bf0858886bb88e2199362f63b844e4a9ddba4ac3393fcb10aebb95fdd53f77fa830620ab9561b88e7b85d0c7632de1d80208f990196f338cb5d277ac533801482624c7356db176ff11f8a7e82c81be0e3c88a5370c582ca2d56a364f1ccd131607cded1cdef528b41f01ed7616f3960a82ac4c21b837c37a928973e88dcbc503554c9c624e96d88beec03136c11f2c678662b18cdceddebcb322a799ee76e098d1900841b18ddf03a8ff30fd900a8e407c17550b86ff68f53c522b9c1e2f8b8ef85855d2963033f556c1912244076ba0868cd5fe706eb5d364e0cd7801556f5600eb6de7337829f0f45d2ac5f6eb75bda1ae9dde3aadb723dadb089bb6617eb406248503b37f54846a9ac0d32d0394fe133dadd6a503e1657ff03068b2d3e3c413eca4d1afbf778a38096ede16a54fb054ef62fd63ad9e98a606fc8f65d040aba7d70ce973bbab625cd2c3370262119fd2b98e4adf358b1c8c4451a03fe91bbcff8da12f6b491db4ba133b71ac6941a681633768e3f0237cdc3818ed3fab38653981bef03ff4c663aa0b61619b9c1967ce9f72e51cceef357c656c4946226bbeb71a448b96740b499e7992d1d53a2733d3c8d685f492981d4545c3a22536ed19a62bbc7e9b0f84c89b4644a3b9d711a6727fd202d8604e0fd4cb850566b5c5f23616ac1987c4aed1291a8a4e7d8f67b8f06159ee0c41077c25b4fe6201f1f559ea983b511dc0f1c06fa273c8a191f0e4fbf0d292eae4737ce9623ce39b096472ce472eb981968d82f1885ff75d2338a036ef5419a435384efd0b11e8e19933c09e7ec7abc357cce6ef58219b930207e23514ecc0665d52c08a7cd95c800bad5137f9a22b3172936bc21050394f402f458f9ccbe985c8122c5c670a1e19324055c695704c96442d59275d2c7efaf7f130fcd5f471376e5330c9cf9d83a6003396890ec88e3112ee54160e61662067e34a4263c6ed11393e12aac3c8e1868ce388e35f0af47558d2157f1895821edc88f20b5cc18f0a29bca4051d6aeb1bdf8452f1f970315eccf5ed19c827b372faef37f2d7ecd98ec5bf1b2b0c94ab31deb0ba84840a01b0c94acbdd393128b605dd206d1ef1be1b694001b0cc40b4feeecc1a4cd22bab9d09cacb8ca244cd39141d2c0c2bc2ce0e1de463d2f9e029f7604bd933fbcaf06cd36f76994ed772659c4189dd49f82fad6e6f968fb2c165f5fe8a39675249fe860a7bafb03f45d7a6e6a5233b0ea1d9325c9e24afc0e566415c5bf98826a933c16bc27d5d4f85f4623025ab1571f7d0d61f5051ce65a37c158e9c3b85be0537dcb1f3ef69602fa2f7d114260063cc7b759abd868daafe42d78791a2ca01801816195083e91c694de36175990edb8acc6403505e0224b360d0dc9ef22cab16a3381a040722f56db7bac565f41e25187e007fb37662bc5193872f4887f277b9905469e5932af1d58e488e12aa8245157c8416111f8b65bf9449adce1b7efca37960d14cf201f6e2809f157da8d2314c80a35af1e269d99702f39762600580765671547bc28871d60e04ddaf9e02bb3bf2efad23964523edc664a3612b8bf48d0fa36a0f4696d7301ef1fdfd8a76ec062e0f4c49d8f142b8153cfc30a547df608a1e816af003e9d46356b35fe701a89f53f97718fc2e291b15207843f18e123c7dd5a549a1b0c89eb9a970f3cac177928a66c9a22e6a2822f08d16a0aa3171a5c8d9f6ecec9d4a37e804b89fb1a4c728509d3e1988fefcb886e4c47108343c6512cfcc88b3a4fa1072dafb989f8062405e07cfee7e75c5c26edd8b4d0a40a19431d8b360c7a6a8658c64a586712afa8a621053572c2d5beed1e11da5fe43eff72911801a328519328fbfeef5d76f2205ae3bed6aefcc565fc0f433b7ea078dd5f78d3a30a0d58ac191193fbc1ae5c3c41269cea3eef5a49c5e6ae361e929773bc3fa94cda4d28e9e8922bdf4121cfdb813f19a3a4facf684418ba5188e283ce8a5205afdfcab320e1f407eef88036426cb9db49cf95ccf5415bdee1e749651a2a777c3cbd7667e77da850d616329339ae61c9bfac4e70a34f1278970cb28dd6c8d816e66d2c5e6a26dd5dceeebb5b739e2fc573e25a5eed97e3b951660879801d126549142898855298737c80264b90ce04382c5ea3e019b5f42030201d5a64fc539e2d4c47d87578371199df8ec1b8028233b9e7b05c3fa6ddbc50420852ec4e7179b4a02cdad4dfca4defa6f17275872450a7252cbbb318f5a9562162c4199b42c1516a10ef6bf0eb65be8461594fa6e63cfe3873ce85a95e7d83745adbcd2a74b1fb0c690ab5d1e9fdd89e907e69ba186b87c5803b1fef2bfc109cadbb2e361b7545ee1fc664eda8a8295fa70077240bc1e54ab5f75396517a725e40a34a005775b4b46320ef326e680521dbd416c05c1932bf932398c1db51c1522ab92314760cabd5fe197a8df4ec636f7dcb5bc9840e58c85eda51cc3051909f1ed1801c987f6f381caff55d02a7e1b71360106e43f50ab9050b15982bda4b507f5bc525d3ab1d9e3ce4255ef2d62ee387a17010b36e7b63b2dc9bbbeff4e6092b8bcd88afe047d841de0b6d9a144e4b4b924d5da06fe13ee3b9b53fd9effc331b7efffd932dcba5c5b8bb04402acafe03a2ee991a829458d813be71f1285e85198977737ffc71159c7d31d74210aaef5c2bf5af5274de9335784734ce4af2778afca7ce54dd1af84688eedd4993257dbc0aaf5643be66c097b38b933044a0e73a5930c1b59a4fe865337abb651aeb5404eae8f743404f170141327d2bd2474cd6bdb6b389fc3896fc75a8d4112b86c8fcfd2f701fd4d32c945e84118b5892015e7941adcbcdac0921380a553ac7a674ad01461a305403299adeaf6388ae6540f926e5ec90b19ff35abe58fcab99b2a7fc4bd4cbab0e6271fa678ba48b5e20750df8d9b9e1bb872dd5e20202d1c0be125938c04f2261df00ff1d8c0dee1a87913f0674ca6e5a6e8731adfe48665c2ada668aed559f1897928f7bb804b7c0b4b7ee6020685589d8c9dd89d6198045b0fe12d68de11329c247e05c83e8eaac376d9cc9c2f800fe53fb1287c9e90d52404dd55af65460c1331d65737bc4d05ebcfeb01a692831d2a52debd492ccb7c121d8d2c03ba3aeaed244f1b9052b64730a9de5e51f788f69ffc7d7e016033ce869a82683b6d494d5154bfe5cbda1f846366ccb4014254ab6b4686eb36806b7212558e4eaa6fc0d431b9cbd8f46ce6c68b272efa2434a19c33be88e28402283d42efed29ddfc6a0076730b95a050c973c7aa9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
