<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72e87ad242d126e06340f5e749b7f438540af1eb741bc983e48d8aab843dad084aa3de1d39d50e8a5e14394c3e77c5c78221b2106d56fd5790725c6ba6864751e08a3df08c130688eca5f887073c761892a98d36763f98dc94e643eb139edca1a959aa231f52b1f330dbef18e45c0f5d3348e4607ac85aa36826549c01c1982c76de0a11404a03eb5d90da6467b81a687395be210dd948ba86d50c14ca93efa64ce116c187776ffe2093d39d62a2b8d1f098d6f7edb6c64cf8056520f432d4ad54bdf9e2042f105a53633ed27de2ea5cfe0d0d8d4063cd38c992b7b6a9652100e6da5f57fdb274619005285105a7a56a640e5ed7c9b142af7422e86411d2acf691319a7f4b870ac633b7baa5898a5e6ab2395c4a5ede5a43b290c1024dbe4a399f3c34b3b993e7a36db1cdc8a9ecdc85eda42be4662eb1cc41560721bc60664b5563b3abf7f75ccedd47dad180b08fa0ccce38bada089741001df35b381996cb2049976599d24d53856e9d36832f15151ade584622e6c41e4dced53b1ec24b8075739bcbf706625085b2f8eec9ec3f42e63af1503d8594cf8dce85c4ed90b60930dee73a2690f8778ce990c45643e95fc56636b9ab05bcd5060bdd6eb88d75433fbdc331c048699018e5e0c28298df7b72820838a1182e6fbfe9a396c014a2d94044499d41f7d661b4256a0b08e9d1f495aa8872146dda7b1b8ed0e78375a9b43ad1b994556ecf8c5abc1160d46c1ee166a2d7aa7b6dec14f72ddfcb5e3e3c4382d5843b4805ab67bdf08bd0f1d5f2f6652b362c1db38670143518aed3f240b1ba99663149a79701f4805dc1c41a98c52d6831648b824efc37ddb86a48a9fc1b3e8e66726b56e96b686cc484d1ceacf56d51178a19cf96174f2366faad32daccbad28ca95cf7b3f762afd57ae768500c395b8212bce3c5393ef73dc854862f59e0c9c093a3dcb770b73aca8f6706469be8d55a70f9630cf2e99bab3235806abacf930ba195dc1e57ae55201d6b51934b44a5395a5e7a5097ec4d30ac0a00755a35bef32c5cca56b3f4444267560c532c8b957f01fc7c031651004c9b45679e4f1b216d274dd1daa2626ac0dac22a4e83bb096c1a0aecbd024bd69250b9b52b70b161bf00921235d6a09f5245616309e37b778910f8dc0c1614d188dee36bab41dcc07a3eb95bbc50032d0d14ed658fbd651fa89d96c7b67949021effd93c044813e481a85cb856d035881a85eb26464907b1235cbedb82fe4a5ebba35932167ed411f65d9f3e719d7c5b1635f668abf8e55a6e2c728e18e5653bb0f75ceb66cdc9216eb29726a24dbb59a21e0c40d0f6aa01e2c1d0022003b9a0e8dca2343946010f7fa1ab99fcdbd25c1c7b2de3e86569c7d34eb19d2fe0725b30a08880420c940237a8d1fe5037d3c6eb14d92167fca8dee80e94fc9615d0ce36419df0bebe4b30cf3338a5391b1f7d55d3d5649bd9dd3ebede21292253473095cc17fd73f43048ebb5b00c3acab58589f2975c647a2db3c89f854decdc7ec72581b8ce368b3976dcdcd6d67cd72dd0714882a519b051be359f334728e48435df8e4375089edc341d4eb86832bcd8478c0af7d7241cdfeeb5f01d97a334af458e320f6721ffe1af391e76e227656319f0b5af0ae3eb34255c3a076d0cd40be2c68a4af43319087b04a3cbecb590f742cc032e22a17b9ce6564823ab3bb37472e13fa420377093e5c523a27a6cf161c3614786f03bbf3e077e0a8347f0c82c3019b189e6cbe7b641901a3eb8c5b23f86620bb892a58e8be505e092c63523277ad72f003fb7670a74809c2da60ab4203a37f457b11e55f6928e72c4067ce5d766c16212d8d3c0f713f8d8cc0cf87ef34d6866597fb316f7db77c1bd4278d7f296991e788c070447c538e4deae418c3ed1164d20154fe2c6a5d07737f108dedc4c738328612bd6562c2b0eb9026fa2e9319b4c72a8aaade3fb08139d4e51f3402da2098eee4df99a2e8194975bfb37456fdc9c23ccae0c175c92a168091b092311d623f1daaccbdf8d23f3132004204802152dbe8daca631812568913ec473eecc6cc1ab57855579bee5191db86646338f48afebc6aa7bfc1abdf3ca3de482ac3158c52d7b1efb77029580319402abf9b076911794adef48d7978528db3da763ecc32024107bda704cf720475e07afcab1af486083bb4379997e0067e01a0b563a3890bca0e325e8afd83d2645b9789282d52cb899198089cccb926934c082a65807cee96b99ecb43a8d6e1e80560d2384e03345bcea7e57a2788fc3caada46d0e2b5c9679f7ad49e66c0bf39a83c84d394c9d5a6fcbb3334e39350259ae2d78899490a42481561b345fc2cd7ece85f504131bddf446b6940fd1d459dc101ba6167f6c6fd4cd92ea7e59b7dda73d7fdb787151befb796ff6e45f7a87b3b1edb08f700b3434926a9773b1104a2d3520f20ca98e18dba81541e72b77432826186b7eea03b8515470e94fcbf03d59fdbb173813f4f87ef42533d61cf49ee8feabb49298d5103decf405961e9501730df3a05fb0b4452b1c14e81936ebb3d5d87ac63d467af21f850b5d7f89441e015515ccbd572b02d2853c140c6503b08886f396d90e702d2cefc04011fa9aa0e6ad1d135fd9a5063434398e3c117ddb3a473400e63cae6a04d071f32989aefc283c563074534dca650a2f76853ca4cd2c6fbb843697d7d98934f81dd89f6470490c3f78bc4d7d1418e87ba94bdb46ae7999d7c9998bd20495d9a8d7cc65374d6738306595e61ddebca9aee3c275c50a42fc00d2d0eeceb04956472e7c989820a3e1021d9bd77dbcd40805f1bba1f2741e6a901edab1ba50030344a59bd66c42a99081c14ec6d251239455b95fc8121b91740af6ffc71205ea53c0e8eef3b8007fe6978374aaaa777553d347e06906d49f3431933d6e6f630aaf3de22b41af66add290fe6a2bd49436023b57d0ef3416090be1fdf9b63aa4579e4543d12bfd80e534f4400108fb4f83c8875b161ebf20b2aa69c33c0664f6e5f2692c51da19a8cc856d10dd8f8b36b40fd9e2f07a4025a5e8d2d7d794c0c8f8fb35c24f0008e75288cfdcb08752577a79a3565de4777296177f8563cc48b7f1d446577b95b056147248cfe2fe22640f7d82d7727f3d295ac56f45842a2a326313dea999e62605e410c209ccdd43abdb3b726a13ef299898b94686cdd540558701c59e3de6967b80cbbf26c30fee20a1a9b68cd6b5251d95d8448592e48961ab6804f17b3b07d14da2bd28470747452faf41b9379466e9feadfcf54216bf5bdd1a9cb274d3b2b03c4dc8f46d5b02dafd870e8db89235d0a4825109692036da64cf711177228e57c62f9a8c5cb10451772e6d78576796b2251f58ee709d90c3c612fe8cfe1799aab85c82af030969da7e93d4f17bfa983dae32177856823a988d9cfa167360f31c9b0eaca5b3b931ba08715133dffc2b96c4191252d8206e709a69b4554e95d26fd81682db42b399f5a87b41b29896da804714d64f348056d6c3d5de05301e4705033b65276ace77235c17ae0d868890deb58b75bd4b7e7ce1eb470e68830585baa5c4a502f6169f72e13dc17fc655de89b571af5626673fe3964e61c2f4c66bdd409480529eeaedd592947e3c5915dea3d8ec9cbf1c9dd41e18761b1f1af4bf54ee5cf5c9054c093cd16c170b8cb7f8bda2d8c04d4c205adf450c690e006c22b2f8f8c7e5cacdcd92c6d3728698d3e3c7ed991f86124c1ffa27004015eb522247e5a72fb626d0d7778a38c72d99738c4437269efde9f2c0668024af68f8a1638e499d5eef096969e4eec9d3eb19d3bd6ab8e1c9147ce4310882a998db36808134a412249c6c5e954bce538a034766f0d11bf1870345fbf22ccca165a2bf15c0f463fe2730aa22b089056cfe338582e711406efa402cd84bc27166d938619a61bf955071a3c43b73561fec898b6501f07d32b0907c02762cb5b66fe61608ce6d02ed06cb3d6b20496b397e227e32d6a6e5dd87ec8dd416b96231f11d80e9143777af535eacb1f4de9571022886268dde6e267553614d7369f26562dfb4db0a26763ce89a0dfdaad07e78413ba89506224afde4826b428040d86f2d595a55e5fd5b2c9d182ce2b156ec99d94bb00716935503cd6dfb4f3d9775aba356b3df31d0072caf9c18bddbcf201c74531b849dcceb95e3f414a8f57238643f2e279796ac00c005d0319348a1d94ec0281bfe45519e6d981f2bb51cb2610834e05f08cfb0367f288b4c2e6aa2aca3132836e0b49377c47b828fd211459cba42ed88acfee3a51b92ef1b39ff0cffbfc367519395d4db1f7550183bb85aa58bbd9fc68885f4106f22d94fa44be22362eac00cbe17db0e962138c9423a6752413731bf7c46d9844cd0103123544189a2a850a4df0c167cd2af7db140cdca80c1ea35adb0eb755a9c7867c113a0a835cc8c49aec3ca2f59d291419a800a288fb6ea26b8dbf2330e9ca89cc372b1a17342f3757bfcc84ba0d77cf6c66d83c6d6900765802a0d6b65d50663008143ca009962d21530e836d24b4dcb792a718ab30e871e4d67a036de454a8c7c676d319c39032b5668f605da6524f92a309b5ac0f19e3df28854fc4f74156a2a00f23a6bccb9d6b28c900fff473d6ce0349747e3b93d0ca67a694405766a4f5b8db28494a15a311ada041d3a5bafc574e2fb9c2f6356a36fb81d1a732a7c02a1457e95aee5d60e610a0218243e12db553d8decbf001eafad0ccc61db99b278f851ff49ec0194b9254be0f4ece769dae74359d3a2ce76c17e1448ea37f2b28f1a7fbf3f23eb17f8186063a68bb6f74e39372cad30b0aa07e80f1c094d9bc8f23a0eb5c0b178e1c428fa7e7dc7a3eb16db3cd3965bd21da0210a117c9776268c83d3e5454897705a32b3cef2628752f3b93e1097e819c5639c7b1fa8a851948fa7f84b6c8e7d7c6420e90a4fe7119886ed97ed5e3f4417093c9f739e735e1579cb9f5d06e90c08e997b81d45b225a7c887fb2d40eb67ee885f3d24fe835df5d56d009a0044baf9925ea21d6ea9c1973d9cf947c1dea7d9959bd9260300358243f7e64a5599525cf498815d8ae793725531fe5d8a805054a3048576458bc60f7392800c89ab8d74a2241c635e5df72780602f2d436c648a8dd7be462233d04f6a21ba1f5de00a8fb19b77454454c03a3511c23ba2bc5b855d97ebfabdeeb74ec56ca49ea21b4321b7bfb57094367e965e31276febda6593da2573395a7d3e43322b3545de88e182d2fedee47fa91a094c86e1beab9207d5018160c8b362385ec283318cb714dd5930beecaee7e5dbef6f4a9b92816530c5566b6d21e698dee8896638db44eb716c31789315ca69e308195c34904ffafff2f5bf1f60fa36a2673a471cef1470280583dcdca5563c8fbffd9ec40d03dec0957e2c7e3a4e38a4d0799a3cc8f9384baa904644558f98b9dac86c1b6f1810f2d8993121d13010cbb03d07bb361a214c8a6be9c89bf673a68b47f34a7061c790609496136178480f056ec633d40800ddd5ac340df201b2ef377da4283c9c5c847c7d4fea0bd221dbe97bd4a1975024f6f7189297f0339396838fb4af4cc96cd3651a795cc63f67702ecdb53089cd95b4e940c97608762a7cd72455f1f59515ef5979dd68bef7a95a1e00e5afe538de7a64581e3405870af51cc18aaaf081aef15dc93796a4a7515ade31b226085b5e64bd534a1ce7649fdaf0d9cb068561932609f42b63ad87512a77b3e6584eb4aa4a00896470dc69c769c7e5efe5fedc00e8c0d245cf94ea5790429e4e83383274a9ae72a45f6074a59d49a886e3974518f27ad17ce7bfdd95331741bc3e19e8fb28ce2272ee29e4efbb9a3d3874594ff0dcfcd0fae30167ef41a4ce932acb23a506ed7832c4287fff614b18045ebbbd01b72b988164536c821288e85b0702f5e028fcef319ba4a324c277f0e3ee049fa61dbd2d961e3707c38a6e353596581f962133933269983d8088c7b4b4767f2552578f60f0d51bacd743805439d3bf1a79ebe03764658d052b56eff2db06d256159d860093897adcbc01cbae78814dfb28f8ecb48c8ebc6275d7027e6fb81ffea668b871e2aa50cb82bfdcb1b942b9208811636213bf4e5b98ac01f12a92109e8c721b51489ade7ed841169ca84c62f87c12bb9e3d1370615a97f8856b5a5be2ec2b47058626f5e28376d4985d85c33741d896ecf234dec88e9ff3f221bef35fa894ef6c2ead9a73a89f30a4fe19e8afba2399fbe6aa7bc61f35f4bd3c680157011922774656842d5bd659756f3380121a50846aacd671547bedb935cffc31011611de02b7007bf4046384a884eb1d3080ff2c1c39103533cde0af00fe2fdd2dde7da08c033906b439f5cb81d49d0563b9c30a9cb89d31f9e80429066b3f5b444acc132b3904074126a657894de810816af72b9feef1dde1fd39be6ce954c470f88d3994d1894e793fc4b85605def361842406498a914dccce3e1def6a62d9408fd2b80f728af333f63d7a0485cb20fd2413b2839392e858474d5be9d7dd2430cda53a1bc727bf7ebd01b53aa176f2314f412da46598186d70ff462ec68765a65ef9e84318c80cbbf974dc9ff72590b75127ae289b2834a98800cd08cf7ab032f78a3af4e3df7e5ef35e063454d2a0386ddb74b29e9cf1b1868c5ce7b1145c3e1688cd901d8a08fe3e691615e81d2ab2fb2c98129e3e2ef2a91bbbfe7df5b3207a995dffd1c2fb6470041d5c92773a547b23ec76e71ebf14e7dda392abcde8bd59c119b98639fba22a807e34103c2e0b3168a37d990d34ec93b289de10836d148642efd113ab66175bee54d28ccdad89e2bf596d50e549e96f73707e0cf897e81ddefd2db887a177ee6bac52568397800dc4065d4aeb48647a8502bebe10d4b09ef73703da920437688c8f0c55a7a1ec95d7e295a419939620ff9c3b8385306bafcd05457fb6d0db6c2b61105fc39a2b16cb8237aedf1d78adff38b925e8d88e8bce14d398739de12c9ddc9e2d8838cc261edc78adbeb69deef25bcd60f45c3dbd6cf535c55974a84d552ef9eb0ed57a8a8f44c7fe0106ef981637ddb25714ab9280ea939e7ac678e2ccaa429bbf064d61a07a096338059dcf1216806ade5431fd69ac9227095fcda20fd66d6c0f550e0058728b132747ffb71d3b2e80672f701c38f6544667ecb89efda03a237deab9666fb64ba9ca476c99f185d64f8245d5a3ab5237cb1e08491ee99deb82075668030327ac736e1d8ba21f108f46d7647bbb6efc7a32ef4cc409abb775ef1ab57fcff8a530d4add42cfe77ad7ead09134dab0fbef7b12d1be03295ee1784d826f3268566fbb4bb808cd521d8526e2127f996a15e1fc2f9b48c6995344bd4bbcc4cd6a68f6e82286d8596a2c453646b2854d9ba67720b2e143c7ab7592fea0e5b4b13bc41865d898e5e16428fe84a3ce4a31ce8867b27f4db575c756796f90dd3f763265acedfe37a55f0e998f3fdfc50cf80f74b8335072da6408fc2f7aa8d840c295bd33a52548a3815994690be452193e2e2585851dd916b5a1175450875867dd56b4464df2672814a35e08bb24208d6f88876678e3673fc4cf40b57613b64eeae65f3fc2bf0389d08cd40e9484245a04e7ee80ede4a6cfdc5e7dd7d1584a9f0da5ecc565979554677c169775bf324f05d061570b7c795e50ec00d81eda142eafe3e46557cd9284acef2aa20767398807578c776b1c68cd734982f6ba4eac81be2782c553a41ed73bf43756f7165ce30eca6df807beaba295989d3d55f948e268965e8f170e4b44e1d0dbefeeb007f11e62cfcf34e51929e36df2d1a87514742873e2875d5038b1f1b77c1e9a9dd0b426aa8473e96be4c0c757dd1ed129dff0e29b42baec760ce6602a445b2895d6842d69436f23645efdf11f9dd4b04fa115aee5d097675a6cd6e8a5d18087e3a542124e78eb3d24f6b59d8ca993f226cb8463d0f7e208415e2c62da8302d5133431c8ea6ad41869f6311e5dbf2ae4c353869cac857b4f38b175cae40b4d5fbe32aff1f82d7b2ec084a938d66d6ea28433a845d65aeb61c03161ff1feda28870980ed13e7082b8fd329cec8c1c391b001e7a378cf22260e2b97af3a548f2e243e7840bec0e231ecbb4b85cfdedb5bd5a918e7a5689e4fcc292b27486712852b09e666d15554fa04b42e35933edb7e51f7bf663675ffd3dd38b26114292ef71eaa8b244cfb61512620ba50cdae8716cbaaee3495e5b78ff32c16dea53aae7048a050f1e59be4817fd0ab9c168c5118cd64fdc600475a8e5eb68b644098aeea4bb934ac0502c9ea855de5c597f2e6329d970bf4ff53c3134dcf0fcc73f3a8b337da645468a92aa2ad718e4bc101f400205c78885debc65c18828059d97690f37edc21a9a27d6fb28b50a68df3c67e0268227e62a7f24db845e12b085ecd80c6b49480af100621b4e0ec7d69ffb60c2b4b73b2d9df7d1ad5272664ed63f641ef1669fb0e19148c7f50e51300538fd82a55760bd22c9d4088ff9117f09982df94351b428afd93cdd48138be3473e7264072b1999fd4eef46274c7c2537e39c10131e04c6e135663fa37dba8afdc1f83119468370c3abd1f124ccf68805cefd6285ab01578a27ae114d4320182395de674f7d88cefc5d7804a4e545ff2dadd6efc7029927e191b0e38f9a0d9b3b5de02199431be1d2860a40ce05911270a49e1d9aa55be8d5ffcfc5aaf8ed02dc6b26f2dd1ff2db608182f36b75b07dd7107acd2c534958f6fb4a4d9abc3caa74a221645f04833266fdf3f2925db11ec69bd9669e586ff786a6a26c2fad1cebe986b896311294e7fcc7e13d9ffd9a9bcb9573161f4304dfddb3834229d5dea3a04a90a6ee1cb3fd2e0842c531578c4d453fc4f7f2f6c915e6b4265e7c30d14f5bce224ad8b87cb5e184ad6aa496c67a71a5f144cb1027d6c765077ac34092b4d45eb488f250e365db5ffaaa820ba04b1a298d5b489c5364f2a0ef4832cd962264d4d3718a80dbcf03e1456f1862ef2b6f5177545d37c35bc09369ac32f29ddda3d0d4cf35b1af19cdfa4ee80c1f4d38e082e06f6e69c3c288a2e56e9bb60cb22a878c78c474b8be129175580178533fa56846fa91a3701a75a3ee370c52253a927d66457bd0864c004bdc1c5e20b568b3e3233dd047553196f57220119046405d7e58e8ab3b29a64057add485c51d307555593a494d923e0699d12f3e5b2430cec361a2c0dbf2282730a9ee12c3db38ce2c9ea30d82fe029f7e38e7dc9d3ede3878e6af146c13d52462040dffb6905d92afd2d1cbdeb768bb9e34f49fbef7a3ad98779191915aed14a934290fbcead62a8d1a6b5063a3ca49b85828cfb3e6de799bcbce6d203794b9c0bb3f97ac7b0717f512a0776a404bd3a7a6d4bc732eee6a4129c270899f1108bcf34688bf714d577f2e18911ce7ef3f425344fc37e6df8360918eeacb7071ed2e9a35522bf66ad65e89b56d200bf9dd41d933579eaf263370ae69639ae8e71c192ceef50fa3b3b2506a12f5f785ce69a93433a76ddeb5f3ad769b1db910281b73ab4232af77a592cf6af9a55f7e9457cc8e0b778fe3ccf662d0f96eae61efd99816515356f68bcef47d5ff0432fff7ac1d4f83ac22baf0d6afac3cf41211f3e422e52364edb3d8a90974d1f722d8571e9027d5562461c0974891637237f41f3d7085b0512315a22d243a8fd170f96c45b1f824f25c561730c02497ae2d8a831b6a677b92366cd2b23207894887f57c55def73a1407026ad60d532a3cf7e6ab7394140ca5fb91fa5e8dd7deaace9aa66fa6c1afd9047a572e356e81f049210d815013c2756908c4489ad807b774ece29cbb7e49790452ff1d054fb5407ec27ff2f3825bfd9171c28056fd4d8a1adc79f208012676524a309dec9e1e6cac396d5dff2bb9c6751ca566bfe77e723e09ddc36ce376af5bcc5fe0086063748c3dc3a5b8337fa65b4097077ce938afdb6d40cdf27a6814d3b820fa15b84ca685f3b1242e79dacd91fc520ba418e434af03f462d300187f963f2d92008a1b69de83407958dd54391af855d4a1e765cc786dd3502f10639a8ea60386bfe9fdfc6be86e43c04c44c054034b24ccdfb265e2d6701e679dd3a4ed5b0ec5e75a1b3c2bede1b97f744ac8db0bada498b571aca94d7ad48a7c2ffe8f1bda59ecd9faff3c5d396719a022f0b889f78a671c783560db9e412bb4d2036ccdfe2642b011d8818ad41057535146155b3138ff216c34e2ddd7e89c1c99069f2b3483b8d90b2262dc54200866c3be298900ceb09c539d95510479eaba26dc5bae4f08cce147da0336b6f6cabfaefc7a83041e8cc3c8155603987d315ad15e580ae25820c5ab066a56b152b44e0b9c836be0054ac023ade74f6815debe21118f66d1dba1f3d2d6b2f7aa5518ace64617172ff91c41acf3c93040ec32a7a8599a3bd87c5bbc9826fcdd4caed24609361cca2b25c85c2bba1e4da80d8316f9d0663dfc65d3300adc273f3633f680f5cc5d9f6eaa780bc26c5874617f41a0790c36b11053b93761b1e0eb07802e5c45b63a8277932f55fde091dcf8de0d13c5c75e2efedfa4fc2fe1308b8948be433fe48375076ddfa1d315a87e269882ff7d03ec1f5ffe3393db652b7a4ffd9b40d97d689cb7aca58cf6eac953bd52071ea5c7fbd5d46fe5c21262971ad0dd7361be0133af8bc2bdbf93af90955f78c8a33f0186b83bba4d76bdac835c3ef1d55f72eac71cb9cb32605f7e116b38615e7778f5ff60e5cbed5c8b95f1a5ad1e35e0ac13209813636e2403fe53efa2511d087941795efeca1b5b3f63e2ce9ae8a04e8a033cc491d2cc68928190f260637ff13960deb4fa7f4ffbb6582209085f65ada2b1101849f3bfc87671fc9a1258e2bde9cdde1127ea21fae9ab05209d340e8b87ed8b991a3d707580b8af9590eed023a8d748ff1f5b2e974b629cbd1450335e99b38352b691487c63ce4d9e6d2471cbd4dc268ce0ccbe04a3d998e9363cd3578ddd9e13a43cbe67e2913e4da52874baa852c9a1ce29579075cbea49f829d89451463fc7b843745cabc69937da37c95cda8064bd3f9eea1043db23254db0108e3d67c3e863cbb10139ad2d7746c1bdc8715d4ff9a3643a6142793a5919651196a94f3ba2a26299281f908414e32f3a7144a1d860146e326434a181d788ffb15fa22dd0bb028662ce760be02be94ac865ce8fccda1434f05ff4f0ddd86b98322d34d7688e16494b5a2ccceacca41e96eec71679b45a59874266af48291ac86692210377bba21ebf092d183eb1872caf744ca2f1ad49efdbb94f97dfde73a712fc0e311a563399d8f5efe872cab0ad81a4506f4258b664040ed517664824b861d3133313745b95bbe747383589a46f9df2ab727413a12bbc4b2330827441b91a02d4d818d1063acf2fb6ed5ff248de5e9ae54dcbc20358b12c96ec9f7cc7a710b96931f988c091cd89eae090711cac6edffab700c1cd6889e4389faa520cdcbe3b6d055550cebcef2a2c70a6438d101dea83dc01999c75fa933f5e80d95c9af7f857e5b705073183384dad68e1952d8e95542dd289f169184e7f29743aee1ec89d0910e388ff9d2ed93bb6a6ede5f526bac104cd0321b9cd5132bbdd760ca0b1f75142d207c61124c07a844e2c7eed596678b4c6f223d7e4bddee6854be833bff97889a67811216795d5f913641326d5be75b2be1fe7b70f70bf49326093ced1afaf6279cb12489003c8891f85510f9086a320de67a09f8c43950903abf8f9434ef698d7cd604d5f024c494c6ddb5d9f7cfd465e4547fe7c8eda4b89ed8b8a9e41a5c6a73b2583db962a3c1e2eb3580a5dd8d49071c7555fa341b3b23c5444dfecf284ad6350f962672e97e01ead2d90379aa23efd71eb25c60a83ae43eadecba29f2307d95398ec48d37cb23876c02d5c574f22da4130826441109fcbf034a51add7727f62d118855f79a3ca6afe5e692ffc49fec76ea2332f5471f8e64fdb00d16f7614937b42e19847b9d4621531e01f377bf54c56becf1c798aa37dc4aa6a76deb0935ad23ce7c34a9a140e0d638a1246f2b84d612772592464ad708dec37e057cab7f5fe21e93a3574914e5fc3564908e07d1b4a25778f757f90a64424c570d46a57765410ccb54bb2db7070d7882733e071390c74f5559d712957d91b837cb79e310385fac98e317d4bafe992a3b586569ad1c1233cfe2139e4d629345ff2b34ca007ae9ac525529eac079278aeed2b2fe4bdfa508b84149b8ec3b10a76734d13be1dabdb538d9f708927d9dc5ad2fd36544ae15e2438321422955951f42f80623c5ea1fc7b36707451d39a230ec6ae40326edb5d1ee5f5843efd2247970a136a1680515d6a5eddeac866f652a84aacbe122ee819c333a9c6fbae879d3193a2c59b35a8707e6cff961e695c080281f76c1f9fd8b988af169990f437a631442ac53f961f9bcc66b6d6365f647d78948bf4f9a7052b3c70a9b6433c956bbbdbcb12b141c65c5d697f95da9f3316e4473ca971e9281c08ef485cb321b785aacaa4f4de4ba65069333a7b2b30168e4f9246cfc2e399edb35a49d2b4ccc3812faf24b534fff7c16dcc8dab1ea70a91a3f29c62776012bece5f22dad261840230ae10a4e5ff44126be0388eecd01160a1188830d44cbdd4dc8196a6c022c243c78455bef1877a10329db08e15e20d5eda26393ca82a072b72ba529ec039e58e62d10eeadc8e2238dad24f8c0b8d1d7d7d984161e6bb9f571db749b8047af11af2777be8eb04ce1d7921150ab07d43d96860457b6eef7437b75cf6c1ffa37dcbb018b0650a723c3c26df5d49f6fa353ba1d028558ab0fa12c9d889e522cf33c984ca4b693f842b36bc4f71971b9574e85f74028acff17c918e9db44284d0126d872c716671f6642576a84d63352cbb9f5ebc1929b47a1a85efd4a0efb777b889a995a5f68001b7347086422739ace2095bba6ec0816f7205e52fd016e095c51ba744b68bb4ec8d6eeeb4726846ecac9692842574608069fa8683afb6c93f15e36dda6fdeb06b6e059e669746bf7a26880dda3d56668af9cbbb7c066c224de5e2502ac9ea9fdd699bbd35348712723d0cfe7734bbf8a8692708289d0b9da5c0e1472184ff8848726ab6bd497fec6d9692410c9b499070a89281be270490b4d8ad9880b7722fbd649f6366e66c666974118338eff8ff36ac66936979ffecb6d22e1d6480fbaac5f2da20c621b9acb55963959fb0f926819dc598de900e9546ff256bd65581c815b610c90c59f94df574c30fd4feb5d6e9847638cc0013f6e3cbe0afc4c06ddd78f386dcaa5c91b94099f3a21006de0579a9a7f2594c1399b404d7515079143f17bcc6b7274910f0d88f0995ed136a59560470308b99a53acfbff3f0931807230c0ba81c7ef94cf85253333afeab312ecc671031c874d5b35341d07970231841131860d5fc3ef43366229195c705ace655b4f15a9d59e8c81713d0ecce15a3a96d269a6d5e2a0b431df285b6cb3f0c7c21912e82954deef2df0c6f3852e9e9e247a0dc2c1ef0a872adfccd19ad2ed29c1e6dc0f44bd3df87c675684f65daf529d418626661942eafa7581a7efab0cff704ed7166a548acb2972f33b36b2a9b95667e7af017e4d7afda43d2308d4e400026251d40924de69581e101e52a23666bc05dd15f64b129ebfff1481a6d8a3a34f611d0c5a10ad2ef4031d5d7d75dec6ceb0b3ef4898ae6d88a96c4aef920a4da89943ad032ed6e83d50bff900c697cc1138c98549ce98cc6747da9c7ad34cd304370301d81024e8632fab2df433ae0c7748475f68d330bc27618610ff9a5a2bf6254edfa50f21aa1cf5f6b16ea453770d29acc5234bdc4dd4aaac6610eca8a0e172ac2e51dfb30d8799e432dac85346f284c737d7bc684d968ad1f91d1e87b8e11cfe37248fd7d44df6990f3a58fc948c442428ec0a8e69f5ceb9d521cd5a3a16649f85d4122f5967599d553bf1f03a0e1e3cd283271409f177d40fb175c294bbcc5197fb662063dff5313ead49f674758273c612c2727681a9bed22abc558309c604b44f874a9eeeaab8cc3cf182246ae86b6961a1e676ed76bbfcc73bd2aa57d804387e06b173724a1964e9db62d03ad5a5bc1c31543a816e561003053b4162a4927df52dc96ae1296ec8de79aaa6cdc938a4b1159391c8acda3737840ddae0f86f438e66db6653f3dafa15a2338a7d840f02b7567aea0a4a9b455cd6130f0338edb133da79ff2ccf113c0ec51d62561f6490aa7b3d855d774843b792a52893600381af1ef84664028c17a5cf1c8e2634fe2369219ddcb1c6358e2fd486ce2d0b7d671847de7a1182cfa0e924d63e0b1f54690f9c4412047226e7bff7502823e42ed3491ec484a378bbc2f0b3f0218a5e22f098c160eb37c3c0668e802694944a3d47ee2266e662c6d3603fe308dba209ecece4abe9473b8e86dbe6d8ccf4dc29da66612ea56714d8f22291a60350160c5cb049fd4d52cd045e9706eced1bc79e36e8cf0fa2c72091631bcf0ea59d67af4900c45a6bf8a1dbfa1c216240941cf5bef30875ecf12d958112bb6d18d85d78ec624df60e866b7c5d9152dda221fdf734f2cef713c95504d1c627a48ef58b9d36243a921bfe772e2da6a5fdbc8c58038a3ac0aef3fed4c6c2b4721a63fb3b581298b9cf673b91bb3c3a68856a7d20fb8cb9f2b0ab08581c15f65a2d7b3abb94e969a2ae3cecb1ac41c6b97cddf2ee3236b06aecc18b6bdc4ec21614b5a796b7cf166c6708b65c39b79466cd503f89ea8dfb911d13fb2d469ce277903f8fbfea4a681d0f64cab28925ffd8e9e216210313090a92dd6b010d71921f7431243fb539569b2872e75159cd2de0b9629267b991c8f4f060946280752b70e50c79e0065b3bdcd87e68324b0c2a878e2aa2a2e31c2b643d6acdf7b1d51855c23daf81b07fbed5e78a8d361eb92c4e0f747386f9f125d92d77f3da7e082f248001d727e36b8bb9267af04405c07f80d1789e34c68e8497da5b81e553134cc16f389bd5b7a9a4368ee0b838a76e6d9916ea5996bb3f74b7dcca846247f2ce49070a3d6012aba060af31586fab681ed1b513939ce2e6576db3c0c78cc9ab476282933f0b7567d3c0fea5a7da41e5f4c0892f149af9c967cb0932613946fec6e0d5fe467b1b84c8ece0be7d6827460cb84597501a741490aa92cdd711a0781e0710531052c19f8a588741e668f95f7ac82972a4c73c3ef5d0fb680574eb70729806fadd7ed4e4561c11fa1f6b62361a8d506a4e91c14e2f19220a70ee34e7ddd1537bb2d1a21818c453330a3d6aa2d1cc0a7a8d62932568c940f00cc7d39550d2a8b0b0d8a2ec0c6a6ad5c185837fd74c5088c291c3794b30fb2ecb7282cae12221e4b22ee460abb3e065cdc291b4ed628c62ea4d353e09fc09f294ed2fbcc990f18549ce761310ee28b18c46c4f124452e48c766a84cc0598545dcd036cc4a88d38228bc5f351c86b688d2a23dd02984cc33cec0f043e0389d330789b5e2700e7ceaa615dec8e2cd07495dbd029975a596f7411229b23bb6ba096ab2bce368036a79450a12bf1d0235e39d4f054cf077193f2e49e27eb4dd5454486d88ad7daa1cc1431621782789030dc8e6fc3877116c20d4602491365397ae540dd8ebfaae25283629e5c663e3367e2d6161448c984133f2e9ed516bcc13176e2854f6d52cd894e0dc5b81c9c3024504be05c063fcd7aebb6ac912377ef52e835bb947e42602889161a6d0dac5d4ca17eab42d023c658f6632b5e30689b50f60953a3cc6f70241be513b8785a7311b8b71bfe32b0c1bdc5a46f88ef30da121fc37f44da8d02831015cc51b2b9b8e808bed3f7fcbbb1bf30b57ff146c89bbffd381f795449eb0ad6037af0804f76b423dc87a5355b2084bfa26fbbe97fe9b12d18dfe5f47e51484898e8e3aff366936af73fe21c0664d0fea9a5779956f1787c8817c7add2518dc3367723671ed59e2fc427ebf5bfd965253a77befc4a9a7d3cd7bbe37838c0eaf20ae6529f207a0c35b9b88b02a674ca8c6075da281bfc9ae538b811b639428507c287b8306a0fb3b9d51b1078658a5ccf24371d399773070ecb7629213d2721307eb83ed19d3517bee4657688538f326421ca6c16e16c1fe8e94dfac687771d6801af72aa00e3c241c593d3099f58c35666af878e0d3b5a35765b6a33a6baad3b0bc578a2edf7d75fa0537d6dd3ee0ace9f5e238089b45bff1a0c943f4f06d8902197a3c30ac732e5ffe7003d7a06656eaaf0a68b401880f75cdebac8cc6cbb8e5881f93787379b6fd0521b252425c4f27ba8d3ed3ef02393cd3354a610ce07eae77f9b33484343ae391cd5b45c1341824a1e7c33dcfb3bc5cd6115a04bbb39eda59efbe2c7e8103053d3680a527119812394eb62240c911aa925b0efd2868d0b86b7c6bf6d5434706fee0367270c5c4e6b37c3376650c65ae6b6e5e2800f5c3f0a80b93b6693fa9db8a303cc8b237ed92680dbc3ad3bebb52d104e05ade48a0d2f3791141d8cab69212db77e28df37e3984c1e431e3c5f8ba310f155aa1792137c348f08e8c023f3a7728627e68b949a405b03e4f6511e624c60cfce6327de543d79378a3b3feb2544457fcf7a0a1dc6c421b5e904e6d6fd504ef157c441d04645049133b5db44b643a6dd3369e4d6c23d798c957c9288e849d1bb1c2606b8ad0a77c46a6e6b38ee7aa2c48d2275b4e97f4229348c68c04bfd8ef55f5c792669353b0de1e3205cb18188ec63bd5bffe4c009791824a32e2d5c27a4c70e5d069f9bfbdb8d7029f20a130197608a53944598698454a3a3b607c88536b768bb10b120798a71d3c47d58b34cce97610145c11681708491b751936eff8801bf7f2b9044fbe8ffbd8e25a346226e8feb2388271fc07662a3cd91b4efac1eab4d0970fecd8e422c2fa2b930869e3e3baf746a5999df056cce2a6be9dafea4ff2f7be3eeebc01db1aa814cda3753b4f64ec3f1883b65b3b8714d67672362955a1159678b8345caad1a38a5eba12322e9b9d3b408f49df7d5503f66b03b9fe2135d47283149b8bd8af98c940fcf9628d8cc9e5da594cf8d7210a69109a9f4f2b0923f6ee53744ad71626833afe6cb5961179510bd2900ae7240ed22431d7da596e540fa1fb6e6753c684623e11394a9ebe1113f46b17f3dbc9491f02f16421591a87dac0091fe1d4c984f0a249d26cae700448e384a22c7e268935596bc22885f3ef5e2eb52f1a0b60083cf441c7b72137dbb9f94617006f92d71e67972edfa57985971c1d931e21c787ec32229326d6421f7948eb5c6a7f2e2a4e6ae132a7c2af795a6712d82582f1cc598745427cbc7969c7b4492ef0324a0571cdd0f5b4e7d5dc95a8ba55cb4c4e76bb8f093ace9dd561161afcab426271151659dc84d261a96ebe6a1abadee041446a24e84bed3d6122d17f76a6120bf5990cbc95bdd47c2bd43bf9bb4d32052cbb6a71155fdc2e4aaed01c7f43119b8c4d77f4ca8d4e1b77c2612ba613c909bfccc349189ad98ac832ac43a3b39e934e0f127cf91b85b8573550a206048cbb54e73c78409282c8a5b40ae725117eef3012e038581cedd9c6b550eeabe88b7e79375d6e353c4cc86531c6f18232da0885665f64831a9f47e0f5e01df84ee5fd609cd6121b1a1615cc4d1a26c7cddbd920aa748296ee3c09e17318431a9b83d0d204975257f64898908e103967a7159a56e2f38131841884fb4e109389d3673cb17e10757c07056d9d0439a253eee56d010f1c54f3ca580831a22628fb29b124a00f62edfeaa3dc044775c506a00e977a94d4ad0afe8489f78939c63ace88e7b85dbe1bc6e420aa13721793b43aa4dc2ebdfe1204851210100198bb8f5f011437e04fafbbb2bfae654b310df4cd24de41babac020563747059595e26be85be9a4093c82ed109540c19a774016629d2917d5e83223666d96f04e826c97a7006242d2d37ebccb0aaf185f573","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
