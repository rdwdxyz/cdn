<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e88b4985bbafe9c4da6fead439f90404322b0ce8a7c738ed3edcda94155500664c78b0631576dc6e498e57e79bfa29228c3f4fa2bfbc65fb049106a2d867c7cab4e9c57089e50bbc3e601d376faa93bef5289d75cf15a4f5192377a95fbee2251426f3c3785e75dd44c562487f07a6847c3d256544b320752ae3a12c75861babd2f7c84c907b0ec3d73ee6c72ba1b02beef0f545bfb6d018cab150a7349eea046fdc2064d6f9b82f9a4c4fcf53a2306872e5ac2929fcdfbb321f1cdbee44a561192e7b0f8d23b44a00689fc56de678be3e96e95bd1d683a1d94b9b55ad8de2ec0a35644606ff54bce092d42c66b0fa9615b5cce718545d129bbcce2cad64a4d349406df859c394f69cf39a40f5a2e47150d02c8dce0eb1468b49aceb9b0982bfdcfcfb0cf9b362f781a86ce90eed37e69f065b7b9ecb6043b8519397f22a992b91f95e04f21cc713a398490a97629a869cba0c5e43ba35930001043fd09a004bb5f9533b9d5c17224bd4b433ff7b941473f8a7d7021edcac81d8e00cf4a0ae89068130278f69e090fe2444cba41799a5c11b4455b01bc31ac33b80a02fbb87f97a4d91605395947ba290f6a020b3b345334c660719088af2af19d60f5848c5a8d22ffaa9770f9c68b7866bbdc364f48a83532af8efa9c555e4812417cb3df0e3e3346ee06e93fe3f14db5190a28727a34fe0e1c3f8d988a300ed56002f3cf0ab29a3ba4672b4ea76eaca1308f2f05c0f698b11540dc3eb02a90eb9e94844895f8f3e6eabc7700f73c4d459a425ce48842f59cb65b397ae702272f73fb6c18f32609288d42207cff4328b9df0212add4966b1b829e2a99f3d37755ea79615beffa76fe7ae4967a2acde2be7ddcb9412f4e94f242cc9d7b45a54ebdfee619372b9d1df7e230283d373c3d5c79d1596b76b947673936d258925a9e039243c9da7ae098c0d5d9f97ab96267b4062e53802665e5d2622a3d7d2527799e0054b0bce3df88c590424c3900f900e28117d3a14c8ad43e20375ee9b9980fc01e1ba4a82b5cfe5e96095f298880df62671948db97ce993629a9953235c917515713d2c9cd6c2d6ea934e777146567045ae8eaaa0f56a5a3b36210d0b681402cf1502832dbf7847e5a4c6f4222c37bd3256a1e7a5a2ee5a9a4454294822a490801af95d4b80bdc1f0af0daa2341d847b4014baa99bc8e1def15424c056707a9b31e1e74032197f92503b79e47f6cd3ad7a1d9b817ef1c917e3bb9f5b20758ca5ff29000a4fe10b4859e4b33ce6e48b5001bb887d465a40d7d7c9eb4d7bdb4a4b2183725e8942aaf7ddf5afbeb79e792851f8d849c8e926dc2a6a6f8105add074ebc6ce5dff4711fd495ae78a92bf159330aa36e0cb8108e3120837746b0d2588d1afe90ef3604685c12e7e9e37c5cbd3d1c33d2c6be0d55c8342388a352e0a94b1f94d215c8e4043ecd56e6ce6f2b9e83ae2f8f19596f87877abec50969a41c9e065124b793bb651a1561a49296eec66f551451552d5cf34a8bc9cc9d44e0d7bf23e6c9d8ca48c51a5fbc64c86800146c414e398213ebdf04de4853a8cd60c141d8b4277a8fd9668d52c1e994a140e773947dd059d10c3b2cf6dcf858354fd2621e27093936303bd19f16e1b38bbb0e52115faec643db947fbb78800564da7bfe379db69bff631c08476788529f74caca21c85e6b4b63676df21dcc0b06316506598f3348ab9f4fb127aaea6eb76ab22d8aba99f18fbdc2642341fb6e06102feda0d8e49e8bfa81192a0e0720bdc2b5819ef4588da7681049618eb1e84389e622bcb0c70ed924eeea4f9587828ebe81209e998d5d9007e8e80e682cf4784feeb86f5b70d02da2027b8871bf6138e766454ed57b409ace5531639d4561fdfafe43cdabaf7423a3a731dd1c3753ce4ee6ebaa8570b217db591fc5a7816bc53d9b1c7da31ef93f180619455ec996fc4fab1bcb07204f6d2298040595f8ec2dd3cb019d4d1e082867436070786c2f9db8e9623a8cd610a7bd891fda4a56abb1f571894d39168babb60c7005e8712a2e7ede258e02b8fa06130b473093706fccb2754041a86a254c7eacbb63e2f74da5b6d4a61ea772a38211c9f3b435bcebcd3126d3ce34ddc385e1f43895418ce765bbfbb6dc146e2637fcd259f1b2bfa528bba7030b1b38067619356b8478c5acd373e51c7e6aab7e88eb870b365e147fa6773a7beec9ce322e34055aea72ee903f14338b26819b88907dea1a92b5e6c32c240c8bc0ca9cb5fb31f0a5b0712af84789c8d1357a0df3e8d32cd8ba209d0b888189905d62dc152b953a67a0855d696819d47521e6abee5e94fd975aba0db9470d82714d2749e8b53575a0c48d10c6913ebf855b5243d182a806b8d3806f8a1d51d41578ce21ec9789921bdd4335347df9792309a65d6d7324295dda88889f86336adf00456e68fe789c5f0b14a05e85c77f6b9f3161c1b80a4abbe94c0aace823429c5694df4f56493b8bf3d349f8284ae901bb706013d437bdd62f09d5eb1b6b1824eb7f7796055a27c0096b6a678192149fd589c662627c2884cb35e3efb0f3d02ee3cea253e57458969aa5027b643cc50bb44656c8091c82d1744d3061f043d2f02d1e1a2512677ba8cb7edc14f7a11af29152bbac45539ac2e6efc1817a3abbc33c4a9f3dd631446e6388e62e349f780e8b98f6611de71a84ff88796e6a885dc2120ff59f388a75ff017286d586cadace762bfe0a5a2a5d7c1f0ff9bd597ad4e69a3a2beac94bff9db32581582fd9da91f3249cef59f713cd86c25321e81005ff067c9116bc30c62ba5fada0b4af356f2120e85a784717c8dea55951001f6bf0d443812631b1fc21117e01b57a44e9fa89c832e3ec935287ea49e05ee0c63c7d4d6324605589d7c44a3b021e0f176896c5401d839f1ef2526c437c17bc69727723784a78bf80654cb49077aaf23a0497d2ba6741e516df81149787b7396b64e1cf0d4ab034c3e46c2360d3329f40697398892ba143f31e93d7c3581fa8b91dbbac3358a7d882dc807a616b4211160b83f8a631f442fa59a8e8d24d1524e0dcc1fb6ccb4ce003677a09a4117ae69e724386b11b35daba360e9e662c32815785e6da04fa0c8a69a3f6eff2f43b497643dd7fdef838a1800811cf791af290044b3ca42aaca22f8c08a7099d27bdb2778815eb6bbf92d5d71c86eefd8b86f0cbfea37d4afbab6e004c73cf7d8a8787aa94f21e63b2ba755a1783040225b3deb715deebb283b08f1121ef23cf7b719bcda1921903dd5f5e9886d696390a23a3f753c122db5fe90e15fd48c5a75cebef3ee3926ecaa359b9c655c07ff798caba27ba1093553a7b876bec94f0069454cce1bea8115f15dcab724e00abb1d6d808094588d37a5563983757e8d2156ed9d38d8fc4a39bf47bc580fee7106879ede629e2e7479bfec11d847b95af1b92b477267610f381cfe6a6136a0c11db2b1717643451cb1232ca0f18ad8c0533d9c281f7494101ea02c0e200dbf308aac467ab60d7400d9ce9438ac93a549d0be6a7393b5fecbdc6aca93e7181aa449b01378900cf38561cadaa0a7b8e587117e313613950c427e99b80b81a25e903d0ef8887ce53000c4acf7d648fc63ef4c43cec58998ab7b29ddc3e1d1b7d4a1f40609b00e96c78f7479202320a2e9d33038cad66b64b99ebe643c10e939100b7c59f1b98e7fabf6d86f8f5f190151901ae8361d32749a0774266487f5d24197961c00b83a01bf153ee5587618f071921c8daff6bc48aaf9373303f39ea894ab7c095b2d4d10def5bd5dc5e226757ea4d6a93a5a0aba4ef3d2bea9be20cb6ed2683dcaa3461642a71bd63bc0f8a4a13f9c09a8140321b1d08b72d35fe973c4b29930e799e2fc65876bcf40f4de980f86b9a2afaedfaba2722d45a77fab25e9e32b1e9bf902161b53a5f6969ef1c5c0482666942a4aa5ca746adfed2bf6d5f585b95fec52bafb72f9e5e927f62e9f018c24d59b99784dd08684b313541748ad18e3c03fed6d115359a83b530f1ca8dc0791935e70c975c31ec4fe2c4f8a60c7ca6f5f2e92238ae3f274597772a375fdc54f06d6a63b187df723912a25f2d158393592ba21b03290992029815f61326816456c98f39a31f57655c73076030892ab97263c5b894e1a12dba14e866f9c133a0b21d0f78d721d63165d78ac25a62f295b6d6cac7db5c63a42db544708344e9445399ed22c43957abfd654dce0c64fd52734e29e6fa3f98e479ec1c4c1e908aa8afa58b07bd1d3b0d4918589114bcce67652d2e6ba0e6ab6ca90df30ab774a6bd936a28b731c7be8336ad64d04975dbf6e95c2c71b3908aa256fd4de3f0b3af779301b30246010fea94dad6426b925daa4a619cc7a34b3fef813c1f177787dbc67cb59b6fd9f977b61f1c98b42e39c4408f2b58d802d256838c98b45a30bf0b9ce8e05dc02a6dc554f49f1b745ae7aa69231df2d608a029fbfe36afc5cf786920daf0f001dbe1de27de7a6ba6c45c4d00d6559df84a326ba8bed3bb6c8a7e73e337620f420e544583a490c339de4a9a89a75772a121e95f075212a04ef5c9113d5c9383c8941ad2e354bab8dfd8d2702bf16618241d533e600032c21a891949de448173641a947a44737283f507de31446da23d28c17b316262298288caf6e9927b4dc0b756c005bf0546ec922f55ab6d2e4892a5d6d727c60a775ea490332773be463d7c2f1097d8cdcf3b4ba3ee2bc2dabc1217b545f12e008f989b7795b4c3a97a59100b022b570bb0c43648dad48b48b324dafab449956cfdd8360051225386d4e6ab02fb745f00a995881f21c5497d8f3e2979cf99cc45246f3ba0c5f96d260c35d55ec57bb2a63631bca3f71d1e02befc4274f5a9da6cf721386224d792c77ec4dd6b3aabcc81cc3cdcdc94070b6629e6f93b96d68235c39caab9ff26873c8cf93b3c6bab0cc7c347a69246e8957647d261851b8e11f34ff21cfd70397d2464e33f5e574c5c6bbe2e0f675aacc67fff3f11da58d79cba8400fa95ba185ac6f04480a159e776f316fa371e7368a662dbc723cc084df64faf4377b8f3bd667cbeebc175dc44457adbcd70c7868994dec0ae63bbe391fc649b717296c712140d157e1d086f83de7825f4999aa56976793f70f6b7a93ef9e040586752108c0551f21bbeee4f7567a262bf0f3606068f5e5a69b8bd7929b79444d3e474138cd020af07064fd971f8e8a5261edebdf83415171894acbaa724cc0efc45028f7af236d404dcdfc1dd1c64ddc54a7318bac1f537553da416bd6b71a332d7520e81e4c8969718ecb3080fbe9ebde3f568b4260973d13791f557e319c863ac9e5f902ac271e40496d7de27ade2ed8386a7999435679bfcd231d2febf2e5e220e277d3505a5bd25f2196fb8056074cf1aa9968b7a56fb4c2f172f30f473e81146081c82c9fadd97cf597d4f395c19619af525223e3d007968a07d3c855c2529b0eccf2baf2bd344d98b4af9df1a182db8a6610805757b5caf255247adfbd0d0312194de647527f0e71e1404993a27b0c0c57d2548ebaa4673fea560cbc94e47149c877477e7e27ddcce0278ba28b6bf5cf9e12f23ee6e28d5a6ba752271298492254e8859e1a6bbca11b6cf81792ebb622f9edea014e0ef25fe385ead71b87300cc58dc27d1c0d75c4ceab4dd39b56ee587b9dbf12465c01f13d5bf63c30184cd9a88399472b76349f7a4cc1fe0b5d0490ef71d144a5c25b88e2af730605a8eb3a56e423fb54e08db547238a2b4bcc3d468d6873b9d7222754517f596748e960f735b130fedf5ee99bd1224a8cad3b768fba48cf4df05eabf53f62a22e04a89b1fa8763760f2698de89990916e428ec0a226275d6ca724b5e5727b8615ac08816cdd435b6011418e3a631601b74e4f28b13db0962d532a070ad2f677698cd185c9d9e763d2a520e26f741fd4d3be61e120514f73302ad8d66da9b1bf2025971ce7dee846a8f9ccc5012612dc8c2ae14aa0b764cb2a66188a0c12d475520836bdea7a46a4d8437164171acfec5ac5841867886e015d3cc8d92192a88500c4a9af73eb3e17d7ffc6b37e43a8e0f3b37567a385a519014ee12a5098ff6c02202e27b791af89115ce076cdbe8fabbcb574319333e4206d07616c51dd3c6f224d24fd64b120656f275f5ec022381e46115821f2ef0bacd950cf415973927f866b25fb1b8fe2f7fccc723edd61af8bbd9eb701844969e07ac84b4d8e841ff8643cf5ab3d0bd0bf6f2e6c76517bd8eabac28b4277ff4b9d1e4ade23a1ac3d4867c50e2aaa2eb1b9afe4808137d5e553df252d18f4a959c947bad992933e4a5a6fc9dcde6cdbe33976254d7fa3413e4aba9cef6e06d770791afdbd9bb284eaf5dab6f26c80a80559b6e53edc9846acd92cfece1c3a79019b1d98ae4e9bb65f5fa23e566262ece199c07feaeafe2ac6563df8e2d90f46271606475900fa9293451564b809c42f2909ac871b60d4b785fe82bbdbfcc78d586a54268b88ece1a77d216ef2a59e66deb235559eed3744f3ea7f4cf15b09dc65d494a59c0dc0101e9f8c5bd2730cc3edf73ff00491b8a4cb6f5c5410f7c776aa92dd117ad523d7ab1498d7bc286b24e1d9d8b189d5ea768fe60d7abbf5494d930c78bc61ee19c8d7fea9e4e22400f41bbc877f9704078a69dcc271f23996e44382f2e8974afe103c9b32fe742b59b9d444fb29927c99ef733e507a94b5f1a47c550ed310e96b5a6421811cc8287f15bcea6f92816a82c9bad8715cd014fa9db95cc11fe6b9b583d9212aa312bfd49a99ec662463cd70e2721751d2ac9e62ad71580f8ca049083c0eb7a37724e5eb22e1df9cb48ca94ae5bd88f536a26641a861021097b309b9fc01979d1a4d56ba61a587b9145b084156affbce64000e3a145bc38b5ea67bb842ab2b3fc0fbfb0236b2e4e7dd22bb61bfe286b755136a814f5ad36335ffdf58a9a6c8399fe8ea9d6d9ebadde06dee40f99795d22fc94224f6dd12091d3eac3f4abf1c20c142cf9829080fef3f4e99bec93586523b3b1c866a25f78ff14998f1fd5b3c2e07c02a87cf88067a66a4bb6eb46598b6190cfd4619cce382995644a5a278a6089e397278dbb3126e907b1d0eceeee14128fc25e089a35a9be3328f504ca9cb19f66b5ead5b11f86450972cb0c98d04f681736111507e669d91644088b6c5ac854e0bdc69906bd2559f0ce080234c11ebbb1ebc6386fffac867ced5287353e530f992bee336921888f323f984de78c4112630d59f49b0d30dfb5712eea8eb35bfeada258779845930e08df465b9ccedfc35181ed6c44e7e84d708d516993708be7ce35f1bd0443affa3eee30be435b9b036e0ea8f6d0bfab6d7ba0392e1f1b7b612a710ad220021605797be4c773c8833b506247324cf938840bf1513eaba2d6a0e7ad52c86868f2ae646b92f5dce10b09c5576d0ab6d799353a3691fff8dff019930a9d1a4bba75a4e89c99fbb5c3643d1d0129b6d1d75ea73009d54ef2598c7c6b6b8e1cee4906dee8b235db8b44ce99efd765bada590425a9f83a81b93b00147c8142382a1f2ef8b6ef31994824ad905d10bfb6eeab05a8f1fff910c6e92706027a901b6448f12168cd0b0702c81f98d2e677a99ba064e761ab27aab2db59d6b73b9244a0f9cf304076cfc6b90b98e6b3ef2b335cc5bf7decd0bf8973f2133317f8cf3a128d435d4b7d0c077bad743e4ad60bc702648cfaf9014345872fad67c3007b77912ef506133f8da9d35ccc717aca91120f017e649eb6bcd17eb6f0493800e0c3ea09af115005a998d596fc1f5a59fe3ac78be1edca91af6766238e1b2cc7d46a10207763b5a33273b10812fa977cee5e3dd7637edb8ae7e7658ebeafd706ea625359e419c69dd8a99c5aa64d57a4f56384c00c8dc9b5820230f645a6a13f8912e45a386c27aafd91542f0039aa287983ea9c92c0f01ce1cb5ce10f46b6baa37a417ee330984b62ee2fb977995898b6294e61b93a79df1394a76812eaa0c349641b04e45d35c2e50a16e827eee34ec21138b3403d36ae7ce700bd2926917d3b2511bb3123d2b1ea0777e8d01389bd0b79adc75028d1efd1fb096a6a5c653e41f7ed01ede7b43cd7ebd66a548731165e64565270f0bf56a6fdb0bedd1812ada8aa4ad9c098f87c59184787b5318e60a57e22e3b259e6b08c0e2d6bb877dce674f9f2a195114a70a6d2d054faa07d746bce22663fd16f5ae53c8e603d003252c83e7d362b96ff0e9fbde124c8ec9ecb5b94908d400822915f26af55d12c556ea3fe6273a011c88035b4749c22e09d4775b3463c8e6ecf3976229ffcae2ab0f0c741d652213acc0a98b1830966949ae1651567b0112be09e095c2989d02050c10b71ebd723a0e828d2de3b06eb4e65fe9f174cd3df1469acd8f92d6792cd02f597843c3ed3c5448f8e3fbd555d1b6b7c6c141f1c8399e01965a3728971bd96a81e07868a34e3cbffaba4a7fa4445675b009d2c268eeba1e2cab46bf7165e4c9ebe0596c67d06d0d28c8290aaa1f930f695f8a5154a9249162ef1e6816e1dd249430b3cd34365bdd860bd184d42da9bee2d3564d1e63de467a28c5eb69887d585bb5354283e7867b64a899a926f0d1ad8ac3b7040062a224d87c8812c8045662a4e6445de2b24acf340901fd1ca20249902cf3292d40ba2f0a1b55fb22152ca6ea2b75461fa47dc62c14c8b945ebf37d8d65f39cb9f83492ecaf810f5a52a67560f7141d00c2dab38384d0a997635a8a25fd79a3594569d453a9e2d613df34dcbaef9d8c2cb4e2670e17ca6224a395e61facef2b08b3f0c10bf643d6376836d6b7bc50de148374b2a096de4a50732687b3afd9d0e939ff8c6ce9db6c099d47ec7917eb687e0706b0f027795f9b1311b5ebfb5c9f3851b2e18b5611e189ff61796a1bd3aa78f024d5aca5100e01191449ebff3150cf02fa1f1e56d5ee16760d0c9ba524066fec9b9680d1ef5b35601ca063aad0512f8f50c107361d758c1e99a351156d5b62660c1e6a100bc75777b59575db1d2d2b26177edf425c4e711347f506f8093f89121340058e4f7dcc83f08ad1662333ee90fb5c837936a856635ebd10b05c421beabf1f6cb2b5b75a897ac84e777d5a606c4114dc71670ae362e22ded00d91f8ae208a7dcbf4ee860f7a16a1a4ddac34f8618a134274292af0ae56bbf5f2e8686ae435776e0a9af144266597f88a15459e0f288c8e1f9eeb8e23e13d9977ad24121aaddfb806fa5a5ee3e8f6faceafc9ea2a262ec392480efc9a363df4124a6c877673b48368606d77bbf127e5d1a24662411c706a082fad0978772dc1a5c016e41b608f16cc5f78acc87d43ba8ef27bbf602cbc236863d0b8c9ba5cb7871f8f2ad29e573620c6288f11d3fb766c27b5945184eab495d312fe1af56f20d6d0d02f5f05a50fb394ef9ce6abc5445e043c714afd2cd97445752f7f74170ba1222e80fada7203e1793f12d4ac6565683baf0cc7cf65458e564dcb90774bb52f355791f669e29a5a60781392d2e11ad03c2f20219bdeaa5bfecd3032344e592633ee1c047aaf9839d6fb6c3894432a317f84f41a55b9608a8e91fa018785ced955614375e9da6ab32d792840a202ad223e84ef9f352d9bab31dd5ca77f858adc5346e9c0a0b87074cb4b040fe0349aaca23af4064acc73721a82f7ecfe1df03d79bce9512293322a4a8ca8ec170d70974291f5dbf968917fd4180d28ce015006596bee2e08147a16696a5727f8567c933fb921858a21975133e9149d4dd8a2c8ea3aaa89d9f3be2be5457197730e7e639928333dca877add990b7ab65f884b6bde6eb039bae82dcd5a73021c77da57a427779c29ea312abe986ce119421669d1410c02e3dbe9afe082b764306d4fec912cc21ecdced769e5cc5e5caa56815ee47f0cdcff60084016faa9a3e7a04dd892ecd3345760a684e59d5a990f6892991bf696c88f9d5dd8e7d86975dbc5e0744f1ce2635cd24e3bc6459e0ef8dc69c968269b200bd0508a49fd521da0e3c6d43722d8a1f2d5cd121224ec6fd948772f9f7a4ada38752e56ce446c260fd6db568f5e11acb250ee33e784df452d912d7645e870d2c5a834bacbb1ba75749fe8b61da6142f776bc639fc3fdf25bff290fb217d8f0bb255b31179fc40a4cd2e02dba738ef67e00a711d471c06c5cdf294a2d11a8c145243e68ceac0c7e09c5297afe1dbae71ece24ca4311f4c754a019ae055dbee0c3eb7f19a67773e34b390937c1a7c54ff7b57880b7de9dccfd1cf0b63775311b0de671405c3477b85a3ecefb51608afa8dc0f8ff2f09b478aee5af974adce1bbd94cd52f43f226bbe359ad445595189fa90ebd46b796577be6732fef442551e5536d32f913af1ec10ba551a79c46a6b4f83bc8a1393ba9a0a1f1119a0ef4f643132ee5b95b73c0a7c3d6e3cd5fdfdef1c8d29ddedbe6f2cf0f3d89da552eb8cac81e46ccb4cad8f57c14171439674d6bc3e8dbbcbca0b7b80c6092af5e48dcddc94a621aab664e2a965a4ce33c8d10f19c7756681cf18398fcf328f4c8d8cc071f7b858b7ce6132f9bc5a29244fdc568efd759ef4ffe337a5dfb78611e262cc2aca40f813ab56697ae33f6be74fb5d4ba96d82a079953a5634288a70faeeadad079c4811e3d044b1bda3311fcb3dabe51250d915e8c90d960f9da87a1923c4c470456c29004911e0ee17f6ad3ddfc4586c9ce4a1ec7a8d45d6b010e0a0539ad4683f34938d7925d4e6bf70fa5b97ef3f354cfd81afce318e1083c34dc6c83b20cfad2070bb94fb17b6599c5eb35b0d6543b20f3c16aab1a2ebe565d6ff6b0a53792e0c12e4a724bd9dd197356bbb5cf5084efb302646659bb54fbad5bc2bab75304128be2c31742f4d6470ac1116b6b5cea7edf4ecbc0b0ce9d09f80f2661b10657b42b5bc0798725b3208886173465ff2e7157f4371547c0d46e164cc93daa30bb5e353310b68bc8a903dd65657f5d06390f5c96a04af4ef3cca3178b7b57fd9382d83c0fc5d008b8b6858c2d8ad062be0c87f8866944fc6c18c4e2868442d44c0dd22e2374bb198b50defd040552852e524b2499a34fb26d0ab9c3d91fa589cf27218ac466e642381811eb5ff519b57bf2be63dba31bdedf5a4acf7e5eb10d783e43cf2375d3dce13f94f959f5e4c6204ecabad698c566a8f9e9b47f10656df11ffcdf029720f7b8edddd91e486f3176161eac8f9d16cf402ab152b6aaa2b47cb3b7c0adc11ae083f463a26418c84dfc9cf6b94e1dfc7056417ef18ff257049796688cad029cdfe19512195b3436d9e624d7a9552fc40c42c8b61cfcda346437826fbe2eb88c2b4fada4239179202819aac4b2c6da13c5b8982637e789b2e611d3e891c91218fd2b54132ce8fe462d5f9a0ac815fe063fe5aa1c337c06817984bfe99cd082e569e717158051e9e330608d496e2e1dd6ecab38018afba4b77926238594c79b621f805ed27f716ee7f7e42bc901a71e7ed9f3af48d180b0ab2c7fafa81eefc28064e2cadd60e7596017233be0b75640e3918e87b51943a99b496ac9cbf02053a33b6c1bd04f8d5cdb2296b8c67c4666d599a9108475abf6e00e583ce25acd8ee958366ebaaf4102d31aa1e7437022060d9fae4d40aaa20eb7e20693b671cba31b5430da1d2dfcd0e96389ccbe06657050bab88ba41d00857a510140b1d634212a390555a6a30ccbb5071d0081c1a03ff5a22635c250b8ea3dbc49d919a794ea92657372595624d1efeb370d02bb6c3ee919a5ecac85f7110b423f644d0dd3a22ec42a51405b5ce1063c9d09c4ad6443e77c092abdd0209b48a51da4c279b2c44291edd0f06f61aab24b592933d8d7a941566ae3cbd022a5b973b500b04a7ecd6ce2e11e067ba285a3faed010299cf074c9ffa1da36a653fd5adf3c4a00bfaed4b7d61c90256f0dd784b3b3478fb0b36ad1cd85ff94c1b5fe42e974398df5f0c675a014f7cc9287677c11801c1d58fdc4e70d792d14a2e6cae2774e015f4ee0dcf2e89b381f2447e75034bd4b8e7520e0b7049ac46d1679ce076718d16a01054e39c7975c5ba1fc7d00ff0f69a54570ba63c078947dfc18bbdbb5fbaeb88174f668067444611c5cb253cb5117b3e8c94d2a193c644294b2a25c65f1a097e8a4ffdeb05544384a44d73f1a7945012a131173fb25476e93f9542808e8ee7c14806801fc01e54a21a3ba0b3a7ba5edcc0e51c48fc60ad3d3a0015c2df46cbdfc6cc072cc2f50c4ee313fe0a9f4a539f277bbc03a5c7ee1bc3c9117a50f48a3fa2d8fa6b5bc79b4cecb2584a2cf1f105ac9de62c9b4c42919600a415552351ea752ed6e39b0ae2205ed9c4210f6f6182a603c607632a0381301b86ff8d5779e28404abd34537f6cd47be315d961f54db8b86d251e390770a41e9c493d47415e6ebd2ced57e3597020414c3da9c22c54e49cdb31f5bc4906737d079a8e6be78c18a7033855ca014ab2af3efc2b4c67f0beab4aca1911359505c4dfd27cab53114569e14affe5092e43dc95acf4b4a663d365957a72a79c1601473725e7b2c14213715a561763e9886653743bc0bc4cb75dc19af3df01b824ca39873db536ef6ab0047356fbec9a1c2cd379b309baaa77c9d65c9cdf3fe917685f6838c96230e7867e23b732b816d7fe0b53a3a6d447cac2ef4bf08677d3b1f8c7a5c3c3953daae8471d99346eac482640adb439ebbfbfb0f85168d4d056fa007516dd681788929b9ef2692c53a38a7f6c07413341fd46fc101d544c16d21797113f019088694194978d5f9dc2f289df2171339bb9b448d4d0a304729422dae6db8eecb0d4fb4fe918a385017753c50a524d1a8d65779ebe3481b317a6a83ecdee9e8e8e6ba1983a192bc1e563ff07f1f35eb50f52aa4f2e3349e12f9d86b1653e22b037e6c3a7bf08c0a5f5b56a5e70bbe0f87b9542be4d86d60c7e88a43760b92fec93db860fcf62ea2076ae780a497b9d7f0f4e4add0d28b7e6b204605247c5cd9eb4e14b69ff0af16177bc849934aad2b0de43c5fe71521cc67063ab903b1fb7545a27197286d01304c0a6a5437e767e98b661120e70e113aa1e81f44309c63c073163678db009da3d5852c49e62de849066881b894bd54b9996c715d3f5852ed01194e0ac122c46512c04b9d1971275830c9f6504ad4a63f518fce679c0702c8b0e44d58f368d5addb2ccfa1d1b81e862ce13258db390f3f1628ec9513a2faa9079e332dabb047bb332eb59345adac5a27dd0a408c4d1e542a7511cc09666406f3c817aa512e1bcab72cf74cd968dbc78c4dc5162316c34c2fcb7c01c6a951263e7461eeb263a4dcf1dc27d6177b5af4400104e3c8f6e0bd61367fbda857e2d69b837f4f147a7f052172da5a3fed8ee685bd1b51a347db4cde1ca4f81d9f22f01a90bcef787691bffe6961585efa2ca4e70e55482483230a28cc0960a0d74100123f4bd269249a98bd6077227947b498fd559d4d508707f977cfc273f276a45d0ee1c2a3c3e12863948a3f0add0a2608e6ba21165dd9b084e386cdb5a3598b2c2f54a7eb5a39ad7e1f071fa193383f649920eb3edd2949073577272f88a0ebe9527fbffb7a3813950ebe7f5eee815dbdcfc7bc180a435d2e19b76eb60bf8189d3ff27233c2678c4c8973bd9189d1d3a6ff0f5d853f6733c7f476e199b4ba943898d9ee55b95889750294bfa3c7c105fc05037a268309751742b720fd6848595de5ef6fc79e1a7a7813c4a888a228c0f18fc4f4420fce25a2ac15933cfc41cbd0f2d7a43987c620934e1a6a12d220f1f1a2c049fc742521f96d3bdfe3b905e66ed7bc7f9bd24b461ce011417e980e3a6afc168a9b674717b657ad30a6233ad1014ef057fbe21fbc1eb33f0806eebbb15f24a644f504e06bd8bc91a2a19880f1da4aebfc8ff741579e6e4b066c559da281f099fa2c3e6ce0400dad848924309e5f49ab9831698666f509c3f171d7e84f149d6c080a96cd16961b21e231e91b4165bd34b9951cb507b16352c019c2e3e9a7b2f5aa70add2b2304596339279dfaeb81ca6fefd139815fdefa968a765773c331bae589afa8bddcf8aa619ffea34d76774f365432feb70aaf7d3c3d45ca650d03269e971d7e87dcd88075a09e145c7964245106d742c431ee5a178b9e6ddb0084a47f7ce668d99484bda1ecdba51f1b8f0193270bf202cee6401296f711373f17a23933395327c007600282087642645e1a19545605fbfa586a5b68dc9c57e3563c4428c463afc6cdcffd0e2788bcc1daabf589cebf24b4817d51e1d4ad81e92240995edf02ce965d4f9406d1cf64197484bdedaaa376ce96fc3c025a372a7625c5bbb027a4de4f139e9c10155c8ec1e7215f4dd7f62d26204602f0015e704b0b6d3f94806014e3f16e64c167e19beea7c43d7170ab16ab70086ef98e61454ce762543a0656b8d44c6c55445cbe8e992109022b173c365b3fab136f46b5faebded166e474b4a47281da093bd264cc92a978f7bb06ac0fdaabc67d7a7768dcaac2b6121d2c5dcb32e1010e7bb62942fcb3c771bfc776c8ab0a4c56d2de9a590ef53736e399178d3808cab1d306507b765b6725d99cfc8d62f0ac830ef2b40c54fdb21d7efd650f57e1a8de3f7b6a08d0c5140d4f444fe86beb85396170c353c518f335eeecc66277615996b53f16b822d8a1f6b46c8b125a3305a5274118aee26606de2b2cea55a82a2cc2f310708e727a30cd38f1bdc268bc3e77ef39304335229be3649c1946c67c222edc247609f495ae265fd9a21cde7b8f9aa59ee406510d81ac6529efba3e55a1a7a70b290fc5bd7487f678985c4f5e7d28bc4f474706672742f2248b55a8d1bbe4cd0b356a3c8668309b2296a2ffceae1f0393a83854cc72fe6a2ebdedf98e7dc8ac0d8a42d7b002723f0a0eaee50dbe5cfa20f04d4bc647c530fd3d9283f5d27f338a19b765a33c57b9e17ade4f968b92b6141ec3258617f1734060ed9b971f472c48d6448afd187f549558ec68bffe2d1764a5c2d3c3f1a8bceb0ae198c08e3fba005e69998fbbe12f6ac2bb12a9545f5cc9f895f24d0bbac7490e3d0dcad6d4761e46a2cbb1ec4296f94fc265012839000e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
