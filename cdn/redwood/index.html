<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ada310a771ce2ca16998c121511d4a50b93c8c5239c8e040d35090c7f71cdbe79fe91f702428a4001e4481a515191e5d02f22f5f8bffe5c74fc8ffd8a12bf63d0c50f1922926cd3f8ef5a6c024a22858a82393d4c831757f51aefb73bd94b9bc814b2cb018281c7a1b2b917a0512bead74990dcac14bbfc0228ba206037ba05195167228be1accc1d97d4d2c76fc2fc2277faf3caceb6d656faa5b71aaf70688e31609b48d7bc0ac9829ed151975ef2cd3db3032297d2522ff2cda0fffc0e3a262ac54a7201828e2ec2233fb6dfc3e8d2284c99b2768cbe6ec84937e2c9b12c38f2657c66fc81e10dd9b04b244d7242d9625f01188989d8f46066e1ad1471c19e4a1a688f7abc3e004f049b0911d5bbad16064cea8bd73d350f5b3d1abecfc4c18f04cfc03db6a555eaea05ae6104e1fc31836eb79925e84b82b3c0f48a4e7e416507214185432297c7cfd8905946d381da68f80313007babd01ee02ce3ea1db8759a71ce47eb896bdbc043ea17d95849e76bd70b15d4ed29db1df3d5ebeb38d045d0d1b9e1dc4569e4f0ea0f15a41739f7db4b38260b4a54a2793d779e832771336bab03019f0f0f53869a6c3bad6317eaed03f256b83a428222f282ee3e7751052fa2d000f8122a10075362f3bb48ff9033cda2dfe1edbd51b995df8ba2e0039b1f72fcc0c6de29f3d41c4258f16f7441cefad39f21f4a3231538e7acbcd4ebce05e84801aeb2e17ddf50e20bb5200136b4fa28333515465cf9011fedb2100432c423d3cab6425cf5153435308ccc10d9e7a16df5bd12d9e083fa12cc74ef9514c7de5bd66fbdf80d69ebe85830acf4cde5c077717cc6663460b239686e695c641d292ef5ba8d3fd362901cfed1284fc9cdaba092a46238b8740cc518d51ea48c6c62cd5528fe813ef3234c04cab44cb43189146955f4f7fa7903e41c56429a8f50bc930343b1eb31b9aa564a91edddf289e787b35a10d0174f51de6b106f0e1502e9a0a9941c057edae9baa1ef567401683309dc63249516278f304f48f01ff5427e9c678ec8454d74dc7b72fa30ce54ceebe1ea7b16cb0abeb574404ee84a35ba00ef1812bca1bbf6d8030dc845d42a7efda7dd6532550df31b465be6c46ea626d23a8427496503f4216f79ae025fc2121e42a65e6dd07f8d1df7002da729ddefaa86ddcb8b6afebf07a7363572cd8aa4a83d09359981e12c31e45d810ec6758cc136902dee6f0cae3b6e11f45cffca4eba0b53992c71a84d5715adaf06762fcccd2a7e34190d6f774208bd380eb4598e2aa39c75dfbe3efd878dedbd8e92b0828f7e4db293b18c0479ebfffe822db6c9fbc4141df16d700880ef7f96aa3e01b9e1c17103c5dc38fc73cfdeb995983f70138c51bb5e2945aa9f2a695474e88bf4ef7d15cfdff70d1d9179689a14f4c86482db29d7fd59dc1c1671d86e969ef44010f5c9d2575b161e091d9b4fdc2b5d17bd08de7476245d61264ee7339c6c8245f1d0aab274526dc81aa95ed4a56bf3fb5c287e32e3ab940d0c135b0a92a3ed362cd74839a34fa43701cc9779c50a1a02fa6d7328ff0b1dddae58b6c6f0e647842a8c468cb06acf8a288fcf07988f86925b5890060e8d7a70b08c3b225e977839270cc46bdae5cd6ae66793dd7da3c7d2c08a153ecdc25ec82fef2659e74021d73dc382780b30ec833931f5bffb8a2039301269a5d024bdcbe3285e7e4372a2dcfddd7a8aa4b15e823b59e31126135922ae5c47e16901e1aa153adae5053290b77299d8a57a8b5aef54e168068d96d7ce4dd1658bf393511b03ab79d2477a4f75112dd3079eb29b99456b7884339fdd3880f1ae805d106e5cfed679cf4ee86cc150d85cd07d38f4fe59a638f0ae45021b023a6c8a3c84803a42bd4786a4a93ee3b7f183b04890ce17e9955c97b231ce01ad76f2a2a69d73645b409e38bb06286f4295deabc43f08c47cfa2a1a77f2574e967e585b3547a47c84f0887397fe82ca207232b1e73656965c87999c4e855521336fa41b8f28df8d6452fadd1bc0573d3c8b02acfb1db73ef45a2ca9e01bee8d401704fab40586f873aef383c96e3e4b8fb3c972dc2da694da4ff9c5c11a958ea476a8d03965fdb9ce2674c52ae3299887285488fff4e54be853fa247aae8aa86de52236fd70f0786a0529ec1be5ac61eb3217d69c9269ed00d1d5991c5e8923dcc5995098b68bbba26c193581ccb12787aef63dbc89011acb2e55c8e6bd9f0b003d45a9f816a126ef553a0f5495e519e0ac397e96f648b011ce7cfb1e61461bc3e7e3e5230c1f4f065240083daf95254cb8e42bd676ff90f8fc5113d55b000e9f2e3f0a636be990976cfea20787939c3e7e011141d003d7a237442e8b419a0574c0b64ca547119af1cf5d25de1dfb13e66e2cfe1b423c13ef482925249b31e55d8e9e35867ab009154469f2dfd75fc019e4fe5052053be3e5567ba622df4d34593a2fdb66c3cf720dc24613519c2a58a3cfe34327a73b9046fbfd03de3fa3a48459562cec7f5209b9dff79df97f61bc71f815b3f16921a5bacb7b91f1c45ca33f2fcf5f46aef4683af7ff24fc883844163bdef9410046d3ecf1bf241dd04655c7d08d9a0cb5a79040575db44373b440491372714b764360bb65cca7a1155a2531fc0df7d2c4318bbd2546687e5571d0cd278fff63c03cbfc5d13d88b3de8381cae0cfcc098a8b48c7b5c3f349c642dc95c7b850b51306434685b4cfc178e2f34e36c104f4124f0b8ea3f8e9ae69c4aa567cc5ee8287e85ccbb53a7f9f71af1b859325458e31de1d458be6ee890c3507a740492bb4fde3112e72226da26d85c6440f4dacd3395587c2dcbe8910c6205da61130a74a1fb5920c50b196ce8d312f625ccf67e74df0af54e4057192d7ce94d418ff3d3e9cf3e0c7d5d9045764edaa04cbb0cc5d085420c57aceb7c78398c4c4c29bfdccee7c1d05dbb98106d2570db8c79421d6359dbf9b54c4da665f75d79a19fb7152891f4963759aa0581813c62a9bb6e7ac2c5ba76b4cbc7cb14e3a49dbe8b1d6a65e8895cbeb6a4cc687f305eca1bd39ae9b64bbde30ca2272a6b05c5da774d1f0c5bf21c0774de9d5d49c787fd05572b12986fd1e4f1366b69c19ab8f587231c60b84c0cf533d938cb11e0efd0521e3c503f971552ebfdcc3758865fe1335f365f1ecd255b56b965506ef75773597e530921df900523f1b7172021344cd51f0b8001d908d5aa27bf0cb35cd69407f94c482db722ec635f322d0158986d7003c49af7347d02d95a054e19bf5f573d88dfb767c1d4cd879929f331528108fe08b373b227104d2c6b5900f0a67590873b83da35bc91bc3bd824beca45dd64aa722c6dd38ca69104add86a323a6a178a6c19133a507baddc55c5cc10af2b212db733fb47ca68176f7811f00cb98f59191fa4599e9cb6de6cfa3ef81b593c72c05ac8b424108a1ad54221651d5ea5b4e75860373fe78dc4c54eef12ba05faa50ea7fee0769d2b8e76da0144e8e92dc841b3e119b3a153692caee883bebea08260cb30437e4111a68ba193f63bb80355e18e57c95ef6d8ca4a37a9c91ac8fe9330da0b24645c570bbed7ef812ae2482e0f53362570390bd78e549a55ec1af984456566a295c390a6d207861338897c1d5ade4c6a8d3bb35f364510a5a451c6770ddafa2edf4b2fe34448257bc660b1d2ccfe9e71b80e1c390532aec33447bc7c0e5a8b4814693094fd060932293d12915dd2f2af0d4ee7df834585e891996fdc4973b70fadfaf72bed77bc78e22d827092602654b1a852f4d42061aa9f39ef53475ecbe1471f3b2ae00e2084e7a571f642094b6e4ffef324d53df599eec1d2590993ea4727d9909b1cce8cdc20c8aab45970550874fbde24eeacbed5b1d35e69a08990fc5ddc7b08ce0e0beb3bd95086ef7c198d748419d19f477a9572f96e55f97c7d003c0ae8127fe81ad58a32e48e70deade66aa2113dcfe6731d36be3f3e6dbed1b52c830c9b2a2e69b5aaefb94dbe3c57ee9f45d6bf404897f7a27469d6dac78e8c987b218d16b7acecf3de67b84b9095f63599081cc0d06ce5a2dec8b8bee177a51b1ba5072bcf0aed57576b788d0571d2b9c9cbe149c573919ea401a329a2670cc54e42d132ae348d8420cd3ff56d223a54791c2689f6c300722c905ce739136018b79d8842d4fa73b6f24becd6970fcdf437fb177ac01740620e018416190958489fd7df768bc4d2489c034c2f96c29aeaf2e420221f5caa892ed6596e6a2411519d1f863f5424620b25cf3709222a38a857e49f0561bc294c3c289849381fdef1f03570b4d8f84c6804c4747bd6699039af3b6c30a439ac5b4ca304ceb8c1ad890c97d7b32ce461277cfa1f353ad73c6baf2da7c52b3cd111b1b855027346c93c7bfa5f4445e519f631c0bbae85185b2aa804fc53e11f53bff1b5ab1654daa2e40e51e11244668e850ca8f3b452dab8209918f067f741b20819ba8370ca2fcc9cefb6261ba5498c60e81eaf28c95f642750521790caaa60244baffa2a04bbd7c72710036a6fd05a9a49c5e4e40a719cbf78e505d92cef7856c3ecd2fc9d5287e223a4d65b3fbcb199a5883557ce34753c8393835c3196afff6f498d406464cee318fe972de1ddc6029101f269f314fdc86bed9a017e0c454b453eee792b00629d56e5dcd379fa966ffa87e3afc13281c9a9ac436e5d921e88136d47b1e0cc5f03695d0371898124e1cc778d4c76101e0b823bc2b5a5f90706a1c976c1fd8c67b78d59a62d2929319b925d0440f33c69131573e92b9949c517450f7b670701fed86e8887ec15e726eeb0674a098eb3642a53f7aa9dda073caa05938ebd55d30203a0b4c3fce078f2486b534abd6cb6534d1380121fc38c18cef12b8d51405d30494b187ffee627305d6cb9b7466418a412d35529a1bf746e1b3d5d8447c3187ed927535fa36782d55eca8047b18497a89a1f5c731d011d85a61a51531ab8469ffc86b4394cc79a92ff830d9c6c710620017959af10422b308af5a3b1beec6b5011582f947139e21d4e321f1ce061e9609d0ee3c9488c1796e8605173b027eb6087f1055e3cd340a4853950f5716031da0a65464e841508befba3a451d66a99be5cc0e41fb89a3eaeafcf4102dc97e0d4290923f4bd0bd3f17710c6a5193e0bc897cf8b2343bcbcd72b786dcee48a956dcd4084a75a3626f25a0033ecb514d3e9ab51e40b1cbb0b2bd40e52c23aa90679bfea0e5ffc650f458a04104f718bdba663305d85458c44f00a0afb4bd9c4705f830fe3da9244f94c8cb5584b9f0b17c39bb45bdeb1a5a6ca601b4a19d40cdd44f957103a33170481f76efe7f97f8b07680956859eb784740830c30421940eba3606caa0f0b5bf4d795323319448736a1b1046d4796dae6f90d9c685da209030224f52ca707586722826d571f3b44d0750be877bc0f826250fb096c71f7c51393ce69e9452600c53bb9d27197061e48be878e3cef859d8a188e30edf4711fa8e608b9f6179a6581630f515d131b77773bae70703de28d45b5bb3aa48f55c117ee6dc18c80307d5ccda175fc93ddcd474622e311b606966117edfc5529d4e99343048806629984192ac597562c85a4c02e804c21d322bd1106772c6c569637b625014a689713ab7a9b9a0955aec0ac338ef514dcd3226faa23755876baa1a4ce704ba5cc3e6483770f74127fbe86bc0589ac6f167728f844fd3b4de3919a75f23a00941b7bdc19c39a8cc7fe5fb061d84d8799dc2e68ededb735ee3a1f345931614aa7113892918a1286eb45793c1690b6c3861b75de1515d33df010ee32ae9d27433bc583eaa2f18e699e33725063e4716e514dad770f0db7f5fffb8d8e7953cfefd01471d0d26881a5dec59c5424f288b9045f37127e7f4aaf5b541dfd0d026ffc122d0467f79bee8d4b92003cbed6bfcdb9a05bbc2016c6124dfaad77094610f5c331dcb001c469979807ff9c53684797764b4db32cbf109be3c8b2c8db47e609c8f5dadc6d90e8130314e919c9bd8c71de74fb1776dfcac4d363428fef57b4d49bea0717a2bdffa09b8783056e33c36329c72137e950785d9930728d82fa2d84048fc66bc8d3feb363cf6cb0c3051933a7ed7dd9b4036482485b251b8dd9e64baabb40957e11321c5c22ca8b25e747fa4aa69296c5a0b5124d3d39aee36e60007601a8fe9259a38d2389032aa4ae97a13c77d81faeda1ddd2819a769f6b21bdfa482ffb3116fd7a5e05284f2719dd09f82369dcf927b4e99df9ecf24394fc9067cda9d6ee7bbd664656d9ba6dbb27dcf9e4675d5604163e5bd42f7194a58f33a9ea2a6dfba4b38ee7e5b59d60e89292b54e4f676855e6a5c5dcc22cb3bc958a8e7a8508a5731664be122de35996876a2b7f6ac7fdfeaf3b651b5cd2e37dc832b331fcb9913e838f9b85217aa0e6d6c2356255dce52ca29a43c4c730a5758e2ad4242a3e3cdc6e699db1371fce23b140ad6a1f2c9b23eb6ad04873b60c7e25e4b4f4b1ae880e6d32845c547bc471eff8d1cb1962a06b3480f2b0b36640d4ca4a9b985b2e03dac7520caa759f275a3d9a7d19496f22f57eab0812922901bc00e27e052553f5b801a382001dbf2f38e30bf3dc53a3106be26ff04fab14aa2f9dbe2dabc8c2e4479bfea92d5b05b5e73f6f183cde47ba3a951713a93b0c0612baa415b25a98b724e1f8924af3c0b121b8e02638eff70f559059e75fca0bdeecb6f3b6f341efb62837db17d265411ad1098e50e5a4d341851ff731dd8bb05378b95de77fd4f209b61d44b895f0833a54917f6992e2a3f7ce34cb5b6060302841a228d3ef749734e67128419eac2a5dc1a4b850c9fab399bda1e1295c22f66c90b90f4cd0234d79e6c02a5a6af6fd28282ffc131771aeed23bf5052b895ae774e9cff046a4433c7a0bd5c71d41b89f684dfd60f31757fe5b788c9428fb9c5107b446d39084f871c5aa95f17fd8c7136f84b8343ce78ee16f8113cb1231f49dd170497d5e44259d77229a4a6ad1659fed96d2424b465a1b09bc324b70b3b32b2aaa81d7815082ad66a4281fd60ff1b24f6552c5047563fe1cd5ee1eb3a311b684a22f51d523778cdd8c5e9691676497d1fc5094be989902b990beeef4d3fff817c90a78307ad8b347c32b93497342d7ff61a6cc4b0d4939a412baffc9eda3501a8a5a595a5a11d5e95e3c522abce7ffe09b7409c508a79e5d064cb4b2680241c2c2fe0ec1323075d2b8b3aa1aa7bb0022f36eb9cdf7f96b1f87e50fb8ce069477d6ee833e24693ba0ad402a6616488fee5d20fd6038d61006d5b6c535b34bde666ef332f13531e4666a0e830d5c0db4ab2a5c1340b210af2e9fcff1f32e4fd3278f268e72fb339e6fc512b88d9d028c5aa8e1020df34a1ca0ce0f7f740f4ff2cf3b568c4c72eaca693a89d027fe95fdfb5d8aed8ed5f0e50a71f144657aec8f0cdde79ae74ed2ac8adb0f207f2a82f233693b03d1bfe5dd9762a8127d3333ba90446f71aa46db764c731911c9920d4bb94153b61336a019c2763cb440de76d3cb16a6d71aee27fa38aed56c0ded71a94d26bd84ee0cbbedfaaa03c7d952c296d7751c4326df30cdbd3e8e6ab97bb8b558a0664bc5d17cb165967de53ecc7b0ec96f697ed44a90c5eada528d75807f1c041d16167df76087c7e456122d87dbd33916383eca92205f33c9e2e4f6a9d1530d05036a3cbf877d09a3d80f6df68029e219d89496ba5c6542aa7bc6e475ae71db2b7faf482d84e60c0b22c76dee5858618f5b6ce59d383a4eec526974551a91eba3896a1cfa911977b62d905f2093fbf7fc0085ea764cab47b778294495cad1dbf9e5be67d7fdb9f15f252cf06863c5ff73cd860207af729de3e12f0295b2b31f3be4d045dc7b2cf96a0434f45af12ca7811169a5a8b67f605a60ed08086621109286c641062bc98893255641a4a2f494efe39c9b905266d66579b1835d9e2c527e4d321f71dd84d2afc884221657ac886aa8adf29e1ae7da9a31dc46521a4b03f81f1ebb3209fc5f9fddfeef150f9bad00ff94bbe7bfcabb3ca15ee47d52cb0f2028c96ac4e37019324adbba2016bddd06af6bd932ee4ceeded412c1687a04be56353a773894b5bf7c6675f8eb338211ff60b000e26bf10738c187d4530aa4585fda4be2e59745f687220a30a25564e12f704cc65340a4b04836481c0f69c6044ee25c9fe04223d7d9cef90293c51c627738644f61abc81e3c227a5eb80c537848943554bf8f213d85fc32afc8db544d88af96e3b3fc55e8e64329e5b98c247ec170e7efe56e688248d63cf7887c9b938c20729a73cadd35a80fb39afa31958e054d49c22ec60288d23ff1dc3678a64594bb7f41b203ea3987b9df66f729a22c2fe436566fb4228765c419636b15cd1596d71e8c8899da457ca0a25686bb1f05a0737d5a8f8df30889c5cbe4cc940b26a1f1d5d816e7305ae0bb773c2d3893a1c151e996f30b373dd9e62d36521eb56ceae4af5419a3545ce545d244e11472c35c9e329e99aa53be74e64a12277529da0ec8d06604d827e21ceb79c568d3ccf8728707652fa38afa45a5697e9ea066b3b39f6698633ec32e7cdd9be4af416afee6f5daba850ac08fab54b350aff41f74878125d02a7868aa265a0f0a98453e7463fad029e417ed6c7488aeb073de605f4378df933aea65bd0c1bd9e190c2fe425db94a2345a9a6bd93dddedf3ad3ac985467151b18002f88c3cf59a824dc5ffa0c332496d5f95db74bff6e0a6b2cc8071053f3b693c92182ab25c121d9204e8252d2bfdb9a56d8d41152cbde3a82a6c51d8b5accab16b913780be0444d0d5f6eb9cae6954adf951a48865e04f3cbb1ec31abee5d3cfded8376bcdf1a611fab31da4c028491cbc6e8968e1ef9aa50d711de3ea6c4e98f46bff5780add373afaccd5e55cceda39c6f6ffd22a66fc41e01c273bc1019586007e898857546772a3b8be290f5c033e81486f168e6db9442abc2f5c7538ca1747f55eb70b87517b20bd5555e30f56c1f012f7318e7f961e8fe6761733a785baad50e4a47df3543ce910d67e9c50afcbe4f44f158677ee14a3ef65f8cd699f9fed361b8a997e64abcd11303a466fe23c63a4c785fbc6ffa806c046ece6f95ac7b6e484bb9061d48ee230747517c466e097a765ba116a87fb50a8a7aec32f23694707fc1437ac117271eb5ce8598e6cec12003772c7eb8ada0cc3123c62149fd6f7fd711181d1bbb5aeb233dfa9a2f4845c4c7cc23556e779aba0f32066bd7c4bc70e86061b5aa122553af860f816c72ca3754decebf5008162633cde5005194739b617f88dce60c41212a7c4c509ad3541c4abc4ef05783eee649ba6ba662e0eca216e568e80049f157ed7b616920f93d438d68a49276a36b80812aa348d0f46c9ce5a61b4c3e9909b4e0b8427076cfc0ff2af6b16c951bfb4c12e372b0b472ad87669bd535524b7168341424f75cd2644a283e7b3e19b86c89b8dc75165603da1426797d5bf13061c9963e872541236173efacf6cd5d6dc68d581c2cf7073b403b56fd82029ac26c454efc8e7662a993604f48124a9118c4a49e16df0a3af8dba84aa00856339ab5decf8d97f24076e16ff2d547ad4a1306cf62a87107217c1b75696e31eb3e3bb1d8f8b724557a340a4396af9bd4a3db17ddddc358c8329067ac659a5de540836cb7c3b56b6a05c253d7ded825a398175a9f16efc75baf6e167ec18dff6506526f764d0628ed320764da17a28606c843652ad04abe84260f326e1b5e60e28bfb8b8054064438658d95c2bf730e7fa22e5e0d2ac263cb7aea7c92f842d22c18a97f07f939ebb9024365e40ebb476ac143242a10bcf2f4f0ffe12df92f481764c917cdfa60b0e5d278cb95673f7cfcfbf9378bc111aa969cd5d368fe376c30158bd90784b04bdb746de2e01a13cefc54ec4bfced74d3cfaf2eaf3503e7b70ad619ffe2b3a1047525e23529125b3c98e7aa08861702b158301eae76e8e7905c4d48ee34ea7ac9dba41f495b0e3e1305505b4ce3a5771d7b20595b9a38b5232c184162d67e90ce102492240b146e12bb8e274e41cba6fc78da64cb2f089a17f863f1f5d040687892bbbf9e41b3ca0f4bea5aa45dc6d950d428e418c6cfd4d48d0296b89ed1821d5062a55b85501523633af725936c0aa18dbad9379d848a49d79f350f277aa34e456fb3d3c5e84ae6672d8c7c7b565a069831257fc0fbb44dde8bb9974d742c56ad52ea88f312822cd6fb4bae13d4fa455d2f7fca9209ecdde8e8f5d1df5a437b64bf0dad4a233e2a0e270ea07d783ac28272bad33ebe8087d3ac9712b5b3658c4e9942c7383a99cace88d1359909cfc708c6ca942bd374e10792a41767863735d998ab959b5749ae19e3928338e55316757db5918f4d1e00fe05fca2b937a052fffc48921d2389bdfd71664232e96452af17b395603591dbe48b233e25e80fef0746d9755afd8dde6ed2d648263badb61ed43489d5884f801053bc213da4a4ef8c01eba3b01f9c4c667df554a9a2ebdf3da28e75ef28ce52a9d1e803c392661a90f4d0b674e46b1097867b7a8aa2423a47765ea86e5e3379e6ef12c31060f8d6036669cb39df8868d06525983c0dc8654cab8f67ebcc532bd0adfc9d0d02b2a9e2bdcefc9603b25eff963340c8a6fc22d949c4c8e6a0d4fa13bcd022660efda1ccd3f3c00c74554cb792b02947982022cc4f1065a29c5cf957aa681a38515daeb4b893524196897bf6e3b9e0061966ca7c00aa07c9fbfc16e1f5f189acaca92da90f00638fa72d7c080e2deb17d08e0485838d3f7877477dbb74f6234ae4ff3c5965fd05d17b9f19c460efd275ace1d74b748c9d4838d1acede123d80780cef5afda60dd336e8f333d221276973a6e5cdb4f14e74cecdcf2ea5c346b6bc77129077ed73d3dc95720108e53b9c3c17334344acbfcc8c8348b189b8851109558a61a5a6fafa3b0ffba66c0445aff7c61156965468082f0fab3a62be40633d5aca526add8176a20c3dc4453ae6d7327cea44febebef65fddd320eeea0f3fc07d3f09830eed25cbed299ad6b8155d5d5f69dfc18680a9e3b3da5fbdcd1e81345aff6c7c8b551c3504ac7203730d1e232a52d1578fbd84738a7f2b4d554cf48c5513633490cb98be03429b0b034d3e2bd0c8ef571f602b6e0a3ddc7c2851cf6ea67cd2c3c72e94d207618aefa1f284819a091a86a666aa012ecbfab47eb053425bab84eb4e09a061e05d7eba8a07e709be1e2f9a1935d3deafe1cfc9a6655e32116604ffc769744d52c83ca0b8d65793bbcfdbd1f19af42255272c6aa2cfcb1b7290e1eb7cc9d746db7c19acded27478980a5d41b3a0a29a9750566f07a2a15de842a252f8e91a5ae22bc7b19c3d16b20eec1cd24fda3b45e144221dc5251fd3d426744d96c023416fcb40b606686581ae06e617ab8d646da0fd54552b38f2e6f2f92f624f326654e2e1279dddfcddb7ea2c288e63504b2f56b161e41536e8d410f34f7cbe0a5a6e4f471f47ecad881463e7c82ce157d00ff1d3e66017f08182b2a18551dd81c463f931baca586dd88720bdcffb6c7b8dc21d2690caecaf0809a6cdf6b779f93344aa5a038427ab8c55da298577db986056429bf5439d08fbfcf6193a1184e0b1d9d4461dadf5ab95f9501b9fa0246a5f84e524ea6c9687b49337ac0a0821e0e7dd9881bc21cf9dacca731614fe91dec778359607d800393d9c8934927c20c493af667e04c86162030c9aa344478988d0062dc3d79024f8f7435f1e2ac7f024174357a17847a555c2e8600d04b18b3721f88c38757e2c2827370d00526163ac478141e2f77e807d893b1faa542649c31b3588f5c82f37f397b6896dd0daebfc5a34cd9762375b7a9f03d1330ce20c1ef1769dfbf2185025e6d9316c50349fa5d11ba9ae69a37282018e12e630b6863fcd7a02494632018bc77fdc92f9989e4b5a346158c7346940b1c889d3c7237616991be68008b86ac5bd89f189b7849acedd16c99af55fa2ac6a998e154d59149b945a85af3e6b5ac840834ee4933c4e98bcb2ad462162bb24d73a2ccc6de6adb864e87a66ee5583a6a60252e4ed02d51bb0c78dff9856c45c62e308deddb2532901b6e1f32aecd7662ee88663c846c99c90289345724a033d98a943a59505fd493893b6cdbbba9683b6e1b30ba3ce5eab7413fe1b421c1d562a56f227b084bb19b1da7a97c07fd20dead1e2f75c96ba9c36197a6120cf7e9bf7a3964a69b469e39e76bdc4468fea94cbe92b666ee96a2eab2d16ae4cbe7fc0d3dab25e0942714d6c684f0303f0ae47bfc855f2e1669b0f1753a130bdcaf4c0d18135eb07d0a2ebe7212640f1af24a19c1843b33641685a57aed5efa3f477859e0fd2e4df0439a462725f4ae09f1867e1f6342ead32fe0a0cba639289b303e0da0f345ea00cc4642fd34efcc893554fd75e85886e8d922a33e486ef14646427ecfc235ab6f8635f5cb409f01f49643c03bb826d8cc2bcad980632ea9602c5575fa07ee9b1619238e769aacbee78620f9703c49c167f677345c5edc820918b3bc46b7d5e8bb4d54cc947ed95f6828c94346e74caea8d7a90642ed0702fc6ebc282eb62d0293884e7c951fb9a7f536bddd5862f4ce58b902b3fb491b03bc9dc354d000a8370c8cdbe4ec52500bb5d7be6142a7da9b847d83f6d4db668920ff7a57a94c43d584b855dc337303969483931e12d810f6e25615ffd056d3d2800ee0fe783533e50d4ef667e3b1fae769bcf0718e119813649bfbd7a2d7ec12660e1d10f4a3055c27e758c03023912f8781cf39c8022a030fe69a0785fb6b0db5f0f790040ae2adc9f351c781acfa908b8ff08c1831d81f2c24e3e16aa2f949d3191bcbf0f2815acf352bbd1f3e6c84ba6188b26d9d71e6f9ec1840d2bfdd3f7df66476a732eb0be81adaa1349744a8c78a3a120c39a3e3ca6925cffeb3c7d40560189c6bbed24bef8e94f021705932a392acfb40b036acc3687a89776ca320db7a2675de379bbd19730f0694416f26e7f44161a967c1d21d068c3c487b7dfc7792204bb3f15b0da714a42d10f90826516e5ab27894c56f4c3687aedc57590fa9eb396e22a525f0ab458c24e19cfb835eaf0e521535105d46e14012f09217e094ce5b163ccbe8363313e3961f76366a7c9dc0adc2bccafeace38349131fe23112d30451de5ad12d9673fe743f8159b6a667744aa9d7c306a5a1c0c60df33b0bfdfacf3d7b4ff7e17bfa8e490e404a1602cd14e85a31e063bb2cf77cdb1eb9d4bbfb57e868d574a840579a8876fca42104ef7836f5fbc1221e6af813ff3a4678a318086b052b797b57f3cbe440a5581d5913832a4cabfedb1c8908c11b725b088c35f0a7f9f61a6ab963e4d29c2d5d294dfdb4823901d502591df90879357d2b4ed4cd5f2f12a5432db2c1e0385786669c3ad3e70c71c6032bc8b5a4f0ccf35901f798078ab4fbd79f705925496a3bca406f2d81e8b962b21d4c8f8dbcd7ce7c7bcb2761e9dc8360b4e57f6978983eec9a0cbf3bd31cc8ee512fd157e0d619095f9ea031af60704566982fe3574872b73003b06e656de18d9b61160404e170af5c625b13f856975cce2a1a1a600cf5b991a85237cab0964abdd967f34bb4ef1108b433a8ffebe7c4949b407d6b8db0512cdec043bfc464eeb630f4926707f977e2b6537470b95790c8dd89084912b75c2dad02fc9f747e7cb4a15feab63a5d9b03554285efdf667c90558491bf642537f5364426f006c2ec4ad44b86ec1dca1241e70328734783a5cfbc037fdfea65d26a386f664287a051c6c7c381f38984b001c1e5d8efb9ee6fc262706ee809eb8de3a61ade14aa0a380329333fb1cbe38b2e6984cc85e3adb9068d06222c263360cc5f22744fece89a520e153f74406516e7cbe3406cf6cc265a8faa65a5abda144307b720fd22d2a8830e3df21f5d9d941d96a47585ea0dadfa107b0c3c64a22d9a8a81b1768fb149ac851166d45ef889a6b286a06ec9902b73d8170b14026709627c3c634fcef8266759bd53cc9d6ee38a682ca59bad88b7ed635214dedb5d0354df129a8c429d3cf7e818786d8d543c8ed5793883c1fb8c523e588be0c30592b3e7da01e25f9e641b8b033f8db39bc20d5c9ea96fa31416301e0ee810b2ee6d424dba9195cf1574169b296316e21ed019ff25ac1aff2732a1fdd210bae566c0882b7d8536d38d34fb8303158125fa575d570080043c27ac8eb112a68d271174b1069a50a4205985e9fdd57dcd7329335316c70ce9b3d81d0be5448e1e7b1526b8ed7a049dc628c00b88454dc931c746325df8d7a0b7a2aa9b73deb0e6a851b709e0057259d87d3e4e0b8e01303f48b279d80bcbf9f467e8d8673c56f713ba3ca6cd7ff22cb914848f2a562db5af32de4eafae645fa65d87024b14795099336ded8d7d9adef948db15f92c7c7ded9bc0fa96791c8ec1cb83feb44edbc44fbd6676228b2df31a67cb4becaf6de98a5f0e5df49115c0f7b165a37c0d25eaebbc0d967bd0da91b44cb593554a5ff65f1c64d9fa041f2baead1cf4103eddc43bf482725af8d66a04eb5a845de781ff87dede2a5360e26169571deb4a4eac5ea0686efa7c52042694de1e8bf6547d06ad500267b8326262d23879b98fed61a878073538057cc50ef62ddde149642e2d378b5cf0fa7cb6f401ee4e940b3b1cac7b6df1dba0564b3a26a6651371245acfc385230042d84361c953fa628de7b2f34ad408c41aa71c412ef311c692d06855c40a27aacb1cb357e636355ef1e82d5c0ef958859bb383f39c42809fdc72766f5f49664136e625de55b418f2d0b62588cd6e67f0dba1be2e6a8479c2da0eaff53ad264c06304af4e594e82df6b9014d7d6da72f69398a3dad14e3da80b7a50cff074ec5d909d96dc37c4ba00f947e1f036282b12a173097f6e07046a4266b57c9a5970063a79b206a705e816ee5f028fd8159d2e28bb59bcb787c7c88649ff9d154dd1739279c4a3ee2c1382073e4dc57b1d24bd9615810c04de1ac7a7e4c8f7e7ec9bcad1b3d077133be30f5b2d383260b6d1beb5a89409bd629aac46c92ece31e62779f37848c713a7651eb582e904343e752c62b2cbff347262b1848a342f87cf8773c61e4061536e973c3b5c46cd573db8e4376b7b505f97a8820556fcc787c66d32594a05f4b1f1882c9e175b67944465c80bab4339209d8939353ad920fbab9fce33cbbf1001e0e615a68792dcda9260cb168aed360bd545db16a1ba0e97a151cea6621cb80f889ef8ef0943cb22001e8d11795e2f88479004ddbcfa261e0993e928fa697b935882463f330f0a96bbf3a2714568691f7880aa1c77526b1c8e1c6140528ff310b1608b8f9e5941b52bc98087509401c49b873737f2426d1740c8d0c51669283839698def0f7fd3a5b3ff0eecc5bbc1e074a0207e949ff0d6e1bcf44c74b898b1a1b1d316fc183bd0239228c380a4f659b3f865932473c3d5a873bddd244f4971de3aa510c90a549fca69e3c5a1532df36ded77ef201423a740ea774dc7a579afa9ec7853d4f589a6d001ab697a0fbbf98a62938a3191e9f62e10c9dd5b239c1d11e7f6203487cd4eb69e2ebf05ba094879625ebad1716c0177b04e22e765bd8692243031b5a9c776a1569a65a2c319772122ea3a178a19762818af16f13dcf06ede14325cacc3c90243cbe3e5424681bc5929e1cf6b0683327d4a60bf9128e69abf46fa4905f2862ea63ef5cf2816c8b1be4e7752e0170074eba2064b4b3af8fb0b423e097fab784b247a5b6442906b6dba45bde1a6cd10e0c8a6defa288a5d5ba0231ff9f7540d944bf77086e293384f3a28866657ed8bd56ae6b386fc0e0bef444db3e15dfa0f71a01428ad8ab6a20783ed3f7e97ae2706f76ec26c9f6a36a6cd1f24a5dce70f9468864709bceadcd53b218985e47c4862d89d28eb47a84f812e01b1118eb44fe03fc849b7b585a3414aa087912de9d7c861d7364f1fbf6a3466e83defd50657288d0b4ff9442412271467076ebe1e2e5020479b6826353ac7e5dd4d8d57d29e1a567f29c10413d3f83b80c744d308de94e4e1884e3193fab5f21bef7bf671fa9863a67aa8868a584b9791c7a77e338cf2723f530aec3a1137732b203cd68cf9d1bf727cab359b86d3a39cd9bced199d65691321808f71aaab0238dd2af7c3ab65aedf792f1c7a8de4b3f438b6198195a2126f8b3b83f746df770d9060bbd4fe9fa0f793b39a1344f590dcfa74a5d33921f56e5a34539fce946cfe82771a5f7d93fcfa1a6d15a4154bf53a59f2ae8689443816635beb218ef6e11f4e04c239900ce131e790ed028bb1137dd398600b961f8cfb57b37f0e12097c3f2d1130915c5216594b27383386b274165d5b4c11273ecaa429d101b799470705cbc1aa20b86959f941116cfc4d7c501942bb2a3e8f59e866775ace44ef2ccfa931a7c88587df138296d8edfb078671a80f743d721f5b52543a5593549e8986b8dc8bcf3f2aa3e38fbf519cbe3ace010925b2cb559b1b91266b38c5137c17b4c6e06bb94456d838a595c9df3368169340b569ef3135b919d70f3e8d97c45eba08923c536d4796065050ea1ae4af714edf8481fd77f712517852099bf09ef40ed81e908dbc541ad9bb2a601b83717fc433468ef15ca644f6303fd7ce9f40155b59394d82ac1d8a7f688c4af9ec33ef0c1ad00912a2e7a67b8d790f89f5a5bbb921a6b01062a3904ecdd35b185caba58e16a3b0ff3301c646a73834cbecdd04389200ce8050fff411008e6ece6578e8cef3f03b5b930b8aca4b560ef543d166734b48d9ffeb230b7340ae42d3d39ec25adbb7d2397ae470d036baafa38d62f71a1f86277e94e1bf619a6227f163a1d219cf6667483625d26fdfa00ec945e02510c7ab4a711fbecc555ef518b5c887641f7dcd9cdff9d5fb5a246e2f5a0df6642a56ff080888cc03ed309b5d3b7eb29aaa0b12004eb12ae4799b195ab950466c3e6ac49e6ce50dbff911789278b572b6090306538ba6e3f904b160a29c1e137652630431878477d755fb4685bf370455205e7a7be1adf29fb1fba77f205d68c2f31a4ab46bd32a6394e05f93ef76d24e65c331c6f7ff06939f5f5ea54c2f81abccc98b251491b87557c93b95e6015662cee33d3fa737ab214d2a3276299802d6f920f243dc739c7e7635182bc68973820b63c2a2c4a8ef7b52e011cda627f7c3056ba2e3c30f71a3066691c77c29c1e5d335a0728ed404b75a0b1d4bad002772fbbfc114109a400e8dcd16d56f079b61d3a1ac35696a334e185878c2eecd055827e90c00625929ff0928bbdc4fade02d199eaa73d9107d93a2a1770509091e45e9b352da450a108837f65b739058941f05a2f21df7359ce335c03b3170b49ea2b2e1e7629b06b35cc85966a676b068bbf3dbce04ecbc36fbda4388379abb87922c0a188a415817bcec91b7a58deb7d3462a76cd44bcdadf9fdba62b4b70e1660618e972e6fe9a18d6a6d307f3cc0110304203672aca0706c5d3d4d2dc1c783b9fc53fe9fd2ea61b827cd81506cf0c06a32abe08c568007253d7bfd789dfb81b611b7287ea6805590bfd3205ce2cf459310cbf3e9350701749fca55f252e367e2289d481b7bea9b1f87531643c1015a98cc8c2d17af5f06f10fd137a03b47e8920d8ccd31c535e0decfc62a61e90c31c2a6195870eeba0f0d626e63d896c3a447931f91433adc92c77e9f0853295e483118fa23a8aed67a6a17632de34610200fcb8597f3ef950f98af37cee7fcedbd36033fd3e613762474d1595129ed07db739752c841adfd1803e7b79cc01e4ea1cf4ba77037c3c543e7929f6df2f5b13030f13d682b473d4c922ce4415c57fb77c6089096153dde81cc340cf287d83f878053394815d57ab38b85affc944f1bdc56e917c92c1da41cc0c561d2659baafccdb3059f96eeca419243d24a05d9d8308f71fd7edcb52015dd6e717b55611500abe5a0d98159ab6f7191","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
