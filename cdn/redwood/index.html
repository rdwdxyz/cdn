<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"613d337b454e264e96f2b5ae613d106d85ca66e96ba2064196d988455d56e2e59ce83b2a10bc5743066c5d2aa7ebd106172cd5af3bbe6b64fd136d4b0c209fd7eeb4b2693f275ae797696776fbe36c51bc939bdbbf5088d2995d8313742ad87055dc1ccd186bc925621029f8e6022986b0880b9b293cb1a40b4657c4ea5a095c30f91101c5c573017b01d48b2f2b97255b444b2a1d7eab77b5071c1dce45b7e7415dcbd9aebb0f967656d8a0004ed75e75f41256f789995712880c551bea38fc6cd4ad8c571a558851caf6ef5148b1cb140d782778c650545386436848dff3857a94e053fe7b486aa35168be6613aa3a1d34f563b47ae5667d2187f1bbcd5c59fcc57620418512342b9216d4c54bee2055c17609593b703521c32e7fffa92ce6422656eb96aefc351d48e5c6564360d608dd2a87ef9be9855369ae0eb37553b4e2155cf60dc00dbce501e79211f8b55e2e0e909d75b60634ad82f9bf891efa06f4a3a8e2d931cd128d3bd776f25a9b68713ec7d04ea42268b47bea45a4a50fd309decd41a57c73d4252c2427eadc122e288ccf03b6551ef6e35d08036e2b6a800258e711581fabbe69eaa4cc0d764ad9bf995df2848d762f4c92e0a217cdbf636d93a52b635ba4c8c4b29435bdaff8aa70899bb523ba6957de0f6027603096e075daa5be1c1fbddd71303e0ca25cbac04c5d480add611586f3511c7a136c3211fe92f2b98b1bdc6a8cc77343097f6305b9c45f7aa32d90075bee1f6171bb540ea27e00a6b327a0051a45902e3486c5b24604d61e4f93bfdbf6079e53eae0b952a4729b9bcae80b98aa5414485036bdc3ded093543061ffc67d7a2c1f1863b0ce86558cf501d57e81818f1ebc5ff9c6d86e533e0dbc26f4e84891267d1e9c1abdf18ffc55fe011b7cd6c19ee23c109da31f89c48f5fee80d4af52f0974780d243f290c08d064127493a7a4097f1c1ce961621c09fb565e0de471646626cbe1c0ec22717e0e428a24be9bcb85bf07e197a5cc4e5090fcd11924449b8df68cbb5652db50b00346083b02885acc7358edc9f6b37a1434e9f3040f9b68e9d718858ab3cabc8e9b8ca730ee4ccb409b9a7dbed30c4e7a23ede3986ed9d06199b94a56439cb290aa0e5e076b2247096a3acb1ea3001fb4cb37a3b971b1fbba860e4b09676fdb49dc09f8c5383a1a249a72dfa2059c6f2ac27aee30ab34a01b2b944c27b87a17a8a859a6a7d93cd4b84beb01388812eda8f8e6250b1ddd2d27d2f518968ee780669935362e1f36d3ba83a5aa66cec7917baebb727c893838cf6db07274733417ac82e195652123308d8949d3a2b568459d861793acc8dc0060107248755ee7bc94fdda516b8528a6e954134e2c5a8aca5d6e5352d88eac7aa53426dd3e224d4f4339ee6d619419e65ed3e4914d6eeef6c8ef59223ababedfeedcfe497c5ee248b55f09edb05f6c0f7dd69e902c9762c65aeebb362710f11ba381bd82cd50020c351621123bd9e6301bb73defe76b3fac3867a15366111f632a6c85134c39d3e8b4f79693a7706d15efc497c40cc04c442c676a95d1968183d6985eecaa10572a09578493b24e18d5e99056945447b02432268fc327893cebbd4b2a6b91be684cc67fe03e2824e411adb29bc320433429082886349fef8127bec6665e1806b7ce88ec9c1d8ab3a08bfa30f70849d3ec2c1b9294a9cace8876dc60f995bec4c57112c59cfce633e398f37299531d4b32d066ee14487aa52190b989bc58825ba45566ebba63b97bc678ee93e3448d22f11888d3b0db51611722914725fadb00d111d1da8c3f04c701719380d4497a65589405a7a78bcf8b81829fa0169962e89f028d1d94378fc7058744552d8480eb9e908080bc7f2a1ccd8e19415bfb4ea5022fada8ca81302f7e023288f7cb20d6cf87f9254aad9cbe94d2e0bf528b29e6570881ce5103564d1a6bc47edee84bc5f6a7f66f49c657d45b4d9e833c3ee06f57aec92441f79aa833888445d0680fdb5163a1ba4d6f72a0efd3b96c24f80c7d89242167eb8b932e39507f29d802c81da2d45b10825605842cdf92e4ee475302b36cee02d18ac5eb593b3e91829fc2dbf4921510006f71084dcad702efd87de07cc7d1705130758df9dd08f034dc3638afd241b88da14b2d02f939d7f934ffb97b0f87e713edab758e39588a215035b3ca2fba498bcb888d4e35dfa9db7e2de26910edf1cc688dcfa72e246722c7e6d004399225233aa54cc41b50b4845e25b88054543d784655097040223f10d5dc71c9d0f0064a8b1fbab95f012f2f439e4afcd4f1d28cc38251d464d6182b8a9184359b51126e51573fab6229b604cc9e96ce911219f0cb4ce3f82c1cf9a2a3c7bed53723fde0f23261aaea3d95b37624d78dfd148919a77bb8538cc54cc7f985d27d8945945b688edb9c8aa9b4d22b298ef049e9b2978272d52095a113bdea6381d2e62f97035af728fa414aeffa44593cdfb1ba7e5bbbcd81e60471fb9d5bdfeda2db396c575162be16c5fb2f4c010fd199fb68ef8e0fdeda3a485c8d11ce097d82f056d4d8d1f1ec80c8d1497e088b360cdd64538cb3446c64939bd879786f830898b232e0ce4d5afa44bdbf18c31523e72e84714c93de5c59d7b6a26964be752fc3ba80f19cee5eed529c39aa150b004082375a904cff6f3398474f28ed1e6bfc57f3fc55be6b9c5197255d3fe925c7f6b810030441666749b7f67a61162afaa48314b6813138b88a35034e9c27617d9a9000a6c7d3a259034efc68cdb474b7f76183712422ad12eba291c255365ae1f5ba20fcc71019c9cfd65391032c4a222c611792114465d69767d08fb28d30fbe08ed0a15e5b1fd47abd261b9822c734c2894da126ecbe678698e8e6e9e5ea737fbc766c32bbb54dfa1062df45eeb01d7de031cf3743b931d850a9abc441a0b23f27cda288a95237ca57ff22a121e2a4a3dbd8cfd70bf9a727da8916c273b8411ab4788385d6250bbcec5c755e155f85551abd6d265318f111004d1c68a2994e664067baabd2324f0d097665cb073fe8ee6d21679144b36b4d0b698c7fe98699c6ff5df31c301945867df81cdc668ca5a285689303de509de149b3bb3f269ec0ff4644c3e542448293e84e6496764ff44a3fb28f87c483e2b63c160037f64dd9d4f0cb11aca2e3e01cd0df859b5d5858257b8788b5b1316f7dd6d2f4d4777aa492f828b59db13300c08b366f2c7a7dedf3c9fd0b97d38321aa1363749e36ad7c70464b629a9d52786affaad6c746b201042f128c0c477f4b900ef138bc0477b2e41d877b0c5e30c9b88e5c3203c11051c3fc84cfed228989bf2fd1323b32460858f9148490816a3af1cd245f49bc2de3c7ff4350f2ef3964e7b0937e0185a28aa9ecb55bec8cfdefbe2b750a42599b7eee21ab4c02357302e044c0a59ea4e91e22e07e568dbece093a73964ce1ac30ba0d686e6e7ba58344e5a68d56c64f6af4b1592d0c1a50763fa7d68bcbe6a06ebe5a757ffa4a0ce68b9b8e433cf7237a3771c3bfd44a929062b47418d70567810e8f7742933bc9e6e3986099c6d97011150bb56fdfea22156cd60c84d6ab35e50944edc576a1ac5f8250a62daac8d07fb8215fd27564f367ec3a330401e8db0245ccc175f386b968591218f1483ef645d4652affa3a2baaa9b7e4ac4b2026b3ada040e232e4dba5a826fd30c2dcc232ef8419f512890b5e4f6dcedd429a065608108bef29eb8ebec549bcfc6d83cf2ff39b5804d700f786e2ba294deba6da8e17d8e0a5c7847a40c00895387f13c9428c1e7a1b5895716563f53917013bb1359c8cc6a0cc6da1e97cda90c35c01515e81528c6ff9d989ccacb7668e61786ec6cdf736e74c6e1cc54aba368d77b68676caad3bc249b3cb9ac63e3d6ffda5810ef7d8f8e7b8d08d0bc562e8731a3071b93a62a93872cd4637fb7c776cd3578ee29e9b1e2030f42d0670bf671bc2b120a7a4ec3b8914493a5ac0f74a569e5701c8607f209922711c2f68126657e1fe6c90136375f42c75b8c41c61ea25d2dd7b662c5a797d145b38845557bccf280d91d77c6661792876253978058ade4f214914933fc7ac99b89727a52a86102a2482ff9588386630cfac7c3346546ca102ea72833821d3e2f6a3aae26530d16897bfc7e431dbd1a23b14bf7e2c34f7f124861b843f1eab1bc6204e548002ec7a74204e884185c96839c2289f150490743d2a792d4d5edff70b1bdece38a1e21ee6c4e18a894ccf95d52e8149f6574a66a9441695fd7021cbcc2d6b8b90b004e3a8204e988e7a56d69fa77df903995e1fe9613365750c4322c9a5d7242b0f30751d26f6efaaaaf3092cb01e74704fecc16890914b949e924b60786f8bd4b0dde65d598ed28b1cea7418776c45aeb36f23a50f436885893388d0abadb5de77782c3e1edda74b635ece57b4b7b7dadde1ad77e602644196b91e54a42e3e8888836225ba009585ae68e25392fac673e103e0d9a19bb8e4060b39723af1e59f931c0611391df126408bdbbe71766fd6beedd922a2ea93142fe72fda7916aa7de5b1ad29c0b5290e11085360b4a7a3abcb699906d8fb5e864e4e11bb065d66127fc185a93cac4dbcdf541409e726638440fb013b769c396bda06b51307e14d5e7f9ab646a67306c3b042673998ec678863e8c8387134fa3ac27bedc85d5a1082ead479457a167524394512c816e75b2771bade1e4f1729a138c7dd07dd54aae0a03bdf830b2329b2961297e2715a3f12c8dfd632fbc291e2bf8088024b1fedbdeffee7f710f7cb28f8ac1baeced72b57e12d6253d2033cf4e4aa12021fbb3a2e9780a52d4d25e73144a04c5027abf7dbb56978e3c3df5756ffa2a07e8673338c51be1224b311deca86b104b961b5458a22ed761a79909547fd4a7829d9bb857395e9e28973dfe7c8f4079fb11c86234fa0c066765e442b34dc2f8764cf4288b5abb236a72b6720e288410c12b199975905b9e7f55bb34d2fac5a9892b560670d3d08418493e0e35a2e7b5d54daffb0b496fe7cbb5c0f7c3a892ba900c883d9090738ee030ff0b1c39d3a12f8a1dd89813b197eff0066b87904be4dca9e65c7fc786ae48900c189b67766596d8c7c4bfcf395c5029bdc73c51a509b6d97db055e52a0a3b1ae2fd8e2776bf6f390cb61f3100b55f2d468c996cf6693e79171db86a535431d96712b113abc786b12386a4b086c018f4863da3da6aeab3cc5553709a4cbfa36c6fc05505a6820c278f1232d05092d0d053352ba70a57db2987e8ec36b0f3cf8d504672e612c3d6793e21eb2c248818c5d8fb1c0e180be0423eca9429404f328a17e15ccf48e7e4884b39351653e9348a8014395e86eb48ce3f1933a58ed76d035c22c889fe324521b4cf3e638524b824501b70a3d6ffcb61bfc18bfe42a71607bc04f591a3c7a0373b583b6ccb94aa15962f24adda8b85719431e824e4640b8e2c5d98848415f3baa9e6d5e79bcb99e2ed98a26b6409173e3c5c02ae0f2e53b5d669325a0bb69464b945f0cd07a5da298036847beee647e94804a4e7e6cca0f383e32f4a959d4c43acff951af2068ee2ab63cb60b24f4dd10fddb0245cd0388e2e683fd985c8d9b76f8cd37208203867feacaa6f9492d9b954af8722076dcaab82a24831e44bc26c0271a79eb2014726c0fcad1717ca02922f65ec0382a4435fc8574f77657e8e9891e13ae25adf2ddd504914c27ed0153aaf589d4c1548be43dd0e82d843d0ee96445fa6332d0756a6817773d92964f6073d981c20dad9e29296dc1fb36fe9b9729cd49a416ffd2a182ab6ce2e69358d987a5e7aa1c079c04a8e4ea063be95831f24f77f5c131ec57f810bbfc9c281686bb1732dc47ec3b81bc4bd770e89ca49dbde3480475b370964a385102899a99b6c8bf90e93be720b4115dc862a610d04654f1999eb0c4231032d8790f4dbfae4b13cdfcee2e0d79d79e464d508bc42d3c2a6d21c381774d53e08e3c1ea024150a9a086600163cb2c9b80e076f8532f81a7caa4db16ea845305fe05e373aec33be8db248fb91843678e5a9bbc8bba65a866c7d1d278503142529f35e6bba6fe3adc344158f2b600ae65a5939f43f2ecab6a28afc99e626b99d0c46f8507b656acb239d03d41b4d63536aab6a1deba1fec080e796df71e1b29c77ff58937026ec2ea753bfdce8e3d65834b266bc589ae90206dcc26d949e30909f5c6bf6f29bd6742d2be9624a84d3052d397e286bfb006ed8da5a54bcfe88f16dc5bbedfa041d4104ee3ef09917ddd8fbe14e96eb9e515c440485dc7cf6bb30ba218e0a19e213ce02acf93f1357f5a9ce71c33131f0287a45c692e490878dc2a5b8a9b1ec4a939fd0d395f143910f8d80bb50147a5ffdd01501dfe962c66f8d55d98a92b613bd85e03408dfc19938adc47af97548464b1eaf7300c4485e826982990f58db662821c7435ab833cf0e7dcbd30d4229cfb1872fdd984df9b11feee483ce5b5deebdd6ab512867b7ba2024b2699b4a6b34be8a87bcc71501d2b3e55a2c07dc8affeba83b075e4eb00fd6adf128a4936a9aaecccc2ede0623b2039f357cc8f75d9b444a8650880ccb6167a3ec2fdd690eadc4bd6009ea445c78ec5adfe557932c50a9d86a2024b13495eebb131c439e9d071957ce9d8020157fc66b8867e594ee4c8c58e69be9b3e3a4877b238ac9be9b9b4eaa306e51ca3a08c6a5bec43d6d551796b35a313bdf479fe048fed8d4eb2271d709341ac27fbe188b35cff75b7550758bf6cc40485233a277b218cc240213ab51a0312adb7f276482b39b07f36822830b13c56339a9229942f86ba9f92461b183598538dbd9b4741672f5b213344f15a2374c95ba553575f18785f12fe61a2025640383fb187b23d7b94144d4f4081729352e86946e1f3d49a9803f7375f6b1b499498526ee331f866d9abd7942aeb8e947166a279fc23e5705f793374f1f626579c61d429794960562d10af696c6bcbb256dafa95c345935ebd1009b7060fcd7246781dcc77e1799c52982132350b8dea9ec6a8074189312553493cd318c26a569970567cc1f61cb7ae018666506149c7505c1171c2cdb0b79c07c8c868495bd816dc09acea959ae2cd8b8c32ce7d079e586fe3348b987d73802da570417287897f81b8686ed5c42c3c71591887994af3878eaeb1352eb27ec74bac65200d7c4dd696c4ce3bdd7fbd910e7abf4524f16a837e8f99e91a86a639d02d1abdd33687b263798e0e76a52deafc50d26f3ac39ba4b4c423e9562a23bad796cec4129c6787e2ff8036a8034f604de6664faaccea23e5445f90a087ec380f3ff2d10fad275f41cfe01359c4b236e53f2676b258d90a6a984300bafa63646f137b5379146458b8640cfb480fd3687bd4f821287622c90e42e289c431c9a0c3a15e8b758adeccc2bd822937bbe475ecb0fff9b9dd3fc37179a484933b4e57e4e4b0401cba1ad70032a38bb840c32268308cd5be697db4f37ec42b734b4892c296480bcab0b14f603b921d36b960da59344de6a92e75dd638e8034948c1f5e737a5ccf8aed9363da665c85e71b6ba0f4b40f79315c27560c1d443bf58df48877703c6baa66dee96d31388b384803d386053a51a9a1c6ebe6d7c8312363b1f6ada143fdebcb4cbc00c8bfeafa71146a04345c94ab6525fa082241ad574b59be5b0aa2bc1b039232da7a2f47817180c54f5ffdb1a4da221f42eff46c52bd3c41115dcb57f1209feeba5c837d5c7b6e1ee603c6bbce520e629eef37d4670eb6858ecb04cf8b63717a58ebe844787984c749082b02e1cf6820a967b5e4074cf0da4188d5aabb4a073e6b067ae80bbe8d9e87dd0cdeb7b0f2a87fd3baa2223a3b9503b84858e0f32ae622d4a16187fb6fcca11399af6fee1df901c2fda2ad5442e80140a47fbde038888d2f5ea49c38c8023f3a2465e15b9719feb87404cae2000b1dbcbf89f80295487a6aa27759b4195aa81d52f55aeb2a393c7c3bd9b462f9da88f5b08d90deb353341604da52b2339f4eac90efa4abb59b25d969635dfab72a4e74ca12064f36b1fee749068aa34d7853217ffe19756462f0b509528d84f02fb902cf61e267691dbbce7f90ca377b96d1d7558555f3e064c82628edf49c942b436538586993bfd97e09c2ad3c869af4061aacc0604394bf5e86fe24f8d594c85ca8c0d8657e9f7c183b7d84df98d051c46475eb275ac965dc7d3496b4a0e8f0f4df5203ded0e1b6a985299bf362ee6d70f524bda816e49c82cc434376be2ff0b9a2fe4ac5524aff89eb8bdc4321dfa4ba0ef0e153da9315ce699bf8a6e9ef4865688a3c73d30197a2d1063925db212544b109b4ea479c55112104bb5663ae94cedee91f2e346630726e2c9a28d9ba713c462b96c44babc3ef33ccf4c261084a92b987ba8af6189932794bf0b64b793f4b1311f7a510841bfd9b799732fd9e46b69a6ff2b7706e44dbacb0a17e75fb1e95bd4285b2c94e2ab9dd0eaae0a80500248513fe7e23c7a2a9573b72cf460a840fc6d7e0bbb101085ceec3bedd591cddcf06afbd48ace82d25295cc9f22a2ec94deecb3c50e220ad00398d11b2d3c660429a4378ce82455d9ff8cfdd05c6e354a3c7777b86b34180bbd997292cbb57b8cbe6deeab446c6ab5447a333ebc8a7f0e41b3906eb75931333a8d69d9fb0bb3690dbeadacc1043142bd1a154ea4afdafa89215877a247729625178bce5227625de36d467c475df301d1cbb22f7aca02c4c80e309ffcf85536ae45decb3d6dbd99abcd2b9567f80942df73f501fed65ec6d68e4f08499de5e02c4b3a454280b9041116acbd9522836b6de5064ba086febdb0b11c31556266a47cd90e40e05dabff73d5844fc032bce86c5459a86941b2247befdc76c763ee9d27b35fb86e807748bdaf761642622913b6eaafb9fdcc0701f770cc4572d8d3afc245562dcfd7b8bbd9c5a700e97b750b9ca39c39254dc8bcbec998f30805b2146287c3ae6dfbfc64de9be519abcb7a6fcc417fa2ebb70ca01776753143bc4d181097340b36182563ec1b7bca0a08054d8b0b1b4611add0fb99c06fc2778e05495bea07d3b159852b7b20f63dd6d895ad30ed8db5c218f9f329710ff7a3b652531dc5ab01c2dee79352510e1d6d1e583ac2ea8fc9e724ef0da38e6e68be9932e8696cdb61721b908c8899426088c41ae1c3248f4da929f58816442cddad68add05b417abfe33e92603b7f7e2b1e5442f0100b908ae515b6f90ce3e3631d580063d0256e7df0f2387aef3daedfda999e137256d4ad8eee89061dfd0de43dbd9c84d25df35bc7e21cd14bfc8815a9a2f42551f47e4bea411bdab0abf3b1299cef6bf59bc2ba583079acb9b68e87e00511453bc3db4da429618620eae1b89deca22b49207819f70d7c75e8d0d4dd2c632b51514600e797ec1aba8f4c75f2c4885584d0ed97c682d073272d454f5c476111b4d256011ceed1cc29f43cee84dd53313c1d7b30a999ff7d40b0adb0710fdd73e2d0ca80f16aa4acc0da1058babf422c0f2a541bb6b54a6831d9fac95e4b9ab3df3fc027ed34f6ac718ad4b1ef22e5a429699b319dfccdda22ae0ccab779c410d1295d6c8e9b73c5070b1155e9a1b0dc6e34a5ed7f7c203ea8be24aa5a02202d7276a57a16f60901b7003287d3bb6409c1b1ec94e7a940ddb9436a2c2a0ee7b54bc1641e33cf62e364595ebdc58d64005f94f60be54761695a6da7aeef5666e877212ac4f61184613bde9664ee69e0e23651a91925a670be5e486bfb68feba482aa2bd15d39b1cda47eccd3112cf9f99bd4cea16006641b694957c913b15b0d171fdd7752bcfb2b0ce9e4783029fbe273e542363b38a6a3549a875eae4388f1c7c0f6ec09dd4ef143904a9719f066d1feb4a9804511b5dce49f2b0ae3a73fc9273fca7472cd89c451ba1c5744e94be9e32ebae405b36e9040d56a0c33e8f1ca47df80ec1dea699fa5cba4dc68e09e0ca284b4e1cec44eef0b560b73872ca6360b9b22869b4d018d77dcb86373e710a15136735f130548a9fc27f3bb8b128ce01b8e71266bc94454dffd9ab03a75a89719b9ac67085045a108191cebf464afc3ea9172b4383e9ebeceed85928065281fb4c7db5b2b65886a3d1a1107f8a87b6e284ff39325048dd52d5bfc8fc43fe29e34f070eb6a563e3fbb945f7746b14d9e5cf01343327c4b7f8fa51fc756bc9b695a98ebd2654765172d5f9017c4fecad4df241658561ff119badab5669f72f91becc3cd5d5b976b7823f5fe6461d20b71ee48f7290083c0da4ac5712d94163b9f0e70abc00ad4fd55b6f8d767ba1292a43ab3d19081f1731954521f8f88e3219c157675b8a8839baa1cd0d7672f3048d6c4bfa19f28fcf95604d91e43e6c77fe16327a832a335d40f2f02ca0fcc94bcbe468310fb228117eea70b449b880c834e762ee5954bdbff99f562ce343b25a05f1d2b7802fc19de6ccdf17b81957018ef104ee4ca6e8f4e41da88fe35b9eb21edf7c7d07afe5a24248c0da00391413cdf6db3cb979132a3435e91976ab06a82bd53054531586513ef71126fdce12de4b8b029649cb6ef474a0d5de654c574d218caf6fcb52622247bd8fc13f8b81165fac0429a4a619d3ea8f3459f4ed23f78e2562f2484d3ae5bd6fe788adeaa463c4493a554f1c85df3534227b2d94a9d6d21783e6d2ebf15b95e8f94fd4c8810c1c45cb44eca200ff8fc25e7b0f66994ba66e932f3a23ed323068c5b4c3b7b9f0e8c24bf672dde00cf4976abe02e8c4784249957f661e2488228ebce88e825c020644279c79c8517da66963abd62894cfe1130f81276a8e6638ba79fb867100d5ad9d77ce1f77afcb295c7a6dc883a99895624ebe57fc7c85aaa058b4603bca927b3d5cc26e7c8b470c4980c7399c8b855c6a2a201a4497bb87b8ab626f954c24d43be2fe0efdc1f2de83de38a1282526c527e1cb819e907c77c61960677febb2a214dff6dafea74387e01d8da61bf68543d101c09a48769bbdc2c1850c81634bae8cda0b7476c2d6f1ca466c263b061a2accf00083cfc965147b8e0710c9f2806a747bb2a71aeafc977668068a2b76f0f66d61d50e15adcab07c1af3a938fb5593476e8df02c5591faa4bde39cd660299231ee747724bd74dd75e4aa437ccf555461dc618b843d416926ebdc2cb1f31f07b5d7bb83bc5fd9d408b73123d651e9b181a7913129dc68b526059b01ac4de335eafce8ace9ff7ae05a049cf40ca930d83872aedf1c49b02e5698fbd07430d302ab9303fbd5cf07f4a36975446eac5be60a3052c022caeb0685095c9b34df9f1e8fbc2e1875bb2963cafd067b10994ea2c09ba55f0fc8f06b445915ecebeea68419fcf750d10dfd7084dcc618f52ca66283be7200f529da9bf9648d38b3a29ef5087581de89b4489c6a44ed692f3eeabc1a87c1bde222922a1bedb8656bfab0607e951cd9c220d0450d5a54a5c6a00905944cc2e333a985db9d5df52c4bfff2ff96d94a45312a0ee3b1ee3b160f79d159ea043adce0eec11714c9ee883984e9949774e0a8265a384340913168007d1246647150b0211ea10093f99367995598fe1d25022c8fae36090f18f073f4fbeba998899e18e22f943c3e31ece05928bbab9098330b463bb5e5ed518992923a679ecfb1a1a996779cc801ba5db602d0e1328fa4622897cd56ca49ef9e03035e3bbf4f5e12f88f4bd274c09faf0e72a071fb51cc228d0893ffae65bc78feccb523d4f170152311a3b6a100e17d89c5bdb7051a98a69e92d7f175d55d20ea36db144d44a8c8b9960f2e19b049cca215ebd49ed87bd1d781d5ed472194e15b5b9a428a33f8556089320be84a78cea51c3849eab3ded55f673c77b2c1a12a3098b8e18b2c4c81567948ddba686553d17be46119d543bad5a81e53bbc559a06a2a8bfe8e6916f9659d3f115540870f0e0cc957687027fc39d4bcc4f107014d8cad867080dfa5039fc100814d49b18ac976411de1f6322577ac97bb94e715436a1bc9081f7762f480ff973a7a6f7fb4b2a6e90a966ee07f0be754bb81186fcdebf4da29d1c0000c31876686b67383efc1c0d0a3047b273c546717d12d43a9b7fe0fe710bf67eef3f24984f2cb52a7138eff0449f0a91dd2842d529d731ab808091048bdbc6720ab4d2eb0b0e6f4b43d51715c8cc3008600c7369a8feab9a3588236d889ad09f64014cac598e931c49cf24f3a55daf9593d741a81674dfafa359b204fcfd551f3831dc5426f44b6f3644dac28521a2ee19ac99ef872a8a4e4c916cf89df6d0f6536c0751da1b4121704f4f8f130553c3f8b0ce1ac18aa59f6d8b410c0af078aa7402d96145de5e3b9ab61b56ac510ccb1040bd75ae7596b2c52fb515a591b1f1adf39a09c14c674774ac15f76673385983e5c437d6bb0090ececcc3618fb280070e23110bcab9fd680a34aeff2d71ce74a49af5d562e0081d39665c1ec2e8b0d233eead9f0557bdf09d4cd68dcc4a7912fe3371a5e48dfe12da10aa45ca0370ae7456f20149a3c2bbef548c951022e8382bf1af433d71571728dc42d20892cfb8c06912f14fc1f1c9e172fd8ba08fe2f58924aaee9e98d4d15027a0fb6653ae98ed3a5622e85f1b27922fb8664e24ff5a8b759e485094ae166f95029a76e2edb5e19035589f535d419072d696702480817095bc0df575b5585b40ede43eea94e63f823e13961e5e234b6426fa396fc431adf4a01fac5761332787539b7c10596fad9b748fed4a90975faa7da76bb3b250abeaadcff39a9ed167d96586dd5ec64a000d053f26bc11f93699c3e98b339d7d03d09f0d33d29f6c9c7359c4e2a845d599ca1df483738cd49726d011992bc670a9f284c8a3da3e0e819425e78bbe4d5f0935b075694ada2b190add0b80302225ab1f2d8e79a353b19f8108f81f55cabf4428d457b2fe3289e1a755bfb9178ec942709184975a3a488c9dd74628711b9639ab231671274159723c04ea72cbf7f90af19c5c80b3e21b9ed81256b11edf60272491111fb780a80a07fb0d2a2ad0f10aba514be7ac796a8dc28535554c44762d6e619fa2aa5352955c541576eae9bb4d13f3f42db83b75352a2b3546edcc64923f7e97d42b9fd0404574bf27c7302db53f6f753106d1c059bdd70478485b80d829ff5a73929d7b23af66cd836f6d296e2e519db9e83610a524eb12019e30e1a9cecd762fc5ab742bcd1672ce28c165f0a1f7998574e202aa28f96a8e7caaa5444106dc5164ffa3931b2a8473e40090ba86a5b4e96f3e5c12d6442b56c9f85b9f2037d8e87a20cf9f3c73e44aaa2cecbc42cfa37738228abd028e65869bf6a50d19631c531d59c28fe22e4bcb378ded764244bd4a9903cd14b8e46f9a5ea33cd6710228b4a6680997d3533ed5470a1d9211f56b84bd417de869516d888e68132137b24cdbe48b87e66e1ab74526ec63178e0036cde4e3738735a25c8c8cdd2c5ad6a7a384da1b07a72c366f4a077facf944561796a8e617f7e29717e0fe03c344ab53a5cc3d65735e0526455c85378746badf870c82b3a1143f0a4e8b023b816c3b682f57cba7b75898b215e2ea2d117675646acf33afd0c0e25a73ff4632fe66f6f6615f5822128661f776c08f56636f52f5f80362e2752f03765b4529717a10c09f7ff69d7d82d808c9b9f3185319bdb40361051efc39b3c6f02a855fad29e91aa53f1bcc85736bb3ad2d7a81f0222ecf6f05d9064cf0eaf1f9d7b9a13f18a53f7932dff10cad05bb07af82f91ba4569438a97f98646f2675a8aed1eafafdd4f5d0409883a9f66b9e38ed0f736fd12e206979a1d1441fefaa685124959fe29535fa4123ea1c53a8f71f8300dc73ddfdb1431ed87d8aed4de35dc8e5a20222ee48d39a3b99df1e0742ab31ca0274c5fa4ea3aeab3ee74f00577f5ad8aef14c4f9d7f47584b8c8824638e94ccbf1ecc10d015bdfee7e95d3ef3927f23025b416ec5a5f0e58ea6b57cf31938ddc55fa7240ca5bf42b20c98edf55f9f27f01a3a1a78ed5c11d499ab37f78859af4fe6b5fe2607ae034bc2262d5ace7b3e7276a51eb0387ae1f537cfdac59e26a909d86f731cc04d04d7668308d87ea3ea85cfa3c79289b9881a55d17e7167aad492e35b7a81bc7c2983a7fa6e0b0c5607cf7798a6b389816e03f3c36a38502d222f997b45eb15890dbef0f874f4c34fd7cab7af8193b65cabc25dd067f193279a2d55c04628bb4a07eb39052253452bc65a2935c750804e1cf04bc657a6b9b654832ee899439654527c8c5b95ce2978ef07963f4654bd6b2b01be15b7f79484e0517e84b3113424f4f66296e984b32c9a1cb682f83566ccb7fa302cdb28174408233a203fe94da7f96781a8280f628583e9ce93902d49460a46cf6797a18feced14eb41a51fa37bd7156a47afe6ab93f18877f5a16725597f2452946e501806eea4b1dc99bc29b1909be312308acaffe9264e058b4b8eed617a2bb34b691f9b53072ecdf45d859ee1a8f17adfb0e2250a4840946cc2e03b275354c78685ecc121d3ee491f37f0f954be527f420e4ae9cdf88877f04353a25e990ee9de4cfa8c05ebe3fd7150740342b41d75aefe931f46d91683b51e0e5fae0159a8bfab57b110e74b820c1d129394334ce4092fa40f3130cb9a2181957b1fa5f7e45286bbe29b73dc4d0f781057be1b17f39c508389c20dc7ff13893bbdf58e163d576a6c12d067f73d1cfdaefb3effd4cb58d30601d96dbb141a518ce315067fb00adbef01668a6f5db6e2875e234b07e4644bf8f32e25d3b5033e1314117ff414b4d5435393712de58fff487029c167e62a46912dbfd9375462290f800cb13f8870661505798e1a6f0f9f457db58dcee4930fb160985f7bafd759ee4a4f7a935376e0787d7fd4bf56d72535e6a0505c806b434020bf29bce7b7d7935303da1ee0c5b1ef0273892223309f1b19175ea690df487325dbc53c8f97e23ec1713e250a6d3a37798a778a89df057116d850085ded54fb164d1e1421a17cacc5f57549dc55e971377b019fc5b91b35eca1620e211b3a26e0b6558e4cf5756fd49613b48fa91d7a2378230ecda09b26f246709486a17c5b69df3b19de9da3026c23615cd8ebe23c4cd0f84c30073b022ebe3e3ad6b9d030ecd3f4ef556389fe1e89d848554da30124c3ad1a13bf2f1b28087c888f67874e9db4a3d9edad801bec75b3c12a450a88c5322afca50d231310992c4d5169c0cbf202b635bd6ea3312d7422edadd0fceec4e4c14f683d91b4a87295764eceaa97e1016860eb7f1a4b285a558e1521b7cac223a72b6f7393b2bb223e5387d9ea1f612814fefc094a62b5ad298f792416b58a19a30bd90af2165bbfb1d6f99d9f66e4a701d7448d78c5c829eb02c9bc200108aa0793820dc9aacef607e58933c8056b02ff3896042f55df3931dd0ce7b2aae142a2b5ed9ff1a1639b512975e086e3969df0c336883a77510311ab8ebe0b945fe5fa5126f7c6a25af842a5d33bbff3264f5b30501c7fa3bcf8ac8783d3c4e9dc8492cc84784f4e234f0a451487ad11e47af16d88c1ac7795fcac83449d5c92fddcef680b13b8e9755008f85667e16c52accee1881a3e66e99a74b6c8b3d154b8c615b23c810255173693f5eca30680838dc601cfe447bc1275d43a2a28e5da1843f8abc728018544223c005a232f99c9553ab6cca67c5eaa839c6800fd7f05e5c544064f535fb3fd741d8b9703ce1407dc0012e46f7c6da8891b8f3eb2223e56b7587e7acb056c165b9c64cf8d023620e889b1882ed3d66c124cd4f35115223e107231cf831c8f7d11e7e716d5cd912ff421f1c48ced01911dad0975a1d4544864cdf7db7db44f3966fb6f7448eb17f8f3435ea5d8d3a97e9b4b623ad21d90f0d0f8cc63e74511e902ac5261b9b1948d8195c1aa33639753d87a433010a0cb531c6b7356c165488dc8a4b86b9a63114a5342a4d4349951f9a3aa472f98f056d4390c34f37dd97c85925fe3dccb02eecf32288ab62cdf2783563dcb9bc79c70b5c6a218eefd6d5e651525cd1fd94daeb31d7fa00ab90fa3e3daf4ec2522dc455094d4a09040edba25826561b3e7e875ae8cd6f7fb634599c324a08e224ab7cb93ec3d4b4bf568515ae60366ebb406eeac63e0390d1e217f91f5371330f7c4b669cbf206d3e5ef6ebca86bb21e74161f30d4551d15490d50ac4498a664c12627c6e3c75b3bb71281d931b81e182bd8923801b69689e85cf69dad61a32ce21bcde5c8ec473c388518e351f3a36dfed843941cb8fd6f23d7af95497c98c4953f83352f9846d6271ddd61c71a5440391e37861e24b8fdbb0248028655a18d009383aa6b52c17ed9ff37a74975695804fbb74fb758dcabaf0ef973ae1ee18be132581d1bc0ed35014f3287e2b718d39d7320769eff87c74c5771f220a278b2df3460bb64f8a9d4b767d8b3b719db9698495508cf295327ca51aad8e4049eefa8aafcc3c386c185f41856c29594701423943c3c7886c9e8ef8edcab16addfe77b220b13c90fb46e91b86db347545118500c269be0e675895f80e378793b33e9f72ce7d3f88b79ee2615c77f41b5df32e7922be3cd06a23db4558adad90a2c6ea075109f432512b99513b1b81a4f4ec8d4f332368553088cb32ae1436f96dda8f22c50bfbe6701bc51fb7842d657860da96f27835a4118d42d43537466797bc29578c05e428fdc4153de01b9c743432f3f4eae9fbdcb29f16b4a66b0b6ecb16c07d0c11a2adfea4ef8a8f73caaa94783c9162e4a8630e690a224324f62365c5fb95d55fb28a913d27cfd63e82a7d9db9d3bebfe603c4ddb5724aa5d599cebb6a09ef429d6901ce7c0c644476cf934d63264f3aa706d60c8b995d59ef883ce049166e19c6e81c7645a453db4ed54c5326bc46c2be13973f04dbb43ea4987e933bbfc6f85e4dd86027a1b8797a557f7acad4a5defe583cd83adf2cfa58267bfa4b1e14691dd0820b3ffbbd5bc65d4d00f491eb8455841ff5458a9646e024dad0303d12ba52d5bb2829236482f0dcbd886c3756781efe4b1eedb3b7d3abd0846ac00af73c1ddcfaca1284ce54c112c2fee7840d3938a054198f89aa4d76eb064c20508280832dcb2b03bfd74650c0b428d3ffac26a9834761c92b2c013f2751165f40fba94dbf52173d325ee492dc279413ea3e61cc1616c54170ab6a5f30d5717407fe31aa7a323f2a420a24acdc8fbe767f21d010c8c259a2af5a280d46d3a475383b3082e07af602ad9c1e0b6c2e16a89b3f32be3ec969c95389611a6e534e668fe3812f8b332a64053afa425b5dc8d2a44cce33958d5e2aa44cd7a7dc633b41f0b5275e254235b446c42b3dc19f7860ded76192f27f4d3ee74d3f83cb2c0b5a59649717527f238180703c1efd3c6fdd61f1617a846041f798a88350435b1f51f3e6f6be0aa886b6db1eb8e9932580091c2ced2f5511d489722bd97968dfc78c75deca7c3a6522c252d95bb87ed798767ad44662177130fd1f5568faa9af30aae463090dd66dac5829627e75d43cde7668ad0ee385a132eb0b5bb34552a43a0194bcd7129c70116310697464703556c039920e6791da63e010bb66cce3f4c36b109d094ad9158dbe856895b91ac7ddd761a99a31e27fcf1d0affcefc2c0f011ad73b535e044de70f2f79b6d3a0c9d893eda10b4893062cf69a31d2bc8254a8f74e0f0b9cc61283df18d02bc7ece5ec099ef751778f08a19dfc220354dea3621eb9d42be35c1f9c01b5be49611f1e91279e1e0ea7a1323ddf8d8b347debac1313d799d8ecb0b0de8bc2525aa131e3a0081269e9e0d1a18ab9afb34b32554c7b030f67feefedf6e2c4a97a9f48b6bc2419f1193659ca37ca7e670a8e47a1fabfdf3b4db01c7bb9fd40102b3adfe426ef882b10c41e9c1f0d576e3f63fc52b3d8a38b9825a702271adbb56458b8750e16759cae89ff3fbabcc83ecaaf2956628443f329c41012a31e301392f7469d8cdb30acd684a84926e47232b7ceefe0d0f51262d2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
