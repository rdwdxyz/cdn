<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4aac46345e7545235efbb2a7406cef07a5f1fc4a0bae5ff791b2b1275e29a25100de33c3defb9aba45a01a4f9eaf6805db7fff27a4bf7b7747b4474ab647eec1f25eba74e90461b459d1cd2faa8327e1de1c2ffa4bbe0a38e570e942d2a16ad684e96a0015b90057b1ac0e55dc0b6d7d899948553cf0b85a6513d2fdd75e799ef7c8fa7985a8059983225ab02e170740cee7ee43187c4ca246fbe155be441325bc20c155daaa8e075a3012461e01aa03bff88e7cfa070b48ed7b120f1666bd8d1e84e99cc4d1d007657344a7e1b5b4336d302ad3ac6bdc81a6f88105cf19edd3a1094bb9c3aca1eafb99e055012777cebd9db21897317dfe076480fe5bcbede155e26b5324c7c3cef9959bd4866f8be42a33fc07042db1e3903f04e77afe4589cb564e57659b11c4cc842ca435d0e4f416d5f651d52d7d6f7f040ec1e7ddbc727454e68318a71caebc30e598e86c28de40a0c0075191612e8f7f54ea075666afcfd0f9ea2a68f770044ec4f0a925ea7fbcfaea8915d625e359885f53d0299fba7fcb18be0897386698a23f1ebd04331572d3dc7589d8d5ae87202e099f68a96269d94ab46d6935e4b63bd91f692c7c4f1015d72d3bb3cbad91b9c4806c305c32dd9887d43db80c535ca4a1b986d2882d14a081069106f9e798de2a17c413d2a9e0fcc2a6d604f23ea918cb710c8de9187e1613037ce70407b6c86f9bfe4533d62f8d20a1cb7ee7e33b48c3b71ec3ad1f519226afeb26ccf4b7bc417ed683a25bc51edd6cadf3e1d0704815752c7edec463953c8256e2c09eb43ff9408b273596c6a28ef36c080df575a8b7978f7ed33bb289ea060734422982d3ba01f8803d46a12d7fa708e9c40e785987d88f248a388eabaf9e294d6b6edc524f4eeef7452b7871a3a124122de64824bcbdb9c715a02db24cb15b9c622c75cff5a039e41b60b62273a7fc56ccf0485fde169652b52ab509afaa9b3ecb8b98cd071623e6e7cc863356abc6cf5276f30b148ecab920934d3cb891adbd1fa0c0e6fcff7dc768a20338f3ade9d80db70e592184b69ea269bc668124fbd7159da5b0bb3a0f86ddeca498be69966f3051d348e39b8aa27b89bd40b5bb3c855bf3741977b30be301841e27647bf13d325b29b1935be9eb884d5c4a7549306c0fdaa88ffe9d0cef1af0699b62f2a744d94804266a18acda8692556c80de2852670ce39be0e99374b4555d7e96f95b4dc67555631aa94e21d56b0a106a6baa411b6d75184f97ec7186115e49a00e9ee525648c9d961b6d1f9f9cff40333b8f1d4231ecf6bfb74e7f4daaa2a630a7fc877647b86d5ace54d0469dc8d67e179711b8a05a24e39ad60d5e5c01bbfc85d2905f8fe576a4e92083dfbc23f2d13aa01d0846bb010fae4d098e1d45af1a648733db9eef3ff0f25837f2430f4cb0a06f3a33f42dbd14d83b9ac0ffeb73b8f7e1b381937b1cf986c84cbe36e3d30ef500ec91332aeae8ba1c213996d50a7ec6b9d33e29947068e4be1f4f07c9c013b6ca92d19e277a3f1ff9ccc1b42f232c16465fbc2421335e9da1b0a8d21b3a4222a5debbd789895c7f54ad4d13e7e3366bd1fad8d901b76a41273cedf836e1146781c2155cbb4f326eecd3077d18629c6c98ea34e16044b7bafdb135bc4a34579b67a354f9939b1408a178f262766a1937513a7b85861bd21b6f58a7f55e97f9682ac11ecf1b337163e3bc9d5587edaf789d6af1c55ce73555de4bc2aa29db712ed8913482d69cd8a7309d433f37727706edaa4931822acb12d5e02670af6d2d0578ec6a4720c6787c4f4de523bf869038d36d1a95c2eb812398f25ef9810d3c0ee88b41f98ba2b5fd842f15290b9e12f8f241c34bcdc0bdf1fad7f1425489bbb92ab7438246009b32c9bff405088e6d73db0bb62ac262d1c76ce2cbf6bad1599087453c85981932fd97c737e6e53b710c36d5309ef57e41af6634ead5ec988aa49784b530e6e00ba6f3db8f4aabbd6139e2dc7b3d1edf9f3b84262eccba0ec20c5eb689cbc4e461c8afecb7c4459ffcb419fc8792610c4edb890bfbc997e797be8969022986d7f7d55b28a46a4ed15ac8e0701f65876fb96ca5b6f54359f186c3cd764c77e760864e3d0c310489223cecf53bbd800543f6de3fa80662c066d1d6b4eeaf00625216da6a171b233d6e682396856f425c9d256e2b146ccc4d11091cd160918e29a6d673e131bb747e62f0dc2e449545a7f53ed6d4452e815912977aef3a7fb6f159584a771c2b49e1bdfefcf578df69c44e76bd8bcb28d6f43a873d3221e5dcae98929be9b34a3ed3dd4f7ec50e64463c2f62a7ec72e13c2e51fbe8d60737ede6e3d00a88eef3682c9dadcf0d88c47c009b4a312c2df72161387f986050f6d0faad93efb45015a4b783f5e4d3d78ba0ba112398a6bd00b3c3cf82177ade7e454f8744eae35ff9d09451580634def3841b9049c5ad657dda9cd937fc61d8c1fae43538339a4dab372489a9cc74a31039d815b59e73c884ac3c1f3e2b748ea64292846f789c10a8d016862cd7816f4e845657e5aa1055e5e82b17d65f52e48a462f2f691426ed689dfe8eecfa45de7be2ed2d4d3f692ff7a1533afaf43ab0610d8f03cc0b228e60fdeca6b262e87a16bd85ae530597004a01f4b2270e3447e832883c121231b532980f046d98063e6296e3c796a539ec97219146abe3ab5110254be3d4fc800b20a2b4ba470a85a0911488da4be541a8e0cc5ce40a5b15213b46a5a877b8fd2699c14bf06cd6a9b893c13538487ec0d29fb38fde70fe485ba8783db16c36ddf9ff10b6bfc659c7c42d5c2b8061ddfc285f082ef6fcccaaf9cb9c7b59858dbcb43b624da217bdfd67b613613842e4feea1555527878d1b6050bf03c89ae5c3c8a0090f991699f65ee1d73d54c7b4a069f1343688b3bbc8b60bc54a59621ab5d99a304dcfbc2a53c09c4f3459933167aebb81dc415699a42ca9e8fac89530e3a4944529ef844b3838ddd23cd5c741248acffc871285f009b446bb85cadb4d580bc4a7a10e255058b220340b3a619c15628e3bb746edabf43cf84d2d7cf7d1d8345dcd2bfcd5fe8d09fbcec074a6c47899039a12f05ec1df8239c5836a97cf4beca982bdb128ad18b227e6871a7f60fa0f35236ad8291849eaf2454360b190b965051871017a5c23adc07abf899b23167d7467a7e01f7f7352c5b6e6c4ce2328685c56bb2502cb0291fef6f1fffcbf3f00b79360256e2fa088ebf4fb40eabc16638a183c3a98111382f1f3c0584f8d2034b56f38259e924271c0e4f1562a4d17529e69eff20892e4b5670bdf85d34dc177a2e517668e6a90b0d744ea26f59fbc9680a9610040ec792a478403d51ebadf869ebe221538353761d12f7dbd6e5e59d9045cfe0bf317d6ec4f71ebacfd35b6b62e4d47f7def1f0ee7cea5ce51e75c62fd5a69ce24d1c3d209da7b37a30a84db41f32aa405d939f611029d9c69ff00519ad2179bb5c7526b756247d1f87eb1c48da0137c9b8198e061f9ea2063b1798ca16c40671402a668601805c117bd7cab170283bab61d4ba297e6db312aafe91f017829b8f2478d4f72c95f65cedc89878c6c648f9f8030af16dd58d48e8c54d70a5b56fc307e41b71fb6c2d9e7388b0cba896a18bcbe63b4d2bd8cec79ca5effa7b1a40274dbd50051b1e803eb6f48450b128d1b97a4355e8aa0f48a5d5d38ed0009c0caf9e0c609bd5aa74eca7366c315994d6ead8c128f181061c072c924cd832bb6805ff58b8b57505745547aa71336248854fdd0b26bccae27f56f37baf96a079043fc91f886499ca7493f58783cce5fac985eed9681c09b3990e51bcf62d21d4b206efc94912b2e93661ccd9f9d6c3e5c1e2b8435704b4ade713f14ade05e687b5f547bec6324cb1882b009e63e11db34ed7be0164d4e35948e4fb37e51e416b38a8d733f6d3b3ac0c1077383c60acc9a707913078df7f22b0c1f1b624cfc534fec6d215145f1828e6b27a9b52e735060e6c27ef7c52aa95963a605f69457b8f0fbb1040ab1448356d940c31d554ccc15d5845f8d7e5a325eeb4a6377679596bc6ea9f829fc75e3ed12ed56302268812a751fab381c3e6c2756c0c8a90dcf808d525f411757a86045e5424c83b57b28dcfa5367b8e1c9e785afe44978602e166f4a98f00ab4e9afbabd17cf2a8a8bde642e812ffba16f86d0d5e71dc0a1e518df0d202c2fa23e2a8d4b73acf67e6675ad9ac8e8dba06646a2b17e4023b139fa2cf39c119d9b29e69d9324d99a81bce9c40a149fe4a87da8cc877b469902dea811f2639091542670269750b1f44ad58446749b3789ef0e3d2f13e6c9b86530f5c2165034db7b26b257118703546b28c5a6f34a1b4a1220fb590f2c88d9103429e92955e6e1f903db63528cf62b75338bc8e56874e554e14c4fa40e27a5ba1568e0f35b60b58ff510e91cb90c981f346b3952ba2b5271cf7918fb54f3d45bad15c2346fff762fa29abf0ff172398b5f8e9a2f3c2e8dfe25b59a40fbcc0308c5b2882dc61b4a15e62dc779eb96f6e69f10722fe6d2cdd997155cd3631e7345e6da03fbca0be2f7f72d08a3db6e5118377592841b34de3ca8f0ec4643f106ef4e926029bd1c1b1eaafb144c9adb7893c499d4f190ad3dc286386eb88efaeafd1b969e34b0275cea56ea4b4618808dc2b10a8fe5adc93b8eb42cdc8428989abdf56cc124879ae6500246bcf0f18a0fbab999674577c8956ce231aef0b15a62cb8827d7b528659c4fd0cfac5781e3f0a76d5c82efc9a460e38760f2c2d3111e45a8d57517b01a7e867d2e623b17aa69e86b36d52871eb5f153ff570b7a73916ebb7162ca9c642d5f02312a5c12c68c845ffcf49b78c82a2c0e91daa10e68323e8ad1405714c78a10be73efdc570300b17cdb1a3f7cff42ebb1b4de05619c46ff0dd663b2dfe61c1cef21dd175308a9c3701c84f8b41fa33c3361485cbc1f88856abc46871b512d8121806736af02ad6fbafed7be7e99a937a0edbc5e3a4a3af02c541a8acbbb377212fdadbc1cfe4a1a053ca90edd02efc96d1b0450431c05bad3ad9691a9e42ba70016e94f295abf3c45ad1082d9b6f8d5b1d306e487294508cbd23eee5562369ce639627d5cae9236d5470ead2fd2a1d7ec7e9ef3184b19b5534bbba45d8d6bc2d52f3b8163ec4c97c0c8ac75021c1c0226580888bc60b60ac6ebb8a18195dc641ed94935fca11df72ab7e23cb8ae583a95c18a29f3b6759aceb7866a51598c42596832a8a893078aa67e5877d3f84fd3b88950f88c0b9c4eab3714c8c3bb6e953f7c5a24b2d9bcfc9a71ddcd8b0f9743a9064eb075cb4e25d3d3519c20daab0c92fbcce2b9dcb65c9c406127ea60a9028b261e803cbcba225b932c19f3e14cd5cf68b0ac876ea4b6f216846deaaea3bd75d684124f756a091b08575acd525aaf31e13dd4133c6dc69b828a23829912857d8987a9daaaf9934e1ea130f9b9b48e1e88cec2a2fd409ed75cddd3c618541c0cd8632f04e92ad0e12dc759d9e7e6f24306c49e2dea14ed7148abe617416d28ca6b54f096270f4e180b3f6fd6bae87ef4d86092e27fba95bcb1e361ddb59aac5e873b99372812fd96c2fa3b6d1c2dbef43fb916cb0f2161fffce3a07bd3cafad1cb655ed8e0725d98d439330af0d6778594775c61b1fded22c08657e0e2db22322b57d11e7770f5824c6eb776ae4ea1f034b1b2a5fb983d1d9b18dc13ba609391699c70936e29ce04edb995350b2341144ad99a323a9fd5b8521eb5ead9f1569e376ae4ff79dac0648a0b22a3a6bdaa803ed58db0edee984bf34acff1c386b139103326a3a50d221820f22351a0aa76a2bb4ee4f738936bb42df62b312aa54b190576050cae9cb0e39f2aa955cfe945a09b61e1d25f0951cf722804956895750ef0d12a9044c116060b8d77bccd54d5383f62f0775537c44cd424012f3a5bc9333882d8249be87411c6dede9bbbd0129689a1208f2e8bb3fdaed42641879f189b64df9152d9eb07fa6b47c0cc6339d1ffd5950e0739abafafc1f59566fd2bf0c89cbc4b6542b943c0af1de0df1a3718438a160b29eb6ac6b1f6c655dd8bd20ef7494b54f85a59b49308551624f7f1d19cd4c9d7a2cf409249712d7b9fed9d70a45c013b8c8c59b558f13d99d5a74bbc94a0da292c4eeda22389a374aaaf81908c194c178c8e7f3d4fc1678ab12cd85a8bff4066cc8129410892acdccb93e099614afa069524ae077367fd7659bd64092fa7a0243f70bc44fb000cf544c54a7e73e5d3cbe5441a3f3bda67181095a473aa14b4aacb13e04d654f2a3ad4f869cd1fd00e384173db9bbba9bebf51ad30ea3d8f630a3aaa8b39e893f7527b530fffb68d8a63663734a88f1d2f6a134eabcc2134e7b0945365d8090bef768094741a8e8f4e131905320dab50c4ba983f4fc3018984ce979594ee099dd53c11dc3ecccd021dde86bdd644fbeff7adf16cefeee1ac043fc50bbf4e192e86cdefdba06f4bf690fc8ae1a84f482d73f0aad7224ed1305008541d99991432ce9ebc5db2768dad06a7c29b08d73206f0b6c24035eb62a1b801f70abbfec46d57d79b4e273247bbf2028ad5e0809533bd1234c9ee670d667943cfc0b1b056b4b17c24a893f90ed35e602ad4be2a9814d4072b4a18adcd1ae94b5447d4a074b6802d922b4ad8568740c652bd748ec4dfc0cda9a3f26179d8a00651944f5889255c545cf2b7c74c1b3bf1eb5fad615ca5097d623ca6609de38e305b96397d25a9e73643df60d868e998a40eabbfecd708281527cd18304ea6749ffa54d0016b8d35acb85f159db695678a9f6bdeae0799e189af5d94bb9391f4351da97e61fb3665f9e75848b8f6bc316dc9d486c3b43ff49529b851981501443bd0448473861852dba81bc88e9af63e2e4526b0b91efdd3f6a63ddf08a44af2827f1975aeb312bf3b624e0c6f32a73577c43fbedfac87c4603282b3e3819dddc73c9860213e54f9244546fe5f7e64ae5dd7cc584e9ee66e24d295b87de91f19ab1ff07ea27d673c3272eb1f88e20f72433c6fa357e59d3c7728e69ac7938935c649656aa63bc0be0dc20f5452a053873a0c1c5e2b659cea46a1c20b8de44e59ebfe23c35d639da72f0e5649fa280105d4fd2ce976ec90187792e8950c3f34364e192f791fdcd0c501e21b2cb38a3367e4cac81ffb1bf5f18d496d70d40839491224d9775da270202ea02794965644a23e917e652b726e5ddc72fe5e59a8ec22a1500e29ca4f60024112dcb19f44708d91360abca631874b65e059f05cb7349f09c7a8f2a5ed483b3b0d5786a406d0d82c16f8c5f26ab79086f564cc7364e37223bd4efd5ac08ab0f37bb50367798de39c19e0442de68543c8def7b8210c7df6731cd862169e6333abf8c0853d3b865950cb2f20506d0c170b024d690e8cbe5b6e2ed13963ce267eec0b91f9084527fb991c223269555f94ba84bd650beac4b6efc40e979ff6faa0ff34b317fc899d521fe315429b1d0f922fdc60b69b4b19708c7b2b2ea889c6c52a9903e3cd822f559208579b8acd78862b41c26e3ee57b977c1ecd956d5125a3be2c55e8d7dd493282701e562554df7ecb63b8adbc0a706d928df5509ec613cf428e0766bc61e320d244b1cffeb9841b2e4e79d73bf378b70c0cc22abe6b9d36aec32053d105ef6206da7f7eecb1cd00dbd02ff723cd617e62a9137e80134663f696a1ce44b225130fbd8fe2456067bd69b76592db4d80bcc4053574af8f5df879c9161a1e601e0886be74e8ebbac7a7952aca2033d567f49917385c29664f500be922ef68d4634c4c9498d7e3d3b67ec3ecdaa61643da81a1826a1e9ed782a4cd0e518c7f8a267a53149eb915ee22a4ba2301bc63c2a91cdafabc465240591241dcbbf8e6c3a7618a38ae42904ebbe0b203a1664e2f8462c6cf557fb8883077b07cbd96f94cdbe44469ebaad2d5a7f97310c54790cc30468c108171f7cb3e51ee114ae69af84e30ea19beeb5019e1dac69d45ac8870cb3ce395b804eccc51c23be141554f6627317bef60bc0e59632a4a4b60a52192d73d7e42a37364552aa15170e360f647628513a3e29d16d6078de1dfb6c67e9623dc83dccad749a7ff3d22dd9bc34728f4a850ff7cf28612fa1d491e528348eb89d1c091ed0611343451ab2db5fccd3f5789d3eac645270c225d67f6714f23013652ba54622892fa754e6cfcc71ce96ff2736eefd64cb42b57ff6059177a43217e11325db4a83d42389f490d66f8f9ffae4bd84bcc77aedeef2b9de697a7210005eafccd7489a70e63940aadf66ef61027337facfdb3c5ab15a4850f80034cb97f2440bf199ffbead7f7db0fd34113e75ac4b948200b8dffce2ac611e461333a860754654136f576352e00b8899c73a91127cb0059eb2c03415f58c34e0367fb6979040227a1d66d1c52f9c6460f9b55284c5664729b360cd73aa73468262c74910828d06f634ca06d3a2043c741c33ea041e6fccd2c5522a097ab517bd46d57f67ca22c8a6a014a3cc00ba721462111158bd1095857ff72a4cf3da6dda10712611d3017e4309fb72f291d4a869950396a55274861ce8a099fec785090c3592b96235936bc4394c8d7f03764306aa96c976979e59956d56fb1c1414cbe579b5d65bbeb88728b412f2eaa9de18a364ac923f950066886e0663c30723a8e393b7279339ad43f1584544c807bcd8edb433f76608fff2768c86feb1339199bfe79faaa67b096e2eaa0d54f5bc975f0654d642d6ee21dbec2e4721de450199e1791b707fe0b505c3f5ee7795bc0b426269266ce2943ab62cc065e89b87cca08ef6603a7d486c4ec2bb05b2bbefad59ea3fb904a56bba264c2681cb70c5752393ae49e34fcb985f5a94768aa21a50382f905faa5593d7d34ddc754070a9486766bfe8f3f21f60807c2c89f71d1609939b651e56c0d319dc85b7fc12a0d6cf3c8b4c30e8b224ac9361a2bf60011a0f7a817e7e2b2492a521156e00787c08e4c3803f0dfca6a0abceb2cff6cc22c7b6e3d9bebcfed3142a6502d0b7e4fd0257609f275a890945b02d563a31b44dd7d701766d2ee5350be1f80948950327ae157c312d20118f6a0a7c0c4b8415acac9d6d19ce1779a3541c0137a004b7c233835f6691ca4e2cefb1979f9a40715c5c9890de1d5b8fb40cae889a1e1b45f2aabf28bff6bd18858cc58bfb1093c611f0ee233541f51f44cdecaf737e3ac3d12b51dac6d5a7107625d12633b7224d31489a4cf10689bf81d7acead5393ec8e94217485ac8976cbd4c4a8d0db9c7db0b1a89b81d52f6c06804dfe3347ad422d01503755f12dacd8ad71e7332ac944d07a5bb60853712f06105ed4a12d7fee843d9fe15d6b999e8e07be038c82baa65a9113f3fe602d81ac7e503f4cfef3a3b6c93e990c89844005226bcf42698daa9aa2f6b2dfb79a865561693e467608365903295ba66820e073f2529e0f75c08e86a43909aa74b4e2d8cd4f8a38900069dc467f70424c8f02f110dc6b994b55af9095968e850e0b4e56521cd08db852896eab487a9a63b41db51d5bddffa801b7dc0512815491300296aa56fe8d4e8af5d55caf6b9226f5b68772da2203e2ddb6b5325de0ec1ddb05b9e324fe3f5bc5e491b3f23b061ece5abe50904ccd7c1ebe709895b7bd26db4b2d7effad735167cfa31ecc9e0dd4980e5ce5afe4dfa17f37241d68749a53cbe2f5fad992735b97817d0a527b10bc974f589727ed58c462fa31289dc1a769e71462c34f40c7476ce20b058e315e2f82d652ab0b6ca15e05341a98e05a6363bbee5db43fad2fec8ec5e0ef6e391a41a9939acdf3f020d223d6bb97c92b5843471ae90ce4b387b46abe55aa7414d59b995e67c32a6cd504c5e7a6090d0d673c880b76a984bc8a35aee62cfe3b4e468dc339ca8b93c1fd52175367ed2e7e2ce266e634427f30c09789dfbd9f806da092a6aa2421e3002ce477ebeafa2f23f8fa829d01b6e6be1f983e1adcfe0a5bb5112493c5b464e230c0f4b3871a211a1e71594857cb8ba3725ca82dfc503aeee96425e31b2e2cd6a257362f0b341ee62facf24b0e86468bdcd8b1b2dde42829ece66ec8fa6aa3004da7f8808123e1d8c13e09a89de793570f673c3adca1a130337880b2cfae3f917bbccb769781b24cac045eaa8691f3aa3c44e96b0cecc49a0c5fa6671465fad4987e572718c270afa52bf2b79286c68ff189cfaba841e6653ae2d3ab549002c82db938bfdb1c9e2bbd87b55bfd8367f6b031b414f48e8afd160cba2fdc4b8794cecc6abbc192e39cc4d4b6a8e14d04575c86a4a4c2700014b4b77b538e474b61f26dae57a52781f43884aaf4cfd5ce0cc904494d0a3ba03906e89c75fe15999f00288e49b801ecbaead8e60861157d11648239fbd6f9e4880f813327549e599a5e00fff969dd0d54162b3c94ec3a1a51499a473bd874953f3fd7ccdf62a05e6e769a63631bc92f16266c533a0f6fbead05a9b2e8bd95e6d28a7ab6296d25640ffdb6e9657fd19c397763b0f560aef0abee7cfde6f48c1b615273793fa4fb830fd3feb8bba63f1c8db319c39ac4086fe28729502ede5230b43f002478f00f504a956de53de3a01b134902584ec1c5bc511573f22fdbe3fd4a11adcb302576ed2ac1df7ba5879907aa897b4878c757f2669c76b5c8b5f7bd32c46c225098a80e14fceedd2ab62bcc38e703813748b2e2bb81e5428c25cbed6b09c86e5df1d3f0d3ef633457b773997025b4c0a2dd13012c462b9a3916304cccbabdb8bc34c8af52f0c20be3a677cee864b5eaa7dbc476e31d5dcf74cff01a4c3db4ce828a141d8303d32330148cae00baea9be630f2756f42cb4c3203de56abf78d8463cc191747043465d5da089e9ce1756bd41d40f7873d3dac129ce37533c5f2e30a056915798520aac3616b79e040047783172c32827b2391446d37ebfd1ce3f47e304f10afd4b588ba8f47b2535c5a5c786404b7e6a1f01cec109c07c222c73f5e1f328be9d7a70c60553946502b51a883aad9c93bd54672aabb641aa0fde132eaa3063c9c4d39fbba3f7bc63433033dd6a66a097df9b02cc16429ac8f37a5aa8f62196851f3d74988ce1a71f39dd3572a9c2749ac00ea49991b754aa3e8eb90cafddd9681d73f94d5a367f4647e1d019a0555d35cf0f8d216a26486ae91e25b41ee7927545ad2faf632a3cacb9c6ffe979a14537122b6c68390795db3f9760c72a8b224ec2cfe7cf3e709244b1ad74cbc8ce3e102dae3ea54b7ddaa53ad9c5279121e807a84097b62204a8f4e99641bff2bed3515fc68d045a2b897e13ea08005d758d1809f4207606e191af6c084204e8f1416b31793cb101d37d8715f55c5aebf80d2075488201362a0d1eb7f718d8db638a8f94d50a3b441f61140b3674afd3275c18e0b38bd136f403b4cea0c70d68f8035fc5e7d2b3136183b837217995f497b304db55858fe7f3961661ffbfbceed8b47b5d6d6ba57557be0643ff024c5471b787c580173b2e6307239c0b715bd2cb5f117e4bae637173fcb0849f54362e7c4d651791cee4a4d5fa5459187951bb0f4fd84d09a86c8b87f6ab582ce6bda455a7d2572e26f90a5843664c3265c088bdf51cd5ca02a4f77644addf915cf7eb9d163b648c219264834b64842d0e2b18eda85fd80cf35e93b7d2e3211df8f1b035596044a3281e18fdb58fad0dae43cdc7bc80d5f5bb3ab39f1b3ce9895d167534733049f097d2a4a5352667d660c222e50ea844412cadb936187fe90847ee16424eb53876c2ac05d66ef46be83c5a6d70d0ebf9c4721db4331e30bf3a97bd543da32c71ff884f8006c5820b1aaea61bcd51ac249feae694b4ca1452072df2ba939ff52db3e6e2622adf83118b219fb19c52499016e99a8f49a0e286cc4fc14a3265f4e5838c53b09a14d2a7bcc3927c0c578d03865be45cec72702396ceed06f39335223aee928b35e739bcf14b24fdeb395bbe15382e46bc090fc73c6bb2d8599ce3a1cde4258ca30302c8f86b64fbd8b6305f4134351fdc720afd2e34d0d2cd6c2213e575d5fce50ffd5ddb5f461ee86efb51e6a0b7d97074713f3160f38249ea7403ba182b40e3f1f3ee9effe77456e568621d8f54c48e5689318f8c19918ccf3a861c2f005d435fb0ac41ecfdfb2fac34873441a689c234906fd7b5f06c347613a0d2ee9075fd731387e2a4f4b6596efa6040a5f8767269cfaaee06cfcce30084b1f5274b8f1221f67c5837aae89ca769b01238fcced2c64f4ec1870231eac7db5e5c8bbf29dd6e92fb5fbc543850d72a9e580e362c620c19a4bc4861072aedc7864d08599fefa345faa4da1d03e46d8911201663502265655f8a1868cc3d4667ac778cbaa4f6d09bbb03a78eeef8698fcccc51d7df2bac5abf8515ee04a27deda5a9e5fce53c891be47e1e6e2cf38ebb6ec54c8676408a044622b28ab272ca07413817eef4ddf15a92633a258a1e9be922446d65bb8f83c8bc57811dbd0dde1972651cd71a6da8c5eb32a376483eeeed8786006f488d2f200a92553ef67019d4ea806533a7b4a5ea60a633b28b6295c6b9f76a209db494c3481d935731cb2ed1c98aa7d96607658e4b0d45c655076d4444b73e5c759d9955fca961d8e166197cdcb220c12214611613d3d1e445deaa638c3f656a17913251ab743e94b888bef463b2bcbaa5794ce6a6eb30ec9b4de984471f8d17f42c4382be40bd48dd851c48bf99d369f27aada6ac0aa5f6209f7a9ef6a4cd3222579df3cdf48cc240a04a61d5cd33cca96d165476212e73577898500fb482c45652732a8577eb7a7d7562ce2c9bd131c1fe3366e5c1553e4f9c633438bb590b4b73e4675eb035768d2c5f1cede8519f93b6fb11e51a191f72dad823aa255b8e849df7950ecf2302cecb6582515fe4aa7e5ded871b2f2ab724e142fb314ef9594a16f23d2f71921777e512324655310bde426382e882b46f6bde6745b2ee8dec9f1d14f3bb710d0ec766c678f86cff084545f8480a9868d25f1bc146776b6288d5f99b2a115430086b309b838c66b86991d39facc58ee70ebf99024562c61ede3fb82e5632d233d7a1a48ac3436d3b6898b27faeb32effe2a8f04a7df8b2ba85eb7023bf7e5d6ad71e117765f122fbca32c09354792c6b258845f621da78fe3390aa1a5530cfd6b71666188e86eb126154476901bc2493efe280d05bbbac79dac61259c4a48e6cdfaabf410484453be273b1fd564a0450011ad4309ef0b1bc86f653e892a988f79895c77d3ec26294fdc9a9af50a9b75452e381ca0a175a8dcec1105de8d74d187e155cd75094da0b9a5fcc829c11f3588307d3870554b467cfca8fea62bb8260edbe688e1579cd9e1da378338d6e7f87f7574d02dfe57f0ec4a56f0b2eeac9aa9462b4793049cbeb22cec653834fa3e0e0c30838e0e517e05e5e70970d3c895ce6cb5258e957ec14e5f3d57ba027410c63b28b5f3f15ad9ad286eee3c6bb92d30d631f0c07e32294ee1556f02a5ad26b12234874d4a5f260f1965eb6fe3b33f8038cc0bd53e8e64b738ad5aaa08b7524b212f975171209c851d5d60e8d0752b3032ccb7468039186e3eb65bf93c66049fbec24ea5815e430dcbcedc9610ba1b6ab8b9162526bd98d093240ecbbd922ba18e23341bf940e631bc000d8781f57ba46639e05c01dfe6ed905abdb2be99b073ce509f9d956ab2e4ef59f01247d4e7db788498264fa71190b88f9036b480355d4fa6b4a245246a7334c08da626e83eb8486871e05f070080cbcbc19e488df51b799e6cc8dc27461032909739ba552568addd180578c6a5752270c4252d508578c7b96b803bae4ab2c0659b100beaa12f5bf6b0e95740dee86ce571c5b373b052ad1f7128d8571946a553543cb4802b009a86c348b53a2d7fcf63604b374bfca9e4699ae86039326e7a7cc6752ef14ab4e1720026747294913aa8be2867c2d4a5f8573d0b246ac5d378a779505879ed0675027f32017811adfe46b698b6285eb1a399a45e598da09d67afb8b942babfb0d4e6f2621c9dae31a6d79763e70dfa083a8512b7c722212756a1ca71a06ba09a14865c7dcb3df4af18f785994588edd775535d90f6d66908301b9ebbab6a458cd4c2d09fb2df59a4a689976bca24d50fa82e207115f349c7fe5400012a002ab8889242c9b0196749f42a4afed5f812b5581b6926f2131f3a65a48c117ae9e74bf3ec76b4cd18a8452802ade3993a322f7a36c837e35fe4f24a7bdd6967169362cc08aa7c898daae214b545e2af0e5de3b1e4736fd96e2d4e13a6e197da27cd2f07f6ff23827790514b7b760a35a88f5294bca47018e633658e8ccfc1477578da3f8590b437124d5d58043b3f01d8faa33fc72ffdd259171b40367f29253d5b34856e73045b6336951cdea368944c2921f5dd783fb816443ba5e45635495c632363ec205c02180d7e23413b060c105693cf7e81e23101747233470eb4be8f38fd57dd4a96b1e0ce486ba192f34c8be6fc3abc567a2cdb6220ac37e1c1a240f9a68f2e54ae2aa42a4ef9357af261894eabae9b86c40b96652cf8ce31b96efae38ebd11f95bc3df241ebea23e72cd7402642a5a05d591ce5b9ad0b1fca89473f4cc441f789cb9bbf3379be0b6ae832561d89c3914622af0633dd6a1b407fc2e4b1dbb6166ee7052a64f03c7839611777def66fe0f7bdfb22170d21e53f8398b88a5de384ec019745f71a24ccb11eddd1b64c2abf0f2862cef953b8fc8a1163c416068afef28de53b9716bcfc0492e10a30f01fa6e3a3fdb00e4428f36211d95e48e0bd0c5eaef36f189aef0940c2cdb9cbec5f1a4a4e0a0414d03252dd89dc537c862ac50c8d0c0c6d7b9f0b72f4b74623a31ca1733ec661ee8db0140c1626ce6e145dbb52f0dbbdb516a1aa1641ab3a0e2374238c7659894286b906c69c4b6b9d6fc60e917790a771a0fefeca99907d93eef87d1d22c9925b6b6e8ff2f4639fecc99d2046b494a4f28924c182b9ee974218f595c5bb2de3c50915d9d2e5f2a2f2acd1807abb57bc14c29031483b4275f721b0229d8e4850e84ef5b22f37c9e29f8401b2facd277d46a241e859","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
