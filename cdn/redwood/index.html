<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8e453079c8a208302a14f11c20ea9bffe291a9a333fc5333d6da224b90924690ef557a22c24a162395a0c5d706d4eb798b07b440d68c608c8b335fd51cfe03f71a7e2e593eec2ab7c5158d146e6ffb73db4332e4f67c9f3eb83d8bbcba9b49d988ae8950d4d1f6d5cdf516c3199d4ba8b30858adb6327b22310852d9add1e597433a87ba190936195d6277b338fb280e2dacd4299d1cf42222d2a7a4d151af71dbcb6ac3fdbee3fd8196b15f646e64c519cca829c3e03fe77c38d77475bec03e35d93eca1ccdf804d0052055a15e4117061695d05ce66a8b7cdb417f85f1d76025f23b3fa03515bcdf7e402bb22ad9d3ede41479adf9162816244ca62efa84f7e15f436b2a6b775b33d87ea7aa336d1e4222d81bef46988ab12cfdcdb5b06bc9e91a79bb2fc222a4258199bea6a8b4ada4019d2167cf8acf8bf07143d9f630f709f967fcdb4d68d182cf9f1477d6a154d59a98f870a3cacb10a5472ebf911566ba73c22ada80988fa5e0b1007b261dcdef88090e5248de48f25323af712e4e3edd0c6e1c680e01f9ecd8af7f6b926d0dfad47b3221e7cc12d8fafcebfb7d6156663bfb70b4a2155d04aab02af61fba5f16eb9e5a62cba86b9715b160e30c4f6af74dd0fff860ba105688c05619d2ae659a7992a3affde5ec57b27fd42c0483cac7f54383e7dd00e91395e875f05f2beac7831525d04a09e2d35e9946ea368bc5ac27b0f910abb815451c0b6da789fd17276c5895769c5c2e7a86942715fad7764c67f01a1da787b1657e1ce40f26f8a4badd26a1ce38ecafa53dd12c9d1445159cd79b690b0ebfe509f122b460e51312b9ddd7acb0ebc62f34cc0e94b2b37dfb071942a80239b7b010cf6f4c140a052c8ec5785de661905ef5f9e3b974b0e07ca9566b2f569b2c03801d57305ab37863c77d823a5d565389b5675fad91865d71a823cca15a977754f697cf2ea8e64338f7e35ecc8517d744cc74cd232683b0b97ad090aa68ea9d71b6a428dee843a49b917ac2dc46cd0b36e1be5c1102cffb1cfe15af801285f0e48edcd5f092a3f96dcc838a4a5ef2d4aefc8f528ef49e8b04ffc11ccab4e9b524546a3e3346444ceda04a343f41f8593ba4cbf65c0080cce3e42279a8ff57763ba1a5894be112e23671d97d170d0b96f289331d1e876588f10ba732a2d38ce5ee2f35e7b860d53eb05147e4b1a114dfc06111506032b49d5889995a1294a80deea45f997cc096b91694546ce5fae7308f8ccdc19ec6e637c93ec82dada1902aa336b27e81f9d5cc668f899f1d698f9da7e57676a871da1a0503113a496683246500605395faf0e43367ee1ddf2c857fb901f35db4df64453a0183f3460fbc61db2f30a09ea56fa23bc883c9bbe5fabcfbb53cb5864bf2ea98f37573ee4717acdf28364bf867c62e4bc939a6d4f7f8f8af38d28816359d60977c6edd1570a9032ff6dc36602facd0022e6536312ac975ea57e8aa435f1cfe8faa68ffab5e26c8ab066ecbf9445efa81489b746ea86fecc96dad06471969f3b74ba549de0f3f355272d2350345eb31580a7414033a7d273224aa6341d887ef5e00f02bc125b578d5c4dc083385aed09070e72c53b2894026c4a7d39693014738a81a870f8a5c6f78f8edd1d626deccab67b3d71a30e1b307ec160e66e742908fb6d87973d5c6f3a1d2e840bddb515c6b839f92920d66f5841288a20077abf66ad80c60ab2a66c94c578fae787dd400a774850e7d29bf480ad5e3dd36664e4006e56e73e8037ed4ae3370a465ea92e0764d7d7b60de2483cf336fcab0d89a150dd9c401f43da8c584e1b6b6495cef96acc6df5cebaae6f1d1080df371bb2f22db18164247424853c8b1f69db2398bda653d37d216a643bd0acdb0221f218a09c618ccade2b945b8fed71b2cb5566b8feeb062cd2b0a591479d4838cf803e59aa4523852142bccf5ddc02c5cb40b1f2ac152a15e008d6f9cc800c71c3c413fcf082d006b9372ae7503f0d9ca7419819f195609d1d9d0197c0bfc6f60e336010f61e9da4e0e0316b27bbb24b59c8551595b18af61908a08f6b064748e28ac4505f91c29fbaee62bc7f8bf14d3717f2c0f96c5854ec8f178d2c3b95c330133cf4e1a68ef6e19dd129afd95b0d3e75f0a85bbd30cba04674c5e54c6b441c0398c4fab3eb6c3974e0df2b3baa7c73b35514739717fcc381a4d0787c9dab0d422e23bc6e69f06e28a753025dd16eb9f64c11b5208180bb1ff516ac2072e20fcad7d7e643e44788d857ec435a58e3771abe4b1c2ff8f8db6bfb19e9d9b8194991e328118ad86466815529b244d77605afcacfb36bf0431938a9db9cdf1a598a4622578aaeb93a465ded6ede4b6b19cdb61030d8e956f6d9c846bb854a6cd7da54030580bbf219cf958304b8b33d448f8011ff6dd8c1b10db9d84c888c44bc2299a7d1669ff7feb22f055a20a72b0ccf954c2ccf64fa01fd65e90e37e07035521b8292a69d245a029f0ee158cf755bfdc2311b1162378d049201c3a2ece3865c290adbaf4d7fd84ee8af1f2f9fe1a1ca0e0bf281d6e6170c8338d6af6f2502d234d7c44320f087d904ee3d655f2b429cadc6ea7be4b58cbf6f2fdc953ef822ce16336f44b6209ea5340e0b90df74892da08ab865753ad97e9ae2e7e0e678a7576967fc3d1df1ec39f82538cd1e0eb0058254a0f4c188ac93a3c4343d9266e889ea5abaed8e4d4d657e2ea51a7eb1028bf64c6a6a2534f2ad3d024913914d30e09e91b996e430d826fe506bd4ced19466d06dfe2d933069b3bbcd28e44aed5aebae47a76bfe1420a1b79b0b7e0b6f2d96603f352a68a010f4f7521fffa229ea408770b7913eece629b9bacc3180aa32ede022b2bba2854e26cbb922346daf8ef5dc4a474b9cf2d13e7a43e484b2b72dbc3b0b3c7507f7208c4ce14542c657dd2315d58a001d977600d7682c3fd3a8106ac512625aa883b703164cf22d37978678f79ad9615d013d93fa03e12a89c2b8ea2ea902c22cc90acf7d4bc0ac0425b0b4fe2fbdb269727a0b18433e767ffa380464f113940fe5e8e1cc93f5b7ff7e9852d851eab9e924bdc1a8272a156e807be7658a0013885c8440d1f941d31f5447fbbbaa20e93697510d6c90185c0751ee6e36686f5c0221b903ed917168f2c252aa8600986655a386ee4d69684bff665024fc8eb02642a2bb7898df262431351855ddd84f8d58a706e5e909b2569bb03410659823088ff7b8014ce7045df1ddee1f32ac43a234718bde037edacd5de4a300b66df31278fd65c4d01fa9a3b5b3d5de282ec1bc7b53b770af96addc9a829bc723f0424d218723d8d432aadda1fa4db6c424288d6f42ed64a2d66342b3b73e0ee36f89fd6387f6b86037a3754375128ddf044c8cb0645a68750db530644507519ca7e639fa0bd41bc4a82e0fc4b9901433379a2be9151878e9314cf9e33fdae04442388ef02ce322046877b579dbcc9625ab4b8909bc2dbb129ee8708fde16aaca9522e84d1855ba04b72b17b2c4127492786b1b683bbbea2c9de87cd184e8caff3cc68fc657d066bf59d00934b19d62fa5a82de0e259d3717d18619d36f29b8a23ff96d6ee9a8a5e5244cb22a9b75f43dab1cdb759d69d51324ce791fd9aa748c47904f362609cd61a2c8f83230691684080e262af2a9c502243fc5b262dea42e3b32a5a0c766996c6ce8e58e20c18b1103b1b204a86f8dad3d1c4a1cf7b742d26f7150e538b8472d918f99b778e4db948b475a20618324f3b1c17a655b2f84979fa000042e0e669222ee95f0652973274337ef2ab345270c4ec8f58bb6a1e992c6c623b9a7a0c562e22959e16dcf342ed2a6e0db94537bc2c71169bf836563afd0d1f84ea805cf52eeaef53d39083a5c128dc5e0f9f3f764887a56cdb61414438b723094bb805a1ad71be494b4a6e00b93a77c9873aebdea218991b4c1a3db65b6c3e5a8e5c348a005aa60aebca724e5c234718cc9f46d109392280f1f927fb44d58deb05fe24fb762ec7776b50657b95a60a544fe69456a8f0185d6502d802ba9a9f044c649a1efbd81b61f93743fd00aa9e1fcc3a41dd6622b17f0f2a4e440dd840f065d4e00d1a805fb461dea92a339eef82819928e08138db43f971a60deb3cb756757fddbe90c97c674f11d8bd98361b75c9bb632b485cde46bc9a7baccf2d38816290f56e68fe168b38bcbd5d331d0bb5cbfe139169930d907a57b72dce347fdc84b5f1953c3818c6fcaadd939284ff58d96b151b0c6b0688d5623a845d13b3cc50e6b6758c6e20c09e699f1da042079703724cc50c89ccae8814fc6325f9486ddcc1530f2163b3ca531e7768406ced4593bd4f80aa2f6e96b657ded6a1d4330bdfbc20c26559dd872804e05c2f72e4bbda5280b64ac37c3d564ed24c12c9f239f52ba1d0490d6ddd235cd1e8427ce11f05db6724bf4c38db50b34b6c93003484795aa82e44daee06c7c437373701e20da1005e9e19108e020a09358be45e0e75e6d2877ac3ad1afb22724644b09c5507da36ab2a86fbe733d662992161b3e081e7ad32468bc3caf416b6edf7e96e951c57dfbd8c1f02ae2a6d76c692e4042c8243d092d09d020315485952b6be248890e485e2918109d80cbc69b385135e7ceaf90867d566dcc9ed73f676d9ebd5b1158c340a893e0681cd5b90af445663bb915f2e8250146188077726afa52bddcf60ba016eadf72346c14b37ea1883d27bdb3ec738d8554bfee53a7fb8464d360a1f2b5ece97a80442bf8cc1cd7ad12d018e885df4e488bab14848b0425bd6593821eaeaa25c437c31807dcc63e87e1874d4609dc90872a2bc2e6369d8aaa4f0d24cf0aa4e80891f8224e7441a0d042c8045a2f1a8be6f3ee8751228517f2062709bbb97acc4f2fb9a04f46d74e77a82f397e9469fef9a48d316ac2a01bb66011492f00c8461bc0f3cd330914214bb9f79f81097f61314dd2a8bb0bdea15abf9cd5f749aba9b78b0814e2d273fb917d1ee1a0c3d3fd157f149ab1fe412d105e5f84bb8d368863a8f9e46d0b5cb3c0153424c566748d1f4e49221f15114d373f0338f8739d9d59aa0a88abdd45953c72e8b2a18011601f72e45c3f59e5b942c7e144bc3f24ab30aaab1d477b0de698522c622cdc22a8e97b82c6c278d4b7d52b9f88abdd3c98a50f9e70845814eda06f360527e15129ddbf3a058721e967841e875af09d64df341a077a3c40f450763500dd69107b1e04e30a2c5660827f578e726951d43ad118dcf02432f7a4fc69a6733a24b52f13cef58b9639aa972c29c1636ebb398b42d9d889086a01b71c4d555ea56e0b1746ed4d32291d3c3aa8b3f2438eb9b64d68d8a706ae5f2c37944146a713cff39ba25db537324784cf03296f97bc34ddacd00d2b0c2f4861cbaefc4832e68bbc95931d57cb222fa557c5e7efc28b6742298e5882c67afe516ddce9cc92c7b3f7b849471d0da1b41e119308b503efb01c196bf8d41156098a162c6d95732193c08c09b72ebcf56def7c618f105287936d32d62dc9ced3a2ad2d3116d25046f8ecb22aa1111702f9c34a5e3dee584e7ee86ff4f7940927cf7312fd3abc338b04259a67e384f1ece00763057450bb7131ef0cdf217768c721d061dd7096efc9afd5199866b49cc3d02032dbcdf672a55b5fca1b172faaa896eb57ce4a6949bb917d56be8cb6ce46db0a3c45a7ab87215343a03ea1f998d944d1b74729aa429d9bcc0f611afbda6472eabb735d0bc0632687b6f3de3330bcba873a9d899ed202910e3233cad46509e9f0e2b445508967a78e11f85bae5a1e5c382069b4eee75d146a7f452f9dbe461e65725ef1abe7b56c2e2f51ce238afee46242b669b6e6e381a54bf30ea1126ddc19257f3ea8f9ce1ed9aec6c38285ad33a39a07a4db40ebb7fb2cd8689252377b11da1722c4322e3c2a81eddefb590caa53cf7c386b2cb23f9a578ae1d3389c9ec81e287a46ee5b38ec3bbc9ec99b1ad7e020179d5f6cbd40121e1dcc698cc76824ab0c5d3c9f8cac5c5bc09b985186445673ceff701271818ab309e5d41cb565285416c58e70b845d2d928b66785b005506c7fb5e071e6c929be2de4d6385962efadcbf5bc3eee29d63e0880c6c351920eec8f4b299f7a7f3443ad2354de11d1a0ce8b3694ed68f949da1292685c43ceb20c1e15c7be2efc518b5e51a733156bc3fa71c1d9b6bceb97c611410e4eaf130440f295e34544ce8b4cb5db6fb9aaff94a49c1dddd3c66a9369f0bd094e603d6cb307817f342c7b6d3579677335084ad2cfff982a390a81da2a23eaa92a386427dd6ec017de226be04e44b6cd1964a10030943cabb010da9cb736f649f2703e304d9f95cec6826310dfe4423c27ae5398fb99dfa07ce1a39dffd2f5e7cb502e6124ae7ee5b9a0813cc0ee3075dd12d2ea551e52fa0c05c0b2341281713619dc9eb9f35567863a84590385e897fd5a45eb1ad67a652bf7b206856d03e25d6e83098e4ac2f357740487f1c5113d74e82737b4694ab68632d01453504e94314077ffb99e9c14d62727dfcd187692b1f1996f49d4a044faa8a6df9f2ef26c6712632486f9982d66c8ca1bbf298f1768d4f1c1918f7ace110f892014730dd369920457c3c9ffaa4d62c99afd4a400deead078ea7b697b1f819ea4e90fcb60d671153f9a68e9313c7e866ad46c06923633e3afdfd7a9709230bc72de18f767c865741ebe5d42b3dca7cdbe69de122b1846ff79230efa4484ae2de14304f0394163d766672985f720e402d6337c4badbd6d81c9bc6d5b2dece1c39065208ce50a504ddef5946d618bcbe6841454a852e2b9aa879e91c3102481680e003d73647097fa9aafa74274408e191029a692f361b17b57b2656e3b0d8600df225620f6530d6bd9e95c4729111281b9dced0048e5344391315bbae667073de1cc62a49f658854eb0b9c99b694919cd41def945a8e5162d02618e4e25e6b9dee3ad68fae01dbd0b144c4f518b99ad1943f79244e1d55fac227ce64de226d450978aae7b72639aa623cbab901ab02423134b28eb8536db5173ff1fd7b7db92eea28b9fcb4d3fd651b2911854ee29c317244f73d18e814d00f100d7338c52666bfba5550d4849298e0c8aa5a02b290f594a10623a577e1e7483641b11139a409eb86621e91efd41d803176d7d7ae2087324470414ea08818b8c9fdbd439b32b6c6f6e795ffafa43d7efe9d742cea50ef0cfc415a94dcdaa4e4dda079c02af85fb438fc9660a997a0591d14c10bfce2ed965c89aa5d8d240b17416715b2d4d9c3226241fcd11bce4550290968975a88f1388cdf07cfb01a52aca8eff67fed6647945d8f78f2cfd38142840b893e3e1553c016a82a6ac38808cd1b978231a6bf9432093f409eba0bb741be609cad5097044e0351b5e7352938c7ec6a813d30bfe68f5dc4a6414094fd6c1a3c246f686f165ef90d1a2fbfb755c06214cd72553fdf7047eafd7e14c06507fd7413513f6840c804747de0e714b049c0772f3d49cb0c3bc1f101ffca363b7b59e4ac78cad7735783088d9bf0079c03962ab8bf35906b47f63c7498664462ec389c49ddcb9baa771eecaadd01c57c53f12b912f527090e072d64443260c800c241a0c48343b01610ab58057fb4aa29ffded84a2c9557f140229af1d0ace47cbe859d1e54cf54a7ebc214f9412e366c1071459303e3342371b5a3b0b5cb9db776903863add18678587d9006e8bb6013352f886f40c6aaee950bfab55aa15b2302e26c9ac23104ec6d56575070e1b02cf11492e87cb9e92c2d82cbf9ed716030ed6e08910fdd035db4851ef9c30ed6cbb15a39758396e7d9a9db10b3bd7b773b9fba188980f6ff892f0a9f8744550e41730412d39b2d28d545c08e00edab581007240a8293af39206bfd40acae83d01b9cdbc9fd7b8a6c5042080c853c442d1021559ab4137c7c8e56b64c67f5d643db7eaf5ef027f64af28bf26f855d4ec2d7958b8175be7ddf07e0f50bf7104234602f44fdbd8cdc8c9c8b394dfad995d27a057b3c5364a0666b59544897fcb598e46b0d17021b545e0731dd70fe30126cb7422d6f3ea06c06f7bad8351731a448bde4af90b5c30c9d8f030f43c478c10f5c06e2b436769b93d827342c9a3e0c5b3dda5f44b21968d026cc75832507059f73d5fb2d6331360e6f688ed59d53509a07e334075600718392b6d95184f3c266c89f7e3d0a0c8241d2cd9f689ce92dd763103b972dfdc78c42c2fb87c7c060ba6681b70e157174e361245823650fe64ea321d5b32151852524ba4089a07ad03f9b60e0dcff19d07255bb5cb2a141cb6ec01f7067b2fd243fb5f667e9dea5dfcf06cbd46ff68cff24a295b83fd8c9b98780747785d12366a2c1f361e02a54e0a398d5ffa090d3373831cb07c3dff08186b0871e46dd32a0fa369d85cd80b38920d16aa7d9bff4d845014b360750723ebe9014a42887f6d3f625d73a3825e608c6d9518a34b778254a4dbe61a8397541fa3a46ea0c2a2e85ae704029265b9e3878b2718acfc632669a7e2f0bbb7511409b6e7ea4c62983651d926544b9f164f193beae53629f9d1dad54315a5b84a905587c3e9ea869f3ff36532c0c85df0991035ad42b5700a86616e42f48d22a29be0def0df1304e3dc22b1cb12cbd2022a477123660d440e4e72dda32563b7a0d76efc94119b90a20641e8dd74b379673016b3af065a21930fd4db4d296f38e1aedf8cfc4441555c278c22a89198914647f66b5b691a1ba1f47c0d5ea586b6606f40d6209042d701a4bea08c8c257c2ae949873862681472fc69c7539c2410834fe0ea77ddc1c6e513e6bc10514010b83bd928932a360e491cde9cec2dc4f61beeb8867500901156234bffb1e9b5b5d2730667642f029023f20d880f9299d0a419ef6fab157204550891bc53fd7a2fe0ba8da50b31c4b701233435e2d5cebc596e30efabcde6cd8424b1c8f29e45ef03a78f9f0d3564bc891e53d0a481cd80c50053454d65aebffbfb61c3c8ff3706b631a0116811ff4323351a5822e45092d0831af89a4939e459882b68d10cc38a39e96fed0c4e5b9a36036cbca7a7c36d6ba21057f57d9088c17a4f34b2984c17b6d7bfe8d679e7f34ad35bb81ec2675cff4c851eebf71feaf1982f12b05bb70550695487904012ae7b0c6bb855f354676a3ac57bb00930431093ef86a3bb2b3a54672828e5092d8361beb6a282b0607f22c7ce39427caa0cf718dc5c8b261c5df17704499ece334134180c92a0d2c4f42bceaceb7e5cd4a3afb03f62be14d762effb48b9caf1c3011decae1ac09c26df8121008d34e53426b6478fe25cf4c9cf72577f9e975445b2b80bbc4d8ec82f9cfd2941a05b29cf3f0cabcd06a5479d3551f6f638338e75b61beb941d0a85aa02306eb1e0c6a9b7d31dd7187bf597c39369c8ae278d254268055d1a9e8a93b3716b29d2cc496ba7adc8bb7a658892cc609ed86a8b35275ff9106287ea5efce0c5b1f9b185e63efa1795d5ceabc9114e1702f84f58a15d71bde0b029dd357664fbdd6a2bc4fdab7e4335243f88f12a032f495dc541eb4549e83bdb989116bcbf32fa2e15b1d3748635de6ef60737051b56e22893e4138bcae2ffd3c53ad9b91583b96a197be06c5cc102501cc188bbfdda3532a3ce3ad8fd513f5cbc71bf125dc3262e98183a69302ce46a3bce31c460b3e2774b8b72c84315e0e8752eaf441a52a0586dccb1d6f7bd96982f73eed348deb43ca5d825d6edcf8da5be2d742e974209acc7aeed11399b5e3ca131a5c4e2647592ec22fb96ab552cd6916482b189b69ef25f7fdd9c097d89ac840e1120e134de1e11179e6c11ff163ab13d5b33db56ee148c90d567f6084923254de6c64f5c37113ef6c47528bb7494ab76612d51c432b903694227b9235c30987859e34fd0928bf2caab6b97503d933111d38f8b16b6b1b689e6a31bad6389792ba9adc610f9ccd74f9d5a0d1c4ea637c521732956e07d146ccb828f16a4959eeecc5f0ad69bd7eda47dba35ebf4c8b0f92d90413ea5219efe5cdf28ba5dab212a569cb2664ccaf60ed041120f5a847b6adf6fb2f2a9879252b7beab7efbebeec713531f23b83683527d7c5c9e4d9a805fb524dacd2317108a2c74f5580926bc871928d9411fd12a260d364febbe32d29fb845afe4fbb3e6cd94403c6f28f7a37b024b614520f20661631fbb6ad30a9fe34c0381e2b43198d0f72472915003474f8e7d8ddbc5245dc8637c8acfe3d3f5b260f6ed1e1eabafeebefc9caf0f2b8f774406d67441af0ab182bb14556c767e7c0aaf5632746f70984bfe2cdb6192ecef6aa2071eef05989a3383db617a462afb47f2390e1bee547ebc2159c086e2d78c87cd2fff7951c8970b8def8838c10f66a9f67638eef6e2896892e206d2061aa8c32248fce48466b67dd42107d2278c5cf9171506377104c18af1858c7750932f90559dbee744a5275b9c68ba47aa283023e575475f1d5abd1f041b578d5f134684a6351a029521e74a1f5650b8334a939fc7ea5536af15ddd10d1b489ddccfa9f40a237ded6752452ae2550f6aa601b5f168925f9905febcd0bb63ca226afe778c86bc97a9d365f81c757fbf5bfe1585bddde0e76c991b76b356d14ca00e3ffddfd7d604cd006c19235e9205b987e99a7ae6b51f57b3847f92b359491f1b592cfd6391e0fafaf520cee55a55b3a5b305c5ab0fa591b5578cdf8efd0bde3e6f4813bda1f7c418e06431ef7f973e96363ec780a21c8d1181315113261d48207ab490fec20435e63c17d9167298f65c24a3d64984e6bafcffadcb29d6558ec25a914eaa0edd6ed7ae17cdbea81856b6cf1eb4dbf94fe1827c5d4d467c284e2f5f4c45017ada3c27ecc28e4044937ff920b5c0bfc1efd283b879066db96148e3e56f3f761c61ec390256ae1e075b6394f4150c26055dede31c63153ed7cfcc86e303ea2b628fc0f6fe4bcf996356c2f5fd7f8412189e6854a1e5bc2dfcd482b4a8edb85bb35c66735f17e085c93517ff0ba9a5d5c1f5f9abdb890ad7d800d61e7876e73563966b177b8bb57b5ab4cb96e07e36654c0ca4ddafa636772fe9a095f967888bd1cba31b345b8248515f5deea2021f89ff0c8a1c7663f32da35f75aa7052fd3eb2a1ee2728db8a16e682f8b669b292a990707af739afefb97d08bc904d1965b8d8cf4ebef3a965ff39b356eaa3683a3f2b3694c005e0dc2d5184de44c233357361e6d37482c690f2d3a21f4f77f80b3e822de5a2916af8bc2ec9d8efae11698ef5e7296f7796a42b6022762ff2d00c8606ec10b687b772400597cbc386e2982967ac841f9d39c36d115a7e8d2241505e1d8c0d64831febcec8ab62694f28b267a68b80e150a99aabc5d09328a82afb07f2a47c3fb89aec4aed278b6a568c433ebfa31bd5189fde9562a869d0cea3e5c4a9ea0111df2029f465a2dbb93f5a9b1e10a0ac9db206c60a1dc2daa24a7ef83f461bc39019a48ff48c435393c55fea10b5d0ffce0ff4738e1fa2dbee47ae64baadb4004dd03ed37c8dabaaaecffa2eb34dd03d3ac7cb6add9cb1545b22b8462f2af9b3633d121d8b2772eabd8ec3451904a91244f063c1d0bbd505ff4f0637d2a4bf36e13fd109a4dd2e14619741e14176e49243e417728183bcb10ca0c74c4a61641b05a8e5c597f48d23d462de2f8d8d9599ca73715da25834368de586bdebc83bd68cce8b53c99c5a62b77dc03ab79d6855363db26a47c175f82be6453e6211f94e872e39ec4a38544319bf49deb7b545ef0baba31c5bb0df567c044833d93d745a5fb3245feac6933ae02024a81a267154f0d60e7d0bb3262989879ca653185992bc445f3ca3ea717d0407b2f1fb823f330dc3cb064671ffeb34387eb647c4e73f3e3e1d6e51618dc32a65749f4e049f94182c529678b31877d6d9c40a58598b3044a99cd6af02537f83dd1281dd572f5822064a15045e6386c4fb6f60326f465c8dccd791c82b4a74e6b39f9214686d4ba9f3d5c4134c026b1aa219f19c7beac6fd50feeaae88163b494b90640f4db9e13d3e30d3083917b7255df7a4f3afbb28af122f987ecedc70ffbade2defd6a2f832cb16ee5c4e5620dd8d08a11f3866315d96c24e03edb1a08aefeb7e17252aa3071f68f6b5cd0903e89c713818af4fcb0f0256157b0c98f8b8c52ea8d6c350eae84554a29a1bcc71a2d8fc492910ca9b73fe8447d9b44bc726f735568ec808226d0310ca9aa48c5049fe31081c261e6b34e376d5a5a1d206297bbd463c58d4709ab369977f0b7a358924225abdd6df33d76326ff661d3f24068e220eb6f241b4cdeefbff3363e5618a0fe4019c517af560a026b9bdba5206e3af773c94385767ab5316a4669cfec44c8890d8f80a575aee0fde2e95560e532793b0792b002589b6593d760012d23ecdbf520893798d552947a5f0f0b1724a17393a840fb976a60e95867083eaf2990859710bf4034381f65b917e09d34b8ec714b4e5a88ddc6d19dc04f6771420f98a4613772aefa066128753bedb14e81098cd81583ecb196576132b1e6874903ecf181b48b9cd4805b636e061b17e8b71a7ccb192571928f37740ea5fece4b1885b98311093506347848169e2ed80f8134c5d23eb8dd7930dcdf65493efcb77ab404265d77dab66bc08cae6e4491eb5abe9b6a79464b5348c713fd12d08d315c5f8468bdb94641dc9848aaba696cffb90a136cdbc7bfe2b858752c71e46427b1af563f0af0b94628ebf65b7a96b375e08a2c2680d0c7d2767f31678e60917c04a4e401dff6fb59448c2c90a63786713ed832513ed8a2e78ce893b268f213d1c9c04ab22959d8a4c321785cc8ea61d856297203181a13ff930ee1bf612bb31ce09bbb7378f93b218d475c05013c062d2df6602d190ac1112ac0b21f51008af3d8905d60ff123040eae33e3e4640ee418a507223cf1cfe4fc9050812c78b5c74980604e279188dbb6e129580f7f38373bbdc4505fabb7d664565dc594a4392e08179143a6582e977601809ad7a8d6f0ec1f97f2c17d981b9678f2ec8f14188e49329ed8591205f18f7fb01323cfa6b18abcc29161c6bde0cf81b36a44234713f587152603770f679a6f4dd23f83b7ae3471807437124c0d186e0a950f39c9d69d8fa88ae9f9d289b1114e7f64624731a06bd3723a8947ecfe966edada78bfb051c1297b93729d0704e9334d8e0ed16c27508dec8743008246d3919b37b55fa3949119b2a5a1013f3a2dddeb59cb3370155169c60013c430038aad4edf3c2db5d322fb901c7cbc3257d497df51c2fd683e370effa7ae0e343e93534d1d6d8226f296a3b38e4b8355e5050bc40093fd2d674e2896b7685ae12c1765df93e11fe06d028a1001f5d9bf0f7cb4642d8fd333ca64ee9262ce5866c71f21d3b53dfb58bbaefbdba03990772584f894a18b1015c8c0ffe0cfe538b4226ce38122864804b440bad4933cab77926ad5f170ffeeab93df096e11aac3037fe197ef9358cc95125356e17ba0a109ee3c25f8313eab82dec1686507969d8988e03606a0e6dd0e765d274ae2b7677f803403be2022317a4fd2af1d6be14602b2a9713f6518a034734bffc2ba1b2c00a4c981f5a98b18063b19d2f6233faaedc758f8df25cc7b1e5d95e94c917ccdc47bc8b76be1759e5d7dd72d4a333f96a21001b9d7ad6cdf915d8b37dfa80d8ffabfcac5b43f92f240ecd8592ed277dff3f5f0db2fa8ec5b7334640dae8c7971fb4802deb9555c6dd09332fb9a2f20f95b23731e6264cfe227896f3b9a87bab70f88db4489248c1b37d0b52f59bb84acf31301e4f19c565fea3d4a593451adb6ce6d056d984b4cd27160cc52b8b821f5bdf8551115866e0fd00b24ffd20f51fa248aece69095c8763a59e9f519eacc224dbab63f1cfa1c3325a639dcf532dee2a29ae90e149083586321b265f1ef90788bc75b1bd4c4f0fafd1bd97ca09dcbda6fa2659722aed93e9076f009ec67055639caacfc837a20392643a537b3588906d2e72cac0bcc9b36a7c1fd34c5f075b697b81ee2b5c491cd681a926408b8628bb6ea02d979ceabbeb38503ffeacc276c8631f70322ba5674d20c5e859dc953f2cdded365a9f8f755b946d4d18f1d5622e82b777de2cee269281c7f4a909d79f9b1535cbef0f434acfec20c1bd113b12ec65dddeeb8bdf60c564b398992f20976621f999fbd09d35354c3d3d547add00623733ed78f8b50b62e556e9b7b2c97c4f0487b6a565f3049f57d61bace72f1bcf7ccab29896264011bfd5d3810828e1dc560ab3b68065865cc9a25f906759ce9daf633ab4cf97219014a448785bcad98a1b55f8742d0f77b51848d72f490ab161f5553213ce175f600b72238514bbf88d6654b4909c2f2319f53e00686021a6b61b233d2ac2f2602e1291d5ca96623bb11227b5086532ad2a1cbcfbbe376cf878aec6a2518b84251e90234ff1815de2d16504b3b6a9fa448dd383fb8c218f8a0a82e65fbf5eb7cfd6a39ad473793e3913743f7c0f727410fa8b79ae79a2a656218ef12514e5f4efe23dca2965e93894f2fef01938573987c2fa30b5051359e6d6e09eda6037f3d4b3b7c867b8abb71894ae0660b87c9043c11c905479b446569f0b919901eeb0ae572b784a37c17514f5da2796c18ebe510ccf6651b02b05cef00edc6c92987dee0ca7c040eb553b75b6ada4730d8ca1bc080526bdaaaf446fb5a701d277313b1f5d4e46d020f648c276ae393a507739c971c7e241731999b5f842b2c60a798fc8d7c6034f611fdc07aaadee726737c17e9884c5bc880e3a2ee353143cdca609f9ab18247253a17b73cf83de892189f50024479039e7b4acc27b1f213d6165b0cff39d58b01c9b11ed60d735a48bbbe693ca2b066d12f83ec3f8477711f03cb88b64aa568cdc79eeb310d4bfbf880a6e1ccd6be83869a7c6eda80e8aa23abea5ef65a246f1b7070524fd1b7691ec9f442ea173fdaa545631fceee0947753cea7a191f7b4ea0327ae0fa2e4b55d6f9a5bc921730f99833301f3dfee4ea23a96ee1e39c161a0a664444d4aafbd1aeb8d30f0fc99f6e6cffb753d6ee88e80e472be4f0cb6378c461f9d08684983e9372dad1fdc2ae0d2c6564b4a5e0ff7a489329b2374e92cc6c71df9e1ccbca850346b9b966b05046508043f9c6bfe417a0b8f1813404dd36168b44708767d08aa7f6206d4454ba8d6b157f1e15dac73b1248d3e37b451c7e649b8dc8e0fbe26e26d70acfba809a44c2086b1e1add5b191606fdd9206d29e3a82cb2c4215aa86b00afb7732bb642b212781bbda5773a9fd4d0e70b08d7c08927b8d80d5db7980aff0ce2689d3dbca351cfadad864ae3618cfba61ccc20eae4ed63b2d8eaff35afc5983d5e0a8419705625cb1ec98109e8f4c24d477776d292d8a3f2376e8ae30923e5155190bc512eae5bfc810ae2594215622c28e9072efb4f23d058981dcb2803b23cc688d9ddf023953f0eebf0c860746febe84748472654ca2da27d52365308d61a830be57aaf6120d80779c6e337198c6b44d061ceb367be3da7b06773f168f757d76a7c0a78c5f8f951ffd3cbf0f6a438a5421ac9eb40a74e0367af297ef2c8f3a70939f59ec548b8bf158c2c613e05c8a2813bf96f07e3760d50dc3529ee82cdd397d2f51d5554959b5db1a5790f7ec322db2812da48b61bc3299f1b716b295db35847f56d4b0581ba56dfdd58d6600a51e3a3b0d44c88e9b158f8fbe0acd6023e9cb6bc977ad6e6d970d4db0d91fd68feb5c4853c8ba17d9743d92705d89c83f383245dea8528d61013235c7d5a799cf06f82d87b4a21739bb583ff70da4efb39c91688ce6bfb2cf5188e3bea51fe5599eb65c70b946bbc4a57951d1ddb153a82ba79305428bc2a2a21e85a203ace53b152fb89089e161530890c653a15b70e9347e9cc44a05ed5ea8cfb3e77913d4b281f33b583a8bd826143b5177aae725e43eba222de4a34bf8371452413f1eaea71db8d680755a18b3b04049ac86e5a5052b4b602a34622e3fbacfc9ea95d848f6f6a59dd3e8d227a8aed406cde69d0f9d31d47bb447ccca2accf7ca525d77d786b3d966d0899f09a312e4d390177d05835df32bf80554be7983fecbb8c2a5c7b1ceee9b46e56debb2b7fca9dfa362c2ad85dbcfa7a3c34d25435a2858c7ec768147410e81e5b3d4e2067563548cb142ea41d9cf5b0f29145c20f8f30b635043f9d8cc877dd33ac5b7fbc8da589f6611ca4fe7dfc68886ff8c7baccebd253af4fad763cd9dab77be67fd93c7a5687a65bca47191e03e611d2e1b0ca046e17987a3c8774c527d50656cb7cd819999cd8730d44d58c18047328a341acead941d4dfcc53da029ef95216a5d0a440f9c19a14e75442d4ad033da69e912723d9e2f66b661f49234491e74aff7da690bfcec4a8e574c5c2637df61e2c98e5b76ab57eb2249884ef05bc0186a3e37b29ccc9f1b676ddc0cbe3be5a47bdc104f14d423cc70be9871725e809787ab493b3318d27bb553060c06c28f5fdba3280feb88d4c803e244a7b54e3f0f48ab0d63d5a2e448ffa7bbf58776d2ee94fafbcac93d44790733caa4bab632352b86e093565ae49c521d1413a32d455ca85072e7d4e4795248ddcead80a8068c1f68cbef6cf645cb67ed601b71704ba334f5dbac63b2cc82e6b0f2332be93e99068d50bf62edaa5e1de683253a8ef9cc94989c70d9f9f47fb7ce06a626e7271d2b97e20d22208c2446f83859bd0308729d14187c384fc51cb83ce6c49cec8142b6f9a9cbc8f97ad7afc6c42a445528b37c485e18ec96a456a8addb6937f6bd3dd07dcf93f6e7fb1e138cdc0b5a12c85ed07a091c34a366a09e9339a0da9f2f7d3a655285f3e5a9947835d5574c785506f6bdf0031c826c629cfa249ac8cce78d242b5ceca8212bae5bf4e2b8725e4cf5b7bb36e64f955cbf3bbadece781b53e581f91067872d85ed498c1d3068c9f66c84db65c21d541e748aadd0bdf45183c2856eed52638ad1303d89ffecc35ff4bbb027f34111694fce3bfea278266856612fea4abdeab77e65d4f2760a6c847afcd99bde13f8f96bfd48e462997b6519f80debfb9e787aadf592f79dab7bc72c9249874ba93a79c498763024f8234ffa13eac4441e1dc4b1d0db96bc6711991cc4f55bb783248f622e1eaf5ad8af2041577e324fef28bf8097e78b8b7eceda5557a3c64e567e7a3ef3c333807db332ce284f1bafeafc2ad57ed6acef20626701c4c343ee70af89a9afdd1585ec969189e8579c8da135b1afa112de1f2b240e3f920b4eb3c56be0d29d172c09fda9a2966f6b3785b1c312232e98f62b5a912942d4b88fd418a6ce359a16a362c3428cad9004aa186551e5b3b4089516fbcdc8379ed51b7da96c524ed426048f6f543fc79a35ff60e21aff7a6746302f2762af04e52039ee96d2ba7f002801e201b9e4506821186f624174cadb867526047a745ca0e627192b298e56d6f9c3c36afc577f6ab82cb9bbe3d08bfc79a722d74a6d25fd2f9f0569d60b82d45a92f81996de66b849765d52b3981f53199f0649200b45c4b9704fdb26d2167e4eeae4799d28023ebc6004cda512a20d15307009dbdbdeb1e673e72ef3591dc38ef56e577a013f369b98dea7f55a8403d7cb3a21ebfe4822457daaf5d27f3bd3b4ba471a1ef6078136e7aa0fd5bb82bdac6f6d2e47cf3d7f596b870b2e9156361122a6590c9a61f6de8192315c2b50ba934ba27fa9e31c1fce38be91bc6f529ae71ae8004bfb8bc75f53aef9a3b8090ff24071c904e362ca29872090f6e3bc2c26298fc1560daff9646248349d26bb2cdd7f6b86dec569e0a18a03366350156505abf6d01569cb7b7d32aef962c73ce9b76a1cc3fb4026157c153ce25e8fc33dd8b3973896f205962655f7a26b6f714a6d27cd40cf4dd11f09047c6438e8bf4207c6e150c0cc69a162d2b0db084028996f3e243ce4cd34f0367a9396bfd4ad8ef3862f6ebe06a3ccb06da09fac8be94dadfe3433ba59c705","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
