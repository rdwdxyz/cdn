<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67aa25a246e9de42979852eb7a2e03be5f7925f986219cec3bff2f2191a8f8680a54b5aa1e7724b84b9ce5681aa30f6805aad2732290d811b6815bfa9ac13ca81d298ee5563b0d4f245633a366f6d8586ac989932961542183db4459dc11897488af7042166560ed7786046d6ad070f7269a713e48d21721f5ae4c73fc522e4218718e9be07a5bab67a003e1428bf0672813938e3f40fd5c1d91fefd2110159f83b64eeba24ad08ae5fdee7113564a1bd18e49761797fc15a8c1f97b6498ecf8f13e209d1d5da8c0fdb0155fc7aa177961388c59c64d71da8b23e7f87d48404a5fbccb8a4397609593ab2e766bc81223cebb3a83ca849069c29d2f6bafa5a32f39436334a5c33c986d1800aa4315764ec0d274eac48f9e8fd807fe9b552af080a53f847bcb9f7eec370041cd1d900065d0a66d3a374cfa5aaf20afd77b25836a8feb67fd9be69dde11ad2161920d2af358738013f67c4928c6a9f17bbabd2633ea5753cfd77e35b15c699c72d313f2030f8f5db39adc8ecdb1138a39ac5fd023b72d351703f2b45795123a6a52700b23ca88894da9e0a6b1d94478e76a5bc838518c9704ade6e984fce61c734809fd86550f4c6cd716c246c950df90a4c6bfcb4d08508b5fc30fce5143d9adcda43eb10e2764e15cccb7fe713f75d13623f46dd6e8ad60d1cee3156dbceb85a8316337907dda26451fe7bbe74fe24fa8f4244de66f31a62ae66acacf007412d4592101a075a0b1f3ab40180de5625321b52dbc35bcac2c3c17f02b006e15e9e3d177a6fb1fea5de86e2dc1a5849e3fcf439db7927143f2628909220c9e762c0bd305fe03be15d3680309ac944b1c018c88649299060b3c660e7034a970aa04c9d644d4145b7ce5ceddfef59f33660e2d44a37b5eab7e4ffccc1f05147fb5c7dac30e88d37620809da6c420e912861b43929286492dd03f3afa29aea19aafac8a07dadd4e1a0de977bf3d45e224de6d11725ae0170bbb5e797344b10d3133de116e9a82b5518c54f592401d8438c462515ba188e26a3b11736a7b5e2ec39a93d37a02cee16e2093501293f805e45cd380f8fda73cc2061fc0e048423ddf7a519548246d4dafef4adf732500d4876228f2bba03b87b188b9ec24fa6b3794d26bd51ec3dcb905daabb3c314a9b640c3625dfb758796c5e3977e53e45860d7f21f29c88a03897653be2d4ab37d0124af2b60f6fb01ecf95b2ba6e9290cc2d4fd8fd94ae042a85831cb56b39f30526503785d3e9e17b788c2a55f665d38e0ab30405e2a18dee71a908b2dc29cf1f3ff1ce833f21add6e7a575f5399e59919157b6edf933dbd4e2ee608fb73ab17c6f78bd59c880c1c3aacc349330dde2490a051ca5e00013cf0126da025469b06801f121cc190980bd1827fc3837d928c88cfb2fcf3cf9ae8d021b5c1de0f16c99205b9e30e84a9fb99981aa1e79c65ed06fa19225450d71c47591bfd7493ebcf6066b60c06fc1a77bf82f7a08f68ad3970e5bcfb16ff4a514742c1433ccbd003bad7be8e33a4818100f73e14e0a610caaea8087165f49e90b35b4a6c0ac10672d6c61713d6a5d428542436b8d0887d52489216c047624cb7aec3138ec71feab7c05e307da57ab039b514b8de63a561d2e78902bd31366ae0a28b1a4e0f910e875cd88982109d6c8254851fa3747e0c72f78a088b9625673336828a4e88b9a019eb83bb67673af1a1b0fd5c302097ce3f2611f1a0fb3797a778f78b2bd69606873408af4fbc98af5f158ad9a64cbb94e7c24f8254ac0197feaed06e0fc24cf2c6183699f282fef4b82a7d5ca9a9e0b364a8ebe4c7dd6c920347346970564d31648f4c3cd8f3c7fb7f2a0f620dcd5e6fa0d1225d976a6d78fc5c5b8d3ec9da30965b5a52f1ae15bb905a089bb26ad7b7f3fc57c70fd0ff9a9aa287d6ac060af84fe39dbc38ec26b92fddc95889de4e8732be7c6b2ef378d5c72066bf7a7863ca3b76b6e1ba1c95fb08f912e7777218d73a093a9ae108ad14c25989f4a048725bd896bc454a764fec124e78741238d36d3854a08fead9bba1bf18a61b36e1071334ae01dac6095fcdc946be51be2b171bfe9d9751b8696d6c224be981690ef6ab00ce8990ee9198199a11ab7b2407eff5df85ed1e4d96a77cbc0481bf4a19b9c8cf29520096bfabc304c63b9d8bfa6f1e1b2302116391cfd279b6f4c5a26829b6d9fc2e75cd6cf0ae3ccf8d7a95562d9a06a4317ba6fb09863aadcddd758db15b0de05bdb8c656b2d55cee75f431e5969866b0cb8b1129ec67000aa25fa560b928dee18f543e08f1ee4e3be2e9503d2e8426e3eeea0d53a35d0ba2585637e31e5ecfe1a8aabc9ce2a8922988bfd17bc14103981f90cebba70cb08b1cc2071c3956511d00b69f91182f09b26f1ba52a3c60a550f0d5c1f8a408c4791890ff5e8fc73d1115a1c090f66eb25dfe951ca16031dabc8884d1054a2cba773e54f1a7419d10ce73ede19fee5e2ec13f30ebba08838f1338df1cf6ccf5ed8247939e7693b4dd62f8e4c8148fc7b1172159587f8d3572846724e4db58945086a0938074c83335b62474220ee3f511c4457647c60ed5fbd00758a3e485847cf78467b17b910cd0817740645cafce26822d970c576efa76baae7619513234ad7a51ea48d216cf92472e392ee0fc42f429057337ecac447eb4181c27731a98ab69badcac34b8d3c31846b936813eb8ec1cd745c4fb1d872a97247538188d0d036818f76fa0759b1f0354908deb6a83ba7c1a62ffd8bb9ad7f6157cd18d3f1ac8d634706349cbab552f002732f28c42d508b2b15c977ef9bae8c2e642682cc2874deb6c9abab09868c0c903febe5e1488e6c5844463ae9948150e5a49e772d12f7f1d8ac9b98463a9e3aa8d376a1be29183912e42c9283fc989f79175e3963747845c29a7e3e9f890dde4885edfb8d16de733b1eda51fcae096647a0a1051ffbed2789bbc381b80b6c8f8d450f0a505d5c3875879ebc874394b4b828467ecc4333e98a74e10b811e349584730976f0c423eeb7ca8f804e1dd3e1f700c680fe9d3bfed0902b73dfe2b562f46b02f46cdc0363332709cc7eeeac8b37b25b3c4c07ced57d7f8d97a16909ad482429685f9bf1472b4f81cb651e8a93077b7f432376f649d32130090cb48fa6d4a97edad1a4e2a628ee7fe4e60ad2f127a279f90a1f71d41f4a4782e437048bdc1a4fb1c2ebc374d3c275f7cd0f81bda772607a8099910fbe1fd5060e1efae46e643ed8ebf3610866503933d489d13c84ef1c429f8a31c239ef52f33918cf6c6c9a8fd3396a5f58f8a010c043ef6c860b57c020096ef9c423ce199a370d5d6ba0ab45f0ec12e5201bb29d2b664c213f94ff85ad6a3ba92136edd34a3b914a4dd61e1a2011d8b5706aa165d468ade34c8e2874cf6cb2650427e2340fcdf4805e50b92938c080793d2b86da21d8b65a5738fb6b6ad27e2a1cc973ec7ea566a4beb76dc4d535b60994c25cea442f2b3549a8f747aa52e6128899e83f27332e435b823e25f909bae6caa3aa6a97569c5b8e8cd7faeb055e5118db3911a6d2e4c54f8220cd4f027bbec6b69894de7fd7db148557c77122a7463f0a1f3110ae1a63da6deaa41eed0a31ac6b29296bdede45ab7e998b297eda1a398ee4a87c7fbb9b1b02a477d8197d57f1c322273159a1783aa23c1e84e392d3e2e9c91af3988ce2ce6e533bfcc3a07a7d03294e6a793879e2033e367deed5598dffffe5c6fe5ee69442eec64c8795be5f9c098f9a989b8ea91e0e306cca7d393540d9750f325622f24b1c7c6c63cddcae180d5da55798f2db1b545bbac6d538cc5a5dce52af732f28636f1be58950c167b317849890b4f9e647c47b2e74425e92cadfc033c6068bdc5e94f13712cff01bce821fdb27b80dadb7f4ed3ac4bab1dc08c88a657c10e2879faee2f65f10874757a214af3f498563fcb60b9c6b40b24f48011d976de9ca1328e50903a21263672f0dba25e90e72d7a06870593f476b324e8b41b7e4fa4c780d881428d99ac634706ee1332b2e37d064a12eb6d87fda1e48e04a3e3772663270c2e655ca8fb3e3606ebc56cccb01d30536a480086bc51b5c07e3ed6d5edcfbbb7e3313e3ed44b9834ca954cc8d88675030cf6f0dbe4255b68b544a3373232a0bfec2f74712abe132cc25434ca9e864f6e512b9140046cdddf5fc8060b0881f65fe9dd92f529a2fc449e2ad15268f11331e72426c9b2506afe188785681b1949ff6f3695771c53fc5f44b7a07d4233e89323cc21ba74ebd387cfa15df7f8cdd1fc85f8aa2b937dc2f8795566eb79a7dee7629295e0845c263ea0d77e26a591ca9d7e91577be1d52665868002c9896a0878c222efec1c9427eb415c1043be37d8e6f800f2845847c5c9d7d81756864a97ba8c0249c9a387f74ae83ab94117b61f4861c246702615a48f161784916ce46311b7993e880267dc20382440b6cee6bb6a73e967a6a9d8238d8f8659d3f1b8cd3f2f93e1702e057232e83361e5c396c95f692a1da31bf2a08779584aa4e38ae1e61930cf1446b36d6d8485dfabcbffc22efabd475890c7a272062695f8a3c6edaca8869f3f3142edaa8352eb56a7b1806830f4fa22391fc964583316549b9121598e2b0af4c839b7e3bf4e315fc4da835f7a378a3116fceb02120d83d3752e264f8a7543de6bdac9344480d5ccf8bee1e9fe1bd49050d6ccf1a30c64ad75cec9962d019b15f159032fabcefe899874a01076539086b43f308397fc5379a7474b23c4286517e26174261db3fb39c104d0a618817153bda38310861f5e286b4fa88c1eff44e04e1340a328fefb852a7727c4f8b4afc35fb74eb8777f63923c5f50586f8309c88807f71948b6245bdb7ee22e3405be0ef6e5bf109eaf70ca8fc2d7f547847a5f5a9e4d7b77f6c631ea8136001f4ad534160babbafd2af2c6d5598c6c0b0b05612cc72ac5a287491ccdbe5111edce36e92d39141c182e41d3051bc1d5698ac63b5911a03a7165c483d78610fe0b319ca3389c9a3cccfbdaf13ebe9884a31a36a569287e62e1f9d7513e144084be8c218ee9470f81002c224c505db453a1598a7ab2c6a01eaab5d1e1017c18c4c45a14fee57a17dc17a197d2b43749c95544f0adf499dda281860053219672a3e41d7ae75ae4ed3f7d9ebd7b86c67ca427339eeeb65801dde0633a45f0e547795e874fb4f41614919921753cb196020c9762ce4995bf8ea777e7f29276a4ccd08ca71ab14d6537db2b002efb3513cf9ce9c095d6cdc57ec8b9bb8844da0463cea991a0f59f00405188365e6d872cc11aa826de451b4dc3835ae47c44e8243e3c750ee1552646a8865245d8a4b774ed762cc22665943942e1a15875bee8d1fdb2c968132ab6b1bdaaa84742b2f55441c486dd3d71bab55845d78bc96f20591114e90b4329d2097f75b5316e6038d8dc52ed14d42cce3f82e67ebfce0e8f9e3931b1bcd635097e25596a1996ba3e9a91a10251398d941cc5e74715842e168bd2a771c90447e497180fb09b0e95b58998dda7cb754dfd4c12b78a06a7fddb5a5087e6daf9a164d9fe6aa854a88f7b09d7b471e7c00e9ec27c5a728257598e9b5039ff8393b82710857bd08f418f83c84ee7ed8586827747114046864c6afd4020f6ed2ba1f80ae5ac682f6fd3509ebeb5a99ee1df7987ad5cdb08d54a2ffd805e3fd82a631ad6ca2711e047219d78dcb3d314aa489f82dee50d1017f846aec269b4541c97a9a0dfe024974cb5ec235369dbcc4be2213606971c1976727c840e6361f96de46078199de19eecd1bd2109c1bd49c786cf2265cbd7c1414b5ec1908fe453cff2aaa533b22f9fa824e6b917a0aab96fb9fef85732a95a0eb86832d4b59e8c69cebbfbcaf25fbff3a425b66a57dbb72288f6a1fa03ca85f3a76806d4c3dfd2b556e02428a1c18cb56082d4e28577391d9e0cb98cc50aa1cff9985d049086467e1fd13db53796da08566e4b98cbb2ce889c6c69f2cc89b06c20bc90c9f856677cb3a5f431bfc0f0267f73ee10850765693d228f6e293adb23a12e62747d78cd5d9169885fa935a9efbdd55203e0dc6693739a82cad16ab0190c7cdec7519e2cf42175a6a7e0ea4d4ec8c350eb4fbef7f23d8389b804b6f9b8ba3fa27b831f60de7c1dd926ee2b24ac25aba436e79d008a406250dfde48557361baaab564489d360eb98e691f3947456f8c9db698c498838401d65ec256b0a0f263f0ecf050af9de8e50bb3020eee52575146c8c4adb0866488df85b24e4b946abd0f4ac418655becae57709912a37904e9f17b93f7e221a87f362175e4da7d43cab14a94e8514c8cd6dbddc3d539d0a642c808e82fbf7f60d47792739be6e900d9eb488a5bae09e38f9efa4a1b9bcf42abf370208163d23ab48391b95f57737914e119e11e44c1e639b87d1139f380032ca705076b1645e55d17995ed8d44b5cb8dac607c49521235d9ef64dd6ffa4a1bc7d716d69a6e04931c37bc42778ce4072ae29ec6d5a86ba8cc19c63dd89d5a1d02f2f30d8a790630e18619363001db3e3124b09b68256abba5df44df47b3522460960303cf255a0fd63d045b7390eac87506a0bc5995298fd72393707124f11ce80675b29315c464f5f4ba983f8cfc5d489c09351bd864cc56186ed4feb3197ee2311ac1fa82d3fb58b898867a81837e435213d174ead69aad10e6163145d25df8f2d88752a89c10f3bef1ffbc38c57f9db9c9166e7dfd78f9ab0e4e49057d714ae14f0f6e3ddac61cc62acc8fdef3a7dbbbdc8b5243afec410e98c5585230b1d8678c72830077fd717e88e77d4a793cb94436494675bb46985fb608194e227a079877aa4688a2c91d2629ef0317cebb496a1a99820bfa9834e7deec114a3b2dd476e7a8a9cfa827cd70853e030eda5314c4f1e057ba40a0a8064b9f3ea332356c744e8510c5d4a84c25f360b3dae6d38d26adb885805d94205b1d16cbf88666ac682e3b143bc900489a12d11fdce81fe368d7e256bf01f6d4e236070dc2f2d9e6cd40f88b44ee7881640d2163f861e1f6cdd206866354ce6b60fc4626a976bff04d3772b9fc96b7a4b7ae9286d1f46bc38db18e6c7f6eb75c4121d6c2d8f4ae7cb078d728523138b0582937d7f35400d5d9180cf74e8ddee80714bbaad194d229913ec19986dea25ab14b353b6dd4dcfebf896dbdf7b2385453841ed1a4eddddfc3db42e10f9f36a014f675f0dd9fff66fbc71e908a0c3cbd5a4ab4c4b3b52ca05410322f60600499019aa379dff77807c534b6f4525b6d18b37e5d4681cb51e7f57ca24ed88d977b4ff95eca79470ecafbe30a1699d903273c030ef88bcd86abe04c4e65c48fb0eb0536f949f59db55a74c6edbfe33ba9b12266157389b9304213e08b3e9334aad02454a500a0fca91de39539e3a4707b17d685b6e5502562aaa5f37520f02fc5ea36578427bd85ff041f63670da265be93a61314085bd86df7f873c916cd00e156cfd1bc174be79b53579ac3abc7fff94f7e2f50b7200d541861b4cef5e55c608f4339efd0acb01529225a788d4a2066323cdfe8f2e5df5d76159a6e3523cc5288cf37781621506674135ac0349494afbe8d42c90f321ba3b520652a9039d90c699beec9bdf1a5f30ad099b40b21f2ec509f6268df4d91162f3edc5d7a855b6ea285edbaf8dba24fd9aecadacae7a76c0b5e75d3d7bda6e2339ea0ddffe23db4f2179357537f5d1eb70d92fb8a5328cc12bee731381a5bd63794b9fc07e8e71d95866d0e6657796855ff150199ae48587a9e7a675793fb5515ad4004d4b8e29f117ff154b82e9ed0ab1af5c3456bfd45efdfc767928c799c2f608f46f1cf39adbe2fef4a1a9051fb49efaaa2e8f8e7942aeff30097428305966a2333017a88291edbf7cc102971395a8f61cd378972019d6c05c31a3aba4ec7ec546191534f7095e770602486b7649526dca81f7b108661bfbea41a2fa0fe335314aefadeceb8c0979cddeb5c55c263521cbfa7e27530f1f955c5e0350f2e5c9dedb021aba1ef75be3766db02f0afd89d3442b45de3adfc0a3a1ce9d65cb21857a64a12d45450e477d9283062d63b0a7381ebb33ad97547c9f4b5ed51bac8ac2fa9848bb394002384c25958b80bb4cdb4b4414b61cbd7db07261434a6ccd6110c6e16bce61a5314deda0fa8e49a9a0737246a3f6071c6ab2140d5bd357f89190cf3238a209a4bca971b0b11c71917b81b4e160de84266d9e0048e8af95eb1500256c6c39bd5a1abfd24c1c98e7a80dcbd12e25fa6d6ac02d7f5c3df0dec765cb0ea3f9b05598c88e745e13970fa3e8f90e7dbd246cd2f260b6d7ef1bda16fa50ed64af190b1f409ca9fed9cffe99570e06b5a622d29cb47bc05b4b0031dec64028843d6a3c43968841a25f785cb8cef2f3728c05f4d8c930c7998efb14a5355646702b159324ee9a3ac3119799fd49ab2600e9cb1e7afbcd3546c7e2328c5ae2915611a13fd29fd7d1380cce7c4abd81e54ab2bf3b7dd42b62154070a239992aee0bf5272d3ab6415b1cffdf63e9b9be22573ff38eec9c5bbc729659de869f79a36603809522bad143af0c5982783b1c65136a59b0b24d08573b19673081f6b58c8c06094c921ff219624a3d3a5c4f775c9c0287e50b5c065e23748d46bb7358d0428a301ee3574e8f22108c76ea81373c72c756d2dea277167bd70a80c698858980b530f0e6386e83e9fde8272a1ee5c8bdb3291d52c527c7f30f322873a167f8ebc767be148543665a9e08fe827e5db4c694000c8bab13e9f62b480989d538e77564c5304470dd66ce56e9cfffac74c4a82a1becdb5b0d8d2ed24cd8ab8bc5d20e99048f1e2f91fe4df502860da4c20feeb8c3fc73834efa27b6fd533a4a9791c5114b96a6735dc6e6992654c1693238f7d701696ec98c2bce159604543b183125379c7788b11fe00c96d9aea72a5983a5c89c2247ba93ddae34f43e0eb4dd6a3a5245c60edec277de36508fb9a97da940f08b8cb77831ee91dd37829b97c60f9bedc86e6cf82ed8dbc37099fbd1f4cdf1a779b4e5184e0c446731c07cdd4eaac5e7f30fbf499d7ca2b38c857db4a68355a248b6036d9125043c7e1ff5316a2550fda9794a8c98fdb8f60889e55a26eb9ef78accc95b799755811d808e828457ee87cbe7191565ce3acd0c6da55afe436c70dee2d01daf3d8790f478f89df9b46c7fd1fed3bf37a1694d315c3866db9e5e6edc2f189c12394a8e2f4bb1315bb8ef68f19b3422ee2a61090677563470770073c22fe926c6c71244ec60d681c36c12f6ac7fb8af665ebfdbfcc09f009995a9d5079ddfb2950990c5a01c9d0897c793d69361bf556745808b6d35142045f1579c3e8011562fcb3368044e53ba123217b851eacc514ec2c5cbb9a3afa514f2d8924b0d977c10f4de59a8db42f4dfeab1f467cc62cd857bfb817b3543179197a6371bef34f6878afed5ca8392ac22cac71cbaaa7c84491bce0be1c30c989da68d09b3cdf3f942f73df4aa6b5714dba8aa1afdf29397acdf5a29b17a5b41ea6ac0a73fb72b634ef182e212664a99d3bb741cbf7501e66c63cc2c8583c4af0ec4772029d70d8c19745e6d704668c775be0978f7d1e18be5adec36b5584748af89c3b2342dd7802e7caebb058b0d63e4249265a23a6b832f149d4368e3ff4cb3ef6fa2f1292d5b4ca7843d8f537a2996ded2e4e8167fb92a742056bb9f4b40b71f4e990fca5f82ee032459abe7ca44a447d20760fd39d43baec280077fa4917bdd8f830a736df4e12e9c50eade41730a71d49c9408bfc6352d5acbd9689b2f7586357f036b798f8fd49b5e77a5be7a9edd6f440a7b19e65ac1c4982a3c385f12cf0a0d9ab26388a47e0bea9d32d51453985d23b87d084d854f3d5f67b6b0eacb2e42922a279c874c720fbdb13f5b37697f6f38275debcdb93199328e96f38275cc68d0f3f5cedc2fe51e0401f4061b6ac8f4a7b92d2687cca95e86352eb15b3622e1660d1a0d527e586966dec5956892ac996979a9e24cc5b113c914882968fd78b8f8969550d9f42874a464b1ae8ca64a5f7c967f1aefd831ae3f8e01abe1d31ea83a09bf9f586af6a768a170ba22955c1ee58230803725b0137c70ade3da55cd4cc322bbcb59407c5ad3302727a549fb7894849b02e045d65e89a9f8959c16576938bb385b9dd6e77f6733fe83e4ed4413b58425fe6057a8766d4ecd080111dbe39e4e421b3294bf9df789750ba2bc95c67bf1039bdf834557dd0b033260b492fddd4da59fd35170bc30a91365306d004ecd1096ae8fd08b9322b559251af69af032e617a2b8e26adc8a68e83471c194231af41634e90c124261aa7fec7f20570b5e8d398ce1b12df1e90279d5ed61f1b663dc308cd7f87703eb2a11d9365708113e2fce0c55b936cce5c5e900bd83242cc8c9e544c4edb12bb8ad3f246aa7d991c4657f9dfbe3719bfe3f47d3190575b8bdaea91f8d9e6a7b6f58774dd79962404ee19b7ad2c97d389b44619ebfd14383d959c9c2f4ab641fe451d38ad081cd2c8de220b1097230f9666242f3643be88848b071e061267fb9626a4d0ff6b6081e00df523b81b9edd3b5132d189173341219e6f9c01f8a56277ffc3ded0754daf3506ddddb091695dcd83e1177a2883f473b4a48e7cfff615c42134ce27c3ed26c06f65171da23ece286aed2912ffdcf0d41fe2b3b29289be7a3eb03bdfe263e2b9f676a36ee08abe800507b24ae2a61dcc4844fa40e3df9806d9750b443bf4f95bb3aed764391e48399bfcb5b20123ec3ca6ad1ad4f5243d84572aa266bbcc10f2eca557cb32a520926b697af42635d8f5167163995a819139b8a29710902fd1696ec959c36d52925d105d03401f0ff42b4e963ad92afc42ce853347ab246980c17181fd21777559885e77d0084f796485258c33d04f086df06391fafe0a9e6ae287b499efc3adbb19aceeda6e2672908c0c20aa0cde238551103262d939c1df6488363eb1a50a42e56cf1636df67e76364ded2eeed5b8ab47bab28da098922a21024a73044558b86348b62cf5467e296f66044474d457dff4da34c5023d7b4eccd2570c7f3f3e53ca259fa112fd1b4e21bb53f981a73640927833539ec968b7e0f6473a886e53fdcb8a22a39af390d1784d3b77a78c7c97a722687e3d2a34f486da137c9a786772ebdfc02ddd6e3c922e09abb2fc4d998257165c1cc7b7c3d3e3718e2f31b916768b0b222438e7b89652720fa3dcab1309d0d9d0516b5f1837754d0e23f0da8339c348e12300a3937351fe35c2d2bf6a8e5c0b23359d5157dbe6ddac265b63c0b513c178cc9e6c85c5f840d49e8c251da4e1f66a4fd4c82e3c17c34c7e9dfa402d589761a8e123e89d99225a816c736a8faacd2b55e1debd6eaddd0c060e15347141f8fa0949c1a3c68828692902b3632ccc23d3f2c55ad8d5b09f06bacb317abea9076aafd535b5ded1c9c32f6b4c6363e22dcf1f7a0708b40b9060d4d6b4147b82974dd907aee3176aaf853c779c45ae2a993a30ca5b747c1a36cad89b8bf401d5da367884363937b7d377b2bb7a66a45f34753910fd8fe4c64a1aebbb4300983ca8b43fb8f0d45cd2b96690231f01d5e19eb03fbc479c21770e696ee0091932b0e0047f8672b39732a770a6b84e3e38071c8d1013954cb5331cf4cc36aa33169622d4ba2461d191d6f94d295941ad397fc5aea76aa05b81a11b6ef4f225d0fa2c5da62b2aff38b87f88f7ab37045a186405598a28b228d084494367ff6c00e3afd7a6bf332cb300589e83277443aff32fba420ae51ebe829be5664eae71bf6fce0279fcff182943e2772fd7937a911d756a50e813af10306b8bc9ed3ae80b6ce5e52fa077282fd72a59b78657b93a8c6099498e1a8d5f9e24e60e32991fd81117365b37a169cbbba6b4f73cce5b4faffb9f90c2d13f7044227ab0bb999017da3fe2de3f74cffa0333013aac5ade4c09861022ea447c4021fc949ac6d1f07bb43799428e93460dba0d9549c2983795d746d8d3b890f030de0f60c3b8577687eb420e51af05263b1018921b60f7503b498f60925f3239cce64cf25094cfad4f40cedca7079b0aae13bba05b240d07326da219ae4f3250c7caa1c0b55b00da54edadfaa1d0dd39a4beb644a8c1349badfa78d9a568bb73c4361082438003ba7daa0c5d93fb2d3e70ea9046b624afcc42bc6556725673ed4513cdc830d6f69f6e46284a3440b78503526bacf2fbe6733f5fe10d119085d462013b251479edc7c6b94fa56c670da5816e669bcdf27634566c04eca89f9fb125b300fb63e52021622795d0f0ae0756d95b187312fd5cb054377a42bf1c8940d5b69fed1e9f057aea343657c3ec52b13b420c1d84db5a0cff7e9046b35dc5874fa97cecaceebb5bcd6e6044cb10532f61a9b21b1785a66e96a6b713f13971caa5d9688c111fc25700e58b031ac325657861283c1cf384fd41a117d740ad8b0dbbcf8d1de04b3f1f8480088a915663e4d631e7ae769d273ed11753076c9aa9aeca77da2d5d51dd815d3c03f0f640843e93deede2ca49b270fc9ef16954b76a14824f222f746c4cb670cc689558060b743636eb2dfed188fdf63bdb184488929add9ff9b388010785b45a083de93fa1a5be70552be3ce8a5240e0192cb3b5f44f858a8412021b50eb875956ddfa437a4e19b7b1e2bd4e2a02287e3fe83fc99dd219e2c3401123f84f46087ec5ebcd941f4f92389dcdfaa43899b92b800bfbbf6f80e8e1ebf5a4ef653289ca5ee4311ec982e634ae363fee2575c3767f6d7fb41089637a781390f9ff80455ae3322b29c05b6b54435e18137f1573f5883d555aa543bab9fb1d5de5811276ad4b7058d92e090f506ec4892cb13e3b81153e0cd7ea27de400fd025d8ea895ec77247611215ea0acd046b24ec49a33fd1c90782d1901632b42a74be23bfc63506f52d9f24104a5adf5a23f3e33580f52f1a816001804d240417ba39b33a1c205819e22c4134f4add6453ae0d9b64697c6e3d31f7959a5160bba049f28a20d50fb820633b500180aec9a0c1021b652901d36073c11e16b632c1e2e68c92f56bbd1d353948a6d1cb5a31ba09c76e92b06ac3552c89065b8c258867d51566aeffc40aea2e6b56a3559bb8b5b135689a185c20b535108c1fec5d78acf31cebafd8e30b9ff69b3590511fa62f0e43d60710f853a8c8e6420df7e91022e714a992b21d12ee8add66c5463f127ca989816df19b5555f39dc5c0d2d595cebb6e8690322a855ccd3616d5b9844872d01db826a54e46539ef4b2fd101f58f44c2d36770c7054c8ab52848751b28300374e080cd32ace68fcf2d7ebd444df167a005e58069c707efd9ce8849904469e47d55cc905407ceb9f02e76aa3f76f7d493a22fe16d75e1481de42786fc31d38ea4b47371aaf0e34932a07771dd6ca9d6c888f0e0002e9f9cf34638ef0a8cc7351a2e6f33cb67746325733a03bf5a20a61d67c55e30be5d0ee66eb4a7479ef3852700c6f30eeede51eb7bb483f4b19ccbfa5e592ef633e5a2605dfcb8a05990c86d3043ff1c44913220f7e322c555878d1c2d034b72d36b049b3329d853807b4a4de513fe6232298f5a51edaa75fc07bae8a2b601375c9f98a6f22b506768b9019616ae011dc425ab962f012f116154b9829b6db07c4377c140bab0d4c10891dff92300f4c72540b888f3cd92c4db66ea0cf2d8d0d634dff5e15562206b10d518796991141e6d411a89d9af5e93784714a826e1051a495d34e50148b8f701c3aa0c17f51d92de1e17bd98b43ac846dfceb57b19e41ca8a725b97e4a4afb1de72cae57d882ce9467325fe64a0b8521777b0665307a5add608c37fabf9f0a1796d34db80a193a3c41c436962cc80cd5a0f8a5e5d8d52a1c04ccea6ba166da946ef50bee2e7d4740d4938c82b285261fec2356e9cab15a3c589e8f4542a825452802d3c425b0bf45430dfc9ce3bc4b07ed321ba325aff3fd1280ec781e2efe9fff8e8f27e8c5da74b141fcf2f76572978cc21c0e4e18588950f02ddebbfa964c2b0c03d304fb1d19fe69f33ae28e695b23f5c0f804f9ba7a5c4f722003c4527a8c32c8618f2ec64aac99430d61998e31db5195a0bc4d1b39dc97c8c150d2316068f3f41a026c75998a0f6c887a941181a896038e38e92f5a72e41f502d26c4f3181f5f953dbe3dd8676fb97ef5ba66da02b851fc30d3be47fff6d68ec3702e5588804e399d228e5c24a3858d696879b18dcf5a98eff9d546d7ace2b237f630dfc9477869f3552b9fd68370a951ab1f554e5e209a065dab36cc797f4efa9ef1ea0b3eee00553436586c21b540e80e1ef87fcfd36ee2cb77d5a8694406ad3430cb4cb7e6a3877330873c93eaa3d81428788afc1b4893043e64d9f19b7b687b5a3f1bc3734a30349a59cc53c242a47065a7d71171ec26516763ba7364f3f7590667b120f957538da644f6b46961481c5497d4cfc2c74602184aa4491e9d2fb4e1108377396194bc5a5de29e992d3062b07373d4f14a55360dbc7e15066eda98b53c51038bc117a3da323ac3f8794b219a0eea2649dc1b436ce6d8d4094cf1f2f862c30c89c7da6134d03b9e1f10e59866706d8cb5ba7b30e329728c36a890c7ba9e4638293b15d450b9cc9ee025eabe81ddc321beec93276c30a625bbda5c916d4d0e68427a74b8b7c6e26bb0a87b1d64114d2930595b9bd1fe08dacc6343ec8a0fb65424cc01eb344afc81d48b21ac0aeb549949d11336529e0287274460e49c0d2b55d26b26728e176c201e13771e37342237b94165274370a7ebaa8eb88ac132cc275d7f97a779737ae669f4e2552d6260b3b4b994332426bb0a8f2f2395bd824d04faa2e1c4be6b3f3582c672d0492f91dc4112bee30632ab876e73096cc2af0c7399c912c5591561c58144f5f9c1b11d4f5a3c84ec6c3081d0aa5a3c2b6365307c01e033174559c48804ff432d7b91fa3ac4572fd283e99c8915eb335b53ee793d29bf9338b11770e5975e99cddb590dc972f093b832e1e1d636eb8f10d0ce73122680472ef58ad4ab3f9d3350895c69c04596970156bb8a665a97246ce4bc0fa6efcc8e7aab4dc572e827f4d9eeb766b4af4d7a375845d335d8005eefbc150554172f63f4832a54450ff5b001e487ae4153bd78f8b50474ff71eff0cdf166af326d7003aa6fe4435f0e452be23f407d2cb02526b7a68f4e93810fd396ad14a7e29833305f2636319999fe350354e93e7815dc30c2bf389cc3cd33ebbf60cf84941f657014fb3693168e609e3f882f73f73c56b4abffcdb3b3be358e8f6edc9c4093ce06e8f14f8dc65e63781f433534aa46acf7cefdf1a2dd84ff92f72621f9ed606835449dac0644414c9990d21b1a67cf06a9370cf94eedca32fb4b524dea4684a2c1308d19991bc2cae0e86521210d63d5def50d5f333cf08d4a0b24b3160714c0a1ae28ef4eae71e1d36fe339ec345f1c76cbe91b18f61a47ad17b72c12024069651490f59367d4f5a1652ed4ddc66930ac132103652a5e2aa1b26e95bdc8a6ad78cb0c70ef984b80f951cb7884f178954021672991cf44945b575fa945662ff2257f877254190a52089fade291f5f5092df4b9141d02c78a00483cf70b4deb6cad64580c24a399a8ba72778fb3aa108dfd848903abfaa151a6d738f4a244ad791a12279a78d622f838948cdc1a88ea21a852f38f304307c89f503e3ba65825eab6ccf79e74ea2ae5c3e4222d4f45d1f6934f800b4988cad9aac056794800a456098365b899dcd3618a9d38b11302b610dcaa3e0e5b7d7f1444860df796c4df9775a87c92b78253d483772ad1687739df27629d3ff07325e8c8d578b968034bc12c130ce301d9f829c89fa1ef75a7ad93cc785db518f35e0bf60422e97ca79e0e89584ce914af4a187ed76a7b3a3c003c167f4892cfbe5498079051afeac5c01c8ad6b02df47029e9cdeba2c9c1db1f2842ba096c35fa9feeffa9b00d4424f51cf3cc851f27e938e90574bcc1d3337e4d4bb6eb4368b873999f8c50fbf40e2d09474b070344114cf7746f2de96c695923ef8af60f91a4b833af10effdff87bc407c54e0c874cefba988b70eebabf96c2e2ac5304f8254b875faf63ca478e43e9f966fc2a5f0b4ad2b810c4670986fcd0b067619d7e3781e737e24c3cd34dc268ed667fa66a17b452e912e3a2888c2f7248af014298ca5c335504f437fde8d21fc155226412ca4d5623260caa8ac3197736f2c4be9326e3cc291d3db9b58a243df9f664a6bfbdeaf9ea6e8e9f511e6ce97fcba1a1928a32c22998e2c3aa2174d81c8a1324537d223c354f1f1743ddb33f2df827682c1b9109a1b3e4498c0390e77cecae90895e3c1e8a90290eb15762a228815427506eb4d478a92cde909a54f69f683781105785de6f735cbe532776467da35dff01aad878c76022b9aaae03fbc400555738115297c22fdd2228588a574176e35d42e2dcaaebadb4228bfe13bfe80e791da94d781a0a89be92c9545b21e5f29a59e12cd6d3b7c7e1a7dca0c168d235a60f2c044cd175640a0021d7000a4fd14c87d39f44fea8a8255a65fc108ebb2179ce5d2e1e99737dca0c0e3ca7e8cd030e8aef0ef908d18435006a68afc5d6fbb0da67083657406dca430e7ca0b9609d506efa883eb179f43491d60f5cc1ec2a0311cfab4c770cb372da023f031c57c607588c7cd3a0c01fd378d797b49b0780d7b6bd49e08650a0284685d8b18b673ae7e59a3aa40ba203b5a5bf42760d58cb158114aabfbeac44696179dcf11333834c2932f368535da54b6109f69a94851ca762d58e73832eb43577461156ac04353cdbc4ad90ee067f0d735e964a33c682f67ccd033f511f20873deb7d71915be3a5617890d52a0ee3acfde6ad11372ed749fec41ded247281080c8794a566c2b30433c31f2d8962c477bdfb80319f10568751efafe3e85dce8e38e672aeed20999dccd7947289d708838d108a8c2e5d4c1548f75796bed68c8e01af5d1dfbf7f517080452205f0a5a83409feb711e863f53439257c735f369a54191a56941b4d990238d5dba79c409a02278ff79d380f2487b2c3ade676f87e50bb601777dcaaf6b1a4320156d2372b58c1a6abe84ff646d770e8cac300aba062d9a20334a447585098917fe19b7243523d6cbba3ce41680883f30e05ef0a63f29b7d614989c5b91de551ad0a214f92d0628b53cf4814b76762bbbc9131665f2a87866cf1707d2436f709a8e43880a97b3d46180b366467f63932323ca61a65310df72d212cbeb32ba61787c57c9e2370be85bcf01d649f503ed4e567a4046b576379f4b91b889c5679e3211c10c4e154bc9c4bd318ca3a35fd8e31a76a872c5186e35ce902388de8eb37dfb31b92777fdaeff92dd54addc3f8522c2716ff7d01b72b39bd17b9f10f4f9522a5a2599c7b67a95f8227f1dcc3efb1d6230271e73bb555f7d158fce515695309078571745eeffc20900c2b5609ae93e80de389fcb3e099707bda3e8b3335ced08088c10976f110a370ed3f02b8acca08fd5201a41d806e335915b7a45862385d4a528374b5bce2391f603a9dd4152a5b206417829b2ce722b9677f51c93eebdeadb8c0a4b1efb917d0ccaf949125b262230f908e3a1dc3b44e9ca16db6cbca37201819ffa1623b5dc8faa5390fe542567755a144c42426221e299ce54126dfc53e5df9de095db6d4d30567d1aa4c10207c03737999054d3fecb81ad32c99e3ebfbe892a8e4492d8e0c477c2fd68f1afe7446cafa253ae6686625650aa8bc787f0f1602e789ac1a2e09457d717477506eba6e76d0bb2b0f85f29cbef2639b7294d8f7723f69880bcd89da8d9d2583c8678080ec260ba9528b10e5c1de9cae0ca5f1573481c9915a2c0b968f781814e7812d06d67f23fb4ef5c5f4f1c09b8584c5bc886a29a1716059499e516284ef357496d164c6b305eaff668db29a8ff9cf8d2eac191d272ac8be2ea1fe872f361ab2de42db704384c0d17dd358","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
