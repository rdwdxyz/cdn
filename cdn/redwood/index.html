<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3105508e97544ba815b16dbdf595731526e393d8a5a52e46a4c2f4f48b8ea4f0967b7294c4af6f0d23b2945c3cdd0e0a73702739f5c15b17113e72bcb4fb3f07890bba0afd5f84ffac138b16cd5dacd4370e231d64f84732bb7b53b1cbc4d4c19a7ad7b32504e5e453879b620e4440d5420c12760aaf077934151667c134bc2c43f525c7703fcc608a8db78f876750e95a0f4d36cfe2508205428538bfcddf9aa585bdcac54d86cbb7c8fc210db7653105547788c99fcef4e822409fb9a7248d4ca7f6536efae04ccfd6735dd47dee21ca6ffc2643069bc11c9b0bb3fd37e215fdfc798d9986ead99feb0bbfacc330089638930a78d7bff84d87e5863f55ee1462ab828e1b95c58cca2dc44d6e5f950c449141d48b846db0c277e420ea33ca9ffaf1d83bb337bed82bc1a028b11432ac0a0b91bdb8e8f3767c0f90dfb87d6785c9208c69fe1e12e9a0d4597c42f1a41a4f7099be3f70653c9bc6df1e816abc97cd9da36c4a695357b67c98dd38d8d281ebd37217198e71267c187579fe967bd5e028022df8e71c24e992368e45f768c4c4c207ce4ffcf18a1a895cdde71461a75529103325a0209ea55d8e6545b623faa4bbcf4f841a3c0fe2421ba4b275e5d3338e56a33d24da5bfa88209d00efdd22246ef6981d2553994fd82c168fc881aaac17149176b6a1d0c48e9bba2f0189bf566ea598e36894d62ac7b3c09d0239ac83ccf2901622a2283a08b7fd639db0dc301883413537f8c75eacb0d5e312874d1956c9728d41af40038f23f48ae969d96a54981f908aa3fa94a400eaa64e5a1caa8ff319a3676df821459288824997676a675235e4d89d09b47a2667f34f0e8807348c3219bfc8e2214ffb8ca03586cc9ad823df9618abd2632fa42aecd90a280e45eb6be9c3b68fbbd2bc0efd701a1997cd850c1dadb0224b2e486a0556600642b3add1e4af2103808a37cded71ca4f6e90f4668a660f97b6df408105e99dff64685a680569ffdd12c862c6eb7988a641609850828103c43d626a48f7ca3a1047d5d1f4cd72f4cbacafe6abccbdca0ab6d0cf8f4488cc4533d01365163e4200e6c139ed89f020cf4132e16bf6a9bd819df36c13b6ba7d394e24023617da5f2c62bf12871434b8804bcab318aa908e3ad8192c53af77e19bb187e070ec597028685744d7493181e31efc1d5d8a19140148a515af3309cec4add51ce11394bbc5871448841d0453b7826752c6f3e7fc8f0f6d06157cf8682bc351648348df833c1c458247740eb8567f64264221cd7c0898529784777035e2e7aa9e6e3a31fbd5f958371da4c49048a8dd7d1638956d40e71e67cfa4fc5300e7278ed0a5a0003e0e2aa7413d320e817685423ed2b5cce7d154d9f7552c438d4b5fcb3e5eae0590517f280b1cd90e45cb350692650b170b3a5c022f5c8f6a237903ce0104e3045c94b384040fd79cc1e0a081fa59ca587053aea8d76be2f5eab386323c58b56aacacd8c8a1bfab644f2553e27e1116017ea26d63bdebf33ba855875e50382afd420ffb319b7b3cf230523bf96e9422c17027dde5cf658bdac523535077c3f52550338310eb28a7a7f994ba88256264496fa51b02efad4451a320bd19edb12092ba2d1da15228dd0c127e673f4d036401985aed7e0f6d7858db887b180688de24a9524397eeb8a935a09b420ca1a6d9943145f94030fa1d1afd30943758dc4b3c3c6ea84ac04f875045a40b9991034dff8d241b5872f68c72e246328a05089498b0d574a935ecb5c652233a20edf8e4d03a467c041ec9bdee941cfb03dc3d762bbca01f39570875a08cb7e951436a695f2264fd70f77e78c4f393d4797cd9b1690e83ecf9b288d7c0830060b23791b6825dd8921888e89af5b8fd06ec09ac8c2ee7203518ef7f4f685c170158dd2e72618ec2631408472f97b54c5f978107812de8062627d43bd9e6213bd0b2a5b46f7013b25966d92635255223af14c90d2ee0cd81f3d5c0ae7ed2ec9539a5a4d63b56d4c903125531f370046141c6d51aa525f39f4f5cce632f56775a3079490b0fecffb988714ffd14e7405bcd55b32944fc8371229479f00fd678362e21daf3106cb8f5de29cfb0af104b16084cfb6b746d715f36bbf62f88782f313ec9caeab9ba77a537c260663ab6f07468056762bf4a7342f998d912e4ff12ea4ea956ab5a6df7f97351be794011ab37a1a73103db66185d0fc37d32e5cc316527d8441674228927d5f43e19ae31ff60da627ceb83b3097ef13403fe77d81c562cedb6789450e9c40de64ff0a1e98551696e1260c236495e920015d6a88b044616cf15bfee750568783476105e09e9d8a08c2824ed09e5dff599973990abdffac95e29cab451e7b2c3f3219316c57fa88a3dc464f2c28f65be7c4b6e5abd8e8698d980c355742b3616193bb1687552a32314a53e0e8ba419d7d415bfd1dc91eb0366aa3bfcbcc2e29cbbea8f65309dbd6d4e2148f270ceb6fcba424357bd6ea63bb9a167743f0c237ab0e090b206db61c2db9fce175d5c5a4f683002c48492a3d194da107ce88005dcf15e4db771121bbe53d6b3c2c84c6893b99c3b6f9d83395c1ac48fc38b8be85e6cf7c389d366497e55cf5156f1d2c61990714ac887d598cfd94e854ee8fe358bf079bf58ab52b5123456825fb7a4e329aa3a66a81259e8b5f171937a7e069c301c7cc194c7ec3ca1209e1e41cdcf7fd1e230c330e0256677a75d32afe46005223f920be87ad61817ba4f694c7448565eaa2785065ba697ebdc2f6603761282ab4f1ad65b6618a0ff795cf79998fbd4299882f9e0415b96ae1652b2d76572e585f042a8eef88fc7b8673b6fb54170d39e85b6bea0ed6334c88749fa5b7f60a7eaaa4c7cd0bdd795a2daee2312e35782a1e06cb2da121ce14a6f5a1bd1a860d75b9c7a7b6cd89781ac0d0ba80335ae949079ecb57c3da7d6a2b8364079b4c6b3f28e591ca7ca032787396e05ce509cf97609579469c41fc921431c85445a12143ef89616aba57ba9a6febef109b5e0399985d01c05f4bb7c9caa26a53ed610ed05af27d0c30ab524575a55dbcc272310099852caaeb24cda56bc738990316fb3fb4d6fa2e04b69bb80eda212aff18898fdcc6bc91549d133e4a4d14379572fbd955fa49941ae3f74d955163fc61e0a62b881ac49f1d1f1369102d9c80aee6db084ff8cac670dfb4766d6d6e8db9ffc305bacd527afdbd25d1b97aadd55bfb40bd34f7d49d3e7244db762a975947bf9e1ff6ee66fe961ba73575c4e1be880ff1e96ee2429a3ef91627756a9d964f7be5bb793466f417739603996255a3b3dbd340df976197bba5d7d3a5cf802063b44daa97a495fb61f78715335a92cb407b9ad36deedd511fe4c0027865a6960f2a24453a2ac46759aceba1976c8d7a7b4f8b567c0e57128d499a8582a79667199da3fccde6c2d2508d2b3fc94d0ca0bacac3ec64b043d024c1182d387300059bf2aefef8702e9e5dfb5b5a0c0fc17433078b0216e7887fce872fe652a13dd15b2f9892216265f563441af96584c66e0f5c056f471be6e4f86a0470dd5f3b6fddd8c856b68cd4ac4f4ab617f5553e8c3267e6c737ef2813d3f728324af88a9b0a55b8a05c453d368a93c4b62135ef7402d87c5049c3eccb803df0c4f9b5cdd1b5307e83bbfd81243fdafc9735271b0b10c87cfaf5acc0560e8144342bc3f3fdc15d6f1b999b7131c1eef968f0034a1a159c16e8c5d75c643dd85c6455fc07d19c53f855d1f26f2ee12133b91f13435bc65c6b370744134b2fdbfca75946ac9707167f62144349a7d1cd0796de4fb38bd6c1565cce9da4d0ddf7a934e478d026e180cd1488178987575150bf79d9559a36573c128030d8a31f897cc6a45f5bdd7be878a56cb0732cc7960d5de20c786b48e3f96e0210266d8092888f6118db6df9342cf5141e256619e253f263d16f218bc0b8e40be61e5fb22b70a3d4dec572c544448ee4fdfed4565c849966a104fb30eca7194087c43954738f81c03818434e91bfec1f9d55e007a1881278c6bc0f16efebd43c22728da79f8415e7b9f6a1dbedd6c8095260c7c7df30e3aeb5510ec00aa8200548fe10fcfe76b1c83a9f485ec97a330ef15635b7be018efc30c52b2b937063286112b9e1d7e84994f2247322027b6df7138c815399f7b853066ec4504e672ecb9c96229549643d59ae6a44ba58563c9e204a03cc54649cc370f4d3ea93cdb9986106eb11c611dea6873774e829dd06b5cb8e17d2f372c9554333362c16321abbee88eff325a301a1744e2a15eb26e85736bd3e07332ffd36368b2f9a2e165ab7bdd6ada6778f44ee986b4b5aab98b5c9bf4eaadca20b9ec91e75c271d8545bb64c26e2835d0c2415c2747cc2ca5517fe9559ab7270c2f07f15a64fcd13dbc3632472dcb967f1410837889415c3ef707ca9a6e708fd8a8b297598aaf4e977ede25eaa6a68ea5641bb21aa705f0ac2448b36be609bf8d2809c47ed17f672d10f5fd439efe176b5b05d9ed5e4606292382b7166dc35534a6c5ec6cf1165ef722a175d1ef089ea865ec9601a4957867e69da4567bddb0ebf89eb3461fe91de1c6fe926eccb02e8ddef85133307a745dfef2ec8db3a0b23981ff61b9ad1c434853e146b6d9ecf600662584d3d61d8c529ed1c36e0631a12a617a7d7b4cd58ed74baf2f22b24fcc9661cac46060934c01dde7811b95fd33d164c5fe9b9b9535c1e2ff297bd75d8251a3406117127708ca928810f3d626df217f90ef20c84aeb2a708d8a3886033e261d6cf2b025631d8d89279f7dff3dcbfcff1d60205286129598473be805a28197cc8db24094e6f37b932a50660fbf338d57bbe983760b80c2c5929cf1e2e01ed6528aae152047ab964d8447f3544757040d15158d7cf6ca57507cd3fbd8c29c8168fc0d36b134ee1cc9515b1ac39527a82212e0f028e07cb5583ad85957a643243298b5e3ad845bcbe30a8929b3b4bafa4077b3be3943448ea33c9ac9d6904a6f06ae04b2fafd0919547e477884f25c7200a268261eeee7c9bcf128cb25efa52814544469510d2153194f229294289b89eb846ccef7d0a667cb553301e2268f12031738c05604d42bb785adce970754642215bb57047f3c4068fe9f2c980fa111e3f6c9069e11ddf2bf549e11e968c5f937bda963b200a6ea85270a4cd687e73c3c9d9c08e17665265361f23d15ecaddf226ad85c8268bf3d32b781d3a9a16eb8fba4ed3ddc4950557f06286a6f8163a618402f26e29a56f22ead90ca7b204bbfcdf2f0edaf82ccd2b52388c766e487a60b81d2cf5479954eacf4db81c13faaa316d1f446be9799dea0a605c5db25756f02349a7722e16e5eaac608b4090c368b369269cc4fffd6cc4d1276b23f6ccb22c2084986045d095d9c3fb5661bd1924add79a2869fb997fa87d21804dc8d1a04a3bd87a8e70a5b46a7c4417762da5961dd4c749b926f07c4240bcf8affaee70d237b402801ce02b5c394521d6f3cf60b48ac4357d4ea8bf44ccba09e34018b33083e6bdea724bd5d4cb4b0ad450d0d74cbebb5bd93d8eafa4f8ed4acda1382e097ac3b324ef14929d9a7115698defe75caf21c943f2547ca55b1f88f3de18df3d074946cbb6d09ce62fd64b34eb07ab6a1320cb6544b3f0c0ea1e0ccdb3948f593bc63988da76c7a49d0ea388191cf767bcc18fe89e86a6aafd3cb686550c905942049ba1413e092baf12e8bec6f396939107fecd1d2299011d89bf40740d96b2b31fbdb3140e6f3ee796382aea3dfacfbc4d4ae41a8d7b8d3f4c81335bf9453e92127a3726a94e133afa50f01c6507d50f5f7c17ae2b07594bc7a35e826ed32f83d67786c89012a51a4fa503514cf7b0707741bea5f97ef49c1ad82ce2e54453538ef7c145d20b15c3117d8aafd5d7e1467a6bb21ceacdfdd5e515c72bed4412852a1f3ed31486001bbe80a565c8cb7ea9fc1e3ff693d62d44af03a3aeea0b27aee9310871308d1aafb9f09aeca7946f26cb59de87fc48a990da46e2e7059a8cf9c66365396c6511b46f40a3bf4211e38abec41de00415c8f6003cf1aec9bf404ab1bc813d5a61d2e0f91e2d404aec32a2c5308670b7b8c856f57d16f62175e7ffffede7e7589760d7c805d2bba081ee97318e05db4e7cc463ac03b4a3239560c29c68a5ce51f504a05695b986595f4bf7efac62429a5d410eb475d4eb972bfcf36df99bb4d2f97de9a4a7ddfbe28024bb19c8134138ac88dca31fe4851bdd025e0698e3f7bb75e87ec703bec747620aa08f0e768bc263de9c84573663b111f5d3a7a89e4228fedb2127cad441758a262a9a474ab633631dc42d24b3abf42126258537c5dec1144abcac58083b526ddf41beef96ca42829446ac354b0e70b6692c8574f8a7d14d0d014dab4307acf49b7ac9826239f8f42e58fa83fd7201841967235cb08d423aa33757d460a433fec16bf7258bb0124b02a1ca21e637f9770b903295b1266a9a9f2359d8f0cd6064e93f0e0c0413b66e828907fc4fb04ed23f6c57becefbb6a41af7cd71521819c0a1aa1c6d7216a8b15d99e8d14c2cfa6244691ea592d736e89f95772ff6dbafbae2d74bc0bd832c9dda929621c1434c88296572da3248b506a7a0ec0d43523c75eb84848992eae390c1efad8d90c2ea68f8979ccee4c03d681a5933f56c02f51900dda41ec22ef991ab55dc6139612ed4cfe326a0fb413ac50dea651ff9abf15c9006ddd7c6a05554c685bdc1593220250cf1572de7f214263a41213b2ff3c8800df2ed148acec3ee427f677314e9aa66ef53e3b41471713bd1e7742a4592afaee1ec2b47fb16fc98eef4aec47bb0ec93a66b50ab64c78ede275d0e4a946f74baeb6fe74698eb4a54dc32b99214d0bc888dc7127be9183adfc0d5852115c08ff2c0add4516f0b6797b9a4e9ee395c7f63a4199ee97cdfc42f0153f74c0980171085460a13b92af2e8edea23d15968fd5c51c7f1d1a5c12d6a8bfe77fb480eb08c2a7b240643c4950ecc6284b9d7b1ba17211331f374980d7a03ccd085aa034294a04ad32a11aa54440b72cdb58870288c71738026922897955f99ba5df613b853199b4875297f8a8aeee135be1b0b48f708afd6e718bad5a880e2e12052df6fedc42d1b2405ff3fd7351148085bd0cae4102e4882ffbe3c608af49c52e62e7d2459930f4d11efa760a5701af14a4c6a7b086e48a2c28758bd109066564f036a1115cd8a40912f21bc0de54024596aea579396c66eb677cf0b87ed817db5e3ba6b0919a1d6e9e1ae62440f5a3830924226e62c1943b391a51d53e25d12cadd558e203680603ba86e224ee88662ba99d8035154c98542493ac8ca1d46f166ec7daa4e26bde0a70c64685c5fdb7aed7d605510ef6a2d8955ade000a45fe3005cfef780eaf78c4fe82cbc323870a05ca3bab44764ebe984cc7266bc34c44895523cf147658569e65f4f3111db70031e004976f4d13f075a7bf80c1e360c8986774f87d0a0d0cbfb8732ab8062474fc18b17917f574251355f8a465b7ceda383537f162966aecb76c6b8bfa64d2b7b5cbf1244b9c4962a3efa5cdd68055dc2e77c01e02394c0bd0b12879aacc7ef03162363b161658ae4c366e3edb320c0d793a58be9693ed9a804dd4b72c3b112c1682fffe629eac1b2c7bb83bdff515a66e66eafd35c9edfda5603d0e23914a602552c39c697fc39c5fee5ad3839d4ec17d8b26ca9fed25f02eb72d13cbe4ecf535b581528e0376fdd5789e71a250132bfc90e3a40bf753dd6f536753b0e407e29d934290070137b3521eebb0144bcd51625b532be33ed3aae90706db8ad8b01cf8f80edce8e02ff673f41d65bcb2a1e8e1bba48ad4ba922f6756c585000ab928d948f3b50849e755d468a791464e042fb5729f07f1d65d0bcd5c96be1dd3937eccd7ad03210dfc8b7fbb1c5671479076ee0747eae491526238df8e0404865540d77f5d65a6e4bae858c7e1a9ddc829e662317c768d7a985b2d027bc35030a4d7883e65eeed1d745356933da5b1384a79936d886031fdc9fb1e4075d1390838210c0a4d590fe4bd36327ebc346ce8a95b718e34df13395a2e39c854712941cbf9df32f3e1cf5d07777ce4df04bbe7d8d569cd4a05bc9a700d322e75163724774d52e344c7c74ed1d2670f05aa3e753a113df1185544f2e5abce3b904e46612be1c8926dfd06831c6d5e27dcdcc2bf1a74c20f289885886b278bb6fac034ece48214a718d7aff2ccab196db863489ed2d173890b0acc8638b0ec45a071b8e5d414da6c15e368493a46f710dac09ff3b8be7dbf074bcc69d05aabf21a6287010ebf331e26a5915d428abc8a69b9b5492493a1edb5043792447fe7a77e7a2b352fab5870f25ca5eb9a32ef9f0ed0f4f0a64034d2ac30d4a3f04002595d98a14a8944c3ae570b250cd3e6305619b3589df8c76d82e74fae018d30e4205c2d9cfc28ed95f976d7fb474a82f6cfe143c8dc048013f27777d1743b65ec503cf844cec10552cf9d2e75f0924b8993d48fad1e5acda7277e5533ab7e32b7b7112875059a34e21ed671530c252fdc2b86cd0f34946e741211bf39b6e82969f6a8eadb2fe8086f6062103acb57133c46086323b772bd4d3a6c2bde2253f4b4ada1958728a8bc99b929577a4a43a7abfcc3cedd919ba3a1cbf46380d143c254b028fed9468c7bd6f455a1c9573e7e8234b96e89347f02b8ff3bc3203cd5fb90f2dd4d371214537d83817660b7f723b8fdf553d2b3e7446578f2cbf4a9d040b66928cf45f37460cfaead76ac2b839fc59ff28383304c646a2560c3ecc40576f0cd5567216b6786f7368113a3ade2c732a2a1d2d70de75b2de96326ff0dadc8ad2a6e35f6c20c852aa8d3c5a24b5d77ba5ed64cc922ae8b600b6f06d7f148bb9a919dc4b32549677e79b8ceb1132919cc711879da56c86ee301d1b69c2b51b44d829f276103bb8d8f2eb0531399f91d45ca71d3ea421e359f573a51987f496557e8692ab0de0143a71f406ec8c8d0ff520842c3d18c18c8a065f6a7d514a2b89c6e78c85a48df0967e94a26162df876911cb09c336747aa79e7b4f0628616b70e2b347a8638aee85cceadd13be77c94f4e38b1753ad56fa42afbaa5acd1a6369a16fb59186eff71096a87972070d4983c524220063b770d592ac3662e0da1f7e7b17f6b245da67105f6e0ce9e2cbddf6b1abc54e6ed8c51a4bd86edd55826f1935c407c28263e332afbd8dcf93cdd59eeccd02d4a8a9b58cafe5d13eacbddba044c6492e5523dff405775ccd21331109fa8fe4f22764e724c80ee1ad8c4273b4ff75c91f6072bb2329d2f59e030a625959fb8c819dba422738713fb683c5393e64dd326c7a7a5638af9be8c1da08c31961bef807bf285316549863ac46231cb091061146f538d716e6da05f8590f9e09a82c2ca7ab6637ddc07148be267df2fe680a36565c6ad9b41f5db6e598a1e53406dc9a569293a109c956ddc21eb6200f2c7bf1b2f04d2d30c0579d6fd23deccbf228795b7cfd3b8c66c42405bb762ac5c52163b3d9db455430155019e0d49b0f88fc778c125f1cb2bca20719afa13188f2b8fc76b2ccd611a6fa2575659801db01689f212c49e730da821be665aa90f40a0feb0e786beea0c070af4da064089507a3dc9681c19a41a165335d9a52708cb33d4495c14fb20ead0b4d4d079a3e2a203e793a05104abe7724bb4575dbd3b88fdc03eda42dc8b076b3f9793b817f64ba2e3537b3dac770256b6e1c60522a15e5c990c59d959faa2a119e77c6e133d1627009a5c8366ab0a5d66926b8686789784cbdacb28591f3b1ac843ac68f85612886b2f073f0e77788c763ef84e39198b2da633e8966b981d104b857a69fa0efc2bd30a59e0219ab89336028578801b82202d906664cd16d0ceab8d8803bf1a222a3370a2ab71502c82ee8133bb253479953124f4f87e56dbee8045d1d8e0426ddf0dec2b24fa6981d3c59f636d4f5022b2546012978b31c5e412959fdbba4ad2c6039d9dc7bf5447d49cc005fe2eb2391861a6b90b280b5fee3a84a741c736b532dafb7b991182577bdc9ed17b3ca735533de5c2bd1761ca542f579ed62e8599e69c1a30fa61bf48b63074ccaec1fceebce2ddbd0f34c9dff533626020cb35794cbf7996cfe038056b7ba720dfa706160b8589b24cb7a5cb79bfe5405c5e529e78c5b1208b3f02cb8a6fd94cb4abd8809e51828fb818fe6b431441f06ea171a0e9c31caba7a649b6bb96cf6a9cc4dd09056e1a47ed0cdb6d78f42dc31f8d6f23873da18072e21fc428ae3930117b254b2e1ba73b33db4b622db029f5b1c05f9f281ba96f8386a2f06ea51b541025529638528c8f1b1e5dca18b84df17203d8119cbac39c6135c0df3410a8fa0833fbfe7d87df43497593e3e79aa87d512e28affc931790df672a8dd45f38ae9e5c6b5ca8b1104c22e2c9c49c7e3a8c2dcaec17f94f2e18b80e3d6a17298dcea08cf0a04812a36c02669fca4b998b13d72de9c9c41c733224a0237a583786eac47cfb7fd24f1296c936af85ce1aa7c3db375b07aa66469c85e794afeb14d026e555537d5c6ca309b06085dca33b3b524fd805211dec23e59b5d61531ac7971838b812b48433a66fd53d140da3374ce24bd6b4eaf17af92b0783a1ff61a445cffce90f41b378782b32b1df9979c6d1bb13e511cc8a3ff9b067ed9d4941d73c4238dbe3caf30df45dccfc040592953ae84c849d1e25553cf459851c04a63a4246adf9eaeaa40cd03fb28e2cfb7ca58e1c616e496792f90364c6a7fb4d0615677dba41bbe7c5873421ed0ed9b2fbb1c1677bf85f004b2ab1379e37ab4dfd0ba68c88a7728bf3261964288585834797458fba998b90f1e710e78e05031d1edd30201b36942af7de87f761d4597bcea608fcd801c216f52052cb33f4a214432ed60fedbb05afbdad9870b42ca5f8362fbdf96bb3737a00570cac965dabfe90ba4f7c4a651cc7d7c90fc27a5e02343fc478d62f1aecc7fd8ab5594065de3489c4c146a99371990d1b5bf784af1cdeb4ea73b9fc6fa7bd8a85e83aab5194f5839a451116934d0bfc30439467b883297a2c5330a08f03506c78a5e476f8128e9270afb674c674195d29aa26e4564be039e9b089f921dbb833e7af9e053e9f0cc888cf8887770a4faf92ebdb57c14ce8637e26f2aea8f990724eb2aa5baedf3aee9021cd3ae148a46bd52ed9c5abbbe88f3f97f54b563870007f7e7493b604d8bfe9765ad35905b313d1c32a1de40064e021845ce3bd3b5c4e76f34f6b7a5266185a6cfa0d8de11ad63a6d660a38a14f845171c073f95fc2ac81ccab5197f4fecffa138593543d1da61c424b147c5831083a898fd167ba87b4664d3941968b0c7fdb35d8aaf106ba18556a38fc3a3bb6d79b480eb87c15b56190799d8e882e3bce76872006bb828a489f759a122f7630c21be939c6cf0df04377c8d730d6002f061e8c2bc74292ae59bffec40de888e880e0fd5a13e7d8bf3e8b7631336bf8683396de43033b301bf04dc5b4b6eca3b7710bc92108b450f004f8766a3c3b60e226c4fa0164e6793b88c7d81b426ad2d73a0b2e915245036fcef3c0b296a14df09c98a017ca5dae73e8b2958bedfc5afccad3eb2dc3bee67e229eddc0b92cc1dfb95b8a37f62629b47c937f5b770d4307b9ca9dc3b72b998f65e620949003cf4e3fd30484e78729879d60e8ce1066efa5588402f2dd3ad1d16f94626a227d97f62a9f437ed3b5d1409b659315c9d4f92e54e5de16348b4ae65a5fce75388580889f776f0dd87c704af133539aee55f6a95a4e158743d0baea77f73d8ce93b2f5aa50a0d1df67f276a8b2f7013a849a0d21379c19d665eec6f6988a13759e9f2865ef381fa017e328544fa7e9b33840d57b78c6175fa2bacce5a4b0d3e83fd726a85a4f2afff8812dd2d5f08cfb6b4395582304b68b9665a2f178ef5bc7005aa6c91aa7c961babd71e1001e72b41702b675b2ec975ae8fe4fa1151c1ab5419d42c7ef6b95fa21188f1e6ce40767b81f9cae159e30cf40f2ad8a9022c114a940c79fbd83eeb578bffbe83e7b46e0842273b231f8233f3587d42fbdc6399726111517c96be4657e48c9b5f61f9efaff6e45faf4e50d5e9b10502f622631b3fe03413b031c7fe3e72c564c1b88142d6def362b07a8eeff1cf85bf0d0c003d424c79d6e54ac8a9103f3ed6cdc412d8192b76ddf1ee6eeabef5637b3264d07c1458beb2c2af266348e1d938b7dbf5b1a5b6a6dbd1295dbf5a506439f8a84348c7f89c2ea9238cfecf37d7e4599be5edf815cd6165e02735ab5494efd1050710b771dc210d8994b47ebcde83596bb7feabdc22832e3f5f6bec27b5427f343730e327c956633eecd0f9f8bf3ea2e5aaf6d1d7d75ba1256dab5ce2cc3858b2a34dcd48f58911ea62accc8046868a6d0394886f0c7741c104626a09115744b6ccadbd114958cfae7ca7053a6f60d01e0e48d6f4fd660cc53102eb397c3fcfa3c58a7d70fd6713fff76c1f46811528f5c7d7c97ea4440b6dc690a91fdfb0a433426f7943336360ebce515a05eff6b98b68d57b29387b079cda0a9c71af8505cbcc50b5f35017c1932a623ce342a621226d6919cf9275785f73eea1b9cdb3b799fe915e0ac1a0e1591ba4d3ecd5fe9bf40471dd435af6a04e2f89e0f701c03b670f59f62bdbfef03ac028700127603fad78c5974cbf8f933a990cdf1d355a6817e79ca3accdee750c8662855681ac2cb87e7cb9f39f19f3bb34a7a437121060f4aa60e703af3180d22337abac2916338260906a46b80dda43d7dbab4981169403a61bd36662186b4fb451821b0127c22bf2629aecd2619aac108ad6e84906a0e8c421a246ed723c2386a67fb89185620136838db070b63285c29dd6838cf85d93e730c5df72790b54293499896e43e0ab82c662e6513d14f50b41c0981255b2fd73fbf7c61332547bd1ce74de1234665786b1dbf095c49e9e5f8c9dd807fd1978ad0474293622f006756cb43e2e0f29bd8134aa52fe8627caa91c411044ead6d442f20d2bb8bda1cc3d9c2a44d7f2f8f9d1f5de0032b66d3e99854b28da521e445e8d25fa71473abfbb4587281b456510aa8a1d166086d455de9fd2dfe57c6b2db03e113ff0c051cae52999ba3d5a33bcf102240ce0dae69c39d26c35b1804a2c06ad0a605df420a354f2a102abf43dffc9ea89de335a51bcd08db34eb47a1161c6b11bc9e8e1ede80ab0e8f2c5d8ffb2617333e9face4fa9ceb5011a2e29889c88ff5b0cc3876dd0f0770077670a60edbf2c958a21d083ac8478f0ab3b7e0a5459d688533454582859eaf455b571659c33b5c1c10542a9f466cbb133a369af45b0484b4d7ac8b2cfd0f78b0e0c883e90f8565426f31955dd257af3a02cf61edfed567689f6d1901c02bc0ba23c98d1063c3bd57652a478c221dafdef47e97e60a71f294083d8afa49d2f7c6abe5d3bc8aa0203910a40c364bff9a9f3eeef0e344e0ee8cdd4b05faa2750789a18376943f9a9527ed26e0b5c67abbdbf0b23013c0f88427dd66a651ba0c37dcc969f987cf72067811f9a6e8583302dc2b5ee64755686a342cf5352987674520a087e51bbcf31e1045ed45ff7bacba20c60836615b55150491413cec38052801e7f5ec29348df8632a7e67b0147df2deae11105bb50f4f32ae657b87bd623642031858015c94a3d3674671e1630e976e879079a123353698b033b5a49a554e7312dc3d074de712e49cc8c8c722d7bce2efee155e38dbd3123ca64eac7a6980a66d0f58bcb830bce29c463b2a374bc9cb80a8597f075792d0dec30665a855f7537dedad1492eb8e83e9e34fc71cf2a381b3e224f856cf5a693dcc01cc693d7a2c9f2ee07f8125f1da6dae3fbe67b3cdc5eb807213879f7ae8d7464ec16353fa26836c1c319063a7fd093d2db3256d29d819e8a244b22a4a6472cae7a8a55fdaeb45264ca07c521d3fc977e53c660912f6bd1ea189bf4ef9aec3c27c4bce9aca8b4c919230aa8981c90b18dbe87e1f4f255a2b0d4e14a433a1f95bccf6834e49f9252b05d756b6b1f7757477322953c4939ddf7b74a260ddf9be3f56807dc9587aa08f20541f36050f8ba2952a968abf284212775e436943751538947614180da455efcd3727ba22eb35ab09f949c723fabf71abe03c52b1c85e2b3622a63e3f26771eff2c8473afe83b803cc21e2587fa79caf986a8b453132ece17a46d2cd54455df8a4088b6226cbca4f92aad4f03a45e269d9b9571547360411289180fa5f6f2b420f8e188e0fe097031f199b96a064d6ee098adb9046baa8ce5c5e841531451ff9350b240d882481923fef3b09b76408006943f2d7e72b8c7297850765a829a757b3f05d43a96235d7092ac0b7907fc700b59078e237a67131e5b6ec2d6db2656fe82261b73dd7413fc2e41aeb1afccc5c19bb9b444618f2b46ad5c7f2b9f2f2f01465d370e0c7fdd303183f9d0268791828d0afd65796582bbf47ebd30e28440217500a3ace1f089358d56d36bb9c3bed0bebbfc6eed7078765f26fd4033999309ba26ab2c53c39dd2ba7c8515d9da387c8681830e749883c97f7dcfbb2ba1a079fc716068aaf207021369ac853e9fdd05300acd9107f56a1d2611b97566701dec5c9bd09305b0daf70e65d16681d8d991e648b1180d2e6c6687f61ddb794b208b11d9d45a120f9df1493416bd212c9dc33a17da9d2767ed1c20457e60a14749ca14ffa23da54608ec5cfb918fb28015e4a68039a5083cd9e14a5878488cf47b897b714b25b58875d0aa1b794d6c0eb8cea91a743a1a960333b349435ab24e4348d1da014c0afad1ad42f59799463b8e2df3fc7ac29072519c201beb019c9d2a8eaed8e5f2b902a02bc91086641224169b6be8a0e9f5d3a08f31b6357d0d7260421c832581195baa299b44473740967d9cbee45d5942d02aa2caa0da7df1dded4cc8210ba28e7b7d194b5f38994fac5dda41110cf0e5e2a90a37352f125ef6ad8d6517beb33159c565b2820c6ccc59c1c650aef475bea1a8bc2f22dbb28c8c3716b1d0f7891bfee845e9fa6dd49faec8b90e1b320d505d04e2496dc777ed72dbadd42bbc27568c761e22389f57487749e7883ff89c0e9d2a21b7de68fff91cfb32a60b798ead1e0629e071a4e20bceb6661173828d7179e0540bb0b39f21ac04ec4087bf12907d2814a6913b440e215484893be92a27d8eda80501508a1030ec7f00b9152b62eaeb77186fc4e06453403719cf2b1d11714141193dd8668116bbeef14d7019fc89ea03e8752215990ef61fe52042074e7fd03a92a657aea967b1e36abca9bc5e509d446946b71cbece9ebf6fddf8edb0798d5f12aca68b4ba6ad0d688d55fbdff794f3110fccff62f659f0306dc319fb6359aeaac5553d67e16f08d99329ef905403952d27640d90dc3b5b40949de54dfd36afb0404ff1c5583ecaf20e5ce1039c37b94c6b310d3234c7c6d9eac0ac1176df885b284295d5b32c6891af2ed1c6eda5065500b3a5753822abc9b5af043c3e2e1f61510dfaa66d707737f52b925fa9007980f60662faf59bacd540c4fef32719a47477c655922826532e6554360b53167f9449ba67fd20495559fd1000567f66d9d24148ac0d47fbe5bbc900cb3edcbe0b1ffcfe53be88e38af7701d039c05737dc1ec155d179f43ef53580504987e8413b14d6d7101f03fbe31ebf5591ef105a5bfac32df28e75316aae396fe2f95dad8aaa21c0ef3093fc523adcd683847bf6c84e7bd8b20acae8d4d3769ae2a3c8ef41d978b92e768d649768d2ce92b96fb4d9c75ef9bd1891bc1a906185e21c2eaffa3fe76cf6d4a64573b25b3badbe9a32b2e69e3e9b75904d88fff38771ca9a7b791d51adc27876f253fe1f70b5ad1be0a8e11a59dd53afc5436613fd82e7f3d8069df70bab61fa4df2d3cb83f06d9afc50e71c670d9e00f0b1cc6639b0cb17a56be5d2a8937182e2ff57ba840ae311aed2a73cf558dbeef32e92f1463a861ec03cb122336a025c0d45c1ecddbd299f35c6891068bc789f08ab644ecc57cc21b1a7df9b9ccfaa7ac3f846feaabd61bea87f5b08075e3d0991fa0d0ad1adb0947f3d2e5cbae397481f01b8c855fb0816bb1131181adc98c5f5f47e45fa96a8a01e63860956a26caaa5462ffa3b366a1dfc7fe07b06f1864ba8b190737eee238917d64117e63996dc8b02aa15b63b0f338df387051d7b7f0a46aa5fe8679af8bb4517b2ff6d718e9689c8e37908f17555a29015245b9dd278b1fe7208f090e8b8a299c5e36301fe1e1fab92258f04b181027056b7b19ec94f4573b159a4cf0ff4b756828a78f827bf371e4017b765da064fa5cfcb27a45630514d340534c5bfda3d9110d61d226326e35ee1f7747d82d839f5d5f95c7044e84e901a403db7d058b37694b1cdb8faf76ade86ea1bdec58943ec2d99e8508ea22a9388953637e2f273bc4f664a93057c8734d085e17ed987566c7ebd65f9f7706da1bc6554eaa3a2b8e36a3f08709363d9902275156f99c842bdaeea6e5486e3ca0e802e2b641443249e2672b3d6b5884d3f5183fc1bd3f28145d4cfcdeec1cc66b6bb62940ff5e4dbee828194656bc2042fd438a54313e42bdaf9e3435e8731d881eda213b84368102e1de5019250694434bb2a1470c0b44509eb5e4afc840937db96e84e8d7e4a3401152b9c16f91307a21265bc20d4f6807c63a6bd4bcbc7d5c0a52de48ba362a5b9f64c5b54a1e326d1ce7dc526222eae8f7e6387f77ebfe892faadf71a03f7eed15048efd24e15de740f9585d28f0f009e77559c41306bb154f34635b1caf9716ca8fa9751e18ad175c4ddbc79988509a6ff3c35a05f4f55dc66bf7a96b5cca5accfbf7030fcc7603692f28180e9ad18ab4c1ed3b7aa35abd98ca5924bb2a27a3c11b293f00a41994b7213515de1a18d7945611ebae0f8091aa00e64296eac846bb18589bb6b7b1a944284be1ff031a5bc68a56449260113f81316c9fd01566ce3d2ff9b100a359ccb8a3f4b10a29df90f08ee359eb00dd30b7f8d60a3b6e17d8f2c82fe62c92181c88197ddc35fec3784ffd1aed98beaeb3869afaf17a7cd95a5705d2e7f6b79003e86bf49eba41ef69568355b22459f42008ddbf75ed1173b2547ccb3155e052e2fa729ac7f107b13e61671e13e92381685f6f3f2e86942681068bea9bae302f7663a8de68e4bdd106a659019df93b59fb831f9401510ff6cb0600382ca9f0c7512794513118b5a70833a4460ce840786707920216ed2f99eeb4714f825d94cab8525716761d133983f9c0f27a349df8b63fe14b12ab994c6c2ea9e71892bad0165fffcf3c86f7d1d4ee1424209dca20509e3785cf78cea7d79268f1525107f6b04e5dafd2a1c46d2641e9472ce50e89fba773b3e76e2e5d24a687368191b032b30a6f5effea7818a9ede7fe0af066453d1beed05a3331dc1b36cf99c1422f1d3a7d6fab011732f34ef3f7cb150156ff2c89b7b632f3cc63b78d8f53c6f3014766cc45185efb4bc1be88e8547db80937b140bedf32b5520c8886cd7a0ac5cae2b495f2117f44c9fa36522719d48534eb2821c9ccc8198ea5af376654f1963ae1d77cfeaeef300df61c0ece440f19ba17b78c5184a9148ef2bde8a812a1f68f98f4e542c057dcbb882d4f691a03283feb7ec4ac5f49188a76566494405c6a6d1af3f2b49696e801832874b10fcae76d18384aeab6d49c0fdf6ed9f172fd583b82d238516de7ae36f9c660e056240bf2aa5072b555d6850e3a91fd24442c6ab561cb0f5c50b0e9b2abb6b8511cb67d3bc60da19e13550f502d6be4d525bda51502effc25b68f1092fbc7a406fd18be0944b921b3478a1dc601b03ce5281db16e4c98315899be26f2c134b42f9ceb98afcda678e0dc5eae01c4ef90f756554b80fc0728585e254bcac4b91524804519a7e5ae48e73d953366d18607fe4ca90cda934e65398232ccf110f1866584597675a7655dd23a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
