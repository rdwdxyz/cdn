<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cfac72b1719f3aac5a5b8fbc8bf06e39fa87b3e89767ba7ec271a4e871d945298cf70e098bdfcd8f8de043f128eee79dda73b704296d1c69eb627fbe253cc22f9c0066ee34d75098b576e8450b647357f9b6b47fd8be9a5974714b7a0d7636caa3b1086eea10f1f980fa3a87b5ad04291be6b30ff0c5415315bc3e35ac57cbf16ac222fa61e691eca5bf4d63c0ea2c4569e19c133ef14682c018ad9f5e270e43fb7517c033407a3183a09b8fea171339b26b80bc82b2e83f16d79a37887de5d317fb90d1fd3e332afd7a35aec6eb87c3fcdd0a676152b738e81521c15efda83bf52aea904b5e3a1c12a20746d9b215c43bf50bddc1edc559c8fdd9dab544abe1c75294c5616b0e5a1a6bd332ace807d934bbdb73930c7b60e3cc1e8fe5c39af040d47e9915d4064ad2f1b68e1e32456a2511bbdb2ab63769db64b0884a9eea20c0fea90dfb51506aa533909f25a05d9ddc78ae116a47de4bc187a5eef1f996a18a96f689910cce948ea822d4f78e9b8806111125a2c801a08a1c16b7250f933dc82c9447694b0c690b7019cd8ce28a6a07278e8132e2f5f5d65eb6dc8e6c33bc952061004778f7d1662a2acb1cc2992bf9e85bbd4e92e8a452f46497e54278cc312502e9854135dc46b5838284b51b4b807de17dbe91bc61e43eeb19f6dcda8ab07edcb0f4653f755def00e68d878c9e57edddee28cac78d716f016cd9731cca1e7838bfc944bfdc393df41858223f58a055f043e2a5c2c648cb73635e6506d2c6f18a5b3ed383474d04f0ce1489316d2fc0fbf37e2ad40caa7d8eab8577ec4c6b1b34789fa14bf2daf3a47fcb7c5b536de433e46b88d9350903a28f6564ecf562fce2849b05b237153e3367290bde4485c65d4054baad123111755212a478d846ea8f34cfdce271abcfe4143655cd27e8943d889aaf48527074b437dcd8767dbad1c0df526e9a2b04eca5f8ff25f310fe193c0372dce95cd46113fe151810337c389f08b461ad0c84049884d51ebc43f7c1e39721261715d114e000fb310eb1ac5c1a308cfaa274f75788289bc3ca5c7895a640c470adb7fcbdae0a6e801bb1f2dea1da13070584e59054f2f736c405266fff34b3525de1340941015a2c30c7bb18b0bdf0008ca4640f40ad6e1ac92c5f4e6147b2e25b93ec88e9f6d3eb722716b9fedbf03caa9698d08819ecd359bf59e6ff807ab2c317bfd90310bb5d95eead577a2fc1f39b726b3fb167d9a91fd5a4628a1f010e950d9f3e1ebd6836d49abc527e4ce2d4d6e27e751db3f97e3fb4e297cd9590731e5d1286d5e8ca34cb6ddc24e1506dfc0a36297a641d67ee2182574d1bdec5d589f79b95e310e96da2849b70877e8a0d8f8fea15cfd6751a6d905ac310e4d4a5f8590f419a413b557082c3481d9cd74446a3cef6bc4a4d45b8812d050a6ac631ff38a312f9294488d1f662b145adcbceae72fa5c7ba5886ab04ed352f1142dd651d891e2fd2f53cb2f748c9219b47796839264e623ad73558e6a3d210ca7998359806a1c1fd8fe683ab4c7a653cb10e1b1fe3e4110e6db6c7e759f67805ac66aa7a83c577327d7879669835d67307f89f70c8fdab410f879be4de1124073b9e90ea030ae472d29f0b66739c273090c25317e3bc43573ca0b55940bbf5b36a146bd4056a8690ab20e59be6d74ba9544713c7a81dc05d5056af312cc4812f7cde645c525c49d22efd418ae53cc0e3a16728bbdc2011fdd5c5b8ae82b8936b9c751ee8894efd77d2ad24ae6fb3f1cc22cb7c44ece8c3f8b107a7a65013509cc0deea151e5664ef17ba2d04a9c579c12cfe0c9589685fbfc67cdd41afd82a3462c84d7ab1805b645202439256e1e8bc56488b51b20ed79095c49391c93db6bcfb6f4a03d3c1f6f697cad83889406a44a62a1617ec284d782789520de9deaf35b44ae554f73b5cbe71b5d79f3b3f484cb65d8874361b2b3a6e2c6afc65bc87c4ba5a9ae18714d0877ca8ea75d672cf274c9c4ed9e9da0b3fef29f5216c3451fd8b8e9fb63c5870063a380b654de23ef2f8dfaae76a88c946d10f775e63a4faba616ead4bfa394f4700882bd9d10960c2f31e5d495006728c17681eaa7512f59a62f8896ee05d5fda4430c156ac1eda0e1b5f9b521f49373eadb32dc395ae3635e4e6d06d2d80fd4537fde3089d1884942ca27a11aee5b4c4d02fb4c41bd1fa33a05fb4a963a50e265678a96714e7b95e506b807cd9bd6e59e363bbc625282b3004aa1715941e4882fe169b196d6ff2360b3db5249af504a9c8bc6c6b864360e153f76484b50102f5b222f69ff4f077a986287e1fc9dfbe408c20f5850db3fdf833a45b8cd6a4ca8b3758d70278c225db84d5a815e3aedc821d1f9344ac58f13b17eecf1331877a91913c0ae943087011f21f188456969d8ffa6ecb37477f24b8c3b119d60f48f5a856b8ffc80824029fa8f3ed53ff7b64e42367108cdd7d782eccb7fc04fa8828014748e1182712b5fb38c8711f95567c1089e1eaf89f385df82dbc8f301c865c4bfd9e3d3a33d7de03ac2c070edb13334aa3e491c4709a307c140f5ee2753e237f5eacfeebacb2d74088fb118d525e9866d6e21410f69779df1a99d07feb3c80b403c8124fe51b0fa40a5caa1a66dc8908700f77921e684afcbab85f80ea7419b113fd3ddf4be5a44cfc9aae5ff8dcaa7fb4ed879da075f4b377b6d54c71f27ecd15c04721331e7789014efd77c93e74cb8c5f0fad6bc995b8a1a84c3d86405f272ec9093a1f8333942720370bebb2ef82ff7da57be58639f98cf4ddb95004e3e3e7666ba8057bb133026d0a1e37f2f676624465be6d5b980bcd045d685e375ec14f7eafad711dfbf71c50ba4e9c9d22778c5d224db60cd5a2072f72e1ab08036d10c082c843ea62ee75ae294cfc80733c1ecf1f68dab9355859f1805252b8a24624fe859f892f60eb2428bc3baaa75686d30f149d319b5cbbd04e43287e16084aa854a604d1095c010e3045581cacbc30510fb489cd45c5ff0aca62afde3e772b6cf9c0e655072852386847cf13299c415c8415391c6fe72b5142168d2d135e2859f3cc883b02fc09c7a1829dbecc4927ff93d1962e5b9b70332c05461726b35696456ebdfc693f1f25defd3b5dce955d0e96c42e7856eb7e6269e4d9676c6a90885841dd80d152466e49dba36eaaa40df2b667c3b67333204bc50ff8a70f05773f0461a80f7bb15f88323d3a4ba9472b30f73f96db77f3049a41281406eee5cb1df483feec387a83a00c17506fa2985b65184da198aed7e138b398c50e3fb512a809a2c0d64542388f1cce332138cac5b2305a1c1e26be36b8105d01d8196b79fec8dd316b6c5c091949dc0c161c48379e621fb1d6baa4546073b2289ebfb270d40fed73210e26f926d65b369d9435c820c2b18ee1a7dfdbc5dd8293f24e2e3cb72e27ab528de752b9782c2278847fe1af876a0f4af556656d5571ce160834bb68d000e0cf1bea8368da4e04fa80d64850a737a4a4fbac504635fa19d01d8b9d90a86e45139374df82f43aa3b80453b34728695b59033142b5d75e743745e5eaae56814ec0bf6c3c2c38c7374ce5c5bb2fa9c08ba53d097278a6fd02cf53959e7d9df5e3e6b729a8e123f6bb7dc1b045fb7ad1491036fa145798606ad09b37e41ad75e924232b716fea5b399af31e1e1f8d25cfb29d32a9de5bdc8a140a0b98e4dc83c140b9bc4d632eb79b386d6a2e9a94522838f492c1569968c3701a345ca4b8466327eacc48bf3e5f301ecc787da723813cd29132d0d691bcec5e502cc9c0740681fc3f6367295091fedf60446907cda4f968505a9e69ca80aa88ee5676d3d1af751c711be929d576199d9ae4f584f3df88e74e2a282c0954d3d2c2ca32f0616a425ae96f251f071c0c933530800f98d51ea584d78f9f1f1da86abf6991f5bdf0f73b2140eac84ea970674f6e1e8939333ec67771297c710a14f9908186e30a7c6426452a4cbd482cc00d0e27c786a2aac2f051f5581e80425201578a4c2036cd4a446aa90ebe7e78fbd219f37917f9ce92394dfe507ae8f8e2121cce4b858c8a5110c0ea989c967b87ff9437a56b16a0bce829961bf613990102b7a5e99fbd66f685b877944738358b50e4c6595790579e47f2ea4225eca67f43851e648226b54abe37759e299999d49db1a84c238e9746bc31e0d219db196d8601bbc7252d73dabd7601f82b41991273ef765e3c5c0754b0450c2600bf03059a3e9627e2c16e9b244e4e1df51e5b36677bb38f04f17629b3755a73a894180cbe98752a4d22d21aaeaf6199f2196d951b8f8f9911bca622e60d2cf2a7679b55931f389b4c126227d4456f1459d2f07e76a75ec935dfa50b00fa9fe09fc4118461c6e7df9785e33487d93480559c212374df535ebb53ebb367e78de7185ed7d496452746d03339c05077b0c13929d65afdd9b453d2f1aa72600ed47cedd27850199f90f323f2fadb48dd14a2e3fb1321bcc0ac52257eade41e2d26f4df5dfc88b7811efe752396f55d66b6f75df96a91d7b3423be1f3aeadf6dcb6b52f6aa4712b1fbe8879ba391e9b5f80197c471ba0070fa5ddb860757c516cd7ed124279a9f1d1eafef4723129e574e1ae9edf0c12383e9783284b71bf5bf384e0f1a6b2f33a4f31903062397de872be0329501534e199e1b58e369cfe21fc45701484e979d6b00fbe9a88e17cb388031a46872860f2b9f956647de74c0840726b1a91102da685818eafc76180bad6aea179c05cf8926443ef41bb39ab07520cb1f936957f455352c277b0f0f897919f3dae428e82584acea02605b96fb48b9ecf115168b68cac294f592b20f8657f15eaf678a43964b547321b43bede276ecce3e3964adf059ef15f6e06fed5b0d380f9f13434f9d5ee89bba61c8c22a06995d7b080d64d64eb00b4a08bb3ef0c4eb44ce71a48adc5d539312c4161a128e15dcd715fc029f1b0c83ad36f07648abd7f0335ad8aa2894d0a40d327ff8021556d18a774c77308ad3dcda60f037320f02d8938a0adc6c99eb769f804494f7a4b077d5768f74589617e2e6f897b8cce3b3e6a6c95d3015fe431fe1da773623a27634a52b0f9336c4ce159ae38b113e608b24a8d606b90e4350e141d1b3ed6d1ccf26111781cbed87fad627e70df872f5ccafb0c8e0edbeba38a9d4319ef37b1e00f2bf7b83c3c816623baa6f30a9c5d14c4feff9261da31f3bdc04d5294a2d4224c21ada8c06e5a83e78dbafaea78d0d79e2a7a4bbc56f163e7cb6f30910b64dba8ff5a814fdc576f389ec3fd4d21d767556eee468f25e65bf01a1e7c94b6fdac715359b34e06f609b3ab6544382aff2794ac172860af3caac267493d13c27a5ca4c36ffcd2607905ba24f6d3d68d77363d825ec2c9f93059e88d3fe785123b660946aefe32f8ac8bd9d18699a1c7ef96368fc79e78eebba905d62e4d0a3a3af4d972b9a7b57a5abbe17ba2ad7b31b2eec6aaebf123bf9e1636b0839d394a9aa5ca66fdfd5644a7103e4f3dca3a3222dbf67e068d56b55b7c309dc77c1d7d92ad1921fe0cb27805674df567012635a5e34707de5e0248a44401a70eda754c5d24d09a0b09d77a332e236b47d994d5b4b2af181249bf6699cc1e48c3a5acc91f329d41a81346b1e6ea4768d23f0bdf0569eb7811afaed91bf7fe527a6876ab023142a3cd7fbfa275cced3551ed063c824fa54dfc125491ab3dd175da19449f11fa5cf0239030e260cb3b62185a13d0099294fb01f22302f95fefee5749aa827d97539a88cb61fcbee742ab1174dba98ea22fca6ddafac207b462fa41c80f3c4aa91c44cfada1a979302e45f8ba754a59fa0728b3cb65b408e97be55181582af35677244a23e82351ec7fd7a46832be798d192af11ac0a048ddd53fcbf604253e9e7ab885348e6a370720f9952b6907d0b3a5746857f85debbf7571b3c843db64499c1a0b0318c014221ef41256e536521078a17d8301c7822277d2fce1fe5efb1f867e4af17ef7c4e58e151422290bc14bd1252bc3a9440fab025c93208ea3c6f390a1343ed22c2d12ab9f9894e62a4acdc098339c70873890801a9e6318e1dbb9cf64806c2936202f488361e782d0eaadae94012d89f643447bdfbb00a548e3a7f0ff55ac87a88a50023db5f06098ca52f6f7da8cb48a1139b2fdd42e7175afab864a35fe4c7ab1dcbc9efb3d70dbc6e181dda3f0d1259d7f951cc313ac69ef05988109e66c6762939a09290ea9a3f2d9ccdea15633cf6dffac507aeed00c6e8a382e1aadf954bb757c127121d67b9e6325688bdee564d8eace87926fdb003774f2a945c16da8ff188d9305c7c84448625aee687f4e6d618fb45b683aa028bbaaa87ed2020682b9d76cda98c464b84b46465f3ea5f6235b576ad7c36fd83ebdf1a7b4f90e497ebde1d2aa0583fa520064e79981df6c6af1222c7e8bc082395afb2219090a9eb1ddba34f0b65c76695f9a039a54da855f16c7c53b696dfa4a3ecc0c71f5fad1d2b1dbd3092c3fad019eee7fcbeec4d2da5a556ee513d41b8dfad1ef3d8abd7c8b1b60039874cb48f573e0d27f0007aace43e37c60f5a8de43deb2f711c8610cb0b8fb3fc56953a1fcae2ac3cda65b23b764f5e76efa19c7c1d773a0dc849e83d54379ee4f80d4c1a3b84c0856d312c1d9c245a5ef4744fb63970d13013afeee463fb405808f547533db2b660f8047f231df6db3571c5b9f01eb23ccdbe61b28f685c5af4e978405955206ecad41e74e1a34909accfe261e51e6e6edf6980cf24839f04c4eb62e7c93aa6f2d3393b7c0736926e1b5551ae95912e476bb6122d4a63291605573df45edd2587f3725fc908406c5a2f2ce8ba5b299bd3c99b89297411a1667505abfcd8a3efd2cfd2d440167b9f2ce6152b9b307ff2b860d0b9ca031c432b9ad244b504f26911cddc8a118e2df3eab7aad1d4a6ac9214f7ed59202080d9568c45e8c99026139255f06420bd10da9432654008da6913142920106f5c633bba286646d40867125e386005c39ea8477902ac3cbe2ef0a76b4d103587332eab271c984fc57bdd272191385b7e4e09d543b2ec40f86b4062b76a85f48a5f767bc60320a2d05143413fbd932482afe8607264d11ed0e76f6c6c804c2d4539f9182924bfd5625f419a0cc24b579d423b18320e70569e60e482593d4c73625c72a5be66f645aae066a5dcad8a363ca5a2f3870a2dafdd70b2eeacff56ef374f3b30e69fb50795a7d4133c4a7520528824ff77e5ccfbd9c01f5d41836bb182c1f286f445ab5035b4f2cbf11fc265c79f10077caaf09a0fed4249f49dff5dc820a2934bf321029b3f3f46a7fcc7c53d1dccb4c4ba04149cd876610adf1ed456ed7c537907241d6e43b2f09d57d397bc61dc21b75dc232b7b7522cc2cf78bc838e9416bd2ce2181f6cc85fb1f24ba1620d9cb45a5fe209b8627e61a2d520f6f5e4ccfb5dbb2cbf27922285bab3e938c02c0dfe70d7484a7003987685d33e3eb542f2ae3b9798f1c2308edd8905fac439e84d77b34c0db72dc5e92e4098374e8eef907ba8c0fad26a6791ab6cd7496feaa3199d08693810bcf2b138111d6690a843068358f690608a9c0588336a6f4f3eeb229bf9db97ec43fafa2dc672adeeda0d6ee64e05b3fa12e86138614004cb4677b887f4efed984da7aaa6b79665cb92fb69298d98198735abdddae7de80eddeb7eb0c4934488ba80d1ff9b0bed9031a35cdc7f075ba84ca6bc736ad21fd03211f8bf13bd1040e7ecb661fd3bf115f6236e61e5d2835467fbabde9fcf9a4f246c7098a2f4ccd6186dba7c89f62610e6a963de30c0762cbab193fdec1ce84d8ac6a4b540cff6086ff540b08fc9d3f12dae92088991b4f7e59c78de093f78091038e9edb4aae9d12466b4b54b382fc3f250480205f26e858c57e083cde1021149445b0fe4dcd6f3e132b9f8a86c81128a8e55fe7f06d57cbaf4b3e6fd6c6ca70252dc04cdf1550d48ff81c08d2183e611e8db87db08ce9fb934f6b383c261dfc99ef6c0018953ab828f6f35e60127de72d12d8b95352c3c2c65352e0d9b42d30958282eee1a8053584a79190b3aa8ea2002c91f637b5d328692b0bf43ecfaf48d184308ac0cca7d4ffbe15d9180450b6592d36bd8c1e875fca4a4a4b5c5bfff3d55b797f0a6403a228f0ac987407ac939fdadfda01dcc3b3fd5407b845cbde808600cd493f9af44e9efe72397ab4a24a63d1fe7a5070108ced22631b77651fd48adfb3c62c88191a28d6f966498105c1329b88e22b9fa11e9c13c448734d0f7f79f798e05589485c28219228d5013327a7098bc1df7317d519444fe83c9aa432b4fc5e184441eab4c41da096dd93458055075a277671bad433bdda4ac7efa7cd967c87c640f0f9a529d8fa278b3775db92227683104c0281dd1c296299037fd2b633351185910ff8f213ef3b388402b89747bc4c595a1b25c2dd951b2c8df1e25db60440fcb403eea122e0165c60cb0c4053e27b53ba16d4e12cf3a3b9bc077dcf496edafd2206e14679f8199eeeea24347a0d8cef74a68a7108a324b217eeea9d63e0886fee2d8852696c240d9767745ed34a902035f7fc78759954d33c8f71119eb226accac51b0a28f0c3cef1fb27de67b87dbb75c4054fa1d577035fb0c118e851fff2fc278c5683b21036b00a95d9c9d0e819e80eb8bcd953c7dfdc83f1b967c957b4afb07a0c02bbd1d2bbd436a1e4e28bf07773b0076daa3980e1b5e9bdd94eb18fe74f37eb5f0803c06df263a2b1898bbf2cde8d0faa1b573c66369ea05a8a4666b133285e7bbe9e40c134e730368de8dbbd844c2ac07d6869ef1996376e746ac054520f7dd0a435ddec043a3bdfd13e3683951fd40e4f5cdd3775a52f2f8bae81159ea5129af1cf98ba73254f4eef4cc1151e0698aab7773b85e7f6624456fd90f0b5c81a5a8d6b408aeffaacae8bc422c780aeea334da600ed8e411cd3e208aad8fa967d536a2705a20f22ab834d07200258a9e19e9a8f1fea7f90d9691102c912cea7f7e64bcd81a1d91430bfc6bc7ac68178e955b0296a490b398c67d6e31e07713a335dfbf5969abd335f5a237d9108f8967339ab91936d9125355bb4513ea9ace7244d582fc71f2e873e92a310cd2de21fa323d924ef054f5dccec60b54b952453ae9d2957044d49bff88e9e713949337e7bab38570b11b203afaae8cca2cce11b9689cfac0766fe73e923bef6e94a7b2ee68b26f658db80f16bdd66df04214a609b0f34aa8c367058a2099ffe9177a49549847b3cad46cf6f3d5e7a327b127575e17c59c937b63d244954e8d699d584b4e517ba9cd034f04ace051f77df2baf92362ff57646b7497f7a78a611aec06dfbd9cbc735c928afd7992bebe68bb1ff4b267d2814eb24020ebeaf0ace2fb922e155ec90def799fd32f415dff51cc415e5470d650c6d9c8e7f0408fdfd8495029bcc8fcac755aad1e170fde5659f0b60702ec9435b96d8683318331bd9a1ba1bbcc01cd8c41a1eb632d9ec94b1a1cd1a9bf29bce85b7570c38e39d8bac3e42e82985431e32230e036d83d12a019f7e3d775c55be430f194d745f46313d45a4168663064b93eab219a88ed6e77a65757da8672fb23249bfe18eaca73e04aff742528d89fc2ecab124b9bd3bbdcdd9ca49f121bb5e50d605c258a0e6c3935c7aaff4ad6ee6480eda5800e2d9784979cf15fcfad8c3a8abc20d69fe3b7ba55b38d62d0ce86026a4890e352f442e7521c78502b6c494fd6888b2cd599d7f5e1e78ad28c6a6c8164da111ade0d0e39c424e050e59e6607983c65c6ebccb5af32cd4382a625a61e2a94ce8d95b389f9c43ebe718ddf117a5c9ffbe3f62a9ddad61f6246905797c68bddd067b7407306695dfc4dae127b91372c4ba3e1f2be76fe73e21c025e2467a18907476141963a5e44d0eadd5a3c1eb0b38f3799cfd4210bf09e314a473c2fd69d41f0bd79e67a1dc9f042efeadab57bc0a00b12bab8718a1151e4e67ef4ce5c8c455918e0c0eff08adc63ca144fac87f4f3c154d0bb591519463b29600d7efc2bd59ec861b50f485b635dad9d764c8ae5e876c79e6dbd1f4b917bb6d45ee050229f968d44313b7fae04bf30a130200c6ea989d8df0992eabbbf5bb99aeebfcea9bac3eddbac94353afb16d22efefe3a3d86b91e0f827453181990f6fb83d20d965aafa5f538d0e47fba82e00bca151046bdcd574f380706f955dfc8446de7f3a606f06306004905ef62feb558b11a49a42ae36ef3ca1f5ce4f0c3afeeeeaa72fa2487f1e273e7c03a35d94948563717fe1352e2d629d263e0ea11e45a3540d0abecf65d2c62ee379a19ea5b86133d10b1d5097da12d5558aa5e3fd69fc4202d871dd2d92cf4e15996c4a243fa49fa466b7a989d91142864c66c7aa95d5fb8a26dd57cc6b0d5424260ae7cc50836e69109b7604310bca91f1250d9c056d2fc76a04c5f09c064cc7dd2ec2acf4fbb3594544ddb5f17b5ddbae2d70171bc14085ee25bfc383cc47e3d3485f904637e0735524843efb6acf6b1644917202b8740748c3dc8536b0bf02b26b27953f4d3d56b03ebb852f801bd909d09e5a6b42dda4e3adc2393175ca7a7dacd26d3f01cd09fe007cfa3a76b6102b09dc90830c6616394d402a7dd33e7d4a66dcd19f4c20517f1811e9098b7709ae7f4ca54ce5a47bd0d9d26bc6445f230d95a4a7075c3936dfca9d9b63e8880c0d5dc7041bb04f24cbb2857ead4b7d9b06ebfc15d107512960eb5fe8483197cad2d34c7bfa342cf04e1cfa8a80f9a397fa36c58a5d3098c68b3b034817c19c7770f3b2123c6d559fa3e0d6a7a16b40240f2e4c50c8016aeae9fc159c2bc7a9fe6090a797da708840e9b3d5161528d958baa49e3994ca23b33ed82060afba3b0b51b6e4aa53414d258df448ac94dfb00adbfcf5c9a193e84a42c1a16c07c3170c616dd851a7faa9316ec9c4c949281ed3799477ddf36ca157868503fa695a255f5c5d69069d0efc22a0a6931a3934cc867129994e1eec7f07f093c705f4a391e40b059310e4193a981f3e5a2b83302aad10f7febc491f0fcbc6e87204f85b2a7c821d5324828f41e9d3993887f166a3013615aef28443f67d33f307c6d1733d2fa92dce5610641fc136717299391010ce6a64819f1d843b1cc43ce2d05c12ca90097e79003345bc3721e75f731f9803101bd786f949295277dfc6dfc5bea3546e5d27229f325efcb05cd233063f70b70d0a80bea6ba2e336676467c59e7ce74b48fb064c63df90c26e15a2a015b150c3076bf6dc035dbfd7e9033733efc29b1a1d15b9bab16442ea8774bc2ebcada6af9bfd432d8ff89a4e0b1c6a5f6a3e57370814dc7c1e2a11f04dc37a091ecc8e74d2eff15263f973a8fe53a51b92e6373c47b780a9ec773d30a856a1d11cb3c00272c7365891c866e39ac5d26a0ca4af114bd0d31c9ce10ec92468c0b854145332a9ef6735d281e3f43e3cc0e8e5fa0527be69628acd7c2b537910fab421191bda219d1513b7dc9e4eff21c939440edef71b21a0f43467e2ff6b386cd58444871449bfcdc66edd77f082705a03da7a16046626c38f8b7755c3b37b29d4dad0eead363a67ef184f3dacf4ccf5f150327346f8fbf4b269c55c7fb81dc0aabeaa6c8cc148dd28524e8b156f31ac9769fb0d4d75018e6a6c6c3dd2ec56bc2d34b47efe405085a08dc36067a1c48d5d7f98c1901960393ca3fc1f707a8359374655d793b359f050c8ceb9912597b510981434ae27eb260a2ce01dfc5b2e921fcd37b6504fbd9567b732f85e96faff8b29de509870e73a68b0cf5ace3f15b8db3ec4ab6ff9eefcb3c857f2c9d5817e4b22d23208c962462a74bee1fcdf9e921a9a210c8922a79a35572f192151c5790db908e5147204a73c990d30c13c74dc0641927c95c8aacfe52819b0f7e41f6dce275c938fdf418deaff9fd6aa3c4e9e62c697a3dff4cba476140a7fd878c9ea590e52ee6c0bd3a274c4548609176d81515046817a637c41edca93703c379f2cccfb006591fa750c9fe308ac5dffd465b65d1448fe03bd9ed8de279fbfe981cf695e5a66d09726687e1da99c1a3e2b5dd9ebaee6ed6cf6619ee4ef2ceddd1ea5716e53eb47ec70c692c62d4833065c0d0271d1ba2efbc98e910847aa0ef3d994aaf04b6f27500e8d890a69cf715a17f76d607d94fda9175168535ef17faa07bc19d1852753eca4d901c6477054a5b524245f050d4c1002ccf10f8f550dd996e37fc8b2fa58915d0dd2e7d00a1851c202d0f42f919c934ef5ccca07ed965d5a922c39c51348d80003846511b58e073c9f0269b7e6fbedfe645b45726d49ccea54c21b0fbd56731513c39615f37a9f4ce249af7952cbadba3758b336406f0d1007eb4b4d48c55b8f8158e56e7ff1653cd0534093b0889fe66bb9ae5fc2c573318111d4778180178460d82fa1d9492a59102e33c69e3991536354299d51fda8939c479241c5f42bbcc5afc8998f10c9e26f1b696a33b55e9aae54bcd98cfd4fdf66e39635e8ff3461cbfc66bfc5dd5ba673f3b3cd330bff20a38f96950e5463f66bfdacef69df0ab0f42baab7a20a156af61f4b5e761021b285928a13befdc79ee81cadec8c32a159d6bd3d6b6695317f8bb3c551c992275a3130d0148903a17f1d90c95d10a2555c15fabc00cb56d9dd72579ad50b42d6e9101d1d7ecd17e12dbf82003fb639cc5f89a6982cba5f22ff7ad290df55758e3562d76344e44fd64fcdad8b03f173f52e409ffe436c064531d77d5b16e3bded7a1de2e58f3f4ee90ebffb31f6c2c938a39d38ed6bfdcf77f438ae08a29880ae1010eb1a184123b12c1281e1216c99392873f95934bcd0c24f5e65cc291d3d3f16f346b00c935294f96905e5cd0b6552cb39458296ea7e2048f25086e6cb7a5c1d8742649e719d9996bf02c273d26bdf256432640645f92cbf9399810dc686bdf337d9ed1e9a0bd51655da91c67605f6fdc03487a70e4a8d829a408ee434b000382a1ca1532e054fb45d102b904b422a12656d91f3ee273b320ad2f6945d8cfaeb222cd1deca6e8b516b5ced2f4a20df17b8a1ef2d98de076c0019aab3f73156940695dd52e73ac62f33eab19cae3b1e7aee1b4bf35de0a4d2ee293bb3162733a0396adcc04879f1b57e9523345262155975dd5b811a4392377ad434d7e40248b40288b0ddbac6496f82828fe18200c0bda4c782ef578c8c8feb226c34aed824af79bf747b3fccf8e8bc60fafce19843a2fb03d9103fc335848d0558101241512eb1a1e1b4d520f5fb4394ed437bd24f98acf404d9195b0ac139af5053f4d8f1012e23913aa6c33033f1b8e6102ee9d4089230ff5a624a26c246cecc864e6e93963f3b1fccfe6c6121db15c51936a4d9d7a893fed124ee082bee083343123d5365f8fcc83319b9795affa63a22fc66c95ba40bd3ed6075d6c169f8efbc3859e6dfd054a9fb66862d20e07d6a5daa953710d1ab757746044aae6dcd094d210f68f8b9fb27424976bfa1587a24c76c5cc54a457bbe372962b15c2527b3b51847db569290c9fc1f5ac49266e081f51a6a6119a2329f46090153c8c1edb8d634d71ee62b74cd76e3e75aac88fad89189991da38fba61e1146a2ddd3a1867680c925ca18efd641bb044e2bd6fdb965ef46090cabab47e3b318c591a79b911cd80de90aec2c8361db88dccb385c1e96aa8cf20209b7652d16672336545a7fe56bc296392369bf5590b4f081c8e91aa0cd3c12d996ebbddbde43319aa7cfcf5a7a364fbf4247e5cdfcdb8fa07f5942ab90c8542fa8e825b9a0242d26064ad2314f6e3f61785c201a459ddfb1d5b42c6e5a0943c80256f93e122971424d13f8cf60f3dbdfb99a10f46171bf8bd3c4a1eee01b6197c256d18270e9a7c5603f85dca7326a037e133a78fea347bdf897cda9215324a360e08d04e27d504f8db6ec7c30e8306d363b21e1e483601c6390f95970c6c2c57147faee9498cbf33c3196d93e759650492fb19fa98f557410fdf98e7c6adfba4419b4927f04e5d320eae2872f015fc7b030e1a9e283c9d4fe78255ff0e8c10b40c0ccdd90fc792b59255e1f65d9fc94c0917bdf08746608cd8559d984d4b596d155e4d151f76b3e00d8d80273aaf1e73a465cf4e4346623121e653c16e30492223dbaf725028dadfd65d399b2d9f1f71d67348ee8876e9c44e13dcadcce10291632127c222a145572dd1c212df623176bc3c31384db8c61afad05b7a475a6edc424f1bf0ffe24935f885e5dd22eadd928faf5d300da5abe41644e2a916e70f946dadd3800746ee99d860f0dcf7b3ab70c599eed92656c77863fb11af96775c05bc99112e9154edaac450cf4f1ce26ee7add489f2ad14f51f6071695d5d77e64a945ac034b089798e3581401ccf897ce82691a8c71b4ee1519e5886e6d3134746b76e6cc25f2b5ee0a287c816b83deee5c498b7ec5749260b8e9dc3c6a586bad5ad63ec4258e415453420a55b9fe75fa3fe9a6f9b5ab9d5ba83a89f1920d9932300dfb1476241729a8ee042a7eac6888d17b9b29a250177efbc0b4ba7489c2dae36121964d36b1520b93a70ac95ae1dad1ff71b29f950610167ff459b79f8121fb19f07c1994aa05c220840487ab513ad0bf80721b79361e51b97fe46b81c6f2b44b7b7bd53e470b93c96799af3968c1d3bcabf16450023463faa93e907675ed18d531fd7a30bc4eb7937aa8183bf148051fa17009ca3a4d445273bdb427a88f9b477fa72bd1ecc5e71f42b230342603544746c7d418027b0d362616eeb4277b7b0db8866dac18c5c2e6899e0ae1427a4d120d848e1f65fd53e680690d45fa2bca3b75032e92f14a751937cf4376881fc5b9b84060359ad55841f0acd5fa014eea47aca2bd79385541a6554d8a9d2ab54771168d0e8671c88602405fce9c326ca6730fcb32d7f725b2c50abb29e24037157877e67ce273f2437c740acc4b8c3667bdadc2c7d5951d03ee582559c2437b62e6fe96a0888d9b2894bb4531dbdee3d121812790383aff199ca3ea9860e58e0b72c62900ad511f5bd3d308355d8d11837976b4ff8684afe5da4be77428b6c8ccb3d27b41524","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
