<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"697c4568112f788526f433295c9086978ec760b78f6d70be8e6c27e0e6ea9728022ba3aef62cd3da81cf3216bcbd49898ef84064e293c18cd19c98695e58bfdc9de0dc14a88031b5751fcf38a99733a3c138202643c26653f59a7c82956815980117f6ca6a16fb55cce15d20d44cb680293a39a3594c07c8b48204527aac6fc591ce18ffc0382f0c8fbc937aa29a57cbf68bc18fec679354a740f766595174985e8baebe5312934f2980da24b1f89ac3e5930d5becddd279dc29e27fd58b4c12468ef2ed31c610660313485370a6ec89b8cd05c022ece190cca79f0d6a333ab8d6ecae879f4714c8ff976715f771d83790d911470367057c2b981ba15569d4a65528c129e96d0eaaae2f0c1b3ca635bd90505ad994fc84916be569e82fb3703ad0e97f9799fe36f7e07524177a329a77afaacfffe8ba0548d3ac980ad05fc2db00caced12778f2c2d76f885b25d4ff56e9f84e00fdca9d35fdd07d385954011f99ab7f366a257544ce357ee1c84936144fa9e4e43d79cbf52e71ce20cfe90823b0f6b46b63abf0418b0dfee57eceba74b52a3756e26734320ba24239da8ce82d0f92ded942448a178df93a6c87a88dd9870f045cfc977e616ab23023a44f1aaded9ae1772ff36d1efe3efe047922db10454c4bd5f9f6c4d4877ac79108d5c9f406c543f2d4d962c75a44dbf2c0781b1ff62aac714f5e6fb190908a2ec9369831b55eaec44c9a25588074dff875de38561a455ea3870dec895fae3cbcd3bf020bacb3c32daa2f5fe71c07e053862ce55efcc810e49eccf09e2c8a057fa1f8a331ca70c9653c8995d38c350a4fb2529fe7460aa69e88c274a4d4f59bc23d5acff950e9645c036755cfc2cba2d46a13ab409cec1252bc2e0868be520d218bace69c3b36b4e616b04ebbf2e593025cd000e8809730c6e9b03e044dda05555e6c9bb87970c56bf74688871ebbbca8012e032427667d5c546612ff21b72277f2864f003746d60d3ce2dfd48ae51624b3cf820012a791b5a4bb186d9f0d21baa32c3340bffdbf27553eac7c2435494882a20ea86a38ee9c6663c8d7b8b8da66b0fd66d5a74a0502256be3fdf16b9fa54489866021023452c7b2ac20eb4805fc4b82c20b617535d9031999420059a70d6f2ff0e7db471ad02518646bc27feefa7944e474707e514512b36875355158005b63f4b2bc26bce813e0b125f0e81ff4a41095a6be61e37afcae9388e6373d58cc0b128c2c65ff9b3eac17a2ee79776617e658816b4122d2c60177793f9c8e7288ec7869b9a514322a6bd3ca3cfa28c09dbf318f05d2eb2d318d35bff2dbffb2e59105fb067328ea3517ca24ad42ce72751dfefd8074f1c8030fed0bf7e08e8d89080c772e46813773fbfafcb905600c983b03c76b3e86472bdb1c6df0cb3106f7f5f40e9dc30277b06726318328370d71d7d50f427a92e01c419d0cd30adabdd0b4d17d0c0ea369389b50a5e5862bc1a12a32a644894a1a53ab368d8d85a87fd968872ba8695454b504cdb4081caec8f29ce02af1d528e45f0c046fc3e26677b5a23c4ae63480f5426983649ad4fc80c096ccbebcbc444852bb3639a8b78754144027ac15c49413b571060f26440d1cddd5200b3bdbc929dadc9a1d660d68b3a572b0a8d3df5118a967b27bf8f87627449cb0404d777747887e8818c098eb236b12d263aa46c9b846e2a91dc4d71201961a93f75ef96316df7406856d869d06232369a232ec65763727b735ac0b85aab6199c98f5aa67a8723c67d33305cccc7a40bf71f8a2cc4bf45e068e1c374e8dfde0b15103d69bd0e4e2586112e0207c84f8f5f6500d3954a5edc9db67cd012b83a90ee853d31530afd94ad54964d38f365f46d6d4182ff47f63552a2f22d22aa8a051d4227bd1ea688022110aff43ffbc1230cb71a4a262b0be8050d93f90c0151c2484f78ecf91c3cfbbdc65be7dfb872732fe1da400b86191c3c783804948429386b652c0dd1be303d6a60186bbaf1fcc2d20401b1152883c0ae8da58bcb2dbfd8633007dcb35ca786079860ff289b838336a44d80967408016eedf130e5b3a1b6c01ed5a860790873ba2ff8db107b2071ae97697e0af002114ab4119e5c05ec3cbdaaf1eb2fb9129e11948587b5c95336e31568131e90ebace9ab07b42444752b0ba1642669c93a1028b1dc8d19658011326238eb3c9626e4c5ec26baba1ff69b0fe2b88ab9ded1970a4f93351381b0dd5d2304cebd5181b74f2ca148ecfdadf27825f9b08e26b666a5f9832fa397578edf4df6b51c703154c1a423dfe76d652d02133ce8e2e79a548e96a0372f87b98d83bf629fd673c798d7a6ff469458df423f00a3b58835309a2fdd86dcab5719946e33c6ceaba92de2a82870da989c44c496eda7fba1f8d904c443f3b317c7174f944892341aed9ae0f7449dfab6eca4e726869b529a2d9b73e458b8a0752b6eac4b13bccfd891ca1b184d415873aa66a420b26c7dbb2f06d34dbfcb5e3106b4c108486fe28d1ab232b14384d54c605de0c44e9083abecd2735e7433ee79c2555650333cbdba2bb0434fce8bb19fe0cc5ef9934d5ed223b4d48e49fb7c00a9aaddfd76abfe13a155abde8b75ab416c5bcf384a0095faf524ed9afbbc24270807916922899553672854120bb7b71c95b3f1a642513bf03bb198c19559c6d8fd550580d1bb0cee2ed4d950f36b4a9ba5ea452ee74cfc427e9802ea1da6242351450fad548f8f15d0d22d6bef3c7f61f6a871cdcdaf5ec0d25799ab08a259e04189e63c337a9af2568bc3bf0d4f60ab40622fb76eb2e01255efcd469d2d80d1191aef579be70ddc11f9df1991ff7558556e88976c249f8453e1f0a0ef22e4a2baf36763a642c0788766225994be2733196a0f581c22d80791828e97e22497887adbc74462b4fb2eb924dfb1a9bbedd50d5fa11b79b9e607cde60ad703898eb220e2d2ace9a1b9d6a8c1b99001bdb8ecde044bd7b572e0fd877e79cca116867f6b88340aee4b6861e0a5f2dfc45881a551f4c141d29fee5070a3bc1c4eb31eaafe6a1e11ef9922f96116753d4378d2548899dda743aaace958565d8a8be5156c7d5e036dda3ab556558827ceed6a7e6e0d15b29c3992a1be3a60411afd34d988c986148c5c36799f63c69afd19ab3318cf64a4bb2cedc8ac4d9d5728960464d73aab06553d18860345536133106825cb528bebd3071b229cc9a419e06c03125cb53916a61600b616033c7a5b88425d0b9cab8fcc0b8eba3ca32c305eae705e786c879c4a187a647d939de7561bb60343ee05683f4010427e4333c08245dd6bddfc1d0ed282df0266ab4a01a81982cb99143ff9a0893efc4b60947544b8cdb7c74e97a5f435cc1a4276fc806bdefcffcd8095c613672a026b9b1592e34c507b6cbda61e9db1eb66a497f5e55a9cd352e176051759dbb4f298f5f34b33d582eb3f6f4dbbb492cacd464dc51fc2c7fb2c2f029484c7d6a70627f103afb72934a1a4923ca1e0070b5c508c4afa312ea8a8b6945a0ce07cd2fd519177fce3b84c2a99837e9edf4f7d479befb4cf96754be8ff5145fe7aecf757ad096252bd0d0759ba18c829d0d3b3eb0c66285cbb3d9f65676415d6c2437dbd6c7d7564b70210f836fb8285699ad9a52553ffe0c8282af59e33c3c15491f065d8c348849c5601751d0a1a81e9389ce2da66bc92c5e9cc295db948d55a4b6b0dcc2fa800f8bdcdca251d210d3eeaaf0bd70717bfb3aa66f06c10a0ccc96fa6d019dea41bea479aea75992a6211a394f8ed00bf2c7d3eef648fb4371b2ce59b9b6d803f05573fc0401da46e0328f7bd6fb29b0c60ebb69672bfdac24cc5e3d6bf9e9c66ab1b04ccb656f02c368da13636c6b0e7ad811647fa3170617b288e1b7daaaa70b4accb90f111d034ecaa652bcb3979648dc2beb61ab7197d4b1ecc8b759a8e870533cc89773603b696baf2d89a53af48ef303378a5a3179065c16e853d371296272c3980abb0043f56f4aebd50a2d65846326ebdde677dd3b3a5ed2701e698d979d44710b16b45cb079af52289d3713a00024823ca08154c78104a6176ed0e96b6f635dc99aedf2a7990640b5dcb9e3f47b75096f3f5aa48c92b535647c7b8084c543a467afda9705235843d008194b8409e5b1ad864a0894bc42cf5702a1ce2b79b2fc31828863517c408cf1b2dfb9e1bc05ce2df49150a1e2b7ec6fa6c234c65e9022343ab5274e76c8b4b1a8692f74444dd89cedac8b474426864aa65410af9e3ecb8ce5fe5155f031fabf4007bb1cc38f101f3e616d84e423637b710a18da50bbf0b7de12841d94fee38adc336ded714a2f40505a03675ae1f82b07a586e50ea0a0153eefcd4ca84b62a59384430de7ea44dae3278d66b7edefe062453d16b4286e7abd90c9d24f231a98a100307ea96b1bc03536ca5922779720533cab2003fa5c1589c80d8458ac5e751c8533af5b2047088bc6c577820c3a16d83f9adabb8c07c98ba67b7d72a52ebbc057e00cad877e75f18ff51e7c27293c73fd53c615b6caab5f05a36f2b1a9971160ad4b6e3be1ba34db1f61389350c4ab7e3af98b80f8d557e95fc97995131e456386bd28fd7b81e0206bfbac9466bd8c6030819bce2875c380b61c78c3c2f6f18a5f4d84df86fd0a3e9a840c645d516c0a2b2d55a2ab6798bcfe24d01ebfb3e98482ab20e6186b8af6dc7e0d1d3818990085e860f8e8b95eb067dd4a1dda9aff5432d3c94f86107112750c62634b3d14e5f936ecd3130ba131ba7a287dfc9dc6e03a6bac3de336dd3635fd13d1aba8de3cd97b1ac75c0b7251ae152ea7160845b7bf88fa74ac2d382a968126172918a199bb583d6e76256696a4f35fe538543ada5c8b734708defb28e0b1e12460455d006db13d52148a01a008df5aaea75ffd608fd878a7c679f691aa8826c90b772a4321824cd2199f054e16190b6349f2d80fd2d7f04a8637621fadeadc1bcc550d6aa2f30a9cc3305607e2594018dcf025adacedd50f920866e75167457645206715f7a9360aaf53568bb81423c3dd231988bd6d746222da05769ae505a489f1dfc53bb32749db79f1da47cd5f31f3bacd25bdd22cfb940845d67a3c19c1d5466540ea66a95a0f50508d0da45d2fc83bf9de376466fec4f6f6eca9f62c13d96d49ccf187350d9d6c3abbb1c3f87231515546895e41fb7aa1e68c96ba46b79273c90098bc856c7d04a61ad741c302b80d912053722205c77a478b782c539a25baaea368ed31d27df896fe67606824c1804a2f9744323a8c10b53f39f8064baa313859dc6b24cbe6d4591df9d988fdfeeb07e0eb482ba6aba08195f0a2f3172f93fa592b1cf66fb796886fc3c55468d5873729bcf89d1a2de1e0fb35a69f1e390a3645556fe3e34058672b0de9376fbb0f2d05be2da2f57da6117b7bd248170b4c47e7c1a4a234fa0f5b09d5532dcff67ded5f16737002a6ab18bb053ab3c58d7ee619c11284e2a0859a153b013833d22e38084a0ff7911f17137984d9853f38d4b0ac4c5be38e8245277349ca1045309625f32bc0ea310ac9c9eb14c7c6a01bd41a491e893f64b29f77c34d2e78a4e898928575a07046bbefb1d0c9032e5c0aeff8455b86f2ba135a72aef1bb85ad3f1e390f34ae2ec08b8bb2a7b6bfa47553aaa60ecd7261c4bb5549fae6b494981d15b323ca04febf01f4f56c25d4dd183331cf29e82b3b06a384347062ececfa802eb6242edff5bfdd95442c3e9b4ef84dafdbf5d774e1cc8c3542bbfa35989ddff0901ea1b18bcf659e3d013e8b281f2da3153656ff6347224a36ee93ae82ff01b97bdc1e538d7defa35e3beada069d65c0fb2342132e31bd903102a548c62a6ed6104e490a21b41d4f35ad933982e603996655be49770cf9d54ea4ec085aaab7b460f833af032e3959147e60c6d26b9159ecfa6c237fb893b93d832683bacc79f15ed233359f57afa2e8840b040fcd10dd903704e9578845d7e9d08e4bb47a11979f3200bcac76157e3c72d4c92bdf301181d593ea53f71b18c1d972916a7c0a69a06c44a7f956aaa7ca064384109489bf44ef03728d85fa7715e2194db7b79fcf1dfcedb768d135e6da68707cbc55a45eeca1f176c21af0affc655445ba23bee3e998d81d2b314fbbfd14d54ce64dcb5be397aaeb5bd5534003d98a7e0d02f04c07555b393fd8af9acf93d27d55578029631db0537cb4465009aee9141ad8db87c3ebd5d1719c0b9278f56dff4039c731dac9ab2c4a48bd39da6a2e37488d177de591df97ac5baa1afb13e9da9b231167256164c3129cdc605c9d45786e52a7be314ea437dd23e04ccba3379a8df56ad91e9cfcf3218525fc9177829a40e0e4bd57caf4b7bf66e8979eb18535a23039b6ef798fd538cb5f629712e1d0ce2fe07e2e28ce83d7594545cada54ceffc8195c68bb4c8e2ebd10dd3b483ea9041804ae8862d861e56a9abc09bc5e39cab62c2284317be96dc308211acbfe778cf4222d27f779b5df77414e3f3bab9180dab8291f0ee25527eac520f7490a250d36d4600b064b673d196a86dae8bc95b54b020f755ca16ef04577adb87fd176f866fd84faeebd44b68eb306e7f9cf4f914c6978676729759c46b502bbe7e0a71f4fec7de0726bfdd61e11c760c17b94333b247a9436ff19342ad66a0df0b65939eb0e694836af5d642705a107e980919c89c0b45a6ec79b236fc03cb5fdcedb4ff063dc7611a5ca33d477804f447bd98c2d33bf2b586034fd4abab20a52d72437c1ebd738eb1ed69a0c8e3c0d867212d970cfbe573606da4323c222f3232b3c68194e6094595cc356c99b62bc72528293c3745d21f3956a59fe92830982ff370e413962cb4102063e0555cf4b77280e4bb38d5376965f8095a5f709dbc0877634523f03a8d0677c6209b2756e6ff687d332772c08fb67cb680a9cb4109d7f487fe117f865a10700972e7458474a7911f7dd376f618de31ef89bcd6f5804ae7c8b08b0876d2ebb62f6f5a72737d0ff3d9a973dcfb5cae57ee10a935109630c29d55e1cf95890ad8fa202daa8d0700acc4d5e3c5b5f7b102727b36cdd28bc57735b78d16d1f8fde2cef267670a66b21973bf5527bb1af0913a31d05b57c9c8dbbca08b691cfcf3ce2b96c1eaa0b4f0e5d85c82bcecab4e46666c4194bfd45ede7259b0fd429bb28242c4612958baad9eb4f98ed66b4492b6d363f2f5d27aa47a9d5cc9169f8a27a222ede7c08f869e558345071b776170667de34a7ae5586152f4ac71036a76f28211b89c4f1daa9c46befbca0efb13f170916bfde797dee14d1f5a7c4a854b1a375c381a9882f8ac37feb6626602c004f08109b0ab216721f8cdbae75afd62bf094ea69a7dda53fcf7546d5c0d57bea1a57fe024956a2084582f17ceaf8482e0058db98fea1eb3d7de7c67ba336348cdc21e250a6112760764df12c512ffe66ab694d97efb8989b413205d41039943a3baab76397a78eab32f09c27add34015dc803286fec853779b52633852032fd149fe23d6b375b770e6522a9a4265f21c8381e9f4ae219b58ee841b09124235c9cb882648e18007c56e374f9a2eb153d70c3707bdbd7be240f062029b008ace5bba82a05dbfbbd4ce9a36b5aa36f71de5d3ab03298a5900bad7f5e143c3bcbd31f5776778873dff3b67d6ab5a17a455625c8e714fbcfff7fa22127dee55964e31e7c668ed9f682194b9b67eb65ecb2f3374fb3946b956b535c99d285b9199e3751fe431c61684e680563c6c67deab292f4832b11bf303dbb75da8c162a2d035a94c506b6af2ba680d4b328df485e729cc87bdad9e9d9622d4611bb330de918f02b75719bbcfef3b5b4d7a687f0ec7aff35b1bf0b9159e8f06de7ebb28dfe72a9d674920d7f98a015b3768d7002fbf5c5ee8f634baa3607104bf38ee8143f3271f16338afc6473dcd4979c7cc322cc9d2b94be4c1a7b00ec74edf6713e57820e0fb6da4b5a0825c9ecc95099408fe8e2a148ca5902ab58d991776ad779ebcda232832284c68311b7e39fb9ac46c1c3d6be15fa6c8d91dd1df0424d0cc6685d15b3ccc7d0c5b055a1fa09f26bb2141626e3ffafeb9bd83dee0ccf12537d17293104cbd4199b5df0392369c1914b5b364ae5e256c9caae392aef9a197e4f7ffec29560d58a99d602c6fe504df651d118a75a4c7e977886d65870ca076ab590ee92aec68c8cfef4dbe49a0e420ccb02ce6be2d5a86c8201c3866d87ecd6127b2ae4ba8b9cee585be316e28b2997aa5b16f6f5479175b052baf3d4a531c2da1956ff76b96a9698d96181644e76968b02ba99e0b26ac911954139c8faf74d69eac21ae1b78aae19233267e42281ff2933e4a75ea207d303ad40af67eeb8eb493432093cf6cd7f3bf002f0d06efcd9a601f6442218032a7b30cfbeffd533e4c15d164dfc2df7e7a671476ef125107b585c958f84c5aa825e06fc0388f08107d089c77fb289ebbd5977f7f41858c1858b38aa393a785c620c86895bc6109a880dfb8ece317c6da07dc96c59935a2f2a49fdd854ea7e4aea50374ef050207773e403abe72f021de0f3c30b7747e7faf714d9b60465dcbfbc1ed030b8dba4be97d8c916779d49321a836ac676ba179920c3bc4af8e97e949a2c0fb321904fed7937b5b38977d16061062e580faad237135c44e0e1cc55fb3428b58cf6300f4d52ecbddfc59438d7c0322082b05f9fc7c22518af415174463cd234295816dbc9296378c9c0239da27a3c2ef33f38c46e09afd5de99ececea18af14d20a6292e20070ca7c13f16ec3ba42e43bd6573b47aaaf042096864ac9c209fbcb15a4b581151feb6c9ee7c490377c2aaf8a22ab6fabea93ff8ba9d6eb92b167900c4cda800614af5653d46fa9766ce8860470cf57bda7b3c150d97b26c41ff0350c8fc9ffb238eb111a8d1204cf7b3d7e1657f7b27f802192fe3cb7c2954e10f1c5685a4b06e774fa875df66145dd781fa11036f95e5029ef664ac484b32d1aa4facf2e30fa7c86afbc7087238675afd1770cbcf305c979c3ec4ce38c1b6417b2fd6d1ef62e7f80d42b957883697944d37c199b9e4cd40ae5ef5a3e0fdff64feaad644c931063d50fa46c0afbb9379778af9010bd26b786d11d52ea567a2f9a0cb92c1e55e3ebc6ca0a059a7831ec4e2f22e69899f6dcb5cb7bbc453bf3950549266befc8b4720dfce7264c6fb9d74fb3b8fe8edf0e555689fb6b1a301e260ae609d7930dcdde7eca993ff56d71cd731d9b07575b749ba063e181a639f08e98885c692abdfe1c09f684b845696a4a5da4dbefdd7362cfb3a46cfbf62627196dad64c2d7605148046b27d32be51ee64ad9692f2cb8bdffba536f3f76c3aacde92a64b1eba6c39ac2172697f28aee649df87a05ade5d8adb0729f9a17cbcb7f987f97c9eb9f04cda6123887e3663b9951f6c642047cecd39282e4328ac95bfed9eee1ed4fd48b84a1080a739783bf4d9f8075c026e23b2fc86a1f02d02f38eaed79cccd3798b90382452ce74c34a2875573b323abb76df19eccdf5efd611d53228353f06d27d85de82e0b90e7cf132a1d1fc811dabb11deaf815f2856aded3b39e18e4c068aff58b72d0bfaed463c8e3e9a8ee53749384af177a082831f07c34c87e7a977251370a40758598989619b8fd929fc720e03822162eeaef3731fbbe271ad4b9192bee2d9ac634b585cb99cb087fd123d11d0971b21e689efb59bd72306378b5d7557272883751d5aa5a1c96d23dfc4f03f806a183f0ac7d70a63536e7afbc9db9a1a92db50743579c436f58ef794d30d18fb7d035efec64f39b0a2ac7239c9ec26779c5fda8f2b459e7f4ab1ec51f0e88da453798b750656fb14567cd475290c5053b03b203fafee7df14536caf4950ec102e607cf8ba95ae7e7fe1d0d8b1d33537fc2e8105ce956d81dc2f58d744b42622ba69de85577be5e91595983753b71507010b7c6abb8b55c21df243ee4f4c9ded13df9e77fa927c32dc4943e603e4c3ebe796301772f0584ee08cddd49d8ee4a4cbccd820eb8a77f6ace9b3cc34d733474ea258a6335e187036b6bdd60231d24630c37361b6f8d080819d5b40e0500330dedbbf06b811bd1dd7e9367f3e3a0ce0facc8d7998fdd83919f1554e0973c20bfecaa5ac9d09d48bcb4a75e1af0ebb0bcc202ab1533be0a40a203e637a6516ac505ae756a38f23553b490abc6649ddf022f65bdf792a541a3c1d69c967b30544af1cef762ca61f21da21475b0ab6712c793585695aa2a140da4f3247340e103d0aa7b11aa576d27b12a65385cc90d562c8717bf9525b1f0a65e98e2e8ab1c94e197efd61bcbdd3a3adbb0bd2b7692d1fb7c1e1a5a6296ca96d642e1a819aebe4827b7acd9bddc8c5959cc55db3066d9d3fcabc3b03bb4004545f50142083bc05e08bb2340c50feaca6634591888e0a2aff79e8cbc61cfacaeca3dcac5111a415fc147d4c0284f9a0afc5c56ac92b44c797d17f5e1db6d8c4f0730bfd9ca6a6a1f4b4bb46624c1c44ce5f9339c0babf32c7489ae2d6d31f42e8617a356f78b1fc6201f8eb4e006d1b3aa0e192a4299d8f9b26685aed855f49c386f8efceac5f6f65a81287d31a2ce9ff5cd7695a88b8b6603c6ed4c414b13c9c3829faf067992b81e97a2a1bae4f66c5b0efcc3c90057861751b7993dfd5a3ecf1b7017d4b3ace427d0acadd598e1eecab0598556afcf0f8860488f5282886d32982b9c16c2d4bb767b16784ee4e41c841bf9342963aa157defbfba63a10de1c82891a44ab45c6a24f21893c34bac73e573777c902e27cd4ace1d3aedf33d4babbb82172dcc36d1d8fd3cd4904073081beff3e598ce33bb446dd86dc4ac1fae7e1ab4803a3b3c2f27c80910b19fafbbfc97ee2fa1f0a326f4522b6dc50645f7609ddc76035a553f0c09aeb2efb7b68b9b71bf94bda1a10c67e1f65584efe7c4a07c4faddea2a8e7cbc90e25a60f25a3bbf8a07be3e291b759ac110473f426b5c926fa1b0ab8cde8a0e18e777cb2016069f40aadf309a3fb4add09c4ad20411dcc745562be8b08cf38d8be46454e28a3e49c9380a968131a683fd830abc68780733a32d8fcb9721500380c659ababcc7846cc1633c1010cab28c970c8a6519c559814a1c7950800f68d9d8e75b6800107236cda647c1a1cf5c5afb088380a4f09a8f5ac45a2783099b00f6347aba24cc4a9fd718af01dc365fa7c889a82193e7985e54e2401c48aa91bc1f1f3eb544f35033cca0d70c71041f1c14c201e4abb03177fb61f2e960f924d4867e7d5253414a858c1edfb56fcc79b1a66669b21f86dea4f22d1310205fca061384d38b177c6d4597b93155277c7f4b0fc9f9828f113b98bd0d8f6e7af9b9687f279cac9bfc9139a86978d7d0702598d36462ccbad56ef65eb7410c010283473d3d0ff63c80e3de5803cde9e900f48cbcdf49233e9050ad2f0fb1fa2ad2de6836fa0a5ea0097ea9e271381d7bb2b1b06b8dfa190744589861b6dccf0c92c94cce294b6ad6528a2d8cef4c8cc3f5e74fb2efb89bd114ca518b54fb94b999f9d68b2eaa5b5c504797ae71b04d4e3c91a3edfb233ff12432d385c2cb641b68bd012ee04565a1068538b68ea2ee90627d1c6b3924bd6ab7277db6efa49466a54e78ccb60f0a59f21673e7ef8673dbae2ac331cf26891caa2a4baafb358dbb5b0f085490ddb5875eaaae8e5eb431addc62d6f0859aab5a94e44fdaa1a225b0c373e76a89e68dda4b817dd27714a9634e0eb98ef367f51d01b073ec61f2e8bf694d0b521141a7ce9c4725bd676e327200e18c2ad188baa50e4844dba121cb143740e44ba32ee74ffc2d676f069fdca3d37fb05eb48fb2bb40392a255f581036beaa4a2585a8b75660218474579b0e3570cd7fcee95751d990a58bd5afdde223d984d783e8e77c15e67857c5a8ed5513cef886022a23e89ff1d2cb6f243ac30b421e46f798f880dce94f939c15f569b408b5cfb1bf00622ee7b818aa01176e4bc51da9400afc369aa67523d81cffa078e24219ab9f2f3389755a61001458a525f9f4c2f141d6dc3ab1830b237bfc6f3598bcd904e80506978e0d696c3f501f00c9b638a346b2639d030cbaba289895243b351d6b1aa9d4c2a9c04fddec05b370271f72e6398619d95567da61cbd7bf9438919e25af8e7f245a9aeafa8ad79dc02b0af203260e176cf75b217478f3640449e88c5f7132e80ae44f84e35bd38da98097af8ec6ca7b19cf1dadf1226527428bb9d9d226f4ffea05af23fa3a527f5a8fd86129a945836a5c8556ad68c252d99ef41526bdf7e0eb62597ce1980783e1b4b9644375c735f2085a2ddce8489181e7c86c8fcf88042d9b536a0ac2b40c79757d251f4e60258c29260547ef6ccb5590cb3548579f8cf929e311553d674af87d0e9b260524779d8fd9234bd0e16b018f24b9981e94c6ca2e8d69a97028fbdfb3cfb13a802ce069869835fb9881fc206c98f2490219c19f8271d8588a40a27bafecfe9d15cc1575ea7dd2777919fbdb6d173c6c85baaad440adc62ea43ba74d0b041934885acbac70a91fddddfad2e5d29c0e4f29c60d81e132bee78072cb215bc626b732acb9ce2a5a9f051401049a908d937f0eca95919978b05284891f9c835bcfc673ce53a3823b9f5bac3e83335d1fd86d563b5813dea9e66b8708f7ef7a1e067217885a5c7a9a75117fc0e491143d4824bf83fe7849ebcff7cfcbd71606a0ddd5996533cffb2ea89cde7240a5c0d92ac07d32f48416cc3a47db8236cff434fb0e070cc77e483f8e242d3cde76b1b86a10353d2c360e4c9f52e1e91f7320ea80fecf12fc374c94a8310e2ec12ac5ca7794a88c5cba54dc7176852285462c6d21903e99ff521e44e52eca1082bb8e8271513418babf656bf6140f726cc644b94a6b4f96b3e0861b760c00860581bfa77c8870818a21e2ec0e97a618622f214a3b460869ccf35d2e90396ce448cf47e45b0b69d1add344e1f5cc258cd44d718d8a9b64d7f5d630f7b52f6897b5b30daea413206d5b5e0df37888d03d092704060eb19fc5b7e68d5036f9f9103ea36e3c8d36c5c1ef642133070ab0d4d0678cdcbbcda1d6959b3c95cfee211411acdd9989fd618c5e5155e1ccb7b4afb3f4515191ac59907e7091aa3685ac50c0b2b953686c2c3b53ce8aa4dde7884fc0e90ff06d2dbff2168207ea050bd1235c6bcd659d672b79c0d843c1022aee87adb0a300569af97b42dc729eab503bc97881bc2becd72cee2405a01cbaaffbe395ac16bc414a4ed175a0e96fff8d0f23baffce7b15ace1b2952873d9b528c0f0134ab70aca956d08ce2af4b75a7d1bc32480ff610f1b76c70aebf285b72e1b01572fb59bf47d73d34f79631e5ea2e259cda3975b6d81464a7cfb2b36a699e8af0b373087692640bd8f81cce16d8d7c97da82e7da576b6a6e50f4adac701ca2f865f2c8a67de0fbf76d39ba04e5422b8dc828972d1246b23fe31f1c0d539257dc2a47643fef0c62bb00c03e8bf2c2365f60ab2fbfddb196fb0e05a4119a8109ccb2cdd3734aeb557f0400ffb5163410afe581540020b64e34b3c389e36b27a2e2b274ec37ee9ae644d63f7af83ee89ad361a0f0d118766400b59cc8e082674cf9aed399929ad667d3050940d344065fb546a202e58053cc0fba822ef6211cf6af3b02410665c69b7d2db4be14a17570935d29b65d262d0775eb2836781231353b6cbc38d28d0c376d5687f5a605b470874265e65f4174101efd6694e2a3a802a390b2ad6b412c26f94def5dc619d5a8362baba7e197bfab6d6bf47f9ea5349ad4cc0aa4187eab6d0d4718a988a60c63b430516d287b66188479f9ed09ec0ffaad50ed224ac817bd46d091468086d7668c9d5a746ef846f29ee9a856acf86fd0254572779a7dfa817e88b57555a025f491f8bb2b6c8633832e67699f1dc01f506e59f34802079eafef1985cfa9984a1e3ac4d1d11a4b65e6427fd9c4a48948395bf0e4f6dfecda5fa6718968028db9d8bc946dffb9864707f70229967c798c7a359771901da4067c889c6f9415427bcc3ff1959a0c94940c01e514245c36c4d344dbc3b33871d71865b526923680e80aa7aacf8aaada0c1c65d7a7872d1f1d3422bc374f4509475ffaa9cc397821c0b47ba2ab182ef08281a04eec38c92ea6ef4286ab2e53820f11845664dd153d0aef3868759ad1a9ccce1d94330780967bc33c854b59c2fa08f0c72d20b29b207a923909cd95e0ff34b023440d599856da40555e69c586bcbd6fd52e23435be09c3d7258cace5ac5903f15b6ff6510630e5ed4f82725d5b46951aa377e79544bedd99371f7a62586ce810440313ea66c33db90c34e196bc1339b846ee1c6d3755622b523b2bc732875537268d24fe18b51581ba4d3c552e42f5f3f9714c82b5cd271dcf3ab3a5194bba490c065fa0c7888dd96389c7b5e15abe32934d40ab7ebc5249064489447706eb9ef1c1ff857dd1d338800b1d1c8d0a66cfae6ab5f907c53645faa98f974b7f3dd1a5ea0ca898252496fbe36cdeb31588c07d509aa72616ab4aecfa26efbca48e5f335e1218ade73316d3b01929629749ee8e06fd844689c359e0a5cbbb0fbb3c220beb3200b25330d5e20a60b71c27723c4283aaf16c052e450c535853c3d9acd47ca02cee3022b34c51daa81250caba5b0eff792bbf7ca29fb6addc62304aebfcaaae2c3cc1a8407399d1c2f9fb3433f9035ad880648e15deecb4cbf88644cb58fb53f5f7363f123a1deb4c2e141b23c7d94dcc03ac2e26dee7bf3aed18e8813de5962b754cca10382eb4bbdd52dbffa71f46524c55abc09ad95df7c57d2c21a1726ec10ba62202a1278ee6a25ecfb93de7a88ca422921b54b3d3432fa1c20f5a52a68c1b65093082ea94a0f1cc1113d3eed8d2400780a1e0b51e0c1626cdcdfacc9133dea4836556057f2942a47fab428fd98ffc004e9b7153beecb5db7f5f1127ada7f47d21dba9268a9457340e48b02a4a2efcc4be15c7426b783f34f48a0f86ededdc7646c8f3339b8915b4e83a8e1abc9ddfdc2c25771352bfe43f5291596783c523a09b2dedc499bfae53d60dff6ab2d690c9c916e49b41f445c0e9b9fece420d01249768a6590644a572a3548d9f3192fdf91552f8361941649116bad27e8d44421c0cb574a9f77930fb7640f9f895fd97ff40365f80554a970104a9a5d61a9389a00a1d0fe70685576ed6d64b359adb6676ad3e2b74899b8abdd008a179a3b06251ffac48085974ba92bdfb3f38ffdeade2ac1b80c2eea8e794e44b26e063153e409408bb462bedef8a8723ebf5428b4eb09667b65740443938b7fd495e1fa09399a18c1b4289ae023b4ffdee11f7e19f93a75f8e5ea6e1ee723e0a399ceb28f183effee7180cd81c068a6555ede4035e3ae5bdd9c44dc3ead4a657b9dbc8a1f34417a3c451e4b014b85c8f5685ccd80db839140a892376b8f8ccb4a67823a68e7c7ef362f15e99dddfda9a273b74668e5925356ff2acfeb82881d0fe40ccc85c2af16108d8755effd5f88b1e5785fedaba173e203a0bc999bdc569dfa0513df4edab094c0ae35aeb070fefbeed5f13fa0385c479e1546203d4d0e918457a6f9bc14679de09be38aa1f07e2261fe554db2423cce06ab649c1c09b2f0d434ba45f88e0a94e9fc76962535d85e52627c6d0c31ee2eda55fa1e45a11ccfa6d04c953050291fee3bf0c546ef8a88c4a034db0065b5b0d9b7b9d857076144019bfbdc3e87d3a169d2435b08a0814a49605c6c9e1446b2810b09a635b227823cad2437cfb8455362d2d77f261bb9fc9cb458dd0d8027fd75d8a77ba4d48390ff54fcd6551e8a9dbbc9e8665b33a50d56474eff72c867aae59a81a883b01890a09142e8330d883aadcadac9e3f8748db273afd5bedad825b2654aa96aa25d575dec5fcfb35a6246f9a47636082a766fd627d787293cb1dca26512fbd62c77c99992dc4f50590b33689ae2ef55c4c5d93fd83cc619d754abbe3f4c8c89f1cc605eca9feb1143fe6cbf4be68a33c79095aedd56519579d4a38774d43570f0f73df416cbedebb12909d3cdccc67da565d4aad7646868e06d58c7dddd81b0c2ce801408a52a5ecc8e42df57d1de5e07eed04a5034f8cff58abde35e106b9fc5822ee387ec98c7755095900dcf88103e3ae1725766b1e1e287412e1c1a5a52a221aad3392a719793e953325cd5d5433fd3ef44ba350a1a201a10da1416f8533c21fa25f1ec109b8f5c2ffd1d8316334798a002c272fd796cf62f3b35808fba9b044e639b99e9518fdfd1ec84eabec78ccb8b205fe5e54530981617635dbc0bf18abbda25851c64460504af87124e545c5aa72b9e3fa9496a46679736524c9d559769e56e15d924fbf4700869ce44b4f8159f8a47e52fbc69ffe6edb7c69bff4b49cf400f786be36092e18a11bbbe23713095f036682f24d176b8b6c28dfa7f336a566644fd475d12b51bb80c9072df14726c21da17522669194e7a0daef1642d0d9c614dba4297dabba49c130bdf65b4e217735cb39037004d54b2ed1a5a796185b5db87d59c87007635dcc7a8521fa48652df935793ebf009e8536b11583e8454afa23c97f9654011daffe3f312f8cf4dd4dc5793847c0f87401c7cb467afad9cc6d6ec5e77bae2e5ebecb525a10c0b6abbeace97402e0e9e283335b54006fef8f7ead207198f10b44ae4a11a06a1578cd49ffbbf468eb2683516f4b01c48210703c43c5ea70e39f5cf549cdfdf7a6623acd27a8cd4e55fffaf1a4955558c70cdad305c912055c085b4e0e7085ff5ff5ffc3a805d70d4bd99b8d28d552da3d7a74c6c18ebf06db0e1789d9b45262f183107228e5738f206e6327ce9d2fd486d3f72daaa3dd6c2ff94d306675e22312740fee8b0e6c3c2fba58168768e1372dfe849bc9047653d7aa7bdae83579e57fe75851c1416d0d5851d5efa39564228594cc200e363327c5d76d4ef0c4a1286888f2e8a15fafe698d5081fed7daa6331f5bfce566b2f8a0e819898d3b68b1c971da306f23e2d04b510bd41e0014427c44e5a8271e64075584d40e6b37468f5be83803a33d8eb5cd1e4950ca91ca4ee66cbb2fd928a4ba71ceed224cbcd8653d063b284e108d6673cc5a5a030ada6d100ef9c2f7ce8f1bce103d3521901a5650149b4a5aed1f79283fb2d77885dcf1ed38dda0d4dfedd6bf50b3741a74b22dbb125aa8e034e47532c8c63fc385dbfe4713fc41d408b5e61d9be503ec3bcce72d81214b7ad7f2378481d8b11961f4cbb543bc774dea3756d7ca7a2541634d1682ddf845580739d9d6785a503929ca3a499e8d4401afba662ea75211d93202ad3f0741fceda328e82d1479e8d9f2594fd70f577c7754502d189ffcb5549798798cf241653165be142d2d02dfc0aa059ce43b80a7012e5302de89c5dc6f674a798ca26719e91a36fcdb7ed10eb5f036944ece58d135ac50019ff60efe0dba8de25ebc630f94634daacb063d17f7b2a0c78c5c50b70a4d6ff844cff994f25025e341b198abcb27293528ad8d8f39cf2f137655a0bf555d9d2c31459b897241ab1a6e9fb33c4202aeb1082a2fba8b17c3330adf074a0426d07e15de88339003895aff73f942d8353a865e837eeff3042e3fd61614ea99100796ad180a7d5f692ffecb34be271b7e9e07506684dec0de2c2f0f327e60c96e5eb3392e4815d0be9b6838a1c7b1e29284fb35499c3144a54e1709a35b015d01e84fd3b2a7a6677bec7ea5b2ebdd4b8b3f73847ac1427222131b139bac23a4c5ef0ec3dfa3a769ccf0e30e062793933066005ec52c9fcb4ac3baa67f1064c8fea006acaa584deb66a1be627b1bac61d59c69980695af46e0493fb1ff3d2706a42746d8e4b065642ecd88612b4bba367dcce3441735a5d10d43b58709eda9cb71156ca6cb130392198ca0b37c98b04adaf8b0063cc1182b5dc148d30061a8bacfe9de1c1c6222f263a6d0e843c61167f2618df1ad2500f689d1b5a92091a84b758be5f27c82c82bb28adcebc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
