<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6d986ffe0601972c5b612632614b3b8ef97e59df7ff809ec895329bfb1951ebcf6f1bd91a207e00e9a343598359850362a91b23250dfad13ed1f476b15b70b4e94c277c75ee9516342dab9c6390fcee0eaa8f199c2427d2109872601a3480064a841278fab70d26e15f0ad11a96e81d79446afba42bd4d3c14030de9a60082403497b25a6a92679fa04332c2cc9f3c5084deb9a9f6609f1b3eb0a7658555986d92c41a999d94efa86d976a8e413dab7ad37ea4bbd204f884fd48e39b51b1c342e8c6662963011ec4e9fbc3b04c33bfafa0e1dbf04fb8381bfbd290f52d238d2ee85bcff9d14720444a7f553f31b49a204643462fa5b432edacb491ad72b12e0149d51082d9eb5a6b8331be35eebdda571827ada995b1cb61640d2f4a099d31b64d25b5f852a135fd0a01d07c95949f1ce4424eefd8efdc98a7eda6525456092139af49bbd388d802def4ffc416b9c0c97613098800554091b2a348ba10e1ed13450ba0ea5423783d3a0483109cdfc775002638ad4a8acf66b9c2118d832268b2d06dfa73bd2e104cd3bb2ff8427531ea4c7c8b43aa2d60b1efe9e8c88b665fe11c757b9b48706cb2e43fb5919e808e81066b452afda2aad158855871835173a7837a4caeb52e90529a6d58dc2a7c6a5fce72d61eaf16df7d488f15d1ae44c542f1df48058dedc531a161f5fc6b4c8510b463eebe58e631299c132a4dccf54bb680f08d971c7d17bc535b4ffb4666d58c1990954826e1234ca835d2c59b32b68b8a9951622ee322488a24ece8e2692a225081da2c5e9bf84c341fe84e829762cd7a784d4444b1a6fa61382fa1d3d5cc5779dade7f5dae41f92d46eb7663512c692fa3a24219546854e97cf14d68f142e264542e422cf06224895c81adeb422ba46e0d66d1b21ec14bc9cf35acedb9eab9d4e3bc0f3704800498f6dadacac9fa6862fbf5addc52ec9ba902074299543d4e81cf9ac570b1110aadd3f7f24e542fd7e2123b83b776e87f4f87bafa50b8230b84bf9d59e229b3769c810a5a2ee65afa3fbdf76a0d481422db7566034dc7352e2be342bf18bfe34d107f87db945be49c7af3e831a298893b09e52be432545a0529ccdd2e630298ff6daedf55d2e7dceb1d784b7d297fa03ce2143fc158cca18af1f57c1509f62b2a3c0b07c296d81c00c18c8be235e7f749ab05d7e80956bd2010e4e4f105c9daee4ffd084379c68c5eb7544ee7952476aaf0fff489d79dadd9045846bcc35537db9f663b33a02e3ec4dfb9488b22887d32d173d5c3332c474e0c68bed23da67b10e3c1e1642e6aebe46f052b96b207639731f7e7a032b0434b7dfe55115287bf4589153c4e1a5811df57301a573d5edbe34e79de0cde679f93225ef58359ff7e752ffb5d7ec54b72409e5897d9e53c4e9e195c5b6354c84a91e31458092fb53dade8aa9b6c0bc7673f84653169bdf2b9b4676415e7fc4535bb78cfb0da53ff80907078813f35c009c07834bae4ecb21fad3932b28ed43c88693e016a50683a0bc472a31d15116e0008a1f611841eab1c7951e48466a6317b9928a045168960e19282535cf67d058c64d6227432478a2b6152217f030110961f5129eaca487d241d9ec3e4b2946dde178d70b1dfe3e0c39e4431495d0cd99173c8faafc2d73422c36320c628182aa252d610e42418a1dd1e7b8a8e3690fbacc640e8d5c3d137864d377e19d285b25089f9110df42cd6b144f7563dddae747e814468ce718553254fe133d06d40ced9a3de8df029377f19e098885af73f13141e2559567e38160132b6eab1f3ce2a5fcb6c84c50596d3266dbc2289fb14c12e7a4217ac93b8a4967fd4b56740f3832c721e56f42b3c995932ec156c9307d276bea001c9c497d9ce2337563a88d2fda2e621025b4b8a2a37d3e6a7f357fc1a5923cf90cc032975dd9e41e61dfab481dc028a618ecab5eb394f4b706dcdf76fb5671c85c2dd3947d78ba7ce0777c34a68b8971e41dd9736e85262321f6be63cb7a38d7af18a650e30454c718d39d8415f1a9c91e499fdf9f23912b18c0ad6debbe94cde04b85f2279a7d0df2ed4856a9e733e82c46ebf784b3c77587d37a44da5af40cc550c8060c0f9f0beeae11f8ad7c2f6be889d9de4826f6c60728a91aaad7d1b538e5e54b6c93202ae17610f043d99589b82ec83f1a1868331c82419dae3c7177323e6b1d1956126e59e1474e6970c767ca093ceb7918abc89a019ca0d2849ca4f96e7e1f7494527321a96a50e1c2755bfebc6e72690c2444b69db74f057d75dac567de684a3854e7331fc276d7435e45bc2e3d1c074e0d2c7b9e6cf1516b16287176457bfe5afcad49be061e1472d0d4c1e58d265ce6c46b7baeeb6dd4da1d760ac3beaecc69211376d8ecc571446969a06dfde4c113650dfd5f24d4cf074c515146053e4cf9b4941164ba5eb16970258ce350e9e20faaadb8cfdcbf52b3deb20c83e2b00579b50b7c1c07f31fe303ae2ffa5bba22ed2c9b9a8af0976386bce2bfbc303da7533755c0acc88f4655a43847886a20dad524aafe5264be82ce05aa5825404c2fd96b2635edc118e35e6e36e28200cce63379839174568e1a7282222f41f898914dc0b3185d99a3130a5d1825681c7fde6de6952acad7a88fbc2dc719cf65590aa3a171a10b668326d713be822ae10fed828adecc80ebae3788e71342d5665d9f2ac2db8da57fcff74d884c8b737971af3bebfa1ed64463008f1814857bdd2bf1575f47dc852ab91f2bf84aaa5020f846ac6cfd3186c6cf345ba99e17116567e7ffa9e132af25d007e676a925865b886f941d3cf0ed4c11844f17bba36a36761f466420d10f92b1473ab3814cad12b381adabdd783a6cbf214260c14ac9afa939d379bf156ba6bbf76822f2e9c10d6e60ece1e95d76fbc98e92b8a121caf0decb6f25fca47444d1f6bc6e97009e1a291ef660e9538d38ae4f2125113f478e304a723efe936f0c91c3ca8162a4e13407e40b60e339cc7a4dae74e6700aec0f4d6f8c5f2e54ada28d75e31eeec2d269915866d6442a966c3dfa4f317f2bf24ca92a0bb0834412feb80a58280d0d107eb591c1340f84ceacfe70b3eac6675b8091c617c93e59714d3bfc26f2189d7afbcf61c7cc834540df8b4a63089ca08ab87fca003087eabec9aed0e7dd96d06e6afbba94506637023f4df0a388fefd98e27c6bfd6473ca4dc50fc18ee33fdf6eaefdbac59781d43c69398f40412a0e67000d99306eed40494cdc86ef2f32452736722338ab4140e7d61f3f80e2023afa50fa75ee57fd6bfc9ec5ed651fc1b566d8c5f4216451232efe12e5db17d93f8cbb8ec93210d8d4898d7c705e86533a1f27b2907c4c5749c745d4c2a16a5b4159c127d1b7845c8a68c1cf1451c5b2c2ad6f4fb5a0abef3a58d3a4c7a95bdf5331ef3b343052de90d1258e7ee64a969df25d4ff79bcb14614fae4d1b8d0210e60746b41c837ec494346dd93fcebab4729f1bf1803cc662c33834c58920f7437e20ccdbc6a8798d5a46e84f7cb08b16a1c707fbeda09448bd5cb7251809e0e62fe83310d59eaeb15c01eb4d561c37579d61c4b3a37c7f66eedfbf03ba8b10890c0f1cdb31432feb5dae6132f47e7872980235157486bcba8fbeaa3aaf631954eaf740201ec2c516513dc36e240fd6990e6a3b08846c8e304ff34284cd7cab307a8d06e8976abada6eaddbb6c16f58b503ac2ddbeccab02182912d3b11c7f74e3bb98703cfb0c7b9941f38399904182598a59e39209f57e9f6d5076ee7ad2a2aaa05423f832a76a753114d1a4a4cb66a50892026e5db92c087a60868fa182b1f0676dadda0c2c76cebf01ecdf7269cd8ddb801067726edb80babd0151980bb0c2f50857c82488454aa7874aecf77db0f9df40120357a60253c27c408676c68607670e4c4fa7c501eff17b1f6d7b9e706f0e1a42532e04de4e65c234953b8d38e1d79914d2ab0046d16b5ab57b65d05019d6f12676be927f73b1e0f0911ad699a5d8e11a1c079bb5b899ce221b8a37845c3f0f21b4a75063519b649263b0b79e6f94bfd1ff91eb61a427dd2efdfbb88c9e3b83f4d3762e16bbc4044c8fdcb958c157f0600db753138305648edd181844bbcf15eaee30d8481e62ebc1c73ed8e05339e883aa4e8ef1df987e8d73d334875c866b68b3f8bab81ca846a39deed2a62714870ca52036de9b3097f049035d61c0b2de5f5bd4acc057d4275d4f19aa98017bde66148d4a89804a7f20c8c2271a1266aa698eefee1fd4f9aae7765427d0e3e660473cb673e28f359a896580ec1d410b7d88d6402dcf6ff1a1f567f22d4e4483fb68ea5259713cd55cfa0e888b4ec189d1b9e533a2ec9d8b4de78298413a2354f3472748ece87374ef2c784ad57242ea2fddb38a3618f4e541bce2318a6eb9e40f60881588f2a6149f11c0f52f5bee4eded595619657c675c83d8d60e9f5a3af308a8d8612be898a030308a89e6bc9618e552ec3008dc3bb6d23fa5bca238edfa0d9cdc84f55b7644b80f4b97cabc97acee5dded825b9432ac966a99a28bc6915874ba8ba7be4fcdb26b6a566850395d173c747f87692396b25fc2c10d4fd655d7dce23b944e3ded1c62c5457730f3b5e8a3d70983fe63f1b761c5c93a7c3b0f0e9739d398afb911e60d395ae6601412dc36a2542c6d4cc11d43a2382c7dc2cde271ffe9fcee6365bf4e1962de53142a8594903c6782e18310912473f440c5c4ce3c82e4256411b70f8050df5051cf2c96f77db799d2124de8c398d85a1b6a435348bae660f4330f258ccf670d7a25c4378edaada6ed51d130037271abf53ce28be5e2f7f38d085ff886e3e4fdf07ed16abbc8b8f360ea10a519c4aa652e4e75cc8f1dc883fc658d24a4d72f22e989b10e7c48b2b1d9b3cf991a74346b1702968cc615bfa1c9086f91f829a1e1d9997fe1e5edc82a83a6adf92cded8dd402bc2ddf338d993697c28f19de61193c2d55e586c454244a72fcb7ee76775ca7e792dc5d87bacd0be9f23b6a064e054e62b411a705cd63cd4539fca52f6b4c2665474c3c53b205a5b56b69b9481a57e289d924361de6df02067f5891e2c9d9d5fed9228c0abe85da2b3d9479676b65900bb25ddefc6d9eaa373e15fc4e9e06678bd4b4992c4a803a7999193390c1d3f555ff7eeb15cba3eb79bd6b57e6a3b18fbc3ce2e27a1c46d1178c4b913c5681d3831bc97abe8f2c6195c7b9eea95e764f9dfc760483b29d13440bda1cef484dae9eb9267d52e58478f4fd92983c38cbd13fc83a615457088a49ecc452bf69935826f6933cec283d12da4f55ee3026aa7bf28fd64f0dd5c036f73d34716ba8ddf608904cb131092480fed347fba8fdec9b05647b13ca8b5df8f62b9e5de719c93d90bff8ff14f02ee71d6b208b4172fe22d5c1949a760eb9d07a93f7cbb3529ff5720d239c4423d4456ac187d5758228157837603a1c7c45037d883757c8310bdd5c50f97d59c410bcf3b587ec1656afead4a44466d7b86325179e8ad11db114b68b28b42259da878fc2f7826865b77030c617c7a4c2d4b48f598d6239053ec91bc27a574337e5a9e254e3b6624fa55232dfec53179c6e90d3a649d4c5ff9988003d1f21d2d89ca154b109226abcad32e50f7bb022b811efdd03b52ec78408db15c6d54348ce470ec7e94cd1d814db6e8ce1bd5193436cde2b36d3e8c7e4ebece0baef349d4fef12500fa4dc571a10ace8a7854d6200f925513e55fedd82191f13b407316715a0cb69d9e83b570c45cee9a129c8e331372aedbb41754abd96372d1a8e47e9b58ef895f8af945a231786ff8d998a2b396bbd5ca6d8a9ad24e02edaf49849eb5c747ee36805467457d6717ca445b8411efe9e688162df555d3854dcecbac87f93c1ba5695c91e71296e519cc907cf1f076c751c7134844f8919b98df6b8eecb02013a8e39aa597c03410851b5ad14dc2aabf3f7dd109a08966a24946e4c959675e8245825cfe71001f03f36bed675de447b5b82cbb32886c81ceb4d7eee1cef54e06b50319bed28e867c0a8d50f079a7f6ef7963397fa0d249140ca84e29db615d8b8b63ecef4fb52bc3e8e112f76e78a2c4e3dd0f83be79078d6c7996ba64eea07e534c92be3f66348f5223c7875e6e50ae22b8364905e6efc8db1a5ab20fcbcdff3a9442a4c5134e44f4d1e2a718f084c6dcfff814f629af7b61bba24b98efde5460c67745809c9fbaf9a5da33186ccd42f9e3d9f27b97ca0ff2527725e1a204252fa5d9f414a41e9e814cc6469910eabb51faf91e7a8b013a2ac0ac8be98a9533841a92e2e5b64490e8eb9af4a1e6c0a12b48a4a57c08eeeff7906df7a5520afcbf0a63619b23b2c20fa3c2b02f37692df260cbe8b1213c85fc65385cb16ecf594a3c51e5dc59376cd789a9be603a27572347b947962e1e9c25b37fcf0ad4a0a09bc4c90d7ce149893eca50f7c632f7eadf0ca8278ea95265707df1da9afb0809cf7f0327b440c97612757a2d489304d032280516ad82cead30bee746ae667134b3b12e5e463b81699d4230f1e3e4d741e195bf167374950722d165047e0447169a569b6d4c6edd29d959e830eeb9d88cd02423e96905d24b2f77d7fbd3647c0eab7e72fc569977be7754795f23f5ad2a4fed99e169cb36e49cb2a86ab475c82513729ceca87f5123a7e4c84490e4f0f59c181b16f6cc79bb85844cce7e5b170aa3afb1240a147129540fdb930b62ccf821bc951ea8fa028e3612762b8e30589a700bad90dcc5b0807294b37d9ff53aa80aae463bf0a33f1f0d2444bf246ec7c1f63bc854fc3a87989e86ad758df35b420a75c7408ee3afdfcfb29ec39252a1d1abf93a53c8f6db19f84aa1b03119987063d9530a933d9d40c6e1fbc5762da7b9d122a80a723f300b9e24ae35169ee54eaeea5aa4f723b321874a92ce1cb5c3a3a4e57b3c85402f2cfd008302fe2de443f5219f8d3893995369be485d000de2665ea59724382513faa4d154bbfdf6e5d579583fada2f2d0032ecf815e57940a08a085731002bd77e633baecb52e989dd0e3e5a566df50d28fc0a14cb86565bfe9c5418d41d4076ad11a10d9af24c12df3a54d685d57a488e23bdf81b7aa8dd73eae11983639f7e509ddd8a26d467a33e8e1c2e24b96e6ad4917d99919e9421b326b8d88fe50389ff1092de218b798150be8a6bc91a748c5e7a190cd31c6a79c0e4ba5159375429f2a79caafbe854248143cff2a9821f133dfdf1be05b51e803afbb6ef54bbd86440d025a963795e10a544f01b9e43f955d86ac86dcee0f3bb083558cc950db03c9580f5ba4847d6fa9ee0622a533664840960804189ccb73f59c54a26ac11914011aa4e85dc0901c5b18c681531d07b5272663efa122bc463a0c6fec79bb79a3153808553f44bb54d6fd1d8dc2e4763ce8859dbcd41c0879f4780e543127e1a6a6934e9bb53eaa00d93f2e77248e09b82fb187784fc80697dfaf190cd26e3db16af5846ca5f76d37404491b0a0fca55e76a705eb0cf2e7251e25fec6d6a5fee9964a9f379a51370f10b552eb53b7bdc43bd00a4212de4ec0ee57f2b9f0859fd8eaae93393c4f6266f3f2e0e3d325bc7fa630287b4d163589033531eca3cbac6d2ac3498a1a32f11df164315256ccefb59911dbcfc530ded36f1c44e1f39745c7a3d79166a721767595f97a647f86c4692cac9a1f5c936b9b5dd6229d625e63f437a7988ca09efd0477df6cf7f6767b3b06b6af9d6057994479ff724b9abf97581622962f771962de3bdcf07f7bc1c2ba68e40020e13804b540c32c72a3641194dff6a74b9b0fd149b47ac07aeb65d22b2c502ce80be2555ad08e34d5d526693775b679f3249a6fc3104ea42821e3b72b81cfe57bf39071df02ce65434868150acf37426962e93569bc419bb6ac165fbc83210ca80eb250f3d25825e0e2c5a6d5899299a45ea438e88bd474dd664f1ba5dd85be8f726a059d327fd0a48e4510a6a285f4deea1f0fcaae4d54688600c0f02b0b7bdd3d2502a73f0bc61fde6f6d229dc3b9fab9c39eb95ca46198dd10cb168986c71508dac35de4e801e21bda5a719166881050b4a97406b280724e8ad711618c0bc598ea8ce4bd221a81f249837d2dec85178033909c30a743376ffb93dc455cce315204414c857ab326f77368f85382b3f02fe62e43a9f825c6c1dd3901aea29798c93328b2c87755118a202407f40a36c3015f41af30bfd32d6646b5d8704ea9909b863ae484455e846eeb99d120058d95e0a668286dfd493cbaf2cd8eefdac72ce85e8668cf66e1c6598cf046c43408e90e353c94f74ef139e76c9f3c101a812d1c985fdca0a19841efe29889bfcc917b40584c96efe4e2e91391426c0148bffc33c782004f40bf7e133b14ebdf69cb11d47826acbaabcf370049730cfdde863789f95a692e83afae28cc2d6942e42ee3836b278729563b32e7759cc2c2dc7ab41c7abc72ef372f4cc8ef9cb99052799b23d8f85f8dcdab6d00431b1e46857b646ca096bbd58fb9d914a2404d8e36c0cb252dc732f7c7cbef3755591c7b78e4b18c9415afb835bd521cd4802232073048de227621767a8504787aea10192655e00cdb0a109fd43a2a97a2b7d9484137dff9d3584e707fa22bb32a338a3307d971b956f5882efb77a0a848cf5e018896e2e4546fa79f84bfdd3f2cf2fee50779a832722064ea2ebfc645a9b6abdd53f10365e193c98398c0b8452ef28ee02fc98229ddd2554c61239f240728c405e61a12850b5c6e42d5808c0fac44dbe5566eb007031682045d22ab2e84c58b92fce415bc09cb1869344332b4bd6deb4c5d90d10811420ae5d69c7ed449a3e1b7d4f94031cd87a4374b9d4795d0f129a38f78a4cb867093b9f07b3e44f6ddb0dc617a99cab5f39ff7cda10e895d8698caae5d4df190e9a8a67550c9bd94d313665cae93b3adb5787eb5b0a01e3f21512af64f0a4261af87509c016c1d055bd2d21d36f0c83c76c685fd69fc7b3927e51a089ed982fed54648f7efcc6210d382d08c40720e11919de4e176a5094c0045b898b4e04611f4bd4be19ef42293d3eb9c40c00e3ab27f43bd6f1b8f459438147ade533fa395f0b658b68019ef797898aef93fc80b56cd02192b5cb9b8ce4572c8df310af2948feb908aaa7bc08f4948c23fc70eb6892f3e7f8eb4170e79b3725519c3127a5b7d23de088cdf083d5ce2a46cde7e1a489283c6d892623e40c789693cfed9fd75dc0e936bfff18ef485c4f1a34ecbcdee8da7ab27167e67cb36ff831b9e11c32a75cd712e0121fe0c8d88e327eeb487e507957b03befa17f26cdb2683a2c1099608acc423e73953b42d1158cf3697905bbdc85591a8c02748976735d10221dbf646bf28692cbc8cd7c14433252e926db31c8497e0b672378a2e5d933a1ae34e905261bd9238006158cde374dac7e5e43e55f361c2d77db685abf77b18aa281324f299bc0298f7c8a6e2921d5d8120a21ff40c5ae6401d0fe7f60a646306cab6b828a4a198229ea30fe51d6efacf7e8a203275cb15ba2d6b64e893b374390de3a8a6b1f86481ed79ed7eba42be169acea90fe668792fa2d9ef5a1b4637249f986aafffcc8e731e608a49686489c81a0aa71aa2bdf242c22ae36d06c58a8ae6da22be4deca1a66aff6c6fc0d7a5cf055b97f2849cec26ee4db896fd8eaca5d67cbc41a66a9eb16d1a11988c4d574a4af1587bb7c077e9028097e661b6edc6782f980ce727b4d79c292bd1946f39243983aa4ed203c6464ba8ca355d66872dd73bb84ca4a304b77ada9fb9ae0d02b6069584c3050aa70a50bad0ceb6014b47d4f8db1ae6e8d889b96d8dbd3ba840bc815c562671ebd86cc6b9d400787cde3c94ef69303a10cd6ddc0175e43bbc70f2ace068d70e35f31570f4c97c672132c133bc58f688e578654aa4fac8681e6631b4402122e7bb484fcade9e4fc1638418a01d8d5d8bc556ddc8b3f0e5386d69a73334489b35eb8950837e767ce165486c9094337e2600e2e5aae78e496a666f69bb94bb7bcc16dbc7593d3ecbdbf9026a8525a38eacb873cc5197597af8e17b84213301101feae130e1d10a44943c129ba912cde65935830a52e4cf2b374727545bfab061ac3d5ee9564b1ee689d759633f73ee1abaf84511bf3d84f9bc9b11f945947e63a5ee0a030ea5a51477637383cb79c639a23baf8bbb9a25f0caea9b68c863cb66c2d9314cb3785ec409226cdeb43fcab6741a414a7dc18c7aadbe590d553e4c136e05f165812a37daa217d3bb6963d76d7206df4f97821af4c09d7f87f488bc80586df55001796ed53dc4761b66560158bf47f330a8cb4a9107880a944bd3d554bdd2568a8bc3004c92f80fe7629d52c7e6a57c1913d62ec1f77ff2f96a232a3f3531dde85130a6ae8f45ffcab220f07db61be06b41b58d2973ce30f1a1fbad68b824388dc9b73ef0a008a99c90698048e86827af31a876b65f62004fc9a039753e352268e7767192fe2515378344fbfda7f6074289d7f428a4495a257cfe95e4b38935f8830c1d6ec9f2323eb74ddb2b2abc24328466ff88066f148c12b5497b35e5945b9dd998674bd6b2edeaf2c96f4ad55a50828a90b627126eb04c507a522808d3530f40452f9c43164f8fd0aac7d305e8f5779954a37cb8395396254b09c0d62af688f88aa6443fbda1bab698346445fbef41858852da2ecb4e60e793f11b44d3e0f1852adb46eebe47dc0584f289eb460fd17fcd160c3d3c6d8646f8f1f84031d53bc70a9e1b89d563948f08e7ffa9ea740462b0e5d39c52dd3449ce69c06d27df2df9b61c41c6c04dfb5bd35e6706643a8d8db4805279e4ed62dcaebf2dd913c5ce01baebd5061c88e2989f323dd4d26eb9d10f8a651c85e119bd41d5b66e39b212093634c0b97ac2341560dcd4588d23d4b94dc43a3ff0f944a0ae12919ddc50fa3a1ae6d0cf3db67a72a585a21008c2f7203d60e5a91f3f17f67a1ca870ea8239f816932549c9998344a3e079d457e5d4d040bc7b337952793b980b25e90da446c8b1db110657892d551d12ad0aa8b202d41c1d73ab0218a887c02dd99c10f9981eff9b9ab5983e75288967beb1b2dde79a30eb1d74358bc9eb9e7de10fd9d8095f18bcb702ede0d17c86d753f45e5e2037e97388e3b616dbd574dd48d3f6e5a2378a7ae57289cc39bbf3b34f3681431b01522cfeab849474ab970a2395085c9777c68881e90a6fb25727df0e88bf1393e5337f8c09badf9ac58337c66faf40e341c4617db9e7fa6b61575ba5dd80a12cbac0927b3155c857e5654d6782fa91dd013ea2a8ae3b250a44bc23acdc629aaaf0000d2c205ad9c9f6da8e4569b6c7ba920e0d50bd97d520bb6d5e97853142aa25509edfb521fab2183deeb7927ae6077b03425dca080d7058f6163c2c8ac01e6dbe2c8f340268fe082b63158663cea5089b0d69a34eaf710290d323d68f683c85901a0266abb6733412aa5d3c9c312f9574db5f2a277ae8d484a7bb6240121d395ca23a972ef508f5a49663c959e237b0e7e567ec6958d96f89d086615131632f05ad17805145be39716a21dfec7fe42d0f3db32fbfada889bd12723703737110730339f515fac01d1066d427ec6a2ddc3d5d83930414d2acbb13ce9171fdee52769902da90185146974e4b8bd3184539157fcf3d7cb36685debdbe224d3fcb583317ea37949d6b28e98ce4d04948d4d13da0a9bfcf61afd8743e79c81255eebdf157371e8143fb5686eba4ff1944dcd624cf83091787f61db01e50207769fefbbfa940e563ab76ac41dc0ef80242a558fb8abe35cd54f1e03c828742d9131582d857aa81ae3f932bf501030c5a5b5f15e03ee4282a1f6a6532e5cd867be41a72b16d154c1ea92567672e191263518c2443e27e0d3daf89185b84d9e57b5dbdb3578a8213afca0162264f893b739b6a3c55e2a0ab956c612af926c6f981a8f1ae7457e2f295f73981ba7a08e57466852e4856505f1ad708dff005f633a6247686ef59a77357218ec87b418310833a430c6fcb3b814cabaac117d53f18a628f3c7867cb0c9ccf5135daf2a7966158184f8919a752cf16359987df29c969085fe715898e953d28e30fd6875156e61c83c391987cd43b95ecbce3c97b47a37d8e995c47985625784d61ccfaf01148a2d87086da8c7df1e5230b5df830220c82087681c71b12431fc4befc284590c412fa4562144022a14f1a144f672ee2cb89f9ab7453b351d998365d67eaffa90fb5f9f7d5bc40bc94e032401c1c4fd940a3aa2cf4b21ff36903e7f26614368de12e7303d67340450d5dad7aa6afb27d7d032198f428e36d00abfb9464a928b2821c2913ef875e034f918c6412de01cc54d1657e3527283c26296ffc122652133768275af5062e09e88e1052a5fed3728c5e4feb0b66b20f7111109fc5dd86241f905a918fc91d748ad9b2f56d6cd28e9c42a42cce11b0fdeb4112ba197eb6bdabba831d97202644591613a53b7f5ade76dd4199eee916c362709edc59f20912b6d5843f3f9e86da9018afe93bc9edc4c1d65004932e517cc54cebef19b498d8fef97c8551113d71eaafbf9a6671fee6a8fe17e515fb982db19d8b3dd72b166ecdfd9587b9d3f485fa485cfeef588532a5a549e944c0d96fb1a76d4a552804514cf33c3fa09befdd369e1e3c04dac76b4918af089a604b571ff92a57a4c1a58e6c5182f3d6ce4944b04927833718acb742d942023c5795763c5f5cd36768182a65d49b3d14c1f1303fe0a815ef64fab55c2fd9ea8adbc084b608c91e98c6dae29e09240c3f851575ee04e99be692ff1fa37064bc8b406329df39bec462d7bfcbb6e113b25cf38dad739953af9878bde224bd486a59f0149ab5b0662f1212d61264ee38e95eaa1655bcbae34661b29e0ffda7d5cde0046f5eea8ad6615a35787d3f824391aa9e653d9b365781e8c08526442d7a3c1bfc55019bf0829ff501e26c2b368b9519cb12cc79007aad36c7e25f6d27adf8f7dc9db7f1f6aed260b97ba3b958aab685351f6e8bf6dd2d8e486a94de2668dd7a7184783b38afc9a3f83a4f4461936d40435bc9c18284cf51a42cacfddf30bc67c046b7baf3f18c126dee575773297b1dde9a47f57bb5af9f63bddd141960326caac5b916a3631eaeb009526dda86a28aa81d20a377b3069a5b01755be4a520217fae4cf5c5d00f24d89be3a45cdcba78361d8fe8ea60c330f0a37bdbe379d5493f709a64dbce6fac7213919f0f41fb8e09868bf559c36e5092893eb4d23449daf5017a0ea8a1d84889b174f535726558a2550577f79a28a1227f2253e609c422390b7f9138d2d34737f331ad9c9e8d367cf04ef1facad16665c98a522fcefe311847477b9a2a958e018ec57eb35530a7a757b464ee83051ec414cbed850fd96312d1dcbf982911c6438fff7ccf8559fc110b1d878ba7ce1e20354f18f44beb1574de1fdb863358bf241c5fd68f741ac4f3cdef77bce5523d72f813f85971957b69fa8781cfa73ff4bf423b31634bda7561f637315bb57104044a9dcc5e664f955b37931d804dc113271afef4fbb469064b70ca1eafe30d90acf1bd42aacd1b4acb398e89c59c1940f1b288ebb2a8574c3520cba7471aee949ac0c74bf68c46d5bf68783528b9a012838cfa29235aa41a1eeb5c15fb1c2876ad91f0e53505c483c6a080408506d6c3920af11acc7f4063b194f61779f72d5d8b16309c48ce9fbf05678bb8fe16da87711f7177fe28053a765c34b88d93a66ad3bb95d36e647926f5cf59f5066769eaf392e11823fbd93fb4dc66c42453daca18b28c44dd0f650dd5455afc88bd14209e099ba915bbf48a425e23a29082ef3d0321f09a233c126863f62b9d9e1dc08386333c004470c8482d585029027b337f0873a2523272957663a4693f0e4a0a5bfde311c341d83c68699830ff6b7b461adf795f80800169eb86792ec5f412a9828fd2ded322029156e7791fc22da5186a7e927180b55508a1128aaef40b5e82bea516b6f2d633b7e523fe80d8f5e49fd6de5f230246c06543c6d474576bc0805b8df35cef967bd1494fcd31790d73742a86804054162c30bb8fe49baba13759b9e153b083cad8f03b4acfd92da33d40610ceebeb9429aa9279f3d5a8fdcb467fc8fdc53d8c2835de86f632673d07c6acedc0db4ff513c33158cc8aa171d6f140380261862b6bf19c206bb6413b0f1fafc6bdbdab609d81fbbedd78460f6162cfb0eecef3873055beee7cc216993857513df3b5625d7f12719d77a247c111b256bf1a72f2708db38506f0c5f8a7c85849edd97760effae3ca767f329384ebce6f459a69ddc92907a7a115fa4f404b54a4213ea5450de39a2fb3d9bf41874be610220c2ccc304fed55e1d65011d4f62aa4d4970a317b0c007189d5cef3dc7797c566855f4f7fe620568f54b76c056648c0dc59268c4fc81a9b2471ead18157c8eac78388dbec594783e3307c00f390a9ce4e7297e859656d6793abda79781e11343b328b9e952c38822d6b71453597a82b288fa24b985ec970398f84a5220c7e320c9dd7590d10a73763d02d16ca4ae73719e2fc65d3d2c83c05567be569da43568bb35574a75b4e555872a102ceb797be0f80c3b19d76a4eb613259d622a35b053a64b0dd9b468dd0866da2b3a5f1a37bb7c14c7ec4c9be41b42c26145b3e72692e72fa6c2f7474ee16ba7d58cde2bd5d937780f296b8ad567610bc840c74bd152c7c85c770ba6d224c6ca91a1e8912ebd7174045640b7f409fe46848861be0b706e40cf5235a22048a954c5347808e06919acdd79adf120ed2ff8e244c4bd48091c99f7cf93a3111c374af77faa7e39bc0323a34f752f9f54d01b873a71ce7065d7095ad8872a70471074c6ca98b25c4d1f4089b5eb1c8bce739ff16e992e7003b96ceca2267dd967bf8b044d2f491c93b16a37b0a6a2b1dd6a87867bbaaf8b3efcd5303cdde17e4b7975a3f93e16dbfa554ebc295012e97d1a4ba5b99e472dc6487129d801cd73bb2dd8e59ca568ca78e5591165398c3ed6d19684a9a3be210bfce610adae3f518bf09edc6813aa921923282005617a05213cd637ce363b7f7257945f45638489c2c79cee5bc87b8bf1407a04e7b1671358e991da4c575e22d351b724e3744925901afe53f96a23752b46191ac4e65f6f50ef68a20509ea6ab5f51b6445c4bcb0dba47ef06922351aad462217e5ea382b2207eddf150c0d39994cfac92110c9c9ad23181f44b79d9483c4641ceeed8a3728996b2590f50ea53b6033027b284eb8b1b51dde68f5a335fdd161973f3f9628ee1962fe00d3b9d4c5c530b28e01b86925b7ce4b2cbe356154c7f7c3d0c3d958529231f07edb74ba4879037e571708238dbcb3ab0ab09f649cdbda8f2c0714e5223bb05e9744dbbafd808905e84bb3ef69d5a9be8f39bf2a17754bbbcd9afc5e287e87d257fdb5d74d3e7aa785a942c3f143aa699944b50c24561bd602afa0000a940da5353b23e92192104b12b25cf0dfd64ba4ec37e2ce770a68ace69c268b73e18855ce01803e94b126ff03208ea4e065d8a343e60f9893f6c4417c1c6d06409dec7c1d9a1604c1962cdae4cac70a255489e15e6e86a18f5f19a265c01e99a7925d2d6cfada476319734d7d518e3830bf5884a9bf95b1aa06195b8cd5ba0790ab440089acec17ce33cf53993662bc5df3eec8f67eb97345f92d57088ac515c0c6f0a9bcad14d23d7be544d86789d617425caca80c08759421a1ff95f6372da8b094c131035f53e7199f05c0d436e48774e0466e7046d6e11fd9f4b44df0dbbe6fb01f281f712992038377097515f0788bceba4b57a37c06e91c615c28120cf891c4f308181b80f356ab399b159a0c015ab93250545ec14ba1842127f03147724b2f1b7298628592804c0831d826d11931f98971372ffaf64e9ad27c9cdfd1f94ce7de885e042ba59f2decbc3f494b0dfb8a5f0fd93eeacdd019a647a4a9747705a950301889d1341d716cf723b87011c0e992ef1626544b5526a61e31844367aa3290b2bfe05db0a56fc2d1c1d8b3a68d9499b458ecd535b2ee4cc077b9310f9036ac1a9cc5f64b609c23283befd0a45a57e49a3e61c9be4a85928b478c48ec7bf9e9a7e39d7dbf758f536fbc91d120d07dc8e7bdeac27834c2b2333dafed3ddc4d6437e7813f07a015f1b1f8c26874998981a06893df02653fe6cc2905b28e49c2453ef566e43979cc5d525f6df316bb17bfcc71d4035a2cc52ed445f2637f560ec96541f54c219ae8d63666c83d12ff589f43b9474f4c64ae92cbd18d897a0fdd2df0aba7e02042d99a4b294d20aa2eeebc49a422cf83c3da569a00f0104be147f7ad208e7191fb7fae404dc69e3d57ce15d438d132e1df2528074c80466a92165f8fc5d49ccf824abac3a47a75fb04250ae24bbc52007132f620cb18c25c6c82d348f90f4521a856b106e678ed1ad735f4a4b4250a0eb0588e18851663762fbc815895834990546ed783159c88ed4e2093df0fedd21d1864f7cae5382a97036301b98a33736eda408763cc97bcd152e375d5c81801ee67adb10b0e57d819d3425a7d753a1c6d2bb6d54ad79f933d0ecab676b7c422ae777a97497faf4873af9d10c28a856a7f0b839a9b61b46811f32d2e985f4445ce6ca1d261d28c67c799eea8acf2306656939282844a207b6997d1747f67d5664089f689d729910aaa13dafe588675deabb4d6531d4495d209acd0c1f213e1d4192e42be79e9519460477ed56501f7b6fff763cebfda232ae81ec9968af4047afe8c72e1e15b62a59aa654beaec7ce3d994fa927f58fe7bd36efc609a6d4211ef40ec2ec5ea561a56df84bae036a13411ea035426810b48fa289953af0968f8970f2dfa9b80b011765005e865c6ee456f0a0fe759dc74bc79a6c46757be04ed10345dde75efe3376519e9f7a85055e5e60f2036bee83c4a8001e1233add9a3727282e18b4cd364affed79e5ea76c74e344a0c68ad8351d67a23d9432a49a25b346d0eda47ef08a00222ca63fbc9fcbc19c322c00b4d78e1c2f0442160bd03c3fc6673d07f97e655e0d5930037adb45c7906d59ea35df0d8cd82ccd59df8f0215c8484cf17e1ba4c9faf40be7eef8b2ffe19e8dac7b7f4e5fa4dfa7bb8e0d6ddc0f544082bc27e84103c8b726faaf89087e6d9d889d784f94964c95b5b8b6b8dc17a6fbfa9e35ee84b7608de21cfd85f0e2ca9c5c5d67659b6c15bc76af94cb1909832739b27e99e26f98e40262090246be2d74475cca10f2a41aa6ad2acbcf9b837acaa67ece264c43351b60062ac91373b355be81d4c38f39a2dc895d5cf5d8aa9ff482aa730a231ae84299e993bcdcff1edec464aa35801490b6a39e86cffa4be8b6309405c461f802bc3e91001579086c43de63c53a04864296f74827730f1f50f92f32396e1ca3a322aeb92165bf572fda7a9ae801c8762a6d07859883fea1f358166e1ffb76b7b898163fa50645f0b4b10c1a755c5b16b6366762d043b9c5b650d29d0231875a87b2637adede5bea38303697b5a602ed5d2a56f491df4f2328f2f581de8ac45865b24681b735af19cf8b620fa1f657d0b75225e3b1fd0b962b7e44ecbf1f2a0b88fcb3d4880875c8a5daaaf7eb7b9b7cd09d2916b46d2eae8ec8080a2c0dd68da4f3a938a529a9ad39ad29dd8518fec6f828ea392c54dc888e2b21f581b42db94588f07522a2fc936dc4df3655d2a43e6d275143f6da9e8ccd92edd6e5ccda62896245b61dc3917fd78502bca2ca417d5986621004cbbfc5826fc9998831193e586370f597f2f731f9e0221a6d8f94b9645fed41e1d0b799a5bddd1618a5e2232a2abf0d71f45ecb0ce5039207b7eb94c4dd2faf9d6d86ca17c2f09a52e3947e0f0b153a032c481400234999ac2053573245be11f622915cd9296fcd1c3c9df06557c3365b5163301751c94aa96828374256ad826d8d60a5c146b2f1628e1faa7a08fc5c684937e0314d27ba8dd69524c004fb2676","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
