<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44048c05661aeee022f191f53197dd7bfac4b4afb5a817b28fc94e67f00fbcd275457a9317fd38750fa2437bacbd6c299dc07b0be06d431e21264c29dc7f24b9e3208a9f4f3ce0c3658004737dc4af28a34aa8f8ab3825ff8f189a3c71b515ff50ab52320caac76ffbd06e214edf5aa4e81687ddace4b59f029b17cb14c4aaaafa7a8c35661bd80487861d12c48ca545eee3f923f3dc2b5da380305491f08a1bc136b42ac02f88a4319dc3259e2726e72e39fdf612bb497fb3d107470e3e88120701d5024140a6a0e6b5708341f49d441a12519849b9eda2fe673cf81861a6145f6c8c7b35e0c2b5e10eb43444ed447f320db348fc68c6fd1de7bfa9764dab9d7ec0ce41e8d3a411480e3e42647c3c2e5e34f3bf3f6ed546588fd5da2ff8593df8ef39dfaf02a1b82728032c0c53c73c0811fc7d208411035dd9071b8ffcbb6ee94fb32b1626f571e495e434433cd69aecf41c0c61479f856de438458ea5cc9c242170da5c96ccce161766f4ce3301f7d0c401b3b9c01644e2a9b743bb805882c6cd17a0d782525ad456ff8db182489932d597e0a3dc8b9051345ad1bc061246e04df95be795999b9fffcd604d2e7d1a3d56a7a4df0dcb413418dfc23ee4d7864e9eb5161cfeb48c95d0281fdbc543e3d78c9a8887241e43c98b62bec3d0e2018be7d63022f05ec5696bdb806f416e824be1cf9769fb602c5884266d667dc5a27e69bc19455eccd05c83f1eeb65f68bc16dbfc2d1cf70b5e76eefabddfab3eab7dda2b4381583ac7a639e86eaf8a6e957bad6821c13c17615d3be9b1ce129d064f8b29057c10d4aed487cc4004cc9ae241e135d385a5745b75cb03878fa4e507efd74bffcae89eac42eb2a740a2ec0e796f1a0e2ebf1a49621e368b577de7f7cfc616286188b942686907eab0d3f9357d1789ffc1b101db063b4054999cc0d4e7c77e47e3e934682e1b2091daf3c255abb07d69975b1a17dcb75013af60db5eab269b36c806714f3781e7469bf67799299b7bb1effde1923e5a6827547b8746f271052336625851a37f32e950c2939af34ba120a26dc725d14753db17aa7202b5f2fab4626bc7cea305a033caaf8dd8d2667466bbfdb581dfe31e50aa513aa7fa33afca2391305c96691e0959365a772900aef4a7239f811ca3a0d69645b4b7054de5a0f673117af6535b9a190ae700fc17a09c56fadcc6d96d7453bb3b3e746f4b19c159f9d6be49b380f04b013222ac4f695c3d7716c99473284d73d51a9a2103f791dc752d8ade1bc06f0445227f4537d5dfd57456303fa46d8096eec42139fddc02810e178acf8ffffad97935309e5ecf1fff657b85b924d624b458ae4a0e395e5e0abef9b4fc29f6fa177031b8d65dc970c2c5245392a91ced1c8059c4cb4f5c03fd84fc6c468b669a7561a367768cfaec4e2610a15f995a7e085352b0a8d25f800554cc64d79fd4f841a41fdfeb1ea572f29e2c8ca2f252b3a3c837aabc44bf3a417abd3e3b3d944f828f0fb473d7f98ce26d43c26e9f19b56a2b2fcf15ec2b42f0a2d37b47a93fadbdedb3b5f06e817924bab4518c1c5f3dc4ef23009241f4bf5af5ea05242bdc4cd458f105f4417f01102a6aabb52b6c4e795f6bba838275de6bd28efe68104e37de663e7545b223e94e4108d3a378f0b0a2ae3438f2a234dc4dc740c26fb438a97d01204795f25a4002b252f024ba5ad1be9c8bcea6374b470f88efb2073828e8cf42b8df310687641013bc82a72302a63f61d581b81dca2840bdba6e3cfb2acb0f53224e62a6848369f94e05692b3af72ee1e547be9cfdbdccec342129a618b6e0cb10ce3861847d29aebe2f65030426f59f892aba7ee11d14c7451e181523969259dc45cb02023d7c8825d983afb5da64e0bc760fe09561f5ef1cc0a870567aaaa4529b834a88f21755eae3db3e97c24855b14aa23476579c530ca8f37555981915012d7e428aff0f3aa67b93dde22411177f485a250f1bb0bed635682f5c8f91075d214ba3824b6975fd3bbc2fd465da5dd1811e3b30c9c0590c9f676f8dfe7f7dcd94157d5351cd21e729e76c1da7b54977b12b5fb83cc0fa2d84ebee1da9fc18aaf428c96c0853d9ff7905ddf1cc16d120c323f858d18cfe152c41c8fefd90027a8dd4e57d8719aa6fd9e4ed1b6a89b15a4256377ab1254a5b4bce64029bd09615d3558df33f21af8908c8f291a702a58ea6eb6a1bff4584bc490d67d582efc151a6e426d3356c867cdd77737530002b321f2c2ca7428f60eccb91eebeaeb1996110314c11d963a63158cabd5a48dbbdd028ede9fd061e50bfba428a7ab444a3cb7d098423df137db6731337faa636f6775435536e1fd6eb7fd1426bcd5bce27d4a5bb91e4116a87981a0c026ed477e5929223ffb01f9e8e575187787e4aae6c14154f3c26f1379b4c492c1f6901129066c641b2339bd0514d1857955598326260d168ab55398583f1e991f818768578c7d56c387fe330923ebd47c89524a5621012ca7c2fc6e07d024234d5c954d9b2f1b86e884a798f61747cba0af5717973ad4597f8fcd1c35bd68bd6024cbc57aed666826ef6109ad9d6983d3d12e3e40656ff5fba55417d79b8d66b445c09864bd35b40af304cf92e15dfe0b40d2f7e0e1d78f3cb2f7e78041fb5940f70230636ea72ca66efc59b81ed21ae0d61394adcf28662d9c3f6966cd148f90fcbd38652a40c72f9e7027c19b6e5512a910a9fb2cc4d8d8957a690318653d4459d73bc884209b9ac95dd7cdbb2b11e5885bbb00c8e990d6702eac949f83f136b325ab4459134dda105eae51ad4b42165be110c972d2c67074c90f8d5dbedc4caaff82276e4cb5e381da638e5a13c9eaa6e9866cb74034a4176df135eaf3d3e4b390272483c690ee75dac51905dfcfcd520cbd1b70581d7aaaf2700f5560ed4207e59b9efcc33e373f4e3894dd915694ac4580d7b422c5e25682ac275a817291bde0a99d9941e676d4840f4bf40d2c7135d3425986e48048ee7ceb29723d5ec769f3d91f02dfce7e0118db644c8ad25a4638942082c40d40eed1c04680be4fe2432b15753a86e2a43a5624ab4a59980395fc3753fd3b3461e4aefb05f7b1cf9c3df61f4f7fdac3ec907a692859c6ed021bab21d09532953a7b20bba5c0fe3082fd964497a3092f6db4f6c0d2600f0fe2e7442cfef8e3e636a5d0f918cb73281b1c132209d13b129018d583534b79ec5a3b56cfd6f548ae9d467d7cb65022b75da2b5aadf164639b69c6effa71f30924ddb7198f5e49100f3c42adc349bb0db2305609a4639834ed75ef34b97a0a6f5b5b268d95471b04ce4f759f30ab7967535aacd088bd5191df7e65dda465d6823a17b15918d632b8a359bc95bf88aa4488dcdf566b76f1057a94cfcda9465d091989e5b86df38ee7abfaf1a1ca14035ca32e611507c209be6c61e0a02a27581ec553a22bc42c0e322e14c654c2154cc235c246ce0856bf93fd11528efd03ae1e7ffd5d24763d7a42bd6c8c95875efb1817f2f3f445fca461f673e26362fe442edf0336aabcd017e7b7774444bfe7c581a4d35429b6760d170c500452246384a0d61b07cc83e9af66600976b29cc0cc9a3d36ce291013f3a3899242b9c0240ae1b5e4251e63de40de724bb39027aeefff087dc373f32998fdb9681318516860d4aa26888ae4b6f6e1ed0396b85143d0f9d4a869965b90a9bee29ea1fbfecadaf5a109cb05947bc7aa587cd1ecef111ec88d5d6d11d23640735e7beae21daa729e6ef17623f66eb8c4a52d624cb1356eeae4da802743f883e77098c6d1abcf0cf30472f9e738c27749f0c00e6e06ff733b5067abec14cf37836b30177ad6d4b1f035176718a821368f007c56a9ab630dd0f5dbf39d7e44080c3c77ee5ea248946be5c49a23e80c0bae691ef073d1ef891a65c15ba61b50f33dbea9cfb54c67323e62c5d852c3df77d31ea0583d0e92bfdde4e6d234857dc43d0ace44e5af2565a2e66006a4771177f0af090978cf91d9585d682e756cf0dc50c9763029d35d5274044ba46d828bfe5dcbe33b033f57f10cc8aab3324953a53e360dd5146eab3d3a3b8d57db845cbb84e119b64e0d13c199c8f9254450b6cefc45768eb12e17ad0ca3e65457ba801da038ed5bf66c87b4ee8975c685099626e5b2478c976fc9398d7767368c5d2766f79dac977f7d93d84f4af72024216010ddcb9782a281f45b4b1341a2241151de2a8fdfb73a029a5dadda0ff3cb08653f79c8fe14947c2bc9f524cc156711b35ad5741f1633a264e5aead8042c7a6c9412f50b29b4db070ba5fc2a8c7cacd13d2d972fb55ce855171da8ab2490f8151fb819a437edf557a1c0426c3b8fe60cc2909ea838dd0cc7462b1c5e2bb85972df94c7150fcf90aa0905f2cbf0a8a635b0b70e2af61dea08deda8c8946d8ae564b418c85799819f8dbed1b1e6705f158b7ff21003a5e4da9f97e32ce420687a97e7fa6352821a075c27e27ef7e90efa36e78dfd560bce80ec5eb9d1dd59de5e97f9fb61b7070b6c4606fcb79509bd4c62a09d3c378048b84dbd174981b34480ca422475b2bde1a5748416889828a0b2ff083fef67ee4ffec12c3d3e592d236f002811ec1b64c3b9a35b1dc7f5d4188f7d7de950be466056e3edf2899fc9b362288659d6536f861b0d5dbc35fa0c3191f68da7a4909941999af44cd2c41742e420bb2fa59fc6b8a81d708ae905a319c4b227c3e339e0862dd40e2e0a16d6a128ccee89ec5f4c4748e368c9db569f0ace6e03a674769afcc2fc5ba66de53c6dd1fdb3ad52aeb9e755e201eb6209c8027dbebc27d043786124667474531cc8f8986b0a87c490fbb48adc3d00bfea7e5126dcd2cfa139d0cd57858b9fbb60716b1c6bb48e6b06fbb6832fb630513daf9faf8b19fa744c2856ca6dfb6892374303e4b1fb7fc68dad2f4ee3f6bb5ea3387656b2d1a64cd67081743838c539fcb9b640772274cb4a557fb28946b92df9a7d51398257a3575766f0131d8bd0974cb41b2609e1dfcd0cd8b0aa1aada5c28d376cc9451a9188e3edc1b01fa44d5c1e56328f9dd29f27cf6bf9c1f047e9d3e033b7e785cc0407171c894468bd4515587c4fdac6e148229b946a55813a12b83216c2e9ca5a3e9096fd2e62dda365cbcd278341ffa8aa116abde40eac9841293871e94f3ae3a85a0d9c076f992e6322bca23d7130adcdbf054fa50a9f012973dab22c973edced8ed096867119d3bde42ce9a21c4caa462f4a9d32781540fe6eb782df875d5fbb11d5b37be0a79948dd2cafafc08934b3bb50ca9c46c750ad02e04ca8d58b369eef97765a5d731afbe8b2586a9d5fac48a8c1534e1e2c6b63821dae5f966521d7a426261c0515413a492b0085c750b0d7983d2e3a3b945a6299c6cdd5d704ca43f3329dad8ef0c99c13033fb16e8beb21dad1994141e0ebd67c5741b3fb94170644f4eb3ea11caefe5a687bf2c64237f866e810c0c296eb73f053db31e63f3c532d22329ebce6283b33d2f8f0010190951ead0d1bf587912f37dc4f68a73496369180fa6641f1d80c43a05792b060545d0a092ce3337cc5113c640c0401e72d9f1cd4cc641b95dc4aad31d1e995fb7fa1d2f84d7c84d4cabe6663bf72fab3945355a465fc7579822c881d782c3b5f9a259a28c9ae91c1f95e7cdaee41a33db4acbd30c9b47014fc5e035ad40240a586ed36ceb836561604976c517dc606ee6df8423586d9b2329be610464b057424cf7b3f2e00a46a2df99f8a2cda5db4ff905219238d72c7c0dd388b8302f53a7b99ea72137723945f80934c5892f099dac561618598e517c61aed8b971064a2b1ec7573faa0a0fc941f4f5f33eaacb43037a475e25ec03e9b5ef901a000f1b235cbac0ee666b403bfbd0b470b2a55273b0346c8d9c944d39dd3d2a7cbcb54973ba7bbb0ab5d23cf4a313a9f751c66ce5d00639e3392b480977154f54658b934df55e1912fc230fe85ff7fd8366858b29051002bc1f19034bd53f44e54aad1f38323723c172631ca1ab6105ba76a6a34432f05a8db333e5722ec127f3365eb96167401d5f64c357c414609fdd874cfd22f8915d1f128c86c0febdd529f95469dc084c646a32db7713b82e215006cc2932c9b595b0f3d8665081cac673f135e4a4bfbe1176d21750a4e07f4c5a407a40f6441e43425b70065bd6c0be42b7f9961a4e09202593b224d718b96f397346e5a685909e35ea48ea94b5c35544ea48d5f0b81839906d86e69faf64aa8a8d37efb987280eef120e64febd5f4c3ff8551947da9540d819eca77b63bdd3714a15970fbccfa23865cd5d049753e12642078e6cc96da9ba279b84369238b43bd72cb30ba446440bd037b2e757f1a4a965e9d0cade049c05b6819e0099f0e60a14999c5cf2bad4a146f606aae354473cac2bf085f3ca2fbdc3d98145cdb9605039cafeaa85b0cd5f0ad7b013e9b8322d7d50ee6af691d101a5d9f49dfaadfe72c92a342e087cb6029eae9690be029c0f9e3f294d7d56d2db85e5e35337c757043c29e9c1090bc3aa913da9ef739382b9fee4ae61cc62b571d8b3f8723ea6284ff27e5dc8349d4c3661ca6d22cc489dfe2501dbd0b77be5c54b551f6580e3273923cb892397461e3791a68b4f2306a0c6039378c97dea40334aaa3a64e616b9fb2f5a5b808defa88f5f3f1ef033e5bfcafe5d07140290d4c11c7509c823988c5bc074bafc18d6d12df52645a76c62539866cc388b7e4a7e94b1b6f175108c0711f5132d3ea499f24572be09225d85709f8fdf8945d34667d3981ac06c9db0b56646a801848c91b75a7e94346d162c919fe9f6f3ee19428c6693819f7c7117e51c52c9e2f73dcb506befd39347707d17cdd26bdca604f0e200900f47e379005c4447e898da205a7997ad8845e712c9430cb2381cc789065a72c31c9ed59c1a384acf73aa21275b806090caed41b6d1af27eab8be476125a7eb1fad3fce7a7a250defab78766af549056819486a4a5b012745fe0ba7285706f80355bdb49878162fb1da0154444fe306dd08868fa68b76217ee64e87a82cfad17e40a4963c6c8bf39f9d8ed2169127c7048db7ddb13521cf0e5f02242ca8788a24c942816516f1e0fa943f56fad2c7736c064ef16736009862be5586a04edb54f21794dbf2e1e1a3a2de89aff72792ef78395014157afe4a54177036400521583271bb10811f29918aace8b1492a6e0add9ae7de80cda2106ee99e35d1e5830a54a7f8772160ca7ac40ec0137f82a517281926f7251ecb9fcd06fc9b2fea39ce2b01366cccef0bb088ff44fd8ab6ee6daeb032c76c23a2a8943ba9b876f29694ee23bbc4101899b7e885f881b7e0a97650bf46f1e44194411c00c890de13ad9f88c9de6f5bab758bfc5160d21bd40c30ef76a8621576a9d6747db2e8a0509dd99c5182156843ad33cd47f83a123c05d07f2041dc9d9deda81555132ee47573663eb55519a125ed379c3f674a794e3f2e22aec6ccff4c3e709ebfe4ed6836416404c4d3bb5ed6a1a5ad8d4cc41ab36bd61db135df8987b59f679427a24cfc51dbb68934219f83805155fec8be18ccb5038bdfc9406329f961e38d7170cfcc4dbdfcbc37e4598df240edbf29e6a6f2a5ec02a62b4ed869174ba7182c23d96d41d0bd5a4fc953cbd1b8554f3e0a65a746cb2e31d385bf76194c6db373a98872205b644221d272634b273de90a6153121c714465fa8bafef7ed778273f4945e4fad659baaee5d4f4772fa39df86267ddef0a9dfc4c112fa4800b06c9a07d0ac27802978b7437e37fe8e523cb7fb1bee2af184a39ae331bdbea06cb03d821992a7837cdc592eb4eb415c321c5ed9625fe285f7d21e8e5e288fd36365dc29633c79a73ab27de5ae0e9973f1087e5b6427d143a0f4413220e68dc670b71039ed072fc62319aad2c847e2634b39eb5441f8325044a5daf36bf30c9fa5c9f9cfee4f206f646cc89e813c28cb1533a95aff9046ff0c96aeb35ece0e5eae4014602ca0bf606e0e3b8807b2c4fc9d94644c536a53f3048c51ebde3210c743080d47f2c2304162aa020ad2247ad606898c4e47cfd4763575332bb9a8be1f29071d0d1675c8c8256c88c905ef39ba7d2a58e1315ded4226cec1bf4fec59d36258d9fafda216846fe4366093e00ed45003991ee1b735bb08882e750d38fed26a5cf5a2bf343caf959d4ee622a9fe72e712ca9e666e576fa61f4969b4a6ffdd0aef5e02b8631df4a6c9fd06aca323e456ef9229e769043e16ddd58c27ec5f59db599263da948e95286f9fb938408e051e6b74b821f0916f19a3a067bee43aa339cbb5d2ad68ef522c7b1fe0b89203e756ba4f09994c1c41dfbb9846961fa3f791819bd10f9eec56dbaef4fe0e17f88a163d78773caabebe6375eab87708e6a211c67295c12b8abe13526ff03ec2abca57ac4fba564a02b5a760663ffbf1f1e865cae74133bc319f1c93ee315efc2285c33f1aebcfdeb5aca1f7d6d450037f43a8f628d172bfcb964a614047bdbb71c5e2f0682a675c1736842402d04d764a5ec31936a90a4d3be6643e4730d57afa876a754e0c18453bcfe47fee62ca7d1576668143e15ef613e210e8ab4b35f842343a7c2851783b008a6c7084563fce9f32c72a8d51b039eb17a048959c0aa46be35b787dda231d5d2fc0003fef74b8612ce87659ee388e644cf5bb17ea4b9d8fb2f3fd84626fe9d91545618c85bd86767ee4cc436820773bd8bd5a576189eacf5a3fdf4da840066770e007e71aa2b39b40319d8d00b88a80ea9f35e81a7c29cb417ad595b2f23d03e664ff2d127d77ad696d6de6453c82d92c1e99eea977e252746d26d6a1f1370a2ada3df70d088112a36fcb1d23bc39ca1a3fefa6c33413c46477696928ab7c401188de031dbc7e04a60191d691134b7751f0c36b0cec122ac65bf7f629ed2abd71d71ac58722c8763661ad63770acb05fb36d7afb87c52797d51f310b23181f06775e8ae059b8c2471992a4cec80376c767a81869aeb66a5b78a84098f65c4a2886eaf712871951e74b8b8a8e84ae649d437dbff5aad5332b47f3cb2e7219512c4795f5d81f541f798e362a378411df249f8231021da3c4055ca8f0086350fe799903157e1f15fdd12132379a1952c14d57628afb8873ea59e237a2c9a51eed4b728f36ea9c75d39c2b1e09977753e24425d750cdf155708af59ea87e42ca58dcf872060c079fc32423da07f1c614b59ec32d38f74ad00e66425acf76bde2bb4c59e18d283bb30c5a1e71b2a44bda84acc8bcb142f9a80c2411aa110ff1ce3298798dbfa873bb696638024c74c3c03f1106b2be591ff3ca829e15a99f38eb45d7549b51de7a76ef227793a5d487a9267ded77d27fa51c22f0bd522504c452dfa65b401093477094a92c3720e82f53a43cfb1c65855e4c1ad213b853081dbe687be664f2be98014c33afbcc8c227472f673cf8d97a2cdfe87c71f9ddd13aea342f09a3c820c45970363698ca58ec41579d853626b10f2881a4e3ba83b8982f0dab4dc49930c5eefd95b049bf11dd2e3fb0fc80bdd8f8e209db75f20a1f07875c28041cbcc39bd1a3d8a3e48c55d985c753d21d3d5ae433580cb5eadaa6ace1b19383de5114046ecadb69dbe51d1b44983dd8ffcdd885013bea22ee71c264160c5de5d3505a8f2e74018e70ea3a2317b3df6cb714f627d7f2923bc601ca863d78d2e4e8f597b9718efbf72ece1b180bf35baf00d2831acac00ddc00cff7f98394b4f68dcd4bac00e00d6e2687b6213bc95696d25ab2f5902fbe4a925df72007a0ca1def2f430ff1adbff8ae68d0d18736c8ee45baca0b057e075f308f5d1e57774c1e187b973bf468d65ffd28b83e3e64ea98bca53dd817219b0a40ea53f68388475fe131036d2deaa07dc3c14cbec5f4f7a992b41a3ee067dd00a27e1232ebfdba3db30fa69d1a51e8b2a6728718507958d3d6ffed0335be39784e2f1339c3001c4a4347a6690610c382e8e04dac5d727b7b6a5e365b7bc481a8a963f1578fb9af4b6ad879ab271eb0f56caaa041860be68017b79aa0c5ceee9efc0364cafa3cb9b8a201877f694c029333f04056091130e5abbb4330f1dd7014d184ff7b1aa431bb132ac96e4a9b2a1d44bfde882d5942293c69781f428f59f101e925193b87c673acc253431a761e9f4756e9e66e1c1265340d11d66aeeef53f4e2ab9b880a438996e19f02adb1c358146018a87242985a844fb0188f8eae7971c0a3d8e559aeedd64a139bfcf1378a35c2333ee0082ffaa77d5eee1ca88989e7924df2365476c089b2eb34f23bc6c593a5ee799fdd0a4627c6debf98ca794d53bcade13c2d7d1db195fc831b22ffcdb2b024c249b82337ff1cb9133b2e540009fdce7e63efce788911a75ad9eedcebc737cf68b81b17a8abf019c58f17e01a44ca063282503029828257bd8efb4959821400b8a3e3b705b850f276f8b9c05254b5463b918130a3144fb483c6207a3d5d7c74dcd1e66575c04c86ffd6ea243670d81a80aa1fc2a74ce5944854d8ad258e7666ad962d8632125927766e1f5b56a1e0e5d626aab6570e985bcbbce72df28f980fff2fca52b659bd537ee3a4aff0d22524f035795fbc6851af6443e3a0bd42053cfba1157243e7f7c77d1ed7dae23577a58bdb34fbab3310dc18f2e0656ced6c68315585e1d6fa2118780028162145f5ca61070f804872486982903a989ed7bf098c1123d9e96a9879bf8e90c56af76f935c57939383219c3c8a0df15ada53c40e9b84e0637ce12429c0d6457ad26716141eca135ae8ab07936b59976ba2f567584742dffb01a34787eda44b008b7f22bdcfba49bd05066d7df0a23980ee9f0b04c00af824b067e5cb27dbdbcf668fdbc4b61472c86f18899abb8649aef485103e0448b370dbdecc911caf69e8293d5ddbdfd6fe832f46b75e4134b57a4cfc155fe4987bcee6efa25c28c0b2ca9ec3f39a554b2b8adc1501d83bd4c0ba5d8c0be5dd857a60396411eb1db4aa1ae60b4c683a36d04182c446ccaae4fe272f053bf5352883e60c4df38a66e0778d635425da6379858db9580e68e65f49971a8c0ad38c006ac751e67bac996c7b5e84dd6851c95ca0d29da8850fbe02125f9d2ec35720e05b38d641fa4171d1c102b4bc9879e961ade7a67c4271a551ecbef0f7d249614cb050fd390da38c80dcf5895876063de926d38f19455879323ec950601b2d2ba3a7bad86aa43beb2422e3737b57cdd35c1c71bf6f4c6f3eaf90e9cf7ce6f94b394d69690159eaeb3442116e7dcd70cbade83023c8e5779ea529afa0d443ae7c24d1190c10c36cacd58feb19b154760fb660c3c5ec935553c5b0596311c9905babdec93c9931f1f404d0ca59da9897ba25069833418e3551498055dea6ef3efffd3f622203e3ae59266054c025b8454b03686793be89f3ce1d91e56d057e63c01672d7b07a6787d195148dc16171c4e8303cf2bf7eae832e15037b21a20c4c8ab6bb9578ebe157937c4c7b00fd9d25ffa9bac06f9c5293c03bbf30eb1617ff6cb5ded90fd054962168e66504f4650baefe81ef5fc48fe4f6ccbbc04c7b3369e09edc9027b011a3788fc1abb3246ee062f1d58c23627ebbfa9a09dd3daff8a64648d6770cf98d2dd056e8b79c40bde62be6b421049ed3cb92e7b00bdd427302269e79a898622ed75537da9c4a47254b432fedee232f306fff4ffdb66a4f1301728e20150e8618c21983091416ea5e66403dd81b0ce9b6507be4135e79981ed6f8f099aa9fe62d388c086a3618d7e0de8b260dbf87551816e947aeaba8e17b6da915ba40f6e25dd4ef6391ad912f71eb84812af5c58d3fd23b23f094e00e484a590297c7ae94bcbd599bf7457d335554577710ee4482eabda940c25c6a5eaf24a457397a24cacc412dc3753a28e24e46752ce3643ebd8da7444f450e1b379010b01492989620b7ded990bb383bdf028528a5727bf6d87b7d06ae44137c5db1c68825ea6d413fa652bd2d7f5403d48d34724d2c240013bdb3dbc40823645349019ec8e916059adf8790ec48aebe7d3abc23d876ea15cf06d4feabf6e646e5f9b833718fd5407f083320b5c2aafbf9291caa37e0ee2c95ef22ebeb197b71cdbb5c795008794d791f39e4b714c24a829d11891667ac76ecc3351347152ec4cf05723dce1e7150bcb43f9c051b7f9f4167b65908bc1a6c8845f10688a518b616d057cdba3a989a5272c7415cdfb0e310a9c7520da9e4b09af82b75c4881fe75106f8250f1772d3bee525f8e847ba325f5a605763ab514ea54fe8f2e621cc603a5132372810333a6a8fbd5d0e80f8ba14383f5d682f0a38bd1edac0c973196e2954644eff6723fff8fb8e75ba7bd79f052bbe81d72678b7eec8ff8dbd6e2f13b4a4d4e200747cb0af0b9a3b57ced05b9902bb3b26dd36a3b749e6dfdf6a41a57a632936e79ce88f136ca4605d5c6d64db0e5c9dc395c7a4174fe224e1068e060b5140fa69d00cbd172cbf670cffc6fad8250143c9ed5254c33103446f95ddcea5ee337ad206930bba963dcff1ce0606d09620017794f824708565e6fadc506cd7493ebe1d213ea4052ec09f86891a4849d23abf610285fb9a04d17389fe2f2368f2d4f2d61426db74c988d60383fbe865572291f8aff570b1bda18d131499c871a91744a4913d5c5c3b9f04e5c1042b5dca090db717c4594963c676bf01704e798330862ff6145a4afa24ade33fb3bcb3f318309d6d8592d83eb0840eae26e265e5f217dc96f3a733cd094233997d673a61fde9484bad38c6af6dcb4f1e4ae4f971f6849dfb17a0967d0c32320c9c76ecf3881e89d2cc134f3c60556e1f2214454c74b05eecdca7427155454627cb003aa6b0dabba759de8fdeff24abc7c11703b8ea2bba0d0c6200e55f46f1adbf1a8a254ca9e73ee1e3813eabf13d41a6aeebf28929a64b3180406dc6dd6fb0fd36edb3b6693fb88bce0d0ed29ee0a2f368ba74073c1c4841e941406f1316f7d86a1bf9a4bb1f8027466b1c82fb64ccb56f3c1e5b13887c6227d6624ea82005689aaaddd3b340569e6e95f911a69fde59cca523c4b963945293258f00fbc660210de081ab432bee5f7707033bcd5e42acb3dc66b26202009dc763c3f7cc2c06a6c98430a618d0df5bc5e9edb76ce926b994583c568e8debd98f6a8896f24f85ce4cea419b427c20b0e57e9c1837172527d024a32a7ebc42188fab35e996571e741c39d0d232091cf1ca6d0d578f1670942635a4f7de2a6f36a4e7f4a086c75e72cc3deac7b0d529a16e25a7a742eb2ffbe4e4bfaf71bbf077096fdd2030a74cb23707000b129d4e4752b63194dc3dd540eeef74ca935d81bfa4706df52ab44810547c2aceea1b2f90cb13a060d375d3a4cdf655719efb8d9dc637a320d0c5b825cd9a9a2c13f68d507889e9155f9d0cca6829d646ae77cbef29cc83d3d10c5f7b0f699e837dde091954b2998954390e073d74bd5d8662b6fc47b6512a42878f0072d7c5b426c2d03a69369cf10074365034f27fb165ed17949d8a63e4c1bc3613145d8f714213e59b79bd199504fc115d9b4038b2cf139fd5bd91415552450d7d26245b730dc04acf79629148f94ce0b002f2f4eed68702352efd3281d5776adaaf3d27832c4787854f0475390127af76b2b0aa7716889681a6efa776cab9505d1d672b3c3aa9e2bdab3dafe17061c806b87fbd66e7049ed6c3e8a541d2c62f879fb1568c0c28fcc72ea0d5e4b8d008a0c4f5e977e77cef88f9fe1eabe1440512ed051cd0c11727b4a9680c5b5b8ebd5c03fe1a6d03f425c0aa5ecca6b8ab05470c8fe091a576374e614189450c807a0abff6e750b131ebfcd56994e0a1659e90bb145b91b844bf1a3ad47663365bca61ab0613698fdc66081057445b220929347cf5e9c489f1e12afc9a5167e23271a78c97946449e3d1c21768e92664991cc446e3836dd8cbadcc284c4c81515e3d0f47e4d54613ddbe0b77ed7d04ef96d578f110abcc25358dc384b1e4722f3417107bec23c874a6a7e358864738ff8bc25317c85d6d8f32a09abd769c41d4c75e134aabc9a6690784d21a1cf2c798e0f084c452097d74c5c238bcdfd7e85fa1b057487bead45762077b1bc5cc193eb430927bd3892364330aa07a8d33a348f41f78cf737e76c832f32765d8e392dc0b298562ca1c81f7a63b9d9a0ef61b25b70f42ea4cff139c9cce49ff0109ae7226d31cc16a89d6fd23f8041509ba4e1067cfd9b34c164ba801dbcd048c55c96733c8e9fddb49ec73c15dbf56daefe68ca8c72d0c0a6666e220dbaa36102ad988d80654fc2f2d51b454cf68ed69309a19c48698fc6f3e8d8fb447d7f67ad83fd9a906493b45a9b51731bba2f7b16722bc2e8dd3d2f716826ed3bc1419d146204cf3d92df0a2ec9e420421c25e14898600c4a0296d7c62aa2536a7da0e4055b3d179afb3bdf10f7e59521315685f6fd342138898877b1e3cf3c19806f642d5e6898a0c36a9071089c633685eac810ce50d382205d4d8cd1aaee52f6ff18607599cc2f0cebffc642729957bbed1bc7f7730c408c7629eca5d5c3af3bceb42c40a3ca137ecabf25e8a8799951ff568029fe38e45248bbddb7858a9a66823dbf3bd1d328a92d78a606943394d2479d4ded822af5adb2202761e479d03a146a9103faf1a68ac7f41c9039f50d9a2416bb8c4ba2c1b0bf67f69f4a585c673431a230760ee2a816d583d4745e9a90ab88a6b06d71e33fb82268c54b82dd88cf55e78edd446246844f67f5642505a7abe4e9120df3f12c713f64fee8e2564db03fb865cd45f0a03540a3c9c6739f20e2b279dc3d8885f17530ba525b9fb91f62d8a77ef6d0ba0b3441cfd4d207f62c65662c20cfa1572f40725653be64338fcca64df0cbf9cbe607def2a53810dd73a1cc6a1713832f21648944f410be4f123fde5bcfd9e11befd682e5601bb688bbb36a9348411cf21355a64689495ca1460f25cf4e0febfffc53db3b8378f70a7639dbcddfb16a242d370fbeb082e860bf2259d44d53763a59ff7a016db5384db408f2bdfbacc85e8cae667a2be01f9b63cdde263ed2f4320a2572e1d8e59aa44218824b4a716f8fb17f21ef247bf4c32e3f75057ca6944ab6221ba3d82de20f587a7c56b2749fa03f0e5c27f8f236261735b84aa7c33511d4ea53613c5fbabffb86de803921044269fc82c386d11884fab33e0cf27d172ce433ae58f87b042bb0c6410be8e4f9c1524d8f14fa66fc4cd549110e1450e8e9853209b16ad6655e8e71fd11293c2e363326f72bc60cfdb98e83f34fa9b3a001525291c3bb5852d9acaa5846a95d30a12e49aabc8e5a626e5250c5ad6844f0f8c0a014fbf6a824a6ca9476a1fcfba90ce5466738d0f6577aa2d335ef057e17f899ff1cfa8b0a124bee0c6703f0a4156ead5b1be11046bfc5250d751af3b4b3a04d4d27a16aadd7d2b375b73c3eccebbf9eb5dbe05dc4e24c65fa7a7b4333164ce89d65526d19eddcc222c5774aeca8332d50c8ea6cd3cd9619261863e0469e07f1a0c53e935eff3673786e7c4ba619e2ef4d008fd3d60ef35765c8e08f0589d547f124423e021eb51388dc883d879b78ab54231d409703b3a5e885550a66eceeaff2ff8f4d6956bfdba2a476ad8cb360ad60f9cb249c66a2fe9172a03412fc0124858875b9e2a50f7205ebb465d109f08a9c4965a40cc6baad854ec0fe9415be07d2c3cc788edb2976f14e24930c5148f13847d16be3f86c5a00d25eff84d0296ddaae959c9d85e4948327181e9f7653d6b397d9519e63124c473c9bd8d7c431fdb7fec6204cb9ed16c18bfb5a7f02f4bfb3de457e99e478e5382e49693bca3c7432e6342b4c8b14b179e154aca5fef550974b994d7fc14595629975a86c61e0d7a48f2a29ec187072f6df1975c5463c9d6a8948235faf28ae111d6a713925d969eda00034304e9f8e99b5fa713ddd9c8958f7afc58aac74f5692f3facae64167d14654e761468955de56c09198704e81a6747f3b427705793a672850ad130d4646da2063495bfc81c18bb1cf0cd6b9ee0411c08987f88cefe63c122d1a8db8d2887cb15aaed01ea454c90dcd286253c6aa4e1d64a14155bb2dc1c169b09e53b805fb9559d110191bb16f3d80da4803958a91f83efc91d43ff7a44ff4c98c874dd37b73d5a5d41f1d72c6f992c91b5276730f2920b16f2abf7085e574a61102291c4461a4399b1d87dec10d75204269762ddb7f99ad84821cf59a97b0421b1ac7272b0fb9e7bb7ac1a0b42b6296640d184aeceb19dfacef30bac51939873f5e059d1968ac77e6596bf329a885bc30c32675889b0e4ed7feae685c2a7bc75186c74b4228c7ea049d92a7046ca5fd80c9436236f501f4a7cd1507680f51a6283a20a1c7c3dfc164041c82121a7041ac8322d706da0210d3d16f9c4525272c550d450c576f1b0f5c4f8cf693c88da567aac212fe17e02b025c43586afb3c2fd74a6118c24f02d2b1a4bc6da09cafc7c4fc23b111a629358b33a1e90d81c84bf7c49f794e6b1d2ba243f19b235523c091a4a72584e57741953c31715effc47b4c6b4bbd91164954a7eb445197e53659733746c045ee495d5d5cc4f5bf768c5f172b41a767cc983bbc0525b44b88203a95e6c1a7f460d67f12783b9ae1792006d159c75488df53aba880774a4b83703c57ee19c0a43f08e7c1110c8ffcd414bce0fc8ce0f54356c2dca96fa17f8a125d1fba0740177f888c99dac4e46fca33f4f763e797e12e938745bbe10ce7bc88b2e7a079e43238b5c2a443a75fb766f9e98ffb83fe6078a879afcfd7c0bfd2e16ff663e833ef104d6c704008d5c8ff4af44477731d03886a5af7a90154cdcfeea347f0577d750c25224885a090c1a0797f5ad7f9ea832d68563ba02bbfcd868daa22e6091c1eb38d43129a796731d33a23302c88f9f26a3ffce516dc2543d3680c5641e06e273eed4a4b3194b51fa0e894360e03547e802546f4c4af2fac622ec1ca577c8a2a93c2ce3ca36ebd065bd349df66ec1f4a9d11f5377068663d6c53e7e8071b3e700f1476012bcc9c873de7a01e3e94459eb533c83435d4e2feba71790ec3b277fb3a3fee351e938021ace04904d3c40b6e14dae165989e5e363b805ebb66e79c506e0cd09de6c8d5f4c6a2d8e59de2448e796a9aafd31bb9f73b0e24024fd873ebc158bc13f636a4203e7b7705d0091aeda32de8eeb5f92b85c7dca480836500881381d33b8c3bdfb7f3d5bb1a53459c32ba9f077c83a48fdf5b4965fe7c30572ba72d29e1c2404f6e86166175a4f5dca1fd8267a9ac6b042e6d1ee3148da6c283a39a8542b66a45993df27eebdf05d1197f9442a0af9dc860fc3b6a09289e3701f8f8e0621f7f1cb05fec62f0b421533a13866fd7d3597d9e930e5462d8dcb8a1760780b2bb44d32d450d9178a5e434045c95b157eacba5fc1f396b91553bd5e31b9e6aac8de257dfc1f93d01dc95ad0539c7c99aee84ff104f637442f157b3749c0fb2989a5a3bfe129708dd7c2b102192cfd6d55301eb3489096d6ef2d2c58b1902dd89a1e4806f3d56727e471381c07ac773630f091326a2242a3bcd430d2d5a8617405dcba699041bfcfc18112f05058c28a6464ea1841c7cfbe9bb25a0a4514dca26a7193c590a8c0d579c5090f67e11a855b56b6b4cb2a236c1a083ac69194a812f658faf6a3a4b4dab70694524a6fc4cc8eff9f13a130ded459b334ddbb1fc470f9bf111917f50fb8659ec50a8d61935e2fcde6a27f8960065c56a34a69e6ca97ad628effe14cb0f6c73e4efea35b4f42f77d14f99c868150fbd46860962044fb6664942918f767f838ef0f0c174d5e98184f242b4760d505ead8417bf91fe64bc730e1fc82d1ab0238fa2d15c2b6d9d7fcd0d46a069dd1bea0128c4ef8cf4afd259082e2b3c085d830335547ad647e72afffd85167c518c3eafc5ccd4e90d995052abdd8ced364a5ab45d1cec78875238f43ccda549caa7d1397c6059e79bd5df38896","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
