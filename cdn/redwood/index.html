<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"546f55342ee82773eb2962d1e2261e98be0a8cdf3cd892516b60d5baf8b32c49599824e8feb36eaa7a689200959b9ca4f1eeb49f03f2114bdb65839742055cad2f6879ab416ba5e7f270bab592ed34c1a6980b7c1234528fbc13787622ba271ff423357606a5736d60b1b13116613faf5b20143cdcfe3299f2e5d8846be485aabf0d71d113fa793cafa1c26525d23392d52f2a07c812f04f082c1a90432489051b6aa1079edb848da4ea60af6b28dcb0d9ffa69aecdf287d1874eb02554df53896ecc4a264f77cd68c8e8f92da58e46479b4720c8e67cc4286d8579e1efe58f631de8add983d8daf19ac3fe60bd8ab107845fc5934d01bdc6a6dbc9399937d9c5a8f0ceaaf5645602a5332c22c8505eea0a6d428aa10a29b2fd4c8d87d29603af78a6cdc513f4d653a63fbdf3839f43aea3f5acde694e65c41b05f4a2586a393c11c43dc4ecb1ff70b7666842efb67eb1693811cc1d36d3ff9fbfa30fe6b31bc4fbee40d3de3ad1ed77b9e88abceee7026de98761627f7687e42956c984026cf4d23cb0d91e107796695f74bcf710b74fdf24ebb84c623283c22fa0ec3a749b225c6d77b8c43ba63c80c4515012d935320ebb470405d31ff43913956d89ca884acc36348364433d44afc37ded0c87ec60d385e6bd30dcd29000b8f6bbc2e4f6d5aca60c636a8ab5eecdd8469105f2559ded1a565c4dfe8effda7aeadce418c26c4083eb11c883417e90d2d98c9b2829cc1a9dfdbc3eced80ab6bdb947d76bc0b080de5707a7fae03a02730b9924864f4d5f50bdc3accdd61fa22f78deeb8a4af60274f8f3c491cc33f6c9daad125d8a5ed8192282aeee75f54e321bc82de6ff729baaca833ea96d5e315c06a53c8dad6c333a4cfac3b7d291f0fd6a3ea2668792345298ec68d8a69dcb76e7eaae317081d4698efab9d1aade34d7cddaf50e4087dd5740494d08e26e97e1f58e909f2dc6337a23f8722542ebbcec75fafd86671f65a29a053f1ebac7b4dcd5ea4d4045757bff3cacc65386115e98147edf36c86d44c5a83c6fd7fe23a3769e433cd254829e83dafa1aa7fb2f77900df2d1766a356c87a713a4067d748ee6e2935d6c68e41b0cb3aa9c4248f6aea844d244bbb4996dd8e0d18cf75bff4d3c1eae998353a5a853c3ea705483f4bf5b84b06c25fb72ae982a7afe0ea34c2b707cc99655c1480409746126e9b0eaaa3a77b4dddc5e3898c8ecbeb4511e10802fd490f4ac22debdfb2b9b33137b7d824e0ec56221356306c8ec3a9f7f6c171160518bae74b696bfce652d195728e8b4ebb0d781d12698b3d06a88e360ff7fd4a6838624d4ff90ccfab135422de29f40d8c8ef583de5f2535ead9f653831e6ba7c40e54a61e04fe345e3ce883bdead85200ce6ee0df952414dc4faf789907a71a8f429a4f3c788837926aec868abbad99f5799b3f4593ac39bbe6155272bf070293f67660e5af29eb516b938be2ebad9839da327898cc4e534f92536e65040c66da85f5bfdbcbb62ff5c56af8cd50c6bbb9eb5d15ea4ea6105793b440ea36cb286f8e274164eab8b027a0510d8278bdc0450f30689d7dfaf27951611000b5c268cad711cafecc15bd65d5aad7716491ea674b78368b59b8ef30b070362bf6668124804e002ff8700e43b8a8f5345aa2d4af58f817bdf25d684631e91fbbd40656423de17ecc5efa214b01d359cb2591ad2957c745edac182a3925a8b96171cbe0f3f79bf034512043ceb92d3e33c87eb72c906a4dc59be864e8f7063218962b97b13bf9d991aadec9664e133d3c3d74d1c7fc2440c742a25371d1bb7c71ea9aca2f79757b2b9c04369ece671228a7a736c9311f4e82379b48f4c3b928ad6e6e732c4f653e4dca6fe34a43376b117eb4805d0d4b7e4651b70f53bb987cbe57c90a2d4766aa66b9cf452fba7b0f5fe0b7dd02e869af5543de437c26051110d0d8f6086f2a6b80d00dc0a42d9c0d63645564ba416b7363fb122830f7d7de28d943d16d7fb9b4ffd20e23ac5ba7f1823bbfbbd855ecf5505183538c27b0cfcc47a5a1a164c575779776b8bdd186c415d431131f2c7298faa19d5c30a20cbd5864a83a9385ca7a864c741e0806a9ec4f86b6d829d29afd70093aee65cf06177654c1407f6c042516b983970827e529e309c5bd2250531da9ab96fe3345f63479852849e98fbec5bdd3fea60bdca3b78275e6fa4e929bec7be83ff7d43fc3d68780123901b8e4f80e11b9f8a9fdc1e1cbd35078151ed151499218bd682993581accdac0f5b44f5ca747403c681328bd3151267dc6ed110b962a8677c310c853471a6c61dca1cc49622edc72a1b93f2b1d9de4c7c044a147bb5cdd9ff56233773d1b7ff8aa587219e69ee0203ebef19f6d9ed0255669ef7a73257168f21ea53df065b616052c7dddecbba667ef89718235ae22e022a76ca1140e21a1762c3301001fd448be25c730795201f4625a81c7e25103946bedf19a355abda906a5e9ff85362216bac7474a02e07773a4ddac70335cf768409a0a5d9bb8111ae2092363566b3d9a53e6e303cb52dd0479f1a380fda52acef5f3a977ae71acbd69e9e519ebcc6f0dd57e37b2821ceb9569c09e5d7c7b4bc9856bc172aa09b6042d7c36e5c0c8aee0428ee1fb3d7b8cf871f3e061169032dd16efb53b694d5ae69aa70dc85855003725b3cf289fcab7e84eac222b097aee47d41d18d2f6a76c599293e32f9d1a8775ba2b944f7f417c326e4cf800dc5a1248c578e8c307b27c1c6b9cf182d8f57eeb79d1bfff3e9a74ef80740cd53372bf3adef777b02f1d65e4146092d783e1d8c1be0ad1b4abf1a0eea54c7a750df58aee344f1e608a722d5acc4759e770926636fa87c4121d37a3faadb6123c430b09e84640ac8e1c8a278a5ea150a54886e11a8c399b090ed3e87cbd46fc55d7bb7091dbe79fc2c8573661d832542042aa7e28d0e0a487a9687d7a97f4c56045593a42ab21eed6881fc3a45e0347dffb8553fc3ae13f8d0607eb8db47616495e1117f38fef349539da0f23ab1dc612f2af5cd88d1341b6bad7afa8d856d07920505045af778f76b442f1b5140d34d0fc2b1ef1299015d4f154700f35aca59b2af22e22ca1c5fc5e668912675210cb8030ed93f2b4c02538027f2a9e700550c18117d17d91cd1fa4ae37a71bc91a7e97dc1545ded784ec39a412b55627631f6f7c0a30e6b0558a72d6a44443120326061eecb332c399ba25aa92d81dc8d13b7edb135b6d3857874e5c6ba069c659c55ade7a073fc2fec376c401c51a472a2c336122a04115af50e81fbf5bef32e6ae54f289fb6ff93d504c64ab4cf2ff9ff5cdfc9dc8a8643366df061adb131f7d82a83bf4168ba03369d20bf3ebe17af56af975f80ec3e050779fc770440c2b032c2975690250c8a81c32c68832e6ad7175ddab83dfc0705be446c696f4aa99f6245767dd709637c01c8aa6512fd3a6cef335efa2e7b01a41d72c7e1ad1eee972aaffbf80c66f353ea15919d9a31c6f68eca25cb95a0ff116238a1ea249b43b57c2c2404ae182d1b165aaa1429a961f940c4740f16ec5dc068f1607b1060eb617470a1817baad8d2dd6da4f25756e08edef0f7d7161efcbcf7a4bcc9842d5b25e5d9108a6b6f9a20dcb637a1d9e445b57caf7f2d27bbd29e98c001315f11f50e6f93c82d9f8efeb681d6830218c7acecd332f5d92abbdde7a77fdd7498ce9e5749fc22e37e46ab14250987d4c7e14f262d40d600ef19c3c52af5c478cbb759ad3f9671aecb7c994311875e737009537351c31caf600caa0337cf6f2c0ca73f51d490d500413e776d03b2d7fa0022e69277f2e230b7b1b41afbb110f0ed789e182628e89536e1a33d7567c25f3a6c81ef7a0c89fb6e41159bf746a308986f9e5ace81e00c496fc30d494ef9a0d7ad504692dddb8a9210eca5f6925c2e96382096f071c58c58f9c9a8613e321e55e8abe10f3e9db2d82040612de3be612695955debfa159e9a334e3824e048fd1358829d05517aea85c9d81a6e54d57cf9958426b4fd3335d099d43e916a2cb3bf1b54464bb13cd58a8ec664fce31bc56527c366934ef01e0fc07e80fe4a118b56c7c4dcfbbbb1e0524428ef2e20784801e78e3c574baf80f4e31329d08b6194fadb4311bc9480046270ce0cfd4c529dd7c6935f22a165f4ef835816f50b24319699921a0e74bfbdba2ee1ee54d20bb449842bb9c411f4437b9af54676a13532eb0fe723bf9ef6dbd6520f3f89343563c96f3344b03b6ae2e526b816847d2fc662718b7a63695cbc376c0b73805385e1fb9eec91c636c6e1a5933cf0f20fd27bcebd0702d3e2629ca74b5b85fd38b3105fb86b1406dcff33f603a6e92eef4eb95c1abbc0bcae518e6be48efdf209c9a2a2e085e7c9d25fbaff15388f1ee5f6e65d32aaaca1316cd6d6402a80de7a09d915af3fe77928bf62b1552b7fb129ffdb24dd0e767ab51ecf77d792e7095298f8ec9e0f841ec3fe6009133d08e4eb4d60cbb3934a54826daeaef2957e69ceb9d652aa622942f61498c40fc2d650a3f93e8c232c8b0050e0950408aafb817b6f54228ebc75bfa5fc0ce07ef5cd4e74501fb1f4478b8660f4542fa8df95d278cfe4df5b1b781f2cebd2f574c556b323b68227f225930409b55b61863f1361a07d8e5f4a7762d6b4ea05031ad49ae48fe7a815ae83430211caa8403058d9af0a4a75bca3a047c77a9224aa8321c10a131e31975a79df5660956ee73a28f38fd156be80cf17258951d774e81704b48f4a67a9d730c31422f9fe46ceabb9bc64a2de80f176fc3cfa85c89d2a6b7b6dd5c70828a032bf926be949561734528b833d054f11dc4c878c10a87d6ab2ef0d9acfce6f2b425a69bec1feb5922f16782dec5942670b1708f02539ba3771b69ebb3711cde7d0e1c8776b308d18433874c0a8ad0fe24f714c7e8e0503e30c805f5d1e59b353ccded9df56abde9d8a0c1c46d5cc2744865b795438672ed8f40d062383ff0308c754d2c4eaaa3525894a916a622838005c3b29c0c0dda4f1c9fdafd8de978f8e6172e4066400e7ebfe4077e40ec0a2d498b2078659c211cfd152e2f185d71b4f0af47a9f76517fa968f2fe4db7d99fe913525019512632a77acd8f0907f1abe221bcf063975730ba4ec331c0922ee7e6ff35b7e44b3794ff0f2db0e23dda1b9c32ed53353c3da67eb4fca7ac38188adeae759690d27f425783064b909cc34fef072fa9e1aaafdbfc5dec12faaada3ff9f5590ebe09d4576d7c6aede95318acd6c66a68977b462faefd436fb66993754b965ba5619d5dbb80e57182508a50fdef2c762d7d2e581cab44f8b1b3e259579ecd68aacb9ab75d31b7b4ef3d811efbe30db29db3089cf22540596caa2636447b87a4147d93dd47bbff58fddc4edecf83ef778194358015397f7695bc7d7d1d1ac8dd91c1702e43db412cc4e43afae1ed57004b873436d72893523822ffcdba30b7be7cbdbbfb9d27f80b27174d24653deeed95ca21a2512d8a18208d78ff50d5acc5fd9a338e02e393030f0abc2fd76b0a4c5aa268f047b48399ef7f092557991c06fb1a86e9912a91118b1c54564e1a7f4c483ae145515ac1fb4354e305e0e52db0697c4797ef9af9869af4daa1d420b06401ac61252605bdeeaefac8f68a1d9ca1aea8f80c1618b2a4f3e64d1068faecc8d43894ce0b540b72e8d331f8718baa101146a08dffcb2624885645376f9ff34c863e167b4e3355616e9521e3859c9f4100869fc87210ab630813be040a119e3b3c8e752d2138f96db778e5a813bc429825b3934950e6c13c88a4f8bb5409a89b37765a8ef4d038a4c2b9df4cd5a6d3b759fc27ef0a387678af87cf2a8da53c8c50459b60b7274c259e2403052054969238e52b46ab3399bc1bb2aef5c0e776a3ddcae1f85372ad49e9558e8f5ee9ea6a6ee34908153d65b573b7a9dcf7cbd9c360894dd3e28e947333595de94071e0bb5437b51dd839e6c31c1fa93034f22b3fd343d7cd777a5b731e33876fca46e979eafbc5475e778de182ca4661327122fbbffeff1771e5140aa8ce4ede823a78650cfc39d4d397ce1f2dd8ab4ba193e0d4e6ffa98494a7f23de064113616ee896ee91e852a802d3738704231f4ec5bde75271fe7343f9f59f43db767410905ed3bcf89583a3de398c4577a737ed2e8bc9b458457ec7a6036574595ac20c0690cad8214917e42697e365a9bc8a8c0baa1baebbce81e63d3448cc62b0569bfa6531275b65e209525be1dc1d88d62dc680be731d1984c86a3d31907d8801feefada64e06a25db51a7e55e5be9d185024e0c78c400139ff0d737ee9ab5db2fbc4c37f507be6eb4bfd53b4ecef759fc3483c1b9faf2529ec74ed0fff57433dade863d8e18dad19fc47b6aefbed5cee057c51fc4b629ec70bfcde4d23fa17e2ac8278a55f820149198ac1bf3315f4b746429c14be783c6ce3d3b60c73124451f666d85d8c585375a916d3a031ef536d7b671ab2840fce7961c9abe92f64868434ba1b45b12456124e3cab21cb02a3870cb42cf182addbbb7d7a1f79c05100f9992866611bf87f214d93330129b8ff88fd36837fa70e9f00e04f32a89e9b86ae06fad22ccf5dfcc78d3540398916eab73f5e3cc062d699a91feb2a5966362088c809e561cea9e8cfe3f6f2f30cebe16482b0b5377407e3aa752370fd1d822d0207cf90decb1d6f5e53fa179fbe7b2e8857da185ff509c3817d622dbe0c1f450b30edc7b85698cfb9c42b73de3ef623284b95032e75aa21eebc8b4fce16a4bffef80549163ec4fcc65a94cf22fd684cc3773d0a952d24029a1425e9f1b8204801fe54186d0e3bcccbe67f9500f4b2bfe2fa876ae5091175e86d30df8dac06999256f6aad7551fcc29d591599e1c3b4d32271570d292e09a4e64cea44acc2ee41ec90e0aa3c202b7d84cc02bd26d6b4f7095b9899f45a756a0c8b209476f176b0ca296e41a780d84a3e2cbedc3dd97e3c0e8b0b903e90e30775b4329906a1ae9ceafc5314ad6a8738a4df44679adffe594daeebc3a71389aa22c17b07d3895016589c3fbe7c2245962f721e97be285822b8a4c062c4ad8f1e03ad458c5e501b0f3bb46daad3e5aa52423f314bb041337f5083db49f5f37e5038cb7fd22098b497b32251e4fcf6ac38f3d8c9ddd3f0c24d60c708a8915ff8f932fe9e1b3a6259b457b1f677725e609758a6d48f0f26914703ecdd9e36365b1374b72a3ce073f14e59cb3a28866f53f5bde80b22fa1d87c19488383f9798f9be167f517083a4172959a13584c3d512027ad7b9aaf36f8d30e39c8737fd765940bacbbbd219019596312b834b9ea9db68fc0a93496ea5b7498caaa9d2f5294600ee7464ad8bcef3103a148082232067630d002725d71e6a172aa7668b50d1f7cb71cb5630a5f0be47066845c907694bb148d7499a8d6bcfe201fcafa433275efa21ac681330978db26cad51a945b635ecaf59b0b20f870f9d787bffe559ca65df7043eca9488209d0f592db50168b703ee39679acdb6d3b088afa24519de2b784a2d9799176f10073adc8de002d759297265c3aaec8db4e43e847c9a32e4b366b680b20739b95d3e2b1c6cf9430ae2bfb9bd8312c4cef598f323de786a554eb74c16c0f1233f83908cfe43a4c09f79c4613b803bb4cf3c05661f860fc69903b541d1b6d634148f5eab3f2f0adab0401361ef2284a2bdb062b2b1bfeac733dc149293f1d78ad3a0e334338bc700101c47add7eca773d4cc3637a381cfa77a9da1382803390277492df351862f79548d844eb08efd056890b8f9125ad2e7df06c208035d57c1c763658479da97459dffae50db41015c9bead8cf2c3d40696b70b762ace39d31a1f265fe2d12126599705233e06bc020d7de62052fdef28e560d0674095c2f861cc01aa9e5b565678dfe938cc8f2a56b92ed8122caf93bab682da5777393f09e982b8a6e686287fa6278012eef4db59a452abba22cfd40c516fd815a11acec965b50faa4e56f56b886ad9ca7d672e78c156b477c9c8db93f9c38db18049f9f3c6d334a6406e6e9a7b7622f53bb5c4ae1c50d8cad61612373ea0557743de1d777190280173cf7ffe021ea0c4f77f27b9f9d1bc50ecec053dbbfbe294a81f6136e6a243915542220997e051cea587cf7734035943983fe66d08d80230aa38259767f643d0083d43f09079c3d595c1a4841c36c46a79cc8b24d72f820496624e112a9fac44c1dbd828dd322498fe0b1af368a473b074cfe056a3f6f9ef3534c9d02eb206b3f3293e32f4c119007085048a484fb883199d49832e3f3945cffef8107481d834d891d2de92eb4c41e2e7e33b54dda43d100174e6f8971a71dc265b457c8974cae823addb2cff449583d52e3e9bf8bd35358c22c2639c8fd05a3de5a1d732f8393f8700e5d692430e2e5bec0e8084307350052b75035d35da391fa9cbf8f925450d21131f3d1f9de9f3efb86fcb44aca63d12d4450dff98fe5c3f9c5c6d0cbd381c44360c25cc9a7babc07bc5ef1116db8be4cbc23d87113c8a57fd07eeaf037f23619c6b54afa54c2cf0e4e563a3476d876591aaa1fe78ccd3eca1bc4e06ab86c13f132c0188cf482902686fb8508279abacb336ab2a264dd2c208e4727a5d12a4f89f1c76d16316b7b0efce51196b43eb6363adfe348dab91116012abe5684a457279d02d49c7f314680df6f5391b4707393e8ed9d670b59bdee1ce269560a29d670f7578d612b915ad9f748750e4f4d97f3867c7cf6e6a502c093f69d858a7d4e60cda0ab714942af12f1f5f3ba0f42147ed632cdc4f4a3ba4644bea70f1b65bcd792319b03fb8d84344534c2c1f6eb2fd8566825e231fea607261782a1d141b062584ac5eddff893a1e91dfac4cde1655c064140f559b778bfd2fb3d5a74dbc6ad364388159bbf0799ffc7c88b413afbce54615225b33679ee1ebfb6e45b0eca110217763219e9362583afc0954c0f4da32835628da6da40cb07f3856fc2dec3a19f4df6ac7501c53f0b352e4c60526b8d648a4eaacee6fbb30ed3887a2bd1298bf74be1525ccb27baa0a331d9ea169c6ff61b194f601d8f32b2a917345bdd1ce3d6e01fc97d6975965950d714985914c88d1b1093b5fd842f012128f00d8a827783a92a76042fb05718184c45bcf459f04857d8f76db916fe6fc7a9c9ba46ebb94355a901e858a1dd95eafc094094855eedec7863727b230b112501894ce319af55ffad28dad2c0cb84e666000876a050356d72f5d42c7dd0e8b74a02081e5f41a3f8b096220ee2a42bfbb9944349fe83e7b231d9d0746b86045f519e6cf2bc456d05d6205b86df713a8724da960a1b2a2f99a899dfb2cd9e5f1aaa9dde6738b3b635657ca6df73d9c8d1e72c56a4ef662f39e28355a4a0717cd82299e340125327fe67a78b3ba5d01b1d3279bf8615fe60b2743fbe3beb65b98820b02ee7987b89eb0ad9ffc48e37d5f431b819f262cf863bbc95647f4881164580465e1c805691ccef87c1a817347d4ee612bec4674c166fd0cb94c629bb0e401652e57e7764d206508cf05de0af0bd600b1f8e5152dc6a0a0352858dabbdcdbbdb2e9bde56f831ca76acf601a90af29865b9cf39a453a53df8d87d2c14130526688ed575906a74c4c23203eea2a99774bb8f2c03a2f4a28cb6792bdcc68a5e1aa9fe4f63424cf7ca036534d53f77d121095a4cc9ccd06a67066f0e4edf718e8e72985b07dca1694454e0d39dbb613ca9c52d71ceb43a4fae74bf627740598e521e2fea82952c60bd6b2825267a6dbbe5fdc42347b6960ad78b130b127a3c38f7394047a529c30a80f0daf4802d38e7f19c876a08578ce61a481662b30be9f66c926aa60b32a4f924373f4e41b8056017e7b1e94147a86e0899a92d8974cdec51110693bfea297d22f2f87660adfc6c0d158bfa5560b63bd72db7147db5c8ac81513066db1abcc8587817599ef74b73abde6ca248a45712c8a39e617bdf3bae54df0851ffc235ac1cda22b5d11353c0f92aa347845c5ed8aeae58de71e011cc5a4c47169b68258ca25f91f48b2ff81e78c0f592e8ade342a17c7551c69dcea7e2afbf038685b45fc30197e5f7e43aea534ad80ae2511cd536ed732f9dda6d40d6fdc5d7bf88fc6c96a546659dd60946ce288d952de244c9b28b1ca06f35ba9de56b4ef3668810ac94f106b00ecb502479bbcbce07220b7fa0fa910deea989a4ea4affd5f6954c843af81eb39062f6c72a75a72338701e33c341eaf019df402b18f53bb2a4b2101c2ebf59cb66495c5b7e05cba1e18ce1b466f9b80265c597d7a44102090637ff1ee2da12115bfd81e9e2fb6ebbaa94331157224c1ca39e4095afab94ba9b4236c36725a83acf879441d122e14cbb9c783edca4c5770c6bb2c3b7cf58d6784d64020aaf08d9652e3f3ba25b179b29045c7241f6b5599d314180bccbb470f0d95729a2fbef0fc9d4148359f81eabffe362fe50420da21b751b803ad2b870827066a2f295e0bc3ce0f210aa3e408797cf0483a937ef9efa6f182d521908f6f7cb99c46dee6b96bae058c84ffc38f1d5bc818a7abeda5e13cf960d5d037bdca1c60bccbeb8100b0034166e349a9e38d38635548a30a4a7f209917e2a693798adab170a3b55688d4f5a7da2a41111ff653b9d99de3df981157b79476e7cc4bffdbe57ad442bfd4bbf4039868dc70a7cbf6f520b744c34123cfed0abfba7b4b571629576b39a0b112eb89e34c0899507ca99aa9ffcdf6150e25ee93573b76e6e26f463724c92f8a750bb616f115c8e02f7110e518aad1bb4559e0932c2aa3e3840a555124f7544f3edff7c27a87fd2549a6e1c1c42a4d0dd02caa2cb8415e2e0415f02bc64b2990ee57fc795c0a898347417ce5d8cf5506c0813858789b0fad93ce8de67ed94227ea5b4ece1d6b6b3e800a8060c7ece88cfcd625bf77533befde5e1c355d1e3e642e3776701e7776f648f2e4732795b8a96533e946391f06d4b97f3f588933cc74f6b1d68748aad77bdccdb339852f6b5fd11d41d114e52fb6118eeb1cca314fd00c5e10f900d3a3b4268b3c10a11dfe824d8245def828abd9ae5afccd8e26e3fc9e42696e42cf22f83f24ebbbdd59e14f945e28647ec32657545dc895b58d9dfd3584c99fbbd5e76d097c83430f4b1f0f4b5482dd39ec5083676df40de56f817e76821c326b32d20f41e3798703ccc4bbf67cf1bbb060ffd347006bbf62a03b07715506d4e0d6f78bedbf31f4e768e908fad98a69e588284633f2c0648e69ab4405ac23c75e89a040548734b95254453365b4b823a8f4452f5f624bbe7f48bdb95d43fd512d75ee4704507c373c136857d0aba130e0ef258dfe9e4642c0d9ca27240b46a29ed291818e80c511167e57d3ae0a91df80e2b095ff3cbc45ab191d80804f84df506a93d511f80320509903f4115a875b6cc44cbb9328c8a4a472b64e8be54df2ade072cce52b11ddedd046d05af72000a3ffa18b84a3a13a323131344f00113144bf709d51c769c47bbb9bf42dffd1ab246b05a021ed872bfec0c0d883cc3e2bd792a8d6eff546ae9fae6e3190b192480e5bf6e3a436d0488f5069966cc0644e6e5d0c1c3d64f542139fa599c01a95456368c68f1dee57d9a997093f38a593463eee2428dd761190fb49ae1e4a661ff07d2648df5442c80a03d190972ac949667912aaf78538af3a6ca0d15743545f7cc177f2e83615b64aba0ac9a45d332596964f86af3852c0ccb4fc19adfa2d0e930ede6ca645712dc26fa2e9759216f3ac73db4496c99a0cd3c5c46db6d3d33ac79414e29df7ebcb4e3bacd9f6a48d084a5450f2cb5dc90f234a2662f70e597c49c8f1fedc8a42e54a12510bd7ef553c98d63d9987badc0467ffbc243491a2e163198ac5c29492bb1e406a7054137b3a958799a6246f5aec22f2fff851fce307ccea3f1796fc654970cfe529c21f11a0056a5f1f8f87a15d045f6cb0716918492f8b4280c255f21447314a1d45657303ab586579077add3289dab7eb34df9d16cd166919efc1b743c347c9e06f4c076404a934c705d76ea75040e9ca27890b94b4170cded6b6422751b52c5921a4a8f8080c0abbd99a96314fd1d8eb8a3da4f071e19738f9cdf8238b430e7bde0ad413160b033fdfa27bcc35a26256f73f1740d1d30c35a9b535b681b92a42fdb5aaa294f938c14ce345acc059955070a6d392f84be6e0f0e1937886e34589442ec89d23504c51880a19eb41c01762fd3616ab2083cd52ed27b417b975a23b4f2443aa0a2cf24ffe2c6e7aac03634212ae8ae54a8412f194473ffe91377be3a79472433ebe0664eec26fcb199f3ef8a5aefb9181699e20a96775c6cfdf450fee384551d0ad88d6e57dd5fb9e96ddffb77ccd83a8fbb996dc277f283976bc71e415c16dc9136766df18e7e3332d3a9a37f76f57ff1add34c39737dcd7b120e59ba2ffd3d461d6cf96fa10fdd22a3205d838e82aad30ead7af12c23fe0d3d4f5110c79b2c233bfc3db4d78d6f684dd72b12c0bb0baf7182d62526318123029792054053d8e58e1031ecd1830686e3d02fed716b8768a10afe6e7278b94dd6652e65328d728f752ca482456c0b5cd03e09f42f624f60579efafca2e3dcdb2c8bd79bfcd028113fa449dc35936e1973981ceeceef13a18629ad49dcdef431ea600a7fdf05283fa720315063a47c0073f43fad7438e46797e04a1b3e975facfa8a2c9148aca047bd974fc5c29b4bb80dd0c4aa99c2767468843c45eee2cc733746c84e87bb46cf8c7d0d8cc1e4498c241c225f5f785558de5ffb54d96751641fb6de664394dd1df05ac7605b56bbe976b1126d98f49a9745ebc60764da6a3c026aaa7284e0fcac81552d22a61563e69bbf7723f8a8288b45d2329af627eb530341e0ebd21d61bf37d6640c66ca751c59ed5f3d33093ab50c7504f1e4cf0ddca84abe2728f0ffa2e96bdc42720054792cbe3b1bf638d6d7a92512bb4a2752289936d239aef67f90f5fbc50b05b17463cbc3f41107ac85d19f7a09c2434610b5df79c0d948218b59b3006d54ba63e41d57dbd3cb19d86f2c97980388e623a1c51203f5c7e84d73c01607f074c99048179d8ea1da05b3d6a0572539bf44e46422e257243962610eedc7a89a06899446796add9e979810da7b78dec81e134dc33c6f573a590e63cae0b2c28f2bf212d57e2f0f3572d9cc28354137488bc1532ff65c26f7dfe4a4175e8068428e785e765011894c6e583e59683ce414c5289d36b78274ee25b6e7b455b5b5d8e72c3ee1e3edd9771c13dca231bd8bc0d05c0e09672b72df4e78c592374bb30c5197e0ff0c6ffd966225ef835a9b1510ac91189de0c9b93593fcf927145ee86a0eb6236b4796a1f1ca86524672a17d4103a00acbd6d326c08559dfb7f26fc01c9f1f1472ee751760be60b2dd9e32d5e2a1847773e5f3149ba7e01ce35950971d439a8d3224458bcddd10a0faf43d1c0478673e31b3cb96719e436d1e0fbc1897691334988af8e48758ab81f2016d444692fa6e2e0822eb84ffd9907a0c4b8633e5e6961475ce3e89cd2e95ffe56a0af3bbc044dcdd49aa3083ffb91c0f0af1a87f689c48b346054ac053ee446fab3ce7cace46e90a86fe754ac5ee6daa8ee0e9ff7bfa4f4b0a36f99c3ebee9c2171f09a1c79cbf46c09b7c167fe9b61cf57ae11de70c828f6d0a5f65284db98f047d9ad83c97f8e9bb9786467de6f3cab92b36df2f1dfec6f86b8b0b7d6fbe4b74b31146bc7c86cb668a5a5b919f75a4d47e9e149223145ee9ed87afad9bc883098160a5f406acc8887c1d2744d2b40ec4c919db71a223c30ff2d8084788b22097cf94f528b12a9ec0fb4482d86412e70de5b7b67091c8245887eb22812444dfe55201f19af914faa9e3b8ecd487d87e8b80be63b996b5a1fa7dca3ebcf684f213eeb368d1424282afb3b913276d93bb5ec98c9b6fa205ec52b7cc772c0f3acf495114c55070848f958db2db6168e16a9838a0e2470fd349645d4c3444a0f19e10518a53e726950b471b8cc0daef1bd456fd335e6500a09c20ce94727e4a28efd8436e633854c221dd7cedb8fbf41673b0e71a8f1be665983cb9fe8ea02d66d15a460af3597b6c35a72da21a4bdc29ef5830af2bb2a66c5abf08f1def4c0f907c1578b5d2a6fd97d555f666f337539f5a4ff38b7b206081897db91160d50df4a6c7d89060feb71f8579c631cd87820066e7cd47fcb9b4dffb2935e503f7155d545ce2261bf3b2fbbf06a4a0f7e580960ed37f389d188db989b9dc0fb51f2f6f19d57d0ecd84709231910163de9544facb23489c074155a39877a8b8cfcc7cf00ee693504d2758b202de43eb80272754e3be128c9cdb7cc6739dd8aa5589275095561cf154c993a64fe77615b3d80402ec4c84f49c83b24fe15d0e81ed1002f5555e87c0e19e52700a48bd0b5e8be441e0f8dc4742af1a67a8938f3464111be80934899507f26260b73fd5dffdd9e6b7e7c5f220b931f7b4365312221bb18dbda40a6af569f0738d61f8c66afed59ed5d6e22941ee471af18c9b85e7d2d42b7e7b18a1711d48c1cc8d053d3aab85e68e6aea3f5fe701c82e976f352be3363b5f383551d700f6aec23fba09265e91181cbd4c2f5e9e533911aac1e24ffaccb64ff817ecbe04705fb59cc0c12af67f3f46056b0364fbd3787c2891321e5690c815ca47a7f49ecf87bcc7373d32260ee380e489d4ef931e9e3a1a3282c1ee6edb151c85664c14038f3e16ba835b1e72821717dd7d67c101421573b6b4ab23bbb24546fd8cd84b40e416309651ed4e05e70e18ec52b803ae1ada9d87a50460de80dba01b1224e26415d1781a1f9127a73ea339250ef4c562773927e56286abe7c39b40dd5eda4418d76f01d14776df0ab86e2a30ed364b217209ff35afea106abf1ee4dff6bc61f415a18c1a9738a3ee95acef8ee7da5d3653c9a3536e0b7963c8dac56b5e6b045b1d7ce45c07744d5aad7c8dead201c8e8af6637d3d9448dc675c60c7386972a38b312b15b9ef5fecdd5b879f2c0528ea7d8153341d6ef6a0d7675695847a02861eb74a8a9406351bf8e0ccd2545360c6c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
