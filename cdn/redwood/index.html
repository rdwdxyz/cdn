<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6ae85e3e5172662317b76d74e1ac3c7718e780b9e2eb968663b37ecc0eb2f449f9790280510877595cc7847e6860f3d49d7a5ec40113690d004c682ee9800ff8d4d5c06a23adce0fc836d7afb3828c9d38faa860971bb60b3d5ff69fd9c8c5709440abb3191868fddee91ee9971f128e97db651ca910ea17fc6aa1da54bcab89126255e3708acf5ad4dd28da611ac0fbfb9d28f2eaf8d82af5192c1a2aa760c4a7fa32a415aefe713e46e22fa62e0737125ad45f48fbc97125de58c2f27452c7d28b4b36c80a50d994e689379d108f3b162a2e2e1be618b58132360d9b5f165cb9f95cf76f429caf0b656130e8ff7d771ca43bf076f117086fc7dad0605bede908afb7b213dca799e200a2bc22a64b4d499e09d7e36dceb35c4ac202dfc82ee2e47b3b72f4ec77e777d96c9e9356f51e876c2689ce2c557e885c51840b0580b2d3040d7d468bd7d24c01dcdc463a2feb6ed00ce26edc01d1b6d751b4019cfb43c7182a5da6b756b97e159ffdd441c789916ee62e6ff3746cf3abcd1d1c423ed59b0f508f915874f913e1cd72b4ccd017b2629aac7c978d731476d4d1b68a98e52a5cedb52b96e82b2440301a693a8930578f675c7555107b4d750112f09c2f862cf0a18fe4fa75eeb1855f50af936791f7ed76b230bb4f575865257cd3743b47a1be02e71016aa6adea1a8f1a67ef872e5089fd5f15939ad7f2b51d7e5805cdd52f6a991e16257c1dec6ba73e09847b19e002e0eaceb01caf7f3b1ea9b6581b5db95e459c6edc647a0d5ca444b5782001d6c0205437b15b19d1546690532e35ba7d37d2d96634b31ab64f08d1547ddbbcaf51fb4f6ab0b4e66ba8acadeb1c81acda6745e35c297913b32145e3c96a41b92960986c04949337e81f645a551d8e4c80f5035ac61544d0391a241c62c93514c10b839a9bce6c40c59a03541a19afe43feaffb255ef70e87a4cc4a606d1e48cc13a5adbe73f43e8def6728020029495dbc9d30cbe0ff11f610dbb8b0cf4fee528b02c45a12ff599ff0991978af55acf70c18a1cecfe6a5203697132c9630fbc3c1f19a99fd92847c48ce2aab7c2ee61463673cd171245e92d07772590ac37c9cdafadb935a7daaf78993a90da228e177745f0b57c9661a24897f70aba3459caa38f25dd30fea2e813a027f50019d2b683c0c05eb0d37e46a1e331e855898fe951543e8c6cf2957e3292f94bc5471ff2b2e119c81599edc30dc64bd417110a4057cc56530feffff4713f0aeb61bea58c1d770026c7af5775ec744fcd55990111b5581e2e69e934becc30a514425c172bb3a61693d2d49ae783b34710b3d635de181210c98648a160e00c96508d8ab43d48d40c6f03fc61189232ca66f9e728bbb4fe49bbb9c4ad3a6ed8466b0259317378417d1b1b02374ec1750c5cd4220cc7ba87409a81a1c2b565ad48c95c24b73bb0b248a2ab588372851a0b970afbdbe274c7c6e6bcace190bddf9ac0bfc22989818ac5277878582258684e55c78ea1f8fdccec75d47f0a63db8942edee30141138f373609d097a4a1c30b388f31231f536185dc9b3fd2beba190df36624a3a6d536a3f278b3bfd1b87a700cf705f8626fdd1e68506d0f0ab16cd8bf5e937540e939862d6c3a46eaa1520bea9c9ec2fb194f9a55000445b20277a1fdfaf2d843e1df962c289375a164029a5b9c6d15529884d2a26819a618fa2625f7124131dddc3a0e5da68b06f7d9dcad628e8bbd1c4875bd61f41f09ed9ff33112a4138407a0485965fc027408cdb9aab85083f7be01ebb474aec81f00b7e4146fa7ec565855c62312229c16739f84fcadeb0ef2109caef778e3877042cd3f23c9b6198894fdcf259f584a15bc2064cbd9d6fa48fa5745bddec787e78ded89bd2344f057d56227b7c2d2a2a77075de3152ca1b48a44cabe4adc2a09255ccc30aba6ed5de4c19bbadaf09e6a209b64e9477e1b00afc755b9571bc5f7ce9fb7fc25ce57a7e11c7f827ce46e5269dfdbab88cdd05c10c5a0ed7c8379d2dc399821ff80f6111b02e56a1df168121d4aee47e228bcdb00ffb48cb86f5a04466626a483371c647f668fd04bb9e5f48d85a5e20c96d8c81c005700f594b9b6814cbb2984a1ad899e65b4e8065f5c0d6838a6dad5a5dd1fa1cb2e2fe5d887761b308715ac8f5521bafc8dd8aae16f35666b88b0fa24c22f47db4ffe57b2a37f4e3fc9be30775148113fe018d8447aa8175f58c864c81bcc3690be98c498dfcab0d3dc9717ed73de1b8b0f322db931aeaee532d95e2fb10951ff561aff7547b0e8697c76d9508b714b6f117d5680778538f67b0ba03a56e80bc6d07ab7ad35e247bda7a6af4a8e128044f5fa220b4a306ab2e5222c7cd4457d1a940f42443f91c3d3566ac432a528370770af88728c9a7c60a66ed98837e65f4e74995c649e5acbffe405f9d507b21f9fea9841364dffd1d289cd1081a49818c5fa2e7628b517b363813879bfb2e9d6e169f1f2486b733228b9f4ddd2fc6e3fafd18754a64153695fa1709faab506a2c80540d6d6c2891488d28a7210b5c15644d5d946e018cb65be0b71ac2582d9f408ea3b08dd56b7a72d0427ea9cbdaacfb67cae67065fb237e9fc500c111b6778bda665f0c8bdc0de400fc1d8eb4af05473efdf630d4503d4a37b18e10469f183e67be7c711c6f4f5a34f4d70ac6982a88e74a70ad681d52409b2e699a49f5cfaf4210af64d4418159f60b2df04bcb3cc719f31dd78d6bb3d0068f5513d6d16301f3436c44d1eed6bf2a08bd69f75a5ac927d0353085b7d8e4e44e3d318629ddc59361b877490430fa910b5e10bd5a536a5d8303f2d1952371cd9261e98ffa1ca803a6d2cd4f1c421d692d5d2fb0ff7c5d56032c9e9da50d25f8bb94028d3f2b42db8f8c4ea3a18d238126b7f33dcac123a96bd393d51c55fcc6fe7e9be3bc2337caf95efb7255d67fb1f91141edfaff8947ea312ca926585718d8d2973d1c288393dc52fed704de3f1e988073dcac14657d5f58c83bccc91aa61aa61efd9ab58ee6bd519cfec2f43808b4d248fe107aa2667c405074a6ceaefb7b23a756b1f0ba527b652b27ecc4ef97aa5c2b91cd073724805d496a55232f7232330e879b3ed570f1e9baa3f9e02a840b2c4e6ef9c33d465e238889cbe084496b1296be8ce3290827404aeeb3c03c1070f1c60c8cd38391cf810551f35072675df9f28290d06b2d74675d837a6e43deaceca0b56a4b05db719a72bfb4ff6ed6a8aff9f6d3efb837c750d5eff26cb2ab6eb9be36feefaf9386887ebf58692259de292e8a4a3bca26aaf4fd8de0e8399af28779e677bcd58ba931fcd709e7f05ae9dd3f26812839e825e470bb462509ac9689610b9431316ab58cd8d40f4860667716e2ea6dcd2a74a236e804df0414ba7a355232ae1ea32d26eb44a5aa9b4419bc38d913d6af1f62bb4ca17957670eaf97c9cb61e4b3094d6ed5441ce0fec74fcceb4d3941f8b274605e01f4c4c810fb3d983ca134178e83203b88a61d15b91ccbeda1e1481a27470d6ce30f9aa9dbef71bde3923333c8bb3772220e5de4e79cbc1baedd4b7dd557b0559cdacdf37378b91aad97a1600e0f1b40403f851cbe956e485a7a826e8fccb7b1691a2798b7a4299c9d2d66f108e897e7f002992287b18261c34b727b15bb92e3bc2ffd26d0febf3334aa622374b1188b153a76a2a1830ca400e62ec1e8e99ea618b765c7908e58b8f9b53f6e3cdfbd25f1530ed5e8a8eda41c99a100ee072daeabb594e4dfd427d66da90d2c388e26894b138a1279a740d6c2c40c193630a28d43a76aeb2540146fe78d95a5b2ba4f25b077f0765407955aba3770e3a266fc9172d4e3c77304e18389227299e99dcea83b12010d2a2e828e856d65220d23ff2b9e6d15e51173af6fee2fa5d4d3ae1b1bbb12cc1d92846ffd9af736140beeb248468230d54568f677f4ae1f6a8e2e2917ecb10553102c8b34b0bd37aa8db11ff2a2449c78c87bda8946d75b53272ad28c73bd7d68859c7370427b7d00c453a8dc247af86868db01f7b2f9a1cd055075435fb7cca909c18b957314aa25f384c43645102f1080158f645cabdaa2f9fd5b339f70d7fdd76f7d8f249577ff9d1c44951a82b0d535641f804b25f93b89de3e929a8277697e347dd28f7dfa50c5d8a93916dc79f63d21bc27c932c31c0a7213b74720e0fb43bc5d6530563f058f75ed417cc4e88d62f34376220871813e229a1c23c399b55cdab9298bf390c891ad32e1c6363097340e6e979996a7c246380269199cec7edfafe022a493a6c403ec634d520f91e985df33a326ce9092586698d9741871efd776f4bdb8fe7fcd2747dc0c65a5112804ec8775c4cda60bb28ee1c09b96bbe2169066a41749123599f33e82e631a285cf49283eafae2118746b405b04df49b9ba2e9557bc5e048cb18159ecec25bda601ea840579219a40c079e33ae9208a77bc92692a8c003c963a2cbdbf0f59d82fc21bfc20a67e536e6fa8c8d9af02b7a1867a02f595d0301b571183325d166fff32f50aed53cad1ea737d2a684a156859d5f3c1fbef1ab619f660b6b0de4d533a5ab5c004b099706c2991b4f8da489abafeb27ba4ed3e09d3b30e543c506cc1d14374dcbce6a18741add7d2e042294e9e4246e2c98b625bababfd74982b61db627cc7ae14ee807f02072b0ffa9e94ec0ad54f765b74b3e71bea44575ef8ae6fffe8c35a7eb255f95f09207105f942730493a0594f674c44fb0c037a84cd17237ec3a708fdace286f1578ae65a7a77cec6eb4223110c31b94f31d75dde0be4acfd2d004d63e500d26f2a09413bde6bf3e37e664cc85bf0c15b793edfa4f455342014c775cc673e5a3975c55f74629b8ba09c72a88a608a49e918504c08615da4b57d75c9c1f859b49f5f3dc141462a1c64977a1ec30b8f2d096760f4a5fe33c55bcb57ef8230920a34ff1c32cf303c43886a35322ce6f80eee900e99936bd6266540ccd8d180348ba1ace1bc9b595fd2c401fcaf54793f5e03e3836da544293b64b537b5e82d5bb2a66b0c81f4986ee445785b490e2f97a3585956f98c1f9285671e2cf6a2e96ccfdbcb81a85a2f92e76af7f379eba79fd796c1539e129689d836dafbc9a6e4eb8a2ef5fadda9e9d03b2129909a32717cb75941b95da0531b6501a0179fe5452d5b33f85eac4b5df915db1578adf5752cbc648d0ca6562cff0d6113835b42b86f3e521af6d5ea1f3ffc514fcb73a6e9a0aad7087c1bd60c27ffa31162bcc6aeb6c3f26681b0851b71e8ef31a15602c00c2a4d78059bded6230414404efa96532d0aff059be4c973d5ca3f822133e2cc23b59edda4a4ba5f6d028c2fa99c8b6ad18d3ca20738f1ea504ae24060bef87f21022dc4f41b957d3c13c0868b619dab643f2eb99b5f450d6db34333f4f79aaec871dc3766070ed0bbf26fca783b9baaa6de27ef3df688bd24eef4d7f700eada87cff65adc1616d5885ec1e4c4dd395786cf5c4189f8ed65d50e999e7c79db18d26ff432a6404acbc1fea72a0f686e22bc867636aff9dfe7371e7ae3e5b3cf12cdf83edacd68419a1378f457f9775aba608b85d27a07d1fe50ce5e0e8398e157a492f576bc83793e49721344338aaf54c7af570b25ead3406d9f6e721b4eb5e75b60718ce32822859bda286a4c5de1844261014174daf0274ca1f05178a11b4379c165d35186a3a7f57b4f2602ae3654efa0649fd6d620be156c0b40a01cc8e531776ca978bc2da3eed0428480921b1e6f48653aa3f12ed20a23f0fcc16da18e3cd0cb54072a7516759caf9199da2e1df702b162e23b35f426863dd327994b5fba780cd76147e6f8b76f41070d1601ff5c2f6c78587221414a57f6f4a53a7dbdbf1deb4794ae53b7696c854aeae8e3dd42f2c8dcc99b1a1fe186affea3f3f4568f88498d65124850efd96e82b7c37b8aecc510674c22bd342029f75e60fc04fe86e5b565c43457cbc688bb94f83ffc53646637aa9938cf0309fb3fbca3e0822966dc5f7e583ac9aa04a0f837cc86bd861b8a2626e120698957cadb3d50f143923dc2706449cc9b560bfeba4bb2998042c98ec56aa4180da51b6341b7fe6eb18eef3638a798cacf375efb6dd6c11b6fcc1eae9928046a89886e79d5d9334770ea3b0654e7e80ab98b8c5354a5ba3f86e3d0533fc3079cc58b6cdbbd7fb8fe2e2ce38f97c64164ef01e474de6ec612bf700eb233cf60cbf090b6e630f0426d9590ae87ea42914fe040ee2506bb94c7d859321c1f0fa5cac60f690419b992878a5ab7f0f57dc215aea3d530022fbdb33bdbdac1b3d31fd4327a34927c6d5082c9c5c91032e3d54bbc532f12a6a9cd3ecb17ebe893c7ddbe051c5ec39a63576b53f0b1b78d46ee0c88297c8313fc6cf68e94851b78178f35a6d2360ba4bc8a4f0e2e95df62f3ef9251a019aef94163f49dd619cdbd73351370accd5e3bb1f64131cd4a646f202ed94b4dc17f5f4e8bfae81bbe1ded1fda94dba07bf36ab5cc9d2e99a8f2603174122f43ec1a2260934fd8a86b02d818b35c2069c9935554f52f32405221f5860e710bbc874f612bee2ecc99672731a6cfb9cb26a42224d84b68ff7743cc67526dfd14207b6c97a6d62b5011a6ed45a7a29b08fce8e7b51293b3459e1083a9cd20331dd82744d1623fbf06be33b9195d99019fd206883b3a8376adf6e1a01e0dba2bd7b29555073cdb3d0d322f65191cc5fce58af22765a60523f5a9e36bb1a2c18be02ec040fb1dd3759bc00d2f53175fd336ae83e4f7ab3ca0930dd57143bac4cb7fe01d8deb2069428c313e5e3af2bc664e2bc5716e4c59c05b03cb734a3b0fd03478aa50bdd217003e014c7f491dee2b3efd90d5e91d6970511a4f3b9fd2d7f8c71eaa297e40d8868c369d2971380c5252d451ed82c95c65f3d244e1af27cd02a6f739043d626e1fab3acce80e6e1590348950b56946009ed4a9cdc0b321cb8e097b1b77a0cf7cbb6f7b418ddd88fed379865ca2ec08b3b58b8d10e18469f27455d1498d1ad067c500e316ccdbe722c094626b3193f0b8bc5c80d3fec53a1a40f1f4dfc18d03c1097be7e7b1ee8967f04deef9eab60d67cc694dbc1f58b667a179931fe070358747dccb2d38f9658833a2415edc87e926cb0128643d7db06431287f9d9196daac9c33a07f148e706c3fd414ca581f317f077f96c368df8817a8e7ee7dfb071657ebd1953aa487924edd05751534f6757649d0bbec0b8cbc16806212b2af754e99e534eec25452863e6701cfdc9e9f6affbc80b098a0c293d828c73ecae19274514df88ac81a2081be1001305c958d00f08d7bdc18e0ed190eb4ab64f3e0a7b04ada47195c358beeea43d1dfed63c74d6625ef3787b2fdafd72dd6fd418040d931e2000a2e619c08c5dbe9e9f485a33939cc4a6472aea1c2a9f4e82df5943d4fb582e75b1a7c593b8f4cc8a6e1893166bb1c8631b0bcda013beb0b27e62888cc850e111e63848edf2d5cc7a1b89352f625f0b138b471eefbfb53f63f118de822492ebf6597d04fd2bb5cefd89efad0eca530c6b2f0d915c5ddcbf06d092c1885fe6fd69d2b8c3e7e40f1b79fa8884af31d1dcc32ca974c4bf2756f8160688def98ed96ba0292dcda1bc404bb956fd179ecfe65a7eb263d372258bb8ed54423b6eee8357d2b9ab7c261605818034b354698c091b9820f6e50976e282e89ca8140ddd38f5ddfafb64736d96f129a94679a7451e0551381d2b8da1cc8c5e38387edb14aaf8db2398ebff2a4a2b534daca70cc0b360c6b3ac99105faeefbd9000cd26ac70b2eff7c4ec088f6fdd20525f2cb0c34ff178f9419ab7fcdd1a29256d0623bf43abe764c58fd2fe3dacf39da4b5f5bfbc55ec9187eade40cdce80aefa8cd085aff7cf0b634618c95dc74c3b8791417abb7344c55d783f50814356c52a6466b6627875dd85ab7934d876a3e8d6bab3fda7a78e201c48574994e0ec5d02648ad8b4bf35b0e2952b286006c021d55bba1eb1104fbbc5a9e3afd926086bddba13479e7da1a9030aa951091c863d4fbd1a8a1a354a95d34f94ed5b4dca4398af32553fcd83e21720c0bb1f5fe03e974c0e7c2365e96f46cd4570759af188d6bc4e2cc8d82640d14aa045bad0494fd988c5b04ada8bff106cbf0d318198e327b9fa483187939064aabbd93ac76ecc0e0425b9f512a0ee2808323e1c0397410636ac9c418ba42ff44b90898576b23c8503cf4b3d659e7e3dba83243ba3bf7a82fd4c929fefd820aa1a17dd1e74da500c31b02a64d583715aa9a981fbed11a34d118fa5ce378bada2b3b23090d7c450ed1a20fb6b1ef3ab2f288a17786633a240665fb1110a9d5b80c5fa0583584024a8db49495930da0396ece4d65ffee8a2cba7d39b0866779f6a2fb9839dae601032ab683b310aa8abf355242d35dfd8f688265a2d0c8f995c48d6963683217542a1adae8795cb73bdbd21ba1f5ed3cb6ecefa03ca4b6c77dec04ee14893d7ab7f5b5ce756cac25da47c32b661032736016d711478d944faac72b998330395a089ab0d4facaa32200bd06521454bb67dff3d216cdd8dd332c60ad1c4ce577e121caa798a6cf8a97be1fbf5dcd197e690b970d20f5bb19356572c2d5de8dfc8a9f681175688cf5496d2508713380410da59bd10f2fc8bf5fa1204ca907c93c8611fca03855c3c4b183f043f67374c0e43b3c8a56e25e74f70bb11d86621f6ab2861a3b6ca3e29703973e2d7322175107263852ae5d0d3ecb893ed3dd2d52fdfb9a8f830609e28f6f81515aa455a3a6b8d8829b9105f0e210f8a3f0dfbb4a52c6c0de5568bb75fe6139e6a433aa3706eec16ace2974ff98177f1dfa74b244eac3670441a89f80eb19f5a41bd51161f2e796d348d2157727ed16746604d6e10d008b95cdad6a9c380b6f88c1bf7a0a322b05a39b0f1ce950a03e04c3baa1fb23dce5a3354de6a2ccac375b9678cd86364a65018a11cdd689d58c98b8bf384f9a698973f18891d429449f70494fd2dc97184f42d56ba4268f09c99b90e7b1f250e7f1476f5782d2e70442df61da931e2ddbe6795cbd6d0c4341560ee7e1f24a5108f2c3d5733c31ef0a7c1880c27e94182b3eee4fae35356d8fa555907d51823b0e72dd7e349aaac8ef44fd7465874c0d468cf039e57ec5c7e3d34efe27c3f3b6f766cdd31df254010ffec0ac09ad33eb0cf7e721403194909a25da3759b7152e01b07257b9819914938cb6791fb0d1431638c1fe69b613bb28925b63575eee469c7eedd73307b410fc5115e7f5468942186dc0a6a5a5d634a53442653d3b2aa0eb289789bbb57b9287771ec1c1af6d756cace28d0a22899054c49c5504348aa52eb7b22b3ee938361bd51a0e8fb571436346652732d8a03cd4e70f5f63545d8edac3a29b887063e4f289a7bf335259fb1997081d1d5f23f7181cd8699609ca1691ae467d12d118bff0a7748238393f9599bc42c25cc0452cd08c7fa6fe575f1e80d03175e2e4988d45149414fe7fb351393dc35c64435907f6e7bbd099ac45cf9c6cefc122c72fea3a7cb92c2f3666a667e25491564847bea37fd9a1fed07add5d7fec3a182261eb508a7e2d724401da0fd35d74fffef114576378f39dec78e664754a2f1a85c7a5577a69a0adb31e5027aa70ff69de02a6a548f6136157ce9ac44dcdeaadf602856dce9a54785ff1c17878c5e2ffe14c7c0d78bbaf15d003b4e209715ebececabed495f693377ea17d8e7eaed849f5fdc694f3d25e72a27b18d9eca014e479b1c7b506935899288d5ac391f2459ffc3d45f2d5661755baf4ab99e37498bb4cda1a47b14af8226dbd913518faaa0e506b53c0e8e5458086271a0b3e3689e9816514d8781d270033ad34c48e7f8b8f7184dd2b96fc800947e5381e8d50b810e25562bac10ee2870cecf18e9626af032091acd2e0aae5efb88d3296894b2686d9a1a28333e4f55ea8c1b5c32e99b8be68db1b3114921dfd10109ab7bbed058dcf1531e82e8c22c805e96cf3e6b2313d3657fbaecfec21a6a262482497486d18273ef79b007e7353341d22a54846f9b954fffa836a68cdb42b1517d0aea4b657ae9757f4fc1ddbd28dd8b9107ba48129c02e8d9fec85ec8884ce2e2b7000ecead80f5d9ea867298b37e862b9844c8fff0d392620e1c604299aa8ca0f2f4b595e78d03772982b48ee491130019a6948b023a45dec093d996000c46c82d917b2dcedd7fb762d8e758366e1c31605d0526bb21ee99cbfb69930dec27682df1677f4181daa2e3bb37f5bd83b8b0e6315deed49f074556662fa8d5d1bd81cfd739e65d3f461ef1fe1de57fa4db7f6bfd01e18a564fc95d177bce94a4611eae3e4984558df942e95dd227bb09cca3e2fdc1afd58b26f0a98f2d8ad3956240478de59c849cb5e0ae6f7cfba457d1350426f2405402006749b5d14dca138abc66648d53eb39a19466655f7db744b03bada4b7c836254162165a30e753567a16fd38d34deeef902a12dac055d49f1192a5d1d08b984f9ec40046a4998f50850485917c95cae50bc7f4214b9cf1facd1d30b3a03517987cb5038551db083df8f17143539c826796d331c497b076d73f5f1e69c619c1c41c2beb1a4559dfdc84fa4c2f4ebb8aaf76797128291b4b822bad42d8292c8a8fdc722563d8c698b42574697694896463f20d8fb271dc3b29f8ee1e30a2d377f673729a55e6c84dc0c6df70dd03fbac439a320757d4fe6ae290cd3bc86976dd9a8e46b397876be8568942d1ed23a4cfa98f001ca305aded2f569765a71926f4e23f4db923c53df55b7d4ba91b47361be236a66c4a094cffa4f9dea46827e8fb09b785d260c2356b3f3ba0af92386d42c077ab748ea339a9a721152c1cca57519d7a3fe4927f7a38bff73fdc0875034df2053af3cec6ea54e287837947202ad2a5bb642841358faeb4ec4d7319a638cde0fb1f1a2d751295e464aadef7ae914b100aa51ef79d815846b60c32ccb2d586ea55554fa86eef36521ebee4b7b4a65bced6fc8b08defc1b94dac1cdd6971252e89b50d088269dfe9a4f639cb3701410267de96b0fd269fcd1d2fb87d692b40ed5f16c62a8d50e73ace00833602de8ca1ec94d5f6b4af8b7a530933ee1a7746b870bc1b864333378440b19835e24857daf52b1f15c1f347525aea0b755797fedcec77a23305455c3feac92866a341e041ff417d4ce8865fdf4fe81ffcdeb2203a1f36f26bf32115fce0639f98fd684efcc6d1b9ebb94ed468885eb282ff1960035eed8301972f3fa33689f04465e0e0c57d8391f88baedf957e286c12ae27f49082f625c3049f411994d9fe292feba6b18114c082a73f15b13b529d9f72e5813250cc688d2cd8ec3eb26bfd97b6dd705799a1576ee1b0836ed696dd6d382adb8a8173e4d274b592f9f6507e5465aa6acfb190914d502f4450a1eb5e2266f23279c7c2bfe4662c14000ef30a217d039da94f3e2e37dfdb85397ff5a2f2ccbe8062b158f8cbc12ee1b39ec2389a5d24701b9b2ff337a5c5c415ddb9a8529037fc947e9945fb6795a53d1b95d87e41b6fdd7f6d2743696c0c9fb14acb0dd4be30eddd5b1a5a84ffe755335ff20d522dd387a773c9e75fd4ad6e4e554e659a242dd1d84607ec5edf09ef8bc4d5b07af1fe1fc59540604a318563d60b628292bb9e5231c622cd60b4e03e10a71be3062a56f007b5c01a40c6656ca6d5e8ba815dd9184954ea95c9483a4375a92d25939ea0eecb970f94589e1f095d99467567580090858ff8072de2b0accf20d8432f5f4ecf215fbe250b9de3b314ce176f15ffd45e843e58096602b8e678976489c399953de02266b08c70cd7ae7bca2c7f9c54d42a6793f9d140fd3efb25e158dc64f3e910d384c6d156cddc66dc957c1e05bdfa3fdb94960a49a905a5217e6a48d849b4c3fb3439879066a908d29c87a90b71dbb86fcedf4903a8698b6c66b3e4f36678957f10c33e45d9d86022b81c15b290e33b74cb05dfb0e2f39c46a60fb61cdb200801dcbe38217926d93b85f1e0354ed0f5a02b56904a0c12b3924dc6c235a2478dda82f8570397ffd4f313ab71c959c21e9663442d20171536a69541588c3b3231a95599e1a73f301e7a932a5c1a376981a6f8df31125fc94f59394c48deb46e132524c9dc0b4548f1f80ae1e9022adb413546c01314905445f097e7eda616890f13aca16dac491aa6eee37129ba1933f8bab6875605ad5062f3fb1b8628846a09918f31630e3c19f3e6433da1d132d1091506762d565780c9f96c648129035998324d5ce2796beaa86fe1d118592f58e53b061840462ba0df37b9826d78208b71969093378525cd8013cd935d06909c20a1af7a2482cb4ad051266ebc251e0c109d9c0c7842fdb187daac38c59f7e73193837f953ec590484313ab919c5e5e07ea5a29378abf377b0925eee612e1a7a03279c5c6ab957b17b20e79a13fa9b9e903246af07b4cc156a8c6564dbfb2ba0e66f3fe90d5423c068c84a118d96b76450944713f905e81fb4dc8b1a279c6233482a35243251cdd64df71c24cc57e91710af933b988fc7b06c51986273179c6de126f3bd9fd02203368481a9700c1c7e9e6772c541fef6cb55fcdba13f0ebbbac77850df1bc686c5220fe330eb1f6b3b370f12b5e71096934f2c2c4368298d26627d2c14e2eb319f428dd59a312432d979f157ce0aa71416c54bcf77f1f965380dadf251a68497451a9111cad6000b5b0ec9c59cb2cff85689361be03c2994c811823a09c03d9e5ec5f63be12d9145e46da7433de08beeb0ff7bf2d26249b8a58e84c6648158f23fcdd61e8f308fca04765424e3da518de1ca091a9500db0fa149b0047eb3494121626fad93bf6443b6f2a00666ec218ca8d2ce3e892248fa68a2af0ff3ef418789382b1e297bd36f173effe356b575de03eba7fc9ff92d4b474c8384e4b2fbb8ffd480195435976e7c0123c398d66d0708e78076a7c761fe9cac44eaece5e7f124666cb769a7b42e4b9c12282ca64287188ef17eb319972d80104184872b1bfcd187c3feb7f867048c45251b2ad97d95d15d7a98e8bad10460e0b4e71327ccf5cd19c821607ead71120d97c681ab25a2626bd2a8426354921fb162fa0eb9871677b38660727de705941357fbc3b7cd9270e3a40592ad71188c8774a3623996bf1b4218b2554b7654730b1f06e63e883fb98de7320d83048cab7071c6de8392a1e59cfb4a723a5820f5230d94e70cb8a862bab7fe01ff769b05fa793a51f6c2fb09ee8bc9eb3f0ec123411f86d2c6f295500343b8b71597a6909f3e034d77970bff9e5c2215635ede6d9bca4c1647b104ccf2bcd8eceea44d640300027d824e719e9c26c9c819e4674aa5509d711d790ac77811ec3ad7f6995900217172c8a14cde702abaf1cc33b1362aca82e2567d89f0d05c3d1a356d5929b191109032c677d15f0ba537d131dba911201cbf01abdc5c5fc83d9bbe523d8f21828d462e58f29ae0b03b69e936629387425536af755248ef32d316cd0c53c88732af7b1f924e4472a0d71e9bf24768efa9a7cc6883e136a132a57195b2cb6e3d1380c2c7a8afe43b465784a017a502b608bb5a2561e8dfc5992b27e1720863c13dc7c64964356d0cb04675ca3a7b35561baba5ee8f43ecbcd4602577560c121cfb15e4611a410b73a122784e5e3a420aa2441152f17b7114f7e51eb8e03eec8f660c550e42b8026665f3107422d450965633d2b1f07a0d420d9fae5385d32d2f87723a57c5696c69e1e1a55cfa56ffd404041134d74aa298ccf706d5663290f07102196012e29370bc592aaef1ba8045d71976897347b1fae11e378e3669814bfa6be2e1f2c36e5e7a39ca550cb44fb2092687b19ee4b792bf36dd8b0a33cf6994d844bcd69fecd7625a405e40bc1efede0318e55046c9ea764b9ca3a3a5396c6180c601967f025aafe49801dfeec10b523814544880397e6076b9abcee4eef1db4f389ea51031ef9b3f69d4c6a3efc60828fd6ce3874cac835b10f0cd08cf271dc2e8a177d8676a08db8a1dcb4e1f0ae6cf375590a12f6a63b6b859af38c2a6eda91e1c8bfaf6d26c5f1e0490fef50b6c7b787abeea568a3ca2e604330eac1948f04a4704c1263df4cb6a7ae89dee9acdf70045bb5ca49b9df3b6028c11c0e89b34c7446d434cb6d1889faad973d805facb2e0c246b23ce867eae17c665d3611077e314cfb67daaf02686cf4fcf6622c737b536f8e6434c5f69d169085e717c7494ab8d01d5d6e696c9975d2cdfc5f7ef68f2f30151136f6f2078cd9afc970c5b20b863b0be7fe362f48e3c73cbfcbc627f19f56f194dadbb2b05bebdac7e7f7462d272d5d981d8dc47bfc3ab2e303f643c382d3bd188b072dc9856dc5aeaf95c352673ee4a0f37b228fc4dcdf51226f193ffa6800178a19438d02abe5c5eb5a8df4c9b8d14eb479fedb2ffb359d8592e654b7c2060289862d1d6d0c6acda27dd44f909f4673a45bb4a45faf5cb8dda15ae9eace8d7844fa56a15f3b574dab4770eed8a115bed7ebf27e3f820d26e2e80380808ca1152b8819966df5b4eb4b261e59bc41843e60233d7420ad67eafd80876c4b9dfa768bfeaf66f7f8173a52e2b209e0231bd0aaa9aa8f307a65e8f927e1eb929c976ab830c6f83e7940c42d9e5a45990f71ccd59aa2c6439123bfd8dae5eeb616b838bdcf1b60b9818d1f31bcd4412b4c4e6fb88378c177b7bf680d0c6e6e3b217b8dcf652009b25157b1d34e2e34adf05896722ae2ef56a39a512c64cc0c5b79cdffb81055020054e684508e2b44f1113a842cb11cfedfecc7a92ec59b3e0203d5580bd9d8afe941d926e0a65c9dcf599ad77178fa42d1f6fc821323169afb5378ca77fd7ee6389edb859dd2cf1eaed35c59f5b800c4221a4ab55e5024765856add6548caeff60eec605092afa910b730db46416bb90877a6f341d6957f982d74fb91f7f30567410ee90385eddae377126f5d17167de2560cdfdd9b8b280c48a76aa5288912c402a3bf70a03068a9f2178ecab4e444c6e1edb01e98fe818e6b71bebf2c6d90401517f690fc91c9432ededdc5b117addbaeed2301a579b82580bac72d94696a3e2da851c1c473506005d7aa60663c1d0a18bc4163243b4b14e11d9d67d64339d156f9a3cb53cf4c77d371c16af12394ddc40dd49d8b52c53fb3fd0ad8a8606afdfbedf4a308ea2c82ca19c78be2bf963fb1d9f2ec574eb87b7e787fc6759b2f23425b3f8035339071cd89e8078b6e2e871ae9cb85461ece810dfc1bb046fd879f5696a11bdc869c0f230959c2e0355b0a41998e11e03f5937cc8692a40c6eea4dd63643e9c79dcc8d4fab34327fae4fcdafa8011c12a7fac55de44b6146c10392ef935b8e2043030b5cc14ba138f3b19473a051f4031ca466faef151d04dd55bb5f1cb5e59e7e2e549aeb933414722d6e14755ed206a2516abf0d74be3f74c264d5e152a426bca672ac88993303d862ed0a6ed9b80b21f8132b3fddfed659a69d36073e8abbe84470211ccd4b7b7c14c06847ed54076dd1d685822f0ffccbe3fd5f91f8ee6d6cc76f2f91526a7521e3a6475775b523dc9d0cd63e0254ceacb655b72440afc9cf57d636fc54f8e3374d34c9f5dc3251f1c139a44fb9b7ba3e18d97f588a0ed52ba7d80a0ab9ef53fca38f0c0119fcd0e7d798a2433c92ae49979e9a721ee49072bb6585cbf568d47dbc810984f5a08312d241ae599a3bd3bf782f288fa52f108cdd26215f980d8776bc480db7c7d6e00e5d7efe0743a1979186a6ae04b459af34e95ec06993b9dac9f6b6ce9463c5658d0f32b9114d5586cdb3109a5cd1212264ca0f95d76b16df77ba60d7af39e8f1a6f6026c78b7df8063b0470fc98e0bdadaeae18ecc77402be649ec3f117df4096ff7100ada60f5c346f1f71c8d2b03fed9740973b34df8570da7c59b73d5979024a91fcce79cb77ce95eae81c91a3dfeadbe83c90c2074f2ebc016549956458d9b04fdbdb0d68cbc543e8c361f70d8c8b2044758af735f91d931d8747ec09b33c8584c0444880580df596f45b80b7c0775281031796f64af70b3512f01b365cae87a1fea6c702d2bb1380a0f73cc374d32e06cca0cc7c1abc28ec167655a1785b6a5bd44e94ef0edfb46370736a89973d00d2303ef33d3a83786928667a20484ca8d9d4a0e48f7c899d39b35cec7fd4654ee937b4e800c754511b0297a7c3c63f91c021288827f5b73ea16f9ebc74673bead609c9a0b1ea6ff78f912d1da17e429fa8889429e16ff814044d45a4fd6fad2125480e4f34ee68dcd026f0cd5cb519114e1cb65e9f22fbec80a95fd0d042c897b0170e9a732f18d809a05c5ffd633f021fc5898a74fd26cdf3f3ad21bd3d4239bb57a50030e0bfc51c1fa9c94b1f39d9c37b5e75770ad1f18ae7205e21c2c8634b5353b05b07ec3750429014c48e4b67dfbdbbefb266170ba72cfb8d9234ccaf336399e1d6eae8a12af1d0c3c83c9a179d66c65dcd53689b41b611da20332f2e9da22123022b3ab353b63ccfbedb04d55d4422c7b4cd88f8bd8efeae092f0dbf4a18065839fd4609985bf552c750ce1ab8f8acaf98275cade58f3a69472a7e2a017de3caa1892dbaa5dd6f833af936335b2362e4dce579f2f99e1e0effb1e2996dd8fe2380f5f3d56fea3e13b7daa56bfa3f3d97c092bae3976fdac7f83ceaec3626758801c93ba6db6a5f526caeb97d372c91e6957bc37ecc9af39edbd948f3bd4345ac1367c22409003a83baf3dffdb6d2999e106cdf6d6d26cb5450d071788824ff186c0ba062306bd5a6de86e4020e408a382c2164f4c253ca5f819de7fcf9ab700bd1a84ebac513faaff47ed575cd810b98f975ccb9115aaebfcf8606e9149fa295bf90e1d7e15881af1646e3552573e859ade5c32911b6bd062066cdda03136107a96d8268d8de4605da01bcedab43a2a278a153d4aabc6db1c994759030e31c07ee87ae813884f6412b4b27d8402bb424f027bd4387d2052f89926c44e9a71a053956aac98ed68b5af36ff38711147cd26a970b2072e77a415ebbc5123d096fb484a0d3917b58c857fe51bc08a526b1bd5e143e52493f9c9ddee04983335303e4f2984050ebcb2e545dc87ce1e201bb1969b674bac8c854d641052b5790bb1adf42b778f6f7b93d804ff1a8bede3dd532813d8d3231fe7f5b62885b5bc9112dc07573a5a350752eea3b896f096896f51f989177f2217ec1e269bb1802bc0f30a6d5669fe1173e0254d1f65f9e79a0b6a0756a596218180c197af0222f578512a3ec040a04630b9f8abae4fbdf9415bbb542f0a109e4b5d7b104dbd7d6f6605b853121f3f5bcb470c8bf6718920af957a68f1d701d494076f32441b41b8d02172c3825d9d7929d526295ec43a9786f90ba1cf92d3b12d4d9ee2d9fc39e95d8e9de9ecce1118bc71ceb387e640a49c878691c593d13d58e5b606bf651b4e4739bc2fce81eb1b87a98f0cdcb2f88371b275e6bc450f6b0cb8efa1599ecb72b27a4f88f1e7dad92e09139f79f93e6058e1ab0884091d8fbaba22ee1b5edf28b794fd7b03982cb945a87908494a477cdf7bb15d1c6e9578cf4926d94abd9a2292b84dfc4f5d26f0131e2159a9c8f8cd7c50e8c74d07ec2a9f9040de1c0a60d87486be1b1bf430694ac96ea47174f6f6e921ba5326510f17962ef29a29d89757110f9959432f7374b7dbe12952bdf59e2c1773a470092ea37bb16bc8a4edca560d51843a9ecb06abffb360978378eaf627f7dd402c63478954a9e866e10a18f79923b11f728042f20e70e558a12543e59c29031076275f882079e4f6febef88029097149baa42303ad1ece6b2067beee8599476d68c13485b050a807726b51e9d887556ecf2a15072336a73853251d95fbf4941cc048c8f04b6990bdc0130e69159466d774d425cf312af438f48041a1b177403e54dda7aacf35c53a93f91fd66a9fca329b374a6c9f51d8d9e90c8c77fb1ffa4c09eaad5ae2249b8c656ec4332b08d125f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
