<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c33738f828df8dbe0bc99be06388ed70aeb222ada2aa2ff40b953480b3bc7721996f28c485f4e14613f5fe7bdb4498c50cd231b820ed4172b3eda6c77316f2c7d25f990e94d6da27c36b7055c62ffe3a9c624de3450b9ac1787bb94710c5f7bba9d9109fca5effa7e5cbeaa816c68df15eabcd776223fe15fa4776008b2d6ef2282091338a4a9299b9536f1e0af69cb7f2be9aa6df073bacf0ea5b494193d805669d375f2faa78b49042d69a5dc71640c5a84bb5a4a0bc1a1d3ec3ebe2c0125e5fcc74352bc4971d18b3c306bb421632858d09a24c7449a1f151f74196ad7426ea90f0300e6c226562e49b1e1540449bbc2d060a00517fe073ad16603ceca84beace7fc2dd1c688a4a99e46c8159ef8dd3af73685d4a142aa0aed8d1516f777933099a108178db4292682d3de7ffb58cf43e57ecb602bddc9ca27be0505973b47a5f08dc9df30abbad380dad89163b86a3f167b9c6454d72e21bfb05a89863ddb837c2bbed18c96be0a8f80cd73d9174ac414c5160c4aaa3c58ef2beb68d1b569f10bedc8ed83095b79c6d43f735507abf3ea6c7863cc25c471d2dd8054f83eb686e9933784fda925028e8a38df0118cba335e2e4b9f310c69b63cea7a6613c0aa58662de6c71f6a7bc1382cae0c63f27c6e4ef7cada053c632d802766f14bff0ad785892c387698f8929b8b97698986baf9f225954c3373437a74c24762e8e86e41e324e4333b9807b7e259f3e1b52abcc6546c435fdc7df0197adee7578b885266fce8eb3bb23508649a6c200b3ac19bd109198eb195a8bc4c4549d4cfb5d565a7812e9eafd0fbf2ac7afc19596e5f4e00411d941bc3eeaad02f72cb0b234b79b4ae6b488fd6fbf6c8111b503a8d8931393ba60bc682f3f7b812c57cc9e8adf71fd7b021fd4c0083158d616107889aad7a5d896ae787b369f1890a72993f9052485544c1f5b7e164c6c10b937a8b1ec43e2f159be1dcce86e256589305478d05c060990484aab3457abd6a3259cbecd7fd7a6953533510b9753cb6a169b6d4b49d235487df223e1eb7a2ea739b22913f409ce7e55b760fe1beb925ead4847e5f4076e8b0d4db911481016b4b6ac11395277fd54b524eae1b66f305e754fbdcb51bebed295eb2e9b3808a4aec26abff34466bd2c50772397b79198fd2db839d16913890c14fe1e787bd700ae737b58a878f9f307cd559e17d599bbbba63cbe3d3584e2bbe0678e29aacaf1de71a586f1b08fe34b3694087e7a63c544410cc635fea70f0d02ad98fe43979906cfe87046ebae5affa20036d58127731d0ede7c5275d92e1275a6d65f95633ef39629c6e5275d8fca9aff09922c16ca933c395625440e05a4934e189400b177d227cdb033ba9b0389101ded56c1d5244a323b19a33838c2b20c30dc74c3f8753d60b16d476b829c7efb2ba61e0978e05e4da0a3171a477dfe7033f3b12d43be1c4314c7cd45e485f55918e4a6237bfb1215915063535fa8d5444a12bedb3d96301c77e14ff6422c67b74ae5f1295d6521bc09ec5544e454a3d3da51bd2114f133fcadf37a80fa968e89fb8cb38272961f12d1adcc4d0e0b60040ee2d8cdb02e97b906c097ec52cf8945ba469d9cd495e6624f10f383f8a67b73c81cec9121530e8ec87cc465843d0ac521c92e2e8bde6154150f936626ddeff0522ae48438a5ea25c757c8119bb58d292b362dc716e9f78889e67c5bd25486cf5bf89c3c09b0e302be2f0b9173ce66f15a3b214e09621ea63b87951a1b73491d8d286d5facce03efa9e120791c4c41a473fba78ce1facda23fd9c95c3e1109edd5f879b927cca166344d5a225ae8dcc5dcf5f0cd4c0d9e1218ee300c2af3110df75eae4ed893004e7af2a9aca9f6e8ed1834ad21795a2d4ebff10eb608fd1525ef42a7f4c07cf5db32b6c4c1c7b8ddcb74c32f68cc0744dda8ace988d7cf1fc91fdfe626817d1a5a1c2f67968b6c8aacb2c62859d79c0362b631eca97adb183bd01bc9e66642dda4c6ac7b799cb3d87fad2cb8098c5ece7e58cc2de37f952277a4cfa6ac63be765439ae1cd55f0ead9d1baf1eefc377625ac57f3980d6a71622a4f1b43903ce664d9ecb6dad13440ffe31fe20c2ce3e29d2fa015ef3dfc32eb32853bfa89fb0fb598654ab40a63e5d39e8de1fa035ba066dada4f8ca408c1c055865f99924d1679a2e11656de854b33cd6ebed05584322b27104366d13b79db698bea0aa3a1f3c8ec6d61bd9b223e518de1eab365d34674d98e2b468dfd4b97b68c1fcca903b208693604e71d916309fe637fb2cff2c795e17c126b7641c7254dee8e592c48eaad025ff59a1cb3d19b966f132c2320f1c134c09eb6eaa3e55b59c0db647352366e7c85f814efe1d2b9b7b88d03c4310987c51071c2d652c4eb2b280826b2b669f1815263631be4df41cedd4214bafaae891993e09167cb184e5eb3a2aae05dc772e86ee00bdbb56456542572305d0895a4f37786f7a03bee1a3e315c59bdd75d32f0605cf40d4317af2996af82739118b3a57224f8ac28898349907a164c04b0235e1e3f1a71f1bc7e9150232dcb52e617ce28a71294cfb5286f12d7c20fd4fdc2aa35491917c64dc05e0b2650a6c39653a2fdb920d95c154aa6abe7131a6a34bf1548e576d7e8e38d273db2d7b73aa6605da63648156a56fd4df012e7ae4928fd25bf4b65ca68af0ee9e283c9b5410e6a848717285957e039323d53c3cfeffa7ca8e909f73a18435de4ac307f3eeba0a39c7ca43a84550a28357148ef273f947068f8f9f9ef5e6aa660354f4067d0ca2ed4b0971ed8754eccba3176715d7dcc3c3fe9dcf936361d2ac43d069cbe575ebc59e96b4e084f537d77663a73615fd83a215dcfc212f51b4ac8298deaa03f271ad88b7f2ed10e00d36dc5124afe444acbd6becadeea1b898310697e697b9d92a1957be65ee1c23cf5a2b55c0705032db2b29e508d5da67161bbe0b760f8000ea818f14fd2c0f6a02dd08ac2788a2469ad43e63f3511eca2d69b47feb1fe6235cba2cfbfdeaadf9c516d6ac34481995118b83ee0ac0c03494eec1eec82d1f17b1b67343aea493f5e23f8b6e49986cd32d6555a540170089656ba6b3083fb11469f3d34963a303abde21eb5ba0ee3bb32e7988f15586dfe89a04fdce77d9187ad4cce1ef49b8dd7aad270135669b362b2057d5a53f9923ef5e6febb433638c81ffdbfb4f6b32a372b922816f1726daee23fccc1e71586b36e917dce7367f7525af17f65c6a84a3a287a7f3d7962c39eb3862d1bd2918df52f9362c17ffd63ce9c06cf03b4453497710955789680a108d4d1309049be4557fc2950f6e9d80f451f8666588d09d735632c4a1b362d48dab287685578dad493a41ca7f2d1f724880f3f57c9b628dd27a27323428e709056e38ef0cb385c906050c30d9c69cd3c4a691a8be6b138bf1a23e14e1f1b7fee732330418e7d515f4456ef2e3c597874d88fb29cf62a59031e799691a48432dcf9450382a3b7bd8fa3d39d2d73d2254b38320447eb129db0e632e6cf595a6b1b6ec82e48c8097b42a020fafda0fa6bdc79569ec25be4b8921d3ee59faf577dcb9fe7ecbd050b94c1011bf4cbdb08c9951a100eec061dfcdd255c42297886699fad9fbfd36667a9b8d3a9e35064c10ab7ff074caa7e0c57f6410fe42f9e22bac043632afc081b28380dba37f1a15ad895fe215e78b2007b3046fbd8a2354fba4a27b99e83451ad51c693046643801b068c5d64f573850d35c427fd31d775054e8dec3c7e4e5f50472b1a694d941bafbdc2c5f57351f17fd5713951b5322cde484dadc686305e73890a0f1f9ae1f965b91f1f60b4bd2d13fccc9785fb2fffce1f2105d6a6dc8f49756fc18ad79dc2b6c82485b70735e5ae43ddaccdcac01dd4c00e75176a865fc1662c7e729070fb6248e8c09ef35f7af4cbfdad814680907b215d8800e3d34858fd4a16825d2ea813c1d34d540bbd8b9c33163104aa62ccb9bfd8a533b8d3ed7f051c68a95d88d06c5ddd08d540af19e282d75884eafe6444c4a7ae4500f29686977e4671ac8b3a2c85307db3322187c6c64aa7b7810757361ebaf7c31277361ec35ef7d9b420453ea518aeffe487476827e032432ede7ffd27f2c05dd609286f44122a7546dc6b70cf96e68e259e61e1a292b784f4655816aa0d638fc99a40726a7e7785006c15c45eb42044fa6a7ab9e2ed5b24dea526422d9b33c0f3b653a6e57cf8d55ce9a410ce48b3ab8209940403a4e55e73ef27a3605066dab8d1117079e7a59645aec958c1a4efd9de7a41162742c8864105fb911377cf5346403d98b8366b2aace6e9349526e62bbd073e38102858379f6e528f6968c91f28da3d22f6c0bcc1ee1dbf804e586e68bc802023039104e6aae97e176cb66bba181a243b7dd0fe5ea00a2873c41dde08d2e4fc89412b1946e8cb97999c01ef44b48df2ec02d740d1f76b2d9e9154065025a0c94b5e101f2227d20d83cc1fd90eee511ecd10f8cfcee94bc3f3aeb7153134509310117a76938b7cd8bcd5aec123e594fd0cb966b6f0af755805b7b113c2a7884df86e76ba60401d3ea44aec8aa12913b4fabacdcd15e30de3d0477ab1410eef19046c0089573624032c5e05d9de084806f159e5a5783422a9ab15341578ef83a80513174cb52e4c61f8bfa5f16302467b1efe504f5acc906126021ab876b999e5dfdd30bef81fac374f7edbd2d017b3873ffcd3691e7214e7553dec9581aabc39245e699559d2825223b5543c67a02c11dfe4258c8d0d551e7aae9c670896276cd0f37cf0a8fc7f2c2d5177c8f104f1a62e38b791faffc70f11a1c8a8257319659e2769e4dc7b98b64d0de7e21adc30ebc9bd42254fc1ee7e83c27d686dea654fb0fc4ee899bfb7034a62125d1c3d0c6407b2e3f8d40782a9c99fcdefb43ec582d6a64d11bd7ba233b83ad8066adc774e224abad62717245f9734fddbd43ec2c19a57728cfe97e5ea32266bff7bb04582d3f2c44854973348a6df371c0dc1a03d7b2fca60b46698484cbe20c63db1d0a16e7e916336bf58ea2fad74db81963c696a2d89a4c97aafae961c52432ed568c938e85ae7512e0dfbf24511d019428db7e1485df010c6d3b20434e39eca5fb2c8db859fb551f563b3c909830c2107f56bec13fe52917391c047aaa1949655f261db661276da873da583525426a11bf9b9836306e7fad021f62b0c964ff1ba49025c86c4c17ecf9630f0d96fbdfcec5dd61ee64fb6e2725caf14280cc9e2ce07215ba638edd8a2278d15dd14bcfb96a0a20e14ead12c92046fa5b88211f79e63f6a604a681f12a3ae21dfdf84e14fe61ed2289660cf0041894d5996eb04f43603245abb3c9495a58431103dc3ba7a603e58408d619d216964ec4e3ce11614f9bbf2817bcc18cf774bd469c95e174b544fe7cfda99d79b69217ed4ae4e25f58c3a1d15bed4634b7fc589299c7321ab77d84bb3e242a40ea45bc6268b0cd7aaa1ddc6ddbe5700fe04fb8087c344cd4574d8222f4ab7fa374a588079b93717d776f31b82c75732cfaf1bbbc5e21b3999c21ee55251159379565d8621f27939ca671ebb5f613b06bd04b9b6ce5b458322681141521454fdc5c740a89ffd8499f83db0389b514df60a55ad607aa9d3b9dcfbbf59119109eab479cd11852a30a1cc2ef4d013f4bb0d15ea05026a83d40ce1918edc3c1d59a171e36d303515794bec4c3effaa75023b5cabf6f43a9013e4040a9d484c9b05f59567925b0fefebe6385f3647a139b755d621f3b2d5b510b4d52a60acc5b07e72ecc122db16eb6c1d48bde3badb11dee5ec01251084a1b24979ca1c43d1204addf1599058151a9ae2b0e10693dafb468eafeb62638dc5faee233df81e13fdf75819bdb674a76947e3fd3c1f5df47ce5a67c7f2da29306564510a87f06ee31116a6f2ef65b016989eff6e06a1db84cbf2c2da464e93ff2ea1bf0c4ddc02bee6de69328e30b765dcbddfce8a6462386a56ba2654b6b8ffbbeddb9a22868ef131e1d688fb622d73ffd1c7b3340f310552802bcfb42ce8cb56dca4f6fdd825494c3d31a046c693e23ca0a927454515d63401f3471df996e9825f592cdd2c9c5485d04cbeb81e0cc556cdafe2e48cff7b7e3f29293b18fd79919e5a0c5ac80ec3e7e79311af42682fe73ef2bb1654b6fda3a2f559e46292754a49dfa33b0462bb0bfc95c5747e7f6d46b38e1a59db3f6584fd4f8cc064f7d700314e025475333ddbff94aafe521d818209897ce63065fd38fc97d496c4ae99c39b43282a56323147adda6753d3b88f06e06d60514afc0005edbfdc2ca183b132efd3b4fef6f7597b03f4e2f3f542b5b1c144e106318970315fdb59c71586b27a95d5cb3b4bbb421e872ededc609672649d23246c830d0a736187a559561eb28202ce2f4b2771c004bad3b27c0a6a9e09a52d264a56e3df86f8103ba663db554fe201bfe84fd32604968f5cb5438201e3fd41a837eaba9e9a3a24edf83cbcf1d187b0eda7f6876ae3a33be92e2ecbbf73550a538fd2b5e57af2f92f568a93f816f100df5b09a9df11f745be961fc393036c62e5c89151ec893a44d80c0fb99512cae214cd80bb4554d269aa124ecce97021a6b0149ce21ffacd26b8929eb54b9267b8f9dde78c87deeaf7613663cff3707f0d5b268489c70dbd7a88e4c999b7809a3d0b756ffb695d3f06a3028ca6b65ee70330ba7e99c55b92a7c513400a66696c9e6a86c0317f59c0a7e00429bbd7663765f376ffa730683193559bf8e19a65b6e20411032e369f897959b4a08ef2f8fbb417fde22e259abd9d3d33954a858d5e3630669e8a98af8f7745c6a36d0d4f1fd673c2b3aa35b45845a79b2619369957549978635c01d868076ee4b4f46ada6c2e832d2a6ecf370b66d238269937f6b92b5f8d36ca6bd0ae0d9a0564a67b10fc6e7184bc0e742c69ddc0e0c3803f187f49886dddc6e61b7b37cad5a0cae3250539ae3375e65f99c8689acfb89bc578acf5662abe7e77ea9d705621e757976dfed5df5785de8908d9ea04b45257d23eb7569e16006887d95d99b3dd94ae1e6eeeff82d73a82657bf0596da81a3278d2a115be3d43b0d0e00be6ab3c80d012a2e6d8debbe748eb5861961c169c70d1ffa86931350341327375aa53698ef1d699938e6dd52624c38051051552363a887496bdf9aa1b12f5c417a76cc7f0010c6320fe395ef26cec6b839ebfc70507f296cd78b4f7af0db93119c9194e47f63e6608c0f080f20eeed7e38f661c0ba233cd1ce9112e1583ba0f68f37ffb87b7979211d4883a2512c25086d3e662cea4e441f398715a7c2de57f5377dac36e6991534f128ace64da3b328a14499f723e492c99b6f8c77d8631c1af6904a0908118a4828f6b95b78400139827a869f0b652aa85e4c929ea121aeab4a732d114690dff6c36a30a86d362148ac88187ece21cc1ceeaf7b9f2b88432cd9ffb0fc38dd3f3a7482742c3a09bab23b0b79b9125fa5d87eb9a25f73ca3e53c1dcb6efceed9c2bb67504ea92b8061a71886f8b36ec70cf4870e9b014fbc5ed26b53a63d6358f59af714cf28bc44e4d160e5f7577b2b7d56e086a7cb803714e10eaea0226622dc74db5aa8ead7c34feaab5c1df2a881588740a7ff70633c39731b84b9cf7ae99dcd5222ade76aa3f69bfecb2093a29fc4a4842d17e3f79facb8c419ffbd1a3fdbfab8dafb9ccc6369496c50f7787d5345672a26a4c6809d9f7f2d7c792055a5859b672cc2359dc60532d232022c61fdd1210c3e0e14389f0909abdd7443ef04d64e76c30d7eaa39cb843f1c2e1ce048c5578d9a3db68b450e0ca17c3061de02a5f515d05b39249051b70286229b7e30d019764363143316ccc1b81fc78f13936999f0ea9d8400843d3c52fc3f8edd90495d4a539d91ca3e4374598e6e3588e63d26d3cc180c93edf5595cc9cfc41ecdb4f638adac476c7daeecbe967418ccc1d189c5f03608f7edc34be561a6f0d49c3a82833340792391684d73699f6e8803c02c1685bba8ad53678d022e2d9be1ac6aaa010211643c616e0c585cc0e3e62958fd4535b9bcc51055dfc6a3c03880284fcae28bf04f2f08053819f12a9391aff3cc9997527f9672d17f33da734fd29808a39f4d111f916a97ece80679f482861dc11477f88ebd250a6babf8ecbf5a69e203383df31fa30981a71f4bfba1289912ba7583f3cf5349b2075a11d62c2325217e819f0f6f99427a0729fceaf383b1a6f955cdc70222b53308f88b34d1d2a7d3d7d384f44996db13eac592bc6582978b1702bfd1d2c8ef92e13c9d08d8b1eb2c516acd93c25226215edd83886df4c12632e2c29551395878e183d53f5c0cbaf9bf86c46ecccf2cfe333937134fe697db9c247d40b6ecde41e9bceef0d4b6be8c780d196f977233323591ed2764f6c5ce95bc3a3707015aed0f00ba0ac846d9baa4fa10c74a4cd2a552c131de9e03607a231a42380711bfbb4a9c1b2bcfec1e6f8c281495f3573380f7bf85152bebd22432eac6742e8421e4f21b5adf6dd1bb30e8d374398f455e7c0f0f4ea6403d56b38cb52adbe4f0cbf20fd0c5a8c182b6a219dc88660c5a6bb4853ccc84d464fd4508a2ddd7af31b3ca15b046394a62a202c2199979e2583b44178a39a842193a72b712e406d8e4e259aa535dbce693f98d9cce88b28ab411c186eb6cf4a0032929f08b484a5ee59823426e3585726ff3fb0e7fa6de7d7690a974442d2d2c166ea41ad75b5a4e698242678dd0e7e9b331b56e87bc42450819b158faf6619cbb708086525903b0d4fc0d7615ee2547ed72a578407be98787256b832253a0fe17c6219ea3ed63a5d1efd55d348f1499b9bc9a4785671346a968f73832671d0aa33c246824932af2464243dd05f149167f60a1b1e7dbd19f60e14b12627563d6bef3cb7ff30881cec8e3b1e1ad5ae27418b550faabdbc427328990a4b63b9814a4a8875b5f6797ced5ac75d4dd123e8a2020076e175eda9adfa8c284cbc510e4697b3bd19eeef2dcd99e6e52a6281d753ebad418d2e1626ef8c8addf1f703ef0a7b115bed8371aaa38e3363d8a451da49b7956b2261dde7c1d0b21ee9a10e0e1f3abb75330ea2d8c4d9e369337a3ef7e4eaa025554b4e39e02a9dd2a98f5eaff46381580e0ab0ff24b03710bef7b872f5a62e094eda62bbbef5c90d25c1a05948402d03258413bd5dcb26e54a3e4b86b19351b974d2a308b87ddff771b4206f04f69437312fa4ec1285ce96c53306a6fd598e2816d713afe03ee6120f5745ad43dff1a38d46b0ecb835a4b21fec4d7c03ccb60f6535eedfb714b02ebc1e336e461e5b248a607e964d312af76b4be475ca1c36c6a2fd0106b399d8d902a68ae1c4e26c159a764f8ee2e234f9935f2186d61555ec2a3112b6eb313d873f0c26aa262321cb1c2737f1994a99501660a4994997165cb3596385f02a9013ffb858670030925afa11b5ad636ca9c96b93a3a9ec82b54b2465eb733cd86cc66f88b7f64bff6fd9012cabc12455ba7e23e73f76d3028a4b738d809a173e80c0eb8a5c61b70b8627d2456c2ce689af18d2c4c405d3050e2111f74a7adec65e063ae4ab6bb88e82c65bba2c9eb352390dfad02323a96ac4fecf6221ea15fd5bd9f9b7a005111882e57a1be8a54f4b375b1faafd43f166d375a0471ab3bf71fbc9041920c6ba623dd3f379cf8229dfa25b8e9bdfbce7954ccb4bc5ad6963bfe147202ed54332f6d07cddd476edb2c89a5ee9aae189dfb8eee5d46b3f9cba6d7a166a165912b20d297cb13cb7765583c0bd6d73be24bbcf60bcd9715969c7ee4337cc6f54405d9e7a87a66c1e9f27f070e39c7ebdc2c38768656a03538cefbe37d4e3180d3f8a9c74b99b0d49ab7e2b1928d64c66d9c0b2bb7bbc989e4ad01caa34bfb019f10fcbd68f5ed544c397a5518e430db519668cdaff1c7c80fa527a510fcc8b6bf8a486d61cbfbf5212bd645c5a5afaacf31bfc67061f50d3991945beae804a248df1d92f54076de797eb82a2cd3cc86ba1d67ffcddb4555b0521c7141d71dad0e92e9c0f88a9bf42ee7633b0f4e6d77246ca12d447120547af593243c4a44945b7b18592f8db3c75742dce83237052c395ec3b0443f81e649be2038b0d3d612bfef39eb850b58fdae3a4a91da5a8308ad1f64ab0e3d7e19348a0c6b781d7f5ef17675362f0c38890d483f924be0801d59c4effa580ac7ca7097a82db5a9c6a5f27f91ee996d777b0659b5f0cf1be05a26cd809b121229be8cde2a10a35ec1de6b738b64e269418fb9782951da81fb28cc6778703e4934f97a3ba015941cb33142f5de6a4e4d1fb54cac63f099f33dd24f8e473ad581eef82bb7afc4cf634c065767641c6f49ee8b5a531b7afa5551062fbb1ddfdea1ddb26c8b926dce001c8c8a5b21a6c0f3753fed6da3695ae35df9750db162be9e92eaf1c02617b9346941df3f62b7ff5bc42e90211064d43bb42f3f90b521c0c2cd092cac3da84cb85c86b3d48a3c2964903f221cbf76cc396e61eae45fb9c7c2debc878bf05aa43d22c10d5d1d103bd5bbcf5956a1226d4e2c520646161c992c30e7dc979e307be21b4edf2a7575a7b31fa6474175ad0d90830d31c88d09b5c4bf37c7525c6e2aafdf9903f96d721ac93257df0ee56ff680cf989055244f7d59e06375c290085bd09a1e3a580448c47a1cb318039f4bcef7a541cb21bf61bad175dbb44e7a9d129a6df8b6be88f1237b7a75404c02f39b45c5477e179f4f7b09f601a3b99d37df74ba77f4c1566115e121894810802ade4ee882284065ef81d0a9832b1152e95d981aa6c41d77528f063b04724c1018c9d2e4912a42d6c6ab818b3440744d5cd862671697ad5cb324902c50bab2090f046f53219e220de7144f061e0d455c396a99e59740d952cb550faf2e399103e52d2765368b073a6954234b0a12770460f4e46b1dfbb2f3923cffe248ae1ae4f37d01e845ce92d64f4f182e925ac1c3f0a3511d55d0063de7c4e7b3c7ef72baacecd9b6e63ceaaa78d554974f9b0cdd4af8110cc0ff9700ed8a483e66b62522a3c1bcfcd4a105ca552646651b268732d9d4bfc1159caa887a3f5108008cf6aa660504fe5023db4c4a7e5b91bdc6659e3391c7c9f6ad5679c46d3ffcf4401d863e849637932b00d0cbab45a4d5fd6c67a1ec18db6b85c61ba110899cc14229b92d9a66440285cdeeb8941f9569667d72654457fd5671e8ee0454290878ceeb1ed15928505ce36637a3d75299a6b0126a2394d3d524c1dc956e37c90b3b987cc78a827d2108ac68b8ef477bf1d650f20f36ac064b189fb67406600b7d38668117ff8478afca5540872030f0f575f4e18ef4f87ba12b1e63fc44cb4c67e84a89183c851b22d805ac69922c39f79ce8383879a71646e03c5c6766d55d81f9819181fdff580b8ffdcff02f6c35a5333bb0de3c774648e390d3decd1675c918cffe63e538d09364a90713a980676d7668c3a2ff9c7db01c6ab7e4d115c0e157488e711d5a9734886cf031a6a7449d0afeb007a689afb63be25cc9e510eb1db887989435fccab785d25591b2f91e3d9c081836648728cd8e9d53488fcd6704291416ad27a4d193985ebc9a17772806f1dad2c2e5f1996a1114ff545c290d26358e4aed75c46624c8bfd8c7a7ba22197be1276a60f126fdbcec856309b90073f0f83f42879ee97504976b321f5d465b4d1e81afee1625fb9bfdab1a8a060c365f3fe86ded5709ef1fcb8a4cd9e722fccdab3dc230bb9d27e7c3fc92fe3251fe39f34f6508d8ea0c0fa256ef709d4f72b3d4535937c81ee0dd750e5f940f8f40b48994bf3261ac997e08732940ab609b79e2a1c8676074eb7f40091453a814510df4548401ff27b3ae875bc13288910b8e070ba41dd4918a3a1869384ccb2168121788f7527e26716dc031294fdf04a118883a4c6189623004ae0130efc025201d637391a283e7ce5954e3728f3e807dee836ad487651e1c5dfe72125abfa26e214de9d1382ac8313c930162711d772720e753ef167e98aee605a9df0f63e26184d7e2b5d3141fb41dc11993e9f2d49a54ad15b1550111bff4a20609bca58d4d86350e4862643ed4e4b31fc1f4c53eeb0ce04e8e35d05bc72203d1f8a1b89c683fb6bb37377b8691af5c5045b9c679e1ecee2f83a698616a13c2937c98243449de433c79ffe53be01cf5f7206b880231b53b7059a9c464bfe9da647b87bfb7a329dceb49bb79283d4c9f23a9659ab34cabe65d6c5c2c29b6f114a862580f9ff3f3828c89ca721ee06425877f3298ffbebd58ba687ec646b7f8586f1603e97cd1519134da955bfb5c1490af10150c28157c319962d5c7f439b8157404a47d99e07f48cbc67c1486098d8731f784fc938237ffde2b2904609693a1cd27a2280dd8c5b22812f63150b419f3f8b67125b75e849c4b53c7f582719c6b7a972397b3a55953417964982a98c27e18adafa17a7d3dce2e22276e3eb3f3ab8eda44efc4a36ee846911f85878d75f44795bc8b72b5a64b4edfbe31862cd776ad9fc5a59fb8d2e26f1ce0ae4e4cd5225bcf7fecbf7750d1b773758d0203ec020f0a9647d322483739a31752d6b422d23c567e4298187b4d4f3af19b90780697bd24c491d1ce9ca665d3085dec8ee83a831126d4e9e060c80665194b3a1c7d2df308f48b7d79811d85b04894c22296a3dad413b0b9ec16d0515bf228ba4bf0afe85b56edc9ce6ac2300aeeae2dbc0c0a940e4791053c0f584906fe30364b545ad8e6eb70a7ab956c8047ccfbf7f4a7f3adab4a19204d7de4a75457f115d1cac613309c9b5e0b6883dce3fdc507459f6f9c7d23777ded304222855bf7d06aac429cf5ef21c78b647fa47415ae646bd908da7518453c5c1af11deb9930b79aa9f703dd03e90123302fad5def4f3e96fb1951e455b4fb0175a8bb21e77986d138ea5f5a39ba17e43c86baccec46dcedc60ab78b1bc987c725dfe52122d423e80408089439575a6684a9beac4234332cef07a0d1e800ecf8baf05dfd824c6a12d90977720de0f9f3f8feb395769debd576a1e009e2f7cbd1475e5b2c1fe14ae90f354de5ea74f7021a77761a9ce4010c9a3f5eb9d09dba6135b0b5c0324c23bf2c3595d73703f9ffdee5aed6866b3103792ef78237731bcf4db31da2f8ecf8410bfc9fbb361c3af86f7565ee2ff673eb2d165c6f415bff0dafbd3c2b60de7a26f31ed8bea55cf7d1b0f160945ddeb946ab583a0c9b2a5a3a4bc076501e701780313c5b7c9b0fda6177a4806c799245d462472bba6ed2fb2263847da74fd9a9663d8169f6abcacc47ded4f85e909bc616c8b8b1ea00357e2c89a153d028a13cf664b35b278ed589666edc871a922d285999b9871736495006f6ccec500251c04d0652b6c276da794b4de360b01d8a4cb0faa70ada6a212cc6e7fe1b2ae60651c1b489df1043e9dcee8ee01d075b0b64f81c865d4ae0551f16793f4fbd83656754935f390961781c10dabaa24fd54116195b5da93121d9a89b7ec32c665d6ef8cbe76942a11a8e5e3395a9a6f82e360cbe8805d8a0a7a727bbd80ebe568ab605214d24d1851345af30ccf206ecd59e088e5c1266908a63d057491210ace6ce1a2f2c2f2fa34b560a47021169f3bcd9a0aa570be57f6c1c86886ec31ba68433bc2090cf8c0b4f64435b36d17701bbec8d1dee66b4d75e6c52315b5f78814275d96d45ae735d94b563c2e4a1489282c13707b2c9839a37f5d48c1e63aa0b54e968ec85fa0b5f52a500ef6a8ea2a388599d8d84a8da1c718653e4dcc9b193e60a5f03dc4e72d80e7145a3444d90ab91360cc97824aacc5d5706701f49e6ae72978e57df1987a7b6bc87e0c4334992c9dee09050fb20c603644c0a7cff8e9cce1f8a56316036c59afe9fc7dbb88f97d6a7faf80f8bcdc6c98fbd3cc3edda84133d1d2c10024b5a6cea77c32b40983fb967d4a93372b81e23d0067f07ef5e4911feb55241bda06f9d6543f4111cfa65788d2df33b9e91a7ae45fcb674e34a6ca81b79b0e0ba37285feddd9329daa0066fa6770ca08d6c16f3975160e21c79cbd14d5cef65b71573db3493e7b41486dbd36a2b49be31e8497887ee4438776c02242cabda82be243c9137c22558feeb8b6ebfecd2f9ccbad83bb4cb520edeed937cbe860947cef0e335a167eb63ca692ca6cb723caa7c564e5daa06e1df0bc36f26bd0e0a0ae7f88e4dcb8b3c4bf65884afad8cb688531174b5a2ef2883c830a6a0c5b3f0e6c4a8d98d1572fcfdc6cc1ba9c110b39b43d6a318a291bcb1ddf0603e3f00cd251f64cce7ea034d3d5ecfa423b8182c4615b2f7bd9e90c493cc9096b274c59e53b62e50f69b4cadedfe750ff17f3160ae4f162c77b54d14e6b535b667f70ff5b3f63e16f122496b31f25e0cad21211c743b70c2ae97bedc6a5adb9d811f743e62100f013fe33e439b7d175ce3e3e75df45091bf91ed51c7cc0e13cabd5155150982920a479eff2cc930332830bc2e45015fdc0041aac7e6c093d61e20293ee9a720003edf79c1b85e7a132341e5626eae0ad0036e5bdfc39a958b33165f826939af74dde1fd5b5722a162543524495c4073bd676d02861b61c470d69e33b5021c1d57a78203538bb87f1ad9249109c7b56d259ca56f278fcf2d328d85da9e30e4530eff6c14dfa2fa086cf5016425a271e49d13e8aedb8565dec31c59baf95c80ed2292554a96bbe96909badc288812090653a1e46e45f173db8d250d1437db6d36b365436bc3181f963f21e35989c689e47d751b7dbc77530eeb0faf13134f21ad49107a07531048c39aa67b1159041ec116bc79d722d11abaf4cb0c3c579013dd8fc0d16d48ba4eaba9794493f3f3206645588bf2008e448b445c31b52dcf0c244599e7256fd9f99e4a3b675757f217a12d80bb21b5a46ed6afab13e328e3709ced7fef4d60cbf95f6b7d140a8aa03ad881b5b2a1a4aa319f4875b13bdda11d707fd62da62761465fc821569ca3c40b86818bbb5991f161cbd1b4c418ce50e8edecba1ec69aae6b5a386a89685752ec7f6d6162f09e3c8f77680d026f9e074cd8f5781998150163370449a11c467441317e6403ba0d80de037201e08827ed28825769d6e76fe282434384fc91290c93b546cef7e86ec9522cda733b2d39a754a90e60f93584c037b6d292bbef6fac63545141e83f13ea7db8a43c9c7b35556cd68aa4e533965536c673e154da014ab71d04d3b6607974cee5fe6d4b81300ba872eeaeb53c7a0d871a667fac3e028cbb5f36cebdbc9b06912051e77716ebd182f950eb99286b7f75263d16b02d7f238e19692f2c8b84c188b883aae58658ed04e2b3be9400f12645a4c07c5a8cb8ebaef345a81cfd396b28d8739cedae5c1aef90084fc610e90f6aa933f2415d3fb8ed0a1cc225f5469f2d7bd867d0ed541e93bdef5ada7a7ec6fe7ba187305dab7685ae621ec24014bde6a0f99dbc78ba6fae03cfb11014c01484a996321f75a231ea17f990f0ff319d6cd5da63795185087cadac740d62e8d76673b0e0a4dcd2ed1fde3a6ab05e5481751bf517ea445e04a198f11afd604bd00a83db3068b448063af1637fcddcef312b092c32990e6d66af56afd63a0dbadd55f697446d00a5aba94971dcaba28eb4ad8094f59a480e8b34a6183cd7d7c3e1f2db72f1a69aee8c48b290fd1436f7450a5a9417f41889b2447115e8931f6d06cca9cda53d528f35079c5d1e46f54252e425472fc41e76317a1de33191350da685ed6edd4bae27934e1eec65a4b8851fd6643c83f57860cd871e1b22f9cfdded85c8ef4951283e8386c195faa2371fce206d1b281fdedfaed0e2be11eb81adbf57f9ec0ef1dec915695e47aeced00a7670f614b4648a36291ec2dbdc3a0dea7fca040d50db9d14de33b8a3a4c4bce9a7d06e9c960c1d916d3e651ec181d63e56ca522675f396f21d9bf6452e2f07beded2c5f0ec667816d98ceddd6bd7cf067083a132758e27a624a2b2d28f1d1ab990650faa7cb2308bbdea883ac7705e1ad076e45d87eecc959e28af1adb6f7c9d9a46e04edc19e7bb60ece752395059d317a7dac33b8dd744f07f57a6ab22bf94f4dadb56dc394ff0046b5ffdf17c43c23656b7331c424d71a9eb9847def6fe1940cc1d7f11f572238a85a1085a0e30d7fc20ab2a83268dda1491961b84b924aeecd464e6219a38dc8091368ffa36232fdd920c9b7f25b013a12e15b99a0f37b67824c54342494401a07f1a68a2a51bff452f38d935f6075734d3c783e4493e10883ef87fa8f8921806aa4dfa3f352ec1b10dd927b37ebd81fa5bfb0c8e69c91f3de9cba715de94e0fd990594f6a7e5ef2031a9fab9714eb2f124cb4a51d90f8068422ba5bb38d0fd18a6602fdfdf8619fb771b91843e65f03348638e2cf068a64f0fd9e14a986cc22f3d2e2e4f9b81b350b5d3d3f75385a46393828fe300fda201c1c4d1d5ef3142d2a5ad63fdca0171f56f27cdfd8b037533836a1dae442c76dc1325f8450521138717183dcdf99ac699519ea181046ceebcc4a349119e096c5ef2c07b56dc2df526ab6e604d187b1370fb1bff4752e3650ca49199a19cc27c1632cf934144fc272036b555793df99e6b6d4d16799366585d2b206ea09ce30eb821beb38b58456d3f7019e80cc3e2208e2e2af7d6edb9a56ec40bfb36601f6ee8f6a5212fd79fc95a488306676644da69ebe9256570873a57c62f2d71b237c41c8461c9ec23db33f5f6e2c15d541b9e8f547528fb2c66bbceb5e1d7e7415884b8fb52c031cb685531a44df1360f1557d340299e5e87a5d7f6b427b5f2302f24ec4680b91028df3dd8ca592ad8c13ba5e39656c6be41ecdb2051b9ed03d05e01a30b177f3a2c15cd094ad91c83c9a8a9621300ebff5581356a90fe60eb07fe34366a1e1fe33dad48847e313a60cd7e9277219bc71886c0107fd04e553be002046d730dcff1acf2cf58d6994459e2a8af50cd02a629c2f749ef37dd67d261e83521e2e9ad6af95e1a8174aa1bb403548c80bd5c0cae0b1da04b6a62b692f66658a79f6acb0f7cc4c4f6bfe11bf91e632a8712aced7d2a087faa828734309f2a044c353c7fc38801e2e1fc513df5f6cdf97c524512b2f96e12de3f925d6af584bec6977cabea1b591acd80aeb1d4c3a407125120ef48990649db982957961e5dac49c4f26feb35f88972eccabe55778777e761b3867711759a6f99e7af65def6dd3a1b693fedd04b7117124fbbc004c7f385bdf3e0f6dd2e5a9ae4b972dd7847c767bb8fa2b4e070e085f6cf578f0f3e3bc488e012caece0b28962160c5b5c9f4c6e8fba63297958088af4926fb59901dc9b33207346374d030de823f7a29993239641d35cba8e9236a0a77c3d318b8e29b5b0d1d53971b59a31061300e36e26af95f5c83f59c2f5efd923766dbf703e973c404f265c48f86708269fce1652c6b8eb60e26677ea16a46ae43798f162dd4217f39665c96ba1c4243c5d69882c94dea779dd9bc53269bca1903a8e1d8c5ce41001002ad6f789b4bd252121b88d91279b65b133133558467f76cac89c77493fd6a178dc5fb34041e30003f600ed759cfec166c92a43e90527508f07a48ac05dc6f335454cc36ccb44d2170a21107f385732ec4195535b0bb996d899c88c2af41f32dc070426d54374c81f54495f3690f21f66bb4ad55442f507cc165c6e373aede9c253a2556276e1b33ca67a9d607ec4e030cf3a2b7c10e41456272c86f186e3ee52fe3fc02fbc12da120bac107c6127c3f5555963eeb177ee47d11d948c532d433865fa7de703286a6c72d871b959db11c500a0365e9e46411401647a243425e34fdd0f1a0103fb464b329524e06ca2aebf72317ad88286e8707b32d81bef00ba829e38463788f585a05b8a9d0c6200f6286109a0c2433d6271966c448f58209eac74d4da80a91edcba09d90df44b1cbe8e17fafd9fbedaec8decd59856ddf024e2625b37295aa08f047b4354698d7219d3c3a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
