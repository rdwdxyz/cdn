<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31f8ad70a9c340645ef6f7e8d43fcbf4a9409edf1524f940c9aea386a6a51db085edb0dbcb5323bb40741bfee1b73bcb2d8a4ab03f9a2a01165a060a901d521eae25a2fa6aa59cd15b49935ecc5ea383c962096aef807a5cbcc6a84aa82d9f90991f3c85b5b400d86320ea974c50b5051a26e3d1efd2fa0f08ee2bdee66ba0207ce03b41a3471c3925e1c42075abb9060edb2043b4284367d73d3fb9fb616242fc8cbb6bbd49a2224a0478deeb49a242b3b8088879332858a321e5c70e221996a685054fc2d31fe26a882b2042af0779e475f46f1c3f0fe9525e85e2db93e3dfabf1092b8387963f6db4d967d2e66aee6f0d68e8e23a68597d888cf60dd30fa6ffac8fcecdd2361585d32ec4eb6eebad333b5f05acc8fed98f3e9d7f64faf719f91212a8e473fd92987a8d1a02aed8b014484918b0956d9fa46a0b810dd013836be72ce0b452196b27efa80a02254e84dda982d9ab9241038a8daaa3144d43c60ec8a326ef7275f074526cf28ea4c8e9af4cbe4844e135778c268392b159c06ac8749c66e95c304b2d38b7a13328ffdaf85083219a4622485dd19cb8dbefe03beee41ecda973ef4f3a60b6f7ee590760bcef28752f8e3f3ee06e52126221c504abfd24965ac4b6bce3df788155ea13b2877f04f20e80b0c9fec0fafe5f200423588f6293f152ef947e92e70a8dcf0df74ce71aab2e21c49c3a634c3f84d6225845aabc734c96ad5239e088193cffbc89a1664b3d73b21e909aaad039ae87bc5d2f6e40421edcc149229748c7b62b9523dd506a3184cf09d7a081ab4729fec7d136cb0feca767f8063f43f5e30a8163c2d6b81d989a24852c44e563623f8c7283f837ed0931edaeecf44e457c25dc8576cb7820851105aba81b17038883a7140819de9e65d5647740136309950282f42f060e256f2ce9e742b0de0b2d8f8ce091ff3ecdaf32329042800540f49dbe0e314f710960757c280a5c427d608fd5ff1cd02bf5228704d6dd2d47188cf6dbf4a57db4cec3169477d4f8776c6081122b63721e3d1c61b4cc3be4c0eefcf208d3ef203caa6c058d513538a874ad2d6fbdf0c83ca722b29474bfdbd9c431d2960f951fd7706309809659883902db7a15de901312364ac6530d66fa71a53fc40156cf7fc220567ffab04ed804ac28a06e0b43d86e7b07493365dce864ef82cbf53d91e465f1b2f0bd7f8f02017d40d4c5d870562aff883acd468d6fda41a4727f591a72eb8bc8a49fc1dfd74631e71eaf8d6d329770d4f7a12545a88b315a82a5e97403c2d893753668d796e6d53d89d4c161e742576461a01c167d9c9db5a971a8ee9035bab4f70ae451485504def1beb67ebf0fcedd18ccc6a223044f2d211a52d269c25b33dd7f645d0559e4fdb5deb2eb93eac8fec050e9ec4cc753d86afef3850a5718502e04cfb75ffff0d893161ada0dad7d87c2f34806b840e9e96f3c0f8a8a54d75f9fe69dd99cafb09d7ca9e3df8c83a8f70114b4bb0c1877ccc3b62f9449b542edb3abd779ef4160efc61d61478b1056563f7eb0c91ace9ba7236564513dca69c944189b61f5f164c53316dddf755fcec97b1bd8f64f5ea68f99457d6deeb5f46922618be0871ef98e19e3ea4ea37edff5d0408bd0dfc6581ab23c88ba5ece7e7b4db454e8b60913057ef6e8991d6da1ffa2f7c8ca241b84c651c171d08fec4dde496e5ee4094958921f0eb7063b27b0a1bf9f13852ac1f8df2761ff33491f6111f5218275a576695122f0e8cf7b1454c5eea46c627d76383a976dd0ff620a23a665689623c4504d22141ac9c66e9acbf75b4d7cd751efd734316dfbd6816b0b7c2f0bd514d7d1c420c6b074d5ba4c12c72c5ea768efa62158023dbe072e8593d7dcb2f8a50098ab4ad9f283b0b587d6eea01e10fba0abdedf444b5f268e9db3aa81d0a510d6da1926c9bae80f5499e07ba4a0fe6219de5cfb4eefc644ff361e019c61a8f479429dfa4b0baa9a6bf3a52c5de4d135ac78798daa461a8ad4fc9475d42d5ce437f1f5c12aed28b032543c6b58576bfe7836fd55546445b0ad35717c992e8825db800f1ff6a5edea635d7708bcb560b2d66e6ceb246c0b0dd683bea7cb28bf3935a71a290acded915e82eab9566e09811b86a1f7a5e2f60749d618797dd8f548e7636d0df2d45fea907f38c0eaf4c829f8bacd68ad42d7eccdae38f3197e9908741990319ef002beec6ad1f4f2d83f559fc1aef565c1fe5da991dafdda3683c29d6c83dc24a64121d3adb5ac0a39cb65cb412b33da2169e9f5ff9a96cbac1123eeba03b1d3b83e8c94acdee263a1f1dda8df82e0e088162b78449d81ee6c9e01e9c8dba84b9b44c8b55275df0e714e5175c2dd82b9c200a5a1c82ee6a8d6fae19ddebc054394d6399be807bf88b2a0c19d31882be15faeeaf580bf637b281c4f951cb33eb702330230d52921f925b5839ead6a190acc815e916f2af3d01846f5ad4160416643a81cfc588129e41caa968b03a22e5ca27d97b7b9aef990dc153c885564bbb1faf60cf0535ffffa3868ee8cbbe3a2869b4225eacda0ff742e03b9537d37279bbdc1e51429b4f7d616299a07201a855edc56db4d04150714e4cd2ec16cc6d11c5d29e9f52e51ac15ddd818e6f0f2439deb2edee907b280d66eb5bb18bf6e5875d3c4ebfc2b90088f378636525e8945717507084ce0f9b5b5f12fa2aa3cdf869f5d1d4149a39498f3bd910cedc26248c349d1a2d3a2a2fc144d1d2c74b20475369dd50de49ca97412d650b357e3b833758f822fd7303dedf33c13bf1afb79bde40b44dd29f7d82ccf09385a4c81f9f9d6ebac352ca7cfbd152ee7130892ae9a75836ba297e9bae3a73f3448a72eaa222d6e5d29a4f4bf5304a7295c89893d08c30e9b44bf86e9eee7aa8ed66980c8a17cd7eb210044bf7d2a91c701f09aa2f19c885b3e472dfe041de6760191ae12fa8caa127ec137eaee00c8aeb77145e40a7b4afc7fb3b9f6acd5cba01f1a6d5a1155e3dac29d533222848cad9b70cf090d610c140e90f751afab9b13dd53dec597cb5d2c862e5907a266ea31988da4d3819c6d0282282f8a82e1515aaaa60d5cb083785c36c91ad79066f47cb51417df56b9ea466662ab219d90089e3e776d3bb54f424c648ab2a8f3c528dab3cb09890b14a7f82dd4b84912f33e70a1d07d712474cd83ccde819ccfea0cff29ac56029be6518a0cb09b1167d806b40c67f90f76270d96235b7c8f8d42cd6541b704dea815984a42dc8b32170ca8da6b1330e5afb52ebcedf580a1fc395ed30a32973d2e635a75c3b3acfb1cc063cfe6f726af83b5b005180b7e2263ddee2cc6193245ec1a943ccb2d45ffe427e17b6e4c66a6a68132ec299660c56f8fa0e64ae2823de50ac63deb18152fe0d1f9fe627469cd5c47390960ffaaef630b96cd35e5c31b6f1918ef70a3720ecc8a78e06e99a8391449f444c1a604cffa6256e14f7c4fa6e8535bd770867b6698220295bea2bd791ee46c69957d14f330ea2379fe9def44953534e9ccc29ae95a5f5b2ab5ad2fbad65271212f528e6b55ea26ab7011ba9f9c8a78eb3f22c96d1c00360ccd02b8c06dceaa8be3a219a8baf02794a74be638898aa5c1bf4724e7217640f86e1b1876e4481e506287e411f4603ee53744835b600153e3376008036e3d31b036123587738768ee8a6f45228720ba3233be9e4e8d23703e33eec50563957f6fd8bd649db28a030d108aa343e1784ee59fe507384c44dcd267fa3fde9f2c4c67aa9395551981a1de69ab66b5fe32ec6b87fe6d2915429d15a8bd51f42d57118731d6d947ed7f1f46dee727fe4344103947302d51ea941d294bb542a9807bdad8ca770f4cf3dc34664165f6cb861f40d2282bc2493351fc4af99b50f8cead78013c3c95b1caebd00af187ffc2d1f52453332c6d23a4aa42c1eeae79832df66964d2b4da15eac256160395401fd7d36217f2b8e3dfa3c19da44b3cdde174078317b94fa0bd360a97341f6c568343760661b8e6b5aa793a1a0d729c2cf5f1bcbca8b6e373953cd7b2b777c3e6e9d6f3bd16d596079f8e6257f94636f247d97da941b3e520bfd5c59e45e8cda42297cede0daf4cec78e6a617f8eb71716789e94c81816f35f80245d7e8c23e0f712ae08a301055388bde0454761ce98f7b1463196d0f8712d420352ec23e42bf45e8acdcaa15411503531baea3e08e8a92c57d1ec315c72e0c2fa0ec8eb2f79596761b59fc9bd6226a26001efcdcd0fde1bba830858e3efe3143b812bc7d2cd31ad1f51a17f70f33ba622e7a085bcb476e11ec6cb957e669e3ae8b1d0cf02eaf00ad8126ccee3345b3f920620cdfd4d853a954e37bd96a22fe27e93cf2254df356d007ec4a1e98bb55b3165a9ad9eca67d1ed99e74d02ee05fce85d687395434fe255e93a84313d56c06553cd99d4e93825b4d19946dec98accd5ecd1ae7b74f252dd3a506071c04507e113488736dd760fa765988a748df9389c7824c79274a813524f984d16b38a79631476727392fad4ce3f0fde92ab6bb2f334ed1dcba3bd31b876dea6b97afaebdb06a2687809542834d36591ec8a0ae6ceb677acc466e9c4cbf4e0cae2cedcd43d0df12856887c08bb54389b523c684060a0b43f479e5126a19cbc14d6b1df7c983d5faab48ab88e1097017e68d8c2847638c3be98790c24f82d6fbe6096b257c081b287e3ffa895d695836bf07c5db195609c6b083bdcd19da9db4eaebcb271b5f256b6920f8cc1f1db4536616b3332976f429f7de30717461a944127c03f7e3af5db124f2a949acbcc709d0ae00c7ad89728fc32ab3d3686a945b63b90f1aa601dde4a28b7b173fd81a807f41f7cd6bd1ed84d091aad829d999f5aef1ddc7e4df7a10595283f58d85e6159b7a7b7f9a844a13c882b66adf925c3cc5a1dd0c9ffd707aa8d6d2bce7e6d70963a9b30a38d53b4cf389fb957ebd6048cbf3102b4df7ca5b998c2ed0fbd61390904977f06cf6d927f94498b6fb5e4a34a428ac3914e42fa2bfb2324225b227a802b2f87cfafe94ffbed17b23b780dbd30939464e77b4931ac35c513929f2d9e9a4a9e451b5480ec4b017ac722899cc945f3d5f08f25044170545ea83b45edc36c970c4fa1c5e765f9d2cbd1d7aa7cb4b8cd9d7216a1124a5500151f7389744e910efe5594365b24ba580de1dc3f339610de44c0dfb81178800a42b2569ab7ad4316d5e61c5ff6e6a59bc109e6b0d8b1f48d65030d5a9e2e97d1d893e81f61894860e46b4cb362742868c809d798e01c7d542bac03018e14f89048cae609835b730c0baa5d820303e36f083061cfcb9b2b928d8c82c67669d4f1d7a165b024c1ec565b60abd50a249ebd396879b6a640f961921c7729c88e25e13bfddf7488431b08d209ad06ea868b6a5531478d2f051db8f6c341b40bbc0f8aabeaeb8ec642ffa3e70817d138ab4572433f80adda67088a33e2727c2008e8380d509e3eac1bd301688db0982d3502d2f9027b9af8de707a3e909152b793fe1478cf7deb73e56d8c804948df3836d3d8561cea8ecfe7c4b6d545182a71e6abc26dd802d0680812e712c2d3e2c417104f0f0d1c9b9d9814982aac43d67c32818798b3049abef72bfc59e79ac688753f2c4254aad7e50ebeb43eba12d40cf9ad64bf6d0d0daebb5b4b65279713f2595f93966ad4fd97d29f30298af93b9fffce1481f9f0997a977de5000bc742db7939c3da7191252eba7fe6e12f54aa05ea91e278b1ce31f19de2397e0c64b4af51952fd2b2e91f17a0da1d393df78ddcee2a73a830ea1d03418b482aaa7ab859acb1001f8029c78fd60d9deb1c111dfd2dc2b03a07c976277e7f1dfb84b2e66c1f7a7923abca1e6362c3a3d9a6e3dd4570885827bd51074fe7eb0ded855d97e7165f8735542ad07bc64194dcf18a015c93a2d4ea40fbe96537ceb4b1671d77b33ae129eed3ce4370c37801bf3e62393f573a656e9d6935f495c18b02868960612bb1a9a07b3fe72afd890ba447764eeb3f8cc369d4a0f0373df449bdec2ea609f90ed2d7935747560f0aa2da4e96c3c8e0557c47625c4337903114805d6f33694f6504c5745ba7a29a117ba07012c89cb894942afb906a6eba67eecef69f756a85ef40808767f4d5cc119a5222a016c21d79d9cc9f188f7d989d098b01e1bd729f26026829549448e0ab67d3eee0d1816c5b4ab27acb9ac6b0a1d5d7d315ad84c2ae159d58c01897ca8c079a3212b25b1937c1ccce38b31e6f7b0884946689d56cc0c9fc8e80aff93af9da8323817f8c0b0c6798776daa4e61dbaab67fc58c0d239736c8391acc5f281e85e3723f3484f0bf94225fc91c0d438c658b893cf08a8c9e6520704001f8c84d5bc37ed7513dce1fd6bc6044854504db6e67e696444fcffea6bb55fce49f2b48840a9b860705274f70c400f28c2b33bea3060e92abb68778886e38122a32f778e352061e695f3435029d345b5cd414e5f8c042d9b1a7a4beb212405ea6eebb8b6763c6c53a499ddea06e87cf2a43eebe8ea6fd3246262b819ff9879aa5227e45569e7618b17ad03dac314c230d7733ea1a0d36a84cd619e23b8cb7cf4d8aeb20990d14d2e50f88ea9f22f28df72113f82bc25de5c66d0afa31fe4226eb9bf43e8822b0f801315010f489143adffc8988b155303c5d55521af6242519a0ae66a58a675567f51b3334c86fe66161a9fc0b8d69a07b18ded907293a17399c67bb89cc6d741636f291c4de590addd7ad5656377af8e0c3dbcf907b2be745cc47d55fcc21ebac3e1107f7ce7ee15887fd587b06a4318be5125771244329f2b69d7b84f5a4156b59760a6ff9b697848247fbea57d988c605b5fd0c2705fa27e946d58022fb811791f9e0a6a80dce29ff3baddc3194ff6dc5f8478444ece07238963011dd416761e00e61e8498fe63758afd651f5e50a37636e4bf90bd387fc62831a9bcd86ad9999759093d13ab0ff0fb2cb91bed7ad1b60402753fc659ff23b95e08d61bd772ca90df9fdc86413578499aced1e232df30cd7bf71d3372476ea63e9ba8e7fefe8f6af31d8f102c0dcc94448005c92266c0b7fe571600966469b9e71321702e04fa5596b46c3a7da3d7079374db94159065062097df8260de4ed0a3efb170fb7affc7091b0f2a5c0f594ba4fd6a05a9c56b661120d37f1885b177e78676050c0331b57432d9976303145bb03ba120f1bcdafe6b9fba4140cac3a7c1527f9f0c4ac42d94d39625ce21b17aebb1a8c47b4bbeb0729d71d36bfe613a5e954a1919036b465589a794c3317d3b96dac741597de2a172aa7ac558685acb3c448669f6cab33aab8fd881cfa938e94d7934076c38b087005570d3174b49a846bd8f2b8eb4f465988eece8497c2000297c117f8951a5ecdeb113eb6ac7e23842dddbade6fbfa4cf7be07a2ef9b57effeb3dfe2e6c850a14e06cb5eb7b1282120cb943e6ad16ca0654b8edbe0f03c18f0a6dacf5c1e0f4ff8404b5848c7fff13071ee8f94c1cdb5cdb328fc162cf7267cd384243f12164aa48efd10628d060353b0eee6517d065c0d95daee7a2a0b60054e3fcc61102a165d9c6c953a3493a3a526ee4254ffb031a20b46d11b667cb175b1ee808ef8080da16d5142ba2d54bc4bf6a8ccc4684ea54e91dfc007685c43fad9aa2d7598847043b00793652c327efbcc0b30ebf29b3317928827eec5945b830d87d838b08f4115b7812f2c5584908cb3e52a955903da5528b5db29c74cd0808f069e96dc8e6e4cb81b3f7007d339e6af88f57477d11c33f00e342ae00285ccfbf7a452fdecaf75449b2da0eab48438b016b9e4972761ab71a0faf60eec73699661408522265ff5c24fbbec530cce418bdbd4f2f2a84bda7c611131bd7615c55b429bc6142d0c429f9dca25e5ad265babf65c299c0a49a29243242ee0f7d908f5132798b2459f394c1089009ad3807caff25bea3339a632de0a9eb8f6e1f0ba1d4321e30e3231a63b8b51e655cfdac9e62b386747d3bc2eba46c05a6a8f497914ce5f747e836a62582189604b0d907ab0d8d698d3976a0f85f881b9efe27998641f88983be359e889548dc457baa50616a2a1b21b984ba8007a2d78fe20a2e381f0509e256a9749b808e4bf667345cf4f55b0cc41833eafb5782154d6c1e5998ed3e791c3bf77e22d80b710cbab4d9d0f55df4f3c5a8ae4a6b477bbb32a75c2cee9b9ffec4a6b9f153b189182296f355be3c50eda86e8698090f167f82779899d854fbb8342bfcaa8ab884c0f6af252668ea2a1440f0054959fa06bc0e2f11d654baf4bb36400b59b660c1e4ad03a04f34473b8aa3e4f6025d7a9bf686053b76b283600dede61ba34d5adb0986462a8168dbf47d5499e7ee0ce22a883f4e2f891fc67f196d02c0a3bfda54f17bfcac17f93035c8e7b603117d470c5ad374853ca89b1deafdd0897c64e57c905903181ee086d447cbf5bcf179e896482692d0f5d89629a9d9410bf894eaa11d0f3de4e2b16431b5df218b59b56bf927753c8142e413d29557ef3d9d5a44183a41e7e3e09228d208c4498ec49f000996cef616bf81a97994555c4af0e0d9b07fd359af58d5fb529988d1d940dcdc4c0845a8985d4442431a473516bb59a0d924c0650f2881703842832199e76821d6530e3db1cd7b6370cb8468d2e2f64dbd968a82cb9f582134f6d273ee3d04fa12347a626a537b2ef469bec2d0e9c95192fc04412dbcff46c8f28a70f0467690f8537f5c19a406e2b990a621c30bfad7a90b638742249ce52a883690b22f589da7468471151f7467b7c9a8f4d61a98ea859940aa1766a30196c1903be4bbf13e3f71eba04cdbe709ad602cbbd0cbea8262fc0fa086f18c352ba6f5dfde7a442d0f88226e244b147e4d330059195ae58ecfdb07c54cee5e844f6607c192720a77abe2cb4daa1b05d83eaf580273684d56a5afd7239cd77d565cfe72f7c2bfad3ffbd42c3dfa8ee1b5aa1c3d762410fccb4b8185643efed6c7defdfa7e9c3272b36401b95c6a7e017c95a8000458e8705168428219a9978036c51dcf9fd93f00e05560b7bebbdd022b2842bae1f620935204c0ccc4cd88a8767f85d28baaca3b8832f73153278b78cfdab2327c0826137d35ffdc1d5910b677d5791a8a63c4ce4ce572e88ccc8ceba17e7abadbf2f39658657fccfb715b12a515dca564e0dc50bd2bb70a58744db31c8e9f84b4be988a4faac62b5c7443622ab9b9f1f25d5f32c92ee7cd44896066d74ae41c6bd6a5e45ce4f1fff5e662f15ee35b6c04c6474bd3ecd6e4899b35da5e4d9d099699b2d5c1fd76250157f70aca22730760afabe6b8ec24cebbfa6a5836495c32e905f0d225d95229c84ec48c215d887f445f9d13921ba11832f5ea437530fe39700016ae51e3e7a70b581c5e493c3cbc2e1d79c2d08964bed1ce86c2be81f753659026bdaa4dd8df62741faafeb74edce861c1f8e0ad4c11d506aa814a2760ca0af87d777d3b581f84a84be6739cde9d40a1805bdc99cd7bfd8d478ec62477e76c0a988dde3a23feee0a174b09403642896a05ef3d35d300e4ee0e92aaae7aa253954009a16311437459f9bd12e641e696e281c8dea22098313a8040251b35da1392648a55f7d2bbe84343513043c5d0d0ee6910cd3c4011670de3f153188c2f187784b5d5ff8d75355bb57fe586882e50fe3f1fd318dd963c24e6ad3ccf71692081d8c8805acf16428ad82cc10de06d981ef91649892eef564dc8f1948da638c77f59a450d39bfb05499333c0fd0c25dbdc5494d655cc85e167c5b2e128c39b82a6e41bf957ca34e18cc9a29b21ccddb77f643fb1191851370c71d74521a23b3606c765d9c424cc9c11bdf8923f60082cb8e5bee451617d30fb138cf1537288929609236b54b08531e18ea7f436f0780363738b63e9251c71f341cce3b6861fa6e00ca35eeb24684434e66e393de2b492443b1bbfc6917a75ecec3d3b5d9e4fcc627593c2dc1e13e8be518abc57ace037709a4073f30d4ce3072e32b8f1969e0fb549de309bb93bd302cf0169b2c32afaaf3edb4531b05b86e2e8dd7dadc53feaec72223a62b988616a9422da4fd18ab93f13674cf889b3587e69cb771257a5e2477ad6b9c60796d2f837803e5e1db8dc4e18eb21d6d1d56a712724f0429ae3a37f95edb72f4496191997eb6e36a661626df1a8c99bd3f374670676347e2f2c9f9bf31147fe5b57ca472bc4bb79311a7e0c29f80bfaa88c7524afa52e54b874bde5666d20e4c5cc99e7236b27964aaca285dce5179a1185c1201876301f6986d61e51bceb712c21425b99123a3a2275fd5b350c12ed300886777540a5adf989b6f65216d4a6624bada21ec010c6e36698b7189c8928b4def87450a943552a2095c6cd80e58fa245a3cc45cd0495ceab5300de7fd4043e0c06e934476b1c97c434d477cbcc3a3660d9e57ee48b61e0c420887ae0e3caf167866a8177be09ee515e12dcbafe972d99bc0ea781ad6a115a5556e5b49d7cc3ee4b7167ffd72b4c8622dacf152ac3a9dde6bd89ee6df06b7ac63ba31027791b4d3d0a9cea2c5c439c941fe0d410482b3ca5e791e4968409434d3301ba6449bd65ca583c371dbb45c821816308b745c258dc4e4261595547ee3d62b164b32200f86624220beaac6ceb828dd34fc12e9ee7757e5d4b632afea25d54710306d39119d1aea06947ce25ade3998a0d4651206637ffc287c3638b60e3e1f59f2035f55b8515a632dcb9210d33f72f8a0083d41d1641cb945dcb462ef7ec12a41bf562b9e09028b7280c867b70afbf24965d1ef4c71df6fb022588af327547ca466e837c2b6bb9734b47a485f3408ea0a613d4052aa60f005b8d67dec6a5aed13801165ad5632595b1de97a4b3073b366ddab3650c15a5f084784495b3c34290a42f74dc164e08cd0510e4351297689eed2e3ed694a46a4fd9a41d57318b812f8344ef57d1dfd0829986952f59ab8e74a60b554fac03bd0715f73c39922b2da67bfb8ef0b93f87af6178445f35d889802bbedb2adbf38764b42fbbbc188547e902c4b7dae974c69c6ba933011f09e29752a729a759d4bdd2eba9d1acfad761a96e69e195c7b5b526db9285529ee8df4292c8089d00edc39ec66ed30a0220e20e47f3d87805ee491425f91f50e6e276f37416f2dda58640c6eb7c607945c21e7b191919dd3df0cd65e8e820b72100a7f337918431f43ca7de87cd6d8ea89b16dcd6754085011646de49b32006f9d666e1847772514b9652b86bf27fcb5e44e349849508d9d3fa4c378cfd3dd3d4ec7799245fc602290d5b8851fee8394bacd2291a5df2f3607999da00ebffcecd68d1004c3ecb45939666533a157921e93ea2ce7cf3bea6fbed9009a31ba4139ae0ee9499ed3f35b0448348b5bdbf1249e6be53b18f6bfcddf8732d09638fc5c5da3947619246bf2411639df03eccbf1a8b5ade2625205035e9c8b5d21f07d47f983f9a3cbe3d2806e519a20475ade0e4f803e70f3819bc49e31c2987f134c28bfd7b56abb7c5f1248bd6cf5da24e75a4019054386b428531d4a910d29722119da3a415e5bb15672e5c906ebf6b6ad8a1db674f12d1af1d8ffecdaee272dc728cf798bb2cb4e4af444595f94e9132f2f968c103ea191af0f71c5897bfbb8978ef185d2f1f3a43e089cb5b4efc0ad788ca76bb72cbc4b9bee3e4667f337b0caa8e8c8b8e5f08ffbf98e22e18855cb6e5d301641df92918e2b5e716834ceefdf42b54d472151f962369062edf0f13aa88a2cc5b84fa5930db4660cfb37d8e74ad78b0fbabb5c623478fb446e0dc9fbffa4310eba2b2724cd62e1ed1ecf44f60c404019a34925b60b862a35aa43a8cddd3bc156aaca39ff329d00d35bc6e612d5663394383ee5bc666376d8a6e2a4ecc8d1c13ec96610ab5a7fae58a63c52db8748cd59509dadbbd096c407c5f83e443c3166eb5dc8bea2baf31021c625fb74e30bf5e4436fdfea6fbd9fedb67089b5fba9b210eedd28e0da55e18cc6243033e356f59cebfc2dd72dca06c67801151ced23fe4f1300b09b3cacb1a585d0f96fd84d890986fb9d18b69881dbad599e3a5a61080cc0f981777a0c4107483e823919afa393f5b910fb5bb33f524f9f08d4bc7a6066dc645520333fdbdf3f5f5c7c0d1335d8dc0bef3bdc12bedc2146500f173f924d94fad3d50481798ec97a3d246f4d96225e759a492e0ce6f8e49e128ed241d814dc2b499bdfcaea990d553fef6a2845e422a0ec7d6b243a13f50790397af1281c00035b9af923bc0b041300d631cb89052e0c6bdfe47aa8550d23cd5011809f98713e6126318620d40a5b129a4db797c786a47ea93c3a809fbed1fc67b1e24d54d2f6d7e969d96114dcc3d4ff25b52e04a4ec65e9811d6b94582f53eea3e0eff3543603d09ce8a831113cc375ee1eb89938e29eff761a4317d4905b6832fa3f7b6df65f95cc5be53250387c0a42601e7c605505164cb8587186cbe38ffdb2a132892fbd1d2bf24f7a5a6d667cf0ff57a1356438beb2053533f9f86822ad6fc80822c7e676dbe5c5a8a54fa3766f226bb54756cdac256e464f57c9bb2b94920e7781bb2895b0edf1585bec49b445b30facac72726a2aa95287c5f4e9155e8e08d37cb52df21418dcda374ffb0d5951d2c3bad62cd02bcfc9f46abfba7eac20d9085d0a3bb0369bf133c4ea40a76f07e0bda4949169cc18b41a2fcf8d72b451681b1677bbdd38817a07bd150b081729c29dcbbe93dfb4e44148549f4ebda0e7d168e7fcd3f4afb76ef7e422d6418ebd9b5d00f8e8fc408d6c064b7ce960f63dc974f0fcf29f65aee6635ac136b0165e60eb3708a8402e3f7bd384b9a9b23f56c7cc91bc1799cc5b2638b685213cd255ec6273d17d960c43f957461f9f7fd4b4f3bf69640bfe7932bd4ee6648f4a2c2d09f3c3b34f02168a0a984bde411eb16f423b867a69e333cb87b513388cd7f78eca85e7a827b0c56b5a02a9f1b3e1bca336147970b160d92879d45cab25c4311c30290303cc6b17248ac7793a967af1308568808c4406509728465b797b9b10dfc8868d59eb6b2c49658eb99a698aa7c3f90d5a0ab3bd643a656212913a590c20efff15eadee1a43d5d5f194e7c8d1edf698ffdeb38db538ad3fbb44903e195e54af91f88549ba73de88a4479b2b75fc7f075c45925b41631c70d1d3f0010c13002c1b05bfd55fbd5dc9a197557fb292c841a7a2e932ae72bd74e50a00c28ebb821338d4c24a1cdfc376158d113302b51bedbdf561cbf4ee6649542691982d088305b7df5d32ecd886c2f86ea6472c20a2dc45374af573a687da37f189832b3c37f54cd9dd2fde3f59ef200eb7e29fb03588a06de5da497aeaead1a159000d54f5176ba975150bc3402fc7d8a277e7b6ce8df63b57a0996d2e8269423546fa477fc88b06858b567bb4b99bb68df00569d92d3a381bba567d700f3f8e1650528fe76c330fa5705b4f18d4aeb0ba49b9fdbc0f6ee02a27ece4e372bb7b312cf1632ba1fcf34deb7f6b82539cff1e47e83464e03e8dc3da15d21e3af5d68c3b4d0c8ad05465b49dceadcb1ce459992a7c4f43a5869ec29f5ffb29fd8caaaa49c5d75a5a262aea89e6cac73350b8eb6780ee7307c6d652cff38a86a833b09e3e3e23a76907d49e4687682f2220775f27079436a93cc35f0fc8a81e20d66dd1f4eb88a4f082e04aa033133493679945bc0116a607a03e1648bdbe090b185bb4aa8e8a8ab983e11bfe42c9079fdea27e9990a1d2d2a47db3596bb44e9c4bbcf068bd9ff6656db23753e4fb2ae3b9d4942b34f238c2b4ac116cc59052a848ae238a720bd972a766dbe36a8950c6bb98cc6a77bdf2250b6df77896174815482d64ddcb6c6758857e09b6cf8930a61a8436deff318c1065621b839e70567c9b4f5c25ae80cb5bfc8c4b50592b0a12c1e9eed22b25b60f7926058e50268e436650980811da9fada2fa0704830aec9221436c55177bc008e6a54c9f686b1b4d3ea53658b0d04b994e5a26f312533ef26722be32d7d04442cae9504a94ddda4524ee2ae1e787f56d46c12fbfe9239c4a30d4920bdbbbc625180f797823246721eec26b6b82c32b8a2785e92c87aadd7515d80f63961359d1088d40da09e64929ccf8a2ec881ee5a506d5027bfb937a7c74fc1792cdff89170c4db321a6fdd19682c19b268a430ee0709ddd0b85870396463e5a1dca09187815cfc0c5ff739ec0383049e57c4da7c6095c1adb1354d93a9157996b9f3f6bb4aa84645213006951cbcc45cbc463b344543a6b6b52b612c65e95fe389413b170d0f6b2a15ad605e333d20b92c54eb5f17dab2dcbc4bcd7fb3b0f38cfcb6095ddc549793c40cc8e4e6713e2d5fcf6af765b85f94980b351f488f6d827d38f885b37efe8da018ff5dfd1e2f94760588ea22813d55fe854c00eab90fb13d87c6c143cef1c35bee4d9753bff9a3663e719f4d55ef3e73c73131c1cf1c37bf9e9c0b2b85fc7f986ecf34e139df9e65f36cfbdf9b46f1a6d2dde82c7d07ab81a07907f9a40fbbcbfe56ecefe96d616ed2894350284a65628b1d78731a0b7b5bbb3bf6a3ef152ae00e2a148f940525ca03f5f2ec4d614c41eec0b0b5fafce1639084cd428d6152c766f78f18c93d97785f8cb80e4c1dfa3df39e4bbde620d29fc90afceb8d3d1b7af8b7e899ff6000141144d9bf1e59f7169f2bb4861834ee09c2821861d30bc871667be10310d7bf27e14f41463ec825b9d3d08c6f76b1fb6e13cc6d47d0adb94cf745b04094ec78ecc07dc81339cbedbe19ed9db8b21adb267e3622592b311c556c784f27ddfa4b2c760d6833aaca04a04528c7a8ffa218959d4e591436c4ad06ac2946a0c2a924522e02bfcb9c78d1e154502cb95d4fcd7012e43c4b29e064e092028afecd9e74c44cc58164b468d5425b96a16a200dfdf53220b0ae25fa068f2b7225a2fd1d0b14650682fca3c298edf4bc4857c559a067e4cbd01ede3070a734a36b304cb51c5743bd0ab157ad120226aab772d13d90f839ef72b839920ed08a8bcba773de2dd947a25f42c09b69b4d5b8e8b136b1f21f1ea50fe9f3697c260760e5ae435a84012362316601ad751fefb8caaefbce52be596c5b3936784128eeba4aad47ff8ef1c7c8f812723b9493877e51f17f96d017db362a7ed69880a7593c02ce7f9df40cbf32605cda7c369639d9d0e6c074896de281f4e18aee689f1c23e62fdafb2b9b3d8093de0133fe9005577ce0358c86d215162436e967e399a98608b8451a39d37dd17d5da995c4dd63aaed62b9cebd03af2261afd28023f71a6004c14eedda60f8edbacf110a4aa7720fc7fe7a22c1ccdd53b556153f2117a878f5053d130a413c5b127a587c3641fbe29c81922134d77b104d741fafcd1e7a0168317d054fbafc78a9789dcdd02208fd7ed331eb17cf61d2a87bceac188188b8059af60dbafa62a07b6245338d55663bf4281058c7f9e53b7d0d65e8b49d2c4f9b8cb000ff40f2b0d49ea9deb3ad8ca507c7d12739a3a75a9005d0be3bc47f881b97865fd9ee14969780fad2bae3c183e29013aaf5ce7751147dbb6dd65fa22cbd875d3bcf041853bbe9bd6413d7bb561e7e076a36a7f25723ad9d5f429203a87f574e1e2d10b7a45e17923d54afd561f65c8b3a4a72b0b4307cc955aeb198560d27f01132617038734dbeabdad41dbf229433aabd382e5e7864679378d4841b789c2734a6a2fb3dec9a4a522bcc7d70557668183113a661b96b804fa4f20605fdbd144cf1946694b31deeddef772c990ef4a769666d35311a4ed385f29654ebf623a4646d1f70ac2da1b6e674c78da81f59a81caa134be3bde5030aa5747fbf1ac4f3ab9dcc2aed3ce2cd5a4d30714676018b2cb4d9460737565294441575438fbef124aa5232c5aced90a08f8deff38f929b0109892badf48d1a72b1ade0bd914f24b35fdcd3bfe438642238e1eae4ff8b11a46d95ef3533d344242adaff9fb689f6ee7793659c5461a2f1a3b0d5199a7595bc7d6d8bc58b245b4e25cde6cf8ac441f50e0efbdad288c77e72a41b9b4033573bbdf3729aa1d591ad0bc1412a6ca9f35050d0a8b773015a1426cd4ced4db60c71d0f86f19ec51db3065d673b0b64ce2120fb66a224650e205139cffae73c5ed203c78e26e9e2cfc4b2c24b54e4d441871040db126062c5a23df12a3432298cfc16c62e8af7186174805fd9f0fd21ba1e603784206fe079a976cc3f0de1fb19d5545b0555beee46bf1b3df1c3394267edd85b48fef5504d194fe0af1e48323c0f2486028c83006c0a304a8f9a2ff3b65e7a50771aeb0b8acd5d4b6e7fb08d730cbf0824de4cce9e7c1726377857db3a177cce237291a02f18cb24533f61ff7376761b147510e2e3bd52886940cfc4a0f2b9d08650d95ea3e18cbc0874fa13d24ccb1e0df86947015e705e56a0993fa8174c560197cc4f60bf0b9b6d67412418ad88cef40a059d3c98ba20f580357488a32f0a05c0d563962b9da456d7e77bde70793179bd9e0d9cc9a4d5662da7f9c91b16d11a0c456cc450fbeb7333592c750c47b173a8f88a7a324f5998b0ba9e194aaa496f80b6db675cfbab50cd5568afe2468653192f53c647c5522ae2513217b2de97643e67856ded10e8581b294b4f34da2cccb4c139892c1d1b51c81f4094da19d1f8b20f827de7cdd9e5c43c2dd0de47a729665b4f46233955425d060902992eb5c9a612c2febdf97286417478cbc1c49d45c3a1e66c8ea540272e9506e0e905615458d00d09fd51589ddae124f540fc50667889b19ec5229c32fc0fead0569452035a4c1a2ea861c3fcae205ab1a860a37b44031d16ba8e7f53549b7080825bc406120cd5294fcf1c99ed1acbff0e90447e9428d870e06b92e72492d76d475dbfe74e6892ed85ecb11747ef767a35959dda937abb1980620ec4ae93c5b005506ac64d518177e0c2702b4b4a6d228f63d06e6a3742ac2b110cabad9a9b0ccaad3adeb6f9da8b6ebd4b792869eeae93d4f0fc80276e2e26675b3d6addd013d72a0e8c6feb9ecc18966163e138c1ec53cb645a4062a3c106ae07c9e3c3a8c16db705c3ccdf7111824e0461722b035013da83be5a8cc72554014419e86f66ec058bf9a78bca7ddf6e5d7a82a2027a6f96bae292e70d22a3cbe23108da9a8aac29f8dae1896093df1ce079eb7ee76c0f977964a7cedab620f25fec4ff3763837a773f17185698c689288c335749e136c339b3c910428a54ee75e50ba3eb564e8871f0ead4ced1dcfbb87298e92e35addf296ae2955b6aab67e94fcd84db909c1049b6800360a6c52514df56a101e7ea67c60119b25ac583436b48fecb747930ed8b00f35bf7cd393ef3b3efcf50f0b6e2accb24ded9a9d8d6e346ff80719cb47d86f0997d5adc0696096aba6c7223a27422114f468b7473f09313a75f5889a65ee193813114c6b7e97bc489fe24fddd29ce642da9b4a262b894ceb5d763242534161a0743a167eac4da956adc83a43d7641ad875678f77e6857747e7ce481489184f07a79f6fa85c05c7f0017f889d8db2126715679da922658bfef95afb5bef95cbecc9b6ffaa5661ce9e486e8c128c725d467c30b02ba7591e5acc57e8a3986db04021512868b82bc8e6fc1bd911065ec31b3f946c04cae879e3572e211e47a71d885ce9fcf7a324e79f6947d93ba93cc38deafc36f98517a46edb76cab52342624f59014c2ddcb9efe45b454b27db1d404053a905f92735c99698f8e3dcf8af8826e787acdb91ed3c6bb2be5fb798ce90bcc71c51e57e29b376c913a86ca471657cf4dcf413f021ce1eb164bfb08bb7f4bd55b3950e31d8a51d9e5dc3384652e6b95edcbf242b1d0101924a6cd769322ac825be1ff81c10107c96813697ce5620ff8a6a98a106d02932998726ef2d28691d3a7e44857546c308e8e0cd5d63d7e9000f9e9f7bf296bd9dc60e345d6e0d0a34eba117dcb04a6ed1a01be426ecf7535d1aaca71f157cb356392c810e6a22d4aa427db6cb565c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
