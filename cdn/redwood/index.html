<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e90f6d341e08f46b6fe0dabb852e2bf4e3dbdbb6ec70b9400e68f61dd84894014f48d2255122d2188d1ed56e04d767f89be8ce4d0891bfd48f2b12e7d7b2e14b5b01bdc67b2a0f0454e44713838a7e1b08f83facba9b20cb93f957144b521524e262d079bd07c5dadfac8dc88eaf721f832581ab4ec6509660977ed6a7ff9c9d3a8319372b1923efef9a0201f44e2509cdfa258ba393ff5da3e81c29abeb30f867f17c7a1cf3072f8a8352a18efda56d1b0976dcb7b3a685c199cf891b5ae99da6fd535eaf3678b216f882e5d2a6ed80f23cc453347e75eeab2f5eca9d5282a2276c87309079c085381af6dbb04abce293defafe0ee724743ffe08a1d339986540d7cb7e6ea5b1b20c8b78fc17746d7af56bf5f7027577cd5c184980823dd1335ed6ea1e53dab910efb353cf75322bc1e90b967274ab221371c682ea5208a3c806f7f2465e6334fc4da8bbfcc7a0e0e1c367f4e5571aa6bb5e3f2ef7ab56f34800bf97b7811e7b48ec3f87911c316546b53cca337c615676471ecc7a59ea69b97b4fdb1bd4a419965ae528360020a2a349fdc3dc63f143462ab0bcafa4516e12a4dc4cb1136c3bac7ce24e4025883e8f26c84f43d9aab1ef3850a2a1d799dbb884a1cb55d08cfa082b1bcf8dd793e7d69a940d2b44e5c493ec184e57815a20bba4ba82627a96590aacf6e4911b37cc3612c546f85c8232c35d4ca69a556dd8d93b1869001333abea978569316d1bce0275d17da7b2d38807a6582353a73517a49f5f377ab872bfa7c03c37400cebe9ef50cdb37a1a4196ab7fea4328c7fcee1032e7a62f4341399374a4ad720adf128365db19b70df28347b7a0c398642bf10c73ffd4b70232d47d5f41998058864aa4b842b100649e6ba183ed8c9ef63e5cf47530ef5df429b19381a4fcfdad2249f0b15858ebd3a1daeeabe8c2812ef0ab09890bccf878e9798f11c1b7d4cd7b4ed1c0ad35b15656df687fb887f214ec71a0c8274e41333edb03d596d9512da8f62d24476c901cd229c6a4b800b048456c8371ec3e2c27a3a01ddb0066fa7a7aa70a09dca21147be5cb256bc3269d855b5db740508d601351c1cf904edac0647c38d68be916b07cc688d56591faea732670676b8c28c5eec0e3697b59ace6ed9b35c648eaf754b962cca1e63e999ebcac7494ce476d216ef3c0078a906ed98aaa1e83ca04401a6a01bce61b2f7afb9882b253251b34fff7a20a67db3e2b9e2fb130b57e7b796ef669609ef36d57b64d115d38340bc1e7456ec1ba928cfd0dad1d4064798d09d85ca3e094612df73f549ec3e60c5545b3e8a3bd372235e5b94daf01b3aab3aa41bc6070cf010c28f8568836c927439af821f9f587b0a41bc6396a5f1578f6456631a8cb66e3bcd33f40acc3a238bb5d14eeb4deac2db0c69d78cbee9f784f708b09a96cd14d40cc61cbb2addf3340c2322d149f8e11a68c66fe44c9b2ddf08f2ebad55db0885da00e8fdda5f718dea2a955be6188f51d4d0728cc7d6428f3e125d8427ba4b6a5af26d3caa6eb0484a44603dafa1baeab3a42bad11f80c055ac50c3e71a3045d6ab07db7a7c10852596f47db8e37fad24992b28836c8e8202ee51dff3bf20c404516d651194eca4166fa2aabdbd6d06b98c0c2607d3269c8f4bcb8425628dcb2dc7e398e8fcc5d43ef05d54b89afd160ff674a47a3a87ba2a58ad5d822a6c7e33ba721b6a1375f554688f7572c08ce44d4215dbd17004671e086428bfa72f4e3f6d4c9e567d790860456228d836afaec2c2ffecb511eb60df71318eeb0e1d9fd7fe31e0daf28ca72271256ead78a373d8b7b43c02d2d463112f0d4766d0dc4dd162aa77068c6b18dd3301826d854f5d6c5b570e1d3ff8083176dbef6fdfb2867d758b2bbda810cc131261cf7529b27b77ad8cc715c2be769895fa1e2f159ebe14b6b01b771e972a15b0d6740c34acd181a7d889c3c9e3c445fc8af281771d74df5296d6608c030869f0f0f020d7e1a343c6c92ca9966e8da6140272865cd33080e65773ebea51e162c36d4d3516e977ed26d54cdae4b755fb052727f7e027dd2eca3007fc3c480f6297160428d7e7dfdc3e609034ca4e62a886df8cecee00422a807b2d5a179d426e7189513e6f488d6c8f02e086abf53e4cfce4114e92206db3c73780b772323f75b548fe02c7adcac9e5d768ec61c81288f802fc477a150192a9d9daebcea4a365445a5ff76861d9ac56e33194e93b8db5aee02887b454ee785e5779239a233727b1ea70f1737a7015173b3da70c62eed8953de691e582fd7f86326e5a007999b336f6eecc2c7eaed870670eecd4e7d6744e19d21b49c3a8b9cf6eb7baf212bfff8c8dd36b8028b676624814ac422b7813f1c72376a7acf1ea574d189dd1faf1426334024e1c4f35fbd381c4f3baa0e8c9c9a51644388f8a7945ba10aeae7901e4d7f88e194e28830fdc075ee275c15024f8d9ca5378005229ea694e5e2e0938cc790ca270b5d477ff8bc78aa14c0f8c198a560e8417cab1be2de819484a79dce479c903c738814cdba858fcce9680b8ace4cbbf7f68880a05b456cf64e84d8f0639359307eaa29ec5de435158980da048f7f30dce1953d2019466de6728460521a39dae4f96257fe51c6c07ff11c3b7eb1205808ad994875e2b73965329c3afa3aaf9bdfce57e2842f0d8f435b71f8f406de28e9bd0c0e8b0df1b0da7d11d3eb781c93bc405532c3bde193f1ee1ea57d3ed2ba9d436e9ccf2d1887dc0888c9fbf386f5620541e3412d02a29134b47354b3e111a9e3ed3d8a6ce02cae6fe2e38e5718f3ee07374244d3c39b0439d0f9b425f3ef7c89ac57a3bc5848da524696fefe62cf2bc50cc257b7389aa1881caf03feaa4bd630b77e986eae2d924e245444c5090e364c84c75c1f7b2a5f5f4f8534ce6aaf072724209f49e6c13e93c86a712e7146d2e1b6e0745bb5ae3f5f90fde6e27d4c8e5030adc67f7c5814a3cffc14fa1c799cde1a45c50e50a58eb779ade6566198eb18a189fa6acaf70af3200bedbf09d2f8890908d6a731857ebf5d160d0cbec3fdd4a93a2724721ea3fdade673629a6c824a6b53f3b492839e375aef13e3b603e15c4d02a52c17707b5b1a7d6946b2aa4fd4d6a71b3778b115e730473288453e2f3a4f19e93defca53b83265eb6bc835de4e798297db9d97bc2e2d0fca3e24af7c87228424a01e1170832cfb8f829d469eefcbd022174f3f4625eee99f25b10a024de77f57e708a0486e6a09668003b4445047cad16e8f0683735c4524cdd5485cc05aa6c8bf1daf6312755e041b6329b6d845ce05c24a966cf472d3edfe12402aac48a3724f0abde1cb8e2cb00c514b3a101ea25e87dff26e05f769a5c729afd0b2908f04c58c20e40fae12c5c2885fea06aa04cc7345e6af5eb8e0fa790bffa71d0d687be136654ef912e4aff66138e4a332fc266a6a9ba96a58bb78114189baaf3a0bf7d5267a32217f3f79629656e3514d78bf9cdf0a000070f5c258e1838d3fefa88be60c737da28f279541182f5578c455f5c75836330915da7ec97fb351349507e65f68a797e7eb0cd7dcd49bd7c0ed7863e8f318391733994e207dbf6713ec9edaedbcbe7b2bc12b69b6aeb06983bccb2d92ba5fb5979e9091db37791079ec93fe2d4d881f3c8a66b4ef0864dfaea8761bea2942905449e014293dd02213fbd49cf3cff43cfb79ba9808fac7cb8d1fdd0e2bec57876cfc956900d1891496ef5a21896f347b85f9b9b125fd34bfff106a43e0bf5e9dceab59782e6a2924263d384618e9dbbcdcbb6765a9f32cefb107ea4bd846b9ea12e0baca79e5bfcdddf2eeee14123bf898cf8bf8d69f4203bf8652cc88f2b640b77cb067ac6ec8e9f2ea378d60911647d5e5862c3012dec820bc15245e8539009d3a095c826b71500757e13d7e7209954210be527536301c8bf6db65e80bbce5096fb2c6afd983e9d65eb35c9cf43916a0b3f071adf36346c7c58fbf2d9563ad09fc163848245879f4f0900b3f44a3bb71c4824e6e0eb1771d49534a18f35f7c852232f25a0f3119477443665e0cde5fe893a85e3c061f844d67d5e276d9244044b366dd624ed61059e080532742e595815ec4126959aea0dc412066c98b7156d005c7bfd415db36e638260a79d6ad92713751c2f291c35de2e46fc2728e175242d95b95cf99150ad463a0b860ce800066acf01e907c70d2496f4d261e8cf6590f1b32cecf358ef9f57a8dc91b3e88081db1c643b9fadf00553d3466348ce2edd415c727980ea36afd13f18f4f7287f93af47f494f68b2c98aa277ebc2414eeb098bf1a0b89e3b9409e36757ff09f52db63b8e74345b396b22c33ef4904b95fd841b46728d59e7a631ace73ac3bd7091757d83ba0c3da020fba4656e703454897607d2979d04e5571cebe520d1bdb713960983757bb65adcd870bd0227fba9b710f723ca9ca9a0fdd24c744b6dbbc6c6929bd2bcce4f10003b1763fb85466b31174b259a5fd7d86e2a8951dfd11ed5990ce7ab544c3dd29d9e8807657120bc3c687eb1ff85d22e2ddc57933d23efc4540bb8c1828aa105a928b7beac24df0e4d43c8b0f56fd51a0314e37d67f855375a74c1b2f0a42a80b5dee4a1a68ee58d7d16e9da5d59cb376ab51e52beeb9d042e9e77e6d458db65a7ad9a41e31363889a4b24b36e5d0d0a839c73af918698abe6561cf46c02849319aa542193810ef25456ab387a199c3d48e007ab1c5719bbd6450a35dac2459254432f62d6c5479241de7d56275a937bd7058a1e16c7a3ea3e5a02024dd9d89d7009a7fa6250597f636deacc38ce2ce632285453b347ef73d5cde95a80cfbe1c85cc2a3fe24c52890f72d70dd743142b862516967739abbb981d49449f4ea6aed34128e64606cce9de6d10c56aa5cd0c9a9a0e800075c0f61f81a9107dcd81666d35c7cedb6107222084198d4d99ab97d5c06cef411a048c859780fab14891d2896d9bb523b824e45682b3d62799786c802686c1427a2195998ade9e5cf26dbca67f293581d319c990152adb9c4673f4b05b0570566c9cb032ac0fce7c1a9c0e54b7fab97051355cf0a1a87e4a427cbca4a3b23323de9e42980a9847f3bcee4182362077f4b6a7182d7d91306a390b8fc16c1358b4b78f436243708b308d120104a417cb49bc4571e59231883feb1c24d7703297babdd80397b9ea831c4a25bdee12f18ffafb086f3f4f0844f0cb5c447280363d425742d7a70b1a1b35e855236771ccda0c858fa9e432c192acd1d949c1a0cbea78cc8028b8d288f8e6c559c8cae6883ac624e4b57665eccb107929b4e703b08a52beb8488f9e186c4c96556fee741f9efab2d00e5de99942a6339b6482e404148784a63a37659ae28a396c255cdf15b514a974c2f4d211a075c6368235adf0140e549f3392c9f38f00fffdb2c42dc643b86c77217eee756a68db50f8700469dfb5aeaa45235267de4a0bd5e624e52929e70648ea0edcaeaec588e215c66e7084ccdded272084670d9d436a15cce658527aaba6768f2750e38103dcb3f0fd5b7b92534ca92e16ee75ecb8ce94bab4f80fb3214ff7c76471575ceaaa86c9cfdcf160877f48cc525c66495f63be509bd3099676a2953f9d64773cf0064d2b105fe43b7583bdc8b08ebe3ba23cc2c3620ed4d2759a61d81efd68055be3f1759e07e698eab28ca13ae6f246af8efa86164ec0dfc7f0618c245a4b95f3ebaadad8ff3018f2fca8e5749895904c0267e885ba1ee2edd96e563896fff6b3be72a621a9fdd2d52e12fd536674e3c4778ef4508be5a8f8ec31323c09573753793d730523455cc5392f469dc5a4ebdd69716513bfd94fabb69a4880b3fe5ceb580cf75b6e30269d3c2c7da157909dc874dbf5651af4c649b9a13fcb54f3e906ef2d9eed77ace64d23e07ef991e1b47ce55a01c646ecc44ee079e871e7d8b463dbac60e2e3f101df41cc60ad6ce0213d7db09f49d5cd7e3eb160416c86ea55ce864d7d69de90cf385edcbf38c7e0377aa87e647a299bda233cffdbbe926017857d93e92bb65661c8f52b82f523f0b1779dceb43d2bac8ae05a0667ca6430b004b9483d0daab3b70e6a5dcf9d921b6b4c55474cf1afb3bacb13f73513ec9efa66b4a3befcb9ae19592c3c6dd25c27809f841560defd474092ed043d4cae7edb89a50368bd19f7c766837629f35faa399de0baf8287c4284435bebb94612a8685ae38f52ef32c69a715b238dccf13071bdfb76842d3f3d9a5b128321fdfb823b9a0edb20188296bf5200542bf118a6949ed58eb1669440069a3c8579dfe1632d6af42bc706728d64348379eb7079a083672acd74060e714a761af50116b2eb1a90ed396ac6c98fd642cae3140188facfb7241bcc4ef41e1cee933e52beae9295450764b98d1e94a8948d45e92acda546413d5242bffc89911968140a8c89529354e428b5b1ac9cb2a8e70fe069d2a29ebcc44a1e1d27d13c31c745b493dad50391181efe65085bfe26ab26be208f58d549df790908ae2d97848ce765fd76cf60ecd0b04e2bb1b0d2a4d9b287dec3a7b34ae70607420888eb282a714c9704e66bb4a04975d1da06cc091f29826df4893228b91fac40a5f407188c9f888e1da65f95028fc272ec7871e2e797b945096c8968fe7d1f864638e2d36609905486c005ba5e245482e478bc3033ed44d030524d71f9fce4bb4099efbec3153ffde1c8f0c45924b1ec669c08b539b63bdb20031f3c70f4efcc471b9a535cf3c9fbc8dea3f0dc31c20deb5d8a9fe96d4689f1abe297e308178667ebc13fe07a2ac7a1c9cd3abde03f30760da424602abd6db712638d6ceb4b7e52ff70ea422e0bf57aa010aad976146f584a50a509db22cf358d875dd062b6b4958723bd34c9e4bc94e8196d17dde03720f9bf303fce602614527951c7602bf5564b3ed5201de13baa3f3a40daaa6bea8cb9b1cccbddcae5d100d39fcade451c97b388a68e1d361757bf90b5cbbbc7899c56486c2849b61a4db75201fa6c16adbe61dceb8c90b091d2ddd6836f82d65c0c291142150c839b2327cf551685feba498e6ad31215250e946774dc052c6bb2a8288f28183b11b154dd4df3e1f9e3d3b43a8f6e6ace599dd5a509176976822621975445e0dfcfc6109d2f4ded9d08ad2c8da4455e6a55cf31731d5d2188c4296c39cffd576e21bec5c44d86a9564630d2e73c6d3a576010d2d00b4b47d359e17453601a51445aa1f6784482fb9238b84a162886e16492710128a083d7659e894b526e36de6e34d0e67368623433426863da18e850122cf69ec558ed2812d2efe3fe62d931e13404b124e6a72245967631a7b67fb2d18c704655e4a5cd3a16c0005513bd05a60c057294c396813377021ecc9503020a3b4e9261e099242d34d26f8c9a184292a9b59d365fa2d38c08116f857e10884d0c8d57024de70e15ded5eba1a66b9c8ada550e7567e715f36e7c4cbe91848255116278b07aa71606f02f81ccf1cc3eed5fced92729c2434f1078473df71bef220d722b89591646f7ae4b279d847e73900722863788834e8ceb4e364668d51de0b126842ce5f9e4c2589a54e5b5908b33c22a9d295cc6cdfe6b6bbfc83d01c1b468b5c89c7d3e6467c3eea2e9af17a4e751387dc04d2f33c604b12fc706b4e46f6081af30d2b5e697df2f7bff19b1a3e392ffd0f8d09cf705736d304cca5e2d08d3ad558e95da25b340fd86c7d8dd4bc0073b0eafb4141ba6c9274e7a5a90c964a3333aa1973cc5d26c633a0418d91d238025814b82f849e5904658993062683ed81ed672f038769dca43c05d6f8b59872a21a193360bf06e5cf13e95591b8853091c9fcaf5ff99611a008e714ca971bca94fe46147422b7277a5e44a340365e7fcae60097d9c06d16fc9777da9e5d938d18f0172a81e566679c6c6d51ae16d71e0250456a5aa97c5621723da1cf4b33c1bb773a00a6fae50b25c5647dffbcb38f0831f2b5c78b015ecce87fef53402968906237fe7eaffae3901d5f9a26980d8bbce33c38f0d67e66623cdbc882a33634bcb4149af5c24f40ef4dedee7ded98990af50c234bd7aaf552618eb5dc8c8e0da9ef91eea988ab5627d1e9372b531e009d1a4269692c09238d6fbc29a358d2713306c0c6c5565f7e19649e869e8ebbadc01a33aa058b6bbef53fbe3f4ed34a755d644f7f210e5b10599a748229fc0c2c293919de1545b86e709925a8986c46d5a3ec01bbf46c300e36e81ba490b0d0aef3bb4ee0d37cf6bdb1e5b730d30029ffc249b93f76fdc7a72646449c7255a15901c2a409dba4b5812e316df41548f8576b8e37a75766c0f1e5b3f13e5b2d7964cdb9b318817379ecceb09bce759e95a7f8af63aee6d7bf36da2ff904f18854b565b1f1734e6875f0c08058678296ad498d71b69c88a9354244170d37c0226beffcacf5867bb1492d22341fca86037758664ba1b03b36f0be93c58b744cd380dd6224089aa0f0e01ea56216018f52acd4393472e93970692aca2474d9cfce572d7e7eba89c3fdfd62af0a6e1202c7621362e2a2fee9d46babf966d4ad274504f74cf45a99230f9128f4211558f37411de33ec3719b37f2f59af8f1e1f997d23cbb19c601f9e71b2f9f9c21607aa5e25bb6c7f9a7d05aa2e66015ed7c82c7f49b8b4dc09606fa7e9512f3290f5132988b2b30859ddd8f23b8be928b04e2a2b011f2f9a7615320d71e9bd07cec460d90afb1fdc49378f33b67c5d0f7bbbed6dd549529e8012e722a8a0aa5339bb2a65958664f425dc59139c211af5961e493a4755e309cba57cbf266ee9f925f4ccc11759f054364e337c10187ce77e74ad2d51c32624cc5cd6237af1367906695b98ce6941d8b831735cef9f4f3124deaec084a2645ce0cad3a1ca80f84ff2e97d4e7bf52fd3bbac5dcf189730514adb7855b2c9fcb0032f2a5377c4c0c2b91eba0cc929316955412a5cdbafa04f5f1ace59bb29ee9df1754b835cea9f16e7f65a11c7feb048021e475cc90f8a220ef7f5271c1c3b197bdddae0b2fd2359297c4abb36d70360a0ff630ac0373812ec87a003fbf2085b9ff1bc8d6a71830b7ce8af55be21b0811e85054591a64e5f4ab7a619aa6d85edaf144d8b81a4eb4775190714e7ca431e18a6ab344448bc9a241316fff5b958c58e614bbcd4cf1ede2f4e39fc02ba9e6accf52f2986e050f3d65e6d29e7eda041355d52511b44b414b45e11496271c0889acad78ade587bd217760184b1de1339e200289b5272c2137e786f33583528ae7fc8ff0636bf265c8f8a64e650a64154df5ca6059f9d63cceb1d970f71172dddc18a0457462ce678b26c6a204d9066bed7d96ce7399b675fde5afd3cbd0ca110179288ed8e1341ecd7d4b22f33905221ca0cc9c580124eee522b8fa370899a6bb6e24243f77976d8c1603cb21d61f02ba3a95513cec868b466ddaad596a5925163b55f12011b0b733b039144d39377efd81689c95c0126f0ed2f485231550c7c4b7557709c6b3b6bbb753e79c29982111476cf69d2ec190ff1738426fc0e7bba2a2bfb149f3b684070b7da679ea7502f1a54154cc3ee98325639de91f648ecb20fdc408e9e3f4fdbb67751426437a24f38f77538a3560ff033c16642981569afc007bd549f2970b79eb1c37ffed2764e7aafc1e032161b9e3fa6f7932a89a30a5548767811af91429eae59d9e8800ef739c677d37bda985eedd4f0a1fc2ada4007111b09860a12fbe33f1f66a698b46afbf8e36e2b9bbcda06073a26ec89f2f9db2dee50bf70056cb4cd5aba091b12d2da16d549ca18bfa5c32da92370bb061c10eac07ad579fb4d1c9d13dc55a76bc9a556a87979327baa6f16fe001c32dc9a75161c023d144ddc9426717f5fe505cf7fe6ff94f95b8a3119185bbd34a7aa8d17a17db3ab4a9ce9df191de474ed426ab2246fd6f81780ad5578bc7a7c664cffa4c5ea5f5efd4bde2d2d080b065d39c920763831d4935e42d2f09de3ad0e4496b97213d2096c62a6968cdf622e0e1b355d99b8643f44cc0d9b99c330d62e8a5193a1232386a12fe26b0415aeed468c640220a4351f8c28bb6988593b9ca234b743300a5d3149c0a35a2b60f237a576a8a9e356556a7d36ef180a913e63a2fdee01999a30607b0a90f4249c8288b7ae51af362447868c47255bb5300045d2fd574f9034c29581d87b4bca68fb8eab3c7afd4472190a4824b1ce0e5c70cf1c9311907d47e0a127e1bed7ff06b6fb91ad912c0389586ce1eec6d183a00815130ba15cacf34c46b00359663037ecd734ae94c1829e4209165883f4f4f54751bc5840d586fe23a2ad7de10d4b47b1db6414b3a67ce2ad2bad6c1f8e11cedbe9bb4790e3549027c36c95ed00025d0a471066ceb32a29fd532a6bff433d6c692b386945edc8eb0a0c0f2abb6739472bc9e720dc0b9a15001a4a81940ef629e50a92aa51ec727afc0ea7fc6008de09268ed79cd318c4bf135898a3c69f78d6b3745525fa974a6c84baa0f246bd21eef181cc7001439736a5df80dbfb31094a0d48140bb48dcd9af01362454126ac597b89f0201f69dbd9bd94078e7fcc7132b82c3351ff2c4141d3e1df6a4a645dd790e332ac4688a1c27a081f8255ae3125ac9a62d674156cc2e8bc849898308385dc67e72216029dc25c977d15acc8dc4c2727c06864428f16f2b89a1bdb0986e4161fc0579b7852945ed8228384c2e7190105ebc8bc708ff59402d8d17f409b7dee573d96d06e9cd53c16201aff86ea6cbcd36cdbf7f1f90027b70411d275fc9b39effea88590a9948b1eb323b73a6e766cb818e3177b4fb65a882e1d3f95db634ebe2b83038de48b32e9c513590508779edb12947d3d10a4cf94e75f2c7ad2ecd917ec85e3d040070322b6f26385654dda9a807bd95ce22cf21a8ba06ed7a7c087663010e260061bc36119373e0f5e4c9539977ab54ad3376ba9793fe491c5a705544b28ee8b5e5d962fe688b20e7aac848fe56b8bb30015c3d6adc0d50ad1aadadc7781f944ae95b18f3c787dde4592b62f0582f8ab448f2986a3c27be8faf93935f671e42e10e6a50b702593bf1adefea889e974547ab46f2ac660cdb4218f72dcf648a63570bb0810b2e5cda74de0022f8d6bbd045ad5244cb48f1755f593b4b660bc6130bd8d5f9b61d97443a9cc3770bd1a349fa5a19dd8611c76ea818374d31be951f036c35eb7d1d47603430d1afd55fbd8df93030a67b27885d480b1c79b27cc087460e3dc52aa3299f155f02b3224ad3498661295a1a69b9a0751fcc8c7afb404822cb668230840ac569ef0eb548ea5605388b44061a410734d5324c10184d14dfae969e4681bbd88bc740b64602cf39e45706c2cf20d73ba25f9ef7a833f78605f92e55cc482de43641fc6328159debb6580b66cfe0530706eca5638183993da014d77b8323371364e0b792fab97a67f893366def2c62045d4af1329cc0fb9ebaaa3cb2ea88ae4ef2172189d1b91dac248fabdc2639a06defa7a116bde302df1052b3a78b6f7c39a625ef908ae9aece200f04cff04515978b667b9fb296896f83dc895d3c87af79f08f524c7af01f264661a31e50e9777948d944f5626d0c5e67fcb77087d4251e42ab73110411368900751b5b2028a169b8413dc90609cbf3515c362a8b55ce187bf7c7177970091d6ee3fc57d807ccee21e76817c069a916f00c85b8099e96651949fac819a4cbba06ba9444edc6a751660595e3eb848759172d4395981ab43d0844aa6ba993567370cab3d3e9823be2c0a33ff8ba62acf0683d1d4df85ac6e4a6f430c051d270409552f7cb5c1782ade8bb2d37a0279b8e0d5f4eb72ebb0e9efae38d34ef8fda181284a332e3e4d964f4eb204e0a011812a26f5a7b452833401dafd7c0a7d531735276795da88a8a77069e7c5a75fb132000a6461203ce746f1a97a991f94b0a00a2b80aa0e2de1ceae58b15589bf3523507d72af285b5c3538895d202404e45c6994626ae9874ce2dd582827168d2c4c78e623fecbed6ad598b6e6c4495865aa282333851ae80a885c1f66470efcffb3f5cb7253e89d464b87abdb9edfed12f48a8c6e956b841e66df1bc58f9ce97ddba53e947bdd7ad9adf14313958dd8340a5779033afcbfba073a7969fd593a46413d874ef6ab683016475d23f7365e277c63ce6604512fb5cad5a8e51a422d5bf27342ed803f7f3a232355a47d4ef67b15ca2aa90080d2a0b72bbf2f1bb6922485b4d3e3e230c947eae6c966d13e44b9d64e9a342d535eb6eb088eac7509fe5d94bf242ba6694e0d4ae8fc98558cdb96b906130ebac797c44d8bc37abe777248b63e8f456fb995e2a9209c5a5eab53265ff9be2a3b3e24963dfb2503cfc8b7c14c3d801f87093702de20eda03451dfb265901efafa092d6bee1d1e9415a926d1e14adedad666ff40b46ba076a02da8ab8b00ecf3b3d1357629c97a068023966accf781f582fe91e153778aa1494974eca2988462ba34a815d13bf47871047dbf80f16dd3b96c29a1df4d66f1f6ac67dc75827ff3835d4b5750885f7a41c4b1197cc5f73827fcb348cfdae44de4255d9889686c36daf8098921b0c6ca87e2b70c9e6084110283b0a371c7ea56756c3b790d829e5ccf8b6856a4a6cf545e0fb2a462838e73171fdc1477cff99221aa9f9de9247d7a239acc208c618c3f314b1c67fdd7d081a5af2ef4550a6e7a67362930f48706b16c36eb7754bf7ca6dd176fc11093715ef53d00e2456d1327e701697a36d13898a9df8a91b5d1b1dae9f833502efce819c21a595abc989db877910d9786813815b0f6b0fd5ab3cede94780c8945f74c21226ce5ad524c789e963327843305afee936ffbba6549d7549f1ea55ad02a79c4b2206eb6777ef9abee2dd342eb747caeca2e3fef7d6c1624fdbc0bd05bd0d512765b05ba756036b33039539702dfe4aa21a6f9072d0a5916769064cc29da7b6b299399ffbe26f58ed94b2e350b7d4bd419b6cee5073873d25a9bb29ac3f8058d7a61d7f9370d876c31c1e950ba371cc0a090924b76a386491314bcbb0e0b32db258f3f161c56d677777dd3e3b2cfbd818bc0e29850772d6cce7bda09c6cacdaadb3fd53626e6ab117bb23981bcde250bdfe858de277e9400245c5730c729f873ad7f9456bc64e9b807ff70998994ce08ea6d8b6b2020b73ce02638c92ac8f85e83d249041e75ad4da1bbde952a732ef009aa82e9fdabfff57a8fc578c8716c34fcca45d8f4c3d4ac68bfe24a907130303a8075e1c86a4eda1ff3c0af2e5e57a9ad0aa24bf1f2c306af69b4d388eddebd952deaaa6255d42eb079cdb946773be03fcaeb7ef567ac263285fbfcdab5ecf05ef4eb5e65c88403617b22c9b2163ba3bf95f152f27a7692b542d4d3b8c627da0f304206b3f596fed8c43584125516c50a1e0bc600b99db74e4cc12c23c2ad7cbd2e50e74343c7dfcbb509dd22d83409019f71875f31247ebb9f1273d437932ceabd7ce5bd22d59a769df9d356957560e6fc11a86eb2b9c38f9d36e5b2f4489d143610047cfca290e99c412814d9db6d01faf66184365bd93d6598eed24f0e5cf1ad6dd71f41f963d35be65908d791620b76ef5b96d84ac7467760d6ccd1665a327c57157b0837dff25cbc05077140beb5b6fbd3235499d79f54dd94020f502d833767e873abcbdbbf6e9d46b901e5f8e10174218adf6cb9936f88244ed1e7810f561ae630961b2cae6ec64644894b8cf199db17a39a6cba725cb429dd0caacee62cc4d8727a79f185d4d8c7cb5697efd988aadcdd43d336bdd10cbb4418eda936fa33d3b98aa3abbb2fe0e0c5fe06b5deb881f35c335ea633c817218c8da318cb36e4ac27037699ac51354113f8e9f1dfafaba8b878783eaf32ad723eb271547c284dc2d7a7f8feac5955c6aafc723d48c93e44ae8cef3c5b05fa96f7262d29616904aaeaef529dd1c3f49975eae25da2fff47f71262e79e9243bc3bceb1a9b1e17733afd931e9ac496a75dfbcbd149c3331b6c6ac467a73dd200d472f18e88d8ef1c887f9ab63a8ac1ac62acc5d62c314e443d188d756e5439f0017f3c32570c7b80bfa4d2ef00ed45e599a87bfa0a41a3102ac1a29cde0a77f977848261b96e58cf73da6a3bc796f33dca7a9d7be78b79f33428a563becf94e6f667795c9ecf1213ea15bcf40ab7610ef8e21ca068fef671fc618ea0c19b852d435519c058a5cdfaa2464268b9b441b061c589454e8fb9dedc283786d2416187e5604c79dabb65f5a1ebc0482163d4559169d1d788d6857222ab08b077e88d0063f615100e68288ebf7baddbe700cf3d8b317813dfd0ac8b96a266617b28e569d425821f89b2fbf9de55bfed74116e460b7a8b38dc420c1581b7f247efe816705c4213eb937c14d806261019afd18bb249860ef017dc038e345c954df31464ae3a5d44b84e4e0226a78924b26e756e725e4fb1d0c1e3e3e030d9efcfbd601c01257c58ff53f5fa4d502fa2221196371a151a811b7ebf44b32443f209e0a0dea42065873fc6428d75a2482221d69032f0a4edfaa62c0adfa5eebd41d1e879cbcb73c44e70dee847964e17bb0d39bc4f4b50f21d9e1e3e41fd1c3c896800a5112cf1db610364f616bf0b8bd86c88894e9c917cfa8478ae92f895df12aa98119acd293f16af0cdd0a8e65d6d2d755deca491d3a007297466d0a9dca6ae34f3f6f38e780ad3e8c91dc805abc9988d03fc97ea4fe1a5f47fd6a8a9512be5fccbe636b61d625ac8b7427ddb52a75129b2a9c507dc60b862e9bc89e74070ed3a7a7649206380575d7338ca58b454e079aae94e972cfdcb7155b5ded5f07f02dc1cb2d0603d940fc925c74b8c827272eda2b9bea837ae64d726ee892783bb10d6a42bc361abfa13b49d55a92ece79f1240b1dc436bca1b9f2f626d1bdfbc18424d84334d7c5b5eb22fcfba4a21496f25c52f38d8571ed039f550d842dc5cfa3dddd845c453c9d75f1efd1d21b704b88fd34190b816b641a34fdf3990bf9b473bb65fd2ab0811f3e718de3969b205b0f8cf324c3b69ccd048a7c7ab874ac38ee3f0e8a708310c7bf3f6ade3a151d4fffc3d5a268308279ce99067efb699f227a4eaecb972319a48c6e06b9d7cb9f1cd36b9e00b2ca8e1889d417c9661828eb24e6d46a0b64eef496a0672ede247092568194766f2356e6fd18a4979b1ecc33a9d8710bd794bd12be7df8462a58fb00a6ff2b65e3d84ef33801279088eedb1f7b81eff2f351b78169f93b202ae57757ef79150b2ee13906fd6c64469b7445b5f32f6f9b1ec70a366550cd20f75628acf341b5085d08cbbe0bb55e4ae1f5d2818edf390cbb3a62fc2620a89716d6608eaa328d49b3dd90de699ca4db6a95893c42ac133bd06495bf861b0494e20fcc9b545434790db1dd0d0f9f94222779a9775c3b72f25d41a5464b95f3891d54e9c0957c756dd60176c08a328ca0c1e14f81289cebdcd7fcc79ede40efa681900def308e56d65c2389e02ddba00f87b8ab8c78822ea72e80866cc0a08d3178b0949a11dba46223ca3e22cfc1280fbb0d5a3148acf8df9d03c303c7fa1f1e97f301435f22491434e1113e8956b9254d53a4a05ab7491a7e96444bf8bf9075bdc8186d60448db50b2ae4bc66d4c024bbd9014650402032a83c264172430608ae79201e94f43e50ac642e6b78e29f1be3921779e30af5024b310425d5f4f2b18429131b4f3ccf4efd836342a62a3dbdab3a3064d9830e276dfd7e2a0dd3e40a673a0a719d45c601b70ae90421e9185924c1495433a6f241cb668ee3379c20eca87e79497ae5bdeb550362c4af6645d0a85505e10c9166523216f3ac8e44f583a2db5dfadbd2109914a1c8ad3c66fce2baf0c8006353617172f1b5a92c477e48726a8938edccd8fe4a6fa7e35642d61dd4046d05176c15ebd4a3a2b600485d33f44a6aad62b1c1d5fe80da3ed9748f5ef67c5d74dddbd4fab938a2b7d6f18ab11c2891c10b48f39c429b02df674ce8709e9c3a7610f674fd20a2a78515d1cd9d6723351ac423658630b38fdc82d12890d2fb8c944df6efc1d8a437c4ba51caf77c74fe824c66430de602684f9d9f77da20522e74e783adec65ff5393758702ff51780738e1fb7d0a6466dd6690d5f7f3cd1e9cb5de7a46a0f5ca35e0f82362529010277b9198ca2f9ed987e63611bd9c66fd4469ac55ec88089d986090912bbd9b4b89d37b6996f4ca2f109334f6ceeb8c39bc6e0469046028c3289a2a784b2a2182c711b8125431f6735b9b00f276355e925198d8463fbd54eb237f66e3c9d66a8b127c41d6b6f24c68a049c0cc69980bedaba5c2e08a2d5dae77fe611f3f9956cabb71d5e9125d97344f8e49a1471db76ce21fae9345a4608ca429f1e9966f45e7ce770c5c08a60f1c655800467419a49b6e499bd3c415667f92398ec28513fa389f65159426c32debbbf37ede6239a59f719e6c407f83ceffb27780f02779b58f79a2aa19c91c61f227a3278b9dcdedf6c010b2d5ff3c62a1a9def647d11b8b6f9d6287191eb27d2693c6174c8420d27557f509756cb62640dd87d94f354cc39bbcfeda41eb54360451dc5f6f9b0506ac744217e825366a8a3c3073b351a3616bed27e248cc04f7896ae7cc17ed205b9009cc78139a4a023a6744abdaa6e01505ceb8bdc29f58ac7d8168c995af7c343c1038ee06c53464b538fa59158f74ec94ca1652234f020961c9f213d6e2cdcbaa076389c91cebcb44e7bbbdb2b18a0df88c1be7a79d55d17922f1cf042720cf1e1d937560f1547832eb002169fe3447e5b0418b8ee790f6b91c544039cec4c7f4ae5d3adfe51d86233049ff41700f60783d7fea7a2ef6aa7db4c412180c08b36c9027449295deff83bdb04bdf8d06289bb0c69ea800ff0dd06495bd60a6006ae4c77031946027d58bffb3c612b59bb52b5b8bd7206ba01f917742c1dc5aeabe4a2bed8242782a2027f651f8722b0a0e33d5b692fbf2b1ce7b291da0ebfa01e17f8c2a944fa8a8833febf5420c883a025c8c7ca3cb474d524485fbc3cf3c61bd2349ecd32052ad87f3129d92692da01553dc2769c1040a69a1f1a47178e0cadd24635b3aad96f9c9ec9a61557f6bd6b86d4e9bfa32034dcead19b0997fd39163863981d8adfabe7edb0cf5f046ccc9a31fcd47f177008aa8946d254997f34249479ea78691bf02783d0b09b96944c63ece14e11868ec6bdfb39027909369c79898152e5102cea17846741b24d00814335bfbf3e331daf99b33cfa8cbad63b5c9110feb9858e2fd7dc8414b66ff710c8791c610d657ab799997f15bd94d72e60723258a4567f5567af22638a8cc17dced1894b10fbb6c14799c29d8ca1392ee3b1e337b19447b28425d8dc515bf0472f39e6d97a9701f86080de74e745e8af971dae9c080a679dcd51a788d187979a58e164c3d5ad8dcfd274e5616e79d9bf6dc5ac95d1074830dfa70f71812cf154d6682ace9241e74d0539d93d77e25220d258a30aaa0621b9a0266af4298a48955001fc6a720fb76f76a1bb91ee29aff8ab29736dac7b102305deb5bedaf384dc95b199aa9c5000c71a11c269b30df4d6371dd4a4f2dd1dc9f82cebe69bc350dc8a8437b83160eab37ce22150d616957c22ee93278d9861e1df75470eabc7e01813d5043a623c126e70c5dc4408a1542a1566a5a9bb9be574affd20cd5377ae1ca042843dc89986a3bcc173ae8f0c0a1f15b71362386788827f3798ed78835452bfb528add3a2e979e036b4961c93327c44eb46b0ceaa5e69d475e86ae98c3040b51d72bfcb7c4b819bed40ad58bf4ca3e00e51b8984b9a2100de4bfde28af78eceb72a3a22649781abc6a8720ea9cd8ee542dc4faa0e1e2d36551aae242566fb9b4fd6d94475bba7f9c8d9eaaa7ce661c4727d62a09b01c448765ecbaed20aff6d505032cbe123b435fd04bf8278cf6552fa934c5fc7a51c78b129690cf84205257d3874097026196d054c939ff20df6d5489fed8a0df0873f66a70d8b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
