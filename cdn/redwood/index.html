<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a4c40bbe9a5f734727bd50929ad02d77a0ee08b3573df1d3ef856f85d02f7a4a96379dc8f52fef69b7c7eea270886ba4cf08255de86e452a9fd55519e6d8a58917e789d83d6638f0a54b4fe1273ad3bbae13fb91761724cc45bbbce304d5042ad13714525b4e4a2eaee74acd64e204ad1405c028fcebe6f87c4f8f44f2fcbf287c6535867b2e72970e3e33de20359c2408f4e9c2261ddeecbc78ba2391d1d6fe138efd351f12508a01f2b7b235e5a311b23e382a3962cce6cd750e6f25e0c97e841e4577edeaf8a611e09f05790947e4cc871a1e46503c5de164043ea7c8f3480128a5f0d47bfe86c98ae2bb8d246454af1ec0329c20d19a4d9ae3ea7a268e0fc32627741c8977c4b9dc7f704e75b36c7b6dcfc863f96e5c38b068f2e580356aba748438c5c2a3918c7658d7efe894f13a072bc83054954033b23c810ca20929ec77ec5705e8d8b84bb6d33e07b801d56446576e0038b2564dd49d325d9ecd8f94c3a86b68f7dd8d5fef88d528dc602224702abae47b59e676f7d001d6304772fff8a4c2cb1fa391e9a9a8e8dc42f900008581863a7065bec11817d3ce852c157cdaf5b1c18e58ddce3c04f9cfd199ea3094f030ed29f06b06003e9625e718c7c93c93abe46b73d5c80b00ab0c14381e47f91ba2a33d2ac6bd10a3866977573578c80453158091f3c302041131e7c116693a37751bb7cf22cbec02cdb747619ff07cb85dd3b52b9e7927d2796ecdec5a4e62a3399fb652bb2133c2d40f221ab61bcc602ca6daa4baf470ad198e64541294db9a3e09e7fedc0d70425dd6b2dbd32aae818205df2738b506958df2e304c00e828009abb3879ab30d2ecc713fb27d46d49c74b68d5627d16c830b40afab4f2654fb749ad344be5d4d81ec2f3ee24835d99d5213f27d6cecbdbf549392bdf2372a69dc97c0ea37c744cdd1defd9bc8edb5aaae177640e3ef730d73e25b7e0e275c3736d54ee9e810413756d5bb7be050c673057155ed2a403f941fda441b4f8d0b1457fc3568444cbdbe3749f3a47eddeca095399493c766c3fd85f8f626e60c63593b29155c6169ea48caabe1846eaf729e4231d9ddb2e3eba6c677712321fa9f9feaf022b91e8497c44148bc9c83a0b16efc24a57094c46d8f6a6494f64fdb79e2f001a295ea029bbaff6b1fc590d2ec81a5488bd1bfbf568be6079de5f31b153bd17fafcaa3f585a71b7d73ed04014ce5e630b3eaff8fa466af9163be8c0f72360e274eae8abd6fe56db393063b4dc21bdf887914fa913f3600484222697a8a804590880f679297923d66435aa3c9bbeec95085a59d7b9a81be732493aefc045637410da3af9498ac24ae363eeb3764ca0c01e1bd9c6a22a969eea5df4b33d0aaac57d8f72b2a0edd9b8b5dbeefdc22552a7295f942d69528d347f8d4b3b2cff2adbf81f1a05f71c7346631ce83f7f07cd306477a7978a11d4cb07a8a2588c844773d90d19ca9af6d323d62a963362c9179f618741b04cbd0624f83351083d9fe2cebbe5a02120fe630acae9205e7080b6ccc75f83152d9ebfad3613f252787c6ea69e21ea52589809f91d3e6dbfc75540a9f8fb1cdcd4c10d0178954ff621b09978032c36c599e21f5d91b39f1c3178569bf8c811f779fd84c8a534d0b18a90c590fe82b23fc9e8d1eb75d2f753bc5ed4ed989325242092b866e7fe4c29e305f99bbbb3c0e38202ca8f92989eae275e670a76d62b26a14964720bc4fbf61da017ad2cac23fc1c20c20605185bff4ec769f176ab325dbe31ceb609c998a5d16dace18e8fa5dd35aa2a6e6cb1679c0d951bd9ce3b162982a53f1746087850d909b31fe08d50ecc528b3a204b34bab27709edd8eded198c0cd3319a04422f93e861c5d2ac6c64d39bb84e4943f3f9f7097f9207f93dce2cdb5dd95be6c2764a2d768b5b295730dbcd27ed9938342d54feb17018d88e49f2acfddb7f50cb2cf35286123f6d00372e4e8ec5357307a553add851dcff6ceb4dd862557943b42f91bbfe2447bb6411d3adcb265e0dc6257b4208e59c15f1e5013d47c1e3f7c58c0a4d738d8e163494e87d3240bb48db9c94eb8d4339c483587c6c0031c376576dc40679b24627d702478a05ac96f2ee500656621e8b2fc034f0d8737c36e0dc1404895ff228c628e8a0e202c58b9dbd90d2fdbc8e7b925c683f06870d00665dd7b2f249f38d520dda9025f9bd83dc94ed787358ac5746557746e7737dbb96bf6f30ea029f26e77a77687bc125391027314d348b570cb13c6173ef1d76e0288eb1e268180d60a00d2ec0a2a5961b3332eb380cd928d403919478d2e75e887b754b1c1f78fce661f0b0bbc0c947adf76508d1a722174bee8c85fa34429191bbfb784262291b14e5c6b4592258b398d270d59360eeb28ab1eac9faca1bca396f9d1a39f314ad2e6c27142f7d43cca4fea8814cea79d5f5e001d1da682408a374b3f022dc91ebfebb5c2220a42fb0aa46cb907045605db8b798f027f7a7b444d1e22c51b9392150d328bc521bfeb6e73994073ac3d90102029bffbb50a79e336844851e80aa9211a6cf31ca46ec8b9a49d80de5de7e7f6be4dc6adb5e28afa5cdd7ead23cc79186d38e280eaa496c44a662d420f12df1cdeb07d51e6466088bb505b440df3cb8ac77bae4539aac6d4fbe2b7c550ddf4135e046daca7e2b313d051891677b53185396d5cb39dabf6c21b9bd34aba7bd36b94eafb265053dc03f921ffc97158234fedcb22bce19ef086389000805c1d64c92ca4a3740d4e408f01385452ad3ebccad190534423139fcf402c9e59074e0904f6c64ca208ab278decb466289cc5a3df66f4491b5a9cf59451d2b8208b4a0ea79c79ea917f86f80a8795cc7ff0f12b3fbe031a4db1e8a6efc090bd933a30d962f0802e30e57bd0933a1164d566d237e211502ae2ae6877a4a002950b8118853446f6ca46a8a642f02406e95be0bdf35af216bfd3265bf0a544bc9f7d93a7acb1921fd108268c135484cacfd0edd32134dd7561b2ed28a0839ed2eecc53aa2c10faefca8e6f57a1540fa2b277386203ef0c6f22386f08b7b8876958b697f2e3317dcbc6afdc005765880fc065f24fd381e0826f1c2db3be402f704de67a0ff5616eae737b4557cf2bc35db49f0a8519478a9e6c98e0a97b3478ba80be5718c23e2f706ed051647173b172238b2428a33f53fb8606cd7d929432dc56aa4b6f534a82a88deef5b5b056c14e21e888342b5831eece528aa54aed1a770ad645926cf9b824a40b32f2c71811fdd9325a1e6877657f5d6b6ff269b218f3c4538d7d4830c017ff5267e46ad4e296c3bbc3a210b0ce34f9010fb77dd2d062a67c7b60a8391d3a8dedab196d487bb99e54b139da5c0646e14718d43b6dc069deaf2bcbac3a2540311f78bedad2f632b5da0e23d2851348861044adbe7e9e7e03b2b8532412b781405669fccfcb9f548572077397703df9ad230b701bbbb3cc1ab5a9fcc36dd0385f04f4aa5897f60851d1781aac2e746ba570f118e25461d90fe213db1cdd2a83e7016007ada60edcd44d66c7df5321179c86e86f630272bea93a5e64d5068c75ad243b38a1ca4d5d8f8cfa0e45e76d84c21d020c7bdc9b3c9e8a2fde8a12a55f17314f2253f654e158138897e009fb81ba0eb84cee3e1dd7781b4ea30b686ae1fe3ca7016889669657cedc26c3327da9cf82dcce23e0d610f0aa690141ad6b9875b2056e4ae95e07400f876524389fa375872ccd45e666f4fbb71cbefc4989eea636cb6713db86307f64a70b89dfb157ef57a72114f24309010f96a135f2371fdfab8030a99ec0b8ea2bbacd90dfd28ce793b1eda91e8f0497c41ca419d4f26b099d012faa6f278749052d09457e7ec7a3a29b0c1be3bbb669bc4a29a3853777cfe23991e9982fe66de47902e5616f94e86178fa8879c9b2933b121fc14497396d1bda1379399fd48bd9b55386d6d4bb4265077bc0f52df9bdb719bb8b06555ce8b3b7c5a083ccd4baf7918efeafcc13ca516af50e1342820213948b1255f0d9792dba97dbea2b0fbb9b4238d195ad89e5d96042728cd9e2fd43adbb52c459b4623c2889477e978ae11b2c0d4e929e2b8759cf286e9f5a36721d66b5138f4be1a183f312ea1dd1f093e06fe1619019189200b37744880fdf4b23a29661a50a7b979188179c7369f8cc8fb2e879cc53f628cd587475758be4c4d6852d23ef03395b52581f90d4bc81a4b6cd7ce4c4abd26b3b8175d92ad03f2f095a49841ec8294270ce1bf6263d21b6fdfb126f936aee4411bc8a4f671be7c721e1bf5a201e0b49db7d09731c5fa6dce1c048e954e4cedc78a10c0bfef54acf5b0186226f54a4d58066eddeb3515f8bdc82ec65fa1823b169030112bc26c956691e1ba8276a1a659c0dacddc484addc298bac0c718e1c37889a7d2f9a5d4b2ac1c926a893b066c663711796b7d941cab492647ec3e18f7238b24795fcf4a89ada46dc702449c9e6319b4ddf3882d76550da2165fbd0720fbbc21dab5905eb21e1ed348cf5c2b140dc137eae44156672b563a16e8fe48502f717caa50138ef95987b3e58b13e9391513a9abef829ad72530e9ba5b339ac9383dad72fa2eba1721263f762e46d276648077a8a59c0fc5d363326a03b307bcdce67a2d623c96e60a7ba62fd8272e1c2dac39bdeb7df03a971d511320411a4e66d62b2fc28ffc7e9c5d93b87538c388221709191a07700fd79d4119f91aaf7cdc3bb48a62b97da0c53c39d172604493ff8922ee73994ec401024103d3cf71e8e44d3d8317b018bad4c8e530ef9201cc5d5d2bf98e32319b511b56e0826044998255211b613fa112a72c497cf24141dc8ded820890fb80b95077466f42d5c5bd4e4524f247abde9508c48e895ee09b266458d1a5f238ef46d54d52e774b4c73ea583b3379d1127f84eddcc95ff34ec9ca4bdc5b13685602137df7a8a3c934673d77fe08fb83871f692c03023b6315121167bf55f4b2c5c9777686e3302d26254d06f960f07014d4e477371cbd2536445a8c40288e3262c707c45d87d1c35f69d859fc086ac134c36a2c2516a775c65a97d2375bf0fbb1ebd717ae7b466624c0a2e0716b94b00702d57d14814714117d187eb672232e586e48492894f49ca1d7574dd6887e2f5e6f6f6a763f6d935c5ed8bff774fd7f00280d2be9a6ed5d6ed20e908e0e748205b8d270569809a35436238c212d8f41f408ef6b49f9a9ba886cc559804add74141f022b7c560166a86f46ffdea6d861f9fa0f79572ac2b30070d576060de3892c0db4a3bc808e1d3803a10c693404730165fe820e7e36bdf3c1e7e37660f22e75987d607994cb903a09e55bbb056cbb64d4b4deda3a616ccef679eb3d53ebaa6fe0044bbc2f46c3c6ab0510ed80f35ca3559d338f0d2fd8f92151c2fe98e9d989f6e244f3cca9b68615726ba2ef6fabd77ec36a07cf9748c2c5e1915f1c0158ae98039b2638e55c59eddf4a9fa59d9ab3901029cc5c73ae6f9363dcf7ab1fa45d65f6397b55040d410b60518ef43ff8a019a1bcf423ca289d5074c786d975100f5a7b1275f2281a13db94946c629af36c16bd0ec749adfd402871ec76c558fe4700de41f6842ebd6be59a1a955dece2a7e63096652bcc9c02c471a320f288b7431d59f380415d47fad7befac900f5f03316f8a7a506f042e673236022768db870e0ccd825421d79896452e968356a8c540e3aa3eeccc46c05ed9c4fe18d6200e3cd5062da863c2420f56f0c4857712177b3b7cf462b0a9c8b81fd8a7e3626b00d5aeb9d065c94ace0f7f426bdf3c371c2c072682fc0e9625c43311eb70d33c86b3a196a1292c7536ba1b58a76c9f9da6316812670360ff97d278be4a971fb541b57d123f9cb8fa801818bfd57641d3ec54c6769c0e2c758f85ab3059c26292101f6ff2b816f21fad1835294bee5cba420d54a9d8b359f94f2ba0e4e8012bf3cb072096153f7491e9ba6cc6fe9161d776b297dfb7aa46e09c8eb93742380e05d4f5afc9e2a9a954a58174083cd3ffde2c793af665fd175f95a0bd442acb6744723c9c6af4cb7ce26c32c828afa9043e8bbdcf7d84f58e75199a9d2cc8a6169fe9c66a1285347bc5459e6d41915bab44f7835e749b26ec33f48a8589bad5576ca6fa2b6da7afdff72f07df3eba5ddf48726a074ad767e6887a2eb2f11a8b9c5fd9b911530d2d19b03842957a49b69ed140c48b51291cf9c64fbbbf64d6f2969b889f779db02e62eb6ee274da05afc546192b56c8747262070fe2c782f054450431c942b32ee9aaafcbbf9738def90252155c58a898f1f0dbc7d80e66429968c35162f69b733f42a2c7af5dc2652b741db4531b98794f7353a0c5879ff27c200e4d137444c6c98c89ccdcdf34fc0cf48001ab5ddc4884e0c94fa232cf5bb608bfcc0e208903453500c613a0453315baf96d575d11348bb4222f035cb54f0980aaac495fff8b11d98ad2943e131dafa09de4ffa60668e2f55aa5fc3eeb88d6e791bf22a346a99527a311bed3fa0313e49eadf1632900620ad325b089573aaf057e54c4e55f50957a2ad889539ddec7cfc3283c551c00950aa711712cec8a38d8bbe31d03cd3cea5e73b3b04df97f7cf9b4b3febe846f8c145cc89b3603ab70c332567f020521d7bc0b1c01bc7476144186ce738717e04d74a99354b4ed4a82013ea2f2cb2ceaa31ff18ddc928f746d260aafe4a9ed34a86fca9ef27dec4a3552a09eb025d746709535580516dc5226e2f856ad76a7618f33c919088e8351f86b198c399ce0766114e1fb542d6e8b35ec70bdca108061ba9553a99f41a58cd030e10a4e06b699593ff53d5a9348660e68fa7ce6ab04a9eda0ebe35c4d663db234b3dcb23bd5fae3ca30c83842c20c3ce430bb4ab2c50bab898602b69d939f22ba7bd363e26fe0c5b4e8312ad0aa2ed7e12368dd4e34c22239feded82a927f05db0dbbf4affd896bc98ba0f79d588bd3e1ea2c2e566ae9b173400bd3b209a3c2e46f3d3f19350a9865d617e916bc9d456ec4173ffe83016ade57b3e9a4e9fed14e4e3f6460e8cc9e6692d28af22700ac8954cbe652c9d7e00529efa564d2ed46349fb9241e0a3a7a2a7766b6cb311d4bff191a37f262afebf50a2db2b153aaa7709967cae0504b2d1d1b39d07b917e11b1f9c5bc97a6502755c6c930d4d62f69c7dd115a5589695b12d4442b8b1430cc6cb360bc9aa75b5e07f60075d53387abf6b7c26ba0321e5a025b44682ac789c0af378c37219dc7228fa106fc80595d3e8261a2e496800f0ba29ab68e16d40f5b0f82b520210a0f6dd5d84519bf3c0a5ce1c5bc75e94d1808a5f8bb35951e53488058d08840e9e6f92f51c0919bf752cb52cea5ba8de05737ad409cb656f137411f86b0a0c4429a2c6d51f610ceeb547b49177ef05b9b6d1121fbaefa373774d2f04b41cee512f294c1a3b840f910d3304cfb80ac53da77fd0bb00168a2dbb814f2f091cce70a4bc3fbd988a5123b3c5d68946bd97366974c3686c0767032af540926e70e88ec440a98945e2a6778eb8855887c9713c985e9c1f20d7f95c95dfd6a082ba5f452528622f63c73c3bbc2dc578e08110c9acfebd7a1f9217ba738509d1d8d12bcdabde70516cddad1258c7c327f592f025540c2e9b061a170b35e2d5bf62334f944e5140cd1e0a2972a78977608a3659d9876a8a4938a44cd2464ba98cd52b3a59135386fc43e4152b6057d918aac22c08d471ae22091286a8661cac97d1368c04bd926a5c667cf016bafe186ae35e0071af963dcaa2eccced99f7e97b92f42c733252e48f50a140d080334b8525ec5a50414bffd669e58904ba03fa5a9a3c7264b75518d6739e8b9aab9ea3ef1bde634d0725fe201c4e77214fda938e2bee570ce9023448db13d143c5b951be837968baf4f87c8769d538dd168fa034413b556af5fffe1c4e9621758fb73828d34d335d4922cc0911ab072a6699ae93105a12e4384e990d15104e06cdbb2bcd9bb95345a7cd7c6471bd785915d4e57167dda9ffdddc12cbf20d95e75545555ca8c989a4cde759265e8c98e064f7420180532da45e5b0136c1931de187dfddaeed430ffede6237b87026f75c4d8ceadd2cdb6f9c63d87a576acc12ba13508a25ceabf00d5c203412d5a6e6108fc36fe194ac0da6ee460c54ff14db311b890c6d0668afc1b51dba657f4932b8b1b094c1ac8af24390426e37d48c0fbb25a8a7924120c30e1aa5cd76b43dc169675f76827394e8f0abeb7ab6f9a2942447a3aebfc54ef0e5c9a778e4de3e535ca9e87cb56ab3b0054a0b51325dbda0aef8d1ed37da141721fbecc4b4259c32dd19fab915bda6fe5ec9a5d3499848a8c8c43ea1539539a0c22dc80269bc78a01ec5bf68c9813bc42bff435c1f14072643a09ecf28d6d2af6a7e608773eae7ca471fc3cca0dcf4026110952d482af0b496ac02d8f034c0ac2095d3f2992864e3f22b6ab65e9f41e194a544656a76c4de9a15ee8a4bc1b77f9c53a77609a1e5679e352800088cbc81437c1e7282fff2e0d76f9d543b5028ab9dd7203112c8f28ca493819fb9e62d9f18b5eedde940b52ced5247801e273718189211aa8c55bac84273ca188015a820c9a741c4b054009ae184523b89d83012d7c1c205ca18a36afde5af9568879480d9b2233310b02ed3f78283c24cc4fedaf107fa0865169f1476f81589bab2cb0d1ade336f4b775d9e3333af94b1f0155add9a6eebe3bd958288e3f54190125a2893410dd4c8c15259b82f375df6c469a6c5bd7b9e3e4e8c30047d6cc345eaf00cdebf6eaa04fe8fc9e952ff3c54a0fc4dc1cd2db09df00948c4480c3a72c4eef2082118e7e131936792848033e585249a0774b934376e37e4a95b02d171258af712e790ea2f62dcdb284cd9f82bfbea2ff0c12162f157a8764a0ba65ebd66dd89a55ed3c8ed60ca99c4570e0751e41fe48374cf8f5948abe697574e5113e7f2bca74214ebc4758c0131fda8b1e665161a2d07cbe2ca520b3c30909ccf0af0b43d76b1aa108cc061b98babc45bd3e9eea28ff4c1f3c52032bd910ca6265bc7f6f0c1f0d04e0217e959652399f9eda6e99a065ea153acfe3d1132fe1069210cf7aa73960bd3012c6e6a55ac8cafea549f04ae6752a631a97ab649015475554beae8f75a01c407b14dd3325459312fd2484fd52d4ca99706bfed90a43f60008e2dc9edacaa194de3847b8cda78ddcb9cc1076519808ead54efeafcc838600deef3e6eb002197213756cca3420032d889de8fc806ea478985d76a15bd5d65e45da11541ce92586a9faf8825995f19cb4b0938355a621864893efd2127ba3bf6dd86bc13be1b930fe0c773bb5cc8bbf0a9d9c8f2cc79dfcde4aa07ea753c4a369315150d53a274d4c7d9ea44509dcf9770be181450bc449273dac636266635d52c0d4bdc4027c3267caff748433b3e35c735645344190a112dc8cf8a0fba43ddb6e2138a6ea54ddeeb69674e18dcb9d0fbf7c1660b9488d9534b31b3a2d562552aa8e95840a4b745f345c034188ccdb6c920b7dc8a32eae251bf4560127652a63fd479dabcdd65a7a9e139a8537d026f1c0ea269afc25bc39a52b9eef7f4016bb7ea44cd54afe5f42057478b04a71935c54888afd3b93ea7e15aecbe2b973e348607f9b17fdf2e14fd7701ccfb054ac45f78a4f6dadbaea4a35ee1168e6ad121e2f584209920293ad01fb5f21bc45f3d5858ed245d1a431bc4f8c768bb0be678569a5bd85fcdf4920abb4e4b4a2c69b1e2b15e5013538ea2db1b1261d5b38db784067bdc3467ed93b1c085a016c835009daee2ca530865a820867dda1fdd9621d658c84e15f1d82a3e07a56aed64244f47e700a27b5bb879b71e35f11a6d324f7706e8a4419972a0b7abba6c0f279c4842daf851032e7f492020fdde78090e57f2cffbbaf3322c9ac30487a09242e08d5ea6d08b3e2fa0ad6cc2a37c294c073fb894331d2e5832af65f4c6f7fb910995280c3e7207026bf80740b990134812ba9b842f5b894d597d047902472e00e212c7614d0bc79a46ea24d5799ec00129ce2b3011624f2d4aa70d0b1f435e5aa242eb49637db404fff690b2c0e06629ec77e86bd62d92c06c745aff15afa1cbd00a971182c0d9e4bf352830c4c0099fb113d9e6df73571a959fd6da9d69c77a00dc7548c04687f6c8916b7e4a44c8b42da36bea26b6054812d70eaea4a9fde64a73df24a6770957761ff80fa6acd78cd20ad3a6aca7c04d8b36b117a64d2f12f15b39453a90553f42465fcdf23f5ef755486f6aa2042843a5f76a85bae625987975b2b07ef26c8e17ce7a2da53ed2619c5c01b145a9fb7084d52bf8f26ce261612e42ec75327042987b63d36db3907d63d07514005bf823778c6d5c4628c2c76b041d13766ecaf719f715c3403c9869c5ee3abeaa8c1112274bb541bb24ddf8b5d3c88ef623054c57f18a2aca202652214137313217e8992d422aa14fc5c24ee7da47223966f49a501357dc0b1725e190864cc24bc54f95cafa223fe76a6f4a24a5dc73e5691ef273cdf41c3d2275445df35662664060cab1e60d9f709b4ef4d012a974960d9a690e4aba321dac885216ae2031698499cf8bffb2d1aed02526a25a54e1fb22a7ea0bf0d06b42e4cb14c60a4f377afdd617caee6923af3ec2627a44d693fb0310fdd663fa416252e157757404b29a31f3ab164f379304130f81518d826e814707465b4169472eeb5852b4d901b14867355641baa4490901c5fd4d3fa9d64c58a08475002532ce9bff30ee1cdfa99b027ca6eeebebbb23911d43c9033eaf1988a058818ba136c7e63c76e276a40b6b5d36113b5fccfc33cd2907ee4ff65647f4e778e1cf2d29844bf500a8c5948a3374921573a3c3b9dfad870353fc61d4db25dfe73d8ad71a38db8e96eb522129c1c7d5554c4227eb424352ceb529dedd142ec5ba6437f35416af1d1cf9d9e6f201892bf006307687339b98b9d3024db0c36a903a6b4e39ea2478cea6bee3699937942b0e32abd231d79a615e207fb60f33327a4eb6cad47b90b8a1b0ef8df33d08c9c55f30f845b2c6a02a835c84f7cc9f13ffe53a647fa506dd9edcd9942787faf343108f9d8abff17f45a2a63e6e0ba8eb583d613efaad20c36fc82eac7383b63c05afc87640964d76c658fa10c63e982c13f5976fdb36de2049e6c4e0d74ce198676ff0da92e3f15c5a62daac440075b6ed283520c7014423449da01b6acbcabd3e1a085723cfe13f3c7e592331f12dc1fb693c7b7b2e228a163b31795b78b0df3c4bb6ce67ebd503dfd1941f2140a61b216b4ffc3754280dfdd6ace629899989828833c13b5da95aba46164f0bab3dba44d396da1ab9eb377e65b8e43e2d553de4956cb1335c095259fec058c3dc7e19ade0b7ba577e7cf08b4e297cd3f3e75236186e58eefcd52f810eefe24c1e55af2cafda83ff143c55787c4591f0097accb69f36602c4872b5b8c7dd157273abc684000b483372764be72ec38539932326bfcb6430889cce1bc64c454a07d90aed3574e924380481512b15e333066330bc4ade344c1d9a819b9662511a9bd2ede1caccfcfccdeb49177346c7b3e521faeada32f820fbc94863912041eaa493533b157856259fb1e5ea004b0ec88d2c0350fc1325440243d4128c04cff286d1a2b73ac902087a7979129f56781febe29983e08c6a9a9dc143b3a9784bae4c8999bd14c3015778e9b55fed9d9ac55b53d0fab5bb97c7c03d677b015bbbc2be6e3eaf875530562722c4c2861b5363beb2409cb67de5c19e64993f8d217103f39d81d6ac86dad0db7ad0f85f0bc8ef5b473bb5c271ba1a5672a9cca120dfe3ed4b89987192e8eb32d5ba6ba10007e86636de7d37413b18ba7a6d0ae5c219cb96c1741721830ccc4b8e34cd67dea4018787c61a445d0bfe41268c7095667be6fbc36dea0c480c45b1a458535e25f8b506b73198395aaf29e2d6ef1f6bf61ddd45590648e7683b79281f49eb4b469001f553e8e2b8146aebeacb5686984304c5145a8c93aa0f4621a864cb4d245f1b0437d2d56cdab52d220052d2bdd1ad61e1a4829f9950030b6ccd240cfd7d6ffb32df59f980cbb6d6e0bce44543d8fcb96672696feed76b5677df018f7bc14e0d051b436d3726e66fa132baa94650e112c7f662da8eea7518f41c396ee5917f32626c818ae5334e6cd39b2a46a75734c75fdf8dc09e30f462938bbc653beab0ff4cf75b1c7cba57ec2097252466e83917ebe98e8983d2525933a41bccc8c4bb94c7083f571eb50d2c39d33dcb67948178074c6f79f30e2949901c2e14f66bacc7c66e5b847c4f354d138c469e28bdc4adf9c2737480786b8b6112ba1b89c076eea0b31124453ac8309086c308e9535773df688727d0a1977d9e0c3dc0ca90cc481e9afaa14ef4838bff65b49cb9945e789bdb78c0ebd11f2299e7b5032839c1d9ef6da6b8e992322da4667a774df0c4aef0c576af151dfb695003cde790c238c2eb8809ef08f4564e634bac1ea8fb3ec264af9962626e34a940c636779a861b4c006e7246e5dfb22815722f355ae3cf5d4c43c04699325b9b6e7155784cc030a6f3341bedd4bfdf7a0ae2304609948786afe2697a4f634136f2d7a8de1fcad8a3c49751fe86069ee96935c6030b66eca2db413e2a9666bd0fb2692073d6d292d3820be8b3c83b96b6ea99aa9c90c1a34c51e4acc8f20088990d3ac2ff5e9c495ba46c468e32c2074f244371ab5ac44788416ac9b67235ef504f9ff62df82023dae41ac71b1a4ed3ca555f7fe92d5e3d9fa6199eb376eced8b8dc5649681e944b63e5dcd48a4a16086dc48476a2d97233e2e5e7050817fae59afcde1fb3965eda385a1c0aeef3b7505f7b95e7cdd7cb21688b66b62dd264ae0505c5d7b906847e934478049359f55a55c9ea35deff3357e674777feec613779bbfd9d8b33a7d7f80edc1443181b3d0d16b90c3ab78f2a79dcc4205aba59daa4388b9f2c93d38fe6d61a50b2db336ab1397e884de487f53113f12ec7074ade01eda1fd99631b09aea8f8364804e702575d5adf619e70b5334eb2ca1fe27ea20d89a28709662a9b3f9f0351b8aebc422b071ea763cc948fb771a57388b17a06b40b6a2983e8e10eb11e25576326d5742417390ac3849a59c63fbaa5621da0721f1f383671defe55e29eb5c8e62842c6ff0e1b147f883f6974c7d15cb793b773e3de652ff130565fae9223f8566d828ca45ccf2793406b0ee280a44623967b2bbd4167496f7eeb3a2c062ad4071e434ff0a978525ee074423ef826fe98e97ce9151bb234c62498ca2993b569d7b7287a3a3f0c0340d8de37bc71cdf15b119704e4bcb0d99194b67c43e37d16bcd8395560fc3abbd4cc48d34182f236100ef71cb6deccc6934223f5d09c205f0dcf59d64f77930813ec15e4dfbd4619967f6ef26ebe56b48440571227e2e57e4c1167cae1656f318ea9319e924d4b61278465d7fc4416b8ff02e1cb4a2aa59008c5e7a028981e0fc197f4eea341cbf86df85a3263175e6a958e2cde81e81c53a9b5b90a404824e222ec3bd96f67a89dbc6a0a0d6dfcddaf4ffd0df1ba26d6d60cc5087523f6e528524c01db54983eaa3ddcd8d88842e022ecfba4ee9ccf063def4a7a6c290850c6afd4520475b0c602fb8b79fd41ba87a0d6700aa2c5859c6a219c86b8bebbc74b2a7e2903380f76020ee4ee7bbdb76db6ef4fab7db6ebfdfe98d035502af9a88ba673f1e990e8b236e1533713aeaaac54fa416f667f2971e6c0370f072c5fb94688eb7c49ece8fd4fb4901bbe5ab76449052f2c91ca4cbe8063412e7386847a562a4dca944c840a043305f532b250d66d56be0578fbbf0f60215002481e18cd2029cb349fabf2dc62de986c6285c7676ef069ebb506243411b0761e34e246eabb42601e2e3d8cbe5cd0b9adab90f1b0a687dcb52811963b898e51390a0a1ce14876abd662fa71086957327dbbaf747b718f201f5538561976e426c0ff3a057f420d7be21af3fb228924599ce0ceb00da7b89693700255ba7419eebb4a23fc73b13422deb9d95161c3c326383d5b324e90073cb152b5e4e33d7718541f78bf0078cb7c7e555784c5ad5c175d875b62c8131da1cc8f2c3ffa92975f6a012c4fc48c4d5e15ccfeef1925b56d0a0cca244709944beade47be45201d70eb630bbf89175e3a631213375f1d28fcb01a86f3a8355bc30ed8cddd5c3a10c4406af8ef93383d0531228027854c42fe5115d997ed73337d5371d23a1a5fe0bb4ba76c2223af44ad5798c858d3462bfb0f21bcd7546544f8f08090a0ee6589b4bc205727a4aee889ee6dd6cd348515d6207f3399c15251685007ebfd3c432ba13b44edffd5cd72dab00096c84e7cd520bb2502fe779f10391ddbd6f377f4b992e40a1a24750716b7ae2a4410d007a25ef2593a308fd61e0addcbbe7f61afc1a426ed0cc79947567c5be915c72fd583a649bec4a7d09e24ae73b1367f8e28564dfc7723dc5ac2bf201774b41f348df030dc9e38c2b16055a54655a64576bd9230474adc0e4e166d3beca96a0b31591e5082b078e808d69de5181db68133501887e7905a213d20d1fc41e307721208154bee258ad011d132cff6cf70a6a9588d0a0a0c9d93fafd986bb493ddb1a2597564c2ffafd4c34936c4be5d87496922a5e04b6f6356f94d3f9dc0262a83f66f1ffbbf9a1785c3855b6a3f06a9041da02dfc9e5cd688d42c654b2250418928d6c34f4ca76b9716ec2ecfe7c1a31223ceb8cf86bc6f7a150144f23c1ddaf65b9a0a6f27e8a25ad7073e6e344ff4b2f15f8eb19870f60fe0005e60572976f2d6c10a6ce96457a151efeccff6d42404e0e3907b4a57545a9f835479043d884138464536eb663b7d16b567df24e15cd7f3a3c2d6a8258ea8f0fc399acbe3ecdaca829f4674dccd7bcf890ab3c411b9c7aad65b6f8cf0bdb0bae31948777dd0b2dd5796313a46cbf2c7a5060414c0908fdb1f4f9f6bbcec2b96ea2cc500b251608cd2541310475237a5fb350f0ff4c06e85caada8a4b71e28094419f3ac4bf84f60333df0d11e09887dd5ca4dd0b9ccfbcad937d509ed5f54ea63433c8628798bee61e9c8dc86998fb6a568dd20b7347f8e479aa077ffa6406d0f8d4182b0ca68148f2b2b999b5efcc059033c58a0e6ea6e62fa2fa770cd9346aaf0d685ca2a5238663eb972d578817eaf1ab709f0f4e889bdb0c70fba9af5c3cfc085adaa7b770958bbf06cf5e35f68fa2ce800462287062aa79cf9f5b780a7716a325bf2347d79021fd9a052580e6486f708e33c26a497257f7b61b726900ecd946f26e1ccbe2f174fb5838f0182b2d1e3c34829a97a87f5c7aec1a56a9d8e8a6517f2d5bd6446fa79b2e430235a8cd322d996b4c2b95b59e038227214ae38569aca4ba3f0aba80b6bdb61015cb24caef1fa3938e060af5fbb5175d019a36a104f3b4bea249087e3f4cedc832639799b0754dc75a34ec72908480ac208051af4634395d75f6d2c1f19e98cdd6ef5293496b37c17299de0446fbcd24fd4614ad5fa36ad0537e9477389397854c83365bd5a283b2e28b2230dbb875c028a3f737463db43eb202517e44c8425bbde466ee09751af0510ed583f9b54789e21163f56602547326090f4a3332338d891bdeeb87d55317cebf281b36a33678ef8ecd8462eb2e82efc7855996755b51f49c5cc12c5dbd16e01ac506660e2468677eb57611eb1d4056a267e35920c881c313a6292ed1984fe4aea532258057b5e4ddcd6410654897116834ee9d8157f5014025c2240c350c5c938be7d063f08cff3a5b80c8b119a36f9d29aa97af655916df2a2be611b4cd0158b4fffeadfd0997b154d0fac4c5adc7ab975070453f18529e34ed30fcb4d6279595d5da2b8848f6a903f61558127ee85dc9a52f668eafcc4f068e514c80456463a843ada52a9aa05c1f0436d3fee632eba745734f69f27de3bd59a7c2eb010bd6d49f166b04a266700380bd7b706b7e2386422d36e528454857af89c704eba3b56d32980e7a19f20646cb355acb2b5d347eda42c679bd608c278c980e56a228897781d1222da181ec10503b20f4885fb0eb65b093010597328ed29274f03c2c64caa564e3e1daba10880f6d4ee1513d5ca70a6535f13704f6e164252cbc8c8347dd7b065f5f87837dc765a4dc3d17819f325879da6a2403b1a0a4a2720e5db2541503f7c80bd4fc98ee549bb1dc0424fd866c4f7b223c0c0cb6d6215aafa4c3cd850f31877960458d061e88f4881b321170a403ed13167f6b1baf620689ac2f3a946a31e92eaf8c078277e34ed0211b397a56d81fdc1a8b001296046d98bdfe7af3cfd081058a0d78d8613f20463893335a3f555fa3122893b7c158ab8dd25bfe5c5951b152ea6676333d4a96b32e3169448d5c9af328b3fb8f2bd25ba4679a3c2ebc78c907aa6b9fe3931f47ec047e6617af592c06e7bf3beedb42886f6f160867af57d0db9b756ea7b2330b7b552beff556798ce228f4096c9b0899a344b591d8a5de5dd1a5860c36943511a6be303cd045ff47a87f33d9504c9e5e9d7a8dff64a3dcc57af66af08c6edcec88f22cd650f72a09c317578a5d2fee59f10e94f65e89261be05b4c5dc760f95c2c79e5640ba92287ee56763359a16b5670dc11a11bb2c237bbe8f97094a47fa472ac8a2c081cfc4cf84cf3ac836db0f8aeeea3bc8f96d4cb2261f9f505aeb560f2a534a7cd222f44e182e4fedbc0db518d7ea2c8f44f7077c31b29772d6dad91ee5035cb372286b23cc9b3fffd6c7f05a19f33234872e47a8eec615d377a853d3b58f95767cfb94d41f2bd0f8bc7461b8681d1dad5a0302866dcc81964ff4a6d1c4c7eb9e21c648e68a62dc325397b65f96dabc9b5ed5daa861f80b4101862c5ab257e885d3dca259aafd80100a03c86ba364e6fcf29c3e73e08b9635202f35f6a4229c33f7ae1abf37f3f09c949af1089c50cc2819495e1da9ba886446e5f5445726cf5928847d213daeb810b87d662afce69c7533835451413c8a85e87442daeb7dc431e8ec2545698342d774a7918277d8df220041c4e61fa5680f322933a48240ece92942fbd3bc6d59743e4d7395a3464dd87d49e1715f754e1efa97332f97de5f5d28ef31ff33880c804449372c7cfdff910dcf724d6f7aa6bb78bc52fde3f5a9a7d04f63f942e0336f4fbaa0b28edf03db7120b916c5bc2fd1335346e157e4e8bee80e33c4605ae7c99227df74251cd549d989043966cf3ef28bc06823b895e10f8c0f47853e432033cda6feb5e5e61e022727f374fd2e076dab83dd1d5bccf94f1b96ab1011afe8239c64cc672fca86f43550bad3bff037675ca7d5e4deedba6ffc86dea4e642d8e493e2657e44cb1dcc74d62bbcbda08c1117061fcaf65b77650cbf49dab4368eab0642051242165777d50ac66636b8423be16a7e8abf113912968b94d3db57a7d389d4637c2dc4b8c149f26c9c96bb7d23a903b2f8f7f9931fb7e82087d174175c3eba458dbb64dd39ddbc5f9ed636c259f6bab32077d6e77c7e84f6598f93539452c5f64689326c79c118361c3bc0d5214aaea30ed9c6adc5aebac34d5713e0c8610e98bc34fe2f96fc13aa2e5150df40423e3beefa93479ab0e7fdf8e378a04199e9954f5c015d2e09f120c4a47b5ca7cb197a99187657cd4c466aa0dd6bcdda1e7db258f74652eb8ffe647a35673442a72b08aedd86c26075036713c6ef1fee890189c3290e04fff5165ff2427197bebee8bc1ee9acc5a90f5f904298b6e526186bedb68c370be60dde7b2c1fa80cfaa3c5fc2b8e41c8b557c70f5996cee9bc25f97fc031a7fd62e7c3e6c752feff9ba258d026644dd40412a02fc77a09e40b2fa25f4eda5ff221da6b4db5f007ead12aeee746bfefb5841a616b3dbbaeddb950951d06f7b14779aaaf16cd5aeabb63635e3439e1b7f437bc84be05d986f5339091a77dda96127de23625ee7e96ead5389c4896c420422c85353b0ee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
