<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51a387289f504f1149d2e2dafce29e878a7962da3db15fb22e33b1dddb41f641a72c217f343e10f4ec5214b320974f599ee7a869bb22ea5a6e4e2fbc35bd9d636431fd4883240816fcdf3c85c705937765f1885c206e3f37cd7f742aa4665294059361554d44c824b608a443a7e161e660df31071cba3a7716816d1e2cb82eee9a44c5c30e495a6f757930b6a4e6025dc1d3befcbc790e6ab6e7e6bcc90e5d28c374c3488049db0ce92829865bcf277f487bda62c4ae6421c2b571c6b39ddb309afb9f1bba9e01f430f4c3cb6fd385da238bc94e9067476ac418d8b6f380da2de265e726b59e4eb107e67f74b84e54eda71e91fb14ac873a998c9113eff3a70caf5b4e69998ee1e0d3838effe8b3b57ab71fcd0cdb4616ed53314acec6290159fa14663eace88f1a618d67f584182e7ae210b0457f38f995a65435a3e663dcc3061b2d50bfbd1953dab326ef6a42a47177f53ed4b54169a82d3bbe2998fc17d6250c549eee990e53fac644bf48f3b41161255f637aa50dac6687f72b0a34eb5c664835d1f810306a77a16c5068af27dfaf2d6a72fd1b604cbe0c8889a588b780956035daa3415fdc0a30b165424571dd54096570c3b8dbf285ad3e960a4afff8bf7a4e60f452ecde4cd4cd4256904d990dfd1ef212b45db993eaa1bb2629d4420b4101e29ef7ef064239a97acfefc365fa0fdaec64a4b29d1f48478854411c1eb13d2015b5e24ebf21f9166f7f9a456f0973a271b3a97ae817a26adb25971c1d77d18a0bcd565f038b4047f11e98ad6b66ae1d9dc9b0af5e273887a2544ff9be06ac02d1334be4c5d692e386972974a4d29643007045402e6e9308cd73d5f2aed09260492a0b9ffd09c4b750ab9a02d6ff38341c0dab44f4ada8324948d7e7d16b7fdeaa315f68230b065ab831c7bc0f62a3cd086208fe83e59296ce78b39a1e8957fff76daca456282a3cf71c9909e3a5c8e4d42434a7a3832608af82c0e626538f4d74b86ab368ea3a1e4932248b4498a563da69262f3142f8dc367b36cb9bb57b86a666e299a81c041017fb600e73a028c2ec294b3de2f203e7e977e784279a05ff7a5f9bf5c29b7173ec020f2eb22ed9a91620d8e812631f000a069f80e7263324e284df1a8f51c4b191722ad7f24ce77980cb1b698c79e680fffc5c4d8c6d7f92340533dfd5e29908b3b6abd7a1764360e523a6d5c9158d714eed7cee701ea6448289dacf3b3293a802af5779c291cbe7ad52312e0200c97c76917d01a9f6de673132ee31c08b869ad3f80d832fbc005a9f218039ddddc2ff7b811f1811f898aa0520c3f5b9a89a240b6fc5d30865105659d29fef32487c94d29bb947468622f4641fae538b17be574cfddb742635e501e22dbbac78de7500c430af9213456a36a600bdaa25c34401e19669da2e4e87896858d6e1e56ecfb30c7ed5aad684eee546c0649f9024619c672e19836f2b881f649e486c5f3d7eb1688ca904580f77b2b1b6a49175d00529ec5c80aba7fa5b5473fd85874080979e5e6b9b9be3b362849ed66c6369d5b104309fd12439d41701844d49525c9a9b22d97db5331f29d0148efbf6baa4d3fe20c66198f179051b02995b3ea0ed478e2be4c8eaa6b4676cf86af91a1070d54b87c16e93775167608dfccdc31f4fa83b32e4d6c845174b1187c3046b62f268315c5f467f6c9bdb0e5283862bcb5fce6cbcd90323e0cdd96b284bc07647fbd75be7143a376b53aa647b0003dd8a69e5ec6c1f24cce297761b7b69cda8c78a5d784391591fd22d0f791994ae192869b6708e0b85afdac751b2cc1ac85bee1a9f0c744976c1e868c9a44ec630dd1bdede2200a10ae3960c660b0dafb1a12f6f03e1418af2b1c6ef67935e13b3aacf2b95aba5d6b2c071dfdaf9ffa348734ecdb3deb69e82ffd293b2b9916505495ccfcb1610f0cc5c6a3c30e22ad395889116294e718bd71ccdd1edd6c842ad0562347332ee92bad95ccb734bb66bae23889a3f20fcd4205ed137118f775a6f4664b1ef1c0001b3399dbe8ccf76812e00521d2a26cb9b8ab3f6a1cae9b1fca4d51e6d6e6ec50be1b470d60b35395bdea8102439245bcc7d7429602e04cc3f7ae9bef4a875e560a9ff24948f8caa5ec39b0e3bbc9e9e505b713472aad659efbc43f9e58eb33968eccf3f73da3021b043aa7a6b899ce7296794bed0279b61b677f90a932ff078410dfe52b282477f17f1fc4d0bd1b0488c8f430182a906411ae1dc311ed513632a2b0e7c00229797fd596f415488b7725ded88595f9d9acd06ab9e563592a43729b9765b86f4bc116cd3e39a8aa65b49b8c578aeeb4e739a68ad9b22b7955fdc04c50b07bd806cd46b272c60800392fdc85fe4cf8613356cc02603d6d53408c0876442b3e373158889a1c6db27b781de0a849eae0b7a467d210a1b472059cd4f9cb000821c9b595086508c84f7a44fa59c74554e4700a9168d643af3e2ab1ee073c5cc6ba194c35f3b82af424fd7fafacb237fb2f8495b19da056e934699fd0b8f8d78b03ef76c1f2e68408e09692d0473493ccb947bf0f023d69c18b54804e97c9930f78e8a59be131738d17a2b092c4119c25bc32215cffc3a7fb61b198ff79a9253bf64ff56272b5ef93f800f9fbd0cb3d9187c98ec92ce81d73da09c59a7749bf3d85bf6db7ddd57681764a32b25196f9f6b8fc737948993b47f8c970ccdc8cd10d908ab78ae8ec3b2c4908b3c86a76ebf0041684be71c85cdcf3208402c219b33facb4181229a01e5b21af3e4515434fae7c1a2658476ceb304fe3d9f7286b45ad35efe10302e67c2280134c2b30e82e6f2ab64003eac5b2b97d44348db91e03dc9c28c14870206903f5f4f1d2393f4b875f99c8c5533b6aa5d74f960e918acdf015c0cc60c24961c5aba22932bc39b1058b21f6ff2a4d686162fa2ee3fa393e30779660fcc1e8f213db98be2ea8902e79d2c5a9b40b00273c676fccf936f91ba35633718c06e2f0a99847154567a0061bed0e1f9c31c1545a99732abdf21cadb5827e1e04ea342de6538228fd78a77c0d3ccf1dc5bc6c8db2f7290b6fccc1a61773e113cc9d6d464a16e7dd197efae7aaecd70b4f6b1aa1d30457503deae0ee9026edc62bea1874d5b4d1f8834b568269abe4eaadbd903004855f6e37c07ded70caa76b6919e15c8534c4669a53ef8fac482c9c19a0db7b8eff958d073ac7bdd1e2b7ecab3123e35232d6fb408f78a4d8a73cee47b1fbeafa8ed640acb8b39f0eb00373d059bb20910b7e7c4202f39c43dc43df7ad769d9072edfbe759c283c2e68f12db6d06b807d49dddfde9b87e5f74cdc8cbaa27fb52ad221a6a9a471b3a5720cb2cd5af7375157919511acbdf42146473dc9a49178a6f756999495945e439c9737a7e1cbc5c4807b03aea96ca27ed7a6d6c5315e6d5c51d01f7395b2833ab6d54e53da3a0f828ffb1d3137e8929adfb4565030152163a841b4bf7601b3cca7f66cbc053188c62adf91c2131409c6363ab903a9966efbdc08b28868bc2b096e59dbfbf6d5d1aae69419529642cc7f49cc25e74f54769e641de8bc83d1df8680f8ad7651b75eda0e6468f8fe54271df36b4028caae58dee23cd85af941ff8f84a080cf2312eb41eb012b3eb9a296e6a29c454791d725ca941b237b245390715f383a9a40eadd220b1b3a45be74dc36069edb98aa21d031a771a360e3f40b65797e948e3ebfb94e189ec84750e818f04a66ea696f0957056a7abc35313eeda32dc007f48570475f00c453d15431c5b6fda04ca38a0b428bd1b71b947ea5b781df1a77fd603ad2795084980f4db8a73fe7e5ccb46920e53efbc34cfe004e86ae590935d36dd2b650e4b8c31961ba27a9d96adceb45a58e14135d46119dca3c6de41833a61ab801c9ea05b49bf15802481f24731557f9b5499f2dbfb60bc1decf64caa5e287ae2363c4fa01057165ec05e3fbf8d4694e0d83177e6a538d3fa0829f2b5f92fba455360e18a87c18c18dd478ab10add2d9a4284ac02a87885065b576139d6cb7451162a3faf7fa1b3bcb455cfef6e7b10fc2a8e095ddc7e4ab2369c875a858d53a4fa198a24b700b673f81ba186752f31f1b50e6600269990158a25e206e8d291b758c41a59037446167ff4848088871e864cbb01d493f504de866d554e3c5a724f02ef86076436e1daf23fa523e2203ff9126f7d24d7c63836918daaf9b3171ba884a8888cdc8a5b55aa59630f812cc281d5e5a5293f840b12c2e0bc9e449e629d4a28680a5a89c14d149ea3aaa357e32db882cb8aa561bfc0e664082fd1247a0c6dfa10661a8f670dcb0e1af189a0cacf9a2340e111154685ee0844bb2bdfef28eb71fe7e7305fd623d8ad49ffcf4354ae3d9bed52427da1c25f4009c3b0f75f677fd785790016086c2a6524eb2bd3bd8c72fc717dd39a21fd0d5b02ef94e0de3c55cbdb733b6d03ccb50c847a81d0a8a909500383d23eaaef2d070bfccb3c674e26d0fcc353b07db699eb3175668829cd10717e18b5dac49e42e5949e78b82197ba086c843f243784f249e15b0c366f4175172444cac66a275e9c7313ad868a315033f08865ca3903bf651fbe8ab21f1eaec57001d99333f4f4e24fc5e2ddf408a834c15ce1ec4ca86c732f6c956c7aefdc3486714c895b22f4611a4e2e4be732e37f82c02589f3fb272a318c5c860cc334e80da535cb185cb258fcaf25285670b229344f5c0c2eea999d03def01c424e53ed21d9c869850b7ecdcc6921b7668ce2cb1a7e8d0c51a002817ec517635c3d21ed24eb5ee5d7b65dbb74197eb4315ca63d0ff9e54094460ee5d463945c91e537d50f2ffc14bf98fe45e204c092151cc9c1c40deed00c71081bade7661ceb14fe7f6965d2d08c9aa6817853202f168619f471929d68db35e015fa383a2ce6baef772eaf3c06a83312f3f894444f8a293399a09069788049268d33ec4a3f332850989b1c96e3d01f2220cb9d4b800c2387ecd9f1ac24fcad841082c5329adfc3bf98f9360d0ed3e6d0a0f6edee5ec17506fd3604e9e6317c29f133f285bdca9ced5149c8b11a537c6cbf5cd21041ff083b4275f495bc8e81ebd154fa0634589fa970a9e489eb2ea2889381da082e63472b8a7b5eb8b6d5f99d6f067ec8ee6036a0ff3695ee8ca9f1038e6223e73642e83d8cf5b6ea53ff1f70762140b328cb29fe16c1d9618f1d6be3181caa47ea8ce5af86b9775d45a76f9f043108495e8d19a56c25c4e42977782cace19f203ee85994b49865169bf7efcdd09afe63a0dcf464a8a14b21359432600d6ae4979584c4eed74097d2ea82f63bc3ef7903d96425bb5343b98786f9514484c777f15863ab8b502a45f23f8d0e4bc9c631dbc8b876e57413c166d1db603e145ec2fa620a73edac612d50c47104586c2a05f9b02099b4276641cd2f6cfe10bd2bc2443cf74084795f20e105ebd9b0b05e5223db2135d768df4ff547f28e60dd8cdf3d943b1ef4f3014a211e429a2f9359542cdb0f7f04101ca5141f471a233c1f636b952f225dced97f57f8d315e1356b7da6c8147fd1c4db46668ebc51d76078e15c9521e9b10c5f3d8c9ecb902208fc9edadfb8ca62473609b0fe36627af1eb7eb79187b674f568e9287e11d88606c1413d5324fa00ba6a6a2247444f02535494a083e80d1a64e0b1261168bf14cc1315d853715ac79a863a85926d9d86c312f45412d9ac6dde96c4c4f3c899c9c56eac953c13bc05f149baf1943330e1c8f5d09f1a71d7a787cf14faad7419a0d85b04797a3a27f65b7643b29643f361733ae8c582d29d99cd47331264c648860a5e22566aecdd0633715145bf8cce92333aa5350bb3378c53e07f398688e8a22dd1307e70f6531baaf7a4240111a0f31b5f84363084f36d9ae1166310a6c3a5fa69f8f081d07d5c1806f15f7f5042781850ac1cd766c3c4e8f0e7d48ef5690fca8af66391cde93b7876f052b6b2ea7602035b0d738117bbae306ffc0a1f279e966b12a2520311c88473ea39ee6b444bd12488874b0465b658b43e6894ced5c085a83c53308ef77ef524e9984ba1d786bc64534eb2ad9b6be9b4809baa6d75480e8ac1668fece7dfdcc047b09632009d916dc110e910301dc3f604f51260ec2448818cc1e6254cbfceb9b2b0e8b11b3049b47da8ce2aa8dd0fc5b1a6743a66c16e71b00bcf29e930d936d4030348ef0be1095c155da0e3cf4b2bdba86ef51977b6f2f6778d1c389beed4bd444703c1b596f2e94f45f523dff8844bb06012cd47726e06beb08b2728eea145409864c339ae8f24860cccc7ba63b67351c45f780534ac0de3caa4d3ee727158330932d1dd85b921323d366e7589cf917463ea2208891d4aad4e53a619c45be36918d9e84ab09a97d8b0b5a5d6d2a3cb328342b313cadc99d6d962a7aa7878b7b5f89b7cab04653d458139d6f906bc85fa14479c9d3914554cf11fe688ece6fb16399cc0b88f8806e56a16e512a39740870959c6876c5d6e93097a0b2091039081793c5bcfc63f75a356b55064df03b614cdca4b5c660a0ff65c2f890de0056926f806880b87d3255ac6781a9c1748f567503775a6651a9cd44f0eee1aa8adb413cdbf1628ee6204ae2b002168726dbbed8e2280692aab01c3f1a0be0e99940435b092afb9891fa37b278f37bcd6336ad1e3897e2a586030d43ecb3c3b33a9b42828e58e2ba474f101776d26fd2668f09fe5bda1810716279bbb7cb2746c1d70fd079cee4696395f25fdaf088a105ff407e8b2f31490b340d69fff120a2edf7b95da0b9f1a5a2264c4c8c61973938ee33ee1833b24c9e63374a50c50006a9f4d3a508587182b54fd22550a237bfcc678c7f6a28934073bec068c76f42cd8dfc8c1988b8eb1828058054452f54d555b626bd60a2e1406ce644ad8dd8a7d773341968d15c4c976fedb6ca858809d613e9633e2550cbda51a6ea2822c8b4851b51a2c6c464e0200febdd46c3756862ca088641143ac68680c07c27baf1491940ec3939fb51ef2a19384e88986d7b9e5c71934f8fe929cafabec846dcb57f937876c3333aa97ace727439431e4566d350ab2d6f5e8f6854bc6f9dcd87ea92efea0c652a2640d297d5d8dd4237109dc8566628b1210f045187615395381cd152d3a8307594b49989512adb6bf162fcbc7b0faa517a86f0b195e00efbeba24f4968df931efa4a88f368d0b5301262ebac8a6324a4a9991ab7b794b0c7678cd64f264d589d08852003319e64feabab864903d83b8a5f12a65849360d7e10b3f6ce8bf69275467a8aae0316ba9f4c95a1083d8fbc306a9388519c3c0e70e15efa91fa63505d0154dae25b832b2df05d92ce5e6f2c1ea7f4b1d1fe70e41e7b55e311c0a5a19d81b0b8973fbe110cba55435814bb7d563585eac229d2b2907a58f8f757fbd531499ca5aec8568254f34e6ebba0efd124f37051347af18784db3cfe9516f80b48d129800fd17cb9b06d17107ec121c37954b125161a6c729b535fbe4ea9974a0df23b48f1d8004d552f7828403bee974484d7f3cb6a8b23ab8ceabfc08024e64ff5667a3e032be4c8b111802531e59c2e3c7d92e3038ecb6fa70669cfc4d2441167141156b59883b2dca9e33e072692f72efd22f29587aadd44f309df492504c062cc2e6f5dfb66e2f1a97c26764e461e9977702f6cc9c0cf09368a9b81e4adf4aa4b5828aa5509ae2e81a8d1aacc598f46ea985ec157591590a0f6b4142b9b8ece692025baf056217d162e6ae391866050a5344c18f8c4c19b56daf04f0cd8ef752a30f507f6f036f59016589d7e656f2322dcef0f1171897e4f7ec8cec5d7596da64a3172fd6a1a2fbba7364cff6bde9d26d40b2cc982dd4aad16a4c29ce10b3fda731453fb8c9f778fb04991eaa24b20a8ad44e1a4f63204a0eceebd996ed56f3c8b48ab2a8f2718caccdc66b57faac72e2061a74b9e33336f8097fcdc848768e03574fd4480bd4466970ee755f122e5543331ae415f323dd52747c067761b4323807017125814bcd62c44b9ef3277f369f058299196128a074de050ec651ba1683f4d38a0c5601acb7a0e0d2a76524a87b88620e069fb6e323fb9cf616c72685511cd151b1e1d2fe66e4292803093ca5bf02fb2cca3e8207d799ef2e9fa7ee0f7c7aa7cdce4e2e8045efedbbc6cf84f0f1407ed1118eb353c8cd9adfec248897bffe5047c1e7804b5866f8f60d8cdef7636e426779afd77adb192fbfbda975972e59af5372affb57e38cf2786eb31ac587d9271fa18e4e07a970db67aeb6c8499b9ef18fccb207b1c64bf76d5d1a782fee9621e34c5f01bae2de57bdd11d43de89692112637d76c0cf81c221347644fd82568d0d9e80fb7999775f51c384e834078a844929c9464d5dad0e69b1dd76766a39e58c7262e98ca4177f8364f511ff376d1788559decdbde9b0cc4ae74a79fdb819813489d4d6fad7577000be2092f9e34e85f337cea6c0769b29fb6fef6d3d1f1039636608323904f07787810fad171afb18a340ee8e417574797cf9cb7492b5fd8ac8d7f7b2675f7e2c362f44afff702c746824fe57e2cf7caa9989598600a805bc58e0c7efc24edb6ba19156865713c083dc571e17660e16b0429e23e5a962aed51f0096af9227b2d37afcb598ece75acc95f061e4e8d5e607a1827c22918c5b0b00c00ff523289d046b0f3da51cf173618bdd85b8c5241f490be33f7f9fc2659cd4077bc108ef7234e1df1cb57cd73e80d7776bf902b89a66b7b61ce198954cadc709f11a05ff1df543d9a9108de68f5a7f614284f40aa9c1c91213fe184d3c60efbf53b31e83cfcf842889419907382d6adfd4620e68b23427e0438188210698ece364aaf0b57d29253f6380ad0920a9d85b3d11ff72a99355bb1f6497b62b2229d3d9f96bc0a8ea0380722458ef6c1087948c1fdc144ccc3172df21ad4ffb2996606e3092c344fa92d95b6061a84fb0d04b1dd5d9d12c739e66c871baf446d5b20103f622087719b3e4cceb6b467b7e2052143265208cdcb7822336ca5ba4b28d045cbf79c17c4d82a89d7551d9bdea6cb3d9e8ffcbf8380427d43973c8722fadcea485fb54175ae5509497632fc9f4a977a0182d86a825f39fd37a0938fa0dc1558d8f533b2678ffb1cc34a47328f9760ea4ea8ab1b6101eacb747f97abd85b4a948aa951e5fe7ae5d49e522f9c046a15c9b3b72f49da195d23fedab03f10280fee978e3f10b03934727d2093c37ff83f7f08e09c4df909b80fdcc709b6b5bf2b81c16f70d11fa6fa13496b2866a221496ee31c72e487e57a92632d0126286ad599f94af300d2bb292cb60cf1f6bcb2b6da17b65328aadc00a65179318bae46647661c9b5b2871cdc66be7f19a7054d0f5d7aa4c32f38da03151165bf09e6cab5763b85f22e341f523709bf84ab01289a1300418361c08411e8bb6e6da49e876e24139bc1d8eff2044b92406f305d04a548bf11231e15cad3e0a0421de212cd2345165cda51a496bf17ca54dc8802d660c30413e4af50283efd38b983fac9550b39a6255b6e32616b9e8ea4e55290880652d97ed0630d4e481c4dac632c7685830a33b1e8efcbeda252eb643b9daf5137e44c30f8b67d941ae25fdde93bb1789d86913ca94dd9dcbf3081f0ea06e020777bf4893f38b69f85105c8951690c72b48940fc0d36c0c5fb5c3e890bb18c660bf9f23e054a2e84bfdd07afc984d5ca805dcc883774be0c133092f1fa824da68d08daf37e6d898ec45d29b962190f6164f1b11bb1ecf6259f32316898c095ca61e1d0eb3e1fcf7a00a93240a10615c772053c1acce50f6650a9acdc88a31ff17eeddc981ef4bc295ab61c4a9997dbab78c95ce0f1fceb523a85bb6024a528d8766944071da1ec9e547b255334ce70b7f1aeacaae7947e8eaaeac9f69e72407aab5afc044da7aa8d24aafe666942a530cb62efcb50c7e9c506a117e093a375c0db23a5439a842644b852aa5fa9d1c5d2914cbf7f578027d6c99fd960de7d4e6a00e17094ca79e522c2c739d4d2186c7ae87d81700f0ba43cd8c854db1b0c4de41c6fc4107f19d411c228a772ad02d40e1bfa85bc90680e588d8d7ebd2e733f7fd0507dee457db39dd0d661ed2a5663610e430092ceda3a82dabc7ecdc5b560097ed38aef5edec9c153b28c419feaa3c99d4ca668a7ed2f10637def48a69afc8f58c45ccb14d439150ab1a1fd0d6e9b36d6a5960bc53b5f329d44256477bb48618577aaac0077db11087e008c8632ef26b4f073061f0ad92c951a902075f0dab63e8c3eccc73a28d97d36f247c8e9708c5c67edb5759f7d3b7f18985a7de4d1bc35daf085f2eb5de5a10f60b5237c7c0f20443468c62b1b7a7a5fee82049f3d4e44d14b4a200d5c64583332f0cec5790ff8e383977c242541d50d71d51bf2d5a2a8a5f5cb5aa6408d22b8a419207386adb516088d32845b7fe5d61e165ef12ed71746d0829210ab3fdd9e0a26b969df71cd4fedc682aa1b660204d3b9a4cc5a64a613807795a8f5cbcaaf323f3d444f2a1840f04bad02795085d1736f3aba42fcfd5ee1f6497f943a10103b4b68909ffb41d6af4d2a28c398ff844a61fca07800611bbdc383379a9895836f81d205ef8e46494fcfa3b4a2b9b6e95c781d795c61382d26dc3f6d20766d1e3c53096626eabe127c942d5b19c2656e61e0215de7ff258755a1ee0a323b7084862a504502f46cc48ae5de5f3850b2f736766b74cce1601f4a27666a1e2a6608e3dc694d6f01371fd00408be0341f9c8cb778c9a3bb4ac5c694e0882406e381cb96b6f34a5a5c8ed938970e161a734c47c40d2a8b5b0e216806653776fdc878ec6257ced98cd184b2f6f18299510aed3ea6b57d99eaa15c93ab7e32af5302f765916b95f9ef2382fdf5e2bf4d9d2a1c17b04dceb2e6e55e045822e9e5e83bb9f329bc8cc7c79be4360b565d949ec8ff82674efd3631ee930545626463813708618a991cbc1cd770d90cdaeebc2c864769d98ff3e3f4e1caa4107c27167112159a169945b9c8936e66b6399bdfcd7620160d0e6207ddcaeb669bf81f18b5299e07ccc4a0c233dda02cfe497b0fb50aa2d9dc8d81bbee31a9c9e00538b760702d30a82ee5a300a71de6c9db80dc3ebca75354348cb66ecbf23b13451c50f525df70dd770a6abe324370fa82b0409d3b2bffbb1db847007863768d3a5318480f9942ec4b24fc55540a1b652709d45f1ddaf4643ca31f61163c477ef24ba96c9f60adc609c199c24208b12f077abde2b156200f640b887ff2973170e08e7e2d9f51bd27c8324052cd9026f2a68d240c0c2abaf13b4fe498cd43e96374e670de1116bd7b5c2061ae15f0a02d210c6893f996126c83c59b192ed0cc457bdf8f2660e74bfae1cadbfdcf00d405b0fd429b79b323d9f55a6dc076c54593b12f0cadb2aa2dc07a4459530bf056b403047eea97242a066f00bb60875a8f4ec93b9f713e38986f781bceb08dbbb0aef3c29e72ee57e56a935b11c5abaab7e713f0c0b8b82a6ad027aad1e62e41da1a7a58c617407502e96edd343d216fc0d18f9a529b25efbd576b5c9a23ff34cbdad0a28c5007402bf2b5ab42e5758ff6502ea8c9ec1fbeac714d3bdeb6f0bf70f44680516311035a7521d799e5e6f8786022b0956b17cebdb1ce626d19b7105c30d8da8e3527fb788118b299fa4d52436b9d79a483fb4ef2113a42dade1b05225aab66cf3b0b00848198e09fb8859da57d500ac439f8999c3e938ced972eb6f10ddfa413d36abcfb7d3c55fb55db5ee6289163ba86e5e51396a6af24a99f4fab27ea7835f3836e7751d0dff0b609215af518d7eff915037d318a51a3b409f49f12bd219949f1fc3fe9fdd1b42822d4542b8facaa224c10918679f85b123b8cc3c6f41d0bf8a52e9f61db1cbec3d01b9237f44650c764ae5cb9bf374f12e0c969140416a97db2d725375329cd63463d1413dc8a19977f99fca036039746013c371b927e07645e24fc48ff13d1ffcf84a39f719b854c8d69f39f3aa061eebd226613724db4ac24dee028134dac85efbe5e2348630856ed3d06d8aaff60e7de7bfa5234b76ec824ca74888401062e9d105f9921b039c51e1c12edc41134827c2b44a4192a5dffcb8841f5721c6b5f6399d58b4944bb893bec1b95f81b27b065da2f60461a2b096fa19d56d173267f978e65fe3c97d35a46db0d1e3908368efa228c506d73b886de7f007fbe7fceafb6e58d595a69b48d160d396fc9363bc4721ca8010b5b3f1700c53135adc186236ed520e34bbb65bd78917749d6ec1999e4f6a371c7292da4c2154192702444827d9eacde39d6ff48f3b933fd79150f0af134205475e0d64c2900592b401d5fc09d3f09bf125ac317f579a2ebc1d2abcf7bb695b34e4ce45c4a8364bd3e57bb718f07351d77c42abb9e86b2903d8370d95f1cfc5bd9c808bd65d028604d08e53561b4a2610519823b9c4b8b7c524903fc510781e0f38b15ce6b761ed321f0e1731084266b8c46e33e8ddbfd8333354b5eb65abded32af17d311ec7064626e6b9d833a1e756f3cb768940f1cddc795051c1c10659d0e0792581130b094a8a0ebba969915c8d15aac3dd43370842aa96fa3a70c121905c90aa6d89841d4b0d91431a35d9fe4c16636c38ce7b17b04da1779bdbea5fcf99e7db487abb02138785128689846f69a4c4e2c2b072b578fc1d74adfc5a0013fe187ed376b09843702aacc9724c49d1e716a1b50595f10bccb18a992c9bc08ca383b62e22cfd3a5860d712d98e0a02ec0a95f1911144c28a809726ebc0d962766178446a716dc88af2a20dbf1a3f6d2b83d232adc129da037f3775000437188a4d5e649c40beab6f420e35a20ea1dd29219fb167205e59651710b21d26ab93e3f455f87ba02f1f843275ec5c17b4f9d88e25a1d6235b65b8d662c9f7408507d51ab12de44d86f794b21924a6430d64ca85c268ecd939a731946922674dcb4a783d28d2fce6e6f0e18dab9ff0d0bb97fe4abbca65174e59bb4887bcacdad8a86e4dcd27c08ab0cdceb49e70203227490e9823cabc4355dbbba998260cbf16497fea168df2a5285637fa529917c52a2c0915edc3f0c0e876df2d75c5fa61dc19078997332c7546f0702f8ae4bb51efcc296745b8d141a0d9af865336573a42585c6d357e53678b4b67458d3f5bc8c27aaa9a5d8d7b95f33f31e60c8141f87b4dbee793f0b3c3d05b4abf293f66dc5fd9d3ea83b8004b37440e5c6f3c88a64fbaa82df8d240524306eb4bd413c902c0031200e366281de3dfd84443d2938f3d8e4d1ca093771884773ac3171cbe88162b6441f6995936f5e5d058fccf410ff8082bffb24572458baafae4ad8113fcfc754c4fb3346f77c89d57515fd4004b0ccb5ca5a0e1112ac42f30b9512d271f68a05a4912ffa3d1f80fcc293ed98b06cd5be7e3c964b7069d48069d87d97751ca2d806261efe1aaaf5e6bc9560c6e020adbd8cb82bfcfdf1c5199f01d88ded992b195308928bd5749d9ed2d661f59c5a4c2d786e1ebfaba43ac002b07f53520834b78d7da284631ac36c54ec409c23666a629caaa9030fcd5b2b25c310e2ef9d9f271788e99fabed074c5100290ff4c39b3aae07fdab6202a36d9c62533da4b7d999252d2278d4ddb0859fa3a116f0e10b3f777e2d77bde4523ca36e4e71dc1e32c4761b90ebeca6c7503d4a8d07d65f887aafdfee36487d8a4003179b558808464e66f0700fca7b23f07229f2b3443216fee989f5f0b290517f22dd86aa4ab1f134aae35efac087e1eee877298c886e3cf7f8cf74507f232d7c2fea30e59d0df37e165c47f7d8bf81fb2d369b8583114b313b6b2a6e8f1e6db400d913009e07f3f1e61744e600398c25c55fd232c08dfcf282e917a2647dd7f42165c941ddaf5488bbf8688db344df490ab680fe3421e8efe3d2ceb66afcbcc976ea38cf6b2354872baf957403f63020eac39467cea6b165ba9033c0bc0fc18c88d8ab4a47c422704888a48d8ba448ce85f2d0b555020d4171d08d4582b19fdfc23459d32f77501d9bb848c4050fab37fa4a16f1550b8f3ec1eacd54e00ae43535a9913684bc413d51a2d609fa78c8fb5cd4d24d2d4478afc5b2ab84b6b39c981f2fff4dea332e8bdf04de7d24151681af7c3c48e4bf1823906f1d57512c390bbc8ebd7074dfd76d530f5910b877791e7ca6c6d82e1da60f5c525169e6f597a73efa49680b3ff89e2f4c6957ac7fb6761dc0313ac2f1ed1b13b70bd3c1737e908ce84bae4ae76926a278abbdeac1e6292ea8a9c2565e9a57e1889ed00e22d026f981c358d5bddbd2035ee834b940db3af615685f25e1827d69826fbf810e47f6eaf0f8084d7dbbe0c1405a1aa5544a6a02a8174e51be97ee1d6d5923af3cc922d6ea69ced0211de1de949c38f9d3ebc96406e8a1d9a8b99aea0d56ef4f13962fbe6fe82dfbb1c279cf70ef7b71d2b851bb99bc1008373c03c30d97d758232347d761a2b9d94c69248fd7073440dd20b2a0bb108da55bafa6848289683e888306b6448c1b8ed01e18ab00635383b39710d4f5e56062b1e66f1e2ac8f2148f581db90d5f7b2fdeb6cc0e9ec7dafa3121d9cd12cf54aa0bb25dad2ae5dee330d0a686e5bada3a3024d109a65aa2841ed83324d6c4cf105a24326b491a2c91aa01644412ab593235fc44452848704574ce9187790b26a62dd2a87750a83c593d7d63d734c4497b1fbdc1b731c2be30f328eb93b16b8933432889d0c09cfecb5def1e522752b1ee1ba23758ab39a53eb5501e02a8075becf3d4056caea8f102ce72426aa01de8368fdfa167d6b82dbb62017b934da95504572cbcb8b4c977f084a0a2a33ff915fd6f4e1ac62acb02701e7370fc8a6d05d86e83e899ef3627eb4e24dc97525d06b93f423eec0069ff2c6b78d3a8cfc6b8f62819b49f9f40b8609278ec68cbbeb78cfa1e91aff98c3a99f21d0dea87dd53562769256d1ff024d380e9c60adb4fc02918babf5990daabd4314a9b99fac7a08e9dc93a8b822dca0dc5b9415d20bfc29f93340bf81e8865f6a90b83774e77e8ec1d35c9b8ebdc7908cb787d6c5fdb218025c8283bf745771622700adae109db16c08866a31875097b3d6e3040e3a00e8ba19394a14420ab4577ce5636109af9cf9809f5c94c64ae5249c9aeffd3b5cdb874b4667aafea035bc0573203517b21caf3277cfc8dcbb89930dc7f20ea1cfb0e27ab5af1348201831e072ead6707d28aa582a028bc7f627536b8ba23ed47ab053f3a7e8d94a0abbeb368d232d56421cbb4422def8f7eb93f6fc6c101b943ee1bec83d5d83c6d823268e526ae824185f322e297e3938b271f37e266167c5100476a6f7bc6ef66e4ff3e1abd8dfde956837c329719fb608edc5090e572c17427a83c50276dfd4ce80dd50907a862b1e8d724a069ae9fbc2417942c27e227a91af07f1171740ce7bd2a5090b13d9bd0d4871f0bb700980246777c59bc45613f7e70c0c0c4a6e82575ed40fe339fc52533a2a4a6fecd5147b74898815b56d374a615bd887baf0ac75f983880d214219e2561ec8a514f3b17aca77463a8cae4f35369dbbe4feab78f530f3cee7f3c2698d70dda356159281f88410f60041dbe3137e5f63af6a332f1fc2c102bd8655a765cbc1a72e4d596ee95f14938c9e38a7f663d49318630aa84153b9fa089d60d9d0d19494754779d06f427ca2bff66437d34f7a3f13ab663203054da79ef5a5f7edd67f4d21fbc18a29a6d75abfe838bc5e853c5faa7ecb178cab8f39f0bd02b8e1a9baf2c600d1bafa908fb5714e3ea865e9cc393cff95641fb885103ab079c20a7559b47caa2f4165f29fe30315fe37e88bf76ec3f10b185beab455c628279fb756b480e787e83fd6c6c3539ce5c66580e38726770f120418153dc0cb03c6c6804bd935c32938f89fd1f1f4aa7063e71cc4d337bd56d7e7995837fd4189625d5908cfe607ef6017dbfc5668f01a962008cd960db1f5243d073fe011db6771fbcc89fb1d3370ad44d8ce2acc1c548487b9707f95426b73393db4b5eae41d42ccc4ecc27f7c31e7b4be6b5d45998a6613735ae2f4771df864a64021d12f8600b41849b79fca3d5289012383dd98d48eb05175fb69b7748d51ba63489f53a4517eee2e8a82ec6ecd09e0363ddfa2349c521c6ac7b2c721d6c57b40872a126f24898d537200f174ee34bf62c3b69b77992cfb8af2c72a9bae4e8aba0072ff9be989751b99cbb5900f8300fec88971ab12944445a7f834eaeb3911324e5b5a0778afb35b736ff204d9281b918c8c6d32c28b84c2ea78c4a2d0a95b0eb6178b7aad70b8974cdebf9d9a6e3bb0674ccdb9e938f2ae8975882e31ee2eea81db56b26d93a87759dc36745cbaf7c8c992e298bad446e8822b65dd5184a55a867aee0026630a7fd1a7063e499af0f6f20b41e292536b8a0f0fbfc26c3227308ad69154cb55189b5b9ceccf25a2f39eedf373d826947a285eb4f6168c42d0420658ab6c69f15465651f9446e5c3fbbd8a94eaf26ae3a2d969a7be1b9f7eb1c6bf799d2b71c755973712e136ec1838bcac787663de64de6caeca54358578bacae38c10e7233273b926d919008f8ceebab53896acd6071acbdfdc755789a44e6f600358c3e2d389d9c4a598c808f79b669e6fdc0488a2c3fb2c9dac6cc4030583b9f60c7c3f86f262c322b71b72aaf23a4bc4f5f7abf1c1fc71a5093de5ea45a4bea9b99048dea6b16ed2538142a32077e4de3ae6d2b5a31db24f48f06745a99411112fb58312ada31d98db7fa6ed37e0c639d3d1825fb0406416dc3b6cb5967b949b91dc8313a65af9d3878cd0a4a4cf9a18b9032cdd76857c2bdf0549f1d04ee5c71fd23d75226273c1e4dd3d8957ecc15290b8f581cebfd836ae81ebff9557b11882369b105ef7d483372722985b15a7fc5d57d6fba5a1cba59923a4643647ddcb6bd5edd419c35d4bf4e445b6ed150187478fb7dc550cc58d87f334cc9d164085ca9018a95a428e573bc17cc93e7500ba621512c280469a3ad3e2a2ac2fbdc36ce2033eca88c20d855d1d347f72a33a1e27c73e2e99946306bab9bfed602bad5bd8d14aada277abef5bd91dc13d231079f508c4ff5214d950fd1ec901d4eb9638a7764f40283e55ade83faab407e06ad14cd1692d2b71722e4187a092331972b94da77e40f6c98123904593d8648aa7c4f3bad8471fcee53b5bc160a05c24d0f5261a4c9f04b8da2c588fca344b040c1a00a3d186ec595dfb2a68191b1403d6fed494588d744332e6fad360106a38e16bf5181c9324371288a23035d8ce6a676e7a9e459703928dfaaf4c0c5b39f69239e4970c84d65c041033c60f42f1d93619e6c8db8feb7784afd80cfb8dda5f38bdfe6c728f85f79341b00724313a59ed1d993069882f307429a8cd5d7c759890897467b43afdf5c7b097ddedea679176b91d1885420b9092cba218dbacd7b58ea1f2b82bb65f1a1ccae3a47081e6329328b5cd346694749a0100f17c2524b89add7021d29ea65572c396a497c9b95770f4d8a474cfb65436e1b9845f7801058adc67e48f092211e669c8b4ea5e1005daa904dba5015381a4c0529a98aa644e3f6d84d35909c9229b959d66922afb44bd53964fbd71cbf3c7d7f32d4f962b90c9d354446480ed5a0b72ff372a5c950ff2017500e73c4471d3cc851b2915cb945ac8f2a76f3ad450fbc8dc33b4964eafefae036cd9be52136d7321ce7949fa5ef0ca4522a1e6104a439bc50eee52cd1aca8f9eff9192d53efa8316ef8b724197a7743beddcdf686cdd69bd9f009aa105056efc38a0feb09c7fb239ef0078b71656e4b67e53edede744c014085df9fcf5c293781dd6f761ac548a412fbfdfe9a1730b96f4451e92694911b712b270881da6a585aacd81df0c50c749858f72258d4363e61bf3df59eee312c1ccdc5e007d1870646b2f3f606c549dd506376b082cecbcab506e7217877ca8a1e334dc3252cb0b0d76ab3d5f0b8c16055c73b6b4b7b48f1e3921eadd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
