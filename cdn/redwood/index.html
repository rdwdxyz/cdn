<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ba27b502d02a38438f969a9499d5aaeb5ac40e53e8cd851f0b64d656b222e81e41acc41f3b28373dcedfe6452041405ed7e77c1c1ac9dd837901109c62a357146ccd1d1627db4d019d3697a30faf936b48a273f8cdc19774ef1306840b47441977b84be249382eac2989ba1c6fb5645b9024d5ec40d3e732d94d23003c525848c9aa084a3731798156423de163e7378a9574f71b93410c27dda55144641b1fd203927ad45340a5282b75cccd3f8a0468044288e08dd42d8374a678ad6e6d66f47680f8626685fc47d2b7e6435082d667d56b45853305e7cb79b61bcf596805a881116a38b3b2944e29fbf1ea6712538eb62059ecfea03e0449321b7e9921916a1f9cdd1903342ba92b379118008222b8b4325f7244d1fda6ef11a14b2f596d263cc10430a2cd48fc71cd8d18ded300dfcca57c8897ceaa7e83a787e894e6d515f080bfae1a46b03b3c2cedfcdcd508dbf1c8a26a1cf2f86566349dccc73eec1d2f5065f152173164742f0fb1a8aa1bfc50445058ff236ff000e292fb8bc09171ac965e860bc39144854c76223daa146fb128caaa70b01693e78c6cedfc69b3fdd45ebc0786112c6f71e212672c202cec88a125c7b4c6aa86ec5bdabef51ff037a047b3717a515fc143c90629a69e845efd267b2415d8aefca3f3bc3310c822e8c61d6fbd99d71a79212030208ab427bc42dcf33c288431798b6185f25e9f92c4fa9389101029020957640ae15c404fb7e3d5802e52d75d7bfdd1c362b38d6814dea0a66f6b12cd7519cf7e596e5408ed44ae69cd65c462cae9aea2887acaf579bbb963b120da06a5459e6609160e0153477b68b1e69dde3b329f8c6b4687d8e50ed28f9e362b85b5c1fcd27169ed252c9957de7a2815015882729770cd4631f5f5780564c4a9b0007b83e194b429e9585c4df8322781e67d723ae9890d38916efd708c0c4af3eec766d29c81c79f838f22c7b9fb938048345090803d3796922f76dcc883ed301982de42c89d306fbd553d2375ac36845978cec0a0786d076da88ed350eff3d3e54c753e5096398d9ff8585a54f6524e4a56a13ee7dc6eae3e1122b32ab83bb7a476f28186743ed86ae7d8963caa1b5c747d1ffe94b701bc6a92f5f4a9230aaab8ab5069acd26060a20de1d9b043b8b836aed27c316c787ac425541e45818d10dc06475ec1542fc10b686d05e41c81d3b214908fdb50aeaeaa4155b7f813f7527fb9eed4b7154f5ac476f254796293d70e97c0cf26f80b7c59f191cf1ba7917c3fbca6b1506974b478d0e29b1494254104ae52388e0bd5112eb7b1fb75bc69af387a02d91c5ee9fd828b6bc5a6fd3ba07b7b8ed0ba83580e076852793b45a9c6326a08701ce80d9f3b68da3f80ca8fe51e74e8dd9041edde36ed20782c36b905168133619c8c3c1c0c0ee2db798475a80d37c0bdf18739644d90637e22a94a55a114ae9fe4aa98f1ae34f25b3589929f62286e9b4ac6cafa2c2daadf64e1e3d91c8320e9726035cd35d9d34358207c9a92573309619d0de93ee1e0aeee48ddf390301ce9594425ecacafb9f916cba9096ea877ec126613d82864933e3c5c563b554828d97e01b622f8d83de8c267fc4e689eebaf720bbad3539dae571c4f4b00de55203932557d39b6d9dff6329cd23239d456734e77aab168016f5cbbba110ce849eb855db9203c6c7617928df0fcd4c0932ea6143276727586c41fe3254352687ac5ac965eb536fe1d2415bca741fb7864827ebfc8acf5ac153a9ec285ec05d917daf1f358c4b7987d16a9a8ef7d4899ec027a503d0e65b2cac3a315fae557fe0749410a85a5735fe1efad41d17aaa26333816f9c919e31980ad88e1e0b7cbec5895e209ea0aa75be430e388cd1b194de25fbcfd28d03d1a5e5ad4e4b40c4e48b1f472a55fb6b2a00f456fd841e5a0fe96ff9eec743564f06814fd9f33db74b550879c1ec2cb1de152a19eca084d7299bf8fcca7726cc3ef4135b43627bad509964163e66a75ac668107e1c9171940090d9bab054e52e051de6da368e9c2de079acd78f33777df2b30dbc1aa423839b1dfecdc808e5ffab58d6dabfb96b81d8b08fb2b5cc53c37003544e79f7ca06d68139289e42d1d00ad8094f1503df0cd01b6fc81fa93deb61f4141304358f82835e0624c37cfbe04a440313c4e152606510fe820b9d63fadd0cd546d4da69299422b5af9e9a50729de7261a96786e01e25aef039f7a3a66d854853554500a809960b4d580f827abc47a39b4074e43880ef8bdf14b12ec6aeda803ea0f8165070298a2fd9e22147c44e99cfce4c3abece9c433cfa8efc7be4cc882e7b988a878c0d424c3f67990674ed5cc56dcc44d34e957cf90c9732c0bff346c80cde4ec640946f80faf236030fd988d384f56d82dc376f710182b9fc86959468cab4431b920d808fe56c67bc77551211461d8d3c238b5cc285fb367540a83fd12a31615f350368814ed8503a60bf9a403e94bf5ad34fdadde71b8e55f9137dfa1cf2b3980ad7ed97bcb58610655f2fd5c764e47ed235711d158c7ba232d201659e5321318a6178c86fffce39f66a1cfe952c7607d5a9b713ea6d47bcfb0d1721918c6ac44b5e7a8f7127803118f5bb2d73ff5536dc61c2ee363481471ff26eba008677365ce524e89ff6f846e5e049ba3ee7db9c67d2cc77204221694bd3b055e5923b4f06b448cc1f09566ec05aed761dd41cc7c73639f5c531055a0566328e20eda5b3b28c82763d065521309af91bcf5a431dce01c121ecaa2392894e763acf6671325c3ec99234ec613f76a1d79bf307a776ee326b2e39b70733205d11dac11cfc98dfd5d8ebee42143eab36323510de37e9506c0b5aedf82a59745f045fb7e07b9a6f7c39e46f45871f879a55890f117b3e297ed398a9c0c922a54dca0452f990753af14aaf1c8a8787973859b90d804f00a30ec49286d3d6a9f93dc9954c7b38af427f603129802a7bb2ed432d1f4e6ec1857b8b40f942840dd3b2835d47409c48296f206dc2d120820bf0e54d809c8fe6320144c53101ee3ad9f94d442913fc9f23d333ec66efc2bbd4ada81e2e58513cf467862d3bd10b6a104acc6bcfc4c565e9088f54a2ccc8dd8b04eeeeeb176f27afe4b4118b8aa85aed84998002934154e205606261cd9dedcca5d6e650faa4c4e13c11447b72057424760ec7c081f690aa2fe7ffb78bd6c198a5c152781ac81ec382d8cf076675d71a8b4370ee8bba2fc80afe1cfc172a9f24c07e36a5f67b8f7d4572eb6ad62fd2c5992c3ce619468e3a8485cf3ccb5a5b912574ded94e94ebaa58b5fd14b9205d3a68e521f41dbe298ad8f7a71b158c66ebf08c56d1b0012796044636df6545e435ca48a841f18a200fb23a84323e142268e3d7d0d960a9ac0c6998a5fa36824ad4ab0be0ca30d28482644e58a7a3ce7fde7e9ed0e84d22b76261c7ead75d12e8c6b2e5c4346664fa1cc617bd54252fe17176f7abf4bde5426727b73297de3137df0570494027b5cb8a186c09810a5c0a1a28119c86e48538c065c7cd43ae87f128bd3bba06bfa23c40d4cb42478e9cd5b39a4890b5c2e6905ea3a35782c94e7f097050ae925400e71740b9adebbb076d02c3b7ccc62820308aa1171bbcf2cc11e96f39a94c86141b1c5676f4cdf1e423434d20f63bd096c54f296da2ff8dfe5ccfe4d712a44da7ee91b34d609c87b9c4cb1ed17354b50ddcd1827288df6505d36de38ec04843a678bb4c56c1b803705148d2a5b572867aa58535ffe5dcdb3037b76f75e8d137aa48d7dc02a71d7e99b391bec1ee87f22ad9d14b41325cc488f6fa62db6ba36ec60c91d7632474998bbb071e3348c4d66c1733cc7e63131a2d975d6767ada6310f5d90c43208ea4be26e57f8da161a132111feeec26b2ab7a4eb815bba87d4e01fa7a1ec638634c3acc74c62274a9ee9cdccbeed7a2bebc73b5daca2d4554c0ec8a080984fc9e270b4615629d051c3cb87e6dc2e51ba2047825622dfb663f72bcaaa76722cde3987914358411159d06bbb4b1e44a0b0e7a045d53cec4b3a06124ea9b664e9ae6f089a931a424d1666ece478b520536e3ae1f28a1b1b185d4be501541f1f116423d751a8f4a4e20c9b7dd90e621a528c30c6eeb5a0890028b4f33095f84a09900805ee046956c1bdd5422b78ebece681cedfb971d5d74dc9e37f93e83692eba66459d3e0c74338ee7fecca95a1aedb7d74575051f806fb47f2d8f1a5f29e89d0bfc4631ca6def777b1ada5f9a82a08e65b00916dc752dde1565e32b2687f3252c9d6dde27403ab2aa308f0b821d71f2b82a6083739fd2759d32d91888d8e2aa16f4d42de2b255e249b67383bb519e4392cc73a485779ef9bc11179bfd790e0f0ab03b4a86e82820710411f25217fa35f404ab8d0b871a2df4beee839c4ebe1cbe506f1405261e2a6419a46ab977715be0b326cfa7dbe7ae04cdc6b1914e7e4eda378eb0a1ce3d535b1227890dd0307801ea4ac832b8aeec74b051ee3ecff41b0dc8552a09be5c80decb4d819edd36315ab987f079dea07bcc91dc54f0100491e55dae878c0da7b018ae0fd08980ffa73c2590a7d7f1f0f14ee38a14651cc8e553172778e550a5bde0134653dccc942112ab1dfb23380a9159a57327b983525d80bbb30baf7c0eee50b5ecae9403db20af8e99598213f9f26a0e534a1f8faa21eb8c3109eb294dd23f23e17c47ea9401029d918637a3e6c496ba6ce6ab07e3f3c7ee7f0303e59dbd917f09ea4b83a15188964375a0f7488254fe4ce3dfa1e760d49c258d00e534ca47be8ad99314507aa77d08efca6cc9141ce26fc26221d35f50311f4d97354af3ffeed8c9449ad7c414a93efbeb0455e3495c06470f0d830f011efbb136ea5d72511e36df2c3a1dae3a0089bc58c748e2963cd1d02c37e07722540e8cbee5acc5339cabd8093a3f2d0cf7a4691ae2fb3a8a2760948abedf5d912541f41c79a2e895669ba3406c4340f26b3640fc2caddbadb0267482cb7fe78d9c1c55bb3f4885235544d92aabde67d6525ee73a71a73e929870dc5aa5b0fd3e4672808198956df52c343b1ab3f55af893680ed7660e15710cb3514d5ff0d252ffe3a2ac9e78c65b0ba29d546ee77e4f91826ecc4ace4a0b9f76d8cecc7b3978eddfe00b77c1abd2b2c506ad9376401d30d69dd993eea1dd0f7cf4f0f889fab4e0ae2922d28e1e0ce69c35253bd1a5ad9b786ad07ab11a59754c44e2da1e68694854e48200e3742b46f44bd0a54397ad9de0459293000b5c89f128fe8714ee06b8edbfbc309b03bc1b8d597f029209ff7d1f89c7e5a156ccdfc5f2c9bf4fbfdf1cafd26938712fbf07ed846e4842993909998fb310bfab2dee5ad884178104c474c46383e65586187b00bd7cc50b18284dfe1197124bc2c5005b8724711a2a99fd139046435bbddd6ef6e10ecf245f2ec0e9c9cdecfaa0fbeea9a6462cf5c2f3c3cb7e48e6e13995243cc60344aa4721f2feb69598b727742bb9875284ef1e9af9cb8d65cedf622f67bb2100064597b05f994bf03a00cd49dd585ee84144ecd0923ad143451a582aeea00b6a399990b78d98462a7af35032fec66fc7873a170bb48effa7fc0c894fbfe862cc5086b343712110423928d1787933922a09ab4c4ca63adbd4f4b7bad49ba2bd41176540ec866fd27ccb7721cf043ab74f65ee112721747b523c9c52fc497abad5e267c7b890fb9e61ae9da20b8eba276a3b771e6a6ceb5c4c5a02d053e2391dd25bebe6b696ee5668f389296ad5165f9ad382f1ea48b09ecf6e700ddbc7829711334dba3112807be4bb832f613e195a1a631a889cdc080ef6abe2fe19af99a065c9534efab682d905fc26da59570dd3203c6e6663a8dfcd2de23110a3e41b21f71527c2e97927c6fa98f99fbaee18bc6912293f42167260d97e2aed9c0e81032c4b09d61263707b4cae3ca2f155711714ec1a582f91219e11bd29743768a3d1d31de12928841a3636d89d22ca24c6b59d49319a4ac813681d300ae94768cdef7905dec6045c6a5253f48b3a6deaced3e490f65ee6b6346c075521ac8b24dfd7b20b438ac8fdda378f8773d8124a12db96141758f4d9887b5bf0d3073d1c26ade3ac3868c5c4712648004666d214473220511be63891e5eb67fc02e15c761a0533e49d9b4b876571fbb6411307113f52429ba4863ec05a7c58b0d767eab25268fbcff661700740bd800ba46ad39d974c15a3135a1f21765242929b2b6106781d3f9faf1148abd4d2e8230543803eaa222ebbfeee2fea95d73d31b6e79c2e6e74158d8afc45003a52c279f15f6e6b18626f079a79d68b7eb10cfd295fae85676c62ea7fb0b24a0bc37bf019bcd199dd81f8241248d2581edc166c9ccaed1611e87a613d79f68187db001f8f750305ee35c4fde947b60c0c49931d3099ae5eccb9d4cd8142aeeb468eb164c3b174e4940efcbe3ae29cabddd1a865914ca58bef703ce961a565e3346c6010905725e5fd16e0908812cc6d598b4308cff4f201574e3bd4f8c99dacf32dd3218015a638a3302625f5ca7b48e7a7b0900f58dafd9799a047801c81f5b962ee2b4d0edc814f70af2d4afe4a07721ed502143af7fe6cfa1b2d6aa428ed31864d9ab5678b61af89940d126d9473dfdd28b67bba04d9d0e2782854fca51fa413f8e98545ea35dec3124b4c2c1b5434f969fbd74a6e4cd8a438ac426826c02e434d6599439c5c0f9cefd71110cb893ab573b746d60ecf7a48c220764bc0f22663fb32baefdeefe684417a7a55bdd74368c85c097b9ba59a69dcda687159b9b37911343ab918ddd9bd36a9fde68f1016329ca8c952fa81685a8a7a459ba4622ab6d4f1f4df2380f07c8b9457d995bb805b2e42e233d495160286356d70dd5f18b722136b1d6c4afd1f17858506025342d8bfd4d3709a15606da08e154eac1e4ed352fe10b507b4e268b56b7662da74bcb1f972fd92888804adbf70e78948e5d88c468d9148ba3bb0432b9e388dd6d19e7e568335113dd4658f2325964543a23989006c061856509a21c6d41582358d9857f042ee47df2f3ac741e8579199f2ae26ed1bc42e423c74008dde61f033d61f8b9fe44a3c4082ab2edcdd9d32c0ee90d7af5cf2254e37d2989600d91dec08d37a4c0e1bb6fa14f095c172ba53001f36cf2d11e22aa2fd04e9d5c205b9b1c1675e91792c2fb225427c504a7e8eda64eec148738b2792004e72ab9085af3a2c8d6338d59dd9b634568446855d28f311bbea91e74b49a9cb40561cfe15069554fb1dd6d4d927b74f34855e7ad3af9301966fbae5f1dbccb21c50b97c4a8e477223435c2bb32fe0737363b8c86dcfbad34580b2a09b1c91e6d7aea0967681c63fc26aaa02b118a02801f73cd686be72a94e612ef05b787d71aa25e583b930e422f552988e6761f3c882fdaf357fabd26c4d7a9d880abca6a9e1db16783c11942f69717ff96c3c6b391b043487a80699c3d904192048b8f1f634c4d1925b3e557771d8de84683197d573896bfcf68b6cf8317c757bf04f5773cd161fbbc9df6f8741646bef7a7c1a9f7e2742fe29909acbd49249ecc3cc3428ff1c4f14c26a41ed9cc7c2daff8fae954751623739941ff5cf3c409b8e643ee8f47e093ff4bde2aa9ae32cca38a6fddc0f0f4d38f628447c7754e0de67a65f9c160095a94869527b67a9e8ea1b2bfcee829293c31e99a696c90fe1da96cf9078caefacd1bcf955cc15031efae8267fc8d7debec43f1c4311c0423eb95775a2f4a926e7d5cd083f5c7bf88875b4e102acd589df4770bde4f38b4662a6765fc6e1cc8250f39eb777cbd3442ddc3b7be4c6de61fa7881dfcff89584c7fd985dd4e588fd64edf0926c6107c7d55dfea43a5bf1349c59240c49d871e243522deb8f8866f7d95ba6682c348d836922e8cf743c109772df63ca49d2ae73dba80d4c8cd423a4fded58042979544d00a894bb495e2435685c12a62de714af68f9839d9c44d924fa9274cb22a235f064488fe44b02a7b9993cc0ba8b18b04937f3b80ee32ebb346a6ef0a4fd1f8a6304645b3af4eadd4b3a95c5ae70cacad1b28dec266ffd4f8493b9b8b2b37cd34b3c41ba4ab39147a922d2cd7adfc518a21755fad5dff751c0801709b83636f7c60aa37448417d1fab797914849297f6f6f0413cd30ece78046e881fa644df9ab773535e2980f83f86abfcdd33d30b8c670596160c64ad52d99fcc8da2a6d22c0a55d07be7a9bd4d00eb496071f351ee55183a44d57529ba55aaf9311ba9a6d1092731e6d3ab99eda69db6c0f6cef6295011924328694f6232b044e56294c617a49675f2ac7b87fb12d83c17a6e4d11a5d32568165e4f2f4365c74fceab7fbe185b1300ed667bb54f4b99ace2c7f439a50ba1651becba686fbe6b8a0083d90fe4f6f445cd47032933bd34ae1bf6826fbfcf271220933965ca24ef362d261bc2d674dbc7e16acc5d316d07fddc5ccbfea564320c3327f1bafb1050f1800e9bc0b0fd1bea29e5b5dc3727286939dc427d90f2a68a19dc7a4254f96be229e817b54643c55675e29f8d2daa04ad8f8dc6008360554db93dcbea2304f49159db8f39698da2c476985441e88d879640ee3472551fc86303ad52428066dc7946245767e851a62b292a3344c5d9f84752dde3e3380de52f73c08775f9313c98fc9ec2576d613c9b33d1b998d21f4bbea04872ece613f847b5a7fa8834e72ca728ae7be53ada165d45a7d2cf5806da008150a80e85c783a6344b0d6a523af2ab3d250f878e0985e77ee77b36657bde930e825321f115c1e344272b6ef489171e4a3d51684dc6d806c5b321da8511804030890117c651051cda27bf35147963ca3bb82261ffa559154991ace0889e5f693ac65dc752d1d879ef5e0cef446bac6a54065c42bd9bb03e92bb874f6e83d7c2e31b4cc6ba2cecd2fd70ecea66b4ceb11b923b7142f26f9fa24fe09ae63df7cc463a5cfbff33df1859dcda09ec95fb2de90187cfccac6adad75400e0a2a673acabf269058f4d36b59e23232780aeae0a64101f437ace30fdb8a2b653476b50119259185da3951be54c54a39752d792fe84fee9e20f5dc4abf9f0c3ff58c1fd11bb42929c3054cf91f5ea8b9260dd4934dc16fdd4e774239821e7f03daeb2abf74bc052b4ececaf7da967dcac59bd760cdf132b79ff62e6836c46296468a3f8c5ab033964fa0e664cf2693613684b096e7d27845cec7f5e1a75ee80aea321a411d5c2ca848c96cd0b71259b8c546a58be086f17e14521907f0eee7756d560be7273d992777929ac805f324c9a3ebc90e68495ffcaab5bf0747485c9b4e6202e80a0ab29d34f860cbe1b95a6bb858037b740235190e6ddc8b2a6e2145ff9f7690a118baec6bc28d7be0dc8c5df860bfd40aab2d09de492f98dc56daf2c95fb6c72fda29356f355d22f223bf25e382037ce8974e5cb3f50c3f7382d5e5f3eaa41decb2868ecc4dc2a0123bbb7ec769b47d4ea1cfb8099fc65cf03db1b09e7763d2ccd0d401f6776ad1aab738e222792b984b078749e1f7f86e7d8e7ed5c8d319b9a2745e1efb083637146fad49d4e047db1a462461b072896a14ca7a498e94bb8ddcfd4bd190812a8009d845caa36f4cc46194e1dfe83be35cf83b87174975dfa5ada34eebd196238d07259130a7345f816a1530d38f5214d9027ce286f65e5bbc313634ec95b5e869b3e14bce14f45e65559b2f01329ffb0f61623a1c7e3012d8803e8cff24fe54acebaae9dfa01212b29e15cb44ce736ced1fad5b52586b0cb24788117e23a989f73d24bd70b308976127debe35c1112afe3050dfa152cc838cefcbc89ba3b15b1038bc20648a1c2ea17dc3123fa74d95aeb0db4697522b96a5f4e82b270f471e457a9169008526723bdba5300deb8d560e3d8f3010dc805bc43f9aa057589449af112151d2a82fbfe729b13bc9d2dbe5fe6de8db35299f2d6024c10325658df6b0ed478209241b8922be11cc0c7c504712d342d6d43270f4708dfb7c90025bddfaeea7e55a456e8515bdde27a0cb2cbfac4fc1cf28dd9ce2b9ee48cdc0f100b41fec2faefbea56593e671b2121148d6bc8d0e71bad33e32b2862133377f7c701afef0f15eda7e5daef7ebf3c0fc4c835f0034c638c6e20b1135b9a2eaa2f7e3a7ec185c3e7d89227e385d47ff04cdca62975163d8af4e9820ccb76ada6751b5e4ad69424269e0c66b5d8441b10b8a8e9be2e31a1fd0453e665baf09c53de92ac526429037c511893891ecd0946258155df782de45c419f064a9c120b0080940d66d96da2676e829872f1e777b6adfcb078c71c95d8ec09492fbe694259e5bebfe2d4408435d7c30f61c44ce893984e26065a0862254fa89be3a9e2e244b9a800f25b5598ee945d2957364bca14e0f4d2c10026224e171a07fd879426e21b36e8772837a0f9baeed9eb81d47ee8063392accde78578199831f61b6e57ef6faa5e833157044a99be662108abf89a64c77f2a3cb6c6f87cd6e2552740d803146ab124c947ec1cefcb2f63859a56a4d0c5e561eafdfd3b2dccad277e135005d0630f8bccf1fb1b8265184274e389258766a16c5b262150326ae1cbb5bf212de2a17974b30a1d5c9e46920d0b25d773b057a0c1ffdc524b7d8238e8e7c2d495c85b484fb67b4a0fda5fa6f956abca68cf7c9cd91b1a03a3d52d2fe314dbc46360754be1764198030844f9576e7e5d4dcafbf6f45e8522eb8fc221537acddf2adba753b9408c8b4758ba4af14ed05835f79c4f30ecaf83d2ac5cdc38bb573c490ae526d057f42afa4595f0140eaf014275a9246155c2e46979f08cf23ee616e9403e95e72a3086ad908a5e21d933f2e78e9c6a603ba2f85deeba504b9dc16b8547e0a539e0f7039317f521b49eb2ea9d929a5c9078a9d8c97f8a00d172c3274c03bf15076768090b8d4f83213534aeb6dce46e2edccd0f89e2fabbc32ae60dadb0596e26d794a428ed910527c8bc83cd7e94dcf1776a5421c2e6ab7adcbe1fa0c8859667d777a9891daa350dce6d4772e79a0058a98cc0dfd97ba95df00ee137ac132d167e74f88a9980059c9f94e71c9f4630bab81b2f89edbb6d6de13ce11fb630619f3f5b377a4043e5bbf8ec5be24ba7a58094adf5552472341596384835d931c3f3484a12fab4397610ef723c9ebd876373f1253cd73321215397fc17aed6a1fd876a47a5c67932d661f419e40a3380344161905965473f36f079aa78486904f05aef4d347a4e41c91d4c239db8b3f48d8bd90fd4c509ba84b7b3057dc031a1b78f996e0d500276d4673c4d421dcc3f5a33615f33503defdff89ec906bc3547c5ae26ab959bd8a82d7289b22f28344beefd2e9017bb165d87cd260b4353e15a86978e7c2fabef0f6826e7eb2016eccf1d5be44b73b445ebd8eaca586cbe3d2b8c83d9583b99176faaeff3371b297b97768e63800c9650254d26e4b77fd79d464dee6398460c925d0aebdcf73799c018c0c6b7a6d91ffecd99ba9628347966db50a4a0d26fdbbd707de9009c83c0f5a035eb9fa8b0c62bb8f44a973ed26651ef185a2437259295a5c673707b0c798d6aaa95481497c91dcfe63cb03289312c4abf32499707206e8cdb249e1b1f3d472ef8be527fca6ab7c2d7663a5b10b05ff68da21af3308a28bd1d1bda30c3bfdd6e3ae680001fabf669245dd8316f68903325d6715116e8caef95dc4a2ad422ca643e5efaf76e4f5a48c2073074c5a2edb8372e0ffa8d858b1a2e06da9abe537b0345bc250123412b0c4e862008147c4a980d4c3c1f8db8b22cbb82f452646a6ab9e76bf0c31035d4ee93bdc0a2aa6648ce2857f5bd9d3b33287cd102c18ffa34093bfa3b3df1fb0c6d0ad77f24364540aec5c196a528e0a7370cf7138e619abd369f2415a7c4eeb1f724591b338237426e9f2ff624b84100d5a1186a1c1955524d9b04232bfe3aadcbec68fec8d87216ceebc7983b4ee08e15e73f87ed33bce4d6a2d3e018b9f4c317a69260e1fa8696e1afec41385f27ca0808f673bafc5fa0787219e7e9818dc04251c89ed880380ff08065bcbca905a845ed92192c60da55959d06fd06e737033df597f8e146cfeb356703ccef9090d65889e0b59fdec88f14e81530039be4380d82266880b057ee44cbbcc2e46f902ea0122711b2c0b74d2d4bc8386d8d220357acb2433482bbef773825801c30239aa6fa3aeac30aa931b85ddfa8aa402c85d3fefa4c582f32cec257b3c34a85aed604175b8aaab432a5bc78e55cdcf0a69e8acc26bcf344edfa979515d7d89deb9c397ca463c565e752797e92fbf3ba52519fc4b7fb9db7fd16e2033c5a7f62cab28d983e676c83b2fc25d6cd8b106f28c15f03a0ed255f41f3a6f87df69c181803c19f04576eb300804f7d96e984a3b3fe573cbf31ad05ea0fa31f36ed82c20d44535c517ea7b6f00988cbf328e2aa48e56c3e2837380cc8c9347d82954c41398df4fc1720cb33f9ccb8e5b1c0d7eb541f3ab2997c955779604dd0f97b40c5b15eae259af70a1533a5770db9cd9c15d1ad98376a946b3ef4398501b2891411eb17a85ce0331e42903bd803a390c36deea075ab07d0a8895320799727be9d7190d458a21b022bd32e7a8b66a45f630fc0703912a4ee24bfd2f09155a48772d6bf89834d1cf77e60e07454de0a1d5a429d056c8d3e91b35ee0b646a9ce0ef1e37ef7063b369b91b870df15bbbebb290e77032effdf852fe1765e32778b1ae19fc165bba2c170cdd73f7abe92fa659df46e34fddd10163ab9cc370b21a09d303e1d450c5efa6580bee676384d04db521d96012389581585acfa39fffefb4e6aa4837a8d04be0799c3bd7d4aaadc30da47a6c7b7e140c6e9ea6ada25a9c2aea4cd0496d39eabf35657b63613e3951bd86387bdc51433d5780b37abc9372e2d126cfa6befc7c5412886bef311f69dd9eaf5375546ff613b9ac340e67f435642226e9483a0aecf936b82b0065132d363ecfda5d4676209a20d6ac9c40e7a24b102bb5a1321a312686ce0ceeae57ef3c91ac9404a9bd3ec372f12a9586a1f96eea54c6cceadb9a40ad907e5c52936b1747186b0dfecbb43cc8e80563ad4fcb987980b55a61cd3b22a6fbd7cae5ddfda98ebf39ba1f67d38ae4fbd3ffba223caecda5c9741e29154bfd286c4f50ce6c30156cb68f93dffce3123fbf4a9d740ad7537e3d5e1082a39eefeb8aced03bec55e0503b264d2dac0583a6b2824631156293ef6d6d6a7b938025e93a62ff9d67104ee2916883911267a84e9b4a815bfb2d8096a155c7810f592ab6aca19b776f199668925918670d11adbab67a2f35a3a8f366ac8ce5e276edd23f0bddb4411f88a86087dd89eb5de5e320f5d229e1dfc7e5c5e085b361f6599eeb3ff2dec9faa279daf487bf587805f17bf3c0fb521ade3df488ffd1e2453e7c5470dddeb14200e33728a7653450697018ed31a0b72fcec5fae82321fbea1eea6bbc1318e2b0b93e472355c7f1827570db871c31dba93f59529192ae381ed1e06197b4f56c96019c1e2506c581359b348771cd0f93e5202a41c90a78e060979b3de364b1f78393f1c209facf1335c2d71d712caba803cc930a9866acc08ea6b06f90e587006cbe546a15fcad87ee97a864f8dbe05e7f75ebaeb7ec46e377f006ec861d54b235676768bc48e0358e44bfd7ebec1fede4c9cbf77799924e07c6f382a9a4e3f7e1a32819207987308cf8e0b5f455ac1be485bd2ae652d7f3f270890adc3614c66c751cc4650f5afe1f13be6eb2d29f8f1c960c83669f7c4162cfe21fb3ddeb6d62706aa5a5d7eae492250756c65b9c2093954e26477b7af37e07e5b5ede7bfc59a78c4900905c5117d588bcee74357a96fc6ea9303b26bdc18356fb0ee17d3586ebcc42adec1630338c5106eeed04d4d767687e7a47273a7795d2857241b50185e7292919a45d21ebe6a491ec2d82264b8dfbee8490deb546f79191d427162563a80e8d9644b3c976cc2145802991b936ca5ee76da9ffb1c839fc10badbc8d79c739a05f98ca681b8f1e0794bfc30c124770a9e07598cf2e83402577dd1aae5c057b2fad806f598af488244da8afaa7a447132be5e92887efd0431c4a6f0aa744df91c5e4570f4a2597c5c99a3e6ae4ebdcc43e92abaa2386377286d48fcfe898f3ff3fc7098a92f8d9f7c7a0e463a547bd00fa38369671a4dfd2082eaf1e47d575e9337a85fb86d82169a6983644313f4217853a5494357ac5c066f52883a3674c560d0b55b99d24d90cbf1a6202ef2cf917ca5b9b9f6ea9bb280f9b0d82153e238e02e24122089ec6cfd7290d5c6277f86f4c98b780d5dc54427939e68103419f35e4afd68c36280af7c7272358a71fc2a748de9198a587a9cf15e1ae53405ca5b598aea40c64045f90378d97ec46eeb28c1e36fb9e42fa9d9cfdfde872f13bff3619884d14a35cafb884b9d93ae31085b51875405533bed4bb6edc31869c546c6bcbc87a168931c31119104d9c7ffb73bd6c18112634e6a65545c6e9078aab798c996788e5adf9203bb61d080549f6d8d79355d621250ce8ebed3d3d29f4fd97b78f25eb1d827e580c600af01e36101b79295626b4ca6227d8bc4580b19dc7e496c12c398fb0e71f3ef703d7cca3da6eba5a2ad3d4c712d18ae085aa306a575e9a58e4b954126c5118dc76d656a81999dc4fd6359a52e1d79abfa4403dceaca77e8a203b3030430f74ab6f91e3a939755c932e38f3c057c2b376096ca2ba52192d825e55dcbc94685bfe1988f22db9d0f7a007591e78463d2482ef1a6a4cfd8b92fa71011c70379c953523e9c2589ab294d376518a9efa137f3372333215a4c3bdd9240460737fa7147d29443d325de9cae2367f3110b8709ce5d4d9ca7e137a1656968b8b644460cd3e1be22363f0e4c2f43919bf21de83d867c215025436459460f09951d72aae95c8c1d7e833caadedf59f6683ab0e335c377682a385cfde2c5f5ef4db185f8e10e1b2e5c346e302968892f3bbc21d5959e02adf4609807f0330a0e3f2cb4d059370ec3f48477b02823270f43a5f750b6fb675c9ab0f4716087e85336f4a37450bedba1d5d4b68bb0d335565d5cc7a378fcec5f3c78f5089ca75e91405329637a14edfaba2db4e41590fde07dbd2cb4cc7cf1fe894791e8f7345324f6a707509f2ce95afdcc47d40276ed984cfafd475ebe70cb63217b29d6bf370dc15c1448bfe53041ca51f34aed58285be0ada631a32c1894314c8d1ae837ecfcfe492adcc8f88ada5ca50ab42b527f4c6550b4afbaead49e95fd62752df8bf4666aeb9510fc80d5ddb7cb04eb1bdbf263abad8cfa3e60c25e7bb6b8c244b2257cdecd0965b843fec0dba44779d839b077a790faf83d8252421fa113fc840877b0134253578ed73a997e03c338283032acc3652cfbad745ec1e4ff096aa2aceedeae87946026cbb217ca99824394306b0b72a22bd21fcedde9f35ba0e569453a559ea4d3d289e4ea7d1ebef95811cf5d865d3f9be6da35a25b29b62588b96799d1166dd0bb3bd3d937c9cec6bd10a1e62cf32d7b02eaa00c262b131bac276f932d8f3241410081b38d516b09d27038fb49b2d8bd517d3a0931f2823be120171d48147532e30916fa651c87764ac8295ca8882a96dfd3a526e3f15aae9085005cd1e5980f2bc327cc1530a6f0c82c50b7d278a62d244aa2b078c4cce963b4f617d00b16eb3dc97fee3ba10d48637b2222297d69d30c03dfb2531e7367cf9f48fed4c5d43a5925cee55a3600b2b725c8ecc344d57a53504f726d79316a7684bbc42edec3091894eddee897b5a5ca0a79acb72dbae06d277a875dae9b5fce616039b2b13e6e93a44a217cabef27538c969f1379a694a728b4581f9b9aebb1407e608728def95c2c0f18b11b85f9321f76dbc83305688a4dae72cc74277d6af15a73a500b902fe97da4d573d5504d1bd207775887e79e01e3335dcc4a784d9dd638f5b81bac237286191477c5869d6346a1e12012fbad14beb590cc361de016faed5f5d2a42e23d69e1c1f9c49992be491d013aee30c79bc4d20ccbb1106a36f8c975efa4e09568262cbfc4247ab3eb58d7f3654919c072fd7aba51ef7fdc4abc3d46bae68fa77fe216cf8027b05a5643bbe34654d5cf67f1c9c8fec9c2bfc94a87b3569fe34348df05846ddec0a6168c6aae58dbea4f3c7966c218c52f9a7a4f02fad3acb41d6a75e6badc0577fc5c4fb15c606ebe3a23165a75e1ea4488d200f27a15fe307375c79fb19da0c90cc76a945d47acd0b14d3456ca1e574999bef490590a17b89f1f0973a038c0304a3b10938faffc7b59d3ec4d0dce14c742a051742e4be7c569e505473770adcddf109471b0f5753df620f8b979d34afb154891d382f66218ede77451b7224170f164927771dc46e8af32d1503a1fc522f692b21c9725a484e15c282e12b5fef73b07a451f91930293a228203f5ee76f8c806ea198d78ca4a33ae1d5605ec0cd22ebdb8088e05c6f17e364df3b5a6d907a44cfadf043010c5e4e9212a9e3f9a958187b33fa0d39304be7dfd1def3082ab7b7054a9c492df404e99bb26164489ec0e5fa8923a4562dffab1e49c75acb2fbdd6cecacd5760e939c7cb4742d967643d8b102724bdbd012f816a36c27470d6d0a384df9f792756701acd238ea92cbd1439b79fddd786985be0a5d3efbf76e44b9d788bc038b86dee08fb2619b6b3efc35ee6d223f76fe0a5dc1a0ea06c654428c31c6ba547eb2e33f400b34da17b7cd6ecb3802b145c39808947496896d163680e23d5c5752683483dcb707b013c48b29f3779ff06f4330fdae68022d0106beb774901912340de634147a1e934d87bf170aae33cbc4375520eb304512017d779414f966749f08eea3ef2de69f3807617f2f32abcb254c463c2bab07088f2713116edf33ae55549f199f900abaf96bd99ea86b996c3c2457ad9706216f3bb84db7ef9f17f18ea0e714752e053395961b1b2be54364ba1e6c6bcd9972d1b45f0e5f07156359fafc575c5e8f1b65bd9fba541fef6e9d02d9a20f7f9ab88c6360c6c31943a5a33bc50100638aeaf4f48daaaba7ed40a371aa8d80fe53e667e60bdf48d274e2819ae7afb7b91fe946418f2214a6f85af83082639db734431e204b240993f0fab19e488ba292b0e85e3cae4ed813cc6da15a9e17761d77b120ab6538b38d4448860d075ce6ef2f790ea7800cda61f4472e4174bc090d7e1783ea97a1c6cfd60f0612fb551011bb2198e916c7ac34f79f1ff24e4c868dc9fb27b8ebfdfa3db810c9d63152ba0de61a77792ddfc8a90b78c2d5879896b8c6dcfcc8f191282c35ae07e12532269fecdcc1603ed5ca6713bb9bc0b3640a58dabc81256a3effe4d813ede5b95fa65c93d30a894dc0e99b4092692ef5925bde50a8067288f67933d460dd7cd29c5990bdcf4b29e281a023c73b15eb9bc94afeff8f7e87d0f9bacd66808d0ee38eebacf87b269ae49232658ce90bd9521ccefd18699b6362d5a49605adae2ca115429dab1f67d3f6a76e457571d0428a62907f51e27d80f4a0eb32000271aa70cffd5164db7825a85df0c3d5bdeffeeda1af5bc2ea85acb037e45c77e517a97ee4d003d631edb8df5e3289bd2f9aa0d2af2f448884cea7c786573ad9d7ab57ef5c5a0d459d71ddb3f2f3f48f322621345def60f3904c8b1c8b867e857401660670f3347e58be6c656b9a581ffaa23df2f0303b538ea3e7f0990d759a313dc9e9512cc8d300e4e557623ebd2dfd0fb64368387ff1757688a0803a5db5227d2be2a535a1047970ff2a6607c88ff71790a0dbbc3bbb2bce5575441ee904de5fb9b41833845655ccbe7a1184d891618e750a75d4ffc7f4f466c91cddd79850f94ced923046ea709a786daa2315432fb40b362131446c3ed52627fe6532d1ab3f2e0b6dc8c51ed84339e802949225cb07a12b52da83fff3430eb1f8ff67f027d17a0350306dcf3ac4b5fb2568b94d0a43bef75d1e61c696ee53e6391b94f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
