<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b527feb09f617a27718c18affcd92ae985e53830ff89111d39ef3585a0230bc4ef358919a9257599af91e628332f0aa5a2b838c0d976f2afae2d7dae3b52d87d45d75be22e6c17983254bbeff7fed8cba769cb51761182532c90aa986a733d0c18fd2199ffd17e3b120998607bd321cb133c13f2e2df7552412dace41181f90eeed6b8494530d6c115ebf01a688ef2c8caeb66e3e5d55a22eec7b7a91f5032cc4093a7803e1938f86d8b7aa5e34bc6820fe4840b48f6530038277c2b49806f78e6ed0137b5b307dc61c86e19629e3723854a2983573fbb44bb2a5ac7b0effc12dc17c7bac66bc8aacfec43dda53f084cb3def8e57e70ef72c27c1eda85641278eef4d7adc36327919e94ee5deb161c32c4649a2eeafd66dd648f5068799cc816e93802b43c2314bc1e1d3ef56e849d09a3c37a9d23e936ca5708d3eef0cba0b29bfeda4cc51d35e40d678af106964accb925ed1a8da10d08d10a6bf0a1dd85ad0969437f1cd702dfccd207c2fd3cf59a9be03b97de441cea66cd7245f02e5911191f3238ae7acf9a7a833c1b2b66d07335de41283de56658b2a44c00f7c19fa3e915e1c17c53e6a34215b042b565a4628faca11d40bce7b9608aef4532f98fe79736514c8adb46ee6296631f3fcc7eae2f40b066de71d754c6c611b7ef85d432f4fc789e9e139f33c4988efd082f21463f4b3fc130a7a0dde975d209b4e3ca853365cafdd1d762ab829fa9c42346c9f18a87b73ddf1e69ae0f2fcdb970b04eb0baa92a98da5227bfd717807bb21c2803132d29de091500a15abf4b25cb51c1e00991f1ca7ad1c14a9184953b606a5357b4125ce470659d8a1e2c5d4c4120e2720bd3a19d62bbc6c977d073b309fd0f590d15ab66d69f52f00619f61122c05aadc7c6a6e5dc22c12452f58282703908ae58b0b443a745f0905aa76e6da4ad64ed79845acb6614978899025e8663c69758e6aefc5a645620e3ab7516cd5b2b69e32fac689734804d5cb195cd41cd8b7858c75f046649c9dd12c793680a313ff3d91bd8cf569368dd7837e355a5ee4470a54b4bab54571faca730ca36ee05ae59e52cb7253adcd833ba37a385406f5a7859ca5cea8b4506a2fbdd6f93aae315bf29695fe0097d816d1c87b22e676af2fac4ed70f33be5851f7989026b2beca8f5567ab53a9e505435bf21f8f3c06ca80c1260b4df06c3f243786e9a3b95d8417bc24a15ee1a27b00531c4710912c72951a6cf1a963b50d93f5430111fb41f9b8c839e0390bd0f5791ec3700884b3ec54a32addc024301801e25957193669ad9db6a812b312d4e2c3246bc6b1881b6761ce082f8a6ac802051155519499a2c8b08dc6e3b941a1c93fd48acc6ed10a7daf531b968dc4c21a6dd838d53eb38d796a6cb0d4a5baf76384b0a3a2419804e0496d3bb51f979a647d2c3b8e595a3e1ff6f45260c2676688cc1523d1209fd8fd40431d1a7ae005c1a39086580198946d1a0bb6356abcfe01b2b225d22abae7486f17e467a905a718ec9dfc27731b07321df90f526c238200f9d28585c0f73a776313de5033319375b536b924bca52b16e3b49e461ac612485ed460d23d94500845ff7decfac5e5e3bd8644f2796b708fefc94997b76f8514001977532b17f896f0ebb56ea59aca06c346f9a888aa21d58a3101bd5048a6a580cfb0841ced4903d52129a6d833c51c7936496d3ac443f782bd1f159de8b0bca91ead2dc502c7604978351253b8763e351ba6401561f1866236225627dbebc461cd084ec320bb3d1664f62121f986cabde8800495a3f6fcaeb6c6c8bffcd8dc71c27ef34b097b79ee4328c049da52ed4f140e518bb72bc8a803fc97edcc977518337b8a221e1d623916428a9daa11d1c75f54ec4b3d6cd0eb5ce1b3a70b01440cd8694d2e84236f8bab137a38d4a4bfa7b5d55328102b42c6255c77cc42a0d8c194cdf60dd2251c80d6b9af0a254735706b9765cf19d7e43865a988bd4ba15e53a515f15e3e604472d9afec1064e26d26e67a9eda321b2d53d4d8efd2b4237653256d73ecc2a29e0a308d80d0998bfbd5d7e6c996b2095525451c10c5f63d6d53ceb13839e34884c0e19e3de25fe9d0dbf3f3c1c914141c77a1c3c01d9382b7fc88fbb6725d4b41728f8434760e34399cf3001288758832e3522320174f82bc597a9acd72506f4844b04c4277a8c253242d4809f32b5c34e0c318b64e0159e68e617b565182f96749d0daa4dfd84e1686f6133815681cdc5c5dde4a86360cd4a761ba132bb188844cef57589f14e8919a5341c38c77e1607482706f42762c00dfb60cfbd0401e3d0e42eeda7fe326b541a74131fffc14579734c5c93052998554341b9b74749e013388020e5cb41fb0053e15a669bfae824a96ac512670fd854bcf14f9db084fb86a187280605eb80490c33c1aad6c6a6933ae981c06280a5a9c245d070c208a81425cb7fed651d48aba115ada1aaffbb76138562f1c859850e8a21fb252904bf27736716085def63eb95816e3e2de7460a068084e8ae7777e1f3467ad19753f70112d0c50bbbf37d0dd269c942bc5a5308f6a7989f4c530ef82b4fb9a57009f77800214ccfdd9a4932cc0865b33254370723ba84854a7cba91d965552fb1e36d0d4e3efa92232fd138a3049abed0ba6a35dc44389c329d171fabf66a4c014731bffca5492d075b53443ee499a0b7eb0eae1e60a6592cff47aa883a24fdf19fcfef795b6ae8cb63cf78ada0373218e3a9a6632c75aa7ec5a685a0dbd7a8080a644e11b5ad80ca7e8e59f13b4f69648cda2fdc453a4083e661365de4b4eab68705544e18d119a93db7371d2d9f9eec62d15127a465b98113e85e120273225cf676b9eb0b87b4d00a76d7a7ac9be4a3b492bcdf64ab593039cd2b68ebc6fdfc4c86e143895d33fa0554c7539930c8e392ff99cba76c89895540b21af726b94a51c199fe343c0657c0d6b46ade0dc878671cb547de3bac47ab307a481acea534bfa82aaea37178d24712b8fab98a3543ded1c4885dda84df2ca9abe54b9a13b1d7b4e91742e4748bbf9ab5002cabbc8ad091b541d0c8c400c397e9369b7ffbed408170c160b55fb614964d47c6677b8d3113e40cc7bfd417442e8f6aaa1e4678a96a8d9c8a37dd4d605c6a29b3bb5a31320e0cc6b5d2e4c4e229f94516bb7354e0a8dea71ad505f7268df375702480197684374ad4adff7142bba5d55cd93619e2a38e49224f7f8cf6bb7ea5eb898449bb803274e01dc4a1f1440019fda423a06de306c4a7f011455cf728d5f06ed7cec597ff8de3798857d21ee34c7f71e8d9fb0016d280652d28d93e45b83515526e798ec03eee708374a9a02c22054ee3fca99b9354c0784ca376e9dbb413666ea07fbf195b20319ebd4e9b9a023025e54c14d740940389617e4a6a1c8d14ec73c0cb9d74e3a7f8ab49e242123b418ca534aadb5adf695d2fee20f13cfb41efc2b1c89495319e5d2617dda7cc5652de5d6da432c8e56259354cb72b5bedf22a70c0dc574ba01bd6ca5d50dd2326be1b47c1ea990219428336b0bb8fa8300e85ea835177972025ee276d5fc77333d3fbb918476d643efd93e57794eb91609806493e0c5baacb5239346c3606dff00514c78e74109e28d4fa74d0112d6354b514a7872a2c3d5fd1aa3bc7fd641721c7e144d25f2825cedefb3b40b81393f11967b7e5f41b7e0667809940a183ab936ed63860957a38f3b276cacefd2c63dda0373114a245e10c26ed8f8c3c5e26bd98f142a90a2c63b4865e81734f7c5508bdff1140367bbbea9012474df341a2cc1f76429130f624795f8f56b590bc9ab48fbd5139b3dbe3df2342ec242b4c1002440e2e2406ce66d6bcb9aada71a4870768c7bac1494bfa6020f878ab7602524fceb3f9a8d83dd8a53b41c5b7871abd8473903df2dcf602ce73e75d09ae0ac5f71f86dde6a91ba26308e1fe58fcb7623f4ff406c617eaad6a82ef944c7b99f420ff3a14ecfdc91d7e5129fe7858cca63cc7278f09861acd1c08a0a46bd7fba0a705657c064c489d92de0bf21b5f8144e59099da6dbe69b847566bf7aa3bd5d3188ffe7a788223ab1c85086e49ccf4747aa66ae24f69d95ba3b7a452d94d61da77f4f251e3f818185ec0d1ae5cdf81bd221e92a25a7562a1b6565b55f55bbaf2f3a5eee5616a28eaf895ef43e48a580fcce6f67d8d990dc2ac8ed6a342366418288eb92c72a9f15541bc01ac69ceadd6badf21d1891607252066721f0f765021310903741853c8a06b67779f5efc6e5aefb7c7df3fc308f20d3df894a8d892009dcc1dba80d64abb857d8545431c0ca6a154b4b34e3c299a26d7d703f43a08b9eb4908a368020488be1321bb1139d7218931754023443dfc50d8eeafeed4e24f3421e804e88baa67ba0f8b93781dac878b5ed2e019ea4a080e0be43f170b4b5c5a8fea3c46467426a21e86b1ea8bc8cd6e9266d46f223433e542b14a7a02c63cea1b1a32f9760c38f34301daa59019f84bf699ca76a97e757f03ec4b0ec0c4fd8a360a09b2434e2d23a9a61cd9cc75c24880a361a112e55453f7856c87444817af45e8164aad21b8e49566abba91da907f048e36566f3fc8f09c5ae9ef8838dccaee1c0330d090e69ffffea3ce3c9893e290a269b934563d626bb4d7945d29ea7bbd872fd74cb83c450179da1aed4d21c8c12b9705913db7276ed1869ca50dd652e50af080f76182bb6603fb893cb9110d91f4a132993d069693d94f7142c9553636e2e8f0f4c8cd397421cf74d3546563594154d5271611c54c38e6f33a6a840e458fb2b7d4fbd324bd4cd04dc1b2ffbc04f9bfa72f2170a3526234dc85bc530696a4b996e270d7a74c0cae05bec65d1ae5d10a6f79bce55b02ba7e46330a911d054fbf475c2323d09efb8878b3cd8adf750f167dbcdc4158b1f105feb1cb9c38ecc3c1cbeb7defe2d4feb7653fc135f267492ccd2258a505f5d51b8f704a7563b905c5cfc352f5f6845a4395ba670e7fb653fd99c7b0f197750b146fe795e89caca72d7219dbe6c609113b63b422d337218ce60d6377bf2fb619a2a04280fb3f1970a64a6fd5ce4f707b61dedf03b09890629b0949e4f725b7b3884f92766b383ebe1b668e6d9e708c5b4eb4e40d481ff3e931519b27cc11620daa44192db932875042bece18127077bc17b0bc924fbc953fc9da9313f8656f0f411ba3ad7d09843070ef17e35ac0d8e3875fe30796703609e7009d30e496995df52582824ee7a8a04e3eb8ed1a65518a82e765f1b8c3d27ad95e285f53f87a5291c8a25de43f823cad728b0136779280abebd382ec64a357e06875426a4ca888e26c98d752f38c7c1c06c9f747b01994ef36deb3db82d51d38920a142a9faf5e6002af1031eb681d88b6e1adbe3a402a75a8f4959f17bc4577d5165eb7ad9adec58770d59ce1eb8110d96c22c6e89d9bc5a290ec7ceb78f2d5a2f10af88e6b4e2fafabf2b0624973d4685b6fccc42a8a6bd09698a2a6e7dd37f908109a8366382375547d7b83f0b35f110039ce89da269df0246ad9823528e14fe062b84f8ae4ad3f390cf3894fc7b86d3f07b9ff6caa05bda4961c5470d803f21439d445ad506f44b894df2484bf0f105d7f6de3c0c2ab462eb0c99453f54e921063aa3115abbe1877992f4569716ef7265ab1394b324ee328b5e3392cdf5382e99a6a5cd6cb25933615a5bdfe9911a37eaa99d843179967c921ae5e80d633b180dc20b4b484feb686160f498e10f14383e2b42e60e04c45d2506324506daa23afc912a0b8611413d24df30cfa6d8cbbf1ffd26e0a813ca0c158e742a33c569b68d6481d82fd349a346a25dbcded6d8704c59e6973cfa132952566451ae6cf9b64e614e7c35bd1cb0e012a2519078d7c0e23322c355fb470eeb1d3335109e6d3e89164f48aae6e5719ccb36920eae30b3e080d562904bfa6f347c7c70cac440395f47169707cd932ad6d217895291b48ca1363cf27214582013d1ee00160a12c827e8b046c67a52fc1bd39bc13f7871102b2aac5520990493c333216337f692c254f361427825b8100fa5d54745bcaa354f25194df4c9fe5b6519e49d1fbb182e4304c7e5fb480bed066a9017341ae008258764ea522cda1fe600610ca67f456443f9a1ff9b862138fd7485763f4598d5408a4a1001adfa5c523e2aa1fdff8140752c176d7aba61e615476bdae45ea5baf9ed5b83938789b0bd3a4409c7f835c7ee0fa81dbc70d61792ad7db053205383c01e7fc8f5fe8849fa7361700f643d1011b7cd021855f2c7f42835a92c75591856cd72c492fc64b82130964fdcb5fb6553d3a2679afb2b1fe8d9fb10e7d6cc75c932c91fa7192227b5099fde344ef7357702f6af89f520bf899d107220d061b54156c931866f645c9dcb6ece0b282f5a2558f6516fefd8e19202651cdbe80d3830cf589e81b6b17d9898107274dabc0302594ae466117abe4531713bad8fa2570e77eb5ba6ada8951661df482eac9834254de7f86631b2d0f643ecc45af2984646511f2108d68bfd617bf29bf0b479aceeeb5fb626c07f74695fc68e05e4016251e6b2c0aa6a9ff7cb72138b26ea333fd59c52df84a6f7822558f58f48806a87bc009ec093e0581d8fd4229108af95b82260f3490b3517f75844e92aa4d149a59e594a639fdce6c280d8f5a52950478fae0e4bcb2e1cd3108214a7a9a423b66b2bb3061637c1a6532d14798a208051ea1c40e1d1c7448b09948d902b9331bb33e8db55491d772b9b937ea75651e096a9ad7bef231e2dece995360f92e041ad2927cb3899a95e37fd413068bc3ed0fcf281cd373f5386fae56afc007f947332fc7e76801dede9f8bfacfe6f852dd01ff3d767123ce0f1e907f49c4532ccac81f54fc1932282510bf1ff318ea80509006dadc5b58f45c4fbf30f655f1a3bef68c33525b50708cacbed6f849848f44a428b3844801be775d56979d9013ebb2dea201c8f00d03f9088324a3c19388f1cff8b25241603da59096b5349c2d093affb5983555945a19d1d85b5e9eca9c4205bfa3c85687bd6ee032f245ff882e4f89f6b220028efe5deba9b4fb6b43859865002e59b87c162a76831d96f3b5de247cf021c74eac7a5713493b574d80605b7d927982c122225ad652f5df9f0b572a4443edb0f5ba853caf63a713d032f428cd247f1c65dc70a902082aa31938d8a7e74324aa0c473ac1832a694db05cf5c7ef64331352e7ade76d2f29489542f2d4a1b9dfc024c9a6fd723986429e437ba6ab27afecbff56e45220c35d9e6bdfc8298631078a0f9741f01ca008e41b18d6a64f1cb2451d865de8b5400db34010989ac71efa3696d7df2f273b69e9953678c66d67a6608ccc08c89d0b75663d027a9e718425a2218f193ac11458025c995df085a3f57c8da8aee618520c6d5fa8fc653e3bc4bfd9b08becd22d30dd6947e2fc0086742b18c08720d1d90fa1f6cea472ce2198190737e15499907f625c0da43a557d5646a62e7b73611246c5455ca3dde51465b44c69974533c49834b476e166ff3be12c13a72c80f3709c4640863e04a07757885c9da2352c44ccc3891ccade87fe1d4c9a5b6a8a7d94dfd245ad17d2b51faebe0e05371502d8ab8d76318dd70cbd6a829d0cdd11189502c751e4c741c549d0514632e2013b6d7ddc9d3bdb012061b9056d1695d2535b9bc8253069679d3630e934129c99747de086e116b7c7d7ee46856de26ce0e08e0c2ab0971c9a9658aa452e2aa4a4f4555822a340c8f6b5545e45be619808bf5eb846c99a663780aa88e75c0df8ec5b954e978d92f3e6c160d67fb5c6f365dbe303e27cdd59266819cce16487ca05af13d6b5ddeb28f11b9755f03770bb65235d696f509630ebc50a3b3bcf41e158810e3b24c87580f6efeb6c2d7d9413f146accd9f12275d4b86f1f9e32c52af6481c5bdb7ae59e9a1dd6163deaa07b4c4ae75d9ea7fc8ca2ec02fe59253823fd026d67449ec1e5e9a9f63677d937d411fe45e338d7947d4d779ad1e2e02d14b961586398b5a26ecd8da411d2bf1b773f4bfe285cd3708e87466ca07fe18097010cf97c0db77c035ce8facc0b1e2fb901205db5ffb9dcc379ddf808dbabd43adbaca3cce77464de1ea2932b31ce1c7581b4f439dc826659a510e8145140b52432be6d51cf6c5e99a412c3b80e51dbb092f5c86d24b1a1e1d7570af3c2579ad8f36cea82467840d45451fd3458c0f232c242c384158e6ede34c27ebdd7c7b4b4b630f24a541f394e1f0c8479d736aa1dba3557453002896bfb02fbe1304fdc712a2feacb48b9ee89eb08295f7a1ac5b4c9aca82209e61a8160e999f3ebd591f6d8c6b8ec6588f6785e30b34cef76a2e0f28bd4d098f146ad5dcdef25e995a4dc0f06cec15a9622f75de39221391c00cde315a690e8e192acd4da5d3a017a6cc4a7dd08378599f9e3ba7ce9722a515e13b75477fe24aabaad26f98eef474365d804524e3754c223b234ac9e4cf46db66928a19d50a7d2861a64d6dd94f2b277cf00774da287d21fdce68c0f789c4852c99a1006ee24b436669dbaf0d609e6daa4853f5591a59564b45cc767d390f634f74db893bfca0723626acfae3be352d326c9ff8f47bf5316f9899b0b03945cef31ae559b73978b5a8014050657ba475fb0cae70b6b02e5d98a33a4da97a78ae88b650a7f27e6f5ba54cbb557fd351bda36c2fddd16b8319a2a0ef664793e7f6d38930205ab1d875a0d167e10863fd46bc1a02b91299721fa577d1042beb4e4ad42140377d69ef518d7444d2c719c3e1c22db388c1773cc5405738488579c730ce0cfe5b09508803587477705733a8bced4651928d52add42a6a8549653aeea02c359906f1251f3244367dec31d9bacb65885bf90dbfd8826749e67f20e6e78e142fe5cea9fb4e00db20476e6039833019fc132470835fd5b1f90be32e61c07e18b747574c4d4ac486a59a2956b729b3dd0a0e871bb99924f7386ef4c0a53219028367ae9d7ebcc6c7805fb4f3a1e37e54ada376417cd27a170e275ec9b39186d37ddd9d2f41da5c8140430ec226b0c0d9ab69c9105b5e4540d18803ae4b3d1b7734d5e4fc10ecadc04dcfb45c9dd7a06cebe699031d88bf1807f6583eea36710b16c44d35e62f6ee9ef7cc7b11c5f1975166fe3ef08871c9de58e9835a6212d3a5084c215abfbdb2dac5a8ee7f20f874a6ea955a514ec869e8926ce6c133213995d8e24b84f8bb6058308583f11962cf6210acd865d5cbb99af39631209cfe559cb1fa2c78ed1a54ba6b10e48dfb329269ff5e95af1f04cde2ddc127f2bf4c87ba1e483f773b7b12d8b48edbc791a19ae757c9e9ff4a144916ff708a97da4b5e487578166788c51fe9c6ed80d10f3500860a44cd66b1f359ba331bfb09e2247a73b583c6c2c7f5f6c43035f162b73adbf7bf6e691199bb03aa355f0a2464500d249adcff670258b6a1ae73488eb901d8fcc61838d2451699959e82e8dedd3ae9d9ec92a8a2c2306e0c0d224150cca6519ea0b360b7db53b32cbabe9ac94beb623ba8d3f850fe8976e09611783e951d682ddd1c4f832a9dd06af9c1527ea610af1dca7bf80aaa07d139f0805c2aa8a2425cde9c10cdee76a082f0d88b6bf74373cdcb66195ecb9309c58052756d3836795cf6dd4e59a6970e8a363efd31a51da36356a69c05a47c1001121d73284e553bde5342f2308751df509e3672232cfa1cff4feb546d1f5775f58445784a519e7f073f1d6e8bcbb248f11037ed5a9b6bed5bac0039812605e8d8b0663aea93c8e8c352faea650c3def2d9d781f8a8428a0cdabb25914f2e6d44163c628abf35639cc15224a3b4c13c01b4bca59fed4883c1edc120dc93d0ec6926b49307935f6009868fbc063f81daef610b2ccbdb731f273a70dbc0322128f0fe911c221c35bea14914c2492ae7530bb60804fc7d738870c6b5653349bbe3377d5a2a0762c9fd6bb01c5a3f93b66e2fbf2c41eb98af0c1f98e27cffc5404270f654e80397c5440a267e2deaed4ca35de09186bf917c67127c92364f9b54c0e9e094fdf9ac1f3fc6637f805f65370667be501a41ae6dc95072af4e464591c7c0ed85449250c9a6efc55ba31c98d92574ebc5b9e2fd770e10ff0fa4431d4a281e4f403b7fe83acbc75dbb588d525e6753b920f36348ccc754d602e4f9cfc2e49c96a6c580557ecd4b975d4408906288ff8a2094e3249ebdafcb8f3816b5c0cbb972a69ad4d44ac3d35a86e6afed0406967f03c4ff725d1ba54a461f808b271d5544748c9c9eaf6a019ab6a7a010ec3419b54640645335ed001526b2502cd41eb317ef798910a50ebc4e1b2cdd1757e0b45e9c18ad0b9fcf2006c2a32d191cdb2ec075d48ca0098a57a0dc1482138f2d48b5ab74fa91f827829d5576ec6cba218e97275ca723816161e82447f021d57c4d31f658d567a756a2758e5bdb57fdcd96fba2b1bde817432298364b06fab4e2effc7ab338f765b7eb2d6fc73e7d4f582c612e5b2ff0d87d68e9935ae49eda5a241bbf16ed44ad6ff5dc86b44c3500ec1a8dc619074a2b99250ca7182d5e41a19922842d24b4899497a5cdc24c5d562cbed885d22bcf0717d36aee08150d08cbcd189585f535e71fb984501f4c629a238f733d203a3ee8edd9205b25b31f4caee741ac2c76bcbd28491f5500fe4fb8570b9b589c1941d21087f380257ae8f67139b1385a23f49fe3256dd278b43751e9bb936f8d05d4afb9dd3264995d46dccce22bda511e20e88754664bfed006a506db6a5c1c439ff53727d94976e86448f966abbf772e9456dbfa335d5f60626c12e6b0e7961587f305defa164758a8322dd2c694d735fa71d924005c2477ce1bd76326f871591b1150e9277d60ce73bb770ebeef27f91fadd9e4272041368bb8717f82759bc8569e79f9328a21ca5600b74ed8ffee9eb04dbab194abf6be5282d33c7292c64fd8f641b0cdb2c0411fb3913ec33e034a78a1e33a45532e9c2a77785d1c747891cc5860d80af06b3b5a7eb437f999c93dad25e3515942c49966bfcfc3713555c9ff879b88f4dd2db7ddc8c87284408b29ec373b78237b306b009aa9c656becc82c45c228731e98e63afd8769134ae959934b7611c8baeae10849183244660bf07d9dc0d5513338ac36264668d3bb390001875fa8e8613b8f2918c3fe09e9e34cc7e779a31db9dee52a5cb95356773a4e0a0f962389504e2d3d7e8df73bd96e9fbe7ba367fd0c53e70ab469d21f6d00a025d7266b749b8fdd02cc48bfafc1364647e85e7f384c7508232a1018b67a2152662479d4511228d2bc244dfc9152dbb29e10acbb8546b60d7456577fe26b0c3a322cdf24403d7aeff2f0ad5eaa3f1994c9e28cb9c2e95d129c86ab7f4dc4c5df15761eb3d54bbe221b0d7b3540b9d62b6382479ba61f0d890bcbc25249264d2f45ca1d1b15ea2f721c0d50afb14077448e53c7b7aea1e47abee92e7fdd8981e85fa04462f2533c4e986b5201e3f31256cab9cd0138c61d8e55663b61dd20f1d634ab763534bcdc426ce0736ae1d55e8da04309762e9d7d0080780f6dfb8e47fcc36ef05c3f798616f8196a5d11a303453e2ff096091dd12c8b99ff652e70ba9147fc1ec452198fe1842241ebb0355effac7fe88b00a46b6602b240fcb584243d7816d4dae947c63b0672ae5bafec21b5efbe25155c87e8314f02a8a387b89999e941cafa5e380033e26d6325361dfe342e99784320a956c6fc73c6918c59b50349b6670873b4781e3948feeed662ec75da4d1a0ef9afc48ede74817e618eb19fe01a7e8a2a1f8292c2927522f10f38c5b8a9237be98866d74770c877559a606bcede6498ed5d564ac261939146292fc991157584142695dbc7fe39fbd4de6a1f87ec880ed03b89c212f50d8a58736b9b81b3c73742031808b4a6851529e17cd09c5d34fdf6f3be4db284a8ea26ba13b91ff18abc12b36a78025ad9f5bb9864256531436628afcb1dbfe73d4675ec2097817472a8fa4765d790412d8f40bb55169ede816de08303de7e73687240d723e4ac2fb4f82abb4cff80ba3b46fc1fb81df2dd9dff4f206a6378b7b6f7373aa50d19bdef2f6be558b8f2644f954c633ba5889565ea712207466e757d003fc1fa530d5af89951c7892755f3aa2bf541d153e32be3aad0546428fe4ca04351536a00a5061f51534246d46d7e6449a300b5f1493f013342cc0cabf15c307846b212d1dee3a6ec72d773e7ce9783ab2899cebd36651ae86917faba6363c753397b6d0faf153b7aef69f961522d43f9d44e020f3203b02bfe6b95dabf332ece3fd7c62c6ab28e5c8c134c1e34e53a19c4075624c38645a7c9a82ebebe7663b56f740fc43a2121eeaed81a044f77d6dce792ffc241d330628ac9448089d5450a5778bc8d31b09782cc42b6ee71a149db05f6321989506b57f7fc3cbaded9342e9ed72088b8d65ebed07fe553b69d14c1eb68ddca0a23e91017d89831edbbe0fe399697f04949a5c17e71df8cae0c56dc6b1f37305d38ae8dcdf883aa5ac66c8dc880927585bf9f89f4ee15a77cd2b51558cad0742b161f5aed6d08ae03ec3f51a26c63f07a180de81ab8da1d2fda8fa580305684366e8eed5d47e4c7e9eb2334ade5a7d7224a2e3c3156e4fcbc22d781f7c8f7782f1d387e88ca53537821a6f5fa7c818650b99797f9ea18ff5ee82fe25ee007e1894a11e2a3785a28bcd3dac1907de53112349a933d6faaa580d5cce3fc4c4bfcda32ede98232cd1e46240bdb3487c1f2004833186146c3b9a4e5fa8acd84e5b2f3f1b67abcac455a78395483a67b2aa030f69af26b85d406e117abc93c66658fcb2e6b5b0d2df4a80d7ebf02c1bedfde8b680df0a771b30e31ac93773c9dc0ccb045a72f9614edbf6199d247bc7b67c12c2452d12dfe67bdb42b65a6bc19e82af62274ef7cd8b88ede83da487f33aad4af4093097ee7f0006ac9659f5e5ce74081b812f5bb135e4ff3ab8370f36240befcc11e02f8f9f523b77e4a306d25843b5de2890f6191594d8a7420ee898d4d4113914c85fa8d5947d484032e8b6b4e005330f7659845b43aa01fe7e61b9f9ec71eb2bed100ad3a6094b8bfc7ffb6c4ca2872ae6ec5358251cf9a9dcb01e71abb297289338ea8a0b5a4eae320c0ab27e3fc5c82d0e5ab219ee17d47957c208d1d9de67db4fa72aecc8d625f0da785c8246916e355432a73d4f1a5f6869717d6d2129f97046543ee3b7f0014fe3d53f9bd80bc37f03bc928d58f7a0883e9c41c70a5f49a3d987e163d7cce56715c8fc2250bfac03866ab1dff082a08cea8ee0d1fd61a6129036c26f3af47b16a5278f5842cc78150adde03eb2dc6d3a69ed4373c82a55cc4d54227165e9a2280219df3c5bc7e53c379ceed9c468765f91307da70bdcf9d1b23739d10e6fbff15319cb0793d438c3d7abaa40923edf438f50213397d0d54cefcea772048a07ed7b8841d079bd8220862b3e6ebd820f07d1b1994a1445d2b736b32d337bd92e243f6ac9934070581b691e52af41dc722c43cbef43b939091bf100f3242e0cb8991fdec48b9d29b3ef17013c9ba18fc39326774714ca8509e4ce77310504904fbc457ae4ac549db2d4dc5a2a15dcd37a1aad0e52ca01b51a2bc1e0eb37fbcb2505b7a9882ce2751cd9a87dceed8a861350948ab702a2b3b669bf39a6b066940a7a29191b58a8a4d355fb742d381250ae8298c1f12d7e4d1cd7b21b3bc46b46e7121af7538d8926215b1d8ef18b1f5cbc2796c419ee1f4f25cc5f9d939ee3e1c161660e9cc3d95972688e6191bbcb8ef5f441255d36b8d62e9222e4af56c1a5ace7321c7c299d99822ca33989162fc49da39f405a2cead72f6ce0f8f383b426319a981ec502c64462da80787cbe78f4937e0c50fc0f3d6bf3b304382698ccc5334bc466154eaca275234b520dc8851cb6955c7a0def64e66f2892aafeaec3a51fe3f07e9012c1a1ee15d18072cd3471a8eea80e08ec7219adcf71f5c963e9569dd3c7dfe86be3222cf7b4d4b0c94ac026224faf7bc6b4d47fba898f6ebdab51796ad596881c9ba6baf1d548b21626a9a2e155a4af8949c35124c97036578cfd4aa5be62ddee5883c402a37462ceb7edd0a14f1ff32675b01099dd6a05b61e83a144b832e151107b729c9d2a13066f702ca507f9fdca9e3c0c37165fe5aa4d6a427eca47bf6808493bbde87330d0a35f81353f82191622bcc713b1e256cd3063b09a365b8d862dad90b9873ed6223b57481fd84d30929f7d2496b939f936b612cb724226860e4eca3aed326afb4aa398cf566e4369f408f38488bae6646d74ad33a74bcefe26e5112c50a1f977eb14f6da018a42e7cb0826ae3828e2415e26ebdd92d46f7dba51fbd4d495b8622e9f6ed367c73b491a550657c69d2ac3275ae4062c3f1d333eca976573aa1eea28ccca59bd40aa6f8133251a6030b8a41aef0fb8e3f9a10f7a3f4bd71af5195b691f7c4dc9e9dcf37cf5b553787885b18e90520b93f564f29f9cf511b8de2b171a6fd4f5ef9fddb3ee4b741d5c1239232c06182b853a159389a6e89f6d50b18b09da29fcba077c42409ceec1b58319c68159d1162ea724ba3ef165d5c0276ff2a8333b00aa8ca38f59c67b44155a1befbe68ea2292885a379777d7e878ea9705bc875d37fe61eeadcb8b2172140a504a5736d34e04acb48a62d7871bb5dc5f3eddb67751fcdfe9e99ebd2265715b407e2f56e4ebd9a544bda96dddb6a0dadea449727bd962c40de2b771da7b9fe9ff60ac74d2b6c10397f6e2850c5ad7dd6166f1dc903efeecaf57b80a1acdd8e66f863900c1fb975aa25ff83dca4730027967be3ceb608707e32003e7e776c9c48f771e3e2db835823e156dc242f687d5003d7352d66ce5cc686fd09d81f6c7798bb90115ccffd3093343ce2da8119dbae62dda306efa7ecb71f545ff3be547baee899700d041b0f2b9627df7628240d5c5874eadc82e3030a5128cfcd31f8b99598dad07b00b645627311e149f6d6ca28e9353cb8e42b2b5cea746f3659778606b4bafd99504284fc628e1a2079519ea4e19609471dc5a257f8cb611e5456f583d01fe697f13df481161eb1010fc737ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
