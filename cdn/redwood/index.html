<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fa0b5bc4659726ece33450beef23d12dd6255a8128460a6bede2444111bf335196513534e23842aa68327755d4186957bdfd735a6455b3196da99a855e3cf785c5c508be5bae452641785832be62f44dd33fbd59317a8b1ad8d653b953545c8625fc731dffd245947ffd95a3c8a6c2d54a59c559574f3d0081f439c4ddfc4ed492358a368f010344bb8b666a08a7af61e6d9b1770f47d2afe2e64cc1e09004a470c0e18f663931850ec4a96f240e3afde839bd575b86a2f057c6447d97a04edf204463d438ca360f065231dfbd0ab5595e3c432e20724f9d8cf292a83c2895e0d360497d7b4d724045e5fd08d682303742fcef07bcf88f3119e548f0930541115d8f4a2a7063bd9f7827e9b1e2271262b10eb67e76e1245f3cdc74fc462b3bf4f752281555c3a9927585409fce904e5ee089e2fd42f91bfec086d40b1036038d6178108c405a4c64590a619e4e390e930a433c6d2e35ed023965228863a95a8964d563ea8211db05b7427148e40adb8e05b55b03ff41de19ab2f7b58cafe9dedc6eddb2670cbdb5c0c97b95d84ef0f22fc525befd692f6237e4c5f68a511ac71803b8d6beafa3f971fb1730429fe6999b40f17da6ec92db98f98fc76e917e99a37b171cea001c0e1a3f849cc7928b1d7ce1d4ee0f36a19cd6bedfc8a102149a90d35f016e7cfed4d32563f10c0d0a9da4776e053e741f70976c0571f9aaa8eedbc4841a4a7abcdc85b27a1ca29fbd272b377c323ea2959fdf9ee3e1a3f4802861c8bb1536d35001cfa4b29f46739656c7feb919a61169cb5a194a32c369e1ee2cedf483b51caa4adc610334f61a44e2112d051c6ff12620b4796e343f2e43de6b29db9ff252bed0de2323ceb9f79c8d2a71d6d0faff85c22480565dacd44b6466674d26666def9feed58012f4ede87825dcd98929917fbe7c38973722820ddfcb90ae8ed03c2c83a802e56208b1071779a49f1663f541cb6e84c33986789105b4a80580874c6b98b8c24f93e9fae8995c32132ded750213015aa27ec40ebc105191b8393744839ca5a5294c9b47b0a79406640a96db7d5d37e1ed567da3e037290bac8d7c54be9adefc108759abafc1969d13edce6a909d9cdb6f96507e13699ff45dc59d410f83d6e76c27c31bcf81aa6eaa386ce81b28b1166c990862e84aaf9a5606a0797ad962131fabef0b5c5f71b3c78df34985880ff8a0ad4f171ad7954ac61ddc59041fdaa02e725b29bb0abcf580791732d3ea360bf3b468b9a9da03669c34d628b873604864a0acb6df544f657ac5eed5c4d652be074df6bcdbac7c0e444fda8cb51cf8721e9230f2d48ad470ad50f8044d56f5995023e3ee136dc68f0569bc06e6f3e20ce0bc14e468ca46a0195843d25162b96a3d641ef310cb3f00562947e9b7f83e69549c4223af35a993ecb5c196ea10524b45942f7c44ff3719db663324c24e686ef8f5896a81830ac9cb5700091be7cf217ecc84f2b6880e378c84c1d1399bdaaf8476d60404d0aad10b4f4565ef59b233d6428432bf42cf2511418f28ec596600e3a46dc1a064ab652b0264ed3a8fc3b2773a9d6381c9b552bb74c3fc1c6b873d8aabd696d1f29d79d81d44b67c13ebf88465f981b55841732d01d2a87d4efc34a023fbd612fb7c40b84efc14ed8ee2dfe3840abbe4007981fc316ab0378b584deead718e78bdf2b3fa87d04648ea45cb006e7218d4e0b67f22201ec76656326e40c58bd1fa9627a42aa573300ddce4906104188beda6f7436ac34c6de42156145afdedeafeed72257ea25b40587519e011b547c6642ed16be23b5ac6a352eecdb46ce883cca8c3ecc98c5d0cb56a6592b58efec0a0c40f782dd2b4f0121020ae4e5762ab6e7e344c766f4433a2766df35dc8431cf1b3d153b028f9c59656e893f56db38ea02f4748dab0f476e07337f08c47a3aa22718aef7441f1dbaaa3848422ca5dff96f0cdb173788da464687bf05ed8e4a94ae82c9fecc5f6862501867050ec41deed77076a7e2a2a36ebf878bc4004ae4f4cb9f30c64f42aa3cd76b97c2157772b5e8db63babe870ee7e4969744528f3ba0b4fbe106dcc450dea6fdbed307af74c063dd09280113e05812f2623e2988cf205ab602637d8223bf2dae6219785c828ac534b25def9ea76372731c5e9826077d272ed4f3fd28c5a36d00573e6de31533f91871a19f2002c5c26e02cc052ff7e1d693d3ac213c0f98f4f9ede5e4ba4e366f1d380a6b732796280c6630c67d03770513001fdca04ec14d1c7a1512c1602308ff64297f8f174fd1be707df4261aa151d5a51891e2fa128d28d9a10837d41fc546d32592329c74d88fd2cfb641ff3d829d8a171ba27396d6975fa107d20315c4494e21f40c271e4d3ba78f5869efff2c6a233eb8ec374ccc42c5b58738eb91ca7cf22b2ef7f9f5d1a5c80db7078c1d1a913bdfcb4f0da3d87639d3c5a23fe98eb6b1dcf80d2274518ea6e565f6e967d3edcf14a72f4a6efcdab7eb9f8717c4c4375a00b964d42cdc670d28b80b9ad823e524b6a68d762c114fa0674d2f2b38047787f7a3f2b65e0da940101267db809b71efda980045ece1800e30ba938b8f5c592b3d70d117705140817a08a09a3a1a10b711dbd56897daf508fff5ac6fe18c3faad62cb63a411a794d9d922e20c74ec3814689367367cb8a9cabb959db0f8338e68c52ea66f7d6358cbb2e20076e8fcc1aab7bab97e039e9eaceaec7808619f2c03498bf614ed88ed13636faa656e964f36f1bfb6f4a955a76bed4142f4290b89da46e7c3ce2cb07bb18ad5d1cec269faaec85ae4ec04656063763075e7eefce067b222b2c8f527b58bc3d9ee0bb25e3dfaf62a0e92733f7fe3aaad369e22587d517ae205b88549b8a5b81623a3c6d69903cc461416e72c885c27ac4e5e7f1ee30adfb373dc78d62d8dc89e3abd49924626b5ee60d617da501f8b542277ef93f5329529bbf22f139db3234168948a94d0d4f86961d5b77928e3a1a2c175d30bbd5e84784fc38a51e7bb1e90f1930968a307bd522a1d739f77c85a77cac5b2a5aa5ffa888014d03b32a0138371e976153743536efb950dac76ce57a7bdb188a0fdd31ae746f02ef8826910b12dd46adf3556dc41eb7225389c73d33b0d1bebaf5f633614b263a4039c741161e17ea2ab201efcc93d87d42e6fb883c5c5196851c455b9975f65793052101eabd80de92bb536b1b82c9df35f6e3a03306cd19318c242c66cfb54bdbb9c0f405259ac7fa5b04dc768ab505b410e523574883a034591270060dab152172eb5e60617ff76d53aeb226fe6e6aaba36500b586057b4749a41af2b4a533569b131730aea6e3dd76a5acddc99fdd2a251b8435ee30298cc7e34aa86205c0c9dad267129cbe1848078e57f181f8eff585f5ebb16361840de5092b1c4b6ebe9e2e9ba642885561f18fe3eec6580da81c240cb0f4605b1cb775bbcc7241f2a5741c88ee083b9af2f9d216bb067a79a3b4bc7848532bc157508fb0faa912771b4690c2a31fa6493aab95df34c3759fe966fd4a3b6a7a44a31da7c8c7c29d5adb77b245e1002a5479ab917c596f031f29ba7ed915fb7627b4d1b28f4173b9b4548d1b7bb4d50c2c79f9391f3e8da51bc2d7cad52b0f0011bce0c12df307a626ce1aa43ee7827674f5be1c0eaa5128a63de46c5364f9bc12c7fb367637e021c6534866421bba8959c348a26138e9172c70f210206c947fa62439af0edb833a6fb2d26e658d81f7d8a66a1ef15009925f4ed971ce5aadec5f9c7b676d8a0637f12e85bf0c326b2725f10e1337b356cd9c12650da8ab519fb8717fd5fb742950eba03203edb3026e1b7c360f53471addef3e4258e8c68c7b6a1ebb43f2f660f4b5e3b1121aea4e20426bf4423fdd4b1625da9a36532e686466cebaf652aa3722127d10b305b01d02bcf6852ae984bdcaca9c1bbe467d65c9a4cbc3539a1bd2ecb0049c71c0176b038712f76b5275fe2d6adc788ff0852f7698c3cf2c657e35d134e3b320735117c0b67f47859823c9444cba581a86c973f867f0e39bcdd90fc4e3c120883a31c50d221d26c04e229f6ef60d4477f969b7445adeaefe493d86fc3eb73851f0ec48047759b364a6e551af0bb7aee6b5564dcbc4bac3f2ca69507e771df1b36c8d95418f3aca583700ac537553b025ab72c93115b8ef4119d44b55b7513336327ce56d4871d0cd99316860eeb6baade7a7bf010b6f4a789f9ab163a8f531f2aa5ff5af21c7109866d35826f592c361c1d7b7ebd2a649c6006f5c79f1b3c6cec69f1b33d0337eb2ac16466128cc853a7c7b8b55874259846a926229f54db8d0ccd89bb52fbbfcc2b003d346d912aa89373406c8fb66e6fd11ac4cb2cc7769a0f4424a974ca3fa26ebb8758995cb8bec8c9f7fd85afa594a59c0298c632d830e76ccbe2fe6559c2f42c914ddda8e41de81fec0ead0fc342f25fe6305370811a88240c3573b916e78b83bbc08d4aea17b1f24cadc0e58494493cdfd7bcadf2220280f8358ccf1a1971e077e70d47b111831f708291baef25abcfd386e27710c8df98299ea4f961d3b711cc2595fb3e2123f8d35736d5e88b1c3d9dde3084d04f4ec3e433eaec5611cf32ea9b5875512299f70ba4016bc0f237d33b9d3bbfdbc7611efa10508ee90bcce5cd4ec4e60ec80cee30bd9a9b4b6ba09e3bc065095cdf1f86779ac38789597973e8f2802637f2aad501a988c40b138749683f6d0b2a6031b1e7282abd04ceaf4a147e47c9fdac4753910326ae7c1c8338e2270c6f4d0dc9ac2a05151a5149862fe10d08db2fbe365f0f9c2e6430a8049e1c9563c92efce64560debb96523c5387294f98bd2c5f4c1dfd14454a7dee7d4e87f8f239bb52fff82424abc6a963ac5e82ae55dd257e7205f0f67f90aa85be9a54f01ae7dd87dc17edb6225a5cb65c0413320b916992464cd64613a1ace693a69fd7e2a3863bd6fb4287c573f2128e878eca22f861c8a044d5a3459d5dabe9c9fd793830ece4610b2eac5c806a0610eec686f30341a1ba967512e8fffa63cc5274a1a0c7e31dc55056a3a3d14e0fe8876c06ac44da54c95adbe8aba40b265ad39a54e37290b3d6bab9eadae55e8e2a31510827530ca5624300b6780746ebdffff4ba97442f6a785694818f892547f6fdd4caef8a81c1841892e679c27af894b9a95a92b6dfbba4aeea80215cdcc82ff57cc465a5918ef61b1145e2507c8ff583a7201b685d5a27c1dcfd581ad838b5172b2645610b5e8c54c1b9a0cc150c0f64da7d6826bd21de01707bbb9ab7d43ff520808a570119e081e427eef49581fde6d7affd9009e52620c5e23fefe06356a70f4d756df9e84b093a80f61f7aefbb3a11c94c7d09899cd1c9834aedbf69bb3b8e63e4fcfb1a6d65f807d9d0aa025c3672f2d98b9b502a487ef17aee4f50eba4e011eef530ab84f4192afc674c90302816c23e9538382d8868d0719b42887504a6c29402f056f86a55ba1325ba484d15d41ad6e7e7a48c96f5b09cdb336de9d6bbfc1674be347abd099d91ba60b6fb542dd664124c8f589637c0afb6b2472d70a3871c985ed40504f5fc92740d5eec520f641914009d073bb36f1619c5f6d0a937880c44f9f0dbe357cfe9af194d20c35c67f19d0e439559988fe1ddd035757588d56d92f625457ccecfe8e4101b7cbf4bb991691442b0d69cd8fb4050ca379bd9a8084404953e2b790007d1cc7cf103db38c5d30df9edc41020a96584bd53296b8b8bf6764d21e3302347a4bb2b510cad25cc84f166428a0efb8b045865af1ed6583b1e08dcdfa90a536e9ba79a19cd2a864b608c837c83ae7c7a1a811564087c9a9db518c529f213092589a608ca01bafa687fa5ef71a26d495adb365bf4d069b0db6fa0b5c8d5003c86ca7224be27c3365e7e54a8e823c7ea4c98ccb5b3f8e297cd336ff55e9da3699824552514125ff5d238fd4ee4ddb27b4bd5ea1b901de1114d6168fcb7f29334e414b8197d195c099eb725dd673977333f87256bec30c1382ddcf52ed3c8f46900f875a2fa14a4726e3d2672f99c5eb052eb2cdfd277a639dc519d29423be4ce6105da9e901562add3c408ddaea19fafd72208dbe6d02973a59925f0f48ba46f125c5dfec1ea15b6d03df771ba55969ef38c3222a2480512f3e1d18a41ceac6bf6d746937a47359ca8edc2f8a2dfd3984c4d37b17cea39e57a3e07e452c13f427857af2f2afd5cd8d509244e43e9aab7a938ce15bd05e0d4d00d4fffeda7f746cd4b3269b14a62eb8c5e66a9ab2321d1f17a80ebea12bcd4a774e0c584a123f658a841355baee6d6bece6f80090ca3e808355e57a58203d5d41d269bf43d878b23f64f62dc0de8bcf47611790eec2acbb89cd6cccbfc7e5cf5d7869ff8ac0df44745577be88006da1ea88849e778c83b6605e058f6986a59a0764faf544250839a5b74e6a4c636720f402ce96051bf8dc26f8748447740d4f6673ffe2c83922c9e41c771a7f3dacf2839db15bb5ea7c1718583a6c35c7d074050ff942db37d8661303b1319369725bc9173792910ea33c31cd05bdd92f5ccdab679a1e89e7c51e6cd25820d9e40fcca59503965c46ee66f0a758853a73fa3678ab363bdc59435f72c51803ee7908cd909fca84ad2dde7ceb40b20346f600af7677fce0f7fc504495a3b01567872fdec8f073d7e65d4db1d7315e81348216a906d3121907209bc7b279654750ebd17bd3a0eb781879223120b094db5242b101f77feb3ead2cd61fc9ef760792c0d819ee59799420c746991fd0f33a21c6a9582c4505f5818d1db69b5f7a5491348dddb2ebec716c67bc1b3a96583721d2c000991628ecd5ada4212e2e4fcd61b3d923437c618059660d1900b7ecb36f046fe9fab7294a1658941aacd0d11dcb467b53ff5c1d029857d0e2840874b1f5664e287bc3329ae7b104efd26944b32417f490e4ed138ee85132b0300264c3b571e897787c3e49f8200e69066b55d0a8b882a15f68b1633e2439bb8156d896852b368f03b89761e7be2d92e3902ebf01dcaddcbb1d0335853992279393ab62fd47a1928a15afe2cdd94b00212612f61e98ea9658bf63e55c33435d5632a94640fba2d08e5860e047712719c12642c14acbcb8ef061e71854756bc2bd1fd444917bc5f8d6247eac745e5f552cdfced47452f29c4f53e20dfaa31700dad6cf839869014c17da7a76778f5f7a881e60bc75e832002ca9c9808852fc0be362d6a3bc8157d3a63d25cc4e38e379eb566952dd687179b5f20a468dbb242bd054cdcf33deb2790b3df87ccdef956a75d32ec2557ca23c73958375a63d5115911da10929b706a21729e1e3a1d4c231ea4472e950dc5f4f163dbc2ee62eb2f14b3ad8f15504810550cce233585e3eeae7e9bfbf6792b6d581bd766746c9bdddb5fd46b89786e07eaa4333f11c71c0c84f06e938787f7d4b95413d378f550e3d487c229ca902ff2e1e9fda83abf56d610970889d7f89d490e102bca477821827711a47d5a68a028997c500e187401dd741c77c6267a45e9affbbb55cc21c36e876c1a572b574e57d8f75c0afe3bd9ba1929b4bd3c3bcfeb404941f715be649d4c179d8393fc9720e6b6ffd55470bfc6860b03a5d64ae2a5efe386aa7e3ee205d983eea94bef773d3d88543174456dad09be096a7dddf05db04900b95c3bc5cb1168ac250f88b33e9b089bd857f9e85699c91e9b96b0d9a34f4e0b0df1b4eb290a2de927ac5625a69203f4bd8286d037336ee5e26f720c5184542f16759f155a7a4024429f56fe08e246484d4dab85740d7f1a0d5bee0e2886c93f7af57781463ea75e665284813c0d2631bd76530c3878c79f5d32ef2407c8921784ef53d0b133d8db62b98846290ff7e28abafb0048b6645809cc4f25a264223a968c87349974185f14067aa308a55ddac6e8112cc3187bea9a26e1defb2539f6fd752bc93950dc7933ff2d23a9f5c9b409627cee7eb27c4b61adcb0e3767cb6be5a31491f03677d714b0d32a64d1d93edbbbd65fe4a2927ceb6c1c48396d94d6490defa65457684c2c4987fea09600ed01155b40ededaefab8c5cfb9a52d103b1fd39159c3d20fdea5ac1d7753e9a136d9a8bcc8e5b5bd427bc8edc6b5ae861ec4ea4f1294c80651d0ef4fa7eacac690f1f7aa5224b51a8f6c2e4fb2971b433ce85f995f1ecbf7bd0b38b13bf9d06e6fdfadbfd8e89f2e7945088429d77e1159baf1161385a9cf899117b906a6cf0c25ac2f9bcd79bbb92b85c087b6706d1801b96fa93ff31834fda6296bc0ea30eac2e47d812e81fdb2ca8d096c5c542b38ee38fd046cdb9e463313a34240e22fd46d885910cdc09edae83f0488a5d8649a3a898ff652e4d9ee2510579a2e5ef614512a1624c8b242a9edf7cc90b7e2c796980206ec61d7ef0987c307d5bb027855ea45b835ec20bd01a4430841e5b734a324df8fad83f559470becc09e9c8e660a298c3237d4a498bf7407da48d24d3f831db2b048c5dab0861395f77ee5e0686721a429224854a01959af04025b717d041ae79ebb0f4beb0fc435103c262f4fc3371b56fd0247ec06c7347632f56c6b970c8437585ef941be01723f8e2d4f26a671183000ae965fa5c99fa37593567e0cce7bb7cf95e5a04b47cfbed4ad57e1ffcbccc7b87928066efe523c52dcd0071e2731b1428d2faa64c8ae9caa70ee453c68f8ce93978d27c0e287b8fc047e5cb94c7f44b347afeb098937ac5afa9279c4832ed5e1e506ad1b469700ce240cf5983650d7c21c289381e7427f84ac08bbb79f645fedaa722f4c1fa4056d66fa7c35872b9ace161925b519db3d7558437edf8f3d77a6c5c226faecb1e91062df0b1121e1ab7a378a85bf5b4b32d2b18f2b6a11b04b7f01c2d208859176933a844bce6b39f3cbb1548ecf5922fffd9a6e6655229596e4713f9493a1628a6c7f7d700e7fa9bb3afc90a5ef7070e2c1735dc5e226c989b373e13cfd288f359927c93987840cbbf1d48ce93c50061cce53f50438f048461f6fc2709711ad7e7924af0ce18af8d21d874e38b55d37a1645900e5f6d8acd543770e484fa4c3dadeaaa5603a67b6ace2bffe7231d489b68ea8ea11fdb2a7f38adf07f2d627b9df9a57468ed3544e013531cce61aaf8307cf957307271cd0275b98b13da66064fbf091b60ca386361d05183e1ca3f2a7d3ed94188a9ccca3de20ff5edfa6941534cdd813a0fc8bd412e5541a29330ad223821efba33ad26f2c28d6a5305649b27baf93acb8719324a5ad686311c54a93d464ab18c5dcbc74d16c5b752b4c5f6572d46c44656ed5e8b65f08e279186df04b3ec63d9951b6eea089dc1bef3aabb2afec86df0ab4f72347677750dc9a4a7eb599c6e0926edd92925cb3c4a5bbae62389eaf45ffa19394e84fe15dc625648fccc5767cc014f5a5aef407a90d73d709b7769477602971fc51745be9f0af932773695227f34e1b93915efca456537b09e82dacf7c091c0463940023d0f1caba4be94e899ffaae196894e35992fffe934ca9c8d228b449032255814bd388e181a3bef9468a1d21a9afdc665d2b03146a00754d28434916d549ecab06b35d47c700cdd041486896ebda19c7917ac3b56f56882d947fdab9992806db9172c2b7e52c5dc81ab32f52d0707247db9e6fd22d2a09610be61a2e9f12519663a6eb2b4b23fcbd8ac9cd26a19fb2c0a3a537d6562930defd0b9dbe7130cb092df5101bf444919451a5ead6800d8503590155a1b1c78c37928f495e8747fdecb2fe86c37d7ddc055ce6e27b8d71c300a8417b56a81c4abad63bd876993a54dcb23346765d0c8938543f17b39b344cd9c56bacde56124d5fc05a6960a92620a75d7ff5e6e7e2d065b8ce77587c517b4c7668a538f933874d44a4fde2822f8ffcd200a508f7b437dffbcddad859c1ac52359b04205271bb34924bac1e4dbdebc394653af21471e7689d0cc006bcc515b0a0d2094d24d4ed786d3128cbe2269d37aadf22cc41b689b1f0c7cb6591c8fe9165813f23d040bb8d4b7d9f73adbe2eee1b82bdce059994bed48366a7b37c4579f7f3423d03cbc4edfcf8e85ab889be3671ec40dabc6a78aa6e9dc54f5d1ef244bfbe3f042b5673a8c02703a75f65e20a4617106688b0484e18c960f63c3e6a16fc90553bf625afa28b31709660848778cdcc4c8b6dc9a82382896f8a5b3d7ff5574c9ea98393d9ddd187464613fb70b62bf13a1f34dda7b8c7e4ea4f3defd365c24383188ea35d7a2231eb523efbd0ef68252c707cf98a752de15cf926fc5ceeebe038853f78e1149da39810da595984aef67798262773344253f49caa34c2fe47db273164c9ffa3cdfa76563a2228b650f5481ebfeb5cdc8454e34bf21630eedce183b7cc99f0f14afc6ee7530b42062a32f360c35330b6f033bb7e157ae2372225103b13eaf3a7b54d63720518acda01b59d8d85d1f5db07774449872567ca3b7d47b560865cb2a70d871114a1d96878aebf094d80f20ffbb60534c92015b444a571c6a1a85b30cb934d27ea0c6ad915c5ec8b449a374d7a006b8512154d7bd57722b160af2dd2dbe2e267376a0c772fd7d1ccacc98ade265f69a24ec3ad9419572ec40174cb5dcc5a6ff81c387cac53aecdad1dd4dda3c6af09a795f5fbe34ea1e8e7d654f6f0fa3c3626a322230537aecf930d074365ba4ccc046ee9b87a8e77fe9cdba1ee52700fdd07baa55503016c123d2f63ce5ee07c6fbebed6de4b2dd66df15ae3d9358da75e369042071e60504bc68f930be09aa83d5d2841e75e27797b42f75bf9315378d8a265bc52f05972e132d497de3acb5c5d6f6d33ad1aeaf88494543b5b7254d27a3e8eb7861d94607cfc1abc997b0a0899853c20493031592df092c9314a8f726418dcb2ead8311830cc3e4a3b7b3896609df687e1418e78c04fa475fde56fc6ef18ab48735939d2bb890d6f06641f6a725601044bfa1523ff61b81ab37fe2c1ce04ba8d357c38e2006424dc2389aacb5c3b27806d741606e5e592fa9a85e7df85b37fd8ac79f40f69876f6df31110beee982e91d8bcfc7dea999ee8b6a9a54a8430b27961644ab455ff88d72c3e2af1294087035b47457ea25eeca57a57c279058e124e084b307e96de172b99fea30cc13e3dcc2964118d4baf690ce9dde52196acb0c8aa239a0d25f36f4d8d5fc7740de69e7a846cfc3a447568155c1afabb5d6043189d1523be1b240c3bf57d75083f16dc5e278289f94402ec4ed881035146965ad65d5bf5fb7af7622e414fb89e1da81bd311280ae3e2a016a6ff3a887dcf3f933cc59257d71748ad3007a80f87e1863423d6bf3e3f0d5b9d77773485efff88143a62b193eb28c6f541c4cc6c5d3e1c82a8adae476ac76c89363ed659920ffd7c7268c45b5fff6150bc4c21f543f52f89162e13fae0622f09379728eaf0cb9772be6dc3c99b558165affc7514e44f3c7ae09c4574f1d59d661b25c6e4b5fcff095eb54fbef9e3945abb7fc5da6a29b13ad04b744046ad46cb6a247e519f6885e51e0c75e286e04f20355f2e50cee5aa8ab704c3f0eaa58876ce432ed3526a77a43c3322d98f11a09b2cafaeebff0534aa447ba4d987ae98233b0168fd56cf756669360a56ce742b80c8cd22fbd471e0a9f7e9098a08a41778da3bfda0d2a07afe27ff6af9303271bf5b9e77ae04c7b2e12dcd2666a47bb930b659bccaee258fafe8d876f85cf99654f4599e5140d1477ec7fdb0a52c726a8d2aa2b9815a20dd9db24759911b42fc8e2101dd449755b9ae51530f07946a054aed00d016671553939972dd4bfad7342124c901e996c5f6170743112e664cb7cacac34b02ed564c0e89e256ddb36f08b310d07ba6c4b0da5539cf75d7567e32b6dd924520b717360ab6673712d94e1f20b99c77d54bb6519e4fdbeff50d462a2d43ba87f88233b1165f69bbd35cc247a2e4e619eac888bb4cf4d684bdab9913ec7c268fb1337241384ce854445b0e6da77ba9ffe8a78c3762005cf5b1c0b4f12de4c3259902c1b545997f1401111c8736811034df58c6651431578d86003f26ae4c38a7ff46d5a3f3548abd2e97cc913141547a688156e58843ed8e0037584c858bd5c59c07371aa7b76a791f299fc65768a7679bfc686433a88cb16c9e765ecdbe981034f36ce62b62e377a2459d38ee7162b79089c342625f3214ba4e053ffac1e46b662c90415c5a5f14de35e7848aa1616fa9dcdd857f015bff77ecd85781632ef12af83d9a915b333aa34de95f6dd90922281046b3e9a83cf57684eae6e14364903756100230d53df90ec1aac3153e25a180eb1681cace2b98a918aff09bd1ee501f2397ac7f0a9fe7aae0403f96eaa2d6b744aef9c6517e8e572b50693a09f2c22f072e5a331227e119f906630b05dd087a15b57885d5349b9068b58ae0720f323d68c8c1f15a921392c9100e8e5dbd42bc8c2ea0a3a0c82731aeee842f9c6188284ba95cca813737f29af7521f7070e852d5b4e63ee5859d6dc9e8c1ec63380916e49c916cd198768d98bd6af31f8dccea6872ed507b27841e59664aa15b68407b417beb5091e154906996fa93559c78eba250e8f3284b36dfbf29f4ebe70efec11db123ed43d4d86ac8fd9e498ac719ad1993a4e0196c34d722d469faea4090a145a144e6b26e78058dc6515605c2ecfa68bfa7135f159fa605609d541d5b0f9933b3a3c9a3998ea3465c34adbf84403cc0f418798808e13a99635826f2188802dc0efcfa6bcc52432af02449915b78bd7958966c7077f512fe0fb2832a4a29ed68debf64cfe309bb09b8322aabc81b6d62d04a576936282119d94c898fbbb35a49daa1938296992bad38c1745dda3764fffb4322a6443849c452e562ebaaaebfd0a2f8c25e154c8750f57f41f39dd65c655f047f544a40942d42ea4e10c98b3ba9f7e1488e7bf6392edfc6d14f35532b3b3107914821f53e61b4f094c0befc2dfd6504898b07a29d344503d813c46d5523f48ad2dfb7ca174c6ab6961e81aa10bf93c1f32b0d0ad121154f8a7f88a728d522ec826c8ff003f6a9d5b447b944d8aced8ad811f7c5a096b7103d991553209028efd05fb0f5665a2e0be073f716bf1c2e51d60dca36c88bbeb469cecfdf47c0c47dfd9e9a7e58bea1b8ed33c0938e0259d91d4797da528364157dfc49020a4e8bc4845f96930c230f2390463e2fd804d4d49842ce7b799edcf86091f287c87a3c26e76856e31ab16ea11dc00adc82c12916ebd2579072dc3b5bf1e8c62678da4c5d87a32cbf4d57150c5efbc3f61b93dc4d2436267381b105c500d883a9e040a61e2d73d0efc0080db527ff5abb4ce667a2cea09e1e0fbb8f17bccb255fa19e38162f156b00ef4747a8acd7c1a19fd68655f699eeba10b86a58be79ea0b2d608fabc0492cb30181353f5a1385865baeaecba246f4b36a172c30f327cbc8bddbee738d05893e845a946a42d4e2b1b1e2396a96293d8cf691151a1f8841067241b6fd88757c8e4c4cd7b01b1ef4b121eda78c61f864c7be9932ba93d52de8da5cc43e6459fa643105d7f2c4f590f8a43364f2a4cc3a0ef3ae52ae0a7f5fd72cb1ba29a2cdc81a2b8963e4849579828ecf35aab538bfe900c4d83b2bc778474c823d944609684e5350a4528d84022b9a128d037230b9247aee27aa98fa1620a4ff9c52755c416176323f4b474e4afd908c9d5dece5ca8f696583ee27309424cc9d3d6e94ed25836b8d1b00a4240d0eef1575a0a7af9733f45fa560b2fbf969c966d9ef519e58c1b08030fc18304768d22e46d2236adcc5e335fa1ba905b5fc9e5cecc2b3159bc925fc4c89683bc85ada773b3a6651b6cd4629a32d86381c8d8fc33d08962c013337d9bc1e67e291965e11662453f4f67c1f9560c5cd8065c5f96fa76f032f8ac483e901d2bad58a3b6c3dd466c085df7293eac66efbb671bb33f6eb53b6572d6143ca954dc55db1687076652a0a2ba409c528197304e17ab0ea1f9f633843936a0d7d41f59e5d73b888d53c8b1dab38aba00999f41ea0bb3b1c62fe67d5d003d24964a48ad9022cee51d5b48993852dfa3ff06cfd3dab2de60a67c4234fad451080886baf2330e92c63cd54322b63d7f4f8790693a70b623d2bbd2395151e9a1f74e42eb22afe07b9464ac7324c4bb9de83a8ae58ae5ad02aa3af0d46aa2c6f4d7a4904f9c8e8e5d9eb687ddeaaddc094364001df16cc0ef87fc24f894849b5ea56c17950d65fe2e55f81feb284057990e14a786d77ec2bd9923d4aa87a6937a0f927bb097b654ba117b15388e3948f8ab0f7a5fbdefa7121b8b348b73d640ead7f1ac4b395231a451a443918fcfb9e8d0354cdef49db22c6acbbe8d9485a2fff7af6fa7d28f83209aefa6bdbdccdbcb95dd4db5d281cdb6f498ef64bbe67061f2f09b409c92fd076abd7ef7cee7796211f6136835ae4245fcbe53745b898c764f265a2172f5697b97b50b2263988cc5a094941298b092ecee45fb507d429b7e26a46be4f08e2ff40b28bd6123e41437ad01daeb0a193051bc290516a9fa93495bb58e2f0661f18b7f0917f5223d3f98302549a3b8fcba2b6185cec1299539342d7bdc003aa54450f2d31d001301fde5de888e6fc7537a3ea3dd329ec25a4a5f561290978f0f70d95b9515d30b2e342392b55eccd00247bbb490c0c267c7f408cb078dc718cec75b23bf46875bac74157092f4e0e609e77ee98c046431da7a55c7bf1fbe6190db613afa8db080c61137953d89edcd553a1e35374f0d17350427771a673afe49430c7f97d36bc1bb3786dde34d0103eb7a91bdcef6924a5ef41b4cc9257b841de9201fdabda346593808fbddc312e118f9845b4fa8e184682d96e54e84c44c97c167d56a0edfa7d0d771d708a75a5e0629e40c7b2aa8f8baa643d65c998d836dc1447ec20f75f205713dd9e3302b37e1b1fabf63f4b9476a8e7fef6449c06b7fab4caec42b4af00e34cb5a79f3f30c019994146b29d56f2ac2b743f1b416e57baba1acb7269e06b1090927f24dd121d8390ecf280301c79e3f5877e066a5344d9a14a1602c2c5df4c25c58e8779f26954cfd1e24885c67be274a69fabd28fd188e62953892552ce76c4a580542171b38a04808f8f99307dfd0f8d11d351e1816a44e262ebfbfbde32e6ea38e7f15c330acc2889f1c8d0a97d00638176a7a0f5a3decb9e877b668e3cb6f774e728a5cade8bdc73f98ca74e47741685cb99cfbed2f726fdaa0120163e96d7acb29d70862cc34244260d1be719f057dea9723e52a48796b3c5a2f14fc0254a40b8fc4663c4149a66fa398f51c3091799964d00f18b4bd7f1535a2dab233f993def2c056c00986f4b5a60498bdbe81e6b442c7e887c338a97cd30e035048bbc3efaae07a3f9dd288c1f5a757dfeeaf1c59ec7df04209a3623c096d81afadd66292a28a9c9f79085f7c63554275bce97f9cc730fd6bcad001e5d0e0be498caef2e63734e8d5340f082798cfe8ff0cab6f883300790b306f400f832bdafbf5bfb47ba139114dbbe3084d5ddfc8b8fc716c0893dde75ef2f669a73b13ed16f0baba05b7a1ff3114bca835dffd3f30baa07a29712e17c72da79f9e2e6e47e7ef8f887fb5c838f4c26de1d36bebeb4fede7d0829867b82782a58f4d7c19589a5f8bbdd9edf50147a17f83f6e6723a6250f1394d0a5569a423bcb41a6943ebc3d3b7d141a13b4d972cf31cb418428ef2520f2ac9c9b83aa565e89447c36e22a9d5917a4bad89dfc3c43616d90a3afa11f5675e74a681463955b2fd7a30d5311d1dea4f991c085094f60cd1daada1f78f165ae3f0c1a29af31aae6a4b287ba0eb678384afcbc24ee7f1fee4ed989c64f30bbe2bdf51fae6567a8db0135f0260f1aeb38dff8c1ba86a06bba7e83bd483f0caea04ff277fb285baaac23e176df5d205cf9227798694c6d01964f96b04eb7afb32b29e0d7d038c0e35d1197583eb409149716c55943781ae023c4ff1f2adbd6b81ab1fe636ae3808ac73adc14eaca1517f45423a4e751328f6b88ecdefc9b6dead8f2fffd41c8a64da322b88c8fefdd272b5675ddf74729bd9ad4a7ee380718e74e900f4744783cc65b404f5b4d10db6f3917eb92e1a369480c0a824ffbd9435e34196f5057f4cde8861dd505be581a8060a9171caeabcb421848b5e5568f918730fe73ba0f1d4cbf3694300a7eee2e5ef3da1d13e01141f3e94eb7a02572e478d0ebbcba4672086f569ea5b28573c99707ed99854b2f977cc17e263f8b3c2723983e0ad22068acf8a7dea53411a656d50ea1187f89a6e18810c19715534718b9b317a2900975f1ccf456984e5aeb2134f043a5beb3d30959a83b4cc35c8d6895b51f2df8b68b039128ffb5f40c144cff9d5df79d7439b75159387f91486ea08c835a7ba79b64bb18e2ac4f4c614fe4323aafbe033bbb01ac1f70b77faec02338cd9d2df23c825b6607b898160690e2a983e4a368a0b1313811b6f1b57ccd3f370c24929f699676d50bb565268bf3ac6cf5c4eda2089b9b6e9eccd52feb636a18290c89e1bc5e72207b04eaed1428ae88438a2ad9d2e32427edc13ffe5347fbfa90735cdd0d182592749539f9772ce03f8e40d91b13056c66c571a7d0435af26dfa590de8eec9eebc4d3e9ccb2849c11f9f0deaabf31b5c5f730a536f096f9fe07305ddde02d6c3ec462e6516335fea57497a1d94cfab0bc56987218bfbb658facec907bcacec381a2e33e249f159e725ea72bed096f211de9b4b69839864cb7b98573ab012dbe8e664a717a197e50b7afca928e64ba3c6d1b4feb5cbd1eca914ed4dc722f1ae1d781c8c2db4f3c852cb24b63bd8f4926bdf00bd854325319573f927821e1de0e1b14e2e8511816ab839b9d90de53b7d1a8c02fd0ca4f6ce602ba1df191700ae6119d6a007bbe384b6a73c5ba0dc9b96c2f4953b857fb2628f3dc8629f5011df43f72f65a217207f12c12dd792e6541f8703fca9eadcb1dceec7d1fc431d9991d991a36635ea1cbc1e296fbfd8e2aacd26051c90f2dd79ea7de2b9ae20ac2a879aee89e52ffb99eefe3ff9f37e8b5f9ba21df9ebd3431d50fe8552aed40b2ee3bee698397a18feec295514016da99132eb74167f9916d08a747bf6c1e5382bf26d25192bd37559beb7d8a0d60487ceebc7042d9f4c912b156731c109851c23d368f72721f6aaa1fea3ebeefeb6a1fee19bca23475d2d9d7397163db5c543645f8429ea7b1fd0d5bb55530aad3b233c7efaaf78996137077df453e2db181b8e5db1a989651942485b2164735da78421ef74bdcb4641113411cebf122f77fa325707dc01444dc45c0eb38a7768193f67809c4dc59d687492db9f35f16696185b1f2c2fc640666d988b61f2d062b0a416155ee6d19008bb3890ac760f43ab699da89891c4be93aa397e65c0ce57666730a15dd516a2ddbb9c6656c7536f11291f83d4867ab71e1f6f3893aae73290867dabaebf365388009c12669e2d99729a135aad08e3a8fa8f496e923248a406cdb752ccfdeec06803ff09dda9e492d3e5b1d0ce646a4da398fcd83fb55663e56509021b810c9b5938d7e017d3a3f0cc360ec3680068d58c785c369edf3210165b691ec5f09aa947af6dff8e167aaacb8ee9878ea6b53326f667c4d5f64de3546302ad203aab9f76d87e75c58d493b9cb39e07810bbe493361c676016e9c8e76bdec6a5f5e01d17e1f1974096dafe1549e77811095bab6dcc51263af6280c9ddb84e2ee3f5b7603750360626f53a99e4d904c33ede3fd60a4881defd4273c0ff36a941338171b7facb967331a32633a9ac4d574c23503cfacebf1467174bc5d68b5f26b5359c65fb1bbd7718d17d6640ebc70f05b2f3cceb1ccdf2bcf94037600bbd71492acdeecff27eb4b28ec33f7962448817497d07a6a99c0788149830bb87e30ace0a95f5ffc0bd6ee0960f37390d3717dd947c31b06fb0ac510b830c32066b6c50ab71d2391f85430f406d3ed2dfa1b88e84ef23958e3026647448c9c745fe5d6d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
