<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe59aabe3b920e68655ad9092ddb2feffbdc39f191fa1a98fefbfca66b6ebdee4876623af64151b8b19cf5be728b5e6430c34fd8c3735b7d89a30e247c13b489958dc9a8cf464587b0d0e469c80be4331d9c01d54936cfd7093e15e0eae5ab252f1d017e40d7200292c0cad6b57fda51a9080d74990c976340f6d0d2be0a419f1e3bc5012c58414f7e19816f34d3b44df03a1e06700b5bd1f543704c4f689a4666b25d6f6ffad9c80f71f29807fd0f0779c5d81facb47bac8b2d97e8cf7447742f674b6b368083a87d8800b5d7fd848bca60912ac2d3afa50ccf51a2936413f6962be3a46e9eddfa8c4ba55580c3d7ffae6911b383b6ebb742d78dbfb3c546d1c136cc8b27b38ac106767ad80a182626f5cbe067a355d25ff74a7e6c1ac6015e2310f98dbf8f7e7c83d6ab69df7077ce661901a29a1d860970033091efde9bf891db48bbc0f8ba6e619221a65761d84c9d98923163d5050661f4f20e45556798fdce21e4ba471542e0fc731bf6461ddbecb6b0ea95812ac25049fdf7c24bc3658ce83e2f83d970db90238fe80d7802956ffba1b5157eb04263f27f36322a407db3df24b245b13d82a133cc16c4b1523602d8656a9360fa705fb540ee37631b11993c9af73ae378964f5d1300b0295f4a8c230ef115e1d7bf5b352f63adcf6fdda0db9efb4651db9aed48e40d600f781f2f94dca2ba78a8ae0e6007496a5fb24a307420d7a9798ba540ca60b12c7f4f10ca9b9306a29d145fb12cddf0c60e18b31fac2c7781fcb3cabc2a50a1092d9a21707931c3e3dffe6dac80c655f23dadf2d0f82b294110174af199cd3405e0d28acf64d1bc1247ef5c487c9aec321b5ba6dd57096136304fb074f4040987c9c6c5ef1257da4fb86298285d421daaaac81ee844f8bc5da7c23e9ff4107f453ca93a87f86e4a79e4526ef6ec6678ff4577ec6278396d6ef3793761c840b682afc274e63ce0c207e0085a9726c344c0b7e945a98f6fe8f54bbd347b413144a768e73cba0c0dc1394e53f2f44b5364c4a37f694cf2ddf649f1a6cc1fa0e0eef15975bc98b91e65ef1b17bb52e408211cd38e01c579400b51c338a82397deef8a782faee124a374206f29b3a9de95d7f23c7a879e07691ecf431931bad0d836c0f69b52a60a561ab06a0a4d03c718c8d45b8d12ca52b9a3a0c102f0941e46dc279ece96a84beb2e237863a93367991dfee1b96bbe341827300c854702217ab397e8f851dcc376fe114ec31ff080309a465f530653a604fc0177f1315d523aedddc751b57b7ceb9700ab594b53d22a6599346d7b1e22d963f595de67af63e5d24ae1da41684253cb365f782ef7f4ffc5c4fad3a31cf81d64a16c69fb9d418de48447ece1ba1158c35988bd8b36f1d1850dc7d677c910ecc3ea326a109a125f9a54c606a07fdb3158eb8396e002d05b3fb0f53c2aea10df52949d939a9798cadc5817e44d63d3cc9ba7f0d5762dc2e24bab55dad8dfc2a1e737b09d218aa8f18529b3b25a80579876d6c5a9a5768246f4a96a99eb0fd9ef23be11d208704df0b64dd788cff8feccdee4109cca5514683f929f9a337c89a05c7ec9145f22768f424b98fb37d56bbd3d3318950ab79b0f9764be7ce655c1606792860bd3b6e256f705aacd88ec3e14b130275525a0e91333a0999b84a2a1fff89b755d8f5af561df1d497783b3ded3abb60151b10384f737affbc5c937a511d90ba9c6eda6699cfeb5c29779882d601d26360137d5e28cb5e8540ada1bd2981192cc1cfba9d2a2b9e1274d8ea0b935038947d962cb83881c4181bfb7b621f84ff40490a7728d522c4d7eba81458a33547a9a79a6bc5e03a12e71da95918bb16476dce8b90da91fccc6cad49f7f5416bc7bf43df0877db5c95aebdaebd156a3854219efec78d69af8c327e552bbb0868e50839f3aa021b13a3fa7790fe0c145e6c13bc7c99e2df0917463237a0e45d68202b11b1a8dd1243139af3c18c1d46bc63bec0991c67022a2402d8ab6b85e9a79e7612df726f6a51e169fbda28c4158775d1ba80f6464ac66d2a9610d250400959f47d4bc1354f9841cffe53977826c910a39b93b10689d72047767525b729c8cf990f11c8c202fdd1eac8eec8252449d80e3a05f7edaba181ebd83f3c59ecb748255fd6f80f2c36201291c811d79f9c5bcd6e4f6ab936e1ba85be1f2cdd62e29e0a77048b47e2a6ff43cf297bf7370df3ddc8daca8e6055bb71cdb5d1e75426215ae813f1f06b680da30432eaf6288490a5769032a63e0ed26f77a15972e5f231650e948dd3c1bb3abe9bbb07c084fe400391da7626c5057423c87c4d9aba92c6553635d96474e96f1057b8c305b7260a3a60b5994a9a235ab39a2c2b4a0e626bb849a218ce9891c56f7f5d57db1dcaa41cd1e0cc344c9d93e3ed2d4967ff2c98549a3542cbb9aa771582d5d7b43d2c1d897ecafb6e73dd6c433d2d163bab1a1740feda2c51a73b2038acdfbcfb12c269f9db76191b130181518641ff92087437cfb247ecdd5e43b4e1be567f488d81c058a16b5305d3818827c4164de6d06e64f4e9123b924c8104290d3f7bdc1965f6345e056cbc41e832c36abba1ee1056c250fa15f3744d86cb55bc024b58d9461ceb631de1f6ace1f66616163b01da57385e20ffd6fce44b4b52575509ba025fcabb7707b467ddd56236036be4a61dabd75de746edec36c0e90e095401a145c7b0858aa1e2222c7b9cae6e1e778ef718192cc8dc9f2275a82eed48980601f2b598adb1c6684e113cf7276b66f6dd3f53234ff7d744f8f196a4c7ac135509b3ebe06a21bf34feebacd90ee8e0134b0da2ec042d0b51e7bddfe6f9876f419c8eb1802187e22c9e16d43e3849f4d9fc9764083f0f5966356581b8c22217802b4442c234069ce8cf465ad43c7d55cc77258438518c8375aa154070b90c54ac0b72393bdaaed091a630ca6e0a37c39740b415074a8029e8ef9c4c99400e4f3363475ca86a7c3f85fcc6d2ff1921dfcdae28f57c91485843493fb35ffa2b28590012e825f8d52e75026beaa5c606f702e95d77ffd37a59ce1ae82ddf10342d7995adb6303fa24d0d47539387718eb124ada04709a7edc6861077961343427e1af35413f57609ae38ef2bf4553d4006177608a0067a4185d5cd4e58664bd7836aa5d011bb11c60039a9efa927c555ec940dab44ef6eca1ba7a221ca3748027d06d7c1ca0729663af734034a0ade4ca7738cce65ddc9bd7098163bdcce3cf8e10dee24d082db7dc7965b71f0d7d19b4d76eb44ab9935b4c3b7ceb7654f8654fcd1678e5cf564860432dae2f83fb5592d3ccd049e6c61da287158d32434d50ac0fb5e4ce4915c679ca2732e5776fa1ff111611b2b387998add6fdcf29a8a2f0b97313fb5b27e15cd999846a99ecb4bc1773c6473c42b76608bf9cc23b67ce6d0529db13eca71b437df6a4009a66610666d3c018d40d4e660d198da3387f50c10347f168f2fdf1471ec66059d483e128c7c723011ca9b0853a87c91141acbd6bceee278de999f894dcc740d15da689dd34db846fd088ffc08672881e31a6858ac93e473fa7cc667195bfc8f666a4b2ab85ae15502a262852fbf08defeac55bb3d94dc5af3c1bd52446da6b30c24eaf36c8a21e57538016c02fb4c8952162d4519d2ee1fb18c4b675bfcece56405d9501229aaefb3065453aacd87f0f3a2373a43ed67b8904c9d7fdc5f7b641fe5b4d10f92b9502491fe4c3779ae37e8a32ba5f98faa58e49acfa12f9c352b75efc040449943c806ac58837539c672b3e05ac06defaffc0b306b02fb6ed6f58c3ba68e6aa448de261de9defd62c5bfccee22c14786e9d24f02fdb67c0952641ac30d34116a67f8867182bfef1d4c0e12101b828b90f0e588a914ba7d93ce2b3133f59215a087a2d7d8d96ec2692e110243e6f9dff35654fcdb0485083be65875de20b0b3f95c920f58d9df9b1fb1508499f590a7b4c522d6178eb1af10df4f73dad6c72824131f226ff22f9d1d6665f4860a7baf40df31122f34cb5fc6fcb12d64e2258ba4cc52eff4f9cc190458f4bb9255081ba78b6474dc9c95157028cd9e5a36aa9f3d66c9fc5941199581692e71e68fb37db90e9f27c518ba5a8f9ce30548c52df66d3c72d750591aff9e472fe03a2defa63361af6bc00c3bef76b45dc921cb3629ad549a74426527d730ebe36fa5ab49f799e10c737706b788238506d3251129649a83c07bb19e6e1baacdcb5cf32407b3913d2fdd3f3f20c5ee19ee8811bf1326b1f1bb87fe93e156e018ee8cf6a1923ebfde24aed3e74a6261f3c7071a1261170352bfc403b6bb2565acda8f64cf8ace3e2d18a8cc78e9e5a283a0a353c7b1dc9d639b543f46779fbdcd48dea06d2377db792c5bf1df119759ebb27c454b412f0643c4b142655c54fa328c575f6a11d3e9f22b5fd257481c1ba3eece0f296ef752d188b77cb93257f2c98f17007411b67bcf0e62e333c296ef0ad8c54755534e6f0d6c7139bc18fd426b88c9d19ba62f28a2cd48451687c7ac95612b6fa764ec5341f4ad6781f5d5d69f44d23892f038d4ec23d9f133ad8b962aef14a172fa674107c8d539349bcbb0392f40e4b6c14fdab57b3d48e0f8f5b2dc145ea71a3fc8cdbcdc70abb18a73737ed01a5b43ab29e456f76cf59c9462fabcb147ab7643be43c3fee655d4f5ea636a8257cd7a2d59e4e22be7fea095f47047f419b01ce15aba575d553a83ef19bc0ad17be24b77a2aa5d2452a4d24305976f774f786d2d0b0d2b6685b89fa4cc86b51b10172bf2e04db688c03e3971de422e4aa7275a3dfa948406f9d44a6d58550156ffb3931afca1a02b20542ded63e6a49ea276fbdb96c4942677f599d40501a355c3dc7cdec08643768d62b41ebae52821c28cacf5d105ad54d52e2fe641843eec8baf41eb7a9a38f8e754b37c09f3dbfb73febf378da52d9527b06b34c7dd3da7eb44771895889c8d34f2768dd8add6c37d0274c723d3238beddb63030222ae82f342b288a9aec10d2996f7fe22da9cc651b4e873dd17fbaea946ab739f059ea536a709e96dba83105d6dbe7e30537ddb66dc3e98d54f31eeb0a55745bdf18c2c81ffffc3730fba85895d8f98a6c88dc08fb4b6d8e6ec3b304826e264d970d584b7d554bc47d6dfc78fe83bb24599ee6425a716a21762c0797b4a4b8f97b2d5bd494be3173c17e739975935b7c3ba4e4ee0791c51bb75c8675436c30c16be524f7381e35501d5e1cf09870c35acef9561577d077040a54a7f432057b60d4bec8a3b2238074641f255fd6a71a7afa076b5647b6553db84ff34dcde7e241f5a1ba84aa091654f0479617ff9e776cd894eb2455d8e9bfea25b9e0689dc3f3f41fba8fe910992b29a73ed10bb0acdff04ef9c550b4ad36b3b03a6868dc1e69503be8bac95b0bf1348fa5bc01d8e4da9e1a1e4532ee69f3cc741babbe62611b7e4b9a8e23243b7c3cd18f46501b349f36df3a749c69acb6faab15553068ee740e7b31cedd74bb1739aa9bdbaf163456bee590e0adfabc6172f7d5bdb2cbc432d2ec35d849d970bf2e71c777123c10d6173aa19595c354641b7f18f731ad5d9d2703291f69628608e0164c401785c06c1cd7d912a09c217b999369bc8d134148be9ca529148cae798a4e2c9539cad63b2a3effbcd90781ae04f9e51da16ef1993139c51066a5151d7379b04d0e09e43780ffc699ce2038a5ed10387c0581370ad73124f95026e2f02ba5588530ac8fff8aff9e130f0ed5ad224b88f7d0bec6c1e6265cf84f3e61bde3c3bdaf67d498e943448028e6e27cac41f2e297b6f00f60806f9ea5408e8586c1e4916f81b125e1608449e2a792311a7e009e2145b339cce9a7f96f6add5f3cf7d4ce30a0fe336265ae284a064f08500e64f7ee73b52400d3cbdba2a3388363e09dd9ecd03b6d72b79ff2a2e8e485e968b506329e1fafbc1ffbebce80123c90a36b0b30fb9acf4cff2a0bfad56684873c573b29c01944e7e2939b6322a5a2ec27b76b4932639bbf715b0b32ceac9c300b80095316b755b4a03c565214f51f9f9e9c7c2f8c31ae71d6fedaf79cc35ca58e17863bebfe62c2836a5f7dae24442237f908fa0e782d79d30f70f3d3a310c18df4d169498bef1eabec2feb2133e817bd1437e82172a393dc8c96aa8fdcc2fc37b0649c0bad994dabdebdb51012239ea50703136e9783901fcde396694657dc8468f6759495e0b3dce1c5a3033f73eabde538e5af231f012764c90bcfc0faa768ecf2244d4fb06514899688770020a70f4c4ba151b68f83bac438a54f01e30c2ba7c2b3e3b59e4b46ad33150f6331b02e243bb886df8bdd7311028a16974e98e75a4a4b9d60429152351b7d1080197a188836e458b444e6f7b70cf1c0a3e8a09b32e3b60d3a73b11be12cb1e413bf2c6226faae600bcd2aff28143f528d23d4792823b36924fb3c1ea63df5b4a80e54944caf647abd0b3700ef19bb9488001f4d7e85b5ef7294a6338251a17fec9d472e553cd8045be4c3ff142c0a8a5b0ae21634f22b1c4101d25990f21870ea973e52822cab24ece398269495f13f077a0ae9cd28e1267231690af06e14a689f56a18c4c8f8b04d906ad32cce9f0ba89a708fce293dd5fbdadb3bc0660e9c6f4d54405df08ce0f78cf5f0556b3fa963d9028fc630c592cb407741e1da6f94d4fac8fe4462ab787515b343729621b0b5217d31c79e31ad359f62217ab94e75d4af5e528e33266d5a0879aa863da7dda13c4a4b5678bfaea534a5d26561a03ce1bec1f321ee9646b5f502bac4e9341772442c57ad9ac3a85035899490443d670a6428014b7a931331e7ee4dfe970789d94af5e8caecede83cccbf41119270c4c86da3857d42f539718928ba69ea6dee6c4f8f6bfd4b3d889fb29ae265eab55a8b5d1cba20f7a26f20296bae8985478be6b880002ec01fa7595578f7f10cd6948276cf64788308ad6f14414ece18c03fde878e12a5536382a95fd2bd21cd046735f0e0c87c188168ad6198cdd3ce7813ab0ac55c789f85953a22065ef032d879fed1ec17e88be1e25bb921d882899a3827a6806fbbd3aa431be93874be6f10a3a626c4f9db8cb9632901ab50e888c581e69fa9b9985b68ca8e47c64a58807e87543a6c10fca22252a2dd7f8663c5acaaefa6843c7893c3d426ae34c3bd7bb397ee756a184e95e0fa1fef8372b577661e45852d8aa925a3944298fa9f33989fc5f31cf7b48d65e0efbac5cf5a762a17e76fd38d42c78f5c16d2542a50fcc2cbdd2ebb4f16eec808dc34bb0585be7baed19bafd400061569630b1cedcc09160cc24ac4f3fd1ca88b03b9a95b7abe807738cd46b0af53c5b134b00ecee1033770f81eb4b78f85e34021cad546c369663fa663de524041fce29b96d924c4555d26d861e0df85b13a4d77411cbdd38e81b5797c871ebccdfcf04e9a2f44f03fdd2e5ff25f664f14aea51cbef6db4e0c4f6bb1f615acf33e7497ca3534698dea1c12b6d2152e8cf816adc5c19a59c70325371489d815fb522238dca20fc1f1913ee07ecd910dabfabce7878ffd95b6d015ff0a87c98c62934a91f3ab6050d837ec894200a0a639e3017e9f19bc892e0b447ce10ce25260a7b9ce5effc12271ca6992d014ce9e6942292270cadb1157922c3885b555fa71d6001195505879529f0e978e53e58b08b57d14a585787816e7f00030df5063b5b9fb067fde0cf1cea9b7b4d170706585817623b3271c0ee65747c3f54d89d3537ced71a49950cd9b366682f9e43311fec9d6f6bb58b6125561121571fd6e7e56a3e512a68c513a66e6749790ed3eaf2ba910d8a54ee1289421b187305037a293675520fdb7e799e58686799a2a08ad1836154802155c4a9db0bd514f006d7f87f9068997009b3c8dcab76eaa01a6e835d2889d0944a7b2b0b941c2e7380f378561745416c71b878509b0fc1373a93803e681d497a175c899f1e885691902edf22d05e1feaa3b268fac69be6360f325f8769b4aa335586c6c1b70eac7a19a4a363e89b3ddfebdbc956fc0b14c2de927295bb0f3421b7d54991f1b8ee20937e85f19b189861572835d70532d571ade82f893170047e00a8856d3f201643aba2fadd5597c009b4d8b1948502423bf7c415381c08074d1ef289dc5d9a956f36784ee2a97c29aef60410996de6f49feb4ec51657041b29c1049158bf40d6d3475067c461878f436bb20cbf295987741a5aca8d2fa9e4ba76e26b6255355d7439acdc33b64908de5624c5effde9511a3026a69297135e3fdbba3680ff3efddcd00142c4f23f974e2afe1f463cf227efe588335faa03d5dcc420cd9d0f67dfd480a140540193dc9e9275cab4afcc871ea2f39ef86ab00f5a4628a5b85eb16085a18e5fb9d3eed1aeead37b5d97f6b52c85137e0c37ba5b23ef3d9418988ce5f8577c28b09df9e533b7b4a7a5e1e88f3c959ee7381495af65d72dedb4b25491fa311b9471cedea38823e52c90004fd81319c14ffd66e96524ad211bebfd7a3fed8b6aeaff3712aba6205155c2d20a8a97bfd36c7953c244a8855836be85ab90a98b866d64a7c923fdcf4986fb07bad8b60d6eb20972d7f12c08a98736c799eec735087f310e5871b3bce2a24c7181cc64e7973207927356d7bdfd6335b1259da606396396ce2709ea9f05beb16e8ee002b49b436ceaa60433d79e8dbd8559165bb39d79657df0916dc90924fa17228a68bb2f0a0906157d7a29a3db17d227848a88d06bf1afed162c521c4362dd4b685316b90f0ab4c8eb2c79aee5358765af5d0f79850a8b8adb16124f620b60fc8a33a89dc87444e29629de6fd9fbc5bfd011689ac38635274d30b1f2e60005e75818b3a598ca53a488b2398ccbe13a01f36b1be8bc1904074cadb9fdbfda7d2e8ea8253fbaa54a75ae4319165b75f1a97359ce75087ee612180e8006e7237fa88b9b478a0661a7e1df0bc407649a1a061c86f1ea867cad568cef0307aab7c3f3fdc560627077ffa9d18dc44266f3f9cb91bf55bb51a5f933bed4799b9a76bda2df1727ac9b1f89c79428f62356129a7a0332e2e3022d6614ab5d8935d08addf534d4a5513930976e5d1ab6d75fb11ba7975fc05c7893d12dcd4149463e6e1b9b3dd1520af518b5a4c4ddf443e61f197df3e14948182d06c060eb71f579ed64bc10f834aa9f67295e06c2ed88dadcf39ae246950923682f1d30b14573eeb3f2b3728fa70db8372ca723bf38c57a0a89faa49ab2838266628e4a89c9cd7683d4d608cf38726fac24abde34f6a6a4cc1feea149f349f7914e8dade406027e333bcd574fcc320801bcbb7ad7b107825760ec0cdff3e93aa94a50ed927fe288058feefab8e7d1a5b222046e903d3d676d7cc94be8a6fb6bb32ceb355ff24cb3a703081ff07240091495afa4adcda8bb4b7eb7bc073624b6271e01bb71342b2d99ea1c1b25e08d8460bed0b00bbc073fb763a3fd825a47d113046b5eea3947b373e70c52eed2514ae1c6f2786f2eceab6d69484c5bb7fae89334dd38ec965b89286a2417558c8463a0ab0205c78a8a256f3d09c2ec5a5b48d3b023172fcee55767a4708c969802533af8a46f742415649784eee118c8518f142fb1611fdf936782f77fc9da3b5c3d9773384b64f45a379b0d4e6c156e2986b3639ff04938061abba5971e58bff3f3ff9afa16a55386df0a21ceb097d8ed5bf621509202ee85211bc48d0b022f2a56a005574a5d3351c3860d06546fd8ab1d197e141b5416152eacac1d8a059cc4d2af8b247385d7670a588e0dcc265f005c85a41ed5f14eee4bb3cdb9f1c309c3a155797b3e516c96e48a4e1f4c3183e87974c45af50152dc00900b7563357e8a2196091f19a6a3e2632bf7d9abd731d3a7ce5267871749e1b8ac642c76100915cfcbf73ccb24aae3fd9f5b9a4b3980c52980fbbc7ea481f07f104642bba6452f4eea38c74c532df91765ba21e9406b46c0dde22e9b6a32750add21e293f941100dad7191548f2e0e66b0e69cd579083f117133f907497ac2aef9ba65979db26b8dede7fa1512a4e31fb78b03dd7c24ce5a5c38f1671539bd54694b35c9a56412cd7429e6aea8c53015a8d6c896e179c42f383a5c782dcfd7a5dc02e5d3c4d7bc3f0ca9c6fe8ce01b3ad892642e73f3cd7c5cc55c412492e68866d9a2c5820b491ee536dc9fd0cfa4d2104d011b7d998ee2b25b798603a2aa9f4764d31bfc8114a81b8f7d239fe0a152f932add37e457f910fafe3dcf23144cf736ebc82e87522a5f6970eac6fdab76168a71ee67a4175e1d9da1e40bf0c8c685383bcd5e260dc81291dff52f3e4ea0f53caa75f8151e98e21d9a4c7fd9f5dc3793e5f894af47191f442c2839bb14b942df37f62756c6debf53506fc37065e593c4f7ad1fe458e5f4325f3744d12318e19734449d4710b605fc85233329164fb99c71f9dd96f5b472290e4bc36efe5a614cad55f21c9c2f04586edb80b361cb12f51f7f6410310c946e608e9c41387cc81b0824c07e6473c7466cd73d91319f93234ed05231887db7ac25d7f61f58daf546f7d557219f4ff5268f3bf13ecd70f50d4b871465406e66eabbd5a13846502ff132513d2bf7d548fbb2d6b7111dec59aa5c7dd47cbc6ff1d148a49c78b95f0295892ed684b6ceec1d2535ca622a6df0b8aa83f80ca2571d133546c11b4af059f811ab7c6eff3c308aacefd4ebfaf496b63538ffb1b42d244d650f1524b2c46572a65d8eee1d2db43aa61da66d0de51f329530a421cd512bca6017ecb3dcb6c56422d981b897a4db073aad2ce5507f3ce94465f87549e6cce0a9b6a5d06a346689f72f4a638501ba9aac366ca51f7c061785bd8f18d2a97b98185493546483af9bce8cb50b13536cae365609855691588ee48efdf4da4e586146da70d5442ceebeb1e8db83e823798b767076062d0587855d77833b4e37690744d7e7d9a1c32753f700e362ad4b17a74f0deaff9b5a1c0209430ae44dd8b3402cd233de8fa6be871c108cc5ad2ba8fa23bd6466bee04e99f4f238e5b8ae43067c3a66620ad3d0ae9857ef1bfe34ab7118544775793c9de948d206f25d5026afc0e9c0ad022b787a319a75be803fa4033d38362889be0a33d7bc2a64582fd40c5318d4848708bbf84f1e2d3075e563904a1e742eef963e1670abae133a3c5fbb7abd35112a6662f44a917f535afeca5d1e520ca527a9bbea6a575c14f0fea8a2c140ca5dd989a33fdc96b00f6e04df735dc60c9d97c82c5bc1ad8bfe2f03bf4f37edd2df0e9b99c1e7bc4706435cb56afdca2c96a40932a88a59a1287009ea787165cd72cac2a598e82c4c7d52db8d664f2e26dffe06c455948a03ca562967394006b333e35f9e67669c06cefb37148f53103345a637f097d4f9fe43c986567638ed35fb4dc22ae27ea5e9c2b503efd0ada60bb08c2825b34eb091be06754776790dd27f8366daa3c968da2c581372570f450764e3f8a41491eb702791fea5a5b7dd2234646c406c0d183d6476868b0d7ecdfadc3cd83dd82b8b31c7a6b0eabf35de368d182063b0953aa4f455029613e6e5653bc1d9ce8d55584bad5df9fed34b419f0c1a1a29c52fc81d8fe2bafcc9cd2ed3664d938442733cb9f1c8d68bb65b1e06c5351fd0337cb1be681cc013eb160553ca2457967a5cc0306d16cdf04eeaec3b34e0b065c953f469532b4f8e725361789b941b7cd3679c84f5a5a95bc9cf0cf8ae365217d4435106f900f698c05cf6bcd7c3e64db8ad4a0f6dc1968a7d2c5d342ba2e0e4447336f0ce5413a91558f2f28540951acda3db1f08f6d60a5dfb3dac5ac16cf6c756af43ea789874f81c9fb308502a8a9d88e9383b0861cfcbd19f5a6bc7d7422ac9ec1053fe672b077d28e1ef2d8e3c9e94fd8cb97e9aabd5016ad1dc285569898e443d687c6e6624aee702e21b3c67200bb659fd0d011a678af7e29ab9506a401c288407d20a400e6e5d19a31282f3e58b29a35f0481fd04eadcc25874e40ae0dfe6f2f626a1d39ebbf05272bdd140a8994bf183f72c129738f0161d867d8f606a534e80720b275f2dd35bb66a71d59d87ef79d41258a8e95b825558615205b6e79f18359d9fb09a15335b3384af108bf7b2ecd61809b06f7be46c7f8ef22b311a9ac026a5a1cf33370ff9aec27edf0331728e9dfb4d9086aa2884b176276b6c4521e623442c0c8fb6cc185a48c2fe571339f30bd044deb74c7a6f312f6470a733225da784e15c6d5171d68f1312dbfb5800593fdb0746bab9bb4a9bb9ca0938379b509c4c29788ca3078f1f243c15b6fc19842de87f15fdb431982d77da9c14bb5478393774cb41cecbddb64704f1ca34bc0832a320eda092ee6aeea7250558547b79c191f1378ffbd4388a95da7785228153c0bdbc7e4361e13f23b129052fbb7c4bf5a9c2b2b34defb53112d0374343c7bc31b982852d57fd4c740a7245df62a527abf7831f19ef7c53e70a5fe135ca34702960896d1b4f05429eeaa0052e008287725ee0399c38d60b96cbb877ff60b161f708f8cd56e1a608dda44e233db38a872a21208aae109137f3b60dc365542c13107c3b87958d5319c26a409936b4bee6d67cda920f484c5f781f8b4629a54f0c277a7d94b1441caa20c631ce358d120895d21ac3a80ebc2d29f6a4648709af8e163a3e1eb3618935be993b7719c4539f75572fe2d44cf942a0061f645b1964c59d744322404023c1edc1d1af61416c82abf49f26bc7519883c22f05e01fcd6cc92feeef34906613d62cc42f340510b318e8612494980c0e37faf0537f85921e2f76e2489a5d604fced7e783bf39f56fa60131a60771e2a2145c381860d048856f3d7d20a9549779a51003138a853dc924af4bd68b3861a6be97a283943a9cf4c239736514ac2b396554b1860d863540697f3c3781d5126dd65d4ad12094bc967c04d0b9862dd0134491e9b5245357cb02073b3bd35f02665c9c2cd8288e45629ca65dd3737545f3cae923450fbe589a21b5740bc1b3d1cc05a52929c24a69086d38c928330ac1b09883848873e98894f489f1318b966792f2213be299b606c2a315a054576a073e57972d1662114adcdac7db2d200ca6eea5bda3744d37ac9dcddaec16879e4af0bd5f17984a2ce8498b01342188c2caa27e5cd4bcf91a8bf7fa8002cba51d95cdf93bf14f2635bd1e14444197ed1d7eafa95d35867c3a7b6925be08e58c53aee36786f42cd8e45ff09bc5ef0764692712a2b52af19e53f77303ea689f050ecaa14101ff3be7963688e00351feb3dd6592423b9c3887eee9e6e4bd5cfcf4e6d1e03e7067080eeafdaeb7410b73ad95e347641dafaa0c53dc2e429f21628de0ba893942be75d222db6895c0aef11c1a404e7f62c75fc0b1eddc8be670dbe1a517b679c1c840213cd3a552c382b59aa2a4803aa01d2f17d090eae8e5dee600d6ba3f04b7eaf03abe9c6b3cabc94db7316af0c40794d03cfd5700f3d1fd477e3279f7c867502dc5fc2b0e776c64e8bddca1e3835416f53b3a23425e6b58114a81d073a84f4d36c52b5522075fe96177f0dfef069d8326355b68b101f490890fdec1bc33f3a2780b5aa92456a735fa539838134be50ddd64c176b5dd1cc479efa744fce2e5e3407bb7a3e4f220312c4659064b137c8a5abb2eede88b62f608b550583fe2855a8e9cb8690f439765c90a90c20f46a470396d96119eda48b9e7b9e0902b615e829a6f100ba4a959936c3b232dff9c54330b99de400864e34efa301af1446359ea3366ee99d216867f8762bddf889c0e399f70d5f858a1d6285ba1c31920bda2d844d047db0750a8093f64dc9f30c80fca67d0d8e009b1357cdf4970394290cafa72769e95713b206bc61aa07964e8a9b8f32968464f2d7565411e782da5f16557e7ce09ca3e3711fff7161bbbcf30cb0ee19d043c5b39a95a8e85adca9ca181f3b65340ebf09a67128be0f1d84cf730a8dc381106f368f3796c3f6519e8f62561f77bca70884b4217f14bd364b88f317b74869b3cca1b8b41590b408ba4eb779711496c8f65cc5ab65c5133cd878e1e3cbc021081e1b91682343cff59d4057a01419c494723a07970c1cfeff3adf1f0cc96afbedf410641df73365f739133466612f4a3d682b817e2d8eb419b1a843e284947f953b186a641e98f79347da557599526bd1bb1379f5e5c090ace6f7f00ccce76c82fbf7ea81c244f42e60bd1fbb06990ca698e57a773521a50731f31bdc02e97b4305c90af57317d6e80a981f7683b9ece8e200fbdd24e5bf3f501c31e89b96ff897277ac094ae36321cc760da065d46373ecef2c7c617b75c0c58c99d31b1e58c6dd2b0d8ca4f17ea2573003dadcda2a3be90b92e562104378c4f713551b346adbdae00967cbb87864508c66a2f653586946ca863424d19f3460d82c10801361455046a06673fd5093ed767d6d212d3afef0b41961af91270513968501768d2ef340291b17312cacd5b24133e5ad0c5122c741e6448630be52af0e2e67c8aa1b10313e0140f46cdd394d2a5236db3b2c15d141948b9a7b648906107733eef2618d6ffe485163746d9eaae23a02a34c3c7bb4e464f0fa8d9d93ca549ac1c3d25ee8daf7abaef03ea2e7b7ae19bd3a69fa46b56700b7cf16251798921f29e1c72ede31a80c4843bbd430819d1a4cfc41573cf85ce5312ede264e9a6e3cae9d3642b4d008a4ee0d08140fb86889f8ffa323b061aec642c99f8a2e06dbcc8dfafa67b1d4b66dcc2e4683588c352b2ef296b23dd1502fe5752f6ed8d51f6e8611b17851038df4ad63831df02b99341060948285905e1f630a462c47082f4903230bebf4fef49520756423a182de5db79a1bd24e07fd454074f62732bc096665a9ece9bc975ebcd5764ca77c940f7f769859dedeb62911da6fd85ec62dde01d68264e1f648bf106403d47f84e469a343641186791cfca1525159eff9a4971fa264976f68f7f4ee6459cc4421c92fc10d38148bf1e80c28686a58493d3ebeabad1d02cfe80a952cf2617d0cb4c8a88c19b65a378eb123483d4665d83e07e70b759cfb9b4bdfa4b5bc95ed97c4cdc827452ec1b75d952a3f31322da9b567ea4c01c0fcd9552fe354aad35631099323d2b07b868b34e0512f28dc3496a7b9068ae8c408de1773dd5a309357980c69c9691f85bb9a312e0ac3b83bb1df118859c9330b5ac6be4ec61120e409939a642eb2aad368f6a6f982e0820ad550e13d1f89dfbbdec1ba1eb4808cb51b40b960fd34c6a3cbea9e459668531f8c655de68dfc84c33529a58e34e1e200ac13b592f0a8164fe77da697fab492e199348788776e6ad4dd2ef34d8c2b87a88f6d858272b7432f204410ed727b2abcb565ea82fdda16a5fff764fb3715df7d015bbb337c1ca01bba89efe8cf843329eedb58b57cccb4f3ebea8449dafc91fdb39f8e0260ca933b7a1c00fe4f95d4775d734752c677955efefeec4a846f4756d2405566e2527ccf42cfb506a9868d638204040a304035ec7a276b5af6cbe877dd5482c9819dfe820f38ebca642d2d4e124bdc0a5a03a834b60d952270bbe6b39e54800e04e51f14ebd711c4790f7cd9be04fe2c3955624c7abb69875f733003c435d4760f0d36f75d485ea54256c84ecb8b6f496882de6c12561eef33b885eecd1f68fc29f3940608bb2f01d704f264d1ccec3e6da691f178f5db1708a4cb1994bd055abd79602db3ab6d756a336e9dd16303080398709eaf790ce0e9214eacc7a6d41a62cc50c2c3ef547ee5949e22d3105ed151e53ca5a57beac20a1bef8048ecb8e5a9f56e13ca239cd6dd609bebc20056281917c49dbbdaf7e1899b4ec1bc57cbedcb1b46f66cf8f9b1cb5688776698f0be84dd00300e16d277755a0a82e41739116435d0bcf8086fbd7b002fd0fb3abfe207b31ee131f211e934e2abcc346e534ce6e141226a315d5e3d161b750ce73b2031ace85cec8ff34d7d41465d474ea2e45ad4a72747b582773affaaf2dab2223f5d929c90077956842247c95e2822900c0a45dd8f4b6ed036daca3a9172126f4e8d1cbd9d96ca3db48edba77be77db2707e15715883a4eccb3b9fc2a07ab7a0b5648c1debfe9bc7f55b7d10d1bab27440ba872efef829fb230b1024180581e101dd9803f14315f534be817f6e367bc4a51548c7baf5dab9e80e4f4839d07d3b7693a0e32921ade03dc4f76efd0de4ae20a74b92e87f15e9b4d0ff066914e24c5840d7ec5c6667876d82c4db582f70c38b641d248d763f1752ca87ba818075aa0a9e7916de118af6c9bdc5a97595856ea22839609611dff052db4e32e2e35d2313ff68613c73e43e636640accb593432aec18f0e32bcb1ceb268d759480c368bca2d01c36e5b6f506812d54e2688d387cee39afdaf40d74a85dfbcb9a0204984a8b698c1901628ef7dda67120ac6a346d68788aa3b090ee3496049784d4e430b5c77458ad8bad0c12aa1e39e10e4f803671ae8d7f4c287c6a46d3ef0cba8b54958a252cd76fd18d4d7bd1f0939cbe3b7dc3cbefe871f83f3c75435a896972bca9e30c661a1d7e77348255e9a5f32b323c0910a8a71515a43801c4a0e44201c7e2caffba4d4b7646814a7535d761c9d8504f5849499cecb8a0dc9cd9c7013c99d5c6dd8c324ffe9805a4e1e0aebe356f35f33fb7c5e74e165c1ecb2e193f6718e0a41d213e40ba0c5902a8ce2c144e227feb413c20deedc212bc9a8dfdf9e787e798f29a68a75b3711219976deb527dddd44946d4e199e3f3c2f7dfbf144836cf4a3ebe1c19ce3f8c7971954afb2e04eaefa34fbdc74bd2612e01e6e30e44c362bea2eb1b85ac86f1cdcfebae1b41380727a1c1cab98dc2b860274fbc9782b8980480ec2efcf68ec2a7ed03fe06321a7664422fadd7be0b11d51e3ef10a88720d071b8e50efbdeae678c781c9a320c911cc748e83d6e5a5ed4c28e7daa79ae72ed270cead52b6eead7b86c54c62873063f51aeece8ff5a4de2325d3b7f3611fbc669dab790ba220c7b53eaaf1f0c8e4a29a6398520599d785174c714d046c7b7a954067257d81204e7e924178dfe47714aaa8fc1c00514eb889ddeb471477d460c4af198ad6f18e02aa5f983541101564b4797714c3b9b56b8f5c1f9d1fbfe7801475879a037384839698a4f9d3a1e420db8a04f5f1ea76f12c7dcc1272e44b30d711abfc78eaf9190ef8c9b2e53ba8207cd7e0ca1c7c7c1da5dcdcc062c4d84ab6388885851d7ee79b585d33ff6de9c3cab202150ff218d2a2553ce3432d97c12877161d2edde53887484c2c0fb183ba95e259a0d2773e6b37aa6b415b3dbc28d7e4c1a4c15c184fc460917ca7012330c7ced987b7a91ebca3c1651230372d53aef002e2a9d30e75cfe43450f8d16d272dcd914e951dba3503bd216ef0ce16c1673c4a3a5b38a850d9ba99631e85a876df83f92b5c64e84f846fe321494206fa810d87d5d0e88f9c23ceac278a1433db8cd6cfa4a6312b8e765d58847e9b501c8b37fe91be5eaa846c34daefbc7aeec13f0d1ef4a2af043d2aeb07a205d49b36b7a9541ef6847aaa242093904282107cea2f49794a131727d93678f8a6ef5697735c1aaf3d9122dd471c88301585578cfd3ebf7b1e2646712a735c93a06148706c67f01c995df62d90e73da0f2168c93841237cadf23fb43715e9c5f607679ac14ff60cd012e6c561597d2cc1b8db2e4b4b1cd80e06b68834ec6b67820fd6504981e85459254c887a1ef09878dc532faf2d2286a94f866200e33cdb3088c7fb03afeb1ae6cdd710fc036b2829a520b61b05114d46584ec4082cc9ba41dd96290c3dcf183f92ae84b0776e546bf2dce492eccd7c2ed65239dfe286e8205e16e4ca5e40423fb03859641cd189d5becce5cc65237f8872c18c07c6ec3dc320d234e7070cc760245607e0d9668d1b637c2468812dc911382ece3c854c65866e0665a99f5857569522884cd0aa1457a2d96e0cdd9dbc3c28838a77cc9df699f0e5a94a284115e24bb5dda93e025ce3a2c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
