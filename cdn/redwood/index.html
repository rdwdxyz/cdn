<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1564d8e8ccf9da50794a72af1d7bf73d08a2dc62464380e786c17d429857fc2d53c85d1f1e5b05358aa40e58597c215907909804265b16275ca8a2045461eb630e8fc844e644973649afeca5a56561153aaedb6c823de4b02b14b335893dc774289d48271c9d50d4212ea710af82d66881fad2a08f0696cab453724bb2d9c564294d762a7da93f9bc1faeff89d791dbb09173b1b16ddbd4bacbbce5da8d1c98aed1693d6a4bd7ff0c12f2fe651c87df8aabd6b0afc6aa6376e5b97c7973d5256fa59597bc3df18d625a77f62df1c8862dd8468bda5d663050d8ec96a912c9c265c739b2cad40ecaf0193a766f22eee86cb43b3b5834d465b4e05dd2a1df5f7677a333543ec9d2a8299847af66d41539ba196259f3f79fe57e4d84138602ea11112b21e04f3462a5ec4348f87a855e10a05a0e230276fd2df577d155cb07762aa681660efce81216e74611dd5635e17cefd6f3ad16cff564cbc4c59b375518e5b625e970861fb4f221f5210cb8fa5fdc4207246ef6852d224e7ef171530d09a9e1f8f482873fb10e77c3c9a9db26d1daff3daed1a2b474449b4c927229424036f39f5f929980122fd08faefc05c37b051fbea059e6d507c76c8a6ca3437daec25579885d750daa47aeb09e94c989a06667e75acf6754516eddb4236d9526e1d8352e3ba7ae7aea1ef5a93a2745521f085800c37d81a3f42a5683a1b6a88c66420ed11f2a3d6e887e6112daa9dedb7ab8a459c015f1bea045714d18878f4ea73fb436bfdaf8cb652991f88b2c0576e5bf47fee21ee98042b947acda9e773cf07e1ad5f9d40a3bf8b64dbc4ee5e42b1c46b0d49b71b691c6158ca0580576a8a605e15c8a55550e392a152fcee76bfe813ecd459f6a682b6817ff6a83f921591ffac4b7489e3a9eb50a2b909ebad13d738c6c0c70c3010f959fbdbfb241d93004fddea62d1871be3e034afd2d24bb93acaff269fcc23fd46b9350a35f13da7c4fa00eb87f0eff05c2841d4f99f0fbcb38f8de18e1ab191fc6a46313cc91fdc312dbae933e8ea18aff2f32f88fb5b57eabd5f180e917ed0164fda1c5c4667888d06d74a372c2c35598cc5812f906d61845e3c755017254b233f7a5de7a84d09a2c7c2f6e13adf9d6ec60b4e29ef8b611bf9c43a414688424b784cfcebf7589510b57517edea439971d4652169076130e4635d576bc408e35e03cec253c82a1ed71f51cc06fc27472418463119347341eca51058ca1dfaaa81d3ed8ef9ab7dc82889e1f999acd7f8505c444157ee985f4f1eedba24c53760bb3960aed36fb8b0b21902b60abe6d4ad595a5c0696e552d01fd7ee07e875cb560b5da18d712cc66593d2be3b23626f874fa90478b576c62086a690528936b8a9de85b9c07acbc4ab23c1ecbbfae666672d17fb7caee740e104b514b40e993a80f99d70f8d03cfffd9f8cea5dc8842fc874acfc15c5e94c4689f72075673b2e12325fdad4abd640654b735c8a7073970d8fc36870bbde7fb3f135e95328c0c04104953f7e9bf7004bcc4c4c00233e7bddd834e9356bff430d028deb7cd2392a1b10381247319872888344a361b813e7550a08b86c9acfa765c9ba4f61c4d6a6a51194ee246398ed4cb48c52cd2a0752a112d8db028e0a019180aee0efb6f59c68cca3ee78ce6be0bdafd2af9afda93044fdcc21894ce67f6ecb285c7ee8584fb82382564854cd96d0526ca8f16fbd607dda702174ac07160cf19ad67cb49aa2c98541b842dbdf9097feeb28254d8103aa3422eb097d4d390667bf85399c36b3bd7a4a1200ac0c1ef14ed6d7d4f1d15cce72fdd58d5bad27a2a10460b4c17985498e9f502b72d17a8396f2e0386cce936dfde50486c9a6a35c86fb0a1b0063b1043a7883179497410d1146622639a0475ea9bdc00c5f768efc56e9216ef55504932f29685e5fd493b9ed9ca7f6ccc246dbb372903bb326dae8251b83e79d6134f337c514dc1b1d5c44bdfbd93e8fd9c3a72383dc310114d6f5bc681a89289905c80b0de9a7e2db4c1699f739ea6ccdcebb345d84c7a1c694a4385c932c35fe7ae266be907ee47ddb878da640ce0fb47b962896d8249571a6bd45dc48add37daeae664311e25afb1ed8a29a355fc03511f54d07c0ff263f61a52110ed8846d42500a3edc2643fdd2fd76c5f996f24c3e274aa3de1017a737e666877bf4a199ef398bf45fbe3d158ccf297ebe75450140c3b6147a814c13002b184b78a6c85cd398d24176ab184ad286e071a9abee827819401d82af06d5808173987f282458ca7a9a5d39e79287becd280b0ec7c76143e68df304dbdf26e6786428b314f10fee32d47c16d63e18e8c9387da9aabade694259538493929e32dd48708e99d327790171d2baf3354f27d9b6db6aa5c039e180376b25747ece2a41e3c00ddf585db7f66540202392305a189de891f182884fdf3537ad656a33a520e7a7145ac8595d4dca606cce47d9c1a04d3678b298ca34237efecf86a1e0d87cea3c98d46add3b8611e97d72b8edcd941b5f008504504ed883a590878081c219c1ff9d21bfdb55dcf0942296fc9c95754e72a853c97be6787fbe95debdf604e16d314d7ebd651aaab4d54aba4db9a3a8483a24742a3073c4a6f583096d3a16ef2a94f06b02c9a13d4a640b1212939ee5595d7345bfba9d3b89da1f1df290d6006830a9e3901dd3538e9b8ada83566c28338d4ae63d95148337b8eae4a9d8d0f432b3d1b8f252a4150357f34e214be27a93410a11678794fd66e06e953f79975fbda977d7cb108bd800dbaf11178396f7d1c69ce963c84f623237e09bda49adbed218cfcd7345c5f8a3826f30936b154918f0c8cdbd8641a31512b37c95c3a3fb1989f44d256901a97ce6f4000958306040d5f0291160a9b52f5dd8effc5b0de3ef35fb0939309585352847be30ab825fe1044e767507caaad8a9ef3f1ff3595cc1d7540eb85e3c523025ae597e2f2daca639980240f12e1cd44e6f8875ac367b13c6fce370d4e0a557cd92149792d65dd91e7575dbe8a387af82c1cfcf99e11a2f9d61524f5e3ef10b4457d4b681d0b3f8ae0d5382b25df869b6fd472e8830a434a9d4da42a2c189e1c6d0fa463932416ccbab2bd9d738032be8228a321c3fac29f5cfebcd82606d6c363bbeade37c4432edd55c96fd785cf36b1f706546c60f28f736b23cd0d314a64c422b930f7b7f4d7c41d03855ec7fd3880298b60a6d2021219c0d82a0aadbabeb5d7ffcb7298dc526e45b121bb5ccfc3a8c3a429c1e039909d2b2f66b525d2b62bdbb4635810b88e28d7578feb2ea00e9db95205d62a319899e89fedc970d20248e6314aa42386e06d4cf92a01e66ea54d46d538971c6c90c2c091688b2c7c0f47eb0d3a8c835ea33dc5a03bb037ebfb5407cb5d93bf05fbdc4929570479b9cd87060de34c2a1bc08146b14ad5eed1cf6b7e9ac3da5627e5c84b8a7639ef537a15c3deb66c078555585ac9ec35bfff7c1c22054511d4cf0e2a9ad825bc33bb07b3c19c30982168f68fcdd366cc9d9dd9a00187f331a6e2d103254ae5c83851489250f4370f9345b5cdac35efae944d9f7509684aa4dcb532cb6401445327ef9e220571c69787606a2687121ca33f083eaef51aa273ceee0619558aa25fe307f95acd36b2bf8e851863a0c8054a08e1e0a7c334e1c42a33b3dfc037db224001ffe41cc67b44a55ed00b52ad5eb7327e35a14e17307c3c195eedebbcc8b5646682a8111e22befe91c7272b5e0841e52a1fb89e7636e04f2b44b31ab955e8ee681ec5f7aa5333dc29934a73fa5e5f7ebf4eb264cfee6c81bf4e5aa8b56342b204495481d5f6a5d3356da2ef8ea694f4b5e9f48a43d141a58346c98ba19d4f22ac33b4aab8e5e5b918290c0503985906abb22851ac609385619835867802bdd2d295029b620b91a82f94ae1b0b6d079a976dc5770565b55cb27658a670dc3e84b4f17f3359de687ef6679b62a3504720d043cd52cf3b7f504d6b1275f5fb4a6be80511d8d6d70f00135a9f26c6f1077016afac60e43c9a772bfe6dd1997c9a8f7a4fb0e6cd7e5b16eb1dfcec5a0857f3f30a72ac67e4f2aa27595c1b7a5a11604e0ef510bbf1dec38f2c666df3623d46919cac8a78f05be15d78a42d53cdb29956eed7db550a8abffb45c7e0828467fcdf8549f799da673396b4cce76dbad19fe4ad9c652e9cf12bb351fc9f89f22930a8b0e4ed008ae25d1a9a31617df9cb6a2bbb2f0566b97c17c7b0579b9a2e43668d2d3138130b356ca9be38cc8368416f0b139060c524e515ef5ce29dae05c23a72ecacf4361e5c8d4b8b6b102dc45a44ae8146eb4cef25e829d8c395ea2a7fd29aa698e74fe814c42296bc1ccedbdef2ee98346a874bc593f15306d6b8e6890249743940b8055bfa2b5d00d131627e86ae407c4b6c9dc8121bfef0a7c0202076f90e5fe52006c98a43a867559572118d65edd215bff5e6da4c26c479c98026acab597d36d8b8b2ad5905dacf6eb7081e3d8c6df9b4f090b7c7cfd092f1b057fe7941fe61a6cc34394646f2b529dc6f2c51518ee3285188efc46e92b2dc1851267e6c238f99536083fbe9d40205bea6d85d6f99160df0ef0013199a5850cbf6a2c49209213c42263516d67ecc232f3a0893f5ab761aca25b06b2c3724be73ae6b6086ffdeda28ea898ec8f525b2d68d4f0a041164062a9350876c6178165cbc5b8c486ff7be71135afb7969004a963eea07afbfb53415d77c80183162f74757bd837c9a651c60f8e3868cd23f5edef16bfdddedc4d6c59c36c6119c34752de15ab33a7011c38cb5de51ac791e2602d7d54ae2136fb5f7262503dfa3912698ba84b01f51c790fb9363a09fdda4ea94a13721b612837215a17095723453de6d4453d4509b449f3585d07cf6015b30b6a4564dcd29b5afeea0ff646330791b70098c2e201a8623acdd9bc7042c3b284399034f22642f0a47b7b37527bee894950e75d53c9f65af546f0725499a693b7e641fbb26f0d142a3bbc5e263b3f76d182fe94f1af89d02e619db5c8c1c6081c44a217bd19e370a0aac9465dc511885b44fa10e4bb2881a933bf2cf27a7fe7030e72ef74e7b82ef92c0f4b9a9ba31ef8db53afaee303af88c9b5748770d20ab8b54c1ca8aeeec5c8a80afa33cfb4660bc1953cdb6ba766cfd4fe12c0f57a50daa8e90cdd454540cb32ef205214576b598e36a3604cac2dc0a42f7c7af6c613aeae520e1e0869b0a2eedc2e8153c5f5bf2d824d8220ff4057565ca4ba684b4671db7f152bea3c893f98ad078c4013b9abd2f7923ac35cf248ec1c9dcaec1b9366c6a0ca8df862ad14278ae89b4f705601ae130da99eff1d346bff203cb89004e37726f836b742e00fa83d4746af6c58cd6f08e8cbb12572f946b291b59bfaebd34ae0e28c4719fb7c50d75dbb85811df8d6f3749b3148930da76a9ea586838bbba0db2f20152a1d4859a73e1626845df443f0787bfb5195847777a7b536e86cd1a13c74b22f3a3c86f0ec7902212d098365ce2d71dd174e1dc59fa69700753a870fffff2d942166c4602f902cd3a3ff3c23c4c46d8ce453c3f66beb6d528265bb2245664a589da252e05d095d2669f4560e578a3c638ac764963484c50058ecf57d9cd419a5576000ea913adf600074e7143f2d29fd918baf7461b91e96168efc29b8f5afc383a69dbe0eddecdaa471322cdf62ffad921d5f994dc435157d61832aa73be90e42638debc121146cac539fdc0271e0193db227fb41d6af0b9d1099aa973a0f5e24558d99b4a57b6c49492aa9fcce7046fe28d5c888cf6b247cd405ee20c667fa4e9984561ba7c8c4dbb0a451c91b40a8f6a960cbf90fcd668326e17873c4ba8225ec0137c929802dcfbcc2609a45e0bf280c9915847375235a5ebba6a2a035aad0472f5f0c34115e686d63bc5c5fe2b27c60237c39605dac065197c7cb7aa1f4439a62591f7570263f84398808e14e57e7f80e2883a91a6d0a89f44d00802ce9f282acea323608b53d1716710782afa196bff54b1f010b609ceddc2f73c35596ad4df46386ed37f887b0437a1d4e151d2079d7eccacb73d90c6c11fd5649ea214bb25950141a378f559455ee8b0aea10d22d043353cd03b53b91c6494cb7eb76187b68320c7dfa51e00fe45d9d7f570acca6f51cf1fa0a7e338bd5cca745cbb8b32ea9f51926d8b9deaa5dd16dc543e4bc8a38be52a796c94d2774c49ed6324c9007157e0e3e83673bd6756efc384d398499a9ccce1f23677f5ef962a8403af93a0ae0a7b1beb443296d92791989e57c154461dc06dd74e23b24f3748a651da568d666335f899be79e46bd66b37e87b099ffeb05d84e9126f1ee6dcb397191dcaffa5c37b51451bb33604918a2e641bc8735328eed848fe949f5594c51368f1b4d3978b97fee534435f54db3481dc23f04f9ca9de6731d27158c929e215082e95997978329fac88832b2ff05802f3abd3cd321505a808403e9856034d2325c1af9e3805d8b1779884352c1778316bf5b44afee4de94abb0d3931dd516dc641390e245e0c9e5a9a246625531b525087d3a6137939679d926e7627605824556506fd07f24afe78dbd66843c60d20a2f09ac33b2a02425d7cdd9615cc9e3576f088aa94f4ee422e358d60ecb1d36d39d4b12e526c06dd73a1b3225c950ecf202049498f54fa3b4e63ca0c50c46a8d1adf02ee336673894bcef6076c0f37f95d4a174e892e91212087df48d437dd891ab7bd769ed28eaa84e02702bb2f82cf6f05451d5fa60bc4e94beda4e8956beb2242847bcc8ae83421eb90e0e07ff5e5d11ee7db37519f195e10ec9d1a36539c36eb7778c1271cef9c02fa783bc343518ba9012d348b249bebebeef3762ebcb9b4d3d2aa894b3690c8681713cc10d29f23c866020bba8933dc02dcec04a1b25636061871f96be458911a6f9812f2efd9b916f0ab636057b2df7634572843179ba5ffe16dd3f05d874ef6ce538598eca47f838c40f0f2fea27b29b994b6c4d038f9886fd4cc2f34586de27da918063accef3fee5bd3ea6a328f7993da04125d9dac32e763579adad2b10fd6ccd10c5a9ec09c65fbe1ea7c8148084dfab7589056a7bf0343f1143f945aeb1cbdeb57b0dc6cfad1ef38f975b89e531928b4c8e1d64685ff10632d3378112d3f2946c21347afa00ab04c814cda17e6cbe68ea8f1e7d26c3d21eb9efcf0d6017f53490c939c5dc5b20f6dbdb75fb78e3697980717f41b11cdf3a3163289018a27ab7a1074f71ed73d2b53adb01bd446eea660f1fc0d053a64cc5542083b3221bfc0726e4e157b2dfdfa08cd3f22ded0ada6cae647b680e310a475a85d8cebc51302d48102e94f1892dae191ba04391d0229ed1704e064056adcd1dab41479e6367b94e82eb9f1bbb15cb384921d452bbfa8d8d225baaf2b691dab759d43e402e87ce25e26683d62013697ae238b8fedd0bebd3ad40fcdf5abf775a8ad2edd7ffb0db6ed54d6ad4e4ca64f15ffc198df7732d185aff5ebf77a10e1f292b38ec1104949d33592f5c2a2d4de71d6c736dfcce51444db479d15e170240d209c23840128e66b4cb5405b0246800e7aec5fd61d4876a949c89839479c321adfbd5ecbaac447f66471817debe2fb124f9937ecb459e935bf8b3153e9ea4e10abae42a22f419b8bcb106dcb11c2316bd9777ab5d423c50b8c3d21a779272b2aa44c13a5d5bc2e8bcf2e1707363feff55bed5c7685943f1038f02c07be5a516a347d77dd5ab79ee9456aaeb24ce390b7c063c74b91877c3ba2f7abe9031b03bd259b01e5579f25a0e163629e9a196a3de8ab08ab6c55362190becf3699c383426dd19c031048309b162f0a7c8c908c0e11440ca37ca9bc0a1cdf048f142179a7fd8bc4ff606df1d053e7996864381f28880621ad4ca5e212d05fc5ec56afa53f715ac0274cf53954ad7330246bcda8d48f3c0bd107f971ae90cab3ccddf16c842028ad3796ebd36255e9eab36f7c5bc2a2c7f6eb5e64505727bac335214e3d00a2f7844bb537677001aec59a2c44fa6b234a7018e5dc2b836e6e876bee6551fa80618f9802eb34359522a5eb8ee66dbbae5328d6987691f0305aa764c352f1a3919c639b7a254fe9d747b510f130969fc41aa7555ae419e81155fd410d12f27130521422619fccf63abfd1b0cb3741e4e278508693bfdf9352237144a72cb17788c13bb18496b83652c80e07adf9049a783f1f4217cdb1796f97580e9a8f043eaa859a603bfba68a26ab930a266183591de87c2124d0934af6fcc77c7afec39c295929c0261d59b144e4dfe2e1f46fbe890a6950cb34d80512eab0b3e7cb511f54b42a3e42c955f2369f8991f0830bc9cb450a0e57d4fa4228f820193032693f7d171bf735eaedeafbcb6ce7a81b2415100d5bb79ed9613be3be1e1d844564020bc96afde38a9384f06c5e8693abd8e8395eeaef2308d2552be01caca2c952eae229edf60e8046ff7f892f6aae540480c412cf4f51d0070df5403b79659f77be680f5354abc997584628495ff57392467a4f8636ca2fc5b44f51db88ae30750d9962268b37dcf9429c2beb852d0fd60ed587c1d57f77d6f309861dfa8fb3d613f32e79a70a09c67fb0716b3f96aebfac5b95a2da72dd1098ac2efc747b8171f8de7db193ed62412f305dbd92c1df1d2bbd5d044d6174f865d55acdd80d921dcae3f89586cc183dc08356895edc5e8709f4392a65aa455fa9895e6b6bd563f6e254757a479b13119e9c0612b71c19041afb300c181b786aee8764546c32a18ec0c8a0f0270d46dd536b92e0193e7d2215d001bb8b343503b9233a12bc8aad6b740b8b02cfec2ff1ac406e311adb108dc5e768d5d1136732ceffd3c23f3a5f99a191e0c2e8ad8e30cccf518dd7d5560d40ab2a17eddba38db6c0adb2d38832ae65a4bcdd4de6e7fc7839c97175af39240db68775f78620c3b704834afb72cc6f689967d1141d25dda575951e624fec87afabd5e44ec27fe04dbe6b1510ddf7efa778d444a485f5621f07cc6759fff3bd6b280abab201daedb6f042b11cb7caccf8a9babe0bf00d4ea07b67179ee68fc56ee9fe1e2fa703bb5c6bda4304bc11afe0c5c35a9687d035103bbb86b7f37d6848f997258b6eaec4a51a89ae4758835d1f5305581b995f0927075dce738c8e0975bfa73d9545f7364d9b2bceb2dc156a7381f06449be4ce42d7c843a8252444c0d8e87176e52662daf94f59993f678c4295fead42fbaecdd35982041c8442fca67bc758ba2c34a0b78c47d2f6ab1069850d0bca7c50758defbc144fa81cae8177c28fe40e80428052a39cc5b719e16ba99e559ce86dd649e8d2f5a7491dfe18adf8358b0d7b88995933ff6eb84a458bfd04e5cc7556bb7b2ddceedd218b11137c6435c47b205b8f0d00d57af2dd82c9bbf22fed034154ffd66be8200f16db3f5298d46ef8286004c424e18361b8027a86cb73486971b8ca87b16db51c77d4fb48d2c2c5eaa2655dfcb347a637ec86135d5d8ee05a6114abf2e6e766f0a95d6b8953c6dd3be6ab4746d16af872cec651875592a9c23981c43256292fae657ffb6c384927b34b761354c5d3d67614da1a4f8e6421177340c37a3937e3549e4876f0909608b6801cb751698f6dad740e361766df8d0e90835b2da034c6dd977e86efdf9be059c78911bbd67ee08514d139b9ece64aaf9e1cb99da20fcb1ef804e6807975d81e2e6b56d3658df88444ed3afce37e70e2ff0fcfad3b082984b16b9d227eeaae340c73998d1bf103a626cba247744954f9f16ce44effdc7a28dc7418fe1e55ceb90f9b1d963ef84ba5e82d22342886e10a2758d61e7a82dced60671da858007bf6ba5739ca656689526ca49184b3ae850bf12c30fbc1166a83de4d1dbfbb2b826dabcc742ed77c5bb5731f26c865cbc0860304b4ff454d74878c709106c85b68909d3fc68b2df3125f8a8d3c150f53df55917b61ef35e04d67119a4a5aef45d5d4576b2373e7761e0f81b07183a77d602501bdb4117f75aba72f239cb5750cc3bf35039a0474a2f18d1991c54f242ef0df250af82dd662ccea2f2556fb6558e0ab77b384b260225a09440bf5e6a1b03d28827c9ef204f54aaaf8c66a34599fa17f06008386b855cc3cd85b474d56deeec0514845d13812398502e9822519e915990f71cbfdfb60966237b3f62e4f1d2c003349968d7cc2169f8ad6fc5d71a85ec508b00df33f065b000cbee78839e396b5438de799ac78b980380f1cae5503ea5ec6c684a622b63767e45ab09ebfff1e41b36f239989296f814a804b945ffcdc35c433192e3af050dd0001555747fbd75fbd01e89c22fa88c012e62431110263c0dffb10841ad75f1f54b8b91b8d34f816f44a76b0ec2b59eb36804b3d4a4a9cca5718e0b3769ee7ff8a7358ba7a108e67a20f458cc287421be8d28f4e9aab074b722a1593f531847584dbc15ee8131a888829cf5c16f738956f4ac2e8b2ce33b37328408af1a641b974583512ac87eaadddc9f058e2b7129c23056bab363b49e4815a41f49d602f637a725a14b57f07082ef20cae1979d0394945b65f44e74730ef3af125b6387630af8c14d9c7dcf6fbecb5b33764955e5d30f20250acc3c1f58ada883b945b4e3dc516085ffb8bdbfe807ac7c02d9bdff17a06c0dfe162245d39b60fe3343536ac797904a6c504f27f7da9ab04edbd32a57e0754da928a0c4c7c86b2434195c212e0ebe6a6ec658a90ff27ea259128adb0fea8faa0e8af04f35b31f3f3fc82b78c08974fe1ba7808593cbb3846a323d5edde6396f68be85e2a86a92551b16575c6a8408f85bff67206b56a23baf7f93594cc82b55328e713b5815df7b71a090283523c1e9fa60fa5c199eccc978a5db6da99b7dadac5d91cf14afc9c615a25b3bce5109bb312cb62e82c1492784af3fbeda338c103cdab399dd84e5250b043828f80dcc942027c9d0edd3ce5814a92762ef6a49d1963d512ac577a94dd83e28fd05961eea2e7efd6ed22150995b54e48ffc1478888e10febfdf157d700c77047d101f64cbd136735f794cc28b83383ed19fb5e3a56d33ff4503479d022962e6dd4733443d2b7771dbed547cd04f51be60ee081b3d4a13e501302e867296d97fa6e8111bc5d8e7a15db2aa9c0d470eacefecec54a45fea55ebf393103ce13bcd1e5a2c07ae2a9b75dcd3a1237aa27be44a52bad4d1702c6a47b702c1334ce022edb54711e1665a3cfd6db453f8fabff9583dfcc9d71bd3eb42c52cfe8e371f6e4dc098e1b08a400d0cba4d352356c6557d028df7dcb7a9e0f856486701b83a62676bb08299b7b0690b3b32b1da7a2e52ff9148f0551fc0a22b893f0b2aa30eaaa9bc8c956626451e9f0983ff0a1b1e0d088d26204451f483cc6bd33cc9d1341dd4a6923f9a6448337fc44e8a508d5bb9f317d7c6930536c59d463e99337619e21ab8c59f72a2df0ad256254735f77b35b408fcb4d686f8e9f7a2ca1204d844c64264e41e02bd4ca9bbb589aa3c9b124666ca59b9460e334fa6e568b139bf0df4f335efa6871157bc93096cd97bf9c7fd92e4a7756f829637f3f5e6832d766e5f59e620f31b1bec14d9a21a637a0290a8cda444c1db21db786190bd38156697750f77307941284919633e2816b3a304ea69eeed2a281ccda05ef467d94045921456cb58ce78c0825430d8f7fe5065a55a922241d1b668f05e83f6e8a2fa22bbd604731ac822f5debc906d25203490263291dfc9cfbf8217ce3435b169faf06c9fa69084b50bfd796ad7b37b910a3a21bae0a1468e20a0ab688700e95d4502240cb41c220f7a469bad49d70c78f41aab69fd812f8dbdb95229340f8d6ec3ff5f79cd97ef10dfe10b5ea14b32c1ce8012399e3c5a6076e6fd375fbdb0db5f278c1c40c5b117f9ea40a24ec1dcf3f67fe3ff7823b65a32c21a6b1bef3a7f07a63b2a369f9bb383c98a073f831c9961a6b10a10a7e8910d748b96e2b8157b84ce620b29ad473e294c10fb3948c8df6629b1b0c988941d905a049e2d5e5e2de1ac826432280252509ab03e201d6d8de7bbc33e8f90abc56d39853884c04054a5dd0c3cd58a6260aed34176260939c449c50d7aa57327cc1a3b5e938be9b7f5eef71f26d990324ee83a712c637fa15010c24539a914a6895458e15f97ae1b137a21ccad017c7d7296a2ee264e310f9d1e059171aa9160944dd5c16f82d85c90a693b81c92773f1cdf2723fca8bf72c0befa4bc6164177f31e944e09f3e0f84284a3aaf4d2b169e8e13ccf7a18387758d29939541322e639a2e9fed2bf07d78e0eb3242f374a2cfb4155d7b76a5afe643b47263a288b4c91f9b197b730f6b89cd603c431d262d8766b6325536ff0a1f03344841a4e4d32a363b51ee137fed013cb4148be610eb484357ddd1fce08edab824b765f9b8b4f29c03d100cd434b70737a0e6374e6612d2e09762b4f661798354c6d953fee620540cd9d3eccccb359ac4184f71fcbbb6d1f075ba099412974881d39f7f94f4368878938b19e6849ac48279ee910fc16a3b22471ba61c1892481c758a3ad33484ef3fd15e447c12ec016dd736e69aade659ee56274429e7509556900e783e8f3d4dc6a215b83638ecb92745ba09fd3451877275c27ff988135e70112177c52b581f6264093be8957531e7444e52b61f943c976ee6f069848a1945e7d35188c96c83491d5227d152883ade7d0a61a26e5e7eadb64f526e4165cba40367a7512cef9ab3dbcb34c46d027cb4c9b684bc025ac6c4a51b1d80845fa1238be384e84d33c6e978f74a94495b5e5b26c112e08a053ba1d958888ccba0d6aa5c895a19281256997377a622eb4221f5498a548ea56dc00c8f3e0d225edf1e3685288647f2d8f38439aacb6de47f36bed5f31da121d991e905090ca2dc7353daa2957df874e82976f02caaa31f7a2dc6601330f9d4a6124d538faf67964a09aa07898fa5d54b5977c953b7a6888348842cab25340dd800309a2af1769d146784984999abc482c96c82d4fd53f28f9c188c3adf8b31631c84e1614df614acf70db872262a7138167d93d33ff3f814591782c4da8efe148d69db4b8c048ac1d2bdfc260533e22dbf76335ccdbdb8774526350617de466c66567c66f4844279d5f04e8024a7efa6a438ef3a0ec3aa340d82a1c7e49ac34d2625c5def40d192ca15db3b634a87a820334f891027ee55a4cb02ef1dced2883e99f0a51380cead3208b499a6b2c123836196995f61858a01245e832ae70d9d3a02675e75e75405ef5604f809d6011a8df94f6623aac93b4db24abbad366eeddbc02db97fd481b2c6e972721f62fc4ad8f18352472678957d8e8959c5c4529482f4e56458041d017803a1d69adf6f4360a58de3abbe3105cb7712c0b6a0c1528fbbcc2f729877d08a7493e31511dcc65ce19a8cde111eef52b0bec8b02f4399bcbb9bb57a2ae4e9a9d0597971fefa60126a71de2948e834d937074ce51f63425bd85c415268950f19288e818672643a450ad0c0fe85cb3eeba0787eda8b75a2d03d16bd7770deac3b62944c7ec5f388c04e02063236430ad6f3b0e521aa26b86b2ed641e2320266947416ff89346275bd76e1515fa8ce7f31247b7b743dd832fff3bbcae6d2740ddeb7f1e05155869ce4e5f89e4e7919a900ba442b4e8ac42fb5d5c684f04e57661975143f4f56b07977633d54ec253fa099a11ece2b3fe57101f7f62b2b4dd972d9cfc91ca54bf3db4364975d956bf08de6cc2fe30bf943fbcb068621c86dc8be3ba307d0bbbb535bc96cd730a7787c90aaba6498f49baec6327c201cd0639feed1bacc04fbddce59e455b2e28a64a5d8accdadf5a83afeed0eb902bb4897a562d1fa4eb60dc4dc89437c7e659e85f19ae449ba0d0a2fa93886247c73a0ff5aa4db282781e72d737ea604bc07eec9f0c194a08718425f849bc8b55617f53a95ea4c5cdf5b85d83b583247ab1ccef43427f0dbe638522fad98866524240b2cd61207b4530505128f12766bf50c11447b092c2471a203cbadcab60c88814b582cea888d3cb38d8deedf1eb36f15ab528975b4a0723479cc0f1996a92ee9ff354d8e5664789e7aa8f545b767f0d1506cc26219b6049df2f044e1c1d03cd63084f29e1a56457df9a593b7013c3f9f2b6a9552210af7151b302bcb154bf1af14b77f8ca093cd570d7f9f374fbff7bd71882c3fdcc9182e2fe38ccb632d59b48aa1c91f679a3442158d0651caf95a2afd11c646f1d7db2488f7ce68adaaeeabcb1caf19c87ad82fcce879e42f32f90e7e98105a926444962eaa554c8d2e253a35411ac2fc0f6061b5c84bf9a3d96fe4a17c7efcee274bcab5a85095a79abca6166fbe28a5c65bba8ae8441927ddfeb75eb1558b35491c2d2cec1a7db1d9ef3635a4297ee0446cdb7b6907b336704c8cd1545944b52cd4e30f3a40c410615043500ad140c01e81c97794251f73067ece0eb17c41a2711496c2f6ec3b46fdc0f2719094395f8dd9316cb27996a44e9578a9ef95fe8fab67a4b8bc24dbaa68e471e11c88922072662950101811e646b423acff24303192e24d59904246569fa0f3a921216c8c450a6ebd08db5a7c914e18b49bcd90a8f3d61b7acc6fa4faf211e11c536fdd0bbe9a95b3c3e5f6c5d4a769f15cea1a9bcd775ed01d09b5e63150d7a6ae4d54fe3f44fa7af2ab4108b20f1891859d723076f365c60744299abf0408cdd61785d19bf3c9628db57298dca6a68bbc8a62fdbb4e87a7ef1b53f0c43306c5e3d5d56fb9bd27719c18bbddf6a32f5eb5db8743a51ab2cabb1e20ced5f7e6e0849d05d2d9a1028a4a7bbea75be9308bd824f633e8f9273912e219929fbe405cff9c68dde428cd244de021d327e1696cc7d281df935a68d10465c6305668042501627d66ec3582553c835466ef613306a71d23b503d3655719fd178978b15ee686caa2245a5fe29c75aa0549097ec204e02be93186cbcf5d57f5642c1631c942026e9dc5b78bf576f01661141663d1a9311aa1435e00a0529b88b4394a9168576f3c66d19b1a8e0c49982c8154923dc6e490b8f9f4123f3959e28edb90bdf2535dfc1293deacc79088b9dd1026437600fb721cb604c1dd868e582133d7b8b0a31675bb4a01078a6e0bd432e3893d71e80f48dc4d46ac2c6550a910368ca9aa2588c18ede6543ef0ee9506f0fffcd462d8b485f916184608ac5f53309333adff97b4bfeafe3392af7426d0a78e57f3a9303d1c8b0ba2bc266a6b1aeb2538b69792a55f1561fda184ff439311007946026f66fccbbc29cdee64b883bb1e55357d1a882ad22dd84807ce6be42ccbc98354b1f8c6338b292d0cb66ab3efdf26faf92c12840edc25cdfcf6e39db8cfbbaf46323ada2b0b34ebde43291bdac6c05bc3da47fd1fa66b4cb0fbf89bae7c07cabc25b6dd4a68e08ba05137fb08f10565d6690a9d471872fb6541caff12922da582b5d50b1a5af92bdf684204fa064f9641714ce7a51425efdd66c474eb15f8d3acaf4f768b5ea708e6d066e330acb9b3e6f79a5fcfc2671aa20ca65074c392113cf523a09677eb46ca04f22bf2e6d8d93b3c2825beac8f396c69a50c4a09b043bb6941c3e2706a612353fb16ee32c603e35ccee2bfaee5f8d2e9b9102025b7351e911aeb68fa57a20a0fbc08203784bb5b24dd6e783688e89873843edcee9784a4c08895c352e77797848819a396130aa343e967f7e5aa61f326accd2c0bdc4bdebbe1158e17b9c9a915e348381d82f0492737b06e4a00068dc4ac07a3a2502f5cd9fe9fc7274d2f451d1e27243012eca3cf839bbc907b4eb388b126c3b89668c79794d3c940f6d49e24c6e7e4915b817d7e452898423259c29c63edeafbf8365fe2f7ee467d417964239ab57acd7aabc1e284b6ea3dd32678389db73c60dd4f955aa170627c12142e522f9765c4135538920cf4f8adb7e17c454ba95c4cf5cf8db0098352a939dc1f23a0e3b75a1af3e5a7b2eb2b0380ed251010d21575e05bc7100c52ce530f1c9795f682db05fcb28231877ef69bf6861085706edbdad2bad247461c295cd14732a26dc44004ae7d58b27301483543cd1ea3bd0d7e62b769305446559da2fd9dadf1a6c4d25ae563b03864a9c21e3b687de73a5524890bfd4a1ff96a08c3c3c0d6570f30fd8f93a650c693decd62f171cf33a2399de2c7111dd3460cd3b1a552bef8602ad8a0dd00b44055877889feb03c1ad5843e75ef37f3d030545bafe94d0c1579cab15f0b3380e2192bb1a3b74796c35447bc0f0fe1decc20eb3362148d02380fc7067914c87c8c8dfa7fe5a6b896809396eb560fc743f20d07f18c5310a17c98c0fe937b67ea53d47c61925c2c47cbeb7bcafed513c2cb0493b6b1343bcf9f5dbe930681df9ff7edb0799911917567182d398e0a89ecbaa5f4739498ac8c1804fc3135927346f35a0f070113843e053450717f6ae3348516d9c0192b25cc9278599f2a98d206cef74909c29ec7e06da162dc2098ab403c73d86538b14dbb4e0fa0d0d934c7f96b8eae8ccdf36d04c5158a8ba7a12406af43a30e8f387ca6ee324fb57571e42b24990b413e0d5a6445bba54e2694e1de498adecbfaba65f71ae92910a71e1d70a49e68e90793e9f3e6b997c132ce8f66b3577767bf5bc28e38cfb144d9809cbcea42de74b1694d9ac4265eab9ed4d4624977753c68d8a211a4b1c37c742b3cfff09aa91c1ae204e03f5e097e3c583a52a08ef48437f2c2e9a4ee68f7def78c9ba9bd6b11ab15d000881d77d423ffde31f32f1a6da186b254d7fb0cc8d162a3b63e13419b00e995279b992c6945fe5d48ad27d4195591f16614717e4567263504156fb97f2d66d201e3756cb2d9bbe24ea8b252492d2c473222bd2fde33cfb1dadecf354b16364daba1f4198853ec9d89c628dbaeb4376be5e6ae1db13c6668cd92bc82e4b55362876484d7a41693afa80398dc9495c8b20a42fb4af4c8a91a7ec46099769d2ca39a048fb75c4db3e6bbea85843cd25c057a6d819f99e5cd6a9df011b14eb8ec8cd392246ae47f6d2bae34c79acbe8414483f46b1bd1fca59a3c2a64b24033a1a92b812ab1c8dfa7b57b66ca1f7e9cbd4fdcca4a2e796f8fc6a18c477b7009eadaa4603ce8bd95a11ae6a9fc9d6c5965a5caf2aa0467fc37f1e2a888ba20e085fb09d05b8315e40094a614c2398658ed5b33bf7bdd73f80e4750154132b18e93342831086060eb509edea59eead6b0ebcf83d3bceea30bc4bbb8e128e629772751170d69843ad161b9c2c4f463208519270fbae2228f568d58bb7e9bcce549f3c24ad820118d2acb58fe98ee674e77637e3668e43835e1dc80891475d7664019e41e438976e5edf61366f243656eb2820d65005650db9d30759356ae4c9f61f2b52eb46afc41c0888be86ad15b65ca74d65cdee373dcca55130bc42280143b86a4e824ca03bb800daefa18f43822716fa5c39f3f7c28928c4bb63f9051c2782db85c445679eb2604f93c7081165e94dee8f6c0cc0ed4bcb534ce95c1b3f58cdf2f74059468d8f2a87d79a3a47b24f409d2b622e98d4cdd2ecdce9b69c6606150df6313582a425262a17e160697b1bbf7ad1ac23a4e7aab73f4106b83e45063abb5029d6ed10cbb798997afdf71e9e2eaab629a27bb67910ecc5bcc2571aa25c3ec61bdbc04c0ca3781a9ad536012d27587951ca0542ad2189dc749647292a02fcb173d1507aae3dc727c7ab989119afe759cd716c32ac3505c466894ce9e47ff99ad6c42e0a8f351a3dd4a0dd6670e2af36d69746fdb8dc1cae973dec5cce4bd0acf68612178dab1f8c377aabefd75843255b00aa38300c550dbfb8552a281e3fc39cd805086b56dfe87d85df4ded8d7959930f5c1ab6117d93891a227701343c3f8232b000c97b6abe7e689efece62188da469bd7b41c5fc6e7b419f70736ee3e89f0344beaaf8b2f4578c6f38b75718aad70cdb417ff147c99327c96a89aa8ad7991d3b5515130c7abc8cab637d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
