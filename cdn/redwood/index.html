<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b0a5795012dc7f32cc5a879d19a42565c830ec57efcd6d640d0a5e3629610cd7515d8d312ba0b351ee305f08697687d9a218341106b8db719809e773e7fe54ee7ae3fbdb5bef6e83046d913e30f7c818c8168f30142aa24b7330a6ba29b75a8fef237949c17197627b09942dfb69c17a46d043b91dc8ec3438d0f45056279be84e258402d2b84ef4066ebc671d1faa172cc68b2353a292cb18f6bc934972915157b6563ff5ac59f828b07c1754eb5a5da2e7fd4e40827f0c72f01de2375f65646333c47399f4416901d91ac8ebb065db2c59bac72cdf5396e25b09e9b66c26f8fb65717cf1af10454a16c55448573c551d3f99450b770ced873d900eead41ff831702e08fff828fcc52a79675503f925a933eef4f316d3de3adfd78e642e781c27244a53154501f2c613e884cd47fe365cea80c54e3d3a141cf8ed342724cbefcf28066178e562a8ddd2b80cd6632c18d935a7be7bb27fa302c8da29dab465d6c61db6429a87fea5c70a07dabd91c1d4eb33f1a380e835086588d042fce689d2c1f5ef93c52c5872def77fd026079ea08705c8fb3136cf49a8b262ab3c41e3ae56be37905dfa98e162899e2eb905a7a5aca43f5f14b9f10126f801aa8335d66b17046d99f60644a12f692d4ef1941eba81536cf2844fc6d549dd932da1ecbccc2c1bd9900603efce2df12df174063178defc6c5b400a9b3e8b70b59e30c44f8eac39b5832420f4774637b57b006e695231bd8a04784f0a9519aee008bd75998af0a320b9d1dfe994618f9951eec2d8d42c5ded37985997fda543537dd1c6a63a3436e115b20326be54c8c11bf2bf324f6bf9a5c693021f4d5dae78b6e849476a178105a54b2ecfdc92e3586f29c0ce1c7283d26c7bf2bdf8ec2b3e9153bf4afd38e27547b964cf12b379024e80c2a9b5e4f53a8e2c421bdeeb0a4cd5cfea23738e937809568e2fb9006c3ba094618aef9b3a1eb0c300feb52cd0c6693bdd02b6e356cdbc0d0edbb7ad636db96e6cfc03b1e5da06dae135cd861ec08a5d84043a8de4e4e1002cfd79322cb470a5e15df24c98c556a90a69ba639f5ce725cf1e468628edf81a3eb7d88be8b37f1a31c8a306c4b84b85b2f15456bf73835ad7d4a2a21854a3f791f611eb0125fde427a689023666789f5955dc5d10f06fd9a1f21dc20415f8dae1bd3de440d350f6ab369af4e7ed9370e78d015fe7b015c510c966d6d3f6d69f62c7a6a1af45a82db47d6dce6c3fbe2b0da327db543a6485f8b35dc77e5576a9c4103428c1156107a68eacda4787587942db5e52b415f33272d539afed2c172b825d4198714e65ee5f966998e296b680add7b2be160b7ae7fb3caa46a40c8c801ebecadfabb6362ad56b4318601e99f75bed3b2cfbd0708d04e098244d34a82390942761f2d8f8756e08e7d5bb23fca87deced7454169b8e3e93086d5d5aec525f4d142eed617e3e729e00a2fe246e054b76b4905f8e3afbff615e0f9860fb95fc65a5e7c63218c9103bdd4a9a6b7c10b4ae5ed15a4ac0d27132cd73856eac7fd455039c6726dbae73141c9a0962deb4d80a1507f3fde44577bcc9855da44ce6c0c518bd40f6c8f05c3a2bed0488f85f29ad684922e92199d0fdcb5b7f7461b94bab10e8d45c20b1f8069b0ccd2b1cb473584d49c4c1420050fdb5e2b4b201882eb9deea8c00a006b9ef97948bf8d7920880ed4f30fc51ad7b9312444e5cae4566ba6626d1da9a232b2d34123cff28c1c11fa2ec5b44e3368a0f5724f12ff839bff6f0ee45abc18c635a5edaf60247e6d504bd546ca4c492cb276438c1707a219dad8e6e930d270e463c79f568ef5141f5871f78423962f19b25b2a6c580a99aea67c95db0d1aff51164460d3005d4124477747d82695f705a348bce8fae62fd274fed72291bcb93a37d11c0780a9fd974a2249902170d8f0bc39fe85aa5749995f53fd56a8054378e37e6238c0baaeea8e0df460cf2506e9d4fd8ccb7f2aee7a6eea1343c0eb715fd4f7cd45a106595a3cd9c9fcdbc6fe72e80964f1133c18301efee50c77df5202772d7dc1bf3c4f0885f131046547160e00d9b23c885eb32265fca20e136a88809e019ae7cca787cc98ed85038281153f7139874f62a6832f70a0ed9e9530655c43e68fda3fa9545214c7adc7d5240ca5247e0de4f57a2e287468c78b259d149ab630970d113d848fc37b0abee27ca42b01a647a403872d214aac6006d18ebb751a2b658f6dc0cf74d3dde89cedd2453ad87eb5ccc16f0a5063e4d3f5a25cbac7be1f17a28d00d24ce31d83ab004ee35db0ada4b16b72dc6abf4162d26878cc9e11b20dbae5dda2a58ab87355069ba39dd9a32a896e982ee5225acc8f35a506587dead144571d200a9134dd23f460f4dbbee67839bd9eb77755c3f824937d0a9481320cde8a602a673d858db8ab408618a1627fa0066707ba17d55b2df1d22f377501bc4423461780cbbb6430f64bddd54270b28f050feda0c8c59c281d9b40682ece833e83b652014504c8aff4a957a7ef357cd19ec2a37f496ce621840dd5f976d33d8e73f85f576e9efd90d65a8d0bc31a3ea48741af567668ee0ba85c6161e4ad3ee7234cba19f97cdf90d28a2d62bc258ad58c684b59b079406c69b1fec15d5269a706e37743adf3986b61eae9e461e1b705cb67832b45f01e262d8cd6464a2eb772888ce1c065233ef02741a8b611746c943846f9d94c35400551806f582460817a23f4c5e90faf114291fda03f0b33dba80b8e678bf44d39f61646cd085dbbf7af78a8e0fccce4956968a8ae0e5a469158afcfbd6657e05d66e808359677f917daec4c9f96988617d6634e129b30346b04c4588ec64a97040bc5d9b15810491c61bc20a903065a4331d846d61a12ed14b4e242b00338eb300b45f9dd0075199a218fc479264615566f44e85dcf1865fef9d8bbbb758ebaca526385113d24076b1ee172ba6d6583ab90f0f3e146b47039ea70acb291eafd9ce42068e5577305c8e42433540f43529fd7a89104119e086069a922662babda7b7a9441cdf288eafeb9834d2debd3d557bbf302ca7f862bed0aa76dde4337189415617546394d1b95e75121a323bf7cc3827191b2706b77ec3ef7826cec97a0630474d15b4f238a5a8cad4257b12398db48592174858095fd27d093be5be95e0e4376beb21dd9b105699e1a772b13c8cd2fe463c69781c96a087817bd8f17796c1ee31fae63769e5574821f97a8ce8f0f1a81dd418d62ef59d1118283c680c10cee0dd094a4db83cf32ccad32ac5765f657782ef46fccd04bed99ecb57beba5087f3e7cc7721eb97992faf3bcced3e8b0ca4c2a81c7b041c1fac8a025e22a94a8b77ba46e387e23e0fcedbb63ec8c8849b10ede9a59c030d1ca43f94606f00756cfde02ed6ce8f89e1fa0fa24eb7808a384b9a2c77dd24c704552ccb9e86392b28aa19d94a000e5611176b05ceb481d357a9e306c8d39446af405cd4b430eabeb45589144b19d0d56ed8797de433457c57f67d76b63dec8cd01ba643a559ea21fa1639d04402613b5df437d7b48e1c5a2a51dd92af01f76afd24cf9285e4b08e542d2b20a3ebeac5feac61a3a54654286e369bb6953de2beefb0e39d10c6d83ab1282c638ae26c6912cf3c56fe9275e111b5774d0085a2652c113484cc38a52a6618ab14bae28a871361034664d762485e06551752a42d1b55fc01fe2f25ffa49756a15ea28add36f9241d0d6d533a952d67279f936a56d9628c99886cebd6cc6f14bf143574f201e47c6e75522b0b58cbc13148851c100735d87d195bab37d4f3e08143c62c9fcf7b0ec131eb749870a9131d5b4b6677baa22e0f321c426c86b672ed95e1a7a736acc3c96840b94ec9717f40e23ea57c03a2532c14cad0486a02a694cc5c1d2bedcaf2df0a52b09a00318a0c8cf13c38d7500ce18ce188a50194c530ced60302caf41981a174b21b3e111a924d6e07ca52d616ad55bb95b748c4bedee0477538a739dcabd523b168af9f8faf4247540a9a928034895ab645cebeca5f798f20be6850a3ebdc7582abc33b341ecac848a8e5de2e9e4c51220f4a3143ca605c1f99f27fac81b1c19121f39503057f9b24a08f830dd91c5bcd8afd462524e30795cdca0fa1eded60e8c769488a93e327cb445706eb094e14c33c51e6e0394a0686a135b601f112a65dbac34716947c30c5627ee85e16e1176b932a3cdb0a96fc96e1a4a326fd4cca1912fdc0c31657b877ccbea134b386bd07ec6778fa27dd59a32c4020fec433f4857586e382a0857bde927192efa0f9ada2b873be10caa34a0490bd9bb5a92095b5fe505b6adb307625e284471f3dba811fbaaaa927383ba7b12819df0ba8d19454eca010b9c4905bafe67e65cb2108262de3cae34120dd7ff15bb040d8548ccc4e7cbfe86335ea2d52dcf1cd23591b3fb5c282fd837489314dc44c1decc73ce600e4e79581742fa06e671a0fe87235ac55850a787593078b804ed7c41f2bf84b38fd5ddde3fb1dbb04e54b8941308d5546930ea6976b400e1e74b70eff70f5f0b85691878a70513787f0cdee129c83e9006e7dea098302e5b0e478de95da7a3b36475b58619fc1580fe5f2573b2c4fb21f31280f233de946d7a871cecfd6ff76b991c14ad1da95b10a796fa8c65b32d9cad768d222716f355ca57f61a1eb42b2270cd3649a0696e40b6e48656c73f2af458e396a1830a5fa575012fd3cde444844a871937b70f3eca76084ba166977c8efb7c2819f9e1053cae5d008a9ef81bc8ce1816e65155ce677973ca61de9c2cfb1fde3a4edae5dcd0b64a6a7cbcb6fe283d56b8318fd5aa99b4123d7ff457d608f891613d2c8411ebb642154566154d45f025b57b515fd2dbabdc7eac8ca7903a7d30a9df0418b79fb614079bd94710f07894c80a04ea34706f439c81986aaf8e22424170e5321cd005806a067bccc3b30f20875b96bd4bd93ade798d54ba3e87aa82d468da02fb73b23d4c099d8a560035e97a1191b612c56b745fe035027da3e22de379ffff8970f3c00a12bdfad51b74df7c215dbc77125826b4ca285aac24257e1e1d5e4c2656f9c0e7ea16a83236535fad8478477508c68a0100702f4997dc067d2ed0b7006eb4cbfbe80ab966f35b477bc5b15832f376804ff9cc59a9c9e6457f0ec69dd6fe3b84aed7b08f86d7c0365c99e20084ef4151ef6bbdbb6178abf29a908c96066681c692978e255a8be96182eb85567a042d89013ddc746175f6dbf566525119f1d9b3905e5c868bfaf6eb869457ca9507e5f394f9860535a5cb851760bc0dfe55aad6b2c4966cdd719b09b67eefd9b082996bcd65baaab924e10e81b3c533aafe6d4f00e8ad374057b4abc3f59fdb5f9bb057fb9b6d857a707c5481c9cf303c71e86a4341773b21cd6774b331d854b35574f221b7fcb08c1bdcf7aaf79ed3a8a7351434dd26f057c325587af8e91eec923b02a1e6a9716b6a26cf2fb2e304718c32df800db23caa391fe1c98a405d3aa5069f152f1abe6e6a2070f79b3dee81d6a71095db2cc731ce1d6eeb0026ccd0bd8b7dac6961d3c9b359bb8b65277fb36b458355529ec1aa59f9d329930d3e9eae2e9d6ef02ca1b55033767e308929906e212904ed507f423be4880ca7f7a8c87d9a1fcc23993299461246d481d80cae0691c57ac1283d29a099f9bd085e238eac81f8717607b975ca5fee36d5910764157d8260d28c33e69721323641dd4c1c54ca8e4589c3382ffb11b98770d60190e88c240f67f30e8627c208ec5f3e8c22ba4d2686cbe27f65855955cd8802644156b56c68fcb247cbdac5a87c2a568d4d8c6f1d068b70086c554c895d6d05eaba74d97300595c644ff5370c7b2f158e73ed6d8475ef03cf2507bbc10e0bfd88fb30ad783654e97ab13508195a974b2cdaa55974f6f771ab3c1f5ad0adb18df20f508c93f88bc0fcb2cb6669ab69c959a6089fb84fb37ef46b842d1e9f93a635d5884c7c9af33b114829fa136b74f806014fa27bc0523af14146366d60070ab7f90b6cd8b9253804f7560ee36d42033a866e73aabd42bbf0affe6f346ca3191fdc24adba7d8722ce40c918e6636b7b73f86b3e860165e4352a8c05bcd469b44236d0aa6aed7c21918b4e4edc275b6bb8fa18a8b18680c240425390e457a40754c168629d1164eaf1100e2ecd2af6a2df429617b9f20d032b88bbed01395293d3a7bfb10fed071efe6da02db86bd3343cdaecf7ad9417111a5a0a0551384b3cacc7f7a4f99f5f5c29d546b9f428cd872e938177687e41ad7224848071c2b11317fb9129eaadbfb86d6665a5404220440b3649eec4516edd7b7c4fdb898ab2423f39b33ea127ca8e5cdf81a538ed39f132b2a2cf32cc627beaed16dfa3083b6500b7d5b60e935ef6032db87dd03596053948e642de21bc5995a7f437b5ad772be2d09c8bea85928ee3825a14f963d22df0d14f9e4fb7b46ee83952ed5d4d8c9cbef215494158d0df76eb122ea84603d6af1135ea4fd0b8bdf3ca5d94bf999c70f57313219a7267569ca3dbb686ff531656329c0813094e9c5daa858c08254c3f5fad7c56a7166baefcf358a9aeda6bd70e4240173fd7e778b112b762cd5a2c53a0672ae70a904fa7614277ea23f990573999026da6fcb195f2ebffea11d5f7f75a5051dd635507851c343a208ace5def9ad4f45163e9dd9bd13341c7548315fc347cf5c6306516090cce3e12538972dee2861eb7707601d8dbfebf527c69483c66177dfe1b252696eb56b6f6ab86bf31845545ba226eb722f9850e9e344f07e6352338d4a0e46f281ee6f1766bb70379cec910f022882c28ae3227fe8faef43dc9fbcaeaae7bd9a64d0c487097d95f3a69011a4e55b6610a3249fbab863bc4245ea96214b1854c8abac19d97801c9ed223ef45e940a343a7919090cc73d126848b58be09b677a8322de5ff13294c4100c824987264d65cdc79bd747c68a9a88c62f67ee94d521f93304ace214768357e731140abd8ece0fceb53d09595ec53b6d77a1f2af92fa560e2c62ddbc58a3ceb5d2891c060591611ac9ae6060f4c86abae58f3c7d6d40cbc724f69285065cd191e3222680442c0027ea03e4cd87816a2d8352a2a32acf54213a7f070dbc0a830be94464c56afd4bec695a60852edf6723cbe370dcf8e5a65c9700eacff42c9c6aeae89a451c3776bd6f9b973b7bd1fd03845b5f8e97c47090eb7c23e3e8a64220b085e9ac4dc432e8a6a9b4308f2b5c100f21928ff02ecbc58073f2ea1746265b3e4bc8a63ff87949ba404cb5c77cef8a5f2513d786dc73aa14f489318aa47b55a0b220ff348ce587a985feb64287ab1624f671fda9ab27d1d35693e03fa82a5565851187b246e2a934e745dac3c219d88efea5f68caadeb98e155ac583d3ab36f7c2598c2745d8acbbce882607537a39d3bf0d97ae6bf0a59ef830266d07d1f097a1c97256e162d5381da6a9310fbb36cf99392bb0202183911db1cfa40bfe17ba36bf269f4338b995c949e64d26e37f69f0bb5d9dc58e3cb59e2eed0add973f35896c422f52e2f1589879838e029ffd32ae456ef95929724a0a393b41831b6aae829012c6726862ae0a9ee36e5818e277b7c2cab70c0c65a578ebb9132c9c449b49660a491d2e1d34f12a3855c73818e778e737cd9850985d06baba23edad731d8c0dbb3806b26598c2e591dc8cb4ce71e362061d789e3ede4a79ccf504ffd59e9a90a6b4c2e20870c695a4a8f164cf987d1cd6829fdf53757e30ce7cfaf4d48983ab8762740327be883ccfe59d553241d00cbc8a8fa1cde5b063d0576418fbff7f7c8fd5e5b6329a179a966e0d32f735ae887f553c02de9e3ef8ab7f2b46f5cbe0f5964b648111adae803bd11dcfaed2f6bf73fd2e62e8b26c017647f6412f6504a425268569aa83524d3994c628974ee7aba25c8b1443f517561cafc6e3c596cdfb24dd83908ef7909a3271364b30133821431d62d658c722274cbcbcc6f2135b1ea5f3869fbc0500bcd216633c197263c32a5cf0d7e3a88f478484c845857a867e196043ba2838a1e8be1a1600b57491409579e32d19868ed43ede1c68768198a189994dd24c1196caf05832840efb25046a4c8d49187b9f0bf2fdf5548fe9be8baf7ccd59f4f0d20750fd056579a9f8c463bde8f973cd5a6e4816780952a87aa70e5b16400a58e2ce80b6d82c665e853a57c2b1ffd2ec72416791d33df9fbbc5c3436d5258b7c4819393a2b03fc0b2518d8bc0d8793b406739b57f52817f8ee1d564b98282492a2aa9296dd1956a4ea6a7ee5e8723c7759b848374c84b8a6782e860dbc8ebbe3d2b83dbd1548b6905d5f5e24ec45657674fe994311100a905533352c96f653f035d6b6e42f8763b02a78e90a699d92c37c7f098d92ac979467fe9f34f8dbbfcd3b6b9037ee2c87b5c80087500281081f8552eb4007409dab1868f47b0ee4a2c988068494a911ec126b594e6c690e53e124fdd8c1b7784ee6ac471a72d0ca84853118cbe9b2fdd77c26e6b81793213beb132e73487c241516037e3556fed0df642defce3bf6355e186a4905b4beb099da8340808933e102956dad0633375873e50d2fe5677f6b774de69b272797ec79879d3719d72d9cbc5ac2031c24ced531391fad5411beab390d40d1eff0979a4862c780cb5e64bd79f7bce72939e424fe2b3996c5be573f14874d3a324e86feddb2f8ce79cd16b6ca5663653a95c1c0c053851ca26a2a74eec1e8878a7423bd88f0ca892963c7ed806522850bf6de9993cedd2b1d5a47df9b05f29e1ba3ec01d78691bef8be060423af9fb06e1ed1341eec217d149594ee41a76770d49ca13b9e9ee115d678a9d95b8ba801e402e26947b98e89cb35625c0e8388b39c6d27eaf93f44275c8d3dca6e30ebf4a1995bdc1f17d73694609bee7d82186c4bf5f020da3ed6290267f83907d7274c80b6b79f4f9a8070f85ba655cad4504782abc9c3049999366fcd11f2ff4c8e234afcc0fcce8e8c5100de4f34deea3bea9aaf77e7400981d5f9cd7ccb5c916d149805a90da8a27d9fe00d3ef651cd58acc8c2b990eb1f580d04081e1381442e4f8ea4adc0f6683302f866995a8eaa7b8ca1cba98fc5e4e8061b11b7cfad4676c04bc606f776198730ff93379a1b45604dcdd52ff35c7ac851d447d00546759cd34524c8019941e5fcef746f6991097c3d484146ae558c63c3882a5ff79a187ee82d5b7ea2f1be2c7a843708949f54b6d2b7d59d78a89a2ffdae15265b64e81836919158a923e0245ac89ae6f2b75f2cf8fdb80b41fb1bf3d557279402e6ef4ddf3fb27e775872750574efd2b6a7f7832b9bb2659fdb65d2e290d684cb2cd7e148501bbb8b7760ed70912e19b772185b1fffbaf04853e384506f9da34d855a9d2cbf35a4845bd7b11d14c74cfc6e744bd2ec805672db31881035036acea02043ffbc116de2fa51d1533cd63682aa3221a80b29a32bd7e2c99e7eb6938d231e50c553194148d0f23b7cac36e9cb540676ec6c3b05b53c5f135c3baae2b3204762a80ceeeda7762b67c86de1511f455e2b525c6444e65e242ee15253e23f405bf890a6ced1af0cd241cf8da5914587adaedff769f5daf4e6952565d89580d216991e3c6720ae416997fecf771a6e3a54563f1bd72d988068789edbdcf1e86135759cdaa593f395923eaebac428ad09b13de9f78fa7648591ff78703b14c17cebb604d92b4ca0bffbec20b7954cd96f4409f377e398f3a4bdac14ecf7eac27bc0fecea84420ab8a4ec5c8d3b7070bf8ca4d226149c013f7bd743602faebd6e9c95150acfca79b3ba7950645aecfee8fed5c2a45fa6ca5f7ed9cb03161681f762c6231719b99d84764d3aafd27a2a1c014d2b0babc7a07728162b0b0787ed47066f61063565481b0bfca2a7294e3f9c9243f48d880a401980f7ac829893f2857d53b54b30746dee303b047720a8874a826c7150c3a248b3ea3ca063b8e3e7cb76526f097e5415da2d4c9eea38854332a4febd2e0f63c71e164189b47a1a0f43337cb059cef2d7f93706124dd5df9752b84f2e0e41c964261e4d8411ab090afa72119e1962582de523e99c7db86c6d2c44022b10b05444699d0fc83b16b5f801f5c6e36798bd45567ff4c22e0f655e574353d016860472716796d3a6b1480182fdaa31d6f58352eae6a7b214b3a6c1adda1f13b322d61acd16cd8c79f40aeec80124a25966cf820779f5a028ecd100fcc406994c2133654387742269d88eec5cde024b480b45cd1ab32e94f4fd115254945e493828e5f5eb48ed90629406271f7890a6e6dcc3d062efb4e1066de9476cb5ddd58c909c35d20286439b4b9281583136aa1fe0c79447a96bc9322bc54c6ed03957a39d034e6b5b30ca5f100031a6a8ce9ee3d5f70f58c1476f791e5c71df6f12c7f74bf74d2adceed978cc912691e44dc18d683fd7be3ed5d91c53dba339b12bc206e423701b503131d75d630d09849daca2959cd25bfc82876d24b3b5055ac4e8095e29e453c6780dce662ae7f225d33c203a5175e4b1f02d028473e2cde0d95d9e47cf5617cd2e6e77809139fd246d141c4f4aa8fa2c4d8cb60832721bccec02cf6b9c9b50870be6d8ad30f81fd38534a04939604cacf0afcfe842dbab9b603d5e33a308e6a38cead49f38dbc175a1573b2796e38ae8e1f3f4b367377d1c868367ed1f2bd6ab22bdf646d1b174905ecfe3474c0427fa649bce29bb5a034b930a2add33a7c0281c2f4144f1d9450fe2c39d7488c3179c1672f14d8e75d337c3bac3f7c698be9568656258daff4fc8cf3f504af01af2285fdeb6da9eb1a057b1faa0df4a1df09250413b93fef7166f6e131dce59c85f5b390ad1f848a44a249681ee6aed4452265d6d3f0471a4cbe30f119f0107e00dde1ca79bdf61446106aee903403f7b32213800bac2611ee92b81d392d01a6c9bd5cd3845e3401484c73c0877601948d1d8659a101ca855fdbfbf503d56b909c5f224de325ca0a62be0143cb7890ecb91d86b5e77fcf736115cde303330763313fe3e878776745963d3a9c3aebaba8cd4819a3779e03b8225d1726a5904387ead73f83603ab369212c65482ccd51d4897560dd96133c44c3d944557eed410f5b1230354242b090d402ee9f7dcedb18ffa0c1f86d7cb310eb41079f7a10655e8f90d38a67cd8bd11e111c43ee8279df602f4a50b2dcfa97ba84c3e20d8673d48266574815c6fc3d8a0bfeea22437b619a68313ed14b23b129f39954b736d1a74a11a4413b1bfbae33beba291e92fc8da9cf729f0837c04f3d7b8d5e7598df07576944ff560a59d04b0e16b3a40a4638f69249f8c6e9bdd017ca017f2dd79a488411673cf01114c99e5e6ad9a174d8a81220dbcab4fe4370f0f439ff314406902fc84ab28ec4f5f16a2bafefddc993816affb8ed3d62c1ee4c4476f1d2f2710af8551eaab0e25fca47c9f5ba8911a3dd5522f91a669a02c9d2248064eac7d1be43f2d2b34d569d68cd924e0e9e5cc48574746fa6c281a7068eb2a0b9b7284bbc398e17c314be7fba9889f1c0939b503c3923c4c2d860e541f9f27dd53e6ab6f2d72b5eaba6cb54fbc3a7dcde8bac706dd8b4deab7205cb2a798806857d9b2cef4425028086e8748191d0e42034fa6149f2296852c360e4e8e3a260a6c7c5d2a2e46c1b5379eff8bc66bf47e746a751ad30a915f31879728d079a863d122407b8dd04ff1e5fb6e20e13b1c6d13212f61164f958c568f5c35414d59ea27d60db7c169862c5dff8b239a41999079ee564f8963dab5f61e22f63c4b5f6ec04594ef2950da91240a3ec7002a2edc6eab6eeacb406e883305b0814b9cb3f8d066256af2107c552c9b113546ace0fece83a3c8b8a28b6648aee6879e92d2a86c78f3e8defe4083a82536a89a33e20b7ee8d20f3eef32c2f98f57d79e33b5147cc8dcd6230cea8caab1e784f38e6f5f81e4b8224dceabdd5f1fa1cf2f0e812001c71af02b189e3245a09d215bb7fc1cd9ae5b81e9d7c7551de7ab29acc910f5057a09841f987394a7ac9ef24f3c0e0365e762a147b25ace88efedbb5402b28458b5d05b62ec89463603e8f360fb3f313d60d9addd42a265904fdaf2d5af1199a6b035b140833c501087e439ec77ef7d54fc80dcaf7d7604f41c2f77bf0f0a89530d33ba4fafd75c3e86461fbb42f6e72180e9781b3a175e305ff98de546626bc08442b0fd7e33ac1534e0c78a6f1062d84c857af947430e4542fdbac792aa48acaefad00ad290e9d5a145f8d3c6a316809a38994bc1b31c5ed46dc81f9d9c6c9cea20c7655ffce95a1a02bc0f84617843cb5b29c61b26c0fc819ae5d7f3785793f6888f74f924485aeafb429584fb60e80e9c82f51050e2589fa6ab626d07923bc2cda03784327931e2d43a94c4391ef953ed1f9c6a399b966a771416ab9db8f982796b0852c070f48841a7be5e6d226106ffe7616da77fbe78fe8c334cfb9e29a4bbdde812aca8b4adfc25f35a9f672d65c84c773a97c7f85b6d500df3fdcd8d4308aa93d4e49bdda7fb870a25f4cbd39c2625d9c4552e52186b89ee82f463f7b0f65f972adf141e2d7a3d3aad0ba7acf2ee6cfe61559291716382275a41ac9360285ddc804c02ba5800927c3e0ffd1240dd35f84861d1125b31defa6aede451c8fa3462daf2a7717cba59ac466ee2da5516f31371e09c56ada8d6b15715836929b32ac0ff0afb7ecd836a57834f77cec994ef5842986793c86c189d408a65981fa3b6568450f4f80d5de93b1122910f7ecc0130b4e5763634a0222cc148956dd18e6268e85dc5cc2eb3ec3aa04bf59fe8c0f54e709ed7a7edeb192e11c546fa480b6b995fd51d6707f09a211b724e9c1d59cf62d01e105a9fb6cc6abf2a436455bbe0bc60bfabca6d57ee5f915c5ae1d41bfdbb3d351ae587d39537619828e7a19d71c266c11c9e1feaaaa26c49a09aa1287b7547af3d14776723616057b9c944d241e8cf0c8b9e26a4f6c7b057a9ddc37ee8895c2bf3c66e60541dfc54c9ee2d9a77171c813f532846e6607f9c244b873f0d34e1ae3dabe85f0f7705ed9df920d8696efb2b8e46a98f57b85d3e062cdb7b2fb5b8e0d55742dc7896c62c038bc5258c55d2dcd3dbe13f4c5b4543334f5a4d9463e4bb1c2646336e4e2b1ae9f103e9e7c40c75d5e36f72ebc453aa0fa8c91bf6360edcd03a01d0250115d7d6b7a0cd275f863c63d13cf318850d03041b411df24e946ebf09536ea30f85cf92e96826226a71a1d523940824a3dab20808ce461aa36b8c02f419bb36b68f1767d74a86aa2bcaed9edbf6fe1c2468e5d26b963e17e84fda16979c87a13918b3d033a627e9c195d775ce7c840492bb6051765514f97c7ebfc6f00d9f60426dae7a3524efeb442575ce06c197cd1f107b905a179333c6743e592a7cd64566ca081cb7ba7bf6bb372c69b96288e0a1b6b65d34b25d0be7c2d4eb13388e3d005d6e9ce8f35ce8a7c4a14fc20048b07d91a30924e21cdc9126e1424571256141b4779af650a0c74c614bc4b88783dc3e3cdbf083b501b6a7b7604650e6cafbddb97fd6b9e5e846026de7bc4f606b622f291d96912197ffef376a148f456bc3cd8882bf5224f03ed7d548e11cd1232d195c3410ce059b33ccea982f6b3b7fc6394bd4cf320cbb002bdbb0d4835ceee351808e586094cae3a0ecdd4b2e6d18004ad9a754e2ca6405985e786819b1d076221015e30d5a2c364aaf28b8bb7964ca619269a72f64d21aff4ee5f6400d6109a74b7b844fdb6a2e8d1142c57b23aa855ed86f1325f83104584a7f18fd751237f9981add1e5c09d043a93b3fd61b213c9dedc6859c3e03fc2b5526a41ed5c5bd1cd8f3da2fb5630bca7307da7d08863ac26d316b80dd6ca61dc223df19549ef4fdd988ec15c056bdf226a8cffbbe264acf2284c0b0fcef76f022fff2621b3db00e7f42af56c6cfdddcf9c5d81411e885ff96722a144afce5007e3919d9b89507932a4d3c29f9c991fc05f1d7665432d1acb1b309f860ce27c16e301d143f532b3520ab082c3a4749e7abdea303b2e32334e95432f7dbb9d3b0790354fd96d65c87692602d587b1e64cb3659482fcc8a5383fe00605ae73dab5dda7036d1f5d9251eaf4e9484d6ee850c2d91ce03fc71de4bf67bf4235d798cca894b3fd259981b4ea8d6f77e5defffae747a5d7c75ceba0b021ba3c00ec202fbbb01419e9dd99e5e1e86532a221c3f11d50d7d9639cf6a04d8707adf0dee8b987f29c08d31845d1947c8823af8d05c398353dc39cb4784a0280fd59d63a5c76fa45b31dff6d85d53bb21f52464ec79d80924923143730ca9e0d3ee17bbfc3c2113084f7d17edad98f4ac1b66f04385688b03f414bed10c8bb5a687db9a12c7f2905f921643fddf99e268bf44856a690acb2de3e8ad7d2b7affb7d7be52be49c567b43ac2ab6976e1ce3f941876064e4119f295dda1d467d65a430a01855d242890e8b694f233cb0b9dc7bb1b5a3056e7040c16e3f97b7e161df95d3ca78b40a675894901bf3bd6ce88e966207d130d4fc833c36059215026bc0e042b8285947014cbe22fbb6521bf06e68bf4b08908aa531761f7a8d39883a18acdccced2ed1362118a9e95b8853b1e4e672b205b712ab8665e8f5b2e98fb06f3b4b5f7c817b11c728ff0a8e4dcea5b3db913f3625ae825de7a57491b036bad54861ab4db43c6c0cc755662db5e6f47c9d661c05ffbac2d7bc4d77c383819397b481372250f6f60e6389dc477d1a19dff9ac4994ae8c6dcab40b4f9d02b86d2ff2d60e14c0bca03ea364d99ae4a8e2cd19a51034aecaa5590d4e452a5918d5548b7c11ff72eda8b6e44ef71923d1da2ec0faba530bf2a4af25ba3d429b9e93ff3b3c56de74915333c01c63cb87aada5a814194c816777c64971ed970e429ba071b5dab5c5dc67cee092b91a4fd61af1e5c987f44c525177ee43f5c06a8b02506f829e2f8e8f76c3d4d7783e2abc2934db068f8c0146dbce0f5f380d3abedae94db276d84e191ccfd4582c73655bc33f622c220cf9e186da3c900e8897ac42bc949ae1327c8138c88f04554462513996c5e0b32865f92a85b0fe22d4cf39f1402067f03c98ed8b82d5e65863b774a12b742dd93db61f1493c0e11cce1c195f8c0e0fce5e4ef4bcf5155953c8ee13f0881867a9d8e95af509c77258f9171b3280bdd60f59686b1e36d2149c5f95599d0207c4002c3c02f2e8ed71a6796d50201bf8cf041bb2773211a2253e90b5ed3ac3dba5b6a81b83ddc42726284a1ec741d0ca148124f1f353b95aab4d054a05207fefaf2e70357e1ff62656b982c90e65e861278d8739e2c857ead48d481f1bc97fd1ae3cf0ca1b33eafd0c3b4ec5fb878c6b5161fa6f66ce6317520fc3ecc5741c39ddc156ac15ca517c56ac85bb14ff6b9e3233b5b7dcda02fadb4390a7d9a58df8b6481c78263c221a97f79869da50deffc08567b96735023bed4adcf3ea8588eccd5245ecaff460e06908cabd3af5c5ecd2cc42a4e4ab0d82e9c32d868ccbec87649e8e71077b430d1dc3b5feabccf15094c2b2c7848bf9baa27bb87a27f408548c3f36c700ec8928dd196271e75f5da79683f541dc1151079446864aacd10100626c42d10df732488530cd962100bf720f33ece8d1af79ece8a940b51a97944d41577e805c97df9a0092905a3bf798a7834646183b9503b131d96fc190c870b50f0142ebbd0fc2abd12d9388f7c1d68b3e1b3fe8a8493626400409aadf152b86bbaf4e0767ddb4cd08d5bf723deef113f7632b7dd6707cd265c490694a3e199fd6029ee36f6b374807de4d99b757440e2252bf7e07391d5e91ca7e38c81ed3c5bad4812011ab8fb8661a8695079106ba8922169e9e270ee93ad9aa8e345f79a3b7ffc5c965ef9ffa1588fad12f8fee244d73711b2f02b690f45781b71e044ab2a64d7e02f107c6f8fcfb5bdc4fdffba001e916e635162c124e6087e885dbb56b88a16dc646c769d30ac649bf56ccde40fcb93a175a76fc4db3471b1719a5ae22549c9a5e49f2382bbe5a7861989447eaaaaaaafda00219ca3d344dcf759901e59a2c270411e64fdea587739a001a497f42a4ee10e63f72dcd4ee912ba3588b264374c41836bd09e2b4a19ef63731c343b95202180f0fac17848dd1dad1824417e81540d9d9f5e6d56360a363b778f9ad7f4c6b5a1cbd695001e9f05cbd62448f79e61dbc220002de9c35f3737a9a6f60ddfafacbd33951771d308bcb7d05b1f49bbf01a82d30094ae9994fbc41f280a5991bcd8ec8e21ab1eedb28aa78b724c79bfc91b1631a9c93dc6fd4d42068eb11afa6b3c6b09ac6794f2c2f866703e22670f82d96b2ecadfe672be35169502f5f9fbb40e8ea158ebff32e6e92503cf169de87914d1db8f767dc50045de2408f3d7b56c8f8d7b09e0c676d840cad6504beaf60cc8a27292e5d155b58f9860a9abe2388c899e1c8999b1a66ae934a8310da9ff85a8918feb26ab3075c8e06907cdd336e5120091b85bb02e8d07aede3e709822d687fce5df2c92da73bf2a35d797cce1bb6a34f97f84e1973a70618869213416c0cced9b8067e496fe7d07e7cf28c3a7f643dcb0f07520900fde93e1c87c1236d37de64185b77a44b2688d2623684cd0897f1e61c9e6b4b3a11065ddcba5fa3c115e2e8b7f9f64ac7b64aba58b8769770740e8e8d6456efd7b641a14edfb5d0c51f4fa4eb234e9b2a7c51209b9cfe7193b886651e8f8b3c32cbeb4375c4c2e54a59d7018fbd9bb974e80de84f579c858d3d8dfbf06befdf03ed19c988644b3f91952367308d96a21bd9482ca33d9ceb8a0ab576de6238dc0c58d8465bcb9a61374745c8c889d6158e569eb6a9f75d5adad550067df767fba924fb97fcc5e0aef010d8fc7c2b8bd01d4766a18b2c01e34f8eada5437e32db24222c949e195b204fcdd1fa6e24054b566dd287e240c732c7c71fbd7af2f1cae0fca2a62eea17e93bae13833c2807c5aa1e356a659e1a534dc826a3f07ad4c8db3de6e2a6a84555fae4a30784bc0b97fe83e2bd6b67309e22d655152c6d3b32618887adb1b2efef15827bd1edd026dff641ff395f87774b430f11075bd306381c9348bd4bc617bdd65a42ee60e62b61e4dd2a8913c413becedd2927b58d207158d060b604b06b94f885f87db9e424751483dd70f67119acc8b7984a3d79f7bc3f76d5c4969637fd7aebddb2286767bef5d96162fc5f93a078557409c1de25e81987429c4ada80cc3c3dfbd0a42456f0cfc5e460da0e752d83353fd8d646fec4ad3462129da57e65c5ce910ea2906eb11bb546fdb8fdd3689eec96b2231babdc7cd96207705f35df73673825651092b46edb4d7d1d85fc9f23df01de6f38102970dbd41550cc7762a15171248b07c1af27955078833a8df45625558a2680ddebde9e6819e81313762b0563a532908c63590cc1ad13a701a711d8a09ad1d8ec305ca8bacbd81473b823799acac2124f800966a7888e5f87255bca3ab45039e8f3c946b94c6cac55c0b56df2ee0803fc991311f57e464da58932452a0192a3a59458a7661022726640e9a563347df24c996a39faed891d84d9e001058ff2904ee976bc379e1fa1221cbfdfa02568290d31b089e28e2ea4b7fbb5557d94813c512edc1639790e6f1103d3f40aa813ca614452673d183313cdd5f501cee66b478497819a05398823c207b3c88f12fb159460c1abc0e757122bad45f6c28f82e36fd33a3f7d5f89ea198a5b872b41bc70510ba3d0c26b66a987cde77d8c6614280a2d6b0fcd308bc17595c43543c094bfa20e6e5ac533d09aea8248c9bbf7d51ff0cf45ce48cd8bcbbeda7dfdff26b534ceb62368401f8fe08eec81ad1f3c5fc957504618607c7e76f003228c15bc95ad716d4f32266e49851e971e19b4afa9c5481a6f7ef8cf8de838b2ecbdbf5367ed978e7a5c98217e2d6d535274968f1df243d02edf298d7135fe1c0c9e927b6048a71865d89012667a48bb626f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
