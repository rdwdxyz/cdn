<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9f9f458aa7ec593ccb9295dd7a57c5524a109ee2572589bdf5d18cc14dccd35ffc17e90ceb4fc681b75fbc3a54d7f9ee1f951b73b4346978364a0f875eb543cba03993ec6991eddc079f4e50959ba611cec847606ad52f077eaf53a1f751cb77c7b98ac0eff7d240c340b71d1264752a199181f02af5ae3cb8f9631428011b2f5d4a9a579212c26ae7f1994b9540d11fcb1fcdba586e489b0265777b1d784041b03641f36e146e4148cd43f4dc4d31b23c8aa900ec1c50dc7954ffa743794002fc8379bb2b1d995c706a322f0e8ffc832988be735e31f80af674805bc256b8796413d9598f3a228e06671fbbedc8315b8a77e60ddb86f1fc1a9bcf656e11dc0be3c3b6fa542464a0d5cc2193112c7167d67f5c8c156c9e3129224a0fcaf5c683dc905be27d361fbaffae0bd6b71fdc23865299d877e3e3432602d872b2af7e7fa46cd432a51457f9412b7a223197919e6bb98efdd4cf8c11f75d0fd85b803b02bd17cd96ffafd43a02a84335de833eb65faeacfd160df04ce8817d1d6e748245f886061ad9f7d7f391fa31ae8210d9554df86b848b015770e17a16d77c86ff4bd1889a63f92e9f5b68866ae9965a8e2cb43744cbcbd1894020f5c5d151ef8e555907d761e27b883dd4744fa53f2d6f9834e904b096d247f3285a73bdc14b4d5545da07e0ad427b29096201bd45f8d3bb14ba986c513cd308e1de3de5c0363c35b4b9a11c0e2db97110014c2f1a75b2bbdbc032d1c54c104435e68271dec4c79ac2dae353f6c8fc4eeb2cd4639e33b23489991b044cd0f5a00dcd3273aace9d400b5a074305384f4d9c9ee56aaa8b093cdb8beb71e79371134014eff9c338089c8d4ae1c66970fc232c6cdda0f0531ba9ca36438e63cb9225b397a10c860bd0fe49b05adf56de37b286dacd5a72afe7b7b05d44a28b33061a1e2f242eb936fb58637fdeca9b077a00dd9a2ec0a0812192cfa105694a031fb960bd4a108ab3d77cf6eb6ceb1486bedcead05910f74f1d2ff4647e9d00872c8f0d278d6d13f7c096c837939b57dda5235f86b75ba958a824383ba40764a5f8b650efcb664cf27b94f5991782e756c8d698b081691b4046eb40b21faae087d348a7bad25eb60743839af2094f2142ac647410878841b14b2ff63d55e54c7d4260c7569b64d24411c9a85eaf628749b5122da7c7018fd89a596b89feff094964938cf653ef7c16d8c320f8b3c54579fc8183aa1cf8cdb5e437fdabf116e80ef165fd3b25ca0f67f2ec8c436db98092dfca19e9b7fb1204cabf9053584eea9ca1e3cb1f0286219ce86b340c785ce599200f474c5b094cb016fe1806df217e4f86aee18bef22f0a9bf118679dc3de39bfcfc8613e66e95536005f0c240957c72fb5150c98407920ea70997dd1f777a549033feb7086343ee48e80ed0523ba696493e7bf860ecfdafc45c0e41335f49cd65422d61649c278f158b3de78acdc90a840ea646db6d2a85ef462560bb0b3541abce4d73140781ab4aeead5b9b32a8780209a364e01d6387250d9519addebac92411b7bffe89592b6ff0df7dc170188268e4acbbb15fb0a8fd6a79c4bbc1260b9bee754b59a09280cc93a50fc49d60b17cb867a24d604ab89a1e18b260cd4b9f7699a2e35b4ca22af9f124eb6ae4aca8043702340ddf61c0b3cf2ed2f639175fd1116a78dac9104719bab903efcff6e2e5b9df79b43ebe66da9d5ac1d4385fb137b6d0a2b6b7a9aded48a9ade331bbda5e742f92a11ad51082880398ad55194415048da44db0db8512f4dcf54cc48375bfd5cc14c1489e673fb5b79010b19bcfbd67ea5c9a8b46c8164832508dfe0fd52799cadbaea5a770b2e157cd63f417b6e6eb5f519da78cf8e2146f83762f3a2f18a3914cd19df3c63f823be93362ff0a86b93ed1ad3708ff01d538e6da922f769d3f8db8809bf2f295e9f76763f55a10e556d030b1d217cec1e0077025fce08c76a55af223f62f8cc550d9afe1f0019875dbc745be9129efddbf946df184be12fc09cd1a20ea1492e100ebb66027bdbbe20f0a31f793419e403fdebde584913045f9049939887a4b4dd3d0cbd29a2f1509d6fcba6d6b59cb083b85f8bc971b006b7ca453f6f8698effa43069777230edb7940867f24908a4c987ad298401220e910869adb3f07d34be6b441354bf54e1b0e63fb0653194333c67eb0ce2ad4c6eb9318fcf5be1b85e229c6bb8b3f9d666fef28796faecba86066dcb81464c4ad18d8101d66c45265147e2f8b7308280a60befdc53d5aa873afed0535d04c22d31d69ccbd5579a8b1939852a42e9d0430f42fa9d4e3361e750b954ffd7161f0f8177a19defed53aa1f34956623e043760de17a214e3114aace89bc676bf2d20b6d1f84ac3cc1bcd19d358b3d799fa592286f23f57ae6d31c375bac8353735ab2aa5e954babff840b235df6c20f6e3776be0b6e5d51c2e319612125cd2548a533e70b3c42adadc826113ec77f754f7af9643a47dd76dd3f7bcb23fe5991a77da6b551152b10ef21b70e67b3d2609879dcf70d4ebd1c7a4374e4d7eaab14e4a50cf4678e34d9603f8c5c6c7417b8563c2aad3322b76df7bbdf27238254a7fd0721d1121960fc49e432559678f7671bcd8e9fd3cfa836c9251df0a60503757b671a67af1c9adc56a5555393458443b62d88b59b7d574624a978c00a93a5136b6ca05a8a8a7707e83e5b2d8c3727219c89333012efb83bc66c93316e874e2474a5197701b05bc631aad02a2807dae1b8fa5cc134a165d48ff68cbb5caab807e5a3bf149d184cd8d182c6cc9c941aae99b3ed71d525bb0ba050562fba6e67655cc2152317882d97cd0cf9eee1b83ce264cea0346e591b7d74237ba4e97bcd26396078cef8b47c503dcb2fa2a3f185060cb3644f49ccae7b1e80c9f10c9613d22436171c6f54ef90338ba70556513b4747aa5098ed8898469f5fc509ccc1f85bc3878d51df569805acb32f7cc44db041e6003719953c33553428f7d5ce365cb4b13ba32a44dda45912abc104bdf4c1f9591bef296a8f8c5ac71daa7cd2f2f89edb963f7377454fdfd34c41523801b0b87e38e5466ddcb7c98666758276c837932cf9036eeb2666fece3f4a262f7724c5a5c170ae797899f3a3cf852ef0b31ccee01f513ee3cf19d52ab25543c68e953fda7f20a6b9ec8624bed3a9d97bd9de58f51883433fc2e05cf9d71ac2d68ad56c1fa5d0cf64be9c14ca898aef5f6f7ca7e05f4a94d5a31c64e8d3f2355bba27b3e5f798664e5940a2f951a63ad6ea5aeac8d70200247ed59bd26dfb07c5f8cbffed7b809be80edc58a1789cd4fea56cf419d6918cdd6c1885c09f47f0cf848c0ef5a4497860de38c8814156863b66e616dc57a4009bc56c54970ab1b509e15ee27bd0f14ce9dda2791995351f11b0a904a27dd51f72b674b4b8a5559204a5243e40a2e92a2cc8cc7c914772b5118f82d4863dc7f8afc813800d89570076f1f3b42f5cce42e5a7d29165022c641d0bac3bdf8144f343b43c107da82854494247ad2463cc4039344b640bd301755d74c82a1db5af666b38927a13b010fc1ad886cce63f7c239b959036b1688406050ef3e7f98d1f55b2c677d800c67e33360df5410fd363c35a95c984b031ee10ce5a29322ff5fd985f40269ed94212bef4135afeb565d044c29cf613f8fbf8d1346cfaac94d3c8c7c3057048ef316c8c8ef7c9a99d34241baccd21ffeded6d2f2caaa6f6887bf0f5dd34a67aead0e850f99cb460cccb176286db6d89da145f3009aa8fe67ec8445045fd61df5e2141af20b520652dcf5a0ba66c8e5d3ad6a2034c4a51535fa27c9c6cf70e8e9a415842727ef42519665f820d3bdeb983b5f52d0297bdff4af12ca7f3b52f47a762baf825caf6672a2fee1de0fd7a3494748ab7c0a171382bf959c800e0dc3c0b2e122f1f31c5b8bbcd86c34cfd1df90760311c1990cbaac4e4a72068e2a86bbea057dca7aa8058e89ac9b63fe7e6ddd468d3e69a203e5c10f3f1e70a02df6e71b218dea72e30b9839f4201733ac4668820e6173919058b5eae773d45133933fed9d1fb0d2cc7acf9c54a6d6a082f8718f09244911dca2410661e428387ff711ba0610892b983b6bd8dd46210d390e3bd70fad48249fa610e9e67f53b575fb998ef3bbb24ab801b8fa04cdcfec22e242076891da45af3798a3fddbbd3e3107d596705019fa7dd7afca46a15109bb2b2a6e09c3aac276b8b61c7a49af16c020d128d4f10820c846124557606569ed8dcde3250b3ea18f3e03618693299b87d4123cd3cc40589021adf7f05b2c61afac19dc15814a1264fa55dcca0dc263aafe4f1dde00602654b4ae0aebe0d0ad77add49e08e0da97ea5b13da88472a41ee57ffdc159e498081e12d99d045195242897a1bb044fb62adaccbb5b6c779ca1c96c808c09a1a9c389e74b811d6b2b2e04054da72f225e95469e527046673dded022e18fd4e979b803ebfdb924ed2520ae8d2df99beabd2f84c397e9996b157684405d548f2545f022f194ef08bd0ae77fec0f16f4a3cad17813b272415a7cd692643bc6a8479b50a020f69ae75e27ae55346ede35b69540e9bad96d262b123ea31c7e6a0a4ba3f8c471aaedee1e4a2ceaeb6e2f9029787400cd10b858781096ca031eba155725c3e6426fb5da18fa8b0d1e4a9bbcc9203bb9ac210b7864940b0b066a7f2ea74f282da518a0beee100d7c2a19b02c796f120dc03eb76c01db952e30df420ba17103edf1fde92edf8570cc069d63b00ed7a3adf6014073c1a2a5bc26547a581f1d15ee1d93a66d7870131cba6b99c580dd2c2def1a3048a5149cfde38937ffde64d5fe70d940bf1579a3e5c03b741bd9fa0f6dee58e14c1a4d0234b86faeb24ef9f45b3bc2991af3b7cbf211bf4e962ab660b910a172fb1b83790524a48687eea1a0decfebdef97b130b22017fe8de04441648b05eb05912913fda6f9b0ac43dd0110eb2c6bcf5036238bb6d6361696b7d3daf48a2f159722ac342512714639bbd3fa8e5d9a22741371fd8ed2c992d235a55bda72121b0d36c30bc694acf00d64b14381fdc632071135c8d84d7d7ad8d995e15671b80008a951eddd842f1db49e476b2e33219d6dd0ddf619e5d9c9d41b5adb8892e71769b0967452f6631c57f7d432694069a90f23c65a6830ef82697fb9cf4957bb733869b92ee3d72288a60d24008a15393821d71e1bf5f9524ccd44164b5aed65555bf1bbba15922af7b5b0b048fce54191ea168db6fa05a2effa2c5402eefc938b42d069f248651534bdb114a3ec41a1d42447a5ccd7036a8872f8944412716d67efdf4bad452cd7a95ec1609d169fe4b44e544377165cf556e08f62cd5e490f6102f4b4dd0f0e18fb13be1ea8ad53570ba13584d87c2a112def9308e063226b3ddeeb7763a6113b3fed42bd394a5d6ad7d069f172df9abc11dffa413b6206b7921eae08803e02c65f0ed263dd93b422d7a2db9c916bc17b612258783d75666a04ed5d76babebe72740eddd040e34e50e5d25103e61237252d046365dade3478f069f470d2a480b47a28b281f87dc5c3451c91440688c2dbf5838f59e6ab90ac3d8a25ce8f4ebd806c34e66a04e574a20165e8e252a88ac3a9ee21b7e2b465539c5a393ec3bbe269f37bb237a374bb62db605d4bbfd674f38cdf6b8cce01753651f897df176ee05ec2b2faf4db1c14402422d5e0805284b93dca30fdfa401a96a22785387f470c55eb14ad569397e02c495cedb6eb590203764616cf8390b8b734898af914b981db371d7fa199a927b14fa6f85136eb40ee83eebcb5b4962a5c771c720a6093246780833251424c7e6381786b34eaa5f9bc5e8ec375c7de7befd8b8d2ea1cfc2b52a469b99350f143e8500ad724a0497703347eab5dbfb4ebec3513b30a2720ee309dc570d56634044cc9dd0690b017b9f6ff69bde5f1915bd4e7d380863776ad4c701e56799297a3de855b1ecfd1d3d2695c91b67438ab062cfea97c90931a6bb675201e56e93032879a535f071474ab2e42abc8fa7942d34901d055fb912d7c0bd7d03d256361a679e8803c0be6098e850526c5fbaea88ed9d368d4d2c560235c8bdbd8b41e32f350c2f6b876e17e2cb137a99800a8114a92b0442e78ec7fed1f61ab602ea2ac683c22337121aa79a4cc3d071b120a1963b064f535f11ce85073b9cf317e56f0aee4fcaeae0223f72131ef81d06d36e2d35e525ee799f019a5ab36f30f00ecafd5e27e12892cfb7457e41c45f6978f428d5a01f5824723d3bf8a766863a589a294db566d93a64b66f3bbf1bb4d80ae969567905fbca9a7e86ca577e4f91d07efc17431f4ff2673492cf91f9a97025e88aa31a82df925cc9f02bae15009041ec8eb314db21bf761730a0fc7a11b92af0df2a9224a07d94c9ff1d8bff22e92b5a609d8f4247e580d6fb49366a1b2750e8027fd6d8f5051c96605ce85f720fe2880374cbe9f5820d196c11671180bfbc045f6f7e2b105d3275e4c3f7dc0e14df394481d1823e04a5ba7fed20b0e50b171e00ac33b81036913a385fb5d31fdcd27b7f1504339264be5c2ac29e9737fb34b7d9f0baa92249fa940b79cdc9a77f6c0b167162de2c0b4e32336241f6f5178228170a57ad32bceefa411fb2d9db12be1e89a2cacc87d08a93cb3b76239a5acd6674de8badc08165e5b2d7713580414fe1372db8dcbb4692dc81f829acc93cc58169419a3cbcb7ed9096ebb791bc0d01d6e668afc4a9f51e60de10f5713cbee9990bfff9e27427febb3ba0519ea8f1fa0963e17fcfc6fea84eeac90164fc8a2f67a9eff64f63e86a4420f194e98093ed9b544cc41809512d64d86797675c3f4c22ebb75d6cdeb0bb5ca6f84a2bd60a14e07dd41f37bc58619de7e087e6368237aa116831b068b902d2aadb1930f0a7725b7295ad0abd915bd100fc1d233a45cd8ed9e7d2fc0a7447e1db89dfd48c2e601f5b24ddc890fe637d97edb54c6318d0bd638b53b2fb5365fcbd4024aa448ce66061716960cbb2571ea8f3a3ffd5d35b0a3ebe0849d53dfad7073c8e86963cb7df3ffd95d6cbfa424e121c4f78510c83bea2354fec82ff63fee9f54684121e042eef7226cf8b2b478125f1bcef36487c3366750eef9707b49103d3c3bad3c1bb763fcb57be284c01571c58fdc9bb1875b880563cc052cb8a24e5eac46c626989ed39c6629bcd2fd1c44fa43c14c58642353334ac9447ebd41eb5aa7105db25954bd25627276c687913e422a2aefc5373a9018776b1592a004707c28240909141c22d77bd7bff0d47b845b7fadff79461222f0960d7877740eb398ae63f3804c398be376523d591c062c029ff8f664e59e372a47a9d1b9cd446fed3629d7c02e907422a104f9474950a5e72e166f29156e2a348d70c90980771b484a17570af49376b014831778817d7d32f38eb03cd7003533cb00638cff2599774de7960cb76a37d4159dbbf9a95d199167f309c79f4c8bc4afd594058c1bda91a25f58c20f601dc7a035c2d643bdbd23c76476b947ee4095278080b17fab0f25ecad32b2b7aa86a115335d7911877f3b0770bd674c0f30c2a2770dbd780737828786497ec9f6353dfafcaa4e627c813b62643032f952cfcfc1afeb24a948b5609f2cd424a9928f692b0475bc9ed00717900d4c082cd350eb294b7daeb068494458bb4cc56efff21b45ec50c5a526d34fdae2fd3db6c1a990d70c5cbf6169b23729ef8348eff3e1f1fcd09ba84c703f12f916ab1e3bb0235d29e088c4195fe761ed318633bbcacae2847e33d079acb77af77b9c2181b9e928846c7e9013476db28b6c566c621a6bda149eaddbccb731c3c483a1e961830e5145d2df0fd7a6be72e722c27599c9e3650467d78cdb00b4a2e45c88c0aeff030e9d563fd6b4ace443908dc2f50283dd48ef0dc307b4bd037e4ff0d407ef35dc675ec47883c74755c79297210253938ffd4e9e60aa7c077eb5439e1e0b2536551e2cea637cc413545d83b061fd913f1ad4ba691d1e396640a9eac36cea63c2977cbe49a0917aa017a0826761a99fa6a53005c12dd00e7540be240cec44e18b29900087fb79ed986cb634489b3e1a9c4a165f3882da4cfdf9c2ad03143fbe2aad44b8b1e4159d93d975026dcb92fb014a86b9070578475f550a14fcfd0803125eafe1ded8cb0e6375de4799fbaebc1ea4a84ae04158aaa075d28a86f1ae96ff6ca66cd52cd639e374520bac38caebe211257112bbc97354b0d92ceda82c033ffc4994220cb0af71093dabbee51068e42d5e80442f49c9fffd48c582a7f05089e5df6044d42773b0335fbc15639c91ce894f32f5a064eb99756252cc4d442d0c36c21a975c6950d99512b91ffbb68e717f1e15315c698632e10ba42f1cf89b6eb54d690424666e25cb7c2cc46c38ed64a745abfe440fb07b09061a0be919d485d7e258d4b571953de8dbaadb53d169ad5ed3bb7ebae64127e4837834f7b4e2fd84d21fbb5bdb27c8ba650b53dcda051a56d80ae4de2911a0dcc22e457837cf72459fc20faf18904b7e2134f31199e63fe4c70508090219010d5ba95934db0ce09f6bb253643c2bebf8a23235aedfbdd3c4a8a08589451dc1b27e939b8d7bf5e046599ea6bc0db2f0bbfcb9803ac94f7a969151c92a92834efea7661876f90eb1d3c495f01d1ce38a2d6da285cf71d1db1f55d5e816f1f162f9e25760045bd673eb393ef5511ddab50f1d4117b5062950d1dba12eb740c00bb1411cb270b5c547d822d3de0adb11a3a218d5715a93430f4c8ec0ba9d7714f1386082f74ea6000d9a431d1051b43ada3a128d5bee000612b0ad8a040bf79c271f7a52d58df7571b085337fb5c49fe2f694177695ad32842875b310a4ac33f5e1646bebec1c1258965f8af799ed85e70500d78777b69c19f9dfeb6dd84f0d68962d8ffccf70ce01a547173faf3f9940f53d860162230f05f5a5dcd852a6d82ba1fd1a01c0597b2ac42aac16421dd6f5dfcb7bd10027e0a1ee98724be333176c21ef70b9c16be39135a7f5a51453827fcb767d2360210db846458f247e9889e0ce19b67d16745771060fc275ef1bbd223b6b969d2608729e89c19465921d9b4ca54ea2dadbd28a0db553ca728a52a1fd90835e29880c89d52bceffc4e71f967f45d5d1de48ef3215eeefd56373b14d4944dee14717524b39a574715fb76fa59437d4031c3e3c0b5597a04f03d42a399dc24cdc8c2284ae45269c5c0922868912ca70eab344d0a7e033f4203bd252b0cf069bd8ed972999ed9a46170e2aaffdfce42b0c6f6526b83827ba3bdf36722a3b570c1200947be5fea0857a40b4806e4ae9a2a548b730d5a96378528c26820ffc52a0b931159b2d3afb8ffdcfbf7c900c1bc37c3b8da6ef81dde325895825158fff8a85644d6ad5f897b28ef15b48d86916c7705809b7db55ee5f95b8e76732f43808816d0d9bdabf28932d55dc5a0925ec4c1d65d8c386cacc14e00120092b85fb4ed962a5eb80cd808fda0b90f548835b270d64f6b5b995f554b2dd544d8f8688c9cb6daa3abc0a6af6a5dfda06b571b15f3c997b00cb4ca3dee4debe3d8355567bb110da9da6da5a0323db9e7342802b8e1e2d9fa865e169ff542aa317a686c86286ef4dc158d8eaa22adc469822ed411290b481716716a150f7b620c089c324e69043f860bfc4ce0ad12a8966aed550efa3fafc7ac8203147b97836153167899abc66fd220ad67b28f33b031a7c181be4de02c179fbf33880ddd062323234373033d5036611a0c5fa6e70399bf3b058b00549a5441c0e3edb985299ed8812e92187e8ce07b3a7c7350a96281318b402a8ede5b0880adf14512700c76467c5d406e6e1f8b279f85ca53cbc7b9d26c4c647494182c9f4de3c1e2eb6347750e2cc86150d7a4d0bfaf95ccda3a4c18a7ed6fe7e48a18b30f93c36a9ba315a48e17d143b0fdca35b3ba4105513edf2f67d4bc730b3f03f8b085a11219bf7afdda179dd641c122fe42fc404ac62936f63159154d41e86895796c1c1ddedb096679a38a08fe955d344825c4e8af4e983df55b566b250019f80351278aa539bb127b7aee7ffc4c8f18191378fd58b936d51de3a2eebc92bd7c970068ee5aeac4b42cb848eb47a8a64369c28533048e0a6a89cb2bd616937fbebb16ed1633dc6288c9c4d421111df85fe4c9d35d6f132db7349f6c143593db6641783cf35804b9f036da6f309b8b0bfd0fad78e975b1b59c8344ac8f5cd9747fbfffbb9a4f4e1b9a272c8972c2931e4e17e7c40c877b92e2d3540f3a23bca23f48e2dc7cbd15c38a5a8b05faa0424822f4435a6bd6adf1b0b2a58405e80e1bc0873d1487fad8e43a46f3b92b6c708be2d31cf7c954b8f5ff639888f0f87ab9ecfa6c991916c2995d34f519cce27f04cfa9002d6f52f16938b2934ace52ab816503c12e6ec477518bb2e1870a73a3b834309d33e747e2da8ae4cdf5f53acd410a9cec9a70988eaefd56a6b482464f5f2bad9bd906877c4e45ea33ae952d88843f0da5150306b896e6de7d7787c3f640169352b2079d5967f415eee51085cbc96b9dd50ce5fc0555bb8f32465dc4ce8569b8320c2911375be5989434e7cc1646923e51722d45f893a9e53b8f8fb64b257f2e515f3c7302ecfc95122db1d7325e4914b0fa33c1ee3c204db2e601660a46efbe0848cba8a1eb7ffa58629043d8ca610cc3dc4ec3ebff9d2ac862f5de043809a31d376542bcf94719ad3c01955c148b7b143db70e3e44d136ce00223afcebd3a277c795901770ddfc344458039288895073f08febcbd6c9efb831bcdb14e8e7c8aa401cccfc07cd2b5b41b99241749b90717963aae0b9c27cceccd75b0babddac12965e2e71ac057977bb062e328769b0ba2760dfcd927fd4b030b2c0c3f7dc1f8109348264c517f52d37e666e56f196778f8db67377c40fa6370a244ce7a347d55e698cf553d1b67bcd0e27517f0eaec9e090519a15ba68e857743d30ee2ae13c2dce6ce27f4703f345b9603382a1254886615152aa2a458e731508aead2ea5e324bb34baaf64a45a74854ec69d6bb138196b266681a4f049b16ce251e9ffca9718396b3ac911dbcef803c4163b248042facaadf7e1a3775d799babe18d8fa8b72b2e6718ed360f03d3b8eda584b6ef2d29f288075b017ac2f1fa685d671a91bae168f76f009ff9d6a1ea7b06bf23938efc9efeb6e3e0ef0c0f9524f320cac60875ce3b866b55b95d50a5cb23403bd600006b8c9de3107bbb59eee05cc28988ca6f856940d7fdd9bb70d8be0552ed89c67df3a0fd6d7c544ec1fa6c31a4222fa498eddd13f95f5b8f4782a398e0d2a077d8013bd6e2932701d8e26e94ae7de3dfa746d36af2996f8677bbb038033ca93c3239ee31c3fd6990b23096ae8ac9105b309d51757eaf8fe7ebaac93457073068499bb582d7201607e185ad708cdb0879b619761552cc3d31bd9ffea4c8e68ffc7e5e8ec47fe6e4974e918a348d1dae4c25cd1bda74248e67a09b3d06bbca47044827deb5bc547254ea548ba9eefedac70c2611650e813684bd68f45ce0780a03ee8501c2a003210d08a68963607d213a99224324c36fd9856cc9f6ffeac2cc859ee771abc179f59c7910b6f3d9d49686be60c9e9de71d61d74305d45cefe75fe0de7f435080f8aa1b2a436a7ffaf543103c2764ad9299809f6208adc97da5740ff2fc9003ad6d202d2c0f1e7f817347926237f03399d955a5f7d0d8fed6db1d3fd2034ff9e3f34665812fea1d009da1fe76ea53c9ef228e3b838c2548197c50c03e13c0b7a4b2afe481cc9e5f3578d77fda38bf59dc34b991059e4ce90c2d3a13f4fd9bc50d2e56571ccab65f161b123ce1ec1994d6a63a631e5528e9fba7e5252f1d2b536a823f4fd527e784faa32ead5b76e311dd32069b0dbf1e90df2e6d891e2891a8f9da6930b069d078b09391e8154d7033f45ed7c71b1f9e3173ace8edebde585c0a03ba40a26074a106cc8d03e18198f3d429017a61d1f16ddeef6b209a720cd1d67c3c536c99d408a5c4a40259ce3a5e8c430cabc7d34dbb53488eecacebd82101290211db96c8dc43eea7b7fc31dae9ba71300b2e9d6ed31f8f8abb85facb8ec02ce1d5fbc76523ec8df1b79ac3fa7c5639fe19d6925befe1b1d68ee7863a459b42df0776b391572b94529a918196267d7dc695354a7f213c08153ebaf84b0a3238b6973cc3442d12fd0e9e86d36362db4f217a3acb0d69eeecf06d4d5200876c09b2b19d0886c5b5e040fc72bc3a7b175477a30bf97be71733fa5d7b596751f81cc0bde83da198641fb5f533d627da6e82928f84e78b058d6c138160cef310266648d65b7e2c73eefd21ea177f78f8d613547e8d32278fcefdcc86b6a7dfc8d4dad0fbbf84f2a9f3d62fde62b9e609fc49862cc085e263e4953ac026d76ced783a3f47454a427847897a3acfffe7a3fe0427d4ef9bdaf3c18093a6802015abd7b79cde16771e98c2b4d72c472c504dab542e92c249e23a3c53cee9c8f6d464295c3e878d5dee3a3e7851b4427aa6f14b3cf135fe717f910823407171df982eb0627a00edadb2413911a2f6f08f67d4d3e42698d0dbae2a2648da9376374c8751aa07b7a1c7d87087de527b4566b378de0f5da5f11340aed45cd86ffaef241d8576b9724a60419f158e69496e9806b0d2a6b4c4b7fb8076ebe3dae8beffaf4e4d897b7242391dc836181ee0e8285d196408f24fc229121638e52d60f8ec4be1124a26728cd543a1b4de029dfc61afbc5b7dff63c600b5704eb5441805c7d7ce6ed441586d1e274da96608badcc77a24372e434e8eecfe75b753011a005f4fa8b15625c9145f75457d644f2e7bd985c3ff9a2c6c15c87290701519145744db48c9f7e7c5935bc00d45e1406fc6d402b2c17c63424a8b0efda896d21dabfb6122ef113fb5709ef5999cec1154224bafbbd98a861ba5b60565300db78f558a932e50bdcbbf356e291b3a368ba51ddcfb407c920f4bf3f6bb3a2a9e9dde5b0eee134fba241773c62c511e60d5fb9e3349432835457b7811a820377479aefe3bcb504432009b6ff8281666ea8ff1e667c4137acee1f45b9d9d34effcfb4bdf14f1005fbae24ec20d033adb2760de1423d0c743e6af6f54bf7e1447b022a7c9ea0aea76712d6c1ec74b89f58275f7e409c05d5be37f97e74710a5edfd7ee572196c116ea2d236b6233bf3566997d100a0a2a256f29099c219b0ef612772f2ce753eff5a975ebdc5921fa190b6fd46cf673d19887bcaf492c90a7b2b8e0d8fb98b2db8bbfc8e443648dc6a30ebb80ae7f966717bb5bcee6ac5c74488f0b23b26fe8c99b2fc8315e1d94b11b87c6312fb146d40a9a5350fda69ccef285cc86898dd9f17d348197dec21bd4dde15e6be53937349cf1a507e250964d75679675b3e2633d7443fea1c253994826c1578da9f9daa5621dc7033b93a009354fde2d6e24982577f45eb67b70a5d95434c34f0451243f1e16db534a5863ec8c808a72fb2e01823e841caafeed520c51bb3d8b2cec9fefec84b8336d146f78e22f936dac164d5a69f357d4941517add6b9172522d4f5d10af5a862ba53e613f7ceaffb8473477aef467e8eaa724046f8d582c003e7779efaa7b4b60a214601e79933b40210408a2bc5715a09b167875fad4374f35773965cbba5eba4ba7c5f265172a1c25597668c3c9f16c4f4ebf5e9365290c5a8ae86221139526fccbd585de78d5dac499f3c31654a8d02c61ab8e6ef6ce6795f184ceb08d695273e2a684b3dcbf9bc021736f070c6a63a51cc5d91c9947a99f85e33b8d8fdfb91099277e1e6ebbfa07a3fa80f0498585c8502e09ab5303dc39afaaca2b5d490e3c4e07e27e8e9130236a4d08962a5b17e85bd9602b28cbf7f577e7169d63f01eabab78cbf5ea7f1c14229a525755b36b5153cb52f8262fbec25a75c03499d6efb2116d8ce39cb1ca3416bbfa1e65eb4b44de79294f2ba285b80b6f9f6768c1680fd3175142cbedfda0485338d5f5f8e9ff317db942c7c7e4c1d0ad090d0646399b23c901c5d71f917de0cd3244d06d2710c2d0ad22a936c92e79a7eb6a56fc04e9f5f5bfa69c8720ad3d5ae92dc1ef5e0265cc5de7ce99805a7c57df40c23e732c75e15b8702340d73bc8816f44e2e00449dc4393b13d8b819a4c17eee17db7fc483c59679e03bf28578911e3c5872941d1640d47041616fe69781fd3f8b6600b0f120dad1725a24e141200a685839018f914f8ca961b9d398aa53382b33b1f14df0194169292947487e4473cfa7fb1346cca092872a8860de207278c8cfe7e2831008a1c5d4bbc5c46a113a9384788bc16ae94ef26e9284cd74ea8ed6f84bb9696824d250186827bdfa51e6c8657f6297f44ccec6ffb1186f72ce1512ca43ed500c6c791edada5efb4bca2ffbb85aac9a85d9ce55c3386b35cc717dabfd4baed7cd11678894190ff1a4dec0c304aee013ba96d4a72dcd8922051971bc5c3f354e58fb4f6a4414263cc84f6d916b16fe41d898af9d51773d56c94b84bfd48b9814ae12d8da3a98af10d77b80446620fef41bc113ec05d5b25d17cb8b6565953485d8f1331f7c87a056498a4f48c21958be219eebda83138c3903f8bc6c2018f16f9732daa6db7fc1961934c6c94801e3bc2c9611aaa196e791c43c4cbd49ec124ec8db3e567d261e5e354601915fc399cd316392c2046424472837a5c3701e7fdda686941f18efb8f598ae234389d936b8f09c852208743d219269ec4944e13a54f55ea1379ec7e7fcbf1678dda8e348a9332da05ce53e88fae8fc5ff263fd0775f28a9d8b3b0768860218e76295ecb4d5a1a195e646a3edefba3893f56289951e23771cde0f14c41dc30b4ac08e3f5492250db5e9b48dbd4f995f87a878d9fd10e2105861a9c28bff00cbb86d530505d5b5498a759970901bf6d8b1dea005e61c8fcf84f5ce2cc6650acd1a5cb35e996131736359ada72c89ab7d06117adfd2fba2e245588dbcc218f07598210ec7f278c41cb6e7f80619d8e79bff063c7c6a5a56c8be20db787b3dc2e3bc89c8dd54076816749a603c6ad9c7ef5ba3780ab594167d12a3f9f1405051ce7b0d93d2c27ae58133f4ae97fe4653880df06a2bc81abab2c4ab0eacc762916437a7627e1ebe5543dc9d11c882bcfa5e4a59bf2d2c6766b7fbb2f1452ce0c897386836bec09d51712a5f83f8015b498d08f99d3a7bf97b26dcaf75ab4f7cefd6f72d9150d1941e9bf92bd65fd7e93a6efe7260a011384d7fc4725fee23ad070a12bbb7546cac36b8e4a3ef39e3c77b05440bfa5348d848a0597e9e9bae0b5f02630d765b5f2600e3744d4f7a3018c9c2e27f07126e69eca21262632eba4fc47c51b57f7cb5cc047fac76af7709ad583e440f867580967d56c11b9c09052c57d85dee074c19775614d779067cffbcf2b09b774027e9ac5cfc3bdd528883dc615d213abf085b82eefe0dd085ea7cc9a83da311abfa846b35d646d94cda73ca82fca0dda45504955b752d0e87a303bcc6be0a36b2e9280d058651ff1dbe4ccebe6c663a22723868885a12f1f23dec674db3c6580be4aefa0a0d61ab977cf39f214bd9f6c83fcd161fd9c7ca6908ddf1a81442c68f806c161a9f2be06039846f0af49ac1ab20969cf112f9ee971daa6c8a59c9255f7d10ae1172de96fffa629da9249961bdfb819aad16b7aefd48d1a34285dcb9073ec7aeb43d509de738bd64ab4ae5ff2547c28f34efe2a46eea7f5f85f8f699326b97e1d73b986dcf81a681e8cb8c9e7140cbd63d79e9a24aa8aa5620c459522fb7781aea66a64aafa482daae0d63e0b85fcb42e8cb1bc7ba24558dcbe739b3da7c4f6d45d8334398ee541d11a64a646873ad793976b578c4d398b49784c84db76be556bf933784965757f97595e145a5f3c7bb4791bfe1a0454223b2ae0ecf119dda3e60c902a9ba3dc6c69f77ffc2bf9ed1ea335ef3a2410483c8cfde8cbac35c59c4fc2b6c654dda90948aa3ca0fd12130118b60dc24eb7fcf7ce835005afb5c43acaae2012193e98a455ebd7a17b64d711523964f9759287c1a8dcd026642724f8c6fbae2ce94016f3e25f81401de31bb10687a2ce16f47716b248dd30b03c46fe85592ff4e9bafb32f49eed8a810464e71622bb2f32dd1d3f28f2e974f949bc85b4e1a029da534d1c692ed5bcfa343fa899a01b6f876df4b4af28c02c14bc4d8c3fec3d15aa9fcd9573863f9bb14d37638593bdbd4de3d0c0eaf7d11155bf04d906680b809d3fd2b1322424107de2a7b48cf3965643803650e77fdde9b77ade4b2417918471957a8c0a6151a9f54832230521b736fa5954c442e547cdeb59c58a05d850aeae5074ace61d6d1a9576083401733b9990c0425549c647deddedc1a6ef0483bcd3fae61ced4a20dd58185509a79cb70864296ec7860d0b7d23dc2ca32a1b5ddd9d105f1f76fa6e810afed768020c8a11b2aa33913f37291ace2ca1283e3e0bbdfd81ef74f2fd51f77e0756c6bcb4134a90ed6542c4b38bf5cf2ac0a76538dba6dd5d1e247721c4fbb058ee9cf7dcc784fceb543adefeaf6344e6b5ceb3edf6b73059112dd47f02f6593343b5ad8f881ee114e95cb9fdb4fca4945a850521c29ac0d4edc59e202ec18253ee63cb92b3d64d884da216121352a99d97482847d6f75b4f4937de392d0e51210a7efd3342cbc63753841f0029510ac513926d4bc8ab5f40096d471afa9360c0b146181b98adfc044ea050390144235c130fc4aff5ac46c2680bbf5d9b126ef1791fa76dbdc7862b7b290129db6cdff468f0f7a49ded013ee69c593b0d7934cdd728b09674627ca0d7230ce574dc752f260d41b71e49cd14ce9c88aaffacd186b2c9e22a5098b1ea710e20a9f9d2430d56e9419a757bf116122dc1b38a49025e99fec22b7c50fb52a7558aea663ba61302773eecd33f6fc3ff7a636a64ae4364cf1e20796177018e8b7f83cc461acf0ed3532a995249d29ac6f95cd8831c2f3d91762c963f4cbc62399e9e1fb00474a6fef590c84baa5f5cdc7b04af7bb3680665a7e55a3bcc8a0bae1bac0b3f48b89eeae5d2eb8f3092d092571f8a10f4c59fb48298aa58ed50a9dbc0d8d968462d8024e329df9093a4415a452d2bf28c34d41fe7fde6d5b9dfa4facd68595629feac5eeb5708ca96d7e7cb28cc459ac80252ab2d626657aab985fa02ebaf3bad5b3db0f904c08739dd2accac4a7ed50b0ed3b9ebd08083973c536b5517aaa065efdcb929503eece6448a355c819a8a8b53a8077129029f34dd84cfb20b2d6ae21def50b627acae24cbbffa717fb441af2530670219b7a8367dcbd84f87c48975cbf15528b9fc980d55f1cff9305f2084801bda2970d084ce2323373b78a102b6d7aec15c143797365731a4ae4d37cf9b3005e25997c46c36aa0e83fdd3c6150e2d85fea73d112ff5c71de2c0f0b4c4fd8277019a5a1f41f28cc5ba026906200d830d2eede725a232cdb2f574e98373d3667af9af7361240a5771becc2a9fccb38ee26b8558e3b4f1c481f8dbecc65ff435706289ca6ef1bd2f7c8e1c554354a144e21e1e0f405417ed09fd956b3b1a72cff125114ca752043bad1208c876465bc9dba1e2a74619aa2818c1f1ae9d541403ae450fc266615cdf35e2e3fe92dc716f0541fe2040e08c2b55ed3b3fcfb4277ac971cf83d3c0ebd5d4d9e5669cd63ce35ce1b6a9afa791915f13fcbe508dfd6c8fe19b28e099dcec8fe50a65cc98958a00c062d1ae2bc7c07ac56f5d5b8bfd6516020c2a498d7dface0325fd4c5cb2d0ab087ae905942577e559dac36f890f65002ca2acffb4f5001ea85fc3aede3bb2b002ed6fc3b545cd2952e46989d17770f255bb850c7698374e79ce164de44941a823d380e39b50b71b6a2dd471e0fc30ef707f060f94515efff719b781decad4165645132314e52be6ed9927452dfb3da95e09bed9122905fb58fa12f81fe131e1695047982fac464b7e48c451d48a42be2fd7f97fa44de94f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
