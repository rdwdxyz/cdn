<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76f27100266b43d43fe49e33ce469a55ff2c652c513567695f9e08dbc701f2f74391b2f6fbfa1ad06a5b14a5d27bd01aa14b430724a3e841c688963b2859d1f0347c84905f60af8c2f85505107eddfc20d58c1d15190c2e71a3685b4dadd4b880295ed9de474445eb5df852510d7ed2657dfee9bd37b4eb370e2e2cd8f569525d90d995c5ae9d7c2212ea51492439613c84484bc4e327892f2f2b05b3aabc1d48c608ca9d76597aad3c15072eafa6f39441795937f00aaef2bd471cccb183fbd8c14407b4651b1abf92caaeb003068c84dd9a4006d8020951a2f74dde0775d4064bb2e055945f98c38a2217d4f53abe560b771598fbbc8e274ec57c74e75dfc63b6b7850b0dd5392129f5d2d18554952cae2b1f691d726ab00c03e1c77911cc93c9e8ed87049c1cb2df19682605f786923f0619c58ba83ca7ed8ef355944afc30ecc7273e08f866ce16cff410bc5b15d789fa3d6f4ae3aa7f83679deeb18d82bfcd1b61b205e212df9adbc6c74939b3d306cf173b112f09c7ebde972a761257aee4718fa43a7c9450120497f938ef5e5abb7467cb95932cf5e0774ccfb9e314e64459e721af1d9d4f15e87048357fbedbc69a21a99bea34952da69a9ca19ec03130db4602185dd9bbcdc320308c364f6a0eb8f616e4984fbea55a9ffda8114d4ca1e7e00da4cc44daadf689e88f07eb54e4be2d8aa8ac84414bfa4f72ba0855be81ee36eda3e7dd1771c1ef008538776e604b8a1b354a71f2e334a7745a3c4af26fc17e1e6aaa68c1e12f2370072993adec92f98b104161e260148be4d4343696d66561823355e9244cf005609425520b03a97a0c1751d1eb803d517a387e912d672aa5abc57e67985069597620900582154d8bb6691ad891c55ef8d348791d98cf218c6cf99a071c6f3c0b713c4d20da77a185a26cceb64383528762a8e0476f54f5e96c12b160e18b81fd12341598a2a36b93a4f5bb9dbd31a2cbfdfa91e8ac994352a7dd9a4c0592d04ddb385db072fa6ab42b72d3314879e172f0db62d728c5d949e6bb4aeca6cfa5d0535ba6333458281143cf31243950c381c96bb23d1b3dffbc3dbd47e77b0d788c830c93e2b1c089ef7f050b98f8516e322f69b42e292f53ea0457bdfedf2669eccff0c3b484bd3644249d5240eda3b3faca27025f08232e24a6e20bd95953d855d7202cdf76f844a2e0c68b00fd90dc91c7120fd6d12fabf5ccf82269039a121a97d0ef07ccbe65ac1f4ae80a2925f51a09cd2c80ad0950504068d294358ba006e427ec707c27dfaaf1ea94d2574ac4256c943c806f374c82dc606a84e622afe17a05c652d701371779f7e4b10184ac88cb1971176ea2ad6d5736719fa2504a8ea12dbdc9af4392cf10fdfc50ac928fb06760b5ea19bc89d1e24e980a1b375e1871fc7155c5711f4fbe298a86b134d589e2ab814d8cfecd9b85023cb4192737fdac55e0654673583e574d51030eff835bc9624b33e400212fedeafbdfe9cf0d8aade3f4180781fb1c121ef5e4811bade9a595180eef2b6bab8b477b3368b4564dc4370142f8b27f7ae7c5c29c7c169401a08f63baed8cca918bed5fecd75aa359bbe579f8a2c62061a8a3732d60f06532c813edfa648054f42f98edcd29373312f8bcd2df04edfc6decde5e8a30b9f401c347064baf4c0ad25d9f375e70e3a85ec15113b3ed954ac23e10b97bf89f4f6807688a2dfdd09e47b703cb15c6eddddb7347199e38b03c817212e51286bced289da578e7ca0b2ee965790d555e496336835f45f13434a9c0a1489ddcefca48d2ac0a1f4695f38c16000986e19c34d14df2f3bc18501000e515366ca652a10715a01789b9522d8ac9c37daec693820c303808b27ba6557c217c4c172bcc04319fe5d3552abda7509dca967b349895b96455ecf5796609c881b3fbddb715768f6995475c025cade6a2752adc07678437e92f5f6de05d6ea15ab818e8354141cae056ccad89c8d3a89fb29d622a4d69245dfefead4359408dcada955deb73ed6bb80e1ce357690d41444093b9942d8f60af276a4841335bf0535af4edc7eaa31f20ce1cfcd67da5657a396a3119558b0068a55be60290d3ae024f7a7110ade47acdb13a6139ff5e783138070128ae4243c6eac02ceac4d8064bca5685794830da7d713a18a54ab250c34cf6d4d7bacccd983913ffa58012697573d381aa0a0c5d7b46e04329135b2f825445d07b2b8a45beec25b963392bdc60b0ee4ac0f2c402c1f24fbba7508a85512e03b05ee6be53ba31e7cc7d4e28f6fec76388504f640f22ef357ac5b12157b9c64900f9a9a45c62ea4eb0020a1ace5540fa3511a3b420daa99898fbd11abcead07c7a10bb1ede2643000dca64488b4fe74a6a19371fa35db1a1a570c8b8535c73d5cc1f1d2d526e6729eb043afe1f1c2697577d67ddf5070d06e665d9b8c9b0bac71c0bd913eea6aad70aa5ac767cc7e9ccb364f5447f1e48678fb22a781fef2bd5001ce969d7c6af8377a578e7a204ab200a424893cfa5beca806f5c7318bcfa07f56c048ded947112e570f76dfec3be3004c32284741843614f8e04be697b1666f7c41223b94f832c4c0595120b31abfd7c9bbf2d472bb5ea854e8b22fbd6c50a9e9cc565d4891c5584d15bee9a20d5c14b4d35140ec7c8b3d85a230c1c1f260ec69b92619dde29630c933d4ab955b069d2ca4c0aebf54250d62bb4ea9dc1f9c382637589a74c7117f7267c6c8f822b177f26cba43c8144710a05a3e6b0bd0667357097d6b40ad77eab4a6777ff3fc8c9bc67430df454fd377ad698bcd98b071de467a371f3bf0baab934ee6631775f388375d2b8fd1be9cad8f7a1b614e99afc5fb25ca13d0e460bf61e30064d26b64b524be7de8df24b803be4e7aec90a9ce63434c98578b7fe8d533ade6c0cd0d3b684d1af1acc0b4c02a836e659c9b50c0620d3434eeb27251614102e42afd0e86285cb04fefc51ca6f9b25b7f03b85831fa10e16d9e2d2492e07fe71aa15224c56ef69243071f38ebada795281eba3dc0947c73a6479a5091ead20c1eab4ad9299731ceb2db7ae262a033417d67fc4b67ddae1e0fa35fcade8689ebfe4fed1409ce90e658aee3bd71c2a8c13095b6a71599e7554758afabee27c5093ac2f05826993e4c19314f8d00a2973fea9a80cf1247bec07030bdd4f94fd594226cea31fd220f89c516c501155e3ef0ffec3b05988df08afcc5c06901d619a544336e0b1f6363e377bb9353058686764ac732e8b754fa23b75fe2e2e2d23fe259bcc5bfb0049ec645aa0d8ac2b005c87a21a7fffbdc4a42fc13e9d42cec184987d7efdd4f3082110f7e4f2c3b19d8baa8b66e00ea6bebb86ea03114741a875c9b81610267a611c1c56f6472779f4dc434470e8d7fc4b17159903e2ef6fd195e937dfa338f4f263fbef86094b1ff5da8e61d9163b6297826bb6fc076945377118d4c76fdcd2cc125934808fa36d59e484e424ff6b7dfdb06b2cddcb9fcc266956719e7e5904a74c2595f9d525ce4744a5f6924209a17f4f5980815909f07106174d3519e0e11f0660ca76978c39b329fddb904bb378eaf5e3f429ae2f42dd2b5797f1253f894f1d691ac62e2807c106fc7fc935abbd5344b5c50c6b8717754d5b41cb8504636714f627bcac374afbb77195cbe62a9186d9db843a8a7a96103c831790ba85efabf3888026b1e119b0b5bb6a86b3ca17a13cbbc1a59173a3f8e13afbb2560428e12b71bbafdf5c61c70ce48fb8dcbdfb779108c7d6a858690eb846d1fee4ab4b565c430657fb3af64d26c16a260a7dc15237d3aa46f6c50d9f9b7624f136cf566f48bed0824bfaf7b42238623c04eaca587317890dc9a1b2d6c3dd20fc3c2ba2c777caa961e9af8889ee2bfa25a168bfeb7e733cc576922b48492ab8f0e9a73e85c77fb7ac688dfcab65db34d9c3b68827d716a0c50c3a28d5bfe544eaa025e0a65b4bceba1a69c44b15057767cab31c4e7082da336ebc165543884234be422ecba70e5125015103ee366bc29e8f8af8cf8ef47f8481188db6ba0c366d39fd0acb7f5c20469b29a56cadbaf8f19e34a01248cb71133371b5dcd6f08387663e4f2fcaa8a5b83c8b3fa0cd9f783d446a910fbf9dd325ce162a3bddadb7e3b41d65fa2e841613f919e318ece0303a322f2c237d1bbc77b90101b842aa7b15b6664d205ab3231aeadd627726b2fd766381cb198a51af06d3c5645ec622201c02215d9e916f4926f52bf2a7f40ec927bbdffa64aec09195a458235298e63277c712264188275855ffce3cb54d68dbf542d38c6b861983f424d9f246936506b0eab2a27d4b6ff8f9d5715a8263221e307b48b8bbf2576458fd7cbcc95639adc5027f0a17dbb6ada4a94374437b6eaffa4ae905a49e85e51da55b0da4a24062deae767739a5b4ed14c9492a40a82f80a4fa18c70347a6ff34bec9385130a933d4df50f5d1c2516d6068685e4a46b49198e2b9ae167ea8da22d835d265d038a1c28948e1e39859b367d2fb48930188118a9d82ad77e63308305c32c4f428e9ff5df9715f46616e237a8caa4ceecaa474e45bc4acb77e6547db9471cebc638262b7e0aabe32dbcabb1515bcd2a02e9371cc37fa252b637d5efea1de615668065e1a8f24d580bba0c7060f0e87867d61b4502f2bc15a943150a0c7629dc63a87a7503c9044831c9a1ef52fb3652d8bce5e1cd9d5d55599ea1ff3608b8eec55401cdd2a16cbe6ebc77e9935bca4970d60e7ac2e80ef4e7f4b649c536d0591dbf499521fc0e966a031b8e26cd4f4501efa9b4f38c33db05f9bff20a5757489e9b783967c2b81a07f5ac5f66e6f070ed51f98459ba34009295112add6f54e9fc214e81d26f6022b0fe4f5f469a6d68e27d705c0ee4943055e9447f174f3389534b15f5eac0a0ed508d1c245ad96ea0d8f9542027a7335f97ce784ebcd9c2f1e2fabf34d807f4ecc1f3ab3f1f8a364a5dcb34d3a3f204c1e12f821cc0a74c5f9ea571cfb6dc4300aa2487f2e73ba2bb204087ff6a97b275ce9c753fa9f05ec5fdfd318e40bd1c82b1f641ede1b2be0982aa2e6bbdbdb481512dc653e1742ab70cefadad2e5e606021562e3e4870be03bc8ea13e65a82af03073700a1b4d13b0509c7008d1e96e4ea88db0cf421d8361586f0444e8861bc40b67057cbcc536f6ab6c1b7246d069dda52c40a16fbd43ff6c9dc0cb3a66aaceccef02694789056ac87a8a903b2cbac02c512d0345f007fa8d2004a5962cb0c162d3b7a5d9824837cb8e75f451efa7c6b7aab80ef7ba6adc10142fbc161ca66743e2eeb67a86c2ad220ff21a27172fe8ebac1b551013af5fb161153c735890cb554a1e85cc982df5be17fac26616fd21a48be781349cba7fe73cd7810f1642c78cad66ba2c62900ef224778e47b83b8f8ac543f9a3c1d6cbf5c5bad22584d1697259dfa30fe402366b5e6493def19ee1b111f7905761bd8c9bc4a7b6380e9a6b9eec59073640f4fdc2e90393ccb42ea7bd347d257f75166155c39d42df457a5aded84e095ddadd4a94fe58afdd208b44c6b607df6c2778a1a55db968ca61713283b3900535462dfaeb9a9e7c32913ac61ffbf6c69ed7697ef293bedb511d5f9b822b40f9a048569b42e390a2c10b8c0ff782a0d544a47168890f29052e874205247d8626107a612d9d559b2f62d3a8bf7c90a23b73d689a71df0405017bd45517379e798c56c7efc0a1f2cfc6137503b9d28d32cf7432b8e9bdfaecdd6b35028cef4c22f70d90d96bdb10c422ba2a0ac2e7f9e5b48bd2b4c39cf58ca71c6087462aaee05b6996c8184da25d6c3e1d08e9f506b369aaee651e7a222359e791f274c768628bcd4eef33b0a443f9b3f332541585229a26da61b67baafe31d805dda3244c3a0fe50432c3b30c9c4cbed3cc8011c866d855aa2c8a6ca8cd814ead7a79d1e9eb2a4fe47b8eb7aa8351a870b036b598cbcef6807495499c0ab02ca7e7fffff02371dd184904c86a4ae3e66cf25d2ce75978f2f7b6a8f1578d96cf4ffa60d730ee2b0a6d78258f9dc8f10bd8bd07eb140be201da41db271036257570bd47e19a2bb3fd8ff3c8fc7a6e3db37d70da5ca971d098b4f62a5052feea5a4eaf69293e81125ae6595187aa216ae4403e888bb04d33f46c2fbb2c5da47971defbb90e889945eeb196b65655e8591bacfea7afb9d4072e83536c046c3e3757aa92509d96cac1cea50d5a1371763f7b635ed647919e41bfdc5ff07f41f03c5431e0ed66a6cfcb2f194fca2c23f57b4964ecd04e1c01048726d0d35ce318f09f39d44431ea779f3c3091b3126d31c67b8812777e76ac3e5daa85c57edf0db31963e3ba504d021d48dad4d99255ed292e5eba9642e492d8229471f27c22aa85b14970d9b6bde5bb53abd48a39fd608477130dc99ac4005ea3c918ecd82bf1802d409d6d96cec2dc36a0ee17743bb4ebcc0e858019fe5f10ac59cf3bfce4edd9bca88158a74d268b9012fb241e8a444b15a02df7c18e05fd2ac145bc1023c7b785c02a04424720e9a2fdf9f00de2575cef17ff163380a2597c6344eb4abb4a7f48c47f156c64e28995b1df43d9ee77666bca4911c469ea1fe7b156c7012a60ca66caf17da15441a9de308637cdedb1aa8f56e07994a8c5c61e4baf22496fe0fdcd9714c35847018d524f6cc95b4159831cb85ff9d56ca369b7e8d7ef663640f1813d6dda73b2238f3042cb507f2a7d2b5849a7ca7f2fe8af6ae18ca3261d2099daefbbae51d350622a82172ea689960a4d3aade57fc7cb0310f5f51db765bd594f9bbd222b9792e76236c989ecf93c47fb922f24ef9583f6e4850399335c2438d93821ee83411db58071d861dbebf2a14ecdc67e495f4235321202671153980b3d238ab18b20af3c3afe9d5d3b01f26fe74ccc695efa055565e3c2f97f715f7f9ab6f28596bd519fdcdfe16a85b62631fc3a8d423c08d988869fe6566b5820c5d2d6f1d3d282579725d11c363cb79ea0a71526a5c82363b945d66064272175fcd5d4818a14f0acd73c97838dc8759ecbf722c00fe2f64a2d344d50db6d92ec4c336e4367907b1287c50ad7330fb67751c5d4c18f62d7d67a34942d7b99ff5c658371a4557fe3900d5b82278fa93982fe87b941593cf1b71917c843e493ce13f5039fae2d96cb80ca295360435bb61a229538595fcab39d27f6c9bfa1685175ca6a56dd79f90e28b5a4a081d89a33051508b9e344ff48a662474185df3df5596993639f73fb13ee3c0c3fedd07b530df66c2391965e8d1d4d6ffd47eebc1c63c031f3d82efa953f650a2f74e74a07384ec09cdec6de47db1b19a3aff42a7544a3e1f2dde8c3679b9d7aee6e021754ac1f286e1ceebfcdc9dbc9338ca9a3afdfefa18d458833b7b78b9f7bde56ce66c73d014424e41b838f306243a4237adbb13078731c80dcd8a473177eb337a8e61ad05cc462fc742769ae7cddf25b6b1aea885f32c9fa2423f4ce98483aa10f4058f5b10d8d31819d0ef2a5d584b8a360893901457d6ab17ea2aae216a06bf9df79db9423e4f713c353f3819e1287ffeabdfba172d22934db18ad6329b22d011df078a8c837e8d221a04a65e0f051e0ad4fb5f53a98beb713907b80fc868a19705b4a287daffff72cf10a0d316c7949bef426e08a703db7ff0b4280774bcf27e2ac23469fecd960d3e5c4e2b7b444f49aae50a8458031722199a6ecde7bb64ee01b880c90dae56f941ddace9bfc84b8cf9411f11c369a4c25c2701b59e359a240e258c3704f117a3e356f8d373201fe2e931a3cd7e407e16886626f8f339d445bae6db99b1789efda78d7466f4556899ddd48db4ced5e8b310198112b463c7a71778c8a2cd0a21182ec52cf951509859a1d7d5c6a063fbbd214c1097f419922852ed19083b93102286a660ea5449395e375f90cfc3d73369b766b2c7cf42074d62184e478ecd240c91d248b26fdcab008015c1ea08eadf58d7dd98e4dd49243ffec7cda24a8daabb2f77b8d02b082dbd858171253dab0aa5dbc8937e655b9ab037d9184be90ca9a347ed196edc91326cc9f1ab1c43c9661f7302f9e81e10925e3d00aa44857778f95824a4599e1c6c9094806bb7e737ab8261990796802d52dd586afa8caaab814df2fa7ee487647b0f500c2f03cddb8caaefb59bf16bbf403ccb90fe91a5ffd75854a952bce0fbbe786a35e0630593f7629d8e72a8819189e426b299659ec04972ef646f42edbc373673eb8610d0548aae726686881b3d6eaa06e4c5a32229163349bfba400de1234d42a98df469203dfac32836962305380e1e15cdc3bfd28d2e8556d85b79d6e3cff87a292a30587ac6d83984c34f3bac40d17887f669a873bbed0fcafbc3571fd433d11b2168a8ee18fd153c2aecf8dcf7bf8ca55da683c6ab7af1b782b417b42fad64f7bef65ca22ea377a52fedc80a7df2e2f0f5467c04b74e0879b287122e8091d290330fcdf94f382f4e8ab13b8451c181d8d2cfc53d86d63ee648b95f5fffef3a6b445d3c96341800ba1fa123d48c7f9bdbd753f485c057bececd185350ad809d209e6c2cfe4bacdd8404607e3ed995921a5e33d5f07f06a4a30620a45186c72df0f8e014aec9feaf0a425ee59c4f3850081d883adae3b9ea0ff4380e70caf0e922816704e1eb8462a59114fb5b499348818e42ce18a745564c3d8d5c93b69f460e3162487d2dade3dabaf519aa464f218c267bf832adf2fa6d7c8cae84ff3271ea4feead9765f50b2d4b7670003f315f226819e97bd2cafbb8b6383547f53ede3e06895cbdf8196eb9c7b705c9ed0192e621a07f9ece6ee55c1e3fef4d410cbf2df4f794f5f389046d3b67e2787768aa9ced90dd3a4b794e44cc1dc5abd76659010581cac65112684e87ab7b82783bda8cab3845fc4559b457aa83dca8c0059ee6f18182779742de02322256d069140e8f9c6d72a7ad88c29ff8ca3b4972753d4940d948026d76ef8fac103ceb262eb52e310b119ae0f780b726605eab821ef7db01c3c5c252c76d9322e309fa4ccec66d2df2fddab29dac2d8ae3123df8851c204eac400db6845ff8e0b66b91d5d7cb275755bca10002a92adae42fc20f129053f33274197283514456a4ed23dac9a9e9856a7d0b292bb6e7a80bcc1a203e7960453f1fea74a71ef4dfea26dc0dc766b3f1d6445826e649b7daa36de615b3a6ce3ce1fe8ee02a2eaba91c23696a80f43c362ed5e91e3786b8c29e9d9348bd54211632eab3594f771d5df8545496f789473903030b284f0d32d3790257551cc1fe1d907630b5297ce6a770d8b325ad987950b1b769d111bb76741b68335e00d036cafaf57a6fe9efbc53963c7a39fc217df170f31bb3b4240f86b8bc0942d3a18e0709d1d8df6352547aca44b767993e8f6e0a005d7c753d2ca188cd26ad93b1d95aa340b3cc055ee5e65e1fd252be97e132e866552b1518a6544a37873e24b3963462de171279ab06068f0c97bc2f2e1cf8eac7ef7295640e942457370272079bb111acf7ca812e0990270885c09f0fbc74325088f22c249fa192a39660cf133ac1a84d24f5f6924f402bf3c3a1ba52f5d983cdcbd9b115d3b7601da7c82e43b18d7657dee351937e3fc5b35ca3732b18752ee6578a3551bf330bcb8c903f1bb771f13129e8b11ac9f1e745e2d3e0a4b1a9821121801918ab6c36037eccf828d8ce33d99b0d893458dd1fa249bcb150a87ec8c51025e217aeaae24d803692b0343df992864721d5926e2672d37104fdb33ba696fece175e61dcb7c850a4fd12736e414e0a1ea4bba7f13c2634d1b001baaab6a0a9f78eb3d5250e05624f569b79506b51620ce594b785e5585236ada737f365398abd665e4a8c4a2e84c08311b4a987560b37149a90235c8f4845da2b11c089a6c43d3730432b9cbc1657a25e17d098afa6c45749e89e9d39bfaa9beb1faaba46211779483e1cd428ac769f62c65fbadbdc3cdb67cf657231106e905cca5fe9f04f77d98abd6684484f0bc13f1f21fb3483ec96cd5938fb1fe73aaabdcbef0e13120299eb3826e19ddb1ec2f42775cbfaeb48da787b339771ff025e5f4961914ad5bfe2aae0550460105a6eb5f08f0eb0c58281de3a2fea4043675c2be2f3c9418e1f39dd5248978d55b9c4e73fff982f7a9730aac2a2f223c03ee9f99a714a48a22dd29bf3e0c6159eaaba2045c80411a6aab7ab133fb68bcdc259557b5efc3528e7f2053a7442166e55e047078396d3885d8d9f7d8709800ffb937fe71594c6d70242ac8f67f31db5cd322ab1e14f893742bc241cbdf89018185821a09b01ff1e1519646df783acd8432399983b8635c64558040e0d025a8c86dc3ecdb084aca00e1a71e8c6b506cdc6db62c8ff64b9317172c8cc036911c48dafb190e7407df176accce7f3d6888aa9e729636963be3a5123748edc28e20283ca6f36dd292fc8c8840be6ca16b4aed7cced92d7cbff11d0047661685282e7abaf6dee09a57916501b378a5ac4b492168f6b7b54170ec35b20d5f70e602ef4ee7577d73d0d7e60b485cae717ccc01dcab0d10802dac86756cf76c243164702830f5cb7d2d6847db97e2a7f34a4b975ce09dfc07be5c9da74966c1d7d8007706e5db12165ed336a5ec2753ab9a10f43bac5bfa679f31aa217713b71fba82dc9dc7529675fb28fe2a4080043f5faf9bfa6359cf1f505e05daa655f63512c9c24eca54ae42982514d64333af9d5f2b2a954124bc302c954616db444ee870a0d6a62e117197978667b6be55dde427768333ef2a0e0469622d4e39e766e399e6a96c626f31e1cc9d1188417cdf257ca1d9e9761c0e8b24286c64fd731a48eb331ccc86a63ef0073a4f47492d6c069cb5546a1d1d537b60e14f266c14138188fa5602453adb6644a843e36fbd5a278c863b5cf78a627c6ce1238ea7591989f2c8b64babf86f24824e7efe12a3b7b7287339668d259130b64cd5109bf483f54012fe28a9469bea0f8135b4bdb50e6ca48310bed86d411fd3fb404b2a9afd45a6b70e0457fbbe13d354aaae366524df9c3135328ddac204a95c3b7e7e7971d4fd16c6b93a28092048689e714007a2c06800d7e7f166fa24a88c9f07b958b23e76935d36ca16721c53df3129da27fefd5292912ae3f7c060ef55cb7131ded4fb79fffb148222ee3a0348b25ae29198477b760818963ee44bc79b3607b669210e9d34bdc4c2d1bd5248ddf086a99084dd395807df574ac522bcb04950632497bc67ca3e6d0a05fc59f0866da6ae20c16c00b9be9a57aec548b4f3ec25ef37c6ec22fce2c008f0534fb2e5c2015188e50f7d4bb52214f1e0f1162a954229e3f85c11d8351919b3a4028b577ed0a9ac9d673726415096c6db70d6eb71e889d33353c18d1de63e9dcd855891a4b36987704b057f2b6f20148f1ccbd422d839583c5dffb7ad84f64a6976341f83b35a3f2add160aac319b8d0640a16a7f7fa61c4b324a7acce21fbc0b76fae6ce5e3bd0ec25f65328e30dba7e44544a4f70c80e0115c63397846d88456752d19192b99efc645b2887337bc0a1fe7b217cc8ff5dc73ea7a824e1b2f9ffd053c16606ede01f1485a5be409200016801e8861ea6e29c84dc29f6481c72b1ccbbd35dfad47de984833a46af9c624511ab8ec7f4b9d6421edbadc54c2f2a1fd0f10e782ad05f857695c30baa94d09ab106463d348aefa34d69d332783ef75e18e65b02f610d589551f6b5c86502bf8e916cdabaf87914120999457540b06e035bfad8010a26e61bf444af451b3cb30c6e579f75fcdec1b9c353211972ac959b6b1a0d788bb616bccec17da8f1cc61c0ded6cd05e3a24e148fb5a5f1050c6873305952a20da0cb8bf18fff27183644b6bc6c75ec467f6a3de6b7fdb4de37af70c33d3ddb36bc68813fe0f73339cb4f438d5653d99a594272a6cd6b821ba250d35940797da1ebb304a2c100190e2d2cf050de0102190a151ea882f4f195055def1827d3c948bbf7cca5e074d810d7da53ddde81cc33fe5b687becd155ee9251509ab62b59891d39ff75d2f543252a18c79f197673dedc79fa9686ab6bda32c331c56bfd86fdf85a13c8c9dda8889e5cbab50d3dc0361bf1adbba80a75d9bf8512a918a2d8028286eb962f461b5ef48694157dccc5ae7b57f4f09fb7a2b63885f850ffdc6a92db542543fc701013d41c515bbc5c0850b120d524b9b594ca8aac4172b2a218d963e86761c804076983921e5ca2c6f0590909bdfadb3208da8816bc9fd756c637c2c052bd5a00479be782c13ce12fa854adbb32edfeb677d7b0b491811e9257515d251f071e5d5b843972496400768ea36bd436dcd91c665340dccf6757c9007f205a4415d745f6099d4df7fedd68bb8973e7d27c11240d2f80918124fba166f8bd84228f53dcd3397920f923880bd64849ee8ca6a4fb988a4597ffb050631c375056ce2e2a65dcf86aad3e96a9bcf4823a50e212abec1efba6373ec850bf706507d1143a14aff07e2b05f7b165600e3a80ce235a14fb943bf5e7d4752603d22fa0c5b595036d8310991ef5b7159c967d0762c606362712caeadbfbef7d40a6b04e61b0cc7093369f1bc82265e4696ceb7c96df6fc7677c7cafff69aa55735c5bb602d2ab700cee58a24f518eb64c6bc81168eb1b5972eaaa12c3ae5ef8406b4f978493ffcf3bb3b6d2ac4450757a9d5e3ab85c99840627fd567e348d53d995b8f04459a5437200e0eae96386b5760c807efa1eae21170548125b513ffb9c21ae8b59fcf0fd82073ed7101527bd7e57dc7d28992d4b0189a1c97e22be0d9822011ca866673cb80d657e3738b5d2e448e476f5d1518c2775294284ec07f953c9bbe24052b36149907fd09bd776d73e4ce1ea70aadad5f4e124cc4a0913346474d7316a3fa67905d38c5c93f100e4ab1e07f06980119bb898435949762b6bc8829f2709fb89a6da51cc9c7dd831506efe40e80575fbc39c5cb45fa88b6453a0a1e91c607f9e05e3de976a8cd7ab14cb4d6da6ee0db84216747e106550d397df206731c36b094097ddf7931b8481ffb2422d2f7b836c0b1673c2ab9245276b41e48b474af8518708d67cf5e1c85725f9341d6c07c1673b8cbb8f7ba4b25a9f736431fcd9e5fa77aedfed91d28ec37fcb97e8fd4021d23f7cf3bf384e00fbc00b4f59ad8619d69d81826d2c2251b7639232a2dedf54abe09d61e5d4c34d5e5ccd4a53ed7d36ae55bb235ab26db80a70f3458a5abd43dc8aff6cedc2f23065b2aa2ef0e408ad3c20b04990d26f106ca768a1bf4cae782516b3502f05a82562ad5a98e742babc4c4bc772fa32422383464978f9caabfc0f24073e5053845abf4f38270a5f509a8ec3cf1461312eab08054669f9ae0a478bd21d20e6d197b460af886ae038dd3c61ffd76ff4a918fd11e6d2d141fbb093da9dacafedfb59de8ba6a2fb8e9904e0ee232e9acede834f7eed5f247bc777aa43dae75aba21a8169df62b699f36574724fb203085b7b137d10531075d5443de11550bc144912e4fa100f20197df80de4ec72c6270834c97d5b7d50300ad40538a96a8c7e1eb1a743d3a456bffd6eda62dc4eea99512fcc91ba841ead3307c8e14760d786e36a435f76db5e478e8eb0db75565c383e6f20dee84b387dee809a948c599e380a9ad9aef9fb76dac9e28645e22709002b5827488c09056bb3209a02efaebf6c0afec3e5e68c2c69d5a6cc173f204599fe2ea0cfc4ba7d2ba6c57fc514794043f2b9e3069bb8599ebccb2a721f6e4c9a1a32da07a05cd99e03172a62de9ee00d30d5b82c2fece1aa7152e61121e69b7cc2c5ef6783d2acd46b3b0cd26e12cb3ccc0b1dfd9107c951e5a6d11770c921d31eca61ac8d13f27adf0441f96af5a39e4b309f0d410832681dce494d33781ae5eca47930ccb633284fe78e27e6e0c6de86ef6c31cb4d84231fe982b79dcda0c83196da9ee81cd3a09ea34d6a9108b6569c8cd218e0911f53147a68b6a88685ad4331e94a24677d64fcf6b5d20a0879065f6f315715fbfa4fbab1f1fea7b6a3b7ce62e2828cb588c7bd8f7d4fe23f21fc96f8c5d8291cd4edf29caa3f49b46962db238667242a5f4892a8ea7304ed53307ebbace8382d4004bb2858a16cb1e4b9781b4d1c75dc52476a99bdfb23e18fcd026bebe279b3070c4ed4b6ea877cf754be5d14db0e0ec901d288ff3419168aac3a17ca42d2fa69e7f15832ac5fd10b7918591a8d2cde2c46bec6915561b88f7c0d4e98dce9bc386c5cdcc8176f4269a6f3ad1b615a4f55834e85bee4acd0220e6c64e4a2eefc65ace8372efd1b1841a5f5af3a6d1af6977b2aae471aff5ee5c52df272d297ac9df1972f4a26e13e4d12c2ab42481baad50b4b7d3488f4559244ed5f2ed189706f2ee01794cacaf48277567caa9f914739cf96e0842c921f8c1d0de9b1803b2a5aae6e0fd2fa521339f450fd025ff0f36de1d993c849c04c9e8cca0ab238f706e6b7ab5bc55a5b2d4e6617bd2fc6901c6cf8b49180030fb8a55d25ffddcf5f25c30f8ab71c00bf34674782e57b2f9865884afd845112b8dab28a06674b229784c66761fd1d1a694db17af58e102e257fb694547f4bc8e217be6bb9e443d6287c36a7a08139945381a564738d2dbdcb921ab3d261ae327dad0382adfc1bcba0ec4719b219c604c398c214f6a9f0651429fa9745c0f9a6940adab44acadc07a2a7f46a6d15ec03dc5e498b604bb08fa00a2195c17de420fb05b6e338690ae15909aa624fab4c6adabedea422dadb6065a29e3225e0f1bbd42660ce5530884ee0d14b897747297b426a8e7a294996b122bb8de5c2ddc943dd20de30705a8cef7b63bf507b41bc9e8be20dbeb98e6b1e880ff45c0babbc07aa2d95a2959654449f901ebe421f5e2d7778a018d5e449967af660fad64a283f12b84a7bf2d0d9ff1af35cbd529cca723d9407cd03552ba14ab0962738229d6a0886ebb86a0c1878caab32b95ac30c6ff198c932d96e0f24d69ad5a49582267464084d2e3dd1b31006f05f4f273d109eeb4c1d8d4bdfd29cb394cf3781ce26c2a384ef6b170fd8cfd002f015815e7cc8ca1fd0d8b893164d17509409b9570b8a177622028a0de60a144f8242754f168e600e22b8cb416a962a71ce9377e3dee1b726866f3d6f84f180a0989ee25947fd33a67eeee10b62e85c1f2377caf8a016e353edfb78a8ad20d4e528197d0668402061659b860f147b56eeff6c971787ccbe953b6f2f9d9bfc7aa78280647cc289b1c81fef8f934d2a500765b1f8de63140234631ae3c812b7a442c531eb5c85c86051a5301c12fed0ce966fac3152e848e06dc44e5d6a7828ebe6947b050e32b423aa73ed7bdc6cf9975320d10089a9a630eab2ca945a78a85d7e0130ed80eee08de209bdc4848ee47ae17f736765039f2e9b5f7abc200ae57f576370e215bd2df40abad91e9b531140c6b53f166980ed3ea33cbb8cbbdd20b42586b04a37af13cbdb8d14bf43ea8180f75f355c20b19990ba20ab94b18f97fa8f09da84d90320b67bb8ac6e3b5dcbe32a2f704252c52de7fcdb81fe329829a82baf2e4cdf813b06c6022a1fb698c747fe014f729a3fbd9e43d24d449adc9c218d7835f76fb68996114c878ecef8010ee78b3aae4ef5b6a1ea5b116438204986f69dc85729ed017220bf73f0836c09277a7a83e712fdefe84d5eaee5d51e904907061bb3be908fe20be3b2bb57f91cf5265a1b65262b12effe5be40e0d4de23f1f5f20a912f44d1c7d52da792cd0b74b31ab45c5ff3fd436a0da28e0faccbc0f5bc49545d053ed14c9e84b8a18f1e15a9e36bcac7dcd38cc05a3a9a5ef06b3e9f2d344401c7dabd764cbf734744d47dc8256443ca0f397159038e05b30302d63174136d3f016a096c5a1cdfea6d63d6114cf4244f17ac3115cffddaf7479c88a50cd44bcce8b398d8f7d5dc3234d2a561e807502933367589b1d687ca36a871415c13fe103e1257da3ed739e82b1af98e68aac2d1be610afde0f33cd1521c8d6769bb23a3600aaccc3f6412a9af99ddda0c0c92a382a585890e1a4dffa42b9d17470ba44a1b16ee08f73a455339d6f431930d2032cecf35f22ab818d33a05384ff472f453476b7a2b20883fb08a6fa61af13190a1e152b4d41a4339cc357bbae99c322a353b0880afd613fc82caec46b7142e8b4fc64a0133e2c799235a4ff4f42b55ebc659dc8dee6e53364cb28a2306a0640894b5ae3f04ccada7cef1127efe317832754be125266304aaa23d27a961482bfda09bf442c890276428e522c6431560fea444c084e44233b5ad19a162fa8ebd8529e341871184a2692acd7c0b559fa0eb43412718e67bb16d1ed6489e56dfef87474c88624e599d4403239c55cfaf97db785acee46745fd958a7a2da7d0469a2fac3d130cb881613874eb2ced71805ca1c4eb14e799533940b3848942ebc04a0b2b444b0c7f53d9cca0a16040857a08afe3b9acf209cb807bf0f827a4869e110aac5a655cfdcaf6c2c3ef1dd3b74173eaedd1d6b9d009cccbe5a505b7a00b58bb326dd8454efd4bfdabf92ad48615ee3cfe417292118963ce2c2e3069eedbd739ea6e3410f0a8e8aaeb2d4c8fc8766fbc83db15d62f9baef34cd9a00aafce1f68aee7ccd321737b51a6fa97a95a8f4106f80d50d512713ab5d7ff085cff65120ad730a9652f6eeaa3f2c05bd65438c8dd621c959784a2d4d022b4ff0294a470bf015a7ce5eefc3429b5e347c305045b556fef79d7c6f20ace19a8a7ae8207504bcd3a498f8f1f91993f16172803b9713f1fdd365258e610e70258874cf16bef3b8933901ad5c91c35bdf76e433e93924ee74d18dab8b70fb4da28c577a38e1728019e7d2405d4a276493337f3347262903c222524ef758782e25c1b2403b873666613b0b0651edbe2ea6d6cee3db29b7c87470f10847fbde02263ed5a1bc8bc23a22548e9b3792b5e6a1356a415e2ebcedda3f3d49f82cfe42c4b3e0e082c02085602bfc7eac7289568df94b71885c7cf870f063c11cf53a042b5132c659a7d30ac0a8df17c8ecf6f3bc4b840913dd13755c8767e3cfb534f5b29523fe946e49746ca4d318893762a2143126953fcf2db1b5de424b8abbf1b7e13dcd33fb2f7572b35b1483acef36fee62f2ef5b140b073f923a1876596bebb731a33f5c17dc883e0b8d33630d3d04c31b4f88ae94a162c7d1ee466df9e1afb0c2761c178072cd749658949a32e6dfd04b670e3c92a0b57909076773986849930d4020099983f0a783a2d8deed81e197a38e44c2399bda4b0355699fd6e0d05ba94b38efaea7e94519dff0c2ceb74a6d63de2ce8a92d4fb67b82603b62ec39520068888cbe4f4c9a9b04059eb43749e12542cc4493c552edb842d3faebf04b175f94a97ec5ba957067bd19f4ff4b41bb17828527f4d34cea68697770be8498ba6ebf54b092069bd3781777005fb6b7c24ef7e9c94d67d63467bdfd986cc6e5482e85b295a51f480b90042bacdac4dbee8cb6ffbfb7e225f424befbf3753afb73408176b60826118fa6c880de6a96b64e635f02b31aaa0cd6e9906482e316dad83f81628a1c224a2a982448ca19c06c387ac051f87b0aa4d148e3269b1e07da18fa1eac42cd9a8e6fa2583776eb2b79d2a530aafd65d5d428ba55ed94b771eff77e725618e648f32c7f19305df8abe462266a3e4b40c69ba44144dd3c87409ac26aa91cb87e0f1a0183665db2ccd4062f6d1f03a138390ebae35e596e241824f6d7e1a0d4ee46e6bb6ab5c1c824c7bb62ebba22942cfdcf102a8d62e847abea85dc3fa37678f2db70f495a780fa1b5efe5c76e09d8bc44e840237ca6d4700c30b4cb978f6715b6217f94586a73a06deda175fd427d8391b6850d1f5243d43cb336ced2afedb88ab07690261da16d14f57eb9e77129829a3bad40b011be1733f107d31e42bf6f10e562204f5aa337dba43e01bdbfb48154296943c17ce5388e6f0a08016bf6e3a0277e7b29b2d4b9bdb26eee32dd9c1529a9770199aff2ae332","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
