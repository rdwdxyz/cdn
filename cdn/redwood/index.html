<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"796246a84364494f978e33ed91502167738bf87be057ab9139148115e22c9d63dccdf100668fbe2f201e08392a84bcb67ba6f2bea27766b760638548ba6b4ab510be286cf3e26c7418c9f059952a76d20bdea75e56fce292149a45dd35d32580ba08c9b96e7cae01d704bbdd3a76f49d8fc3bdf57687c32be9c94fefc8f813b022e3fdc7cb2964f70fcf4665d8e4b15fd4c1eb5eff0148c032cdf2d221ecf95206c2a9313b87c69fb16400ebafd659b2b99bf1655ab5e953f20d1ae71e7d506ab333b0307c3a9a9f8384a3269e334a7b8a114238e0f00fefd3095203512a781f8420c079be89db0055df036cc5e8930f5e84e5ab27cc5f7cbe89878b6f7e695063cc42338bf1aceb9eb510af85c67ea66ace9a0884edb14cc3e8096568fa01b09970865a8bc88ea94945b3372b7c4c31b8791e5f804afd98c86435296a7dc73ea04a4286fb5305e88cea29c2a2f44df4d6c5fc6e4fec1d67c2c071cf6f658b8c6d230054dc67c2aa65359e2682906f9aa0b5c594dabf5582c3525b762ef63343b5bf8506103f164150561addd9bf44f30371b671142a63647f3382f1ec9b24b70c04c7316c8ffeaf2cf35c45e895c6dfec8f2ad117fdb4a2205b8a4d37a4d27d89f39352de5a3d159615e18f8f5f86961fa56f63b6741fa3192f102f42788adf5465cfd6dc965435fd328619464cad492e467bd4bb56bd00733cd9f48e93d30b731b35acca6c83a85405649befd7ff6c606c3801ff4e5ff1ddde68f9d0e5264addaf7404e606e92117b3b3ab2a889115cf00103383d1d638f91301e15b0454001896cb9563c56f8a12d6c695f1e7be3b1820fe19da6e07a2f7e8589ca48b8d6a55d4bca6995990a999375e06366579fff69a311092e1398e8e87758ff264f68399779126744827c79dc0d03cf71c15b83acbad323b70c84f2b429d0d32056861568ba61435327ca13f5aaec936d62c9796cda63844b08503d7ce4a898b2c0683401040445fe2d8d5f1f45665fd05e6a0ada53593af2f0325950e2394f0f3e2b791b62856a2ce903ba7eed1b2a3b9eb015f5cf2a0b9701c55ef9b316102231c08e4e9a923710c73edea2d8db93a89ae318a0a58587f17b99519f91305f9cb38033e6539ed8beb62000b5e2e162e2b1bfeba47452dcba12106d1ce809a09489b9a184d94a4294306590bbec4f745bfa5b92bb19747858ee45cbf6f2e7b0c388075f139ddbb96e3ffa141aa1bf4e74b9a2aeee628cae541b551c53d58c5667f953803bc035a1999cf304f54375bb04e7a6d6a3ac5494f0a63cecfdae878c1ba077818d4a0d9d820c39547667daeb14defe475ed0284550aaf3089efd56de742e02212edcb29030cafb6b78bc4f86b65cfab7cc697547b6b4a0b5af72455404c0a95c51383543b2525f3e64037bd61672e2f95ceb1bb0699c27323c6286585f7afa5ba27d4233fe1e79dddf9e77389f3c1bf8133b59acdb7ccbabaa4f3636ea78d790126311a7d0ce7db015f5a96c7ec2726d8b841823029a35a65bb0deec1537a7fe6beed24c6b2a8d47ed743814a3d8b8b8bcede2bb1b7a018b80725c826d5a530c0c7cc90cd27cbf25aece32ead833ff9b510642bf90003505b8da800af05dee2c2099aa003085f7e57b9bb5602efd8ca7946cdde3eefaa36e7e4a02bb1a4e617a28af53429d779556ebe6cb2819bb4b130febd728063012e937cbdabdefa8fb3a5918887100449a35f866d63423bfc59d304444e723a16df06770dc97df64b3b022eee7b3566d6ebd3d6a8a2be3454b7b554bc0053e0a46be4ea084d388eb799324c22ba811da16cd0dbb87cc81fc1751396510e5faa8b44ad2688412ef86b3cef33736aebc9707d2f424eb7ff7674d6f86aa49a11d041497e63831871550bc139a4c4bb6e53d98b62e09802c118f472d5324cf8b4fd4fb0eb671c57540fad395001e09215841875332b5c39f66e4700e7a4cffe8efef4107fdfc5d3dc1b479e30b50217ba7ca478410ed5a4b224131abd5942f2108e7b607c1750ae0ac2b08a343930c130a6b09187fd076560cf2d9d1c56b693fe19667028b2f137485b4d713664b30fe37c606e8486756c84550df8bb37459b001c5069845bdb71a7442308e1791e83df96e155ddeddcaceea1b4bccfbd0ea3c97ef461665af172018be009bab728b610d6c23f70638557e92dfa0ed64b44bb658f49bb1f4bc320ca66ee302bea92c62088b2fca637a43dbf2e5a5e9b5fe4f8760b594c564fcea2f1136bb30b11dd55c0cdf4a13d89dedfff901a7b32de2ce0667117f16db485a344114972a225f0c166d7b99b8055017412e53663a0755884f05b8f657d87d3e1105676a082cd3733c0360c830138473cc8c4291cba1444443bac9a8732cb791fb272e489c5f258677c3384238c76446db87a56110d5314f77c9fe578aa67fab568316a3d46bf674bcdc6fdd967808fffad36ac21e810583485dda164babbc74a7a4671b5e563a369cfef2edafcea0ff63db5deac4ac462d2e3b818689928ff38560acc29750a97fb48d8c931c2191c67ae01b04844e3eeb6460fe88045d02dc79d308e2e7cc81dcb415f8c9e91853d09aec9abf1f2934de866f475c90c5229d01510ffd956ec0a3d13196b8fc3ab9639b4ba287064bfbc155a9f1c221bab0ee87a75a0ba798b215bf44552155356495047efb8b4f32f167f0de46d6c6d741a545662e5ca24fc252ea4cc09e0e7ded021f87847fa21fc0b72d01f0c744175a6d5137f65575cef9857bc7b56766c0d2342636e155fa5886884be184bbc1c3990e5a69f21be25a05f82b3dedfa4cc223e17865e5ece4d309caf5ca3810fbc5daf0e56fc9fec9583b772ff369bbfd466d6ef9646103c9b13620efd076431e7fbee9ad6554000679aef30e7313d562660c7fdffafbf2ec3a6e8438e6a16a05bbddf34aa2ac88cc5bc0407e8639a6799e5bd9e8dd4ba88dc5fb1ca06e902e14940bce19654f7399810582ee8d6293e7b6e5c34a2717f4bb33f97b1c1ab478f0d2fda8bd25fb5f637e0705e987bf8a6f0d84bd0687ba29d4326a2c39cbfab2ee3622ba4ea5657928abbd0159e2435583ce9eeaa661a52058b6ccf743c798d77af523b99cfb347dd89751d0c0ddb320a9e70449e2ce1d0a157665b6ed7bb6ad7bdfc17614eb07622e139065a723bddc3c1bd15f9fa76149fd8fca3af597d52cdb86a6e89cf879815711a27fb19cf726e8ca3c168cb0a80b88f35f299714483240af8c00748450e89c7882950711c7ba37dc302cc7dbe0fbf91aaabec5897b4a8a295611223930a45e00de1fdda16e81656fec697bc6dac6d6d4bd662addd82eef734b042481125486de42579a46a898124c6e971d0e4bdebb027b11d77e98ac34d61a6b2360c8e4c36c6bc64a96f8970cee8fa87fd9b3743b2d92ca2d47a7df3bb29d046a7335a3aaaaeb276cd0510bfb642006cb6362ac9f0c8dfdd19ce7ee0be88a72fd0fc058ede91124b9fd43aa02ce4ab03099a01c1dff3650ee9b675cd874c30fb9d2a64b90986a93b2163efa6834151145a0ed38ef5b7d720d7cfee3abd73aec5e205fa8bb8dd0e97b12b7c6e47f6cc6c7d39378c5f34aec92c1cfb55c8ddecc496fd9b130e41ececc4d03cf23798fbf0a32e96db81afa5b7b5800e3343eaa96ab5f944942cd144e67d0623946091cc1a95d966a2f0ce5e6fa8d94fe7d3c030d6f73da048cde9661fbc48cbcf47cb3cbc93e538c78314c82ec59ccf79417107fc5f4da1c15cf914bee63070e5205462844d2167ab067dfa961209289b2ea6bac6cf6b64f08345875100dabece9905e466bae5c3e1778cef2c218dabb05b2fc58b274baed5ff3c42d4dcc59d6408c3b77677e8c04b6cf27422f163f3ca4246f6ecac53709b98d19d433e05404aafe22653524393190c58b9802bcfe1d47be70765362bdcc0522974903dd7a282bcfd2ea10eaa51bbe894926ce74799993561eff06eb975caa951207f0527efa1872df665ac336c41475a7946977dec54be7141a3c2b763eb2d0e92df47bbccdf6aa6469f8f6c9283208e976a20152fa77728616066a46c8a93c8c88f66e0b0e7c4f854ec4a56703a13c603ef75591702bba0584a01bcf7efd4efbada2a2951a835204aaa5a275a5ee343409e659bc144ead70cd340660313022f6c8d64d136b0d36f81035c2b77edc36cd8536a15a26e424ba05481c72f0553e7ad699a530e48d82337fb6cb9d32725e5ef8340bdacd106a196b39201faf524ae7df74e585c7ae758f7e6fb902109cfa792a444242998694aafa9d08d7f63ce0c32994af9b287c6d4329346097771ec23f18f128038bd5efead1bcf9894c0fec6244d2c4c7699ddf4a4b7233e9793aee0f47dba0e1fcc4d4fa36ee7df15c2197d464f0462fbabcc4f9bc5a7231cf0c1abfa8540bbb06f16a7573d0f413762cd1098bc2ed82adcdc93ba4e1aefed19640a77ae1deaf0388a44e243504491af6a020ae98bd51fbfd8eb75a12b491cc47969f15ca48912af742df2b54e07e462d1053628516ecf913c346de19963d06e41eeea375223658b0f2b7ef4730ed570798063db5e1faa870328f87b6a76cd633f9a6d1f3c3a351fa57145a531469bd2535869865d9df23a5a693efe2050951fcca482d941c4af0a9023b1dd31fa520baa6c19cc8545f6b9a7db0b7d6bfebdae05c2388f1669e4d7784bf19d28dd5155861cf9d858837ef1e69fc91b08a713b203887625f729ff045cc2d462d0aa0fb18bb90941abc125a13b93d16b1a0d5c9e21614635e940537cc3b100918e7b696f0fee405a63ce02173233fb8ff25048c43943ba84420c60ec08e7c2e6509ed82118e382a9a3d44a8850aed9957381581c8ebaa8550138ade5ffc3fbba28295cfb9596a400e49b2f1f12c25c161ed23386721b78ca2f32041f05d7f01e733cd5593ab9f7de92993fd029be73b9ad82eec8b681861ffeb6a2c2f496d915a3ba6ca1074d8b7b4921eb4c6da53a29c4767e7a5dda73e9c72452384fbf6b5d278036c33313b7e512e9ebcba932adcc05ff4433048fd34bccf8adf5dc012dfb1e7ae7d8a13ab17cce18daae87e5dce37aeb8e01612a2ff2a639a8a146db6333a7853fa46b153f9b1ee6d6bd7295a51720372922071c738ea049dcf7ce9474576143dbe851ed0daa6865860ab9d5e184bd66618bce59a6d6f69171bf0f555cfece9c44cc189e191e1648da919599a9481296dc718e0e6a3ecadfb66edc40517fb08a22679cc2e6366f490b0499970559a26e512526788f6e86ba5c0c5fdaf2a06332c2c06d79c34ca3452ddaf667670f01bab7e81371f7696cfaff874001d90db775f85956e5015a3a9617efa3a3056a987e569e1527c04b9a348c01b319eaf59f938c852aa23eeb5d9a23ea5fe0ecd4b5b1d75150c0b5c98cf4ef390a4284b3bea87fb22cdce5c42c23ab7792405602e389a0a6a7fa3106aa4608b4affdb238a279514fb6ba59b1af26cf38ca09343b658cebb5aa6ab0f594ee6f33fe4a157b440ad792ec5d114c132b4851f38e321cd07b8932dcf6fdadee91880a636b28b76158e85563c902212ef8bb422f5563b9f2d0d269f4620b2c617edbcceaed2a9c5e0f2dee8ea7a7dfe78007bd941c97479dacce30cc279c57f52ebe88ab03a7698fc2668d2817e94eaa18694c9cadb9fd80cfd8334de44af8a225a319c8a864f5971542801e5815ce311301e630dcfd7b661cfb86bfb8d55557af1be6a9636c8fd058bf3b5cf0320422655826d8b545691e5022043715c1690f2de94acf6997966327fe1d06ae79398d7bfc817cfc337b539f0d9ab9e951d7f5440df75fc6bb4b193362ced14b10c830e1dd1e2eb9f136b96e8ba9d5c3fe44b2190e1d92f8874f709387bef777bb6bf0f8b9ffe92d2b0078b5e2c1a69132e0c7154c4738273116cc838a237b3efbdfdea2def67ec53c4d85624081fd8d51fb875ceafa706a5f68b7e6e7c23ebc91643fe9c12385db0f6f141a6d138cfea725518f0ca80d07c36c38ed361ff232535b121aa1de41b9ca32984d795685b4e633b8fe10d0c1c9c6e6dbb0ed691e28bbb1022b8258a20d4881a029a3a08b433d941c63749f0e732a7c8955b6557b97f0b956d1ed75361d3d475fec02d8904d95ea8630344c8939b7bbab24912003644561ef2e68397b2e0dd901ba3cf98c5929ab5f52b6606f2399193ab49f60af87cb3f034e8fcfbea6a20b62d6c0216ae6dbffe9ce2b19b4eda8910cded257b7c85e70506577892d46ef39245dfa4b569ce8ba94685f6dd5512928c8e3322dc4796009aeeaf369ee32d9f8381209ad6d00567d5c07abdc4d57f6942096d76fc2bcd35dad267cac150cdda7f80006a7a2f10b7ed47236af9dd835a3c7737654c221e94847ec69c9a15ebe50d395483cd74575d2e3cc3cd4d2542c0083e128bded82a52b15f49418f3a2ed024607622b175825b859e2143268df8d77ceeaf745883c440b08aa9fd2f7e977f3476f80605b309486f5f1b6ccfd6a109018068012887c1fc447c5beb977c0f2429da87be2cd2e90a9fce01644553f64fc1a559024684caf35581cf72fd0cec5f6008762e8abf18d4dd0fd997e190fbb58ad3ce61d1b596bb7cd790b062655822ac78a807567997461626839595dc0dcb76bd8ea0a146062c278b051bf8cc38b5487982e436e6cdaf1264da2ea3f4cb61b7018578111bbfc52a2de73d8be2629edb52a57b8f35435cca062ecbd28e0830ea033985da8ac742e4596ae948c64a83f5f3e646dd92e574faf057aefcd67983034753d1dc087cc9896323c5c3216a65be8e1224e643ebcf90809a97c8789ec5babbbc5e30d22e6f615a2dd6fd52d285de4c96ff7b8bf750672d2bd4b69cae1dbd0420cd67c35a35bdcbb2eaf2b8323ad659644730df3d5a5353a6be7b6343fb7ec7423dfd34f92ce037c5dd3463b20882a6b2afa276d7ca1513156d3413ea5ecf628691fc003f82c26134e7a59e441b16235fb0f002bdbdf8971d3931deb0e9e85d5a1de364141456b1b4984cf388a98588bda9c4e7be428055b5f31f01b1c9ecb739ab97e99477b36a96f66abda5e3075db70eb530e9fe240b98a322a78045345c5ee4e421719fc993fbe34a21393f4bd236c1639f09f5554da2d03ec9b77d2d42e525f5daa063380b0aa6ec7d9c0ef8966a74679e98ea80889ab8e7fbbd624bcc6fcffd0a70ee74318884d34e41765c2971bdbd240a6c1bed1e0925ae1615fff237c312d619c1c295d20c94d51721679e6f87bd8a787bab5742dc4ee9be24bef77bd65b693747907d46764cc41cd0e85f2e4cc8b25cc4cda8b60fbb8fabb194ee8e3823da279a5040f084b92689d867126f46c6100356dffc1f3d75575cff4045d20bca93c84e31b23e4d46a2207044c7e412e0d87710ab7f88d889976cb6ee0d902c8e76900518f85d1b7918987d4a618ec161a95a1997352337673c474993e72f85a5bf0ef2b22dac9ff6a37f821128b5e025e1033a6562fcf74d5774895b5c9360279afe3907537fbc431ae5d24f9d003f3625531752c3f40aea569dcd534f30ec016bdade10034dd9ba0bfd4a1943eb3fd578fe44cc9537c4ff9327f6176c1b24355100e9c35ba3de5b4afc8e9942f5a12736ce61ed9a1a420271d07cd2d2b7c6d432879a15ab10498a1ebaea928e9e21e568f66fe088f775578e9cc09716b6a5d417f29883d3b5a9a509842164e08b017d91135e66cc38a22583eacf614b47e92bc5029d742d36f0662888299d3f32dc97bb7d3c3292d288cd729aeadcff0d3a923bee9ac586f29f9bf82b7410d3146dcd7854349ab42edae5a3af201c2784693ab04cd94843743dfa5dc34d2e61d1a954c4595bb75c0f76450fdab8ad3b8f2a0890d2c64b09faff42371c3df78070c24a7cd1724a7a766c84eb629eeeaff41a695a6c0d5da8064bd2f0b178407a8938a5b09d785ce30d174ca718263dc3e1709c0220131eedf84ab018f60d0fe9955016ba3451cfeae26b5bb101c55da1e15c19524b4019af8488584146a7fd07322582a000429509b7aecc04835b04e8394b0f52d32155e6b5b487c03e92ae13a8f5207bffcd4bc60a806d2f5080b0c482770def21bb8cda85bc9ef96bdc3dd58e64277bb592432024355eb32a66990f8dfa5366f285666e5481aa4bbab5f941fa1e6fdb488dbfc97fed617e45a0c849c22faf15b14c25a118fdf9ba5c1c93b45eddaf758537a6743d786be821a52309f2db50e30d5b5d604ab4f6fa712391d091c074e8b987394302dc346ea321f0bcdfd20630a22a56291c0b3e036a1976d95e54534d6d514b805a5b684145de6eb65d0e5a7b3e7e4df1aee2fabae344da6b19f60b0907159bb2e84df18911d192d2bb724eacb76e0d1af7a24c1c7d80d40e39abd7e45dcb578c7435d03dd2667e2452dcfc6370a3cf9d478b426eb79938136cc3b164cc83dae3c042a7b51c365979777fd703c107053605318d40b52a5754fbcb09ee623f17afdde5ab47c20cb9aec57c3e911dcfc5ae9f843efb1fa97b6d5942827fac477639b0ee3927f14f8933278f1d56d0fee1365f17f4b38914493ea641d9cf64e298e0c9f7d7b5a47c35daf26c76616797d66e05e5d2b8316719fbce92179feeb3d54c04b4e325a9ef2adae42a5bfc3a25c8270e81500f56beb6046617e2acf71dc5541561059bc26547c8a9dcdd25c5c3018caa4efd9013e39c79efe11c3ecef44892afc855387565257e5816c490ca8610bea899c2bc1df9cd0df41d01e42b6de863477c37f2138e55d83abb2f76384cb3c674727f53b920edbe6d50b651f3a6993229241748366977f3e1bf4669929c73c55bc6f24ca8cde868423df63c611eea162eb19f0e43eb1244031a32e84243cd5c001de0f84a318b2b72502278007357fb278b690d2335887d13ab04203979e360ff855eecdb3cc3b8cbb6b70f3215cbf710e1d747ea8324aee4518e8c7c1dc4c1d06408c86182335cc3f711d53ce987534eb77ed27cb1fcec5df37c3f72c745d77bed5797c6489f9ff5f4e5912d4eb252f4033e7ac2f50d36ce053f2f4057b786b12f774a1b02c27253d5ff6be6f4e0ce604767905839ad160c9b604d97169f0e5cefb500e90477bc43d15b634c045f8083f5883e3d226cfb7e8e038d3159b3e5bd6d8df695bcf99ec1ecc5e2ee56a0c97dc9d854bffe0e017cd6bf4558eb3b433d6092154629c9c0bf1bbc747a0b949a3d53e9cc94bfef8f92273d63e1d31023790d4c2e9c106ddc98a8ff513b020f767fc524acc7f5007e70ef1a25928b13d4cff38114f707d830b0e9e3b31d4458f5a57e879f769f9fd57232c8c89484a15c96552202829367e8e7dc8902fa5da504ac24822d7fd0652f62db6bc8e54a9a99ccacfbdf2df5fc961ede32795c2bb559200c8a3fa146ecd340a014f1b741f6bff2fc4e791e57862acab55a6ab402bff7ee0cec0348389ec6655ab7a48edb053a2616fb9f7632e434721d9ff69ae0aff4409413546adbd4eacb19d321444978a90b22c3d8257e555b2c50b7b221bc992b1f04460e7f55aeb42e06e4977558faa35adc1052d797d2539decf8eeeef9c44efaea124a91513d1bba57a2dca909c98a23671303ddb3e05849eccde23a7fa51312b20d993f92d40f06b926e59fba643382495ae21455f12cee7e712b22b969e0f9cc9695727be1aff82142217adfcd77634231de519bbdfcae7fb3c6dfba45b87a6a334b8b62fb70694f7930b07293acf8699861849bd1cf44dc703501ad23ea267429ddfcb1698a8e336e5d1dc1209782cd726d3801e841f452ad2307e1830dfe6b748b34155ffcdc3957cfc16a2fda939d68973e9b74ebd42207b004b4c9490f9d676510b2336ac01240fc093eb71b5c55bc076839931e12628b3e9ae1332d17de25c1dd35b2d13f2ea19879405cd3e2ef9fb15c6448e412e82cfd14246ec48cc2065a5808edf9567037c3bbb4a23b33954d3988749377192cdf3c6b32430da2ec03caa85202a893bb6dada9c788cd5e390a70473e4000208d75e02b6fe16d9012bd453a0e6b982d16404c7c80041544331d929eeb8f2dd19c9074a7e2e8734c91819608fa42eb0981219cc75cf5e06f43f6949d5ffb7be8ea533716b7477c541e8670c44393b0d0924d8d71d0c37ae8356644355a79a676b1f29c361aab9134553ad82ba99b7a78027f287b243460899e7e48b3e826b73ad8c661b3836929bdf92fafd452a7777c18c76ef4e210881278862af184e4da2d4b9b3cd02924bd3ff34402fe79568c1c40bd11e1c2e1c859a7142975d50f033b9f031e1a3f01d9282309edbf7e29ad0b080e9b7d4791e8f80c46da46953ed088ef4724f50cc99ec8fbbee22b4da1f2345316ee56b059b8beeb297b6757fc5664e1ccb7a9013181d82bbc42801760594b6975bd4dd3c39536bc16acd098418e4efbfd558d67e5646ef699a1fee7859d476fc9ea11655ac0285bd8dbf261034d0c1ae0fcf02e4d44a8575969c4e1a5aef53c5bcf22712c056fcbdc383cb77aa7af82b217d98653037c372a718d86a14ff00c6780d3191858f5e31f7a9658a9bf5025930ce135be9c47b4718a6b9afaff2f623e91bd4d8ce16b1a85acb36fca071456e96ba183ad09258b42bf3ed972d9b0f3f8175c3c7f549d6313a17b42672eb9ae5a7292bb55d85d18266d1c7bb258240fdef2f076546614cbead7b895bb77e3cf28c759de85949e478c797e9a6bdce57fbed129d2a39056b1b941678052e4c5a0b8d1edb8d4814a0a374ffa8a4e8ae67adf5ec526f6bf702f5aa7a13387d263c2e3a14d972bca88e4ff2be7e87a2e802cd2a96afd35fb5b80a78054518c07d7d0be5583129e9ce241bf25bc1e1eaa64173eeb696d81269e848486ea2691252028a0a1eb8aaf9bc22a1fdb94dd79741914da2e58e7410fed40ad7fcae29fa4bd9fbe127c82d1f7f9becd49fe32a86dd87b9f718fed04f0e83f50d0a386ca544644959ae609c0c70ff31835765bc56c465738933ac9437359eeb0c43b80e304a39023e2f1c01b5094dddbac3ece10e012b0a39f3b4992399b182c3bf1d972d6266db462ecfd5f733f7ec62c1ab77e2bda145d814d5ae8aa4143d44f2044751e0ede5f870c724cc3491088e4d96be349288c078c36ffd13b1b9d43ba1f81d6d2a30b59a48619399fff515566b3a30c2447bc97c93e3d6060fb0efbbd832a80a5a862005985fb76858e7685e8350d1176df52e321674bb76d80ec45898ae9bc0fb494f06089975e35249dc3bc749dba1bace68c43358fe5852f6bea43b9e7acef8253978db83db78f485f7df50bdaeee49ba98e22b6f27d1f2af420c8b48dc672da4cf841640c89062dfad297158c7a8a840ab3ea1fb91183a72f50952b218742f49634ad3e4d5d8b48ec62f52185a0e2c7b0b7cdaa618556d414b55f69d3ad620c9e2c583da43d27573bf1adfab4cfaae6e67cf708634be440ec1b9e6126a7236e31d857a7a473c49e68f539abb179e4b956bb0484dabfde52cfe6c376170eb5e8b865d94eba36e591c509407dccab5c09f7c6ba4e4003d7b83537fcc479bf08dad05400401c94a489037aeeeadc5b474751a6ec12f707c19cd4d4dd60bdce19fca1a8a81d7e73db5988cda761d76c5ac1d327c4cf5383fa42b764fa9b6a3bafcb81ec53e3e191d9a1721ff7a235ea4f6f7f11795ad6a500b3dc3889fb61b786b7b533a6808271faa781f8d78a82a38910a98099836bbaa164dcc85eca0ed81c57bdd2773531e6be555e343f8852bd4f565fd68c51b7a61d5daedd66b285c3040b8a4a3c1d26412c30475138d49f1cf8d5eb6da2d2bf4923d466cba409125626aa9782b1ae3c10960ef3f4e2c2b58a403fbb4a946812ac2ce34bc4f97d28ece7aaa89ba26321601078b9ef9963035c17b251ac41aa0ef892d1bce22c99401b0c28fbb20f79530eb4a7ce97730a5aa16a2a4b7dc3d825890079d65242b9e28e9a66c7b9374a31a5c2c7894f866502c2a5f3527853584079861d60c5ccc037b2619e3641b807837ac97b667f5d4887940d096e426c25376a76b104b446d6318c330a243d3e869527abf595892dc5d4eea18a1009f5653d5157185cbcca4b6fe362a06d9fc47aa4589cf2f4dd52642d703b474e0a619c13e4cb4c56db60699b4010f764e294bef5562aa3fd721d126d9c29e2fb2b817c0dc489bbf201218d3ad63dab900f2d8a8ba54887e6efd3ca4741a418a5f29b0801d8ee694ba73b8fc0899869c3379721f13d44156e01088e1f08086ae3dac53712434dafc26a20e7a8b6851af6b9109d61fbbca00cb4aea85e594f135ede80eec2f2a02df75b99d532770b9c4913c04318821b1f2c9cd753368cf0057f1fc7752f49081cfe50dd4bbe3c247fc8527798baa08c2a2253da9700077c09f6f29e5d7343eeefd79ddb6dc07ffd5285172ee2cbb310d4a8a2f15675511f994e81ee425ce103e39a753b7f7d988db0b69d2f7efa3c97449e28899a781b420fbe8032a73a1c0e80fedafc4b45c2d2a8720c781f4590c7c73f37c04cbf47bcb57c1396a5e2e634bcd2c6cceab9f1430cdeb9f07d818e4f2453fc8e32b6501ca91bd2bcbb2a2658b00f64825f5ed7ab0f8faea653294f98436abe0053587e96fc32beec00ddfdbe0dc912552bb2bec446f6f0ffa9340bb40a48abe5f59317ab8e0ae0ef6e7490b92381b4cda2784abd6c7d2cd5d22b0278433c71c62b1c15a1f75e75f814434014d2d178bd656eee189aaea6510464f37755d77d8a732bd1ff59810adab8e0a7f4ffd6bd27af99221f4860450772e911fc3346541d7f0c6d73a5bd6fbc854ae4695716ccc4b2afbb610733f225c218096f6f7dbeb9c1d315e115eb40a2a93188a08b23f1debe988bb9ac23272402c27463ff86167ac1fcaae795129823223e3cd47d88897a0370a0118c7f0fc23d6fc5535ccb9a17da782a45e1d6c9c45c276caefa4dd82198ec9907f4b25ea2819da3d083a46f60deea59fca9d50ca39a12e9e93741784e5d94d344e7e0348634ea9774821349e3ea41b4028f2b536155f4725a5fdbcac41b04de162ad0b15a8c8df68672eec2fde96f63727ead05cec79cb1f081363ce11b9b6417289583fcb443ea1ba95715976f22d3cb8292613b2777abedcb1b596b1981176f4e8d176af934ead426b933d4b862dcb2b439aee8b006e012981949c3caa9831d4fd8b53ed35de0cf1c2b8a764833ddf560f303dc75da9ebcdd801c4d0788fd0a473570fe7dc10e12f073dafed6f4f80bb8d7542623e3825a0a4341ed070859179405bb4678180684478bc52f7378b9cc08eb3e56b717dea574fb8461f75247bad7b233871c78b8320327da0ccaac1f6ccd34bf99d3924de07b737497d26173102f03235a0a63939e0b835d56169bcae3134c6b204081fa06604098fe2299f5bd499d2a31c51ff7f8c38ac996a38a565111dfe688abbecfb604ae1c38dea72fc0a0943e33f764b863228895027eec0bee3a3e7bd34ac6b6e47e9963232e89b41590fa544f532028fd417407b61c8c0ff0458e6cc0e4886a9500919a765dfd726649e9256f419469fccfbafd85ebb99eb166f69725b63897dacc2b3d8a115b9de2832d22082c674f60367dab9bcffb3d70e7b5d6f66498713f8fc155cea84cdc7ad2f132f54363dcdacdbb7c5aee63e6c2d51a5d072522e6e12dfa60c81caf73e7648e350dcc2f813d8488d32fbedaec80d0a2bf970fce46845b168c08ffc21571aeb071f7ad741fb79f1e27bc1e5a635d4155e9881bba488bd50cb94a43c8c165e2db231c4405d8380104c79345581148979783adf9ed42615a8d678cbff74f0717ad55c330059b82ef1d7e35d072efe9cc3174579a214a7549db7344ea084ed1219a00c16a58b5304de45e7c9875ed6ca31d57475d28140ff3701a8c3b1fe0e25814dbb73571075a5bd74f6ab513c3160fd51d2b2c3b8d38db9c506c7696733336d4201e25e9eed7582affb75e12524e5f0b2f77583f448ed11f1b26f58912d4047e0e10d86f11393f81e745133c88a272df05fe514cef3753b7923a9eba991785432ea4f8baaa1b0236b8ffac18c21a424aea98a3310cf21cebf0ff344094ad68085ad614b540e01e2913aa98f8ce7199c4deffc22d0b4bd82b64e28f7008ed4a3311c254cfa1e0a0656423b10422b2b726bc16fb5679ca8167bf4e0d9d9dd1413ea3f1aeec9787fa38615e69d5af8e3d12128f77b4ebaeafedd49c8375e9f812fc545e3a4c3f973837cffd4e2ebe5ff96106b3f3c31e2b0052eb90c3bf2726479a3e8db0db9b05ed59f179d4b7b352266adfba155ff14fc1ac56b403ed7641950ea11fd1788b9b15797fd68c0885d8fbe948635a7dd42bf1411baf789a4b3c1c2b05576cbd247232bd0b64cfe25766ce4eeaa9aaf64bed72f39df26383e2da7e017470cac5bf257eab942b20158bd984f4309704cf9079a781316b1f7321d69dc1cd8d650f857596d8cff88d0a7454d9be7dc052c6bd156d67890091bb651d8898e6ed85b367a72e15e63dd5b210a6ebc776d7958dc8a30642e5a1ab5bfa24911036fbc8c7b5c40e5cec7c22e964182e12cb8eb554a2e8baa3ff89e5b2e6e006303bcc6ce2244437475c5b56ca4f3e558593087b5a7764d93a5269b331ddcc143513d516925572d313e20ac68d350de068fd0c621e5329826670c0491f7ad819eab621ab4a202966e87fceb52d1023de61385d5d5e223a10c10132c5342695b5db937bcb9e02ea965f28f785724909a9dec692d989a98b665727fa75feb20336de70ab0e070d6e66cf7afd7d043c0588fa501636d1cc50be954d82bff2f3ecb9d781ed2c9076bcecdbe1c28a5f7871c9fa79ef31d50fd8eff5949266890b2bfacc80b2d46e0927d044156f2c5aff578d852bb01d325ee6d917e3edf78ed1af31ded98ee15dbd589b9124d36c4ab4a0c94521061bf1b3a75d3e068124057d3f372b6ac1a5e04d841221a8e66280dbb4117158663519038764de29e9ac7128e228d6a07646d0564d175df1fc3e53d065485889b0f7cfcd246940115ec4b4e4bb9a8e9d3030f6f2b9d37f1a15ef519914c771e8b0ec95cfddbfd78debb4c3f84d2fdc24b8aeb19f466249f642fd1db954609963e9a50460108f9131a8bcf330f0ba9804d70751c196cf804cf8984a9ec43ad1cc5b4ebe8bbb413229c6cbf3865ae1a00b5118108b9e24487d0e1ce9e6120d4eb207779a4bcef31fe75a8c21d1cb271aeea65fb26254f09c3f580fefa25a4ff115ee342289f9a7632420d3a7d04ceb2745f878248a90b583a45172b858679cdef9e749de46d973341b419eebfeafdb707e21cdde41f47759dadd7a0389095d12a0899bd58c59ea6544e34ddfd477875e461347b16078862c0383333822589276b05fcc219520b04a6f79607044dc31a90edbcd827d0d2829a80915b7869a16a7ff3308733e288b4d4d2de784c667340fa3849660f4cd722b836310d9cacdfd82b0888791c973df7521d9ce6b97537ccd445719fc9c1c5fb4aa5718805e629fd99ffeeb2329826f78aa03a9dac9597fae3b03419a966494d009f53bea8cd95324b1ca134fec9e982fd6723245fd043872cfc25b13eecd827c2066e7e6ec5d4cfa6de6ad3cbc457ccc403a0532e55d3b4c76f872b432630257cc534eca3562cf233696f45ed23b176b3397bb6a2dca8f733398b9e3fd68aa778e3a24f85bc9a7d8943730cd34ed44ff8d43a44504ba33ce5a6a57351cf4ad6903c9fb22f10ede11a66a08fda6f96f60f1a269f84527f0ee186fbcf6272feabcc3deb6a2c101facd041296a82c952977977349b9ad4b5f0a152e580a7bb9922e4466246037553e2065171b638accd18ef20a9652c806dcd6367c62336f22b0b524718383f5a030f5d4092e5283ef832b14731ff1236a0a169c4a6ec84280731e9b527ccffa065a9c49faf7f7366d279d14d09b7c8c3ac19903affe9b7707de79b3a618e80bb8da92e0f90b11d2fc3567f3965aec5cedbf35bab3205945b57aedc236ee15dca6e297712a1a877b891c2445a694151430d194950ff505c302464617e81231a8ca1acb806c6e326f6f2eb5ca4f9cefa43398d0007fda9f0abc498767fe45bc6ef1eaa0805549edb1d8185d40dc0e88ad6505773c628b8d6dbbfe0643e0ee98603c18a8ab4b21261100e88ab08756444ca19678f985894e70eaac786a09252a73226535803ebd1c7031e63ef02bb6c0fd0e7a5b722bed27658565951eb20e4104b40ec9c8b1fbe39e56e77472f87128b0ac4944095d10d0deff70465e10985fd92ff6c7c25a6315c67171eb688c6080825cf30d3d7edc3c21e86eb3fa3b9a00da14b6d6e34ba5b948bf43a1ec4725100c4561928d19185ebc04a5ee04c7f62ab21049a0c4100c57d08af216da1c5fde1722044323997c00e77601bdc0d7852fae5af54411d172581edbfba2b197311b4fcfe8da5d1c39db3be8c89a6987264ed082cf87a703f364235cb6bd0c8bf5e4571117afdbd99641fe2b73a4c69e1abb8861f480c55a18f5ac9292e39d0e28839d954a5722931f0b288fa4ab88e45ae7890bf6ae7d573401cfd2d003f8da331ea83035617494f4b2eb4e280a6dd790e654a3a3a9dc6c92011e7e8835adb6b20ce8835a16c5c9cb48c27b6e982f295e3bd6750735b2170830b114266b3fc3fdd2e96f46d1d9bd4c7f31d9c361f26fb6fbb2f8b1554d7c55d8a3edbb44eef39b1d7f51ec395d81bee51d738866d40e6859ee0a17961b775bcbfc6b27f4370112514aa7bfc5325862da9a89e36b176861f60f7456ff1e314d9f26b67127fd6ad9292f2c0b67a21a71fc8394c1fb72059a31f20ffa356f9711e3cfc78dc58bd6e7c5ab6f19ff4d56b04b7bd253a964dd86e9bee3e671695222e33f882813e7b19d302f056787850dde239d1bffa1f07355fb0ab1b23786c36bbbd6c639d409c3ce7b7fb2f90e5de0ec796532afb2a3d7c95ca813ae9a1cfea8d544ce0b37e471dc8e79d6597cb9ab0fba1d792e2957096a049f31f66a8d73c292bc1d0e087726ebd45dca933e135c500ad649008a165e36f79f5cdc653a58cf0a2f15783a84f83a709ff862b1a40a0b7e79eb5c441fe1a584677800b711a441e581cbc8560e73160efef07194640c391d20a04dbf04e3a10228c9260802b2691b10453ff5f7e71bc0d8103665cdfdc144db147bfa2c01a82d47db55df8bbb4fdcdbac41a127f18647e33ae4e172733820430bb618f10ec65b4fa230e209afb500e1e5206b0a759fe46996c4ba0c5f8ee75bb2391a5a7843203246989a8dcd20d756a467bd4f005394c52e4c3bf81eea58d9bed60bbb971a934bb0870a6cd23ed66a264e1b69919ee48b75f755056e2aa36488976f5d6d9a233504d00f84c2e2f47a4e8ce63543e10999acaeabdf4bb30cf8539a5cda9a5cdb2576850f353c9dadc37c43de233809ca270376820e39730cdd44ca548e7a211fc3cc02fb474753672efa9225bca62735ebe651c3c2fa7a8fc3ce41112013dc770ba25825cf6d45896d6d43e483d83a0c403cee458aaefa88b2c9058d8c5889896c16f562a9205a378128a3fb5251c82c8bdbfbd7227a067226a79ef797eb622ebc5f4da30708be75a68c0d29503b3a1f724b56328a2250482f4667ac0f163f701cde94e997b7c856f350297b08a69b649b94e14283c382520181a82aa58677138ccbb6171a5fbe1f23505af2a29cbb8f6a811c84468043668919cb5455b134bcca417fdf6e271a356371d8e333b41a53ca453a85a5ad80056b900c5a41d0022204a86048a0095f13316b95d335c92b051d6851d8abe6c5b655ed5b7e28bfdb1cb80da8c4be7535d885992375ca68703d7f7ac3b3291c871a30ae5eb51c03c39c2b6081fb71ed32aa70f1d0e8e8704f9e5c4057a3e13ed50a31c23926ee20fa0dfd710159a33ea373c61e9cee3f48ae169874f2e54942c0d0e2f879f4fa89fc8b60a37cf23b0d0be618e9af213bcff43ddc6af51b920d99bf0607ada38a4ea5690e3647c3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
