<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"953df4c16eba32d1ed4074d0fbbcacca9145e63b6ba78b7cb4777e328138590eb36c9bd4cb4c5dd724988dcd7e2e3179e0459ebf41453d4f69fc85e8a44e7a3d0b4c05b4db4309045c3c43f4b759693abadb99a97a313d1b2aaa0c33f0d1a72aca846ff4477db4671bb66f36348ad6291c29937b3f5618499425beb45080226dd405bc9b88488f65621113dfee3552142820a4d9f1a9863453382cf1d51b8e5e6536f21f113a69a8a81fe6cc463addb062996b37b6d3630ec68cbbd0c271b0d940e1edfbe02bcbe139c17b3c97afe88bc083aa013c22d5b85269b22356036859bee87e11998bd823dfb9cebbc980b333fee8623e4acd44c5430714b884f8b454a2fd603a42ec26f7d87c4779c0fda8d8aac09d04549d8a68e7e24e9e913ada7ff17d825b6eaa54a4c92b62df752d33b19ffff2ea55d259dfd87c645ffac52dcb1417fabca5684a56e9a00420985ba90ba59a469ebfe26ce81827ff481625b302c3103829af7fe01eb75f41ebc81e9db3ad1fe4c8536d77f0ee9e62ed623c91963f5cea9bb35b83b5a112d46122ae7b3054b8d066f4f5782b5d32cf005cd976cd6ab3c1e586c5d48525e63f66b42b4141de6c7f7dc552c83f8a176a91f26c4ae4bc99df96b6b4d5e563b23721f64425419f9ab236be48dd9ba32bc0e05fa07a0d10ce5316ee78fbd1fab21d472aeb3afa6eb1a98ced04726de9d8936e125d9266366c96882e3c8746a050ec4a24d296a93c17c13985f496ff625a13eddd718010bd2089a97fc7fb81603cfe8d021df6a2f6c37549b9c3fae3f650966cdaff38b9e8d0d558b48d51faa0216f693bba0b2e9c313622163dc1c5a9606799e8e27722bdabff9ddaf1264a454168cbf8c90cd2e45d2e6d2d2fc8fb55dd594914e43f1fb59ae4798df7fb898ca99263d38fad54163f99788073bca156d809f172b8a0f7f28c9d9f91047d344c180177c37e8d31e9110ece166369489c15823cea0e2412b534e3dec125233b313b67b85bb76cb38328abe4fa4a884066ec855d9e055e4a6ad88caf573acf3fa2eed47ed5087186c776c055f7028932fe451cfb4c7da26580c1bc3bdab1160a99771702bd56d43e89c244a2ecb38b816428f7b5a59fc42fc286d83c7b27da8eafa9dc4cf8d54a78de69a251f968dcc179ee3dad7e07f1da0bef0c06a420d3bbd4b63d46f6f8d12d44d7296ceaa7d3c5eb449383acd67e82aa47e49287d0c3ce4ddcce1a7419a5bbb072a387e5549e40174973b9bb19653c4be090db7fe8def1c0b20194d18c9ce1d70b13df2cde9945870a36209b3cafa6d03cdba784377e241ff4de0c3643beaaffce15ad9d8745eabc97b241e74ff217afc14a60262425b6965d58b624443136d179f350fd8d112ee469939e575e54b84fa84e2b1219db888d363cb0b607b183564d06d9c57c75d2de217aa2c917cb6871797f02229bcfbeb7559d3cb0526d36e72febb791710d712010079b4d883d0b6c703229a418e6153c9bfffd43989f858a16ad2ff2fe20515184d658bdefc3893e44189247b772233148a9c045f4831a202745695426f544a8a69a70fcf3b3928310ae0a4208231465fc9421b30c5b168194612dd881d8ba94f088d0a51bd804a049b673e5282378cf463607d65124eafabbe0f8e9798afafe19b9e11be91db67bcd2db04057053c33bb792d55865ba7343dd5d92f1b01d3ba27b7a65811f30b7d8430ecad95e9ab4188db1662575f2f8fd9362fd47663dd631b870ca05f7f045f565f3a4ca3e654b222fae691e6a31023ee32b7d5742b3331f462a91b95c19447e921e4bb710ad6230ab2e55044668f29fc40e91509a6a4a6ddb4d0b3034065874e3e52a16f5a4fdc83ff7401d23dbfc07029c36dea18e9d7c67e309f480093363a63a25b62b75e89126f290536e45294121c06366d29b18b90c5f51d8f0e81c19ab36145dd3677a3995b033b4cc2cb9293e09f310082d1a2319f0601f59675fe0313b3c07cbf7c472967aa99882cea4cdaf5b5cb0770e3d05bcb76689f24ed776fda246e27d377cd7a8304a3cf1a97e6ead7bdbac64f1631ea175cb54ff5aeb3b5df03f6905008cc7b78612fb141d48edad01eea29c70fc7e66a02b2a0540cd748c3391ca175e39e3ee7ea6226228e7bf3b211f9a1edb6be4d7a49c3d7ecff068cb625715f1d502afed1519138e69a9070a147b4fb040157ee997971ce339f9873814b2c955dafa909250fa89aa6daba5db874fe8893cc44ecad77e9e248cdc98b440122684e8aefd1823d0ca34639e2f0264c6a5a5a514587c6094ac7964cb67b4a12f7b213672e22eefa880c37a5ce26078412de1b36c704f2b2e4f5ced8fe73282e34c3509090ab6c031c40eabcbd2d7e1d68e97fb759008785c9faa6a9ec8f1f22c0d5352778c292a5dd90f5ba423bedfdd4af62378109770e47eb5edafb721b5a02ed8f1746dec02d541cfbb326e44dc87343bc5e7d678aa244e22c640a6781ef496594243708b7d7308e406b4d8e99f46f1a2b67b6f6d52042eddb0196a09a283ee7f2667da8aabe6808c5ad09ccb4848587df00f211b4cbfe6b206ee9cc598af06ebf3527a1cf1b8ed17caac267962bf02c1dc21216066af7bcb85f58040298260f0c937a9ff5e74cea5a9b358c7d90240b065e48cb8e06db7faa49b2c5e73ab82312daaab579b04fb649e07e487076ea78e2fe5549553d80d37c1c601eec6ceff96ca0cc75300d75babdca6d28a114fbe577822f933cbe78535766dcbbbdc1100879e38d1c5c384cb949a70959c59f331c97b837da7e210a60df3940df1643b30517bf2ea8518c9145d812c8e2e81f89d7252c8588b4ef0d474c3edeb81b300ed2bac3a44f785b1f69d5c2a3e9a68f250147765f54ba21cd63f892a11422083cdd5ebd4e149b86b00b540516323065c665b3aa06c3ed004351e23f728884cfcde5bea06c2db52af71226d291e2e88509891b6f18a553cccf8d87bd8db37c439408ca8ddc4d3a402d056f407f9b97a274347d37e806e1d258eb129e74d2421e4b157bd4bed232788d06bee7ff18726a47d81224dec29ac8f299c90873665bbcb7013ec889657b64f6b4fe2bd9ad633ec15a7557f66316e8c097838a9e942c224aa21e76718f54b82ccd5359087e75f46f1e631f6ae73b7bbd9a9291a86f878c09dfdc87d8c472f8fbf02b9ddf77129a96eaf866005b8ccf8a000facc7d14f9908589894ef59bb3e5fcc19223d6bd96937779562ed361d2c2f4bbf7a69728d62aa81145db68a4b89a24866b1075741cb24b2ae75df2903e89416c2a3da9f6a32c2ae72762335cee6b1249655e86230cea9f0e5544247211180c5c0f8929353edd9f7d254b1ffe7a90ed0ba0b4825762d9521edad3bb54060a71dd61ceb459d78b993598c9d70662ab35cee388be09ffeeb693b5d1b226740ad81e87adfaf324823cedbcff090724a2c60774befb131b8938d735ec170954081b92ddd9ecac1ffc10c41e7fb8a1cc9d075297199f673361a1b675991b828ef9cba8e97c7fcc622354928f28ecf205f73a1034249fd5e1018801057787a320097b159da7c02fa6b5553546b79be77f3f0ac9eb8508717368ea19b644e1b0fa714f1aa067e93285015f93480f7e1c54e3a57363e08bae0966b47e782303d3bd8b1cd1ca5769b8f137dad1ce61177437fd2ef4df90b50731b5938a0c1f0b501464c0e105575d9a0abfae0a74bdf19c44b29e5185201c5d5ae76bcf814c6766e26d187feed07078feccccf721411b02a7c9f9f3bbe731223341a64fa6d296d8ea6cc019b7fc1c4b80923b2b9778c2f31e3c5c96e0f2241f475ab13e7e976b9c879c9a6083eb143c51126dd9bd9d0b96c5d789574ee90508f60adbf2230caf569cdb18f7c7c3b1fe29d4783a2456c81c5ccd4fb17f4971baf18b97c47bac69b6c688d4d6db83c1126dfbcfdcd4380bf0be89c58191e8847c1ff3965e2a3f42955d3be6cc41f11b1edf36a0b048fcf262641ba15b8343eef524349bcdccbc5881bd3a2131810ef92b885c5e8e0c2e405f473d7531c07485e1c390d30e1f2e03907e6097828886af4cdee3957a874593a68997dfe27e823f4f4b351da9498a7202d52479f2c1c2b592115dcc1956183dbd594f099266c938077d91e67c791aacf9f5c7a31a8ba61e8b2520a9d079aebaffccbd35c9869c7452012bd1050b6a4f79a68ba435571134591631c9615dff8627bf366a3163faced3596a8679f94b3cdee094a6bd2e4c6eb7057c8fc9fb429e8cb3cc5cfac0c2d4597bb8944c78e33e3757b6d07522ac7a98b892a130f6b82347a81661641ffc492e5ad4c38de5eda6287964978bf32248eb3d6a7d8aed954cb449a21e492ec541a4d9d0697ad52c44f63f41a7d224691e9a3d015b0d1dffee9c26db4c8905273147670bfce99cb53ec04b02b5e796af42c281910a78c0738c3c22fc6f069b82708d0526b80828a0c9d2adb289d92c3d1e3cb42f79d19139bb5b29ec0ca1e9b7990bfc10ef9a449e78d547b36173c155c565f85b309b7901d224d5a2ea9e1dc2a46c988ceea052bf4b3d73181aff62b2074305d4cb70f1f532e9756066cd2f8da6f666458cdbf3a7f84d8bcf1c916d1611b17b71be2b2de075a0a1e2d209a659decd3a66d2a34b2e95543cabc622abe12e002a3cb6cca3fda4468e7b474ce29296aa2aed5ddc098fc93087d2cbe1a4ddc0df05e4cc963e89e5de75012bf79a8c7cfb691b4f5ad26845d99e7d09648e1ca5a2c24165831ab492cb20b55dd0e603aa5a0783b413849c81c0b7a99e0b2a658a6f74d0056e81df08b04cbd97368246836e0c15ccbd66b303611dad8717a5a28eeeefbda8992d6350f4fd1abfce9b554cc6ce8c10165a3eef1f6bc63a2e805ab3fd418a611943d7c5578af16d51abe18ed0eec7900a0e91121837ffee61352167ffdde1b500d5777d72197a3216fd493029413b972f985aa5d11d60e0e5be5962f72f1021bcc599be0a33048d3f2699f3d97100d7d22d14a7d8654ab35101dd81f1a16524d4382fae4f1fc2f6c72ee2024a39653beb41c0e6b353cc54727e770551c73d05c17d97a3eee5919c10e5b02c62dca837360e2f4830a099659e86fa198ffa128ea3be32fbe4b348fdb3ae16e9d9484990f85e5b064a35b304e289ceaa173b7a19f6325b4b15c8b7403114a5a6b604bc12e7f0bdf917902230fe48330ed5c27774a631e9dcb7e6434e28436512f9cf8dcae918e32e76d049ffc3ff8c902a782601c41369be96ffb8b682b1ed939e0db2be5f7f0e7e869c1cc13559e77bd39e2066e7de8989688437b11cea9ea3a2f2424be7085bda84d722e7eff1f11dc8efeea78f266ce1c6cd3a1ed411a06c1745445a33c948866686d9dfa38a0270320df653648889746b26446a0a3f10396f481b76e32c1afaf089f9fba454ff26dcadf02ae6a2c614b5253a923399a7dd49e271d8de3b21d4a1d617533ae22e62abb04f66fd69357c08f485e8d9c93022e28a5816c52f9d84d092c72c670971bfe7a1682a806d49192dd1dafc5cb6c86114e59827fdc9ee46d7a3b1e98986e6264e835f69ad66d2016983271a31ed2aee2f68c8a67e818ddd95b1b107af6f32215bc97db6b3f06cd2ad84193b548d5c55c232a61401abc51fb6ef8e114b2da104573c2d63d558b3d5ce29c3a5e8fab59d5e2f1944a14d2c882ab9a95b42c895e62ebcc42329a75b785d514fcd521c4504886f8a1b6059b16498a68caee189b70cd50832c2379555b18e70b955ecd76c484eee838fdde6da185e20849b1b7e3ffc7c74808a1d55d67c8281c4deb42720282828884ff2a7196633a7af4d29d3e1d6d25e47a710e805fec1c19b146e71d4556d8d493f25fa50366af10189d8e1f6367c12a4984ad7bf894456dc4d7ecfd73c4c157c147ea033dc40c94b3f67aa7e28bfb2be81bc8d9b3446724614a5c92cce3cae320f5152519607a407488e2db12e09faab3e8372b06aa1130094ab8c81fdd3515ec60d5ec751c438bcb44dad0cbdaf2245060ab3e8131f1a2780da7a989caf56af13ce129e39e7c3d3793c7926bddd5fcfbdceff6fb168d8bfa5d09be52fde3412a5ef2fce75c64f318d3cf1eeb6b1378246d148b99a862d48e33ac885296bf14d3e01c468b82286703474ab74ffbe6e37cb8e14b8e67cf7ced8023fee74b4b92e4f52ef2c7b3f8e568024e69f32d9d90bd93881076b1ff6f04b2ea3570e25a987897f6cde857dfcd0982f4720f13a55645370c17c62b55682c829ad16d9c496406e9d28662c706cbaa4e92ea40a38d553d64ce65cc395cf48824c219a0531bda3c00965b2d2a3fbd888cb2946a70f38bd4736198e3485bbda9d6ff0119acec1f3daf29a5afc1df33dc9e3d33d2b059301866c1a9e7855eb46256e0b4ddb6dba6c91a57662507a2f9594c9bb2ef6b3f31368966ff0fb1e12868fcae0991bda57594f0a60d03854f4e13311a4dfb69f9bd527b6af73955a636671c0f8a31d2fe08699d9e42fab96769ff36ab2b841ac4d43445d1c7b8c72dfac774d2a227800d3754e145f6d302834d4c5398e9bb5483a6ad33c90fb60b69fd3371073955a4db0118c5c3dd79348e2e2be2d55ecdd9b5a7b0d366774f60963cc16767d5a4427e031d6539c95b3856b580ff67eaff86dc32bc92b92c52034e15c17a40ee3aa0b1fd9ce18dc5093dd021a4b8907bb312d4d0070d78b46c037252a21d899b314c477341f163a18162d6415ab43bd34889ee86ee4df9f694bdabf208a7f70b225a4c74dbf91e2fd69d92d27a4560aa708900fe60ed8c4da28c415f60525ff695a69433fb7d5c14bf35cab2f456748ef4b5410acea9b31df52c00f834e62b86b53bf7a8da17aef34337b992a4fdc8389a3d7de116b945afbd9def09328d0850380d5414c4e62670d9d12f22a7923876c1333827bb311026b68ed6e1576188917e7c6aced9396ccd1f4f7aa3bf3ccf87d23d4c8f2bd8d33224505958dfc4f2234faf3d5f056ef83cca376064365a20f0e2915a9faa957c37c302bd4994237c7187ee59ba988aa2b4c2f2d3bb3568d0273fe9243d731da05bc7e7914315499e4e581ae32a73ec0761ffc3443b5b0200edcd554ec79566db7842a6acb09013b6cf2fcd9e7c331bb0411bdf26e0481bb108dea451ef8ef68f8f4b69be099fdb43f132a28f4577a7f35813ee988157e2b274144582cdc81c57e71ffc3f8a86578b2ba7c9d6f6b57f9855a0594542a0b761824477a978bba717bfb726dd6dfc51b44bdabcf17469c24725f41124dc372ee6b8bb49c9ec3005fd797defe0829897509e89f277a82ca9c4f049265976e59e50ca7723ec602cc1086b5bf230b5b44b902e9e204762abafd13120ff03efc711660513cfe05475e5eb7fcfa03753b773c242fc3d9382d0d67261cc103ebd49b68c29d7300deb007589a9cdafe62ed6ab6502066af70b479705675dc9e2930dacdea3c2fef3f2f69bc976cadcef4a5bd1bf2142320a0c598a0a2c586e88124d85db8d75f1e3c5be9f789bdc860df0ad94b258b716e27af0ae5602ee11fdfeb3162a40c1eac9f1cd7bc6de658190ad6f17bbb7391ff4ebaf0737d628dd6f9389b4a70b5905c2359f7df658ebeac0990bda77097f820b6a490856e630ed9a0ccbb5a6329f8ca7fd88b5b9188d223b6f7c565ed41d49ff45cfc0d82a25498e5bc3d235a362a42359b899381e84ed00f533a08f8b19b59a89f26dbd42d9e0c0be46e38b1e76a127f049cb2b4586eb56497fe85bb9616fd375c3f616f59f0ccfb2fe04399f957110efa6d602a019525eb0069c81365063ad3c325d04e67c2a6471a086dae95ad66c50f202c9f02982c45b2b8e6f73260d295b50d6d9a850877499b97ee8e1e8cb1d156325b47945f481b474d8a254a13325644efc1ec08adf8be03d617851d71ff41bcac9b8706dd66a0ef8ce2dd4162a970ce172361eafc61ab1062f16da0ee82349790f631582cb248b954828cfcf1299c3d2b9ba8d1b33ab9f459ddce2b1fd3595c9aa0f63294c6954733dabd76588289b88235df62b7fd0735a6869344e17a8c976d98fd5d5c814f155c4ef029d54935d5f4e213899f59a18d661c4defeefcc842279ebe5e9fc2758fdd760a9697824bf9e04a5e9d8c0bf793fe253a55c090170b104c399ab4528408f3e7b3342d0104d5b9c3474d6dd666415257e254dba2af7e6cdfa0fc96564f6c36bd4afb39bd2c3965abf32cfe2757a4e6f5d69d6211da6a004a089a2484fe8b7a9b6e04dd5d40b3acea6c2689e81dc4427edb4410b5dc3651baf7311c8146c299c7d259562ec579a3b37b3e0273100f93a720415ef43cb63091290332aba7989c96ac9a10931bb82b8de5b4dd5d5be6433d070dc27509ab239f3cd5635185723100c162684c5114666e7a4644d4e45c2d6413c1c2767e88fdb35dbaafefc538d21bf16305a568bfd00b4eac0b4e5621dea07b2d88999422f16ae23ce0cdc25a409d4a40a61aaa9b25a620e8705efc4f51fb955946785835491d34199d41ae5e82645d68901b6ad0c9092192d2bb42c73ec3a6d8057a205c327316daf4a3d28314ba295faba71fd03c4aa9d7372de86ba2fd2036f7de3afdcbd70b6641b32c46d0464d169b8322d902724ecabcf1aa0a538949088ebd9b3dc26f780e2aeed0a18af5866251f568314e878429c7ace55baacaae51a6b5fa624dd434d78a1a50a4dfb906ab74f059131f29b60eeb2a7ddd035a30681f498eccb4ead6c7936eb47015eeab8120fb208f87257ad9b31f2276bd5be6733727c774c69c50702236141278832b590a66eef93e1bcce05fb83e1a4e9345ba948be8114541854415fdd129999fb2454378365c007cc56956457f035e717e9eac7a0577a751ed713604d83a4a5a6a3f0cabb3c1c07f21ff3c0109e25436a1a723a88ff9b7ab4a8f06e75a27175a6442fc8013bd5339140981b1d262247424415b85a9eba545ddb06c1d605f1a50e74d4e00675a320bbe4c95a6e73bfce71eb2e7f12b1e6554b60651addbc92e83d225b6e9ee93c6e50aeb01d1e35ee6652463e05b3fd0e8718e9890a8c733071c5f1db424618aa3af3b82900b6429679de0a4a0a9fa03aef74fd88a459f25bba2a134830d79339cd19adf4a873f7fc16ce03ecb65fe8e3789f9f2baaad0455d5b37793cc6a169f10eb0f0cf8bd85c567d79e18b4905ac3737f08599652d93af7493b7aed2adf954018208b55d655339300e2dfb414e76e09ec0fa778caf10cf90b5d78a4efc572913cad679c399acd621f75c16c28a1de46ac199fdbd402f78a628e3b510b19cddff74082428d637621f4ff45a55543557bc7d966240409622d2502f9af8529338bf9ece83330da1d694f6ef6547207476198f55607d114422e56d7fe22f202ff26b98e0a8c462af5d6aa60aae2994b7883952e3347c9051046d8c3c2b6a2b7278e7fba18641f471e61638cd63232637ddfdb81fd3f2c4b14694869498d7fe66e5c2e79e087d29b14869b8e18d9077db934265c0de55e30fdfd7f4fea7cab083d6e48199ca64602c2e3bea788dfd3e2af3a58c2c96a1310663b09dc1acccf181e6fd25880910335fa9ce9d19d17fef43a30773ebee3d7837613064dc2d351158bd8b0378308404e76c2f1e0c988ed4da160ec40d916d6f2c43e0cb8c8c6fb2bfec4b83352947a4c79cc92d3104cd7d2b8cb75094dd6555748d237de5a92ee2de958e86772b27d0807f0cf442e73bbf46347342327019348f660fda467af5d43b494a86b33be5659e9477cdce84db864c9072aca4b3a1266c44feb045d035230e2a98ac449bba5494b14607b34da9800ca0876e67f83a48003f01b5b6ba0e064e9f0b7b56ac79dede0392929d6afc628770fd3ea26d831546ece1de217ed7f771e7668b7539f28f3715c0a93c2af274114d225448084ed30aae7016d766ff5b7005ae2273db2e700107be39bee37338c54177c4fcc445c64e29768348a239694226c8fc899c66b5400ad530c16638a2f6d2b79abd1cf19d798383935e8d02f3b0153e6318f0c3c541be46680e1ea2efe90ccdddfcf39cff691f8fa74cacb5f40821d142ac3a0afa9ca15b4a33e5de37ceb8a02dea6cd5649f647a890e1100a028772f06d534dde14521463f89f067b3b5a40c55e320c2884daf4c85c834931b9968c6c9f0468c595d64c906e143c4b9136f1027560355872d21119803183403898ea866f6a2ae84bf985676fb60e257639ac7304fd32b52252e2b99ecf56ab76dd9b40685fd06d0a811666ac1b66ed6faacdc6117ede95b0666a083e34f1208c1bfd1f10d39da976a94436587a4fa1a25e151d465aa4505294f9a2139ec6558fd3c48617323ca10a1247f5bae95d0d695f75f38b23df128f12f6e0ad287049f014a1ae7424ba58f0402c16a2f66ff9a7f7c16742524f97c74479e8a2f2ddd5486abf02bad121b67b14b94d393b7cd3f29078460a8060268c68de5119ec6a324bc85d1ecfb0dde1b833d4e01bb201b021aeab9369d5775b5668ec0270f06dd5fc949e0d6ff78fdf7f566110f7bd08aff0751a56b2407cd23ad366a99191750c3fd29ac6a31a8a78b0b0339a10dd7cd47fbe34c21d4114932f97e53f22fef4bd11fca4c43301af11be2c3c09201763825a547a15cfa7dc5ed18b8723691257efac13e4e688a2564a976e5ed715ee4aa35f6a27f7d2e0ce87760d2f018582aae1f78f200b22bdf0213f3f7e9739096f9694047dbd5e0a6aaf4cff945e4ae34460a88add085cfaee5916d12e1b4bda6b6a6c36b9fc0024030c53230b7403994f1befca6b01bb387584003d329fae5a90037caad93683394eb99decc98a1af2dbf84d5eab50c9acf48436b4a86805f7691b77cb839610b1051a45e3ab1f0bb99fb739efe5d9cb02e649c6982ef7cd41b55989cbe61c4ecff639247f7ba2f4fa4c9c5df39e60e51f9afb0fdd834787ad1b612efe5454fae54390dcd5fc1b63160c8c067838240c694f2364b55b9a4efb91dfd5f43ad3d6b144fa45f267a8c05a7da8f9d19e1f3e00c6e35100d17e92577669e9bf9b6a99f16b856f773cecc21576a940ee0ef204bb80975e6e986cc5832999980c23b1908318e2202bf9f4707a178530deede6f3e35f9f7763f40541b3a3e3d31ae07582daf750ed3f0027e473010ad134dbf63f30c10c371516f0d4db94272b0cb94087e86c5ae3704f436ff951c99cf6fafeb5228a8abf4abc7933f9742cc958db95da3d764b25f069cc0652d8e1ce34c99adf801f1471277f08c016dd96c320db195d53ca774d5442290a95f339248a2c1fcd1456c092ee5f23b6284f0637180dfb38e780c9cce3f5486d8decce444cb1450e8500f2b6a2a75b1e3bbff0eff98a18d677a7314e457b2669b1901b8fcf29fd0230800eeb592fcf286f83bf2f1ba10aab4829ab18a81b0710a92b089b3d59eb06ab792261cfc47b1b0c111f5fc02a17d5ca96d6d2939768d6ee8a9c480fd0ffe2d1002584296a41a987025f33d96bd98843a593eb8abf6fc4ff7a15c3e34866d57390c3e4e11c62dfbba72a11641fd181c6ee0e97bde4efdc8ba83979443d9ed1cf8cadc0fb278d1bf553274f25dd1ed73be480c610ab73e73e8139ef17794fa78195bf69cfc8103d8ec872963c99b89e6859f94437b456e237226727d109a01d0a75ea7c9d7c39ba34729ddb59fb175c6a8b1a4e71b8ed021c0ecf751aa6496971e266750bfd68c6f0d6380bdf4f0687ce64a7ec21bf7c3ec5586c74ea846da9df2ade91e59f6f7000add6315071f1fee9d0d6f74745366456b021b7c0ee6181a4bb88eb3f0a9843d704adcebf2c226c46fbda45b2e0c20abbb27bcbf0abb47716db0b496d2726c1901cebcca337691c32e6d33aa0eaa6c57bf98bb9d3c61913564cbcdab4b424e2af3a737fa00f2142f4dd9ba11d7c0f11c8e6f89a2590935cbb4737795861422d3701e7d26fa7c3621824a083b8c8d202b945b4dcee5d3a350b071e2366d1e36c168eaf95dbdf17cd8b35052859d16f36d0858fcd3cd389d150e7c80b48a72bc7ff6e05dd86f7f36343a3a866cb572da40cab07d78ecd220433587b43f6715272f45eb996a88cb77f4947716d3569cd8037be6ea8688f7cad8ec3523888f72ebf6025b009a7f6f006e9872969f16c51f4c089e1d676638952ca015c1741fb00c1cf973ab3598f3be6cf885d30aebe2883c7d353164a31c7aabc10e3c63215483b14488b0b28b70c210e9e9f9611786feb944153b74f0445580f26a8ac1897048d6373ab2fd0b3395f01dde0596a88a191a32849a8b06f2b3188202337f0ba0a1983ab5e098bbb474e7a655ea896db3120ab329accdc6eaa1a3f8a6ebffff6a5e8c64c51fe89437d798fb4d81df119a63eb6d6b6bc839a65ace0442faff54100a927050c3d8d8e25017cbbb7064a41951319d0c53fe9415b08ffe35f733b477f3477c0eeaaa674e790489e3160ea660cc5eb8a315c9ad297692399e2f1da5e4c880f3d1938b717317a1e8c2a8d18845dbf927eb0ad58bf58105ad3284a97fafdfe9aa0bc2366b46fb171e1235cea371559ff5cafaf163f7131e3a340d7f17b56c7af05ed95d084e2e5a6b19b701d02fd72b13baf950d9c2e912fa181b68f0180dfd78fd8d81c50452f4437aaf44b59172e77afa870d0439d6c08cff7c9cdc0f234854346a850313bd39258b9a6e7dec2f33e13afa3d4e77255faa13e60281f69d5dc2c14a4b89c84d3417cb535b15ed6b23dc9d93a9e6e8a323449634b34b7fdfb0a986681633debd5ef57425e7c0ca8b97a17738e27fe1d9f44891eb5c387f7f7bfd2c45200b2db58e6180cba8b396efe17bea23d601f7e4873269502c7727ed5755281eee9989451beba7c9f269a08c1d1c90abd9e349da84dc8d6a0aeb8d3c953d1b9e0884f7f67b922a2f0bd400148736484ac65121025652b1b7c924dc6816921344f28d4fb8e764456bbdca0d3675cc1f5aa425c4fc85414111b4133599693c06a0b4efb6ec1956062a5ab691725db1127c96491ae5fc0d572c06e5d3b84d8aeab6dbe3560cf2b8d7c26508a255521e5f4b8afaeffcf742e23fa79109bf7a7631c32029ba0e86deb7f70efcd113ba72ba9872c8d345b717bc2d4319566b4965aa303cef5b93ea90db15a62430a1996d601305a2060aa2e4cacd1680eb0012e06adf86e5a779f9416fb230e47832a66b89f08dab6511849b3557e615c57516d85c9944e655de85b8c964fa77d655ba9cab81a961704b80a86abbb8257396e9b914125e45563cc0f3adce0ee8899a6b33862554f0b30b1183cf8fbdd2675a5bf44035e7439bb732885a4efc1bc2a846a87479c75dd147c657570795fb25ba5766562537a3ed73c36713b79066dd6fc08adcf378caa13209e9705bc1ec33f96d63cba566ccb207acb4dc7d29f9dc9d54fd234a521d3eb1d8770a0868dff437339865d246ddb566502ad2248ee2253b04e6e4ab7651f085e02b97fbbc5c300fa67956ab9ddc4f88c14ad9ec0907064baed81fd0182d05a63bd143a5502eff758a6ce7b6de0dfda356c5c4ce7d09bd1ccce4bc225b97e06dec99c0a8af4c66d784e72a0a3fba36f7cfa1b47cde88b6a600435de83da459b76588a9c0e035309e9d4e1fa86e232dba0ff3ae0fc0657a59f83b77d8bb742b32477d6fcb1dfe46e00b64c86fa6ae95d5a57f8604a957d517f0deba1622f4d5cdccb7add6f3eef481c4366f82d269e84620ea2b83edf44d10013279f9de18639cc1472c2490f45d96bd191b253d6d2cce0d13c5ddddfd9c29d757ac9264b7a10b1fdabf3912c83ef2fecb1fb6d92ad2c2c70df57537be0809850cb634adb00d4d88fe753ffb990becf7014e5983b343fc1b17eda775b29c97c10a115deb6486d72403066be80c45029c5e21ccb1d6cfea022aa278c468e1716db727041412479730fac17ffe4acab07e018bbab4dd3b345bb57cee3d2acb3f7b2e9cf1826a110d109309b34505947bb10e4ee47f2b1298031374e39b0c21e5b717d0dde54f40d8238b6e733492ae60f624ac14dcca314098d9951a9306aaaa70e489081d779ccc58aabb3fcf6e774b859e1b79ff822f56a4146ac06e477d563a00cc02f2be8c10ba0de096f334e520fe02d9ed6cfc260be74acc08aa1dc889dd3084c12654ae3f472ab3741d42eac3fb0ed7679fec7053e02a35803c16c36eea0efb979e5fe7d9782aaa30168478832187912f386b1bc0fca31054335c91d69bd27171b495ecdd6da4c4add4a8f7943516ed7f4dc32d406efcf88a71643b35171a0d373c521ef45638fceb48145811e4f6ae78478a77c52bd438c199ae3a18a3506222084e979c689082753b5f320f115feb1ba1088d23de0cebba7a2cb1cde0e1af0fc619a84c8e4ff189f310f942674eab70d59f64df34be126067ca556038f5671402d50099d1ed3b629db497c4c5028ccb8e4e2d9aed5c06e60b758a56ce36f99ee7c1d927c1a3fe091f5566f61e7ad14eceb141c9d0fc0358565d1e2eae31012fd36beddabc711c8ffbb1df3a7f5fa53149dbb3a288247183a0fb1fdb81ab3d0afc5ebaee9cbaf3c0c784531fd31dab97221c38031894afae51ca99c7f34e20b46fd11afe1a929b4ae1618407fb7826d716cdab2a9807a92225eee1f18448ed02b78c291cf18001f21335b92695e2939a70ad700f888eb5b776e4797b145037cfda9ef4471b4dffffe2fc3f59860012c59b544e1eedd3c627fa4b87b231d404f793e82db531d7dff625871cf1ae9fa39ee7dae260cca8d35ba630dfb559ee76279dc886b8f97e57eafd9f1f8c16dfcfb0b3f2aad9818789904cfba52ada04f1e1da2eb632c6eddcb7c0869a5c212366dbea2897d4ad213e3f71310478f2d6ed2463e485555f73d4aed160c53fa38714a7fb843f3ebc8fa8d3647a41d7d1a709101e0d41fd305abd5ee21a031710eda92d5b788c12cea039545055b4d2bd7b727f2be187ef429f1adc633e31c0e2ba116021976846623a03e5047f2d7cfc38a6c9c89675a98d130492df86be088628b14798df58f0faaf739fa2b016b7ef1194de252e4c390db957552eba26dcad18c06290085a6a4b4187aab54f0ea8b0f9652499a242cb4b7366efd96a24c7d0fad514e7d72b8ede4f40d9c6d2f4c4870b334416905802612af8606003ad2e638227c0af7694751531b6c3192089a63b6ec6210b0435fe6a89c7e1caf9210da3098b8927b82d7a60565ef6055c48acea4ffd5f515be29cbbb895102a169b02c83e3ab099c5bd37bfcc480678303da4de3f08fe3752840b68b1dcae1df7f61c488e98e3137b37b75c87b14a55ef280aaf686f22c78090049513ba00c5102270bd3e0f0ccaf689e7f464a41b4d6dfbcfcb8abd11500eece53498249ed1cd5a9b9052c170c429cc2bcfa3f403ac4ac94c381c72495990a94edcf96fd6d22ccbfdd31a1014d03482b864ae1db3cd0600d89dbb3e7564241b695d5aa77d7d68629523d90e26ccc4bc47e6a4ce58980364b9065926b7acf8b5719f9c04b74b691f27c2ffa21c938853ec25f8c9ee2aeed635a0136a68389b851f53796068791040faf76792bc09660bb8ab4ca1a0c54ce3322e31b93edde55c6a49d72f889c8e06d0d97ba7ce1cbc280b14e709e9dd752dd7ea45ea90039c2ffe1b5b22ca696ea75490d304d947235046feaf74dc4c9c8dda45e12cbbac0076d9890c54477e197d8188d0cf40e13df49b4e455b40b3597d93d2017e9f65b4144424e333c46583edfa40b3871e1b5dc916dc410158d5180a6ce6188d50bf3e901205cfa2422e62049a8e7bfddf4b0856f2f0c72bdf64ffd67ec9d54b7ee463ca22572d36cbea8d553aae25a25fc224df85ae2a0be3784cfcb8091c636992357223a701e3452eb28f3c63f728d33ec97e88ebb04ec4a28c952b84c3c48308805685a1e3752101384bdad758add2ff0ef639815f277bc8b9d0a81a7de4b0806ee328ed147b6398b800e09f99df5a492b01406f5c1473c3f0033def317a3a22058135b10aa53b718e6125b28b16b83bcfb7161949937a4987f6a60eeb8f836371785060c414b3b403bda1a3bb8be26d9a06035e6e18b2575e730500d01ddf1eff30b4989d2fabee1e8c956ae6259cfce36ea7a71469fe19e45124b6cb62d9ea18f3833f6db48dd9d872bc8f7a9e26f260872169630277da1817efb2ed0ebd2b8e646589b53756ca82abfaf2a6e18256e4c2e87a024bdb1945c43950eab127e9c0d07a1358e2302da06c64f83b161cdf625d7fdf3b8c499da7f63dd22697b0fe9c8859ee56fe9369f1dbc567fac1c3ab073c8c286aee718f05e2b3e0ce317682d337c17805ccc1a2b912cb4b463c24c83d6e26925988d94d3f68545a764563f6ddb5fac56c1615e19d680d9240467adadf8854885346d443f5c8359a5f9473697acbbb8c3da762aa88a0e3a70fbfef08e36ab6d81c8d581e39a30049c5d5d25e8b05a3743fa801544f77266cb6b1f453347e2774533d098700ee8d23c8420139972b24da7c1c4888a237316c77a7a9c368e71002c77cde77e9325922214b5a693a6c9174811ee6ab410f51c92acc792904ad5a6517eb3a96583a05b2397ed51314add162fb10b4655fa68c7df8a9c9171192523c53a7af8c6179bbd188248f8d9baa613b4548896280115b6f4f9210e30609bc8680af6ebd26bb078804b0c12a27baa364958da5ad056701614e5e0a9073566c52002f5fa4dbaccd2f0e4472ba9158fc69da6611152b81a15c4923f28cce8ec64993ae2788e65b600c7beb896d2a4f210931ca97830050ddd55efac3ed15fb5ed46a13695efcc2a6a23320166e7bafe2602587582cbb6791e6c18958667c07df7af5806758bc17e35032a0a7fc4e95d4f5ce3c0292a66fd7ce5f0242ac634c9238f40a94c897384948caa83995543a801581478dfb0f0179e5077b55c06c0a308d28d44f9dd450c4fd2c6fca7f8a93082d79c3325a8ad1074d6215042a443dfd04ba725c3f0cea907ca40fa0f2dfd6bdcedd1144e19e65dd8bb212403bb3507d7fc6fa6e82a7e0e931d16b0d49d7669318d68cd72d2923aafe348c0f5479f492bb36ef7f523d0f4191bd32da58098c4d0e8c9a5440cf6f6781b4f20298ec20d0fd58d7c462feefea1dd5efc4b7bb51d38309322c900b098efe95b12ba0a04c538cf187439eb1aac2f05bf60cb5fafac9b312575824a00731cc9a3a497aec8b91206b0e8ee4f45181eb5d66ed21743195c99d566c745afe76e2ab2f9c5d3cd210664002837dc26978c363b424a495b46d12b9a524c3bc34a2a9bfc34362384cf2b6a9b0083d87aa96e7172bbffdcc509bc34e8610cb0ce8c68edeefd2d1e1348121d1a7a96ae9b04e1c408c3b838e65ea4459315b7e2adda62f80d0cefe117a90581819acd3d17044bd94619d3a7d508dcb69961759922de12f002d7fac5469444a397ada4cf7eb41370f3cc58ce5a93f32cf8616fde71e25c32210e43e643333418a08eb52d01ab01ee341ca73db9c1dd7764f3e5601ef67e8b140b731208063ff44df16cab4e5db2ed8a257b54df08417a6ba10d6f71b12454a238ae01b916336e96d6ef5aada906bb85564053a2eada244a92665c50511973f2a4bb6e4e13d69c90c13cd725375158936f40e465a0f5d03705df2556751101688d5967e127dc85f48a6297035fe3b1af7f609f6a1f063d57e1650bb6f1cc2d14129c103a9c873d496676587c8b353f474166b6e254b3072c228034da1415e97a5e7ca0bb07550712268105f5943c9629567414d61bcc91b41fe350091baec5b235d45ea9d7067c86f0f955b5ae9874f5bed0c1b55187db7e914300968f2f49fca49e327a6de4165243911b0482abd66ceed6c7301f08881ac09b1b7ed7031fbbc388b606b09b58d177a2327683f0133c0ffcaae145ee11bfd0c7467132e222f284fa2165aa40264eaf054014447c46ea6cd325b5a600a92293e65ab3770958e410409a9f732723bb2acc8a873fce944581ebe62a764bfb45cedd380635ba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
