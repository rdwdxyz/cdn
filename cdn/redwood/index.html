<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"45e1014974a6a94dc46f5e1fd523f5cb4c447e1dbf17bd96aca8b5498f84bcc5b8970c657d91d9ca245989488160d19a9de95f3ecba301bc356c3a9c2c59600db53a3bd1c7055fe59f00ace1488f0e449d220007ec8f6413d4bd3a259e5b6a314794e2ff00dacf8aec2cda890e746c8604febca9fa0933aa1d79090fe3071745ee447c20883a59c83ee5729fb36a0308123df9bdc977d972d97f1215e3347200da0f10a03b6238c95e405722e77cd129c764a3b39bb253ed7667e6a015b6b3f13632ebdab5a39a4a14aa4c938bdd488c6a1b93c184dba6117f1de694e8700eb0cd1a0abcc82a87351aa66a507adbc1bac833304baed344a5ad20b4cf81635c988a8a0b131f70972b12308cd9bdc51a8a52e737242515343d322577a4613ed94fa60f809fd9f871acc22fd2bb4bb8fddda28cbf53b69bd10b29208d21e78cdb34255f848c438846add97a03e93701bc3357149d709b6e3c5e20837958025469076f31519865cf3bfe374938513fffd6ab4bedc2c5f8cf4163b3e5a51c37329d409a86526b4cdcec26e963db3d5ca52f6354936a3b585b0821a8d5f7f4c7ff701a2ca78ccce0a719d18ab7c81670defc7a3df01c1d398f034425484263934228c714589407ccd3096af7b6a03dcd3f803613823f81a17ef5f1007d3da9bf998f695e3fd9334ae9f26ba05c05a3124997cf1a0d23389ad03afae0fb1b3e97b791d76c2c3fae33ff48cfd2ade12ef3cd0f41b6424a9cb9eea949254c43660858879f1ef6af665d7d20d5a3d9f7eca636ecdb7c200b18b4672a45944c91a21acabb2b51c26bf8c59ac9bd72b5d4d0d38c446d02f8b3711116f327227c423ec8e301b3065525066f88bf3227b07f38731461352a80cd5b1154e793a1bf0cc3d1782a7b285eaea452842c335a1a156c1071ee4f335697e5cd61ca901590836e826b256632629ae8252791b5b12964a16dfe6a9c9ea343068651138799c61d4e08bcdc39a63fa7c51c9962e870857af60530879cf6036f5ed8e2fad6e584d7b0b0049ea44309dbdf965fefdfd18090bcc4f2e362c2758ba764d4937f2c0da55e48b363c6463378ae3620b16c2b8967a08e16ded4395993352e4e1a25fcd6a0754bb1e19459f085db828b365076c2f4a4f7d21e8e3e4cace3699f3d7dd34cfd82ce5c1efba5f8d71bb9bfd978be60eb6eab8b12ed48a263fc193d9610e6af9c05496be698e29e88c4ec455456692f49f4ea9ad58cbad2886d7292d36e9c260473e2bc9bfe072aebb582b1865b55d8a2d2669f41e6c7b02af0b50c7e74af4bf6619a05b7d3e48e973e3dd35fc2f7ca02edf39684ba83def5d720fcff6bd6f7b45707d836c11bab2a06a8f98f3dbd58e829d054952c30ec4623990e2d683da6741e7fca2e1e235f18696f01f1eaf5f3d764a4dc1d815c8d1d1a86f5930bac927c2c4e622549bde2b47d96aacca7d069ab50f32ba9ddfd4a075558b9ab5afb8c856363942552d0e3142d3c5ef59ba95928fe41b7913c1b711d236a4188043ebbfedd6d78f3b7b1e6f119f2976f8921d7ec53491fab716cb14001c789d4c17f8daec3a7e9b0b1874431084f8e22eeef9c723917a91d5aef2e7e76eb37bd4867af8414031a7c61446418ec9724bc98613fa5bf7248b10a1dd16b2d7f40123cbb35db2269a722e088409ede395ba52890b27a836bcbbd9d780162a0ed9fff4dd997e9210f0f1b74d7e5154f4d02acaff1f841b3f6f2b2b027996e2651df0a699d67180f0a3c4c96fa55c453f1d6bc0d5336963950063e59f71e2dca743365fa025847ccda519b4d3a09ce042740cbe9ea33f65a1f8695775b8d6a1291f05386f4cafc34360a5213fe1d0c544e540c853fe82914186e9e1cfd371a3e24a1a3b0ab0e32d7c8a533940d662945e7875290e263d014b69e06271efc1f2e23613ae43d91591bd16879d1f3f35d6b57faa7ec20b6acf9392106b22f48814df938d1887fc31d621d0b455f5f795f8f4a13cefb084a73253ed61a72e9568eb70334f9aa5c2787f521b71e372c7a6dc4cfc25ab8c457e409f9fadb3c8a502d3627f6444300196c1268ed5c342f1a3fc7c148c8152473560a0ee266103570a39f4db7c6ed25fe0f29c2d71131992e579887ffe23fb74b31086bf114d334373a84c7ec32a855a1e7aec4997cfe3c79bbf600bfc91889bef6bd842b929b98d69fa356c609914431460b190c0e9da6a67e0f9204d11fbc655cd23066156f69bd1d7063a401c14f74d9107c2e58e195a7c2abeb0a9470e9a2f0f9791c6bc8c7b309cd54e624d80de47bf9fe98620a79ab8678828618c946afdfe01749113a1fc392b8751984cd4185eae20e1f292a34718a974e4a4930316044ceefad293898028cf820c4fb1de2e602e5156186d27812c0ff6a22394026f03097b8c4269f844a289d7b668ea374c0028e4d5d6427efdec36cfe1350c5829003dd415fd29303c4c255b49870029ed97226eaad6106f03624545910806af75891866f237a9833f21c6b58fb311e396fff05696f49b03c39ca9894a3272b7a4ce05b5766b3ec1087d6fae4bfd08a9411d92c99574a9d969e3d2a0493ad242c5aa7b96421f006e27cae2e97b5867ac8665495510cb8949ac56077133cf6309ea1e09fa3324f824d5b45772112efd9128274d19e8588048984096f1f786c8ce6c36efdae0db1bde68dd72e75dd740362afb2ecba292bcf3d3fb283c36f977eb92057eac6fbb306bc819bcceceb0605edea29a356b1eecfd458930298281dcfada69141b1c5159bc3e56586dc50e0c4f0047f944e2517c9eabae21c971507f1d8962947b00245c16801a60c587c729b7f46eae2f2dc10ae17d1015afd50acc54b1d9b4c7a91c353d691a50325db1f2eb3027c3d90fb445865e9ae90d5d624fa838a60c8c0a14bced84ecd8bb57a95a417cd380593ca25885a33ff9c9da5a01bee93555caaf64a925901714aef66338f1eca396d1c54aaf7fb63f534ff61866dd5b04627244a85d927a54b808456d15a3bb8c913b0eafb953cfb625dff109363add8cdd7cd7900a97dad406e0132510565ead57c2e2fca3d588175b0774ecefc05711b205add988e9fdf685f4621c4a498e7fbd3d05f50c360aeb1ba5e3415ab6379cd1232c7db3734488cdf8a4c63e828f35774083194732a8cda37885a5a16974a082eef47a37919cdcb38a01a3d94a25990cbb9e4358ee3291cf0d4c03bdada8e7d115d0cbc59d6f98e8b601152177c56d9b5d3abce26854e10286a2543ffde5c5f0b4b9b2cb8aade54a85fe57ea13f94f4e7e6b56f32e2a3a72f02986a800bb484d86603794e9b7e2b11df25938b003518e35b30e881051076006ec45b72f162d1ceef602e62c3bde09575f666aaed92c7c563d8b57bddd3e6dd7847147f9a700964e0f7746df1ab5d248fc42319e66247e8bde1b1deb8f4b44ac68b4a1e2d8a06c35e554938b46bb731e6c3b99b72472532267860b0a273b2b6ad94606d2a96e767afefcd89a2e24a598353d3efbfcee2331cd74fca7b9c02f83ca7bda656829cbffe1312f2662d73def8b04c175a1829b05c62634e1d313ad00f8719a30091178934529cff048521bb595dfcd52bf66e049581430d688f1d4b50414ccaa4d872f41d9828835bf8672e8f1f1b1dbac6f6a8208323b9cbf846aad5d3dc87a2e78982ed85becb0c9b51f98b4111be521b98185cb8983355175c8cdd07c83ddcdadc01e8bcc51497446e328d9c3063cfa1eff58efad2732f4683d759531c6ef518fdff8a8793953b826d8639000a2e76e6281ef635817244ffcdb976527fa8eb189a9a743f2324c14a786e980f372a8fd317d8fbf1f717ba23c62e96e3d6c45a6481f67ea25518a71557bf8e15b8fdd7c8b9d204faa142720ccad1c3d700411a2d701117fa8bd990c2717e3a2c7d6284f583dbc919f74660b314e3e666f7b7693c41757cbe0648edc615105315eba7be40f6e260f090fb3c17d85b0f90891a85d5b22b5dd9270362d93d7d352766b23adcd2a0520ad6797e5e58e35964bf152b453e8fdec282027d83aadfdc401fafe7ed0946c99b075e0331142ee4bf5c59d531e9d7a484a3d7419ca0d92e60bc409ac1f3c6c9f5b244a4a44815dce80ab95fae6461c982548a048d6cb9c75db1911f1e7411613774d1eaf49400bb6c42d8ab29c206bf3c9035355c7a22919aeb42920840af9a8ee6a70fecac1a3c80ba3d0de18844da165b9591997a877150c0a87957a82498625ba41d7068e15fc5c51e580ba928f03c1a1c8b0886bbebac8bcefe7e57dd3edde8d00f6f4574a9cd5ac19c721b0ba9bf5172d545d09e6d92bd11e7ef349a75e89c2eb416c26efc8eaacbf2641f8d313bed32f7f21008cfb3b01e1a902a439501253247295be50674c8aaf042595c2da9dd2ed1d651ea83e04a82dbfba0a36f1cdbc867bc95b5d65fd1baa6bccda20efbcd6d7bc2932917986d67f94bd4e2d81aa0432d7705ca211feb1ce3c6e72721afe57e773ee13d79722666127b435460a1d35b7d6d01750e64447cc57b9f49ee57017649b0605da81d6ffbdb18b238e5f8ec39b1aa5b098317a8e954f8d43dec59d22f23b95fbcd7e0dcbdd4d193772d07e91ce235d435d906c0c3bef881bd72e09c5d2fbe98a6ba7ec02a5cae0c20f3912aac3c389dc5c9b0db0fbf4a9923cbb529354140581ea16969039fee1d6c981484d22b78fd932b2c4e17ae8b83751e38338264fcaf17c1ac34437f4651590ca607c26a2e026e9b75ffd76ff011799521f6dec1386c96e47971c368e9d535399197912e39cdbd21a4c0b06ac3ce0cce665ce59db012fb6178724222f670b7999416110a2e6be7d6617e48eedf20b886c65b15492c61c6db3c9724853b8558c7f1f460b7a6789b395d984d0684904bc0ecf7b396596dd53b8851da762c800659d8e29e58c9d5a87b2b482fa1106010261e13f37d269814ca7650e947057476b043479bc3a598395fbc2d353e3de9c07ab27e986245a0f957aaf90227318b7d578c8b110c38235f3b8265c1774bf24d846cf458d36a7c5d26d7fe331f97ac6ec5c0777853168aeb6c97ad6489fbd0dcef463eadfb78b84e5af1d9207d9affd050f5ffbd4beb3c805c02c4ff23388effb784712ab65f62e37528a06947c126ba82fd4cdbef27b98379692095778aaec50a7d48a567d21bb0d2a5bdacb9b017344f95a3033b39f2a0003cd7e86ff9f26af8f99ba54a951934a73f510316b0e4639c8ae7e810873ab25b9df2df34bbcfc74db126b76e31a4f8db1e2d6e6f7770c4ec1c07c7e71574132e6579dd87cdda13d780d5bf9f6f13fe62e02dc3ed70674c491ed681a6bf76e30c8182b4cdf846f26570109f3082bbf712ca61a717d7f24fbcf07a3843dc781d26a3b7bd89573478bc5698bf1fe22d7b65aa24de4b132b69df0869d1bd7df7158fac5ec8158a1eaf5899fc644eb55781f28c0afa9701b6ee1ba0e05c60b61e10680a914153bdbdde99dc3142ec138f232224452cb9bcbf3339217faf5460ae98126b616ca1e230487cee4406734e99db7e4945583534adebe361c14677ade379150e212bd308eb3297a92366ef4c332fd9fd8f6799e8e85ddd4a2e895d271d92bb4fd5d2865876ea9675452f6c135135167ce5e4d01d654c20d587b6bc920c721a029e6cad8df34c6a3f79623361353136c69371c6d2694c9a4bbbe08e605edbcce43689477c9dcf03beb68fd470490edf89c6d5ee01368e80da6e227dfc6ea07d552d255f9b7dae9a76cc1567d52f34896ce9d270f2deabbdfabb59e7d811b4eaa8d24715208d7b19721ecd97f1c8215ce48ad143271f7d070ca8a908db7ae27240c8bf3e8a2e0d846daaea9830e30f43ee7aa971f43ad7988ff77baf4b9bc849da88c65b2161f9e2ef92a6a0b91b844147fa38352b0c4498bac0467a9c1116cc0648bacf5e4b9df8fdf6d266929fbf545397b074d4aeaebf8ad614a43879caac3f617cf987b362e56a84cdb6d4dc6e37a775337baee9fd7104e8b865de767ef3a72705a32b9645321e609d84349a1247b7a6a942d85ff87cc603e526db73cbe9437021d8e07aecca03ff0de7627249f0ef64f801270d55781589f81dce1dd84d56bf83182200d5932ca872a56820cf1c072b68f5de1f99a9d7daa390ae26d74a29e7cdf7694b1946437d4de3b34bd22afbc55451f838e363cb293d4e90e8f4baef68a867d968c74a1b3f465fe21be214dec09fda2d7ed624faabc01fd796ece6fbe4e2559283f46b3212c142ea42bb552cd82c6406fef4ab885051a8818d8ab661f432fa4168d65f45b93c0f7381ae92729fa03013e1d7ed9f3279432b0f51099551efdfe58d2cfd0c0d86bc9523f43b4e3e14ac8e9910131bc5f753b17d649ff41e2a0d76fa07f8ee186c7ddba9f3b6e77014048bbad265ae1cf41c624b9af3176425457e221793361feaccbdf22cd78c4fdce01375103f712d8cd2eb4b9e709ff78c01c686427a4ebc4fa05bb15341751ebff07ea2b117a65f5d74341e77fc667b31e8d80adbc881047433a23be972ba94e36c807f0a8b64d092347e1c2fa6d1f2ff24a6a94a59f20c5c7811f4bae8d172f26369b3152735a95126b167ab88af05cea32b4e7766eb93c0daca8759cf85722850b6fe98c32b83973b25cf53959e6cb09578090deba8ca5607da985345065a343f2811696887bebbf8f4c160a6efcffbff15a48b39dda3488ef68660d0523875be46440213f2f154ae182c2e629c311be0326f171060394dde31631ae0d2c02a7d90087a860c1cd0afd7eed0e70cd7ac89ae14351e101da65be08ab3234d3a3ed9478c6e410cf68d16450e6105786b360471647a8e878c2c9e19955a6513543b0c2383ecee555e7ff66518e7afde82599d1c7a738bba2eb206591fed94f2910796f36109b51ccd50397c186c2db917cd2e58caf565bb00541b81ce81c41f9aefec7ce8100300b22445fd439d020f40db5457ce752ba2d2c379e3aebbf072d3a1d085ae4bcfa22a4d13c2cbfdb4b8e19c7436b483709accbc6a39cd999bfaeda6104c5cb10ff2783acd025e4b57075ef6d80331cfe9cc99bdfb1944be050f8d9557dc287c762bc6b0f2ce4af225a38041804efa148a9aaaa16454eaf2a45445f301405dc3a58e2ad47cfaaf35a3c153d388c364a4dd1d5cde66221c0e37f7bff5c9ce2123f26e6b7dc91d229a69804c4d95c9c319ef74f7f21493605add90deeaf7792a4e40cb1cf732f36baace61988cd95f4364e84f8c4499b2a23d9bcdddd2954135779d0ae6e5c84e4e072660236735d62d724ef26b1e2dd73055a7b53e46d4e6c08de7f820c9c63bc67b0dca915cfb41652a8c333c6a562042f0a04579260cda96678ab6a3a3e22c5f9f22588989002b2be68f07e29725ba1ff0d46f150c5f7e063cfcaaab771c0ad6e666d7d50f7bbbca24b2a174217d8c1de8e9a80d8a561b9d5a290720dbe6b08ff5b52d028d5037ae2ef10e046e7fef43624ffe69020fb531aed539c9ab9a4e5472d9c524663878d6974ee9262a82b36808d40ce7e55ef9641ff3f4225e926252f805fb9c23cb7750c43412e941fcc1fb49c4e08ac6da83be770c8c5bed9fe444a6f21bc1a902f30b39723b35baadee64b3345f8280c5f9ce32e6e34aef95d28d81b4a6256488f025ba482c0dba9e25d7d0574536dcdc9100961548d6440461fd86fb2b75ac44c1a09c035823511dbf07819cdd11a59a1eba977143bfeebbbccb2846dc8aa7e7c72c93c7a3bdf4d2f2794061e549a5fece4f40a6be418c8577f2febf9b2db741436dd8ea3a4960c5ade74a1289e2dd180fca629a025745756905b03561ecbce301ab5b175a35857b4f9ce314cabd13779a5fd57bec0a057ebc7ee9b0cdfaac0b3ae4fcf9f8671dcec33e581d5c3d893b30f5ab32971ef6a41b48ea91e9300eee42c276dd2d0f588def0b2825af598cee72c00863808b34af77ecbf85ab3c71d80f6642eb89e7ab42265ef556eda8a4c09a88d3b8c8b993ccbc3d9fda54eb74e02434b86ce09cff936df6e45df4b7eedd4d1042f6ccdf812e132c089bacf119077ed45cf945718edd2a78c9c0a304a2485298152ba2ed09b089971ab9dd4a5af3dadc3d42381946a980286ca1206956b64fdbddaa8049c2526c4eeddc7a6cdba391be75b306fa6c8c4d2eaf4ca27d5153caff625016f6a8aef42108019fe1dd8c7720d010319398b18a8f4b3457a37acf18aefdb26c6e011e8a7e04f9e0536b8712e5d9cbb048f5ddc143e3f6651d2e90bf4721947ef9fd9560cb8db11eca58bb86d8db08f0674f1c6f984f0614dbd22fb1a54063b7030d53944ba8ca64475adadee22fa586846181da522667dce1f01d516b1cc87ccb20f775ce663ed867790f883420c13e3e568fa757698d3e87f295d47130e48471502cc5c640f82a812fcb1424f92e63913ac0f4d1ef2982ef6f4907af06f9ecab6e978eb641f1ae86e919c9f117f63112d1882c801a9d88f7d6cb99f7be411f6b083554e13db844995acfd5b4f6fe64f0ed8e71c5fb7816dd9e37e544370666388a3d5334f2242a23d005a194b9ced956d58ecd30d994f669ca5d70d342d770d423932a8d727e65d3d7601cc167a5b6fd76bd5a0429a04a71576981d1fcbcc0388a5f8f118fcc723dac2e51c03dc5aaf62d4d66e0dd9f18052ef1f62351b3bb0904f758ba573666ae55c2ee88a2c16b62cdf8de3783fd2613867a73764c05768e3aab3444397c15ba1c1c07b58065c11b020744555be81fb9021dcbc1dd3bf58cdb4549cae9fb7c39f5d8fe22a32597797b9c6cdb2b0ae71fc086ef1fe14be37ea2922cd5d8b0c2ba3b07068850b17b2df55b75124c80cfc20d78c5cd65dc9d115d412a227ffb8e2257d4923024d4e7b3dd7b2d373539d20fce5132186a6199708dd753c1d454d783a3e42a75241bc3a9950ecfe163e4ec1a5b81e1a9f84250455012ba3ce6216004146751968ff67ce8bf84e099473d95e03f7175e3d70bfa33146e749804f92d4b7749b1e91fa932a76adb8a9e647abe03de740d3a66d7c4a011b022fa8cb18d00fb0d3caafb6365e709018cbe6b0f61424ff3db366c90988bfb4815e7aad915c72680d0ba9df94c880203976b0fcf2c9e0535bb70932a732f6372e45461f0a17f5416ae9e33bef7e4ca28bef90cedd44fdd47950ebf130f80bf0e96ce0dcf04f17c11c8103978bf03c5a6c11d87e1bb5e1135e0e363c69a029f9ead0c2663f93dd9fef27e2e19fed51748d0057e3a71bd13fc8220abd6d44d6d0a95e2cec9f2f60bf208d0d829deb9a343da997c7207e56191bdc0fee1b1cc776956b603be77d905b3abbff32c0178cbd909612dccb49ab1708fe0b403229f0347b1c82a565f4b00c79cc546d10d8e5f2a67ea661641dfc1d31066e90b63932e2d456303c7bb02ec4525a529a7191fef7e371b83aab0eb04ca0d370b078dc7eac3c86b7afa74b3edcebecfe060f9f39a17c37091b7f9244562472941a6ec8023745d1d81a1397b6b3c6423df0171cc1a107c87e95c5ff1d6ea437989795dce8a6f30dd5beac2f4888d6afda9f26890011adcb2b690441f0b232d0aaf397253a9bbb855cba1d3d3bb3e3450380866911971e65de7fec2cdd8fa63033d691fc9ffac65d4e0e7474145950f740c520080652ed3e713527fef23a10122f676fcc922fafbfbcc340916e08e6986942839ab6506decb7d9f5fda872ce7257314f241e2bb8f5e39478dbdbc030067010dbe88d0481c040ad3e1c529e358535f6ed4e1df358d5d01bb2ce4ea7cb969cfe85e14c96023bb1a9c2914b0b98d390051df95d4669b4d7f35187365f44f1ffeb66813d7685fd1176cb20e5bd76eeaad92ebd1ff37fb9c58724168f61e4821426ae0aa34c22e00284b3559f7ce2135e22aabe0b8a4ebead208cb4429d0a7c82e3a8bf65261664187e994db515fbbea254e88c4f60083a3476506224f9956de79d024d8d714f956b19616fbf2426d42547867a63ab07092478d9fb02d9ef7b9d18223e066a956539aeb77d98e16d15460a9cf5977ba34aa4401b4ccbbaae920f06a50801d58dc73675a5f513099fb86c61c162573db9b4967c70f5995dbd679cfa6be27f0bda8f75db6f1f545de88b6092b320f7f8564d0285923cb5dbbde633802f0f1e10c4473fd171d16f69194fb88e25b97c8061d42ede6a724eea9c1b74a990aff59b67eb8e7d3333502dbede3b84e45ee8739151437b85fe44916b708c236bcdf2cad5bfaf8ed20a1f662801ed5e8c937d09e9066f08d68f3224c680d4523dee374e4e59f57065c974b838fda439df500832ea10d1786c268eaeb6137852079e7fa2c44ccd533c60371afac9646f6ebbdbfb336832a19b8b3bcdee355130bde72dd7cdbf8f8ff6f4a982d2f99110edb6df742a0ffbf4803d77d45991f85d61a152dc95175079b8b477f7458506589682680e01cb8e93c68a7bc5232335ea219c32613713a242833cfdeba558d90390f79ef35c613023200a23ebeecc4253c7bf3ee39516736f27528ad41e5d2e7ed45a4d228a3d5ce3767a813a223db37e595ee6926bab62e6fbe17bd57850a710cbc799f8a38f9d54d88a14213a520d7bba7012872dbef5a7cfb894c5c8a105a4dbf9bec28f5342d2ba9e0c69b7422c8c187ffa45d2ca3dfae7a4fcabf019ca26ec568315b15691c3715c03e8cf4e7d69a418ea4372d6a302c859679cfa82d57c6d269a74d8cb7af82e5ddb4d5d36a14b02eaada1d07cabfe8626b01bd5b4a31760b73a61a574ee9c75e03f64068b5fb8bd741b6c23b81bdced664f26506f45c6519df762a25c4813cd74648f58a6a505039fbce5a29dc35d2b2e31199ecc46c9d2807274713ed24de1b24afd225044e0cbe71e9d4f4422923ccef537d85d162227281cdd9ee8bf698bfbc90d0269c6fc9c2cf87e746dac53e98822ed891a0e6ff1d4378a91cbcc570727dccb46d8b3e8837f8073fc01cdeb94c17c5efad71936dfe028ce4027b10e86351315908b444904efc3c49ffbafadea92746e25550962be609a9257f32304ed3b8d03649764703fccf2e1f0de3b71b30aecd9fbaa23665be60514e79657861450d78fea6dfecba4d2a2c960a8b7b9695d20811613b9ff2b7676147d9d03727a277048812986a33b0f43d75811d02118b7abdc7be371d17c9a1d38e3c738c28613499febafdee4eec5c802edfd9cfb193a7b355682b87dd1be37362bdc4678265ade46fe17c4ef127be45e25244cac06361813ee19e675abff67ac97188fd4400f9f6c33d2c766d59b4e7abefb1b1a8744901817f86d250707ede9a8756f61214799aa628ae9e5cbc5344d5f8c2de4a646cee8d83e7390be79af6a8e7f8689969cf228646abc995734cca27d71339a60bb72318ca9d866b21de1c5f1cedce1c49957833e0382639f6eb2306f02c0cf4aefa9d41ced2bd8e457f75f5ba5e5c8ceb6948fec78bf5d5aa5d5d83e02cbb4a98c3e1cdf9a74659fe3a057d73d06c3099064d09b98083730b04188aef2b52a8a381121abb88113ca3813729e7fd26d539194dd76de82dd456b58a749bdad38bbb5c3629869c3eda9edf96f6bb59c7c71c58cf0bf17f61d066598c1065df70e3b438b52970907ed9989ca6a8f7d4774eee9b65bdf39e64a49378410ddacec0771a07d907abf5ac302a369c34fecd74444fc3cdaf5616e51793b5388bd28dd682eb6a95dadd9ac1f3ff27b5d0908d17a2c041199608869c7e70df37ac8dac182602acca2e347ad81311830adce1c1cd776b3da53e1a2c6f8163bd893f1355900d7508e61772174887082ac1e9ab8e0350e222517b52c27244d348a9e6439a9ae023f45ddabf8b7cf4dceed5331021722be0717b905fe20c595061e547a9caa6d225d2e1f4d44e5153c443c7f64d96d2456dc6e80f36968992f1dc39eb29f52f8d95771bf90f45c4df6afb2b524db4045e15e0cb5bf32d47da36a207e0937135a3569cfc33836fbe3660600342c66623b26780936d454cc514a2b6fc58df725ebe390cbb48e7e53aa9d50549d4d79cb84b32017ffbc6cbbffe0b6fde66ef83ff1ef6b0b0b996d378ad8534397e616033f9c818e66cf350f6e203a156335061c2979fdf1c0e2a2f1899e401590cc78827ce1d83c7c79219286d4d087064f78b85ff89921da60c6a41bf0f4d04f347ff5b7696fe5a7d88269a07506d24fb19fe487d3e693e2f94a5f66043fa5f730bce6eb5b3b0eb54b36b08c79e3277fd46767a06a3403fca33acb0b0910c6d5cda738d43eed144a203085c291f44bbf99a802c0c09aff24474f8224b5fb5355c77ae827b8f8c99593ae5bbc7667c4e16dbf1b2c9e34880dbc1f70c27776ef2bcc7e5f6d95dac335e0d84a3cf151fde552f340c19c6a449705c6075e1f8229995090d4ee7ac031ad638609d61d6beb5391215c252e8290092e98e32fb7d7cad6ece2a57cd26e121aa0dc5253721812265c44da59146b5db690b09d26e00ceec74e8870594e36e86912902a4610cfa5afeebf59e502c0744e4b0ad60bdb51cd66cc57ed53daf75b06fafe5cf2eaf299569fa26cb2af4b6b6fc40b7f05cba3288e1e5cf961c5778863b1c4059736a72de76d9e7fd67a374657c8f09b2b2006b6e6d2103ad128ba3468e40ebb79e4e2bf7e09d016ddb12cd15bf53a5272ac99c4946c1e3809c02a970b47bd621e5fe497fe82616391cb1c9f40686b8c199bb8b699c1a8413af7020b082c403f927b4573dfc204cb0db9940e65c407c2cc2bc46c1675f82e383f3e040b10944b8936f2734e8a481ab7c551ca8415b009b87d70260e2424ee33f0268dfc3c7315391ff3e21e205d2bfceae8b8beba0cf92a8c76ffd92568c5f28cf9116f137e97d49cde9ebf3229a24c123872842b1267dcfb65f685d04d0b47db4228290b75afee4946e6d5000bbf99849002d55a28922ad67bf840f777ec7c1d60b49b9c7e480e0dd98de93a0e99fae57b31bdeb711eb4bff615d6d2ad404aed7b3196166933b1f608a978ce5d723e3a10305fa39756b513d9bcbe2bc70310313f33a14f24d3a3ae98aca76be243498198caf9e68b7444fd58ae471c4b6cbd5a17b556d8ed58fea43516fb8eeac69dd62fad01c1a5d3ec1b1ebad69e39c66e712c65a695bc17eb20aae6ce73ee690d72316bf00ceee1249c2f8592fad35d4a22a7b126580742205f41c1104ace875c3693e2773cd25592cdbb47fb7dac52f5b0fd5300837409124187b83bcf6cd5ea31501a285942d9f499ffe5ca9e3d42354708deee568347ab9eb5366bccf400c6d94bea529eecb33f56142bd3a790b70a236ae0f393029346e66a9f28abe3a3f9ece0e371d77212c38e32da6a0f83d622381103b0d74853057d8237279afeb15743b7a490e534c308b73e370fbf38fe37f66d6a8476fe23cf64a18ca78daceaaa7c529b34857c4eb5553b0ecd0d1f175692ad889d4430f6f8b31e90dc211d7f39bf8cca7a44b3a93c941f628ce3a3f45487127b1f2603c5e35b13f85e3136d061fcedf45aaccedc19c373b0878e35877ef1bc51949cf56c1a1284f8e66f4f6f38e9259d4d2f680090b06bb463357c9599f6419a3486d4b90a773381160f2046e08e3da38b7e248fbd6aa1ae21eccade050622c80af4e5a250ada5df32b712575901c7dfa753476b38d8d8f606979929142c69199ba836cfc15f276b34bcd63ab90d2fff3586496d6236ad8a95e6bf5e125b18d216b5b589f8ec0aebc86ef47d7b3646010471aef812450eb543748a8e1f1e3fd8a4f496ab969b7b4c904178c637d7ae8774bdbabc081d06fd984347f894c4380385c9d3dbbf5f920b93f47e9803f0238212a477e02f29e4494c6d28108cab2d3104d672f38916d9bfa692d838b2b3ee72f5c4a4f2c27968c483f32ef054147a3eb3559da64b52ad8f5d480d8f1edcdb9a76de8c2a64132fd209705a1a3134ddd48b1c302a8b8f4cd82d0e1511c02590c2f254879c2d644184d1411bb043fad91951c643082dc2255b786de784f3b2c4a5d2d15222eb9ad6505a96c5ec7a221cb58ffe2a3130e11fa56dc7e48acaa4b0cbb22d5513b8f266d489ed1f7465e54b33792fda10f2f6a4bbc49dd23b49daa71d66cfbf7e105b148a59f501496f9c8dd40438f74ed825358056bdbe77ec9d13d88316f0b1f45417c7e45d9526566479d9a7e01a9108eba247582204cf6fbaa4826d69e782522f9bcc2b36c47e43e022e87588358805bbd9e641777c625c052a52b91196ed1aa3e42ab44ec5f4078e385fb5d5fdc7f3ab80dfc5e4f1d5dd6d452af571f89d361d865df29f68dbf52505e2252f3a7bf200ad656d639fb1f973079dc813dfda748f86b892d8c758530ec5a2689495cdc11e80619f39b677236232ab13b720900786a48b2c209ae352a53ddc2a18b05210d1c9372a9f7b9559f5580f0e8b803fc18f84d2c670a62fddf1961dc4bfaa0e6a5b1e8b9378f3cc0a8d5fe3914f21f925aef7e6b389a401b5c26f8da04c5eda591b5c12c5987bfaad7cf9240fb7b9076a2630383b6953ffdcb42c35122013dc33c54d6843e1ac3de346b5fe2b1b02dc6432186ac5c5220e6dd180adadbe7a77a01d6bcf58a8b317b0a39433738e41ce30dbbf4466715c0b2eae0a0ad5f33355c6031e9f4589170bde3f64f36a813c176532dcfe16609fd00cedb0667b1b0b83b9b326723fe2887e14094a53bb4d575514de6c6772cabeb074a12a5875d6c55aa0aa7ec2ac918b9f0f3c900918b3b894c5ef3478f14763c858838c41af8c32a0c010dc188b9c1660e2c0af4c8c2c765ee506dacd6f324ce8691cb4ee23a6aebcd5627260867c1d90602b1a7801cc9ec981528a4ca050746fa2ff9662526cbf3e06fc67ddc74f218c2c1ceeb5fd6ca37a3ae0ac9acd32ab86d0820f64322ec7ab94810e0dea555ccc223e3ade9b16be19a8586c4c6bcba3266cfbcaba6fe1f77aa098aaf57e5044f53c272408fd7690dec3672ab14880b2821e03af3e21625cd1ebe9ac0fb4a0cc376a4342159c609bca037131f734d62113b1abe9abe02a35f531e7849e48b2c40816ac94c510ee6baa759ae198cd0923b0abb80817f334036131bbff4ac048030b44b8b94476fe96834afa2e0a976109eae26671ac95a5574f83860e7496fdca648e7dc175c627dabe7e1ed2f2cf3b8808242ec44a07508eb008241840cbd121d32a5c44ad7eac2539fcf5f08064080b8d602195ac9ba505c9ad029b3b7f651a063c33b494d36c352ea8345d97eecf64a43eafefc0f9255259f3b072400f16f69838a71b79c9a251affd678fecfe0f9b3a7bab01ccd09b0679103f156244ccb3882040ac855377510e44d31be5d7b0025600866dd5fe848399632dee350bdbfcbe73a59e6402860997d5fe508af25152841bd4418f3104e77c899030e663c3f5096df285bf409d3138014c32b823f19c8afb9d3fda37f5ddcc81a888367f6463a93f87f642196c5336d770d0887b92a3158bf0b5bd1b70d473a34e525700d6b2fbdbc6fd4606788a1ba01c85a809413472c0882ada5b433589da33784803a301b04b22d34a5a3621da749dc32b4aa0e74f6937eb855e81c197d138c2bef8a542148b21441ebdde9dde3f7ff16f98587c6c31643a5f154c39e375fcca77d52f680c6f6d62d530e3ea7a88326ac583e4e9edaa5ae540d8e0b93a80126342ad8fb371e5add2943f2f357234e05b0337ed2322e4d7dcc5e36c9396260fdd33a29a9d80fbff0decdc19b14a30d46e70bc4cbb30a43530a9a1828af23d87675d64a3e587c8061959e0c84247caaaf10a773697361cc758a769ba118e9b9cb8e7a279e15d4f3ab37cf24559701a0575be59370bcbaf363e70fd339f3e964840b5d4ed505fa71f89ba1a81604d284e9ade30040b5efc42a620438d12ed79da0d7cb0589f21090449f79dced4f86b9db65f41cadb61c311f5eb3263a729c0865a671760f00bc6878c4a55cf732551f4927637ab0c642c62956c7647f13b3d8323969e77701062703689cd596487d0772e7682037505e0609b4da0ebabeef6aebb8f084b858244001ab2d6de87880592ede390e1e1855b3c96c56521d58abf81c3db244ddd996ff4b8a3df0048dbd5b31f6ead96d5b57b28d9a18eec8414d047e27fda2b9e0d897a3ed5897380c7b409697cac3a41b6d0afde1b31ef1d865f1c89390debf0e5d005976d36034237daafbf757c4c2cc1450f1f4b07b634a4e09838e424aa04501d145dcd39435e79ca6b5cc8c25fa30858b05ae0edde8a5d68dbc4ad0868f411a2e70d2d8df8920afe6502c13c23fa29d4cdbb1ad752e95ef832d9f3279c73fdf6b7172c980be44f53d898f623737a5d221496a6f6e98ffac2086cf0b32ebaedc6265460d81f8b61443cec97c7bc3cff48396661fb9070c0e040346c3d1c39cbb96b678ff9c2c6cb4eb14bd60da25211d8683b5af00802d0108ca092d938a5399a6d8c038a43cb370c28f7c1109925ccb2357bd82b8ec90a1f48a1aa5bc6f81888a8e6662d9364cba51a5cd152da0f8a7686c1748487adc65b620a53ad8991d5996d32e460425edcc340a8cbf6af2d6c46d8ff7fe531ba867c78271804ff7a57ac11d30d52a934071240256001dda8d7eb1513f628a5fee315b380ac4d465299066062b115e28c78e7298440fff5e0d94238cdc1d3fbaaccfa4c28ccda57df97cb3af3cd77276a1ad7c041663d7d67c6899e19884adb3e9e457d772d8d395077273919e93125e9b9e16193a3d77933502e236504a1db9fef68d6505c8b7bd1e22749c15ea37ada3d4ae7d1acb964d795b87e5828768fe18517049dd1738d55ed2f4ec17698e994e88535dddf3471c3f4cd7e496069663608fdfbfe6861fdbf202140a524959021a3ee5b775891febab8c5f9dd38db874986d95c02ecd0ecbfbc74ad5784fc1d848300e9a91e05dc7074e8b4df13bf721c98fddf36aa7576d324f66e7ec1c712fbc1fe4e6d6b60973c3cd4070e8587e1537869144bf568f7b521e37bde7e363ef0bdaedf20653f0dfadb7110e4e48bc7efcff20f212f15ebaf1789c59643da9b000cad1d6ef509886dbc507980496e9f6d235c0ab250b605a2a8c13cc2e54340570286a5418c75344473ab8899873d4725dd6071bad17e1b627527c3b56adc2ece099862645d92aff810590e5d2adcc6e9f45a4c1366552aecd00fba95d443d50bfed0ddda8742a2e2a26dd200866d6077676803eca6b49dbebc3ce698751b35a9e26d99be4942db0f14eb74063c3805307dfe60fa2f58ff45495a8db54475aed25b331f78a7a59922c15b05815e33b925a75e21634c6a09c439986f5cfea1c5cca08d19b4d70dd9d4c09305d89755427d957d04072d3b70bb9aaaa8e29e4810b53b946dacc97fc5b1da369a173e80edf9090711d27f852ba14b71545f661ef2eaf7476ac058e8e78a6bc549d019569dd9d566d8866047fec06a79a729601566187b0838b8e90cde5e4f9cf011e08b6c7d33274c63d1d27b33619f2f9c7f179c38cb671d763889966a1b35beb8eef8467a6bfc3e7d2c2983551c0b1708b016407c49f2eb7767ae3e7cf1b7528c36dea85f4819eb8fa2d4804c7c4fedc4f2a7a990fd821831ae1808e349f1be96aae2206ca7da513ba5c32009c6e46dfa8a7cccbfac4c7766cd95e7b66da4fc805820d70eacae99b6a1aabae7fbbef5d2abf3bb5b61735cf917b27033048f314a6bf6b775d77526825b77892f8f81337fc950c13921da647122fe80de3f205dcfe24712f67c7670fba0af6efd8d30569631c0286e41b462c9c0d79c8ded6696c7cf860e8bf2e95e889af9e0f9f59daf57f21ac322d72b505319f2b0f99cba55be0c623b460e51a865c56ad491ab0e6e836a19795f099bc11e7dfe315801324e943ac1dd28983efa487e1ca53ba57f6b09eb127f7e8b15dc14741da4e737944d5a28442331d4d1a6c304992f971dfcb756506304b4a3aa1b0ff6709d448ed8ed282b632c3e4475aa8213cba64ec07f8d72fae26712287707b6208","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
