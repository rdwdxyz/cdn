<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b483714a5dbe578663c65504c23f4c227b33ac0f743e9796daa9e7a3fab4267efb460680eef64c8b5c34825c7a452a331e282e7bab3a77ca5a31c14e421a06826920a7fb5302475bd71b08badb019a0b8e24a8295ca0c715f2bb8d248aec38530e50c76f83d4038f9494caef9ef8a340e830406dca6921002de1bc9928e116f5e733fcca98d36b72598f34b9fc18fda908b3ef9a7139eff58ab2e2f90172bf77bb7da5c5dc987ca779debcd1420569cdd2415e43197176a790e457d01c38212c96ade9c1f546195342401871eed2ab515f80de725b559fc1a3d7d849ed4758ab07a3759ad90b01784f3ff0d89a23bbe817e62ab1283d29564008d00dba4a93165d180e290d45e19d3268a2fac11cf99e7b52b8c90fa68101d20b741d5dd449f43ff4c303f2ab572eeb8b70759ca11b72ae17a73e05e09020d4c42dcd7a24221b6cc236850fb0af9e104e055b07b3086aa10084d94d34cc4cec1977694d4342f9a1be83f6bb73fa06344950fe12c8a3f0a8dabe9ac1307ff2a83d28ab748a38d1090b6f8e4dee1ec0bc5bc09d2c121f5de59e8bf0f26d068a6e8418c638cd2519f0b6cb7242d9d12c619959e5e81148f60c30b4f9688afda3eab6b7ec048dd6feae0501202c73ecf181fa9206e85696ef59b3b083b676e0655a8f9d434a64c0242b03cdc3bd05811c2b4fea23d26aba7890d1fbffd8db0b851844686b912f748fb38016554c8fbc5f31d957061416f3d8c8c67baf65303a16d6429e36432235128b2b139504e4f4182c8f589027d01ae7960330137f576773473aebae03051459bac374a169005426009c0de80f63ee20847dcd76f04045602b9eee3082a341664661c434ce4f27d06c49d7f8dc4500f2c7ef2fb8a2c89ae6d0baab707c8df8345e0504b8fc5d7ab22d584284c7e6a9a23f418738dea7107502d6058dd879a46992daf14a461e4eb797dd1e6506ceeab59f763fb8b6851be59130cf33598cf5b7f38102b157503d7a87b6b84bbb80f0212023a91e152160856e55fdfba261a86f3f08d1da50840c5b4294cfb6d36456435244fe96d8f33b235ff082b714e297d1a260f99112679865e809939c3fef0dad8d4f7e0bac3d62719f850d598effe4fdd18b841058575b98e5c4cfcc9505137d58f7af968d88a5a62c3c331768d3188428ea0c90e29ab7e5796e62bec8e5905f1ae9078a0599db9b589e42abecbbd8b11dd4eccfd8f0e59805e4aa7cbe8607195d335874f3fa965dacf76cb7a2783bfa0a1f69a9bd4c9e16b8fa293a14c5416646c31a6e5dd0000f566d5eb9ab27fbb0c41c9f771fc026ff2289a4e24780702cf50f48c90b321d37880a5dd0fc966606bc60cbde20e77e7a7f5302ffa90e51d782676e04403264b3a87db1aca4a44a8a9330e5552afb9da31c98aa67bef3ab8e0608e6620dafe98943dc323fdce9a604f6c81697607c9b46e547b14619c7028c176af9e76f03aba0323bc00f29685aae4cd1aa25283cc65b21d0f4b9d4aadf0ccd56706b098f9fe53391984616eadd1343520364076bb201d817f5f5e2d1ce118eedf5321c22c2c4bbc3b5494cd3599cbc2de5b07f49a94ffe62a9f3704a547b1f2ab9e5a1048a74798a67c80c12062f47cfee48cd8cc4e2dc9c7277e36b1d185b1b1d7a8c048f09c9de04a2ea3fb912601caeadf0b4567c67e7db295f3e31e42b0a76e68acf4b123b35d045f02bdab1c6a64ad39171f1e875aa20cd71deb6d9ce3336ce384bac6d4b09587d3e28023c581a4606ebb62900423dafe71251b0f1e6bd63c129dad051917bafd62175787f64b2f24e6dcbdc4d0ca2ebc9a6f9c236068db7ca00a4cba4a6217eebc9e02d6c513730802adc0e766d98730827ef09b7e3f631fd83f1e4a1a31a979751dd1dae32c95840ef547f383908baa81d3d36723a3ca67caf0e35670a3a96f6712fcd15d8c3546820f84aecbc85e6a36af838a5164823825bf883ff32015b5806e7c2d3a120eb72f52a2ad9d671bd3803389d2f0f8a7571ce4842c5646137cadb624ffff27b4596706580c65f7a8b20846e4a13d37f09c3a9912d49c7f5430400fd229060ba70c2efbe9bdc848a63af80f49de83c51dd15149b99a1bbf7aed3eb21c25263cd4f421cc165e10aeba827d35bc736781fe69862da493322687574c8b2d07ddb978e03c310d428ca1728431e85851656ae046a272721333febd640c0103f60d674654dfb29e6e7346e34f5681e37e71f6e43184e9b4a70eefbf889d403a5dcc2ef43c4ab80a5bcdde819a6968e64ca1b16ee2adc71ee63174403da78923dc9e4af23d5ea65b03b311870dbf7a7efba0e34b28c123a0e0474e9af46cd07a951b4d1dea2704b70f099aa049290e38d96b337d52499fe8454a37e63c07f0108c0817842a6455be68a9590fc4eb43d40daf8e4ed6e284f8437dd71c31f5c467b4a9c19f0e2792776772449d4b248be7b534819c097d4f1e38504390b3d1e6043a152954d9883c9dec66d31d3531e71169e7f53cf8a1f7cd386370ee296c2f1b5986ef716ef5fb2a3afd39eceb80560c47d9d0aca55c9eaa67b2f6ed9a7c08fa6e712ee78b4e0e3a64cd907aa737b814041f2f6d9b53e5d714e9afcb075b122526c2989e5d4c63ba35f2cf18de6df3a517ef88c22ccd2672d60aacd6b21dc61414835f4c2bfb0c17fcc6c0880b929e912c0ac78603ed7bc09cebea470e2a915d87bdbedb102bafefb8e9e5ced12272bba38b149a5b1db89e2d9a17311e7f72cd0765143d3b76b5e8cb4d73f088f90a15d4231b81a3f9d745fd643e1d262c7692f9b03dc73a248d36b49e823fc5af457490619ac935979c4a227c1e76eb309ef75f369d420cff1becf84e13e66140a3687251199fbdd891006cceffa1854686a8431b1095acb9e288bd5666a17b70573ac57a207be3214b001a92b89662f0f56c3f7f9494c47d319709c3b892443219732184b90917d5a120ed33a0c6511fdc8ddb605412ccc336931ddb6bad981a85a54a8f51ef8a711dc12873a4464cbd278dd314d9abe4f0c089388929ff8f0f0b3c95d185a2c0b914f747e3010bb4286038f2f24830dffe84a9afd924daad45ce102febb452da968113c3e0184201ebc4163b02e05ff84a20983255ac1aec6ae4b6bd5aa5990a90a8be3638b566deab19157600ff07fbe9b26c95b7afec53e87dddbbf7e445f7b3934e2a89917f424fe5733e569c76bb609002553bf0424b7e7465484956375e112091ebfee99cb24be4bc7f6832d957bbfd372419714b10fc9f914ed368ce11e49fd2a35cf0f80acf3b3bdadd2a1396507aac971519a1d3429fed269f8e7c5620560e7f9a838248c140762ef5fe6bb813d0d12bb39f94c21d45321b0f8ac55fe63a9aebeac15caae397587db813031916511ab0e1754db899f6e2e5435e7340b2c22b3c455d742bed10a534a80c92c0ba5d427366d288c1a18c4fec7618dfdf83506b889052e8b07f5bff013ef64eef422e87e99bc6c2fe5be691d56bcaee64ce33b16d3a74808910b98d5aa1690c9ac37f4ace00a001383292dd180f128a8bb3312a1ce397365bcdf5235233ad2e72729eb812fa12aca24f6141701ed5dfd7750793b12fc5a5b0a4905649e89a150b15a1d19edb5b53c794c8fe6fc093e3496588576326639a94adccb8139300a5406f2d5102a3d2aadd775fff87c9220cfe91ba9aa028e17ec6db2b9cfed56cd3ba346a723ae51a03a920d34bcd37a2759437a5601ed41381b5f9aae4b2e6f32d2a073d6bef331c5c4d69bd2b86df2d9820fc8022032e3eeca97d95d951ca60e97a40f4b75981ce40d16e8977b8d62a16484c406c8ea7aa0df025239c80ae2d3cfa92fe2043bb7e4b5d808157be22aa97c5f2c5b0508b1fd0611e8ea0c8653b276baf16294b4c04ac8c623e44677400fe975b7b04c7a2c0f49bc1febf7117626680f79aa10df776ceaea09b88085f58abd1fecb97efd1aa516d25d651154cd80b38e9d67aed09af9d6eef4e4b1b093f938ff5b6a3756ec6371f88e761ad2636f7564ed4af3415ef86e39757003f90da0f573258fb414d784210ab6ca07b52184747faebac46cea7291d550088a066d8e9facb9546246d12f17386a9982a7c7821e2e575d14719585fe414f19dd495ea096d0cdb61fc73a6bdd492dd9a80f9c7547e2be0535de9c94cb55ddc5822b62bc4d6078c4118536ad1c870123b48695460fcaea9c15ff768b348cbd5abe1f192110fa2be43c1373980a64064019643348b8d9df04f7bf9a31174437ed678054a88ee3e1db29049fd19dd923e3e56c7f5274de461630ff432c6d2d760fdb4401a939809eba04f51489598dbdf7e5892c2e52399ceb4114dc9ae6eacbbc680fc75e89ffb640a46585d46e89466d0b6b74f215268cfd5259410078f436c1aa813eac88cb4f785f360c28b29c042045afb8e046ef45955e29396215ed00e473a281393c63f8fa26d08ddd69cfd46c5a0c6c093744587b28c7b536844e8a6c776489d209009864ad34f18e06d5f5b8e8a8cf40a3c96657489afcc2ae7bc6cfb8000847f38ff3dea43f612052c83e54ab138a292d7970a5e37872209298c03077ab28b48db9581b9f0f71623f29648c8ff5f02152e8f69f25bf08affbaba9cc0d3c2e191f32e1263d1c07d6d649c7f4c346471419eccc7b8e3c17d9650a5886429e8fe37c493723b178ad188e80f66d89aff4e5dd3cc5c11b8ad6b216a3d449f4df4dba6c7110f56ad324ae90f77f6b3bd22a3512fc3caf07a52512ea285325103699d2aa7cf0063cda88b4c0ccad7b6a97dae40b0da2ca180c05094fbf5e280dda22135670bdacc43d9276c7b2ee4f68efdb77db50ae663f7bb0535c23206bc4ffd4d8c7442ee3aa4576f8adc0a958e8e148d5f1e9b8e51414e860d09b5ff61bd7df840bed27014da882988a12fb72a24884be87d1ca50d9f98e1af425aa59b32bf54dacda4923a9f864af6c905ef062e29c3b81f2edf34c814a33fdd98d8ab8c5dff362c74cd94ee9b6b69a5193aed0720c2799e88c60e99219153aeb758fb3f9256713354c6b89c9f1e53f4f8ccefa80e0ceef49b7d4337cf5f0d763a3b5f2beb683b4510853eef3af584e8a55a168da5277282962c4fe8ffc10f31d4cc22dfb39332ce1b3bcc4fef10ebb227e64d5f605ca319880216c2c84ddf01f933d3f3ad27c1ece07a395270496ef41fb3d3eb337776c3997d68d68bbc7b5ee4e2f96f8a4a104a2a3405aadba81ca25732e61ffbe43d4f50e9683ebb8f7c8930fac6fb346e04ae09dd86f6e4b007434776d912db92940360315e1934028763e3989b3b2946da79baa2ba48c776ae35467fde39f1c6f493155cee844f41bf5fd9176e8c6aba35fe072bc237502dde45e6648645fb4aa95f6bc8532d86fd7a9c1d65cf7192bdfc6f25cbf1c9adcafa5632825e287bfe67e88570ae650221fcb27fa00316b4736ae35038241ee2b35a2d992e93f7d73d2235c2e0153771f8e57731cce0559632840618b4f6d2ff86e1fc02d493a85b2ea84036705dc9c698f4e8202dea7191adc66219f719b349f4017ed13497414311392630f67af1994473a6e922a1311811b5e5742c838ca1def9a0a9f44e835a1da11fe2e39442711b0059b5880c71e34782a517ce5a379ae25ae683c1334047463c869c7aca7f89528ce70ed15be02ef72492b3881f0079c0a1b002c7d838e636055bfa327b2795bbda018b189b0f110a4af62e0106d4ce20eb3326f6088fccbf73233d0ee3ba525e29b85f749a27c7b351e6c4549480ecdb84248fb6c041167495c99c8d30dd6f2fa81873d6bb78ec50a4f76c7640f3eb8878035729676457417b854d2709b89f4da3d46da6da7acede9aa3b8ec5834993a3a070f57bf1bfa8ee19f3d7024a4ebb34a01e7fdc62771365961897f0fdbe25c156f35dc9dcd2523735c3ef809771fd4c6f7ccb3f8c7ed1552095bd9677a266486c08391ebdd1b45e577d2dec3df2526084c27482f93035537fa9211a490b5d0c19a698dd69bbad61ac0e8141b33edcea6799279799eb09c34c50fc608a6f4abff07fbc1f5b169a51c6fbfeffe8690d0addded8bb2b69f5f2044ae8a884f93c140db2b5a60a1155cc61181d8ce046e8e093cce9a4e10e52fe004ce9c862b9da12e19b457e93b1895137514e6b990e34620f5eefc3b4df99f2e5b80f42d384661227607285a68e130ea8e329c9ff5db31b528a23291b64339a4105762db578f73399a3ef486520e34377050989bdb697b5fc9aaa848715dd115f7297ea5d9fa0ecaddc54f14e4ad4114fe43d44cdf4b83d7a2038d38a0e00be3c2cf06d32b0a80d62d471a0ed7e1fe8d0ed4df844bc3886f01524f8a6a1888acd4db821e45e5bffeddd8e49f2c59b88767f2b4583bd46340b0f6029a1448e6ac8c9e7507c292b2017c303f4ecd0fe35081d60bc3e8b72532645eac8ffa18a5224a5851e37e4166955220b0d40c5ed5bf7f13d0f223f66edce62ef0ef4340bee6a72265bd1d4e1a13b9dba981607d6ddc1b03e180036ec7410288349cab73944529769ec916e64a7d490d0b40176ddfe4fc82835c8a19983478b136d13a0ee33dfa09e8a8a52335cc4b0fb6bb2d30128400381558685c3fbfd4b390b2496442e068d75b2285717cd9e7749b2bd446472dc4073dbe84ecf66438810e5eb280a5b061f48063f997ba33ea5b00ebbe12319e20cd62771a7987a26a076fe651d355c9616d4eb5abf67eac3597242c608e87a2609cd9db308bb6b99ebc015773bcb59aa2476f283d179a8ba318b88dd17c3ba4517a770252c3ac786e4ee00f54650547882d8289418aba2253736258e4c08ba9ad20e5bf2a53b2a14c296934268057b50bf4572a55728ce728b06e810a4c810ee5edd31442623b24f47a97c0eb62eb645d7c121c5faf7cdefaa5d0de276132d91809567b8ce93fdf596cbf726725f9fd5744064d4dc48556a7c422b55a52c9b2faa0ec4fa1c3a4bcce6232007fcb63c669e8f3c86aaeeee257ab298d594f5871911f60c2f53b287c1b56c382dd4dce05aa981b7befcb32f79742708c3e875895f5debaf54dfb5f64ad663f536bb4543da507740b31b0762eadfb65177109f7fa6c08b336dcad75a6d71c8196083d132a95d6ce518ced83fcd8fe5e12a169450252400d867f7615c8286da74456b5b641689be91da82a91df6539601a9013b7b7c77bfa1bad2431f7935d1325f6de927d98cbddad319714ab187bdf55a6c6f6cac73b069090cc56ea4eda635234dd36676bb6a11d88104ce571a1808f75941a8bcf3e1cd5240cb3528f3cded3247878513dfd7201aa7357c5455cd7c4223422110da222d5936369c774b0f0967cb0509894b7e4bc2ef7a8c504e4095162d18c0cb6a96f4d7d0b2b758bd0297bab32ac9ca2da99f134dff80f76cb0d94fe70f827a94a2b06fea1d32040c3120ada6aa109a0447a13d80a968b7042b989925ab2c5be97b7e8dc4745e1bda8019bc382f57333902da0fbe5b63032dfcd45d4c49a5d11f2bababb002b2ea3698e67cf7dae0b39e08a9380db0f5cc6c05a78e6110661808a72be3ef2c35f20189fef966881cf8102d74f298e3864c389d1d57f333312dc4ddfd191a97b299e91035dd62aaa39af325319e753bca61bf4479164545a8812beb754cf0f468ecb2293baae0385e37fca48c971ea23744e239b9b4a844b0064845b9c63f7ccac9c9de3555ac046f3ce7da3fcda8af2592ce8df5de5b8f44b8be8f38306c1b3d16525514b89e221d7e6120ff4eb7659a2e0bbe367da3e1363b529e831fadf048e60b974079b981c7db3008c96d24af0a52cf34882c619f995ab57fadc7439c02e05597bdfa2afb7d2251bcf43ea6c8622d7583a2b9e036047a609a810a081cb39a104ffe05713aaf324a4dbbc4b39e12aa25f6190fb9af3e3f370e7e73ec4453717c1cf69fa61464182e10e5bd4a8757bab64563116a26a2c7d90e8224161d8980380f66a65e04035552177f981920b2dfddb8b73b6772340c8caf4dfee4ae0df889845d1809bfb9deca5b2d2268ad9bc8347a808b0dc2e7a1749f72793f6ac5194ffe6c518f0e1d7d92afe4b86cd1e6bbc371d7d79ad895d012a32e8573d80d9f6215e11194eecbb2d078ca2fdb094313008ba1b482384a1cc709117bc47acfdb4be709ac67a47a553f420f718d809507ef1c7ddab1362762bee8ae66f291c3f922ae0c6def9270fa543f1fc2d29ec27920f03e8b9f12389836656fc791f7ecce24821e2c548657619ceda033d39c83d6a8a8eb88f54f386acb3971d0ba4db0d97814011a8568f5543dd048fb81bbe4f00cf66e25a2165d19da1684ae4bb67a96746b9bb4a31449395657cc7713c4106261808abb77c790ed870cf1d136b11bc8673dcde578267be7374f6cbe4eff0c64893c0b6afbe505d20111e8fcd6ea1e81e72636c7a1d59cff80e63c46cd2ec5ebfe7f6c315ab9241362aa51aca86a4e318b6c0689f26f733b4a6a2c31c04659d0de39d4ad56bcd8cf7955ebb5cf2441f80e6beddae226e0633c8c04dd5d808e36917ce15742dd64c475f48eb8f6b491a70b3184621e7d779ce769a1e1bf9defb2dd1c29b16e029bc7e885f42970a454853d1ad07786641e5b2e8bbdc2f87b08742d6d3f957a6f700b1149baa5d6cd54febb987e1218c1279990b23a7eda96de7821631ad24cf90bf06a64f35b2bafae30d221e666bec82c1280e2ac16a33701585c6aec4c0b5442d5c8dbcf2dd79da47c606ac290606ae210a40c50593df7f4f284a74eb433f38a7428e0a2ada65f42e217145ba243e4a2e8d67af5391e2a393deaf9473605a8c71010c607df09c099fb15dd3a2c78d1966837e6aaf5aa66b50374c4e9a7a4d0d7c35317477ef3ebb49e9db96126263e8f6e5680f04fc4783de1b6308dc98ccb5e21ff7ffd000eb6dff0c03535b5ba67d851b84a6b8b057845aced23c1b1d03bb0bf2fdf5a5ce777f36f134a90df503657d8b877bacfe4a9b328820c2a778948e57eedfbfe51b17c8a4c0e1ebb5d0fc0d51cb1f975f010fe5082cca764a7ce5c6fc0f0a9ff1ebfac3b958aa5f450380673b0b5070a52967c54c81de3806001b12e806d8c294f8f44720d82a4fef536be6c4fc434a59cdae806fe50a0c703b7e7a1d3c8147323d663bd043fd04c08db887e1658a85a67666a501551a631a4a623cd1b1e91c9f7f513df70197629470dd19251a947bb16734efc3b302b70e4c8800ca1eb4999125e8fd8c9ef5640bbffe7c113a746e2a8091151d4deca2296bbbf9bb62dc53d471f8239c9524fbb4731abe57189dd530b48bf52f21581e45fe6a6d50aeb7589d44f69ec1c18be78dec877a857f26bb51f1d0120b6bfa67a64269dec9c773ab7191279890ac5cc9a4d7b2459473da2468a8c180095637a05abc32992e50599af636196496e8b8e0fbded798fb0c36eb69f940ad943bbe8fca3be16118cfe4a9d868aa61a35ca877824cc76bb5a3d3021f600c298640436543bb7a2e65953da6e5c43f17dd4111f6094d5fe9bbca2601def32957cb3ef5d0adda9d1bdf35160a1e271e4a7159facd15f0e3a79c18b5ff9ec21c7fe86f96cad3361f26b1c8fb074c4dd95090e31ebff0d36b5e982de219ac2ff4a6abacfce8a925d231b42514ec1c49a2413a477563eb6eee31a57a8b28969046b0639d8b5f19f9a9cdc21996fa9b9f96c4621f1ea1e24dfe5e9ebea695b607e06a0369a0e2a289349bff7afec350374f09d8a7c37164249f2f9cdeff601856d0479c0fb1ad9caac6315ea2280096ed59aea4764ddf543452dd2d6bdfc7eae8e583fe943c1ae8914bc50ad0b57d3992f74bcb405ed1ec3eba71b439da08da3bf33722d7a53c27345991f93e35d925428a782965109a55385d0f4f73b950351db2cbcd2ea5be703452b541bf42c78452f6daeb0a943ce6efed4612c6915a5bcb58a72cd7ec7b15ce90a9db5e0ec497f53a5813b6dc96a9d12113e800c89d0200c7dea9dd5e14ed48338302e26b26dc77df6527d552e44841fdc42dfba321f98f1ceacdfb8d9e697064fab5988d303f84b996ea60aee0d24932ae206958f8a7b2b21b4d9eabf8c1e63c56d4c947fa1b995a0711c881af90de835936c4c4558625cf45161104f08337b12d5e4e0857c370680deab50cf0576a2c6be27a7009f9c9a5e870fdd5203edaf5f55363ef06c680827e275d373b63b432c3309a0260e695b6e91fb4e05e1fed7a77948aa943d7174a89856b957ba21d6253177d0dce6b10466d0693ee7c18b0eff7f8cc27dc3d769e6d4fe02100e6a5263bc5dbff64d3e939acc525733d6ab6f3fabde73b89362a7d9336f7e53e325f92f7bacb3ed355af4b44ebd8c3de627f12a0cbf669fbb7d50760a6c4def912f371661524ecce2a473fde831e5af84b635f2567e1118462465df5a3a9106bc7163d789463a3d8e66fc1e2723fb41e0a0cd51e91326eb77b53194dff3f012004f72d853d9f893869035bfcd529a310f786395038d8c68788b03a5aafde77b566cc47792ee4fb6d30d139565bbb954aaa7adcbc3949b84b2445569649c4581f2c83fe96779aa45530579c0b9975feb8a6673f9a4abffbe532f96297ccd745916d677cbd48e746eafe606de2de684ffbad6e8257b6c4fc171b5252039ab082b6e044baa0d62b12ffe3c96e30acd938a49539c79bb897e6ccd53e7be8d080c1d6c645c8b7a05230da001474380c952edcc9714bc5e4c06eb591d48c5929fedd533d7c2602f20cc796c30b19f85a9103d2262d93d0ee2e8a7ed544c00e791d6d7f2c6f2a4c033f800b41aab28afffa17bba97fc7c33660e69df2a5e32d1d8013d761001688020c2fd7dcb2a9dfe582511d00b976a6239e15a1cd74ae3505c202b62e9a6bfc0b6e81e525b0b586be76cbb8219bc52af862219e3c8eb237747dcd6b36be68cf712909a59cc30d63f4c61e97bab5c009e8a18467931703ccb0ab7ae011fa7a899b54c849dd545518dbdec992b7330c67a943d2df51db991f3454e07d71dbef15c3396f66dd2df6cf78c249ea0d7d9554d6b2d34a923f3454848e840fc9be3866b760bf556dfd210949ab440e0739a96ef82a8aa1e46bbabd6f7bc28fc6d0f53cdcc437c7d2cf8d2a524397ceb470567c1b8e1294575222e021fe0fc335dd67d45f2575b96f80ad666daee8f06563a5a53a4f6bea88339ff954532c7d02c156730fc4f9d9a2b9ef14549863fcc20d9af35d4bef001757c91902def0342275c8c94c0200cdfd7ad8973218ce4eeecf784058d0eef264ab84ddd74c5f5b2f1010769f1c3a8779f3e46bef6d446831d2ea0e6c4a16a55fc7a88a09e63f052da92dc18c86bb9a9867a2bc76150c0a6f58493ac46cf9a5069f7fd0d295436c5b5d7db662d6294254ab2778d2b6cd07c3956ff4c8d538d4c16d2456ec491e0c5276ccf9b397ee9baa50b5a50af32c018f1937efdd7cbf3aaee7840dfd262ba9bb258c741f412e613cedd1d58354539a85a3f16fb7f8514a67e59eccf56cfcf77296436946b5084aa8f4f27746fc5e751b42f55bf5d955b06a9e982ec217934366ae447631493c58cdcc1317c54948d3df6a304081a14c08f3978170b6ff5b8141303328bdcb74062fc3d41ae54170df0ae54363a7be41002272ce6cf385594baa6b73fe48e7f0609150995b32bed299576066688be0f363da5f2a80fed98a975bc768d797b1f9fa97afc6afd6165f3a912311323c3478112b3adc7dfdacdc2209239839349fe5601bd26322c88ca06837a585593b45ad34da0dd89ce6955ff4ef6365ea6408da5bbedadf49522a79b473b9b65a44b876700ebe4da42cfe403ef54d69a446522794dc2e3ecbb4cb40cc416a7f81ea0a56235b2ff9bd0ce6a393dcf435bdb6c13047b3dbee6c3c460d7ffd2076a1d44446a9f973ccd42e3d2a30cef84d8bf431d8998e970de99ab4f7036872b361b729b89a3838b0bc8add45c9df7eb39e430a42f1daf430caafb694bd993be7464b99d4273566c4f936284163ec6c4676c47ad32b36b2d78ed9f62b473bcd6ab1f6d22f0221391cfeb6f4137cecffe28122da31aa329ad72cffe459a7b6507dc0efaa31bd43cf9807a47645b2664e8591e8d14043511457af084dca20bab4f3cd23f5307f9a94cbd1967c32a706cbf29d89ffc426b7df59d469e447b2677939e12d8c85de41534c2fdaad04c581959eeb969e374cc6bebba82755ecc628a78312399bd6686f1959b6eb37f187e27ecce506aee02baba72f6253a7c962704fda62c5238e98190be63aac7d517387435503c9c58bbf9676a7b6b9404d13cb9be3343d6afd35f1e280b1488df2cc6529410f7fd350996445918cfc921ffa2ba8df1299a1bc5ecacb2bb64683e70eaa9b55bdda6bc6577d3b697daa461bf019af4edae21bc596d4a35f750981582d7e784efb3508569eb62371326b3349f9506d2b5083e2383562299f298eb7049f7794950c668f2974589846ab553e970f4163f517f5a5d0bd8d139ede0cf701bab76931268d16020325bb5d761f133e5167571f09b5bd3791b37382a0c77f13382a5a61f38687d387f2446ed9e88f3f21d6f9f81ff66b57cc629321590d37c8ebc47df0de596e90ca44835773f1113185f0897b9abae9dd3ae5a9dd02244e4f68835fac85f74dcff61890f9b5aa202e443990e945929be18a5c21de306f3eb388804c154c0397f6505845f93572d32650fe41f7a9b139cd5d6e94ef2bd36d000a79882150b09c35fe60c90de7432bd63cb06d6c9e82c82a691fa1cfe85ca439cccc4871ca30e873edc540a899a44bb0d43741644b64b5addb3a9f521be91bd0b6774fe13fe9b15dacb6d5221f1d8863700f511bd7bc90093a13b083cc26a547ae5c0ac201440f9df7b54ec36a7b91e9acd96a1f2c00574458ba4e0a373bbbfcebd44f85113e7b17696f3ab19b59a46abcdb742f04a29fdfcf06e61f192f97e574ff9b131be83e9757576c2e25c3b8543201fb4515f79f5787ec2e9d2d3123172ba1ef0c66dee213405dfb0db52956e03966bd6eda26655a6ca96d2fdae5df5e166ecef7f513b3ff867dfc9c5147e5114daaa6aac50ed49f17ad01ab0b9acc4745b3d3ba97188138351c86c6d8149a9a1b52acfdf98e350a7127a45ef68247a0cb9c3ae2c27d9cc04661bb02d3c02ab325067cbcb9fe05878bd657a2c4b2a49e61910a0221ed7d2572cefbb2e819e275860f2ff853c0da8bb323b726f14ef2c49f7d097fc9a901a46f0a939df2e254296b39d7683ee39ed8b86c98a38dd948fe4b8cfd274212a37cfb0f0fc333cb58df8abe2374136106795d20ea4d9a14bb160211c6ca2b4906c4d7ef124a01eb394865278d8d65e57478a572753d92d7eb917fa9337e4e8f7cbefdece4e7725134ce76944e67c43b421b5b42ebc703733f3bc10e76f082cbc77ad7990b0ecae41d0f152cf342d69b42f41abac1a45be008aa500aa6a540a68d6ff220c1e2998bd6a1f5ab068d108f0ffe3c51894e077a07d6e8770e0a13b2e36726b7c3f8d94fc0d3c5dc72032a375f7ee8237bd3ad3f84d7639f00057b5aa1b6e8701ef59fb4442b3057617ab35e5bad41a226ed77d02650fcd9a448b441afce2fe7300ae35817d0d608bbff7370a8c75848ad3f4f0309a2fb418a32fbc40d28af96b447143d8438205e8d12726c575cd32376c80dc20409a1532d70748a201c1788ab7ac391a874fc5f5ecadd3ec89e381739d4d07272ebe488d06c56574fc70ec52f68dfa614252ab21e71c313dd722031577c0ea0d736daeca02fa0bedefb51fdfbe27125f666730e4fb9a042a1105aeeddf132f786e766870b1b4d89dfbd536b471015a48da0e1bcd4023f86c2fa4e15e6d9f3df9536c13ddc0d7442dba889dbb91f826396aade1eacdfce488d9adf18871eafa9b55388868d7a66a6ceec913477c1c3c9e12f40106642a0091c75ff2c15d1320fb33a9dfcc92f6e81df4cb623fe5eae5ec628aea428492aded799d832021816a3394c462762a1a129a217b7499b225973fc43446ccf7968388e475a24a2f0702c8417dc8dfea705fbabbab40aaebd9229187b078d7e5173ebb3e8b7a8bf1042333866f112bc5f1fa6d09656fc3f619605c97d3ed2ea623feda4aac212ecffd1d21ab7ea74eed4d7417802af5483c0b06de8ab8b1ba0637cdd5e6411b424d14a9cd1a5758bc7c70397025867f747db3fb0583a468fb3c4d3ca8bef9216e8c92a5506af277f39aebf9b4fc73d3fce5dcf9816617297b6c13c552c48678fcdb146621a8c50f9633c2e9319856246c7c0cc2746dddfeb65b5025b18862bed8d6af53ee348a5d318c6ce9b1a24ea56bee3233a70864e311359ad2b112f657b2686d10c0b0a54b440e4d5925eabdf09bccaa25167a172f1c6516119a0eb88c817f0796cf9ccf41decf57dfaed4064ec83bd809234403b475ea6dba7fc608481b1b1707959b1dfc2f818af5f484a7678cc20d4b08348b18a9baf29e7adb24d370b7b353e77ddd5256a5d84c8decee0ed3c2d8c5d4ff65c26d4188ebf3973313bd0c78bc5738ddfa22fad1d58257fb2a1a0dee65ff289c097db824fad15e45e4eb05ce0f0843618e6528b438d932fb6ea88b625c281cf68cc255e293d380f16d23c9662d76cd7b0ebcbf9143b9d0f984c09e20329bf8db28630db172f27ae1eec2e8564e759681b77b36bec28c4b1aee50069957012fd8e2661d28a204dd39489c643259603752f055c9580ca3ac2235772fc235becde2152b63568ff748f0e0906a22bd6085d23598eaeec784f244d3c7b914927b05ddd368e802e0e9045ab253f0caf9bd3090d5762a349b0a0d9d59907b28fa822db3ba96df3bcf55494d3bf39646dd39be4a4f9733eda4eccded6e4f80fbe95dff4295e9f281bcf2288be1a1a8f52900b4356e53c13a0551f31bb6552a3eea3a8a72a527c2a56a10236026ea3683590357122c22900de79919935e3a32bdd5d3bec5a86f54e4f31ab12bdd0f107f18e614d2779b259eb723a46290c2b839c22fc9c608264efeb19063bb23b11db66755bb168489ac3b84e57abe0453edf7e5a6a6622e710b3e77de7cb096c779325e6644e678f10a88101e1fecc10c9bd696c164150b2225b62cc86a4486412f68f83f80e32f8fd5e5d5c34aea480e2315f7be44bdb4d1e77e449411a924d8db0b6bd418cc958ef795494e8192d311e6646fa78d75a4e547931e4c20ed35841d197b813f3eeabc72c8dd1da60156b0575b27c227a974e8339d96ceaa4b99674b50016610d3a34256d65f4312a610cc7e53da0c08e50a8bf925ff73bd6d196d8aca161fd43de7a247eedd677f452d03d67cb3406d89cbb5970d89a4de3222d095aeab1f254c43dec02e1733967ab59e153fa5f613617f8543dc5beb36fb29ea67ff9d7b88c6e50b05db352e6c7f9637ca7f6d0d584ea803d5b9274c81d1930111116379d38975416b756544660042eb90f71913eeb1c79e6cbcf9a0d31949e27d6c9c77294adff5ef4c7fae21f375e1baf67574c060c77a966633eaf6bf7282b1ed8b892f25c7cd7d6c9fb2a376ec72b14a6b35e361497d2f03c214482fda89c6f418189b7876db1b30307e96ea7365193042c9d111fa9c8c5866af55e7dfdcf65cc745b88a802f3e1b5b45faaacf0212243489e9b8cf71808d30d87d954c512b1a0006b19c0cc32e2b73f04e8b0037383832123303963bc4055c2840ed5b04f4ab797e1362b8303882b4a96bd6d7141bae27b39a7dda8a043bdb74c2095fb4159b64f8b5cd5a2bbf246e639ad63f082b926c546b8fb96a37da46d922c60c5b4926dbc8ed19af6a5f7ddd072f3b1a8b3f623a0d375d5f1a53ac097ddfb69fb4c084d7197dabbb0a918c8235e398c7de149bd9cc988b8f106f9b09435f6e1bccb1fc71de1685f6a84166c51f8ca206c6340df7c2aed061e7ea9ef383d6914cc47d00249b14e8d1b77bb555efeb4eb7c1ce626d8ff999ef672b3a3814e6bf78cde9348690304c01ac95bbaf7e3f324d7b67c84e108a80156570b1bcc9a15e9fdfdd60df70a38ba75d4d7f18ce78ab4f99b46232329f65de26dfd1113283635ef3c01106e8d071ea072c7f7a0213ea20fda1cc728c74b6d6c499c9beb6d9edf29268d8803cdd083abd1b10ca1cbfbe6dbb86808a967e69bf8127055ed60f42f515363439b49f5225b34a32ea848ce6ad4b32a3d85632de9cf224bfaf8d4144b0618870bd135e621696102a291eed59ab82871419fe392d3d64ddb15fc6bb87d0105bd0e3060f3dd97e6d651a91f5b739efdd3bd25f3cdfcfc7c3f13e28f801f1f41e9de6b7cc91f9d2da9e89b4a07c82212f936245512dae8bc2f09e1bc84260cb72f50726c689752d5aa354fecfb53b33de8a0ad79da881d585119f52320088af56d2d09a3e24335b76ecb5496ddaa3cdee3d0edfe927d2712c3d5e7d325d6c9f3486ff621cb0a0153c271bcc5a9b07827c1d457c4e6103cac42e0f122f1fa7400c1c65eef9cde3a81cea6138da859aca1c68cae87ebea97b16458859a4298c9c25b03a340bed6b444bd39c5d3f12dda6062a6c855c6763265b844008b3305cabaebce4628d2cd71866c659ea45cd66e7d6187337b33cca12caaff8d9435b59e621f7d6e4012c7a48a955e0431cdda7ffa68dab90a8adac8c03957e9e98834a1d5557d9d79b6a14087e23edc436d5ad3f6a0858be0c8f1f2c65249e54e532c95e8130a57fb5192e778b9d1e3211bfcce18d00a5148d903d7a936ad067d2a97c5eec9b31443016038c83ae4d5ffd5792e693f5e94fbe741fbe604d6b9d8f7508d7e54aaa88dec59516e615d7c3747ed4963b41f70c2e4e939dc40d8f4670e3b8dc52e50a3cbe35e3c88063bf1356086a0035dfada430f5bad634c4208027b46c25f7068dae1eb7409eb3822137133e201c228287e7c49e4056e8b11d833e7bbc221ddf07b1c8b61e27c003fc462cf26ca55251f4de3ace7821f1eb529df681a690f4c070e3658506f9fd7a2dab7e548264f4218c45feb7d3f79b61c0bae3445efefb91f3b0dc6f4d9e26057b12718d222651c2f4e102eb2b0accbc8e20e17ff5e6e176af57f2f3007854482c97e6c4fce4de2b97f645bbef3a8258082e8ec9cf9ba17bf7c9d2dceeadaee6dd280ace04982f643632f98b3bba344206d14e25a30ecab9013ed495c571389da07d88ca86633efa2d45ca1e6f7b772c8574b7717ac1c6b224977ce56973921101f8df2e0d9f1080a4836b897f445044feee5c170056921668cfb987c97e1e5319ef6ad1ef421579822a6869015db5ba27319d868f29d775917a9dbb3d31992375781196d5ed2c77e297adb91fa9eb1967d1fac68e047ff7d20e0c7246ef008df8d4af35712c0e5777cde4dfac959b6f5bf3236c671c59f96daa47c7129dcd08b515810edb3b2c4b99a9b5169aa5aaa15f59136fb557dc2a4a3ea98ecb75df908caee0a7a201675d64185029e850fb19b3064f7ff903ce2d61fd0622686c83c39b8581dc52227638f8a0f789c7841829b1d94e6c9cc8731f8f2d096fdb26e88fc1d29c7c814fd9decd7d308577f3c4d38f3d3851b5d6ce9d0f935988d832f3ee6ce9dfcd5003339bc2d2fb01de147a8a2d0b06661cbfd3c71cfcd3f86f32825d95932917f078bd25ec347560c327df55d61bd93c79a81199fa3cc66cc85aa733b31075b813a6c9d7845f68588efbb9af30677393d18df60763dc4f46cde7a6292535b36fc17b7701fa3107d57a6198171a247838f6c5f7f65ffba07e3a0f4e652e18ef45f22e3a1bda318c78479063a4eaa894005c22bdc9c32b49c0ea1d898b609a439b7bdcdd4a27918dcd680e5094a511a275e5efbb4af6db59726781bb95a08c84d5d1c73e1a75a76800abcbd4ab80d43e47732db3734bc9884a018b1c2ee62a910bfae6d7d774305d51d7766fad6412656cc98507fe3764ce689f6784a8a3771c840c34d21853c57a897d0b6ffabaa8afc93c13c07f0feac7695482291312ce5024b2e9e0e6136c103336d3c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
