<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0e0589bb110c086ea17c25275ad06cfd6a7c5421f1324f3fe139d9855c6178cac220f3b72e46414403f37ff0f052e6c8ef06ca089d0c0fe0cfc5636aa48c6b520f7a55ce6a960b5f9ce05b6d8a3e6c0bb4ff1653bb7fb0a8c52fb6dff543a32208c510d7e39a3833b541ed51a859abace17fa1e32d214f81a401def03d7c2258ba8bec36dac08a4c52840cb98e3427b69a91b92cbff9afe5104756c4c669bc6a806535fac7ae65d680c7b7f726104a744707f5b3bdcbc5bc8c1f00abe40df2253ee44a752408e94a61eb801374e84053d6ad52ae8e0318c9826b2388c2139fea19f250737b2e1a53d83e791dbd9eaffc3934e2dcc8716f518eae7451554a7d8cc4806624dbc4e722a1c0dac5284586646679b614247ecfcfcd365d3d9fd3f9f5cc78d84d4fbc2b51cbe0dfab865c506e5c64d515354670a80aa4b1f87c718628ac5fc34ffe112c34eea0633c8d1d142e5c36f31a08347f6b0d828e246ca8a259cc604b45ef39cc29f76e17a83550b4aa413a5ccb682d88920ae227e7dd9f2dee420de66662d725028ff476d04eda9eb33e36f32f4836a84dc0495da5ace5bfc32c6b476f08fa8f18a262864239783a7249588689169a83f37f2c4fafb0a99e88dee8a501de45849969250a6827c963ed872744a3dfd0fa7c5a44ce7b025c4b483af7755c800d532a25cc8ed069de589e1cf77d927aeebcba4bef0273fab60ad6f5671ba8b9ad8c9222348316db890c61ea534fb92930edad15679b4ab1b425cbf8df8dbab375d13fcb00fa2d06d9666b18108e567d7a2274a396dd96c862c86c852cba21131b47768f3d232e65993010bb1df019bf0a023d435af0465b2de24f1a8b30416a7af7ada989100e8866f0628651542127418b77cd557c50f7622f41dc8542601bc3a4a3371c89cff0edc8e8f6c72bc0908706d6a0cc3b1e288199d7db362e70ae9e6baa8e52a0f84ae43684c7d6cdaf7234370ec96459292f5672857193c7723f0a6d63c47f3c7f730c6e6da2864c7f6110df9d69771b8ad7253702d1f1b15106952ddd9b6f170e73d3e2e76630d69c7b55ec4e9348b012de1dd8cd4252f3465b29c9bcd7443a67cad0d89de6610ebc1e793b8cfdf5c0b3299adf29562f35d088d52ab9979fb96eed5e846149e6e92c67c26de3892383b3d39d56dcc4408bd5f01d96a1498b8ce4956846a0aeac74e070dbb1be80439bb135a1adf8a03e04369305c061c2d3e2fe0bb2ecd40cd3ac94ca64d35603373c183a39c0831bc214cd4c17f251d0398d8574140d94e8fac7f030f43d5a3531188ee9f1ce09d5776c76a2353246e489dfef0373d4f6e0f29e84803c48ff1a08fd0dd7217f599338aec43d48d1fc2b9513ddb499eec2fa7a9f1876703e43746feee238ab30b97c63beb53bd972447fede1870bee189d356e670a917a252f387e151b9dc33e3871b237cca26e40236503cea15afc5bb99ae932d698963f3d814b822ffb07bf1a59ecf6020f3edece2cf36c119dcb8f4a6eadc2731d8211303d6f189c249006172c9289f89b4ae533e9b69f774049eedf755b2d05c08c555de25977a3c5286b69b5858c1f4d8eee5e46edaf70d316374157039b1e4a4e1543136bb385b270f88f1f33678dd8a3fb37f20f64f7ddf03241a25c4f9d6c0a02cb07d32fb1c11541fae52058882ab3032cdc1986ea4c5bb4a9faf1fafe43d5e0dcdddacd0868fd598c9f022a73665498c549df6c4cb6a4ea6a1aa19ab35637e5a7a33212abf061de839e6868c25de421bd520f43f8e2a39cbedf80f2a3d9f0fa1c4838416e26afb62edd3ac2fe4ef7e72c8417dbbcaf95d8a698d3f12b64aabb34bb0ccf384449756ad25ac7b1dda5908400b58a63d096a97ae46b899478baf9701989b5818223a6129ed02368abb76979242cd7ce6bf9662729fddb38679bab385c295709f5ea493e00503750d0dbd7099e10e077154c459f3711049bdf051cad444c11ffcba8159e5a8fc200690d2b2439c92bbd04f7323c1495943ea1bdcdfedaf21fe32f4b4f884d660a5d34e603d7abc231162c91ac04b1be18254bf5ea87ac3137a3b636f297e497b3ddad881a0610ab97944793b18a6103047801ac51b83df6050c523799a99c476a742780c5f9732cf69906144a7d828e93f966496625f1fc5258bc0183c872c9a591bab0803c334952de0f41d3a91985ae1326365aa783e8d5b85219e38942fb56efd144ea080f152634864cb2f5b28a179e8143cadc9f915feb1fa27a326ac2d8c0e6234011c8e2c3c65d7a509921ddf6e95bb34f1b851d1ee88a0eaa277f7d9b08957205a637f1306b27328d3499992d36507a06b557c8dcde13bc61c5b8ffc310236f9726741bd45c2c128976c095714af3c9c1e6d139660844008eb316b258046625ee01c45a033029ee6ec0108c1bedb9db284dae5e99acd13cce55f140c1e97f02f09aa77427aaf5fe4b27e098c8a94ebb868f731894cb65c7cffc9a1c938452e67e9e9214a08d81c86d9afb722dbb9ec82f0e18c147eeae3e590162e0ded3e361f161a596ee861af0a46e9f8fa8beae914da7642fc00a2b42046d5feedd8a85857d2a4115b974b3dcdf22ef8058687b342e83b78d1e276072cd475de6c6ffc1699b8d9985a2d7eb3320eb1746813e661fb797f30f2a54be7e158b548c70275ad35cd0a694eb940c7d35f549d2649286f930938b98990ef42dd85d446882ce4a497df815d9274e6a721eb53bc10bf81b9be42d0e7ac57ced8fa63e65fb2e02172547b9654cdc74b95a8a42f9f0719a9535191bb14dba1fd36d27c4cd6d829e90cc8a4a54fb1b226ec9737300b5f8b6a846da9c2ec17764c59cf80cf98b868b36d96c3c3de70f3fb4aad06d0753e564f603d21db7978335e1e2c9f2027e1212c52eb1ab58483924443fc855e0ef4de3d99e4354c58286f3d97aa74db31c12080a0c59ce76e5952d70a79bcf912be0bd4fbe2d40dd7d00f88288056a3934745bbac130696d01c85b9497b4b24c544ef16384d9b40d1320d51676c413ecba3e3ded2e6eb4edc742c8b13943637a8b651af2777b3c0689c1e856209814aedbf2d2ef53abc2e4487b5635b4560fec589d1c618b86ceb510085ee8fa4c517a52713a6ad6930471ff145c0f9693a84fa80bda5abc3b3d9ac4b03c1479b36549fd59a10566db468a7178083d6530aeda56d77d562d320bc0853b706c0bf562452820bd7e0b3f5d9b2493f094db3b0ce88c5389e4d019f7177fc568ad0d6e73b00743b485fcd55ff579030217dd9f8c18517cc4a8a68c5f15704253b0f4937270e0d8ae19d773ba78e7d08d2a33d9ef82c1146b691c3e9f77f0698e8474f96e8a195208bc61d8c0aa95a46c6dbd42bc9bf471473592d45067e58c45e0823c176a475de8b8eaf8290686e1055844bd1eff61b2e34eda87129e6a49ad86ef48e5625bf378224245da56a069776e93e792e764de7ccf449e58095b6ab5cd0a3dd5c6def9b3cd22e777731c96c19bfd807411d30a16ccaf9d0f112e013d4b5dd4fde07f3b8bef77c1c45850559fdf29d9ff7ee9c67fcd2e854988c7546c36ae3dc5ad1c02801c7a1da267ae9726d8f3a51972666e2848b0dfcf4fe0f553478e9b10b3535ebfce00c9708b6ade10330c9a1c25f7244e0818ea930198edb6dac2a01da9546e917055068b573bcb3cefbbcb3464c0063f8d72c6785c1c9965b738e26606b11b67270a1f943513a910e35ab9f9ee970d719d2b2e76e19bdb3868c97b872d1135dbbea79d67188d436251d1c4da546a9cd844746e334960ba138a70cd80df3846d1cc111e726291cac76084a59412860de270a4ac46e5c63cbe3f337b969380c19ab06eb220ec1d02bfdfac02651c697703142ef83a4c62c6f399a7d3f240da3d7590d297c8b648fd9e14c2f2d466fea916c8445b2ced20914bc08a89bb3d115a52b0dc94b087d9d759e087176aed9ec74a0acad7af73c61a7e503b6bb53748bcaccba34383aab8657bbc223cf086f80de9dc5882436fc17677a138bccbe744cdf9cca26d6e79b139c850511f275cf8c0a30b29bf7d4349b5fdd001168178367bce97a2b92a59cdda5860790f52375ee9f90629ed6435f2a164126cb5801ff26e20e6c7040eb7d4bacc2667ae5d03bcfcf17265ef344c559d885386fe4e86823fe8fe04af75459fcdd3b31c698c1991782fe57055fd121c4821bfc8734ddca18b5e120e59bb01039015870c100f8bae7657c15e865ffe320693b7a0d60b4577b7a949396b77f5d585458d83a366701d8bca12cb1d2e4abd4563cfec7b6bdf619f132c46efe2fec2efafdbac3b4cb16a967b3fa8d3bd94891064604754fc5e0f6ac4ab6ca0b8ffa8d7c4ceb9c228ba0b6d6bf480031c21f87fa727f9d3a07a44fcc516bd04b5b086123658a3ba8e17005b182f4189771b0c4a4aee327ce5f5445d88fa4f2aae9c6a19a5733b8140ea7a45b60579d840c260541f804a33df9df8958f2fcc5a3338c337882e19f721ee691de131b55e8d3dbf88142841d03a6ef9257341ac3410dd0116610840fb944fdcb21797ef71f5ffeb4979b20f312e9cddb684414022b5e5ddfa88984adbc89686d22b4b7b078d7290102022698002293995cceb8509dee98c1f241bb7752532a67c8930ec7093af47a7f11f8dc3d3ad244ed6749d5f43fd7f46111ef41f976b64a22fe222bed9dd785684941011ad455f256afbe22f670eb7312f5a6f6b09006fa1c75a34ed07f46528302874db55e84e64284db7a19f714ae4165b6ecd954e0a8b6d6b2dcef18492cbd7567ffdbcd28354dc5e5664955ae9db8ba50eda46e530614761c7ba6a6c073de4470f2064b579b5c77be1a9fbbca120b0b2be72c501e307f3b40e5a1ebfd28e68f8eb96100eab3784bd91e1292df91254e25e5d42d9e4c869eb19a57f69e086c6b8ac81675889b6c82e060fe2240b88eb98ce23916fb177d9f2e283ccacef052b2478b7dbb16f074b2a627d3f06dca62388af639a4257cb2d99d00431dd4833b74fd82cb72d13d308723c82a25083f0ee6b000d9702cfb9a89905243aa67c644cf0bfff4b7aab50146c5fbed433b6933a397986c4e9f44f11121686a1d043658116a43543c533fbc9b3a1703c0141358e47de50d6b29773274e824b8926322757e5b2df812ae3afc55a7546fdb5a82389d7c45d3f9720f9ecff09c3c347c7d598b6bca78392546a09aaf1edb1d3cfb13714d4b2d863ab3aa8052e66b0a6abd0d305f66c351019282b2a46ad5c439756020ce69dd95c11a08e104bb4b486359f26e22e717c8314e9eb35a79105dc11a0b79c4552ae54bb2de48851bbb58d5e69b60436b55212e0da7fc897e06dbf25adb8bfc9592ee36e52a6599b37f528edf5f8f9a971c0af9e2936914f25b51539ed01152591215adc742deb1ab93d138845547a0b1b8355810b329f3361b56996988e29eab7dceca76c1fce1189c81dc678ff8ba27d968f2cdcce000d3d28878e6ef9ce14e705ca08fff505ac044a7b7935ff735adfb59d8507487fde56c7d48b0cecdfaff19124da3a4d12ebc84be8d956b56b79bc8d73d23316f4eb40a5002e05568a1bb0a56fcfe347fa4ff63ad8283f3ad02d993268353ba7e9dd5519890b15d6adbb81f9310530e071850f8dad834976ddb9f76a124f57049b95ea79a22ef96d10ed178bfdb20f6d131c2120e394a92759b81ece0f025d6ce124fe81947ec451f8ac5b9ed3db588ca87e6256b0060b50910222913e1d1913efb030bcb66baa4a3ec55902830c67d7b080eebc9123f0066474111bc415e28968977c3597be90ca38a0eecd66404e71b1306d4526b4b85b7cfb81bcae74ac8e81667ea890efe442e5db4e544a00eee6c45a9fec91ab55156b9f1b6ffd4f195a509eab7a8fcb473334091102339dc9d4c1966007be80040ad9951d51233ba748983b0d37fbc694d379d1c7c9f3482b995d0024d3cf24fdab2e413adcfe7c8c8a3b92dde3c26bf3c37e9321819decadc50a143be2acbfd2c727a2809e10099e23664fe62c6805bf450b419b5daedfacb6697d6b4ccb0ee3406b3e769de6289598402000d766664d325d1bdaa68fe0cee7728d6a63683f1a2d312e264baefb303df6fae930d670955bcdd0add2328125281ae3ea194663f73f366c8ebfe1b6247714ca01f8b2ccbf6702454daa7b0e905345a74b998cf15e5402b2d268060061db4528c200d75ed7dbd02d7ffba789affab5a354934a9b5093fa911e83531a082ba0324662aa2ae14413eb5ba87e7536bd8376b7f5694dc120a8139e6856bba487f3383b6066b9af864fdc0cb7d0f0501545780ac2acc156d61a7e785434f9c2e9c163d75423228c6955f6e301733ce17c9ab9930e87faf4b73d591382e30288e0ec51935295c3b72b713a58dd016ff56775e4aebe7d8d1712b607d43121eedae26a08c6218f79d35bf392c332ac1766582301574433d39db33d7fa3ea4e0ba49db83b6435251d92311a47e7295011308e03cc661c5bfcab8e40e6f921ccca91e4a8ea24a8dd1f4fcffcef9317de16ef695888b0c9a71b272d0da52eaa747be277be64d17280994d83950f8acaed56cd08447f7d3ae451e85d8d62f56e24e73b687bdc44022037b7f6fb0d96f44e15c21178a2e25bd629cefc1616075a082707b521e011088034b914a1a5412c3b71880006889ceabb9a2c265dddb0adca7bf875c8e1e4ebcf415fb64731259d6eb7a42ee3404af20d6ff79ae413fc6dd2c7e8b42b3d0e00c70acf588ed0401fdc8b93eed1e97945afad2a319647432505597bbeabbfba8791d876b56d3838703b9fbef3bd8ac1cbeadf1c0e8dd42b2833b83cef5fc9038ba2ac82e5a7b48324745adf3602bd406a317ca862153279bd5b3803654a5fd181863e2b2229f8cfdaf89c1b0d5e40a28340e0205e27d58ce49b24a20311b5a3560881b6521c6e72c12329bf769fa1b28f33bd530f3d47981ae35245aac7bdd0abdc50beb41d597c557679f1839835b28aaedd58b236c398fcf207103f5cc2524eef587cf06089adfc0606b04238a60131b2e7a0fb1ac7cc39cb906cf24cf35f8e7cfa18bbbada66496d6560f0aaed9515c260fdc74c09bb57ca4c04fdda985f05042ccac27d0a42fb518acafc80b39969cd61bf34d6128a598bc1e58a6b7d2234cc20e7729cf77ed9ab3f3af1b00529372c571273930a86a23634cadbe0180592a986d9f3ae2a6627ed237bd3088411af679f6dc5d7b9ae2cd504c9c334910098990ddbcca83d168e8fb4b05c6d5b192e12e7747276aa3cea4467d75786b292659705ed6e5ec8d2fd28260402722c105b15e4ed5edcc531daba83f193f473dd4557fc96c9ef2dd4680daa9e019bb9e39ad63c4b15bf303fd83fac2f64228110d4eb805ba1aedc843caa1c27056503ed50a0586b7f6aed4d07cb1228271d03683bc775bee151a56ce31692b54a923cfb58aff4ca8aa8840b4b71ab40864cab7356d61674d2e95ad62697c1d46d9e8a06597cf8313259b7a3aab990d60c22fa2007f31740b41d3ba521a2bc0bd71c10615b74df4f46890ec1cc00e5099c7780c1e88c8c344f0202431f5030e7ba8750327345280dd3a7c554f99447f64a47ad5d2f76bb0582f3215aa9226170c18ef8067905ec5328a9c14d03d02101029235fe1957dc4ae97dfffeacf2e41b71360bfb9eb8bb08720f8b37e8f2f52d37606362a1d0f49f9905d18ad432ae49104279a8db26b96db7561e8551c2cd2cd09a7bbffb27061650e2bd8cf4036460a673f246f19f99fd5f4d4e0a97d0290b353e7a8e1abd7f6c132017f0dfe2a9c30479522ed36832308ea68448c19a2816afe3640cdc0f82f16514297dd9af4a11d80889b8af20505facd8764f44b9265797530e86e00a0fc235c250066976deed514b75036537de1be47973d091f54bd76c6bb81a2a52bffa48fd60ab0bd4f449e0ba6b674a0bc118691dc6381b4bf741305ae57dbccd3ab9dd6cb11ec445878b5069d58c485d5126a69abc6930561ab33cb1bb288e0cc1ce739d4538412b1e06ba8170bf3559eed65f8fe08e7e80c2410f828ff75c4cc334259f5b6e0bd9fe9c079945b0890f4e7a9d74f68d92e215eb9290fb3ff9c2a7b177ef44fd64f7d9ac6d644bac60d9d78b768f2955852b3cad412bf8db8cbc0c008d4a35e28fe767d72865f8f68e7812d556e65a8856db0d7fe730998d138846db9794cbfccc2bb4cb4f78063372a0a926e9226142ebfe3da231b1dd4d5f6f29d67474eb8f1bc1f08fe7df6c32893e9643d7d46d8b724eae9ab6a747f931f949f87ae030f77630477bf9b2fcd73e0aa9c56c9c49be097807c9c30f1b261e57020895581c2a67a0abf9e9f4e94b992efbccbfb69229a992c0d3537a4cd2f30ef5c0654d9dc042ecf1703aa77db76331c379cf466421368f48ff42493f7a87ce9fb39db881c490397680032b9dc2d011b8f6c002cd1ffc416cbceee8ecf72e2412fe3cbdd1a113fb8475de5b8131c3f2b236fae1c417f3e0f720b708a55720a4350b86c59ce5f7b5a8febf1a435a3f56827c8afb2804188d2e220751074e07e001c1b1bc4bd7811a494adc1aef40b38fc31c6f94e73c3739427815d96d4d23b3417cd825bc4ec8c7a3f0c736369f5bdc6218244f408686c667af5804c322385dfab2823cf354ac08b0cb653b636e4af6a6d6f4888a559c8403814dbe1f3b2a7913c05cb71baf78e4ed3f6aceec3c97ff7abb3c8f193f2087135b3292f2015d2f4dc438841181f3219fb55ca0993ec51249b4da0cd85fdd26c2a94ce2b1972f7c79f713209d94c40cc42276b5d2fdff4ec8f937a66d1f12f26afe9ab3dbc684a7f52799805cfaeccee9a2cd78e887b73cf3c004ba2f749b8500ce917a6002102d5c982b2b186c58f454cf9793ad424a3253652ed6dd1c074028c4d4de3ac92073f06b82992fe79bb4adb5b7c75558253ed3e36e41cf2135452e94663b8b63927a3302db04b624474790a3adfa47cbde722fe4b181dcf5ffc138947085ba6cd251ee512da7c423aeff534631772de10bc29ad57ae7c6794c7ff8919731840d20b4ee85b295e58820a9e9b37aec55edb57cee3b8b6dcedb1cd4fb6a9c1914dfbf54f2ca5bf2e5f3dfa1b70cc22bd48650eb554e06f013630373341ee197bcb082b6f8ee47f1067b10a142917b1811ff5ae1db1e187972626f6daa65ec17c12fdfe9ed9ddb0c5b0b62a2af7f9b9abe44e22b31be6b0589eac6d4f1806a2f48e185ff1bf91cf4293bb144d7690bb2ebaa8f6f26fbb00764dc66c3d74e7d8f869b30b7cfb6962ee922e121d458b24212f8038fcc4c01b7fcc8527a88cbb0b6d532c1e3a16df9714c6541aafbd4f94ebbcd8bb8f9f94bf21d71d028d73d9408653a0e03ff4450111a9e8b9037542af9846ca27d0bd4b49acd7a7da74d1699c468068f8672a675b6c56d3dad1e35848018396c3bb894580037efc5f7be4dbea431499ec454b9a5e1ec6b0ce787d208835d4f5bcb4613535b247a4e8586d074dfa099fc9d53e9fd44fc1783717125b2b9e4cae5aa98f9aaa56462a77806c9386f2001c637754fe476caa588e43c7664e0f2d5ba9cf0603a5ac23c1a7579a879cdbc7b67b0bfb5213eebd9fb4f9076e0b03880bb8f134db817e9b9d266f6e7b96452923b3784e6db7fa0389a07dfcd9560122caf8295b9239289b5b778435553c34f6fb7d508505af8cffa76fe9f0767c74da148ecd701bbf87005f3fe12aba812cafcdc106e8080d3def53ff475fd6ca7dd6f342052212dc34216700eb5e44f495a8b42750fd48ddb5eec8036a151ed8f933535bebedff541f034966596f8ee90211e7937cedde43bc37259c64faf2534d5e80b7cd2cbe43be9531dca19abb38b779489b3fa5a423458e9abc286ce31a1152e046211ee91162b9c2c9330fbcd1f70e91b0cd56c228b6171178373a980765b3ca2bd37b036b80713b56059a66d3b1fd3859ab1656bb314d6348c9a9ac543ebc383372be273357127b96b2e318c48f47d071fa5dbe179bdc95aa2ed4ba463c25643540c812462297a089730922faa7deb1d3daa6ef4a473f0dcb3d636d3436cd9fff4822744445ad85dbbd4d7dd8cbd404952fad73bb047330dd6d8380441f35c83f47ab1dc066d5e3b9064133224e85a7641ffb35a02e9b611fb9eca8a09a7332a6c7b07280e35aa65e15e55e8889f20230ac5e60607f03fa231afa9ccdebc3282ebc84526bd9781cf88cb7365bdd4562cbc86441a4a588d441303804681291aa00e927a9b3343b6b1313d81a61f62056a90c8ce3c306bfcdddd462fd461fed27852a661f02700acaf5cab102c046cde21acb624255b39e72f9e10befe60a873c54be4827b1ad5b9c84b621b96c612223cf8be6768867655854dceb1100fda2f387b37b49bb4f550842ef9e0064e1e72551c03c65e176a74c7aa6c8e5f8cae60d4c97e02d9cd2cf05f176bc62d8ebdfb6e4361d3ba23bce2c223003fb3a850ea95e65280ae0d50bfe3ae075e5b520d6053ddcd86ac173243d5917d850176d87bee2f40c9ea11f600bdb93ebed675782f0bf07fbd89b90d71cf1e9007572adca136e7a50641c8d904c8b10eb42c53cb0481646f8b8132079f872d464f373a0f3460be8dc55e37e4147f6bab4c25d89e7e225a0078873bff76e711705b9eb3ee5e6d68aaa5319845f1ba4f9355cbb4cd074a172842fcb429c6b295dbd4ce32b245861fcd9a4b5eb8eb8db0079a7f85a2ace6e30cff5e74c63ff60a5d78630a82e6fc1d21d7fab327198432eddacfa8765c253de5ce940be607d21944e04498f158d267c87fb7ec750df627b3749859488531026f165b68509b24c74b0fe7e815bb8036bf04f1862a941f33c4458052f5739731c3d2b99ef4d2a79e91bedca5b5b78d94343e8bc10b4549c46778f0d8fa190b560698db9fcbc2fb9e795dcf919cface8082869e287942d309346ad3fe88fa1d914709dfe4e93d43c9237c51d30d354ee9173358f7a934fc055c8127afea2aa392bbb35c8c3d99bb485742c78be360c1e85a5b075ee6199528801df35ff82859f39137eba2cf0d15c0514cd632e9e670e8fac1a7e081d75c12430e1cf7f31e7a6905a80159d4084f72048e94d7638c9310b78c27b06004b773909272cd629f08b24a16e9c742032376486261cc23001d334e51cfd2e974643e75952f1743239ae95eda63c19a5c3c1559afbc51af05c63c0a97cf43ab1943ceac1afe4f315a1ae4a337723c0ee0f5fb36630fe707dc4b98014abfa6a958fa57c6b9a8013aea05f3013361a0f76f54fa4c4609fb0621d3e0d7751407a5d5f930a77082402e52c67898612cbe095d2a3c503e33c8df2efb568ff2a64c519a5cdeb24082f3805da570f43404349381043b725bf8a32dc07eca971db006b7ed788b1d9bbfddb9eebd59d5f76fb1f59046405b24fe389255c0ce7eb3360855af2a28fdf96ba5ee0d0f1fbe95a000ec2308ef8bf46c43929aa3bf06fe3f9caae2e75240ce60e966430582523c81fef9bf29f430eb8a3996308299e8209d331a00620ddb33f0ee060e88f838680c51e62adbae18afb45c794725e8b08dcf843d7201ac476cd712381760cf3e33fcdf0de06f8ec839c5f60ab742127ad5eca78c80309ed23a85d71d4260c11abc4a91c5e078f6bac299fbbe00e2f8a72019972732c237a930970afc6a05baae10c9451eb54427b8d5b7ba9ec87b4580bf30d0e64df2723275dc69ff39bd9eb2bae4d6338ddda341ab597c82243d43636b1844a0f4d1995ef8aa3b8ea4d51eb8aa58488ef2455d2d59287a5688f8ce68b9a0d3925b9b0298f85579ef3f84f82f6dd58b667a4bb2effc68e2964c0df0ad248986324c34a6b609d5402a8a2dfaa380df65662a163edab47290fcb32b0d4e62b458933b8247d9dd69c9752980550e81786d82610eaac63cbe01f27c0f0717b2ab8f698b37aa26e0d88de87feab31d9a6738e8bf758268a67b91aa605bb22ee3069a94b7d8b9da869705b84c984ca92ee2b7c63a72ddd2be62a441d30d68b135f536a2652f7a046fe8f34a43f37836cc1ae65be54bb74609d161dac5f16ca6373f960e9be5e4f75baa00577e04d65a5b0b2e95551ac6e9d1f22e83180b4a258c893a6145e0ee5e0be24f629bff23bc2c94b73e3f3cee59f632f054542cc46f33943801ab6b03f2578a785e8fc161bbf546f2a95814ecb5d8553ac935e470f59e445a13141f993927f625d9e2673c4d4c0b8b08ae2adc4bd12a09223e18296935de1c6bf7dc9470f82deea2be6824051ee85ab3b8860d8ba4521de08282d09a62a6ae284c9238bb4e497a6d18afc1fd6030ae95a2fcdfae4e7c6dcfecf89f1d6a2d73e6e5f20661e27823610d40a0faca01fc7eb0b1c900ee5007b5a0a82b04ecd99609492179922f9b8207373b4d75304863737f438f3d999e7d2892acf55fe3e6a04471ed9c8114b08c4d41ca00e468a5a083a1c32ec201830761d2ca9d09febe0f44197ed5923ee6e7bf61d37fd628f847fe24fd646540475a96b16c4b67ddeefe09808ec4a79a5b7849cac111d9f5421a53f2115fdf71a3769878467bab67f1cc45b8a0cff73b5e63666317c52e47b1dd4a0abb9069446b96110e518a0abe4f96154b03a08b3d1dece1e78756495c63227bb80b0923e5e0aa63fe4c1d0a119fbf78c2813d9e8d2143f9ac6978c6bf6acede9b48aa3435bab500993a477437f088ceb4de810705d2c9d179b0d56defd6262ae916718cdb8e1afec03b0732d8e61a771ca0b67b35732d65a12dff882cd10dc97c1a85f615a9e19f962ecbad4f7eb7d2947bbdab330c5636d7143f3e0b2beedcacca1c7e69622be2547c9f8bcd52f5e9d8bca06c5fec427c4be73026d5518655f11e90dbda2911f0882d184c4fa40066d30b966ca7bc7c0deb038ddfd8bcd7078020d8dc36a1d89da3f52dfd53989e3e1d58fb4f58bcd0e74879abe6cc2a27659b8b6022812290faaecae59c0eda4b9b60b218bdecca4769ec9fab72b8e820319a6b430d25306e0f660f757300bb0d50a8dc4ef739a8aa405904b1a3bcdf04faacd8a73e60702b96db35098c1cabdebeaa58e8c349ff459007c38b709e179697a6340b37478c50fd78b9c7b8c5685c792b76e2c334db313cf981323469a8c47819badcb7de4c40553c859e62b2ca71f8e9d5d52bb81e4545089762114dc7ef72b56fb4340e5315c2ba2be7dc30623e1f49da4b2e55cc314a460a8753adca35f8e4b121649710cddc5917fd2f23143af09aa97cd54fa82f07f0f52834421f62aa049c4e8cda4b5397740fce1aa913244ec7c2a9561b8ec8262e7032e2f11b3fa70917051ffa97e49bae6e800d9f22eac6477200a0e3dfb1684d1dfcc71f571d4e8ff7fa2261adcaae9ffcebfd18d74064d8980170d17507bfffaaf2c3b22e5c5038978b9baf243d5f939bbdef94e43ff148db55692cedb0bec947d380303331c5757287d680f755be3d72c6e6b7afaf3c920927f62c999e878bd4eaf18d9edf65c3f13f9dd736ea4653ea300a9450e63b0ec6458fea688794f5c29d44261ba2aad2e3234b70ea5d0de3fddfb0ee0e06045dace47016ec0c5c82c3e13b362dc359966822658e171b51b918f47300ee12a8630ed4e68101ea9fcabb3f7971c50eb023b32281c4a8d442f2884bb7656ad265c4aa78085a1533ea763346265111b0385dbf211076a43a0a83a3bc278f0b53dce82f95859054570435a243e461ea7ddb4f1f295498ed3c3bcdfce286f77559726d526765fed3ee18d81f0dba288b3526bb1b00c7d022ea5f651f3f973d38dacd07ca16f01c9ca35a7272aad97e7fd24a919d62821cb704644882c8fccd9243391774cd79d72448ee84189c5c4daf6ccb7379cfd2583475b941ea87a0a28c51da1ddb1cbd0c5f9820e2c1e474a202cc85db6b8f9bcc73c20fb2daa13cba7d90af518f476eb00ea2b7b216b7f6cc5a84da6a43b989d7b11f198f2c18923e1af65400075331649386a3a3eb6a6812bd75ea74fb1cb33d799532aa20bc33820b088c1471190ce9bc05beb338e8e5c4d8c331cf0361a7244e58e063ff7bbc1b9b38d0defc36a147522af054afff4af09c6746fab428768399ba5ad9212fe55458e2557aed5ab2a30c78590a403f35ba397d20a788d2e70827d838dccfd1206ecc196fe9f1a416a1c549a506ad9109a51d15459439bfe0c7e6ef9b3b8037dd4c0b1bde45c4b54b3391d68267169d9302af034e8fb47b648a5d41dd5dc494ad53c75d165cc5e24b7e0ab9b9b1f6c16d6cc2fe6934a96f6f6d8b68b6fcd6732ccb5b17ae1531ea0577ed50b41bd21d233c450a80d8656c4b59259eb6682c44bad83c2e87ed4df85079184ad52b5f4562f99df9bf7ec1a7e202a1d70eee1c998fa63410ade608ce4d42878db25eefe2ca645dae4c2614548385cd466f1ce13a3485ef59495523529d7d39251ed67c7c43abd6fcb738d43e1885d55c67a75e067a2b8a5978f0290d8bc6958c740466f9afcb68521dbc53c49bfb5e44c6d0e83e7f87bfab01d21bca6a1dadead076043b2837e21fda361d1e47db13575bb75fc04b270dd62277d3397ec3b1739823ebd65d8ac1d16e83172012e9ffcf058c3e757223cca648f8cb562bbad57325b7855d4a99292616bd0f56ccd13263ba8234d0f4b3a55e094bf4c4cd0dabadec3af3b11523df7ccc9f95afa81ed02c63d7769d0f9ebb9fb11ddadb1e10eea8e8f5dfb3bb9bd02a7a8d2e7ba47ab42c08f70a4038d1bda32a79c646480fcd7b74d53b29aecdde12309f5ffe2f889b5eef27d7482393982d0dfe6b641d272dcc6b07d5a299dd3caa4f7c581b29fef8edf0e1a5a9e5987d42934a1dacb5ac3ef36fb64fe640a3b4f948a3854e6ac1c426f82dd9d9e5d9b87d18da005cc9077618f05a43d6a2020c0816fd7551788adee9589c588e4965da169206b663dcb407819b4a426cae0c105169ff9918ba08dab308dac760648a8017ab52ac98ea941e469218bcc92afa9d5064d3d8d739f63fe5e150f4d3df23ccc8673fe6242b72cef1444f5a4e02204e546f6e832f204809214bf7a4aabad6863cdd99fe482ce756dbddf6327ea9f5c8b1d7294cdb32c05fe10529e0e77be8bcd5c595841c08c28da371e6cd61770ac7270b265b39da8a1f1a533f5670f64f37755c296fe369da4bd5d73df53c5ed67adf7f0ef6c4440c506f744f8e8924f31ae10bec24dcb8a54b15c4f817c9e54c2ba4eef9e9cb61195afb86b86a6f4b7852a7acb6d371b72c06088facbc9ead67f406322453e46d1d98956092f2071abd24c9d2d132a8e361371c18e846a1485d5af76b8c8922bf3b09bf189a7fb695943998de1b3ad38c386178deb6ec8f880e79a2e8e2bdd36ff983c561249b9342a611a30670610084ce4ec04b73e59e53698d1e68157a5b49b716fec710d6ccc38b2c8bced587377a6b292abc030c8c8bce577c82f51f3b4618eb904a9b20734fc49d9955ff9b8a5f5fb1c803df8d3a4631ece2bcdbcc377775e2d210b50fd30cf72b5ac825cfc2baefcd645629413b4b946b6ec31606a5e5da5c2849accf2bc1c0438b11cba197fd13c20520f3280935ab3114c4563976eddd1604402f504882b61a932ec16fab975fb020018a2829f9cd6d55422b10bdcf5cc3d3b018fb5fea16c383a1e575ca9df55823ce81b2190dd12c7f163a81e7edead8890196843f04649112eec16c8b9c19798a1a31ab893d4094e3d180aeb87287a278aaa3665ccacf20be78fd82298078c3ad674eae7a3fd1c940430f6c4427dd1297a53e9bddf33afdf7719e6a8d65a2ad07e56be6060d151461470518ca58f267468ecabcf220b27c35c5c65acb3c782f13c3587972cb12c0616aabda1fd73236c69478433f9fc1a2e2c265e96974b24f2268e31476118012b105b7a1481080e851f4bc3b27d8a8162c5186a39adfbeb21748dcff5751e5e851d76a9d444fb0c6f2e545b38f265c7305022a3a9fbab5e85af1c3499c7cc5012f16fdd832c54c51723d3b5a12a8e1dfca12f9809e2b8bdbfa8863e83a9297bf49968ae39c62c0036a7ed0e26b59f0a1b6304086c6a3d1318066553cb7adba2f7cf0f7935c41c4c5c16cd39bd0a84d036f27de7238a1c2c1e60da8f7b2f9b56047732ee6e45d6ed207a56e3c51eb9b14fb02e2d340d20f41d918b0568933f715de199492809d4c3e06d5e2428a0fdb8938ec94c09e122ea0518731e8a1018cedd8dcd66a7a7e86ccd8a6cbe45fa1d51af2ffd520fbe5171586171c21484d77ea6bc549dd5562fc579d3b1e83fdc3fe1cd600972f0a3dc17d34a7c6728a0f2210c3b06ad0fd4c481818838e62de8c04f0dbeb70167864a21660dbb6cac9dfa4cbc33801921f65cddc561705dfef51f984e2bfe9cf5fe25dee138899eb4cb77d3bf7aef63f6ad89df9bff4ed3935f8f05449e8f2eae9d055cf63bda729c31592321a4a30655b7715448c9dcbabb99507b16e6049e7dc82ffddf7bfe34a8eb3f564e7e5f0d7b2fc79383d089de6f6da1da50a4858e169403717c6a267cc6e4ec506335ff2d516388d4e290f01f4d9f8161da6bbf3c906371d774952f3b7efd498d7e5312a6e8b37f0cabd4f9651221b25b829baf22914dc21b841efa117579be09797d9ef164950ba24e6171faaaeb11bad1a709b6493c15851f55bec4225bdfdf156a1352ffc129caac35364b35252fca018541fd931545877fd5562de07aea49c5a37566b9957e8ddd2884651d8dcd58c45b9ed7056c36ea2e503c09dd3de053890d573aa0fa73b1ba5d8c1bab5a2d0c83e4f543585e23c2cf3ccd1e0ecf9b5e2e3980febc433b51c74aa2e671eb49fa9b28f8b7c21943cc8961ec786aed84a761b4d118264f864836af1235fd8b3f4f24c000e1b38508869c4dfc186eb3b068e7acc4ee867ccfa6676a2c4c430f7e2ff4eeadbc785fc1d22549926342998855900cc7291f0a977e317f2b4bccd5765d72fb2efcbec1056c358c61f86e802c1f64de701006c66dccccc46118e018b5f6d837d72125fad3af9d898c861a56148c133221cc095fb18a1c333a0909b3cb726b4c34f59a9832e070728e32d93ef7220a082d588efa9260078ae07fa2d32cddb3321de9fd309edeebc2cdac4cc75f658e7f9a4b6546f0db23e39b07f9613df59377f1f1b2a31ce2185d7a2ee7408b20d3335eed24c55281aea0cca7c4772590c320960b0768219402889be24be7c50dc3f035c5599d2d36f99738cd801c62bb6f38c53fe72d8612fb82ce36af47ebe30c1e60b279665bbbe7f3a585feb4c92e3609c841ccfdaf4cdfe1ddca5f44b9ffc6b3e6bfa8bfd1535722e09a079910ca364bb8feab1ad4ca3de1da8c9964221a4da381834720dd15cc93a96d84cde687c5ea5708c6532f5b86d71a6f6c754659dd057a8106bfd66481dfc36a731e5195d3459597814de3b95d974870f4a8e337c14f4660e45c37bab8a785b40cfa586012c1cae33064a398658c027ef1c26ec85b2159d7b560b2e37600fc80ddb85abef6bc4af9dcf5a8908f958eb6df382aeb0d229189268b1eaa50ee31ccce5448f259da1a2997829cc293ba94013cf9d00568f57fa3571ce459af4c692f6dce8fb25c58b060c1bff83e089f8dd3bcb9b652ac68fb21bd761bf2fa2e392444ade797b119b996304b512ab2e48830b3d71b3156fee21a5ad3c434e96829a5740375f682b1925564c0207eef4127334659d5b72e729ff7bf1fa347c6a60c5369614cf9edc4c1f33f91ba94e6bcc32f5307e10526ba4bfd927ed57536f45a2ff5bf8f8ba79d4b8bad708e479b22df2ada852640a45c2b73775629163ef2bffcb4418784bb56c3ea004cc9cd7561179dda9b68b8324d3fe2810a49f809337ceb733fba1ab9435cc38d491ad87da22af2c585d7452004633e2cbfab7febdfd6901c3e0c695a2ae219d86fab530062ccf44c92f73436751f270412e5b81b9d6bd59dd7b008d094985d90cef1981b8d9eeab2b18d21492815c497a651482c79e5b65ddbacda6dcafef4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
