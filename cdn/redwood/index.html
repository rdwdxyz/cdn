<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0eedfcf5edeae7e4ea7efd38d0e675291b199e74366bc0befeef5b729d12c608d456b91e2b0d919157f423eb6f0ed0f19498610c167a9f332854eca256990b417c759b42e1b710ed64f53082d00cd71c3f56dd9e83b4098e4621a9c93d2ac752403c8cf9043dbba2870fb42a150b38f876e25887034e895acc9e0d55cbfa89cf8ebb2d5f0616b8150f099a95878365d514e78e092e4dec348aa53d857e4be468019dc71d8ee2100b7df1c35f5be29098ea36878befa497bf5f378dc1c66e0d4645a29d25db34a7024deba4ce7134aadb7c5040ea474fcb20801468a7c766903575258139ea696529b32d1d9ad9f16fab029266b3efd590600bf652fee4f9062670bcdd7c957788220e7e1e4a5e7f5a461c6ef7a55e6a92441203a547602ce2662604102f72b78d0351c9c3b68814fee11637f1955f9da661cecf8d594ff42f95f7c15aa0596d1c53f7515979172039a3e84fc30c6ac3f28bfb4d7bef1635874ca25d61b9b3c952c8a2764df557c40291f725e1c9d7ecc8e6f9d49ba02b485d2e91783284753f71f773ad9f9698a8664627dd4bed675471ba3961c35c1bf390b1b837ed15169c3223efedb6942acc80fbb4b4195017801d422a8c59dd8c81c9efab5e1f146266cd7b742bb5e2886e0e553d5d5a37738a630883c4a22221b5ffaa93868a2bcfe0c05f0f02725d59697a012540a09b285b50f6f3c9d921c6a4d6fb5b6e04f3cd41368a18a1ad80a08795fb28f6691cbdbc7f664c02a68f1491010d00bbff0b3ae2b314bb4f79748788a354c79b417f0f1b093b1b927761d3b2cc409fd705b83d3ae1b398bab2bf4350347f2857c453a4e11a96da2d18090bc2107d367aceb5c13f6d39375cfd924ae74b6d0c2503163c85eb812199ca707b662ca93cdadd31a97feb122ee0ec209147320b41d0738201838c9255609ef46bd1bac9a95024e329fa50d251a749290ef119107e18ace58b2a8e4e8e01461ca4dcb83787890c34d8ac121d64d332dc3849eaea083eb9e5c1ffa7e0841b828fa7ebdf77832f84f0ee7f81204a8b3fea56e75bccebe3550cda26c067e45e609018b29dacb31321e9301b62f75f12eba629e11e79ebd5a1db3ad822ac8e6694b9c5d8dbeb426715ae2135c01f40afbae3987a145f3a1a2223e4d5ebd7fd79691c192f2f754cbd343d61b9776c2442f1e8d6cd0157616f45e161876a657c0fb37a366f1f5fb6b2e4e92e123bed9ea765572ffaad9f38367f9815174f1f06319adb5c184ce9329e323c33df091636fa288ccbef21073b211df60a5cbaec8e7d7d6f61edf9a7c8ba7e8763fb2a6cfe22aec629710f2f90008305e0602c51a14c95077e05573ce9f07344390680e55f6951308dab485372c6dc9d4506b927be7e25ff307e28083c5bd585c724cabe9b3edc62d43caae0b6ae92b1c5d299c7437788b4af4f10ef9873f5fd80a680106df130fd471613c8fb67ecef62d24b02c60ec02dcd0d55c574925df952cce0a212435c38643f060359500210a23a8914719a137dec8179cc40f4b7c75ce067476bd3294bf8905ea5a9ecca21ef41c9fd20585383c92e2d51336c613063dfe8e18cfc31449c6496354c219ec85b2f700c41ef179c35c3ff626a15ede087ebed0f5f4b81b7d3c3f02dc0e446a41d8c1050ea2ff39af6c291abf322601ac2080b668b693aaecd3681a796509836b9185f975daee62562c40d0ce542fc1fc8d55a89bd72a164109751f265e65771e735f5baa87adc79448d088dbffe7dbcf312a19bdaf0ee941fd05d6990b15eb169cd6fdb503727075d8d09e414e792c3203a838c93d9a9e42edb5ff1b055d6001cca613b6c2f711c26eae8fdb6929dd721d41291932639058f71f449be5789d64f22a7d6a3ea6dd221b3bd2ba412d76deb95864f0b0e1d525487fb0c78c9ea5c13a16aaaae4c44a91be12ef9970a0331ed411dd06b95e5dddf095aa5313e30df92185c9f3be67bf24b84bd6e2cb966713720675b2cca1ae71d92d88ecf828c03eaa45863fd13a39003af74f6e1aaf958c5b67b7e30c58f3d689d40ee270defe0e16a032ae9b0451c7bb73e243ebcf57b31e82fc584b300cf1827bb06792155fde3caea195c897205b4370a2f660819872bedaae8de7c6862f28609c604a7ee01821c1f1d52d473b42abcf3dd97bf255732661ca3c3c67fe444b02ff00b52438b9d0ea58f2ef0660b2d7dad97ced5239ce7bbaf7d91f56fc7293d5afd0eed97d4993f4ec3f48c47b4511e00f6a8ef2bd9932a6052fbf072dc5ab88cb84468643e7ab0115f169333f7020a1e81fb0b7d742da98edfef43c1a6e21a7aee667d91f6ae3fc936b8e4730283c43bd40f36037e45cdf65400bb0a962045d0023134279e8d78edfcb68b184f4e7ad431ecc2843e2e1ab02fd42f206e7fe71bb05bc08ff87a44e388f8e0641622f38a5275547a5985c1dfec6c5cfc0c46ce4cdfb522cb933080b178e3aa2b810e5cc821a61d53c106c2e5e19943e99014220e4f4fe25ed45a51585a1df48be299726a7ad85642863b50fff3ee209540fc6d4bf071e4e6e3aba1b410e25f4909fdbb510624a5ff888bd7bcce7627c9f21752074d7019a98d55cb84ff662abf061fc4f47f52b43dd6d2abac28d6ab79c2c1d62eb991ef38a5d53aa63f349dd4ad3082c3cbf0877b022def63d0b177eb3e9d9512861a7ac7bd1a953e3b9f5e41014b21ebdac7b70278f2523b38b80f166688f75e9a48c993e788a32992a4f6b9d37560d61e3f800606fec5f8fa3c80de8a59f366d0a1124146c4ad6c5cc956d3db821acf0fa36950a467aa78084bc47eea1c16c64a20c6f73b326fa45f180a7cb8291670eb700210096e0a393074513b91c52b63ae8b40351ff8e2367510475c639dbb6ac3e8f2bb38f423c5b3d16ad2d0f5221ba9a4411a59530648308062cd370c5dac80858978003ca2e4406303ba0912ef23ed863bac10a87eae7e76b5c7f2e0fe2893340bb8381e6f4a163add2659a9b5227c2de86bfd835737736d91a5f6c39df9eb8b7e672d87a9cdab1028256672d65492faef96cdd1abd051d30f6500e502434dc6047ab55dbcb6a628d71ba14224725ee8e4c29562caff00cd5ddc0e2e75ef11e427dc505138d99d12275292c3c5ef53f5bd05b4e7ad88aa27e66ba0a86ce58d7e9cfda96cd4d5565970888d031b5995aa1da13fbe7ed4651099512f208aa5c976fecfe2b08671c633e965556c71596bf0233db9e775987ab7ef217f60b214cea85e67f259ca55a77ad6673f5d7931e04b30e19f242b287ad10b4ac9f004fcc91c42283a858fe72c97cbbd95d6e29ec650feaf7cfe03e3206a6643d0dc23f136e41bb95f6e692577632c97c1933d96ff8f403ba7572e42ef021d2666166af08cd7fe752f1b6a159407c854bb0d10c0b5ff2e504b343f64fe5b481087d056d18717e7c2751665851f0008431a1f75b28d49e8073f08e5a593d448ecbf4d3697635f83e7160d296b6919e330620dfc5e619361002262ac8117f122e45fefa4bdbbc4abac863e7865021da216d4a2be4d5cb7c5379f342f538da946cd62e5a9a20f4e004e0c5d2b0809f30dcbae95e7d295e4a589931a82eff128c5e6e52aa7f8f130205f5097b5db401219b106868227c6812a0774f9452a33b2014a6f44c4a5283f68861d3cb9e11ca3e1d1bab5227bdf55601aa075b72b30df200b95eab7c7fea864a6e9134d1952195ec051d6088e55e297b6ec5220a427aabe91ad0b920fed1716596df7afe0ed2e0293f9f24a5a33b6e0aaa6a16d4cc301a76b2095a8e4782ce78434acd8e9f12d7c45647a6cfeaf8a1208aa351cb7174bb7d18a3f7f4d3f6580256d5ff0497e3a89fdf45db6a6d07de232597d2f704d78be2849d8b9eaefbbc190b741973c8ea96e924778b07cefd8b06d2a935188b3e6703928106ad1a57ccc351315b48462417ef4a9182dbf2959b66cd5daa547f432afe728322a16106c74bca97b94b532f3e77a9f13e4d57f60107cbcfa8805967a3038542bba9358292ec741c1d7275ab444e9f7b4050f30aeea5ead59b6f3cc06da4fa3afd8e5c486d1e7d9e3376df64ef5685c44356fbe838f5170e0d74c75ffb409e357e5d18960b3b3026fd7e85546cb9ae933e4344b93a0b581b980a4910b483638a4ef4a3d769d493d2493adccf9ead1a117994eae38b0db4dc393848b857f58670e9e129891f0072ec0b766196184221ea02365ede5c7cfd0ad53c0d708b9d234f7d7be318477cb6abc7a7e02c59f33c7105b33f4a14b0c4cce5bd0470555c7fbad183481745efc64cb024fc3f76954f5b65b1801e39098087fc63282047ecf890de23508f03b3549890f606ab1a39dc0c8251ea5bc17f22a12a269dff859edada6a58d447f6b040acc86b87de7dcf9804eb584a24c5c2532dab955c2ff8a3bfc65dabe4d9b2bb19a007fdda6a6d05225c73d6625153abb1bdfe3563cc685950640b576bb35dd3e25654c0f867377bff41590e778a9ca894b39b39c1054f2ab634e95b601832566194d5880a86a65ad9de093dc6cdcc04a58e179805cf9cb4e84e56a13cda036375e833eec121ad3ab63940304fcf7fae76a5c34ce8af0d9dced354de9b87b48e9cee46cf2c4dc23b77b2df062226b1f3ef382c243553c8fdde0cd38414731da5975a461844099ac255081eea1b513ecb9f5334b2f7438078750508f1ce823b05728c06fcf21a971dbe437c5d50f029cd89a15fd63c01d566c345d3eb71dad33d35847e41bf05c0bac918435922e0e8389f9bcb1126b03a7520c29ea092395a2b43f8ac9f566e236da5cb3d395b2f1e22fb56fe134153f6c026620f321d1d6f950d169dd967c83f7c476b0232d0b8356576a1d116351ce071d692875937041d32ebddf391528d4d6a9da60b691ec4933d500733ed48458e40e449fe71c8d0d32a90f42269c461dd0d11c0000aa49de59a0e2866b177c73d893052d882f15c1120fba8bfe97c30b2433c5e1dd5ee147d1d9d5642d5e1bf576f14652edab82ecb0d30a3d944d3a4ad769587d965630ea80bddb2efcd5cbe025b08132a802227c897c0c5e450d59d1b7ed95e7eaa79a6b627ef0f53fb239ba68c6ef577a701116e175664e0b7e3749679de7378726064a3f9d5a7a8b20563405745e94aa00924ed2fd3217ef70d806c904a5727c8505b78e25c26014a136875b1cfb56c004dd800d48a8db15518fa26fc9bdbe7d9070b43b288f8b542cd98c6d240b2914d87f347522d5ec2a6dfff4e2d79a392540e1ffbb33bd0247f512509f2103423add786d10f886f5d4a811958ee33c025270b1bf75b87193186a819be75966ac45e555a7c2cb2248511fb17f0727e83e57436b6b7fd09d9650094e6adc054e6965194c3ebc9ccda52620812d49c44c300c87f859f9dea1a074ca6fdc099010949d7c2238503231888c6967aa3150a2786c4fdf133767297d1fe9ac8016203ac932e5726853c8a608d8a06d23cf53d4b780810a6efd9726a2ca12475d9d28dafeeaec265249b325e7e965fe380096eedd5d127c0c676d51786ab8e65025c78742a46cd4008a9123f8dfd935370acddc25e04b21316ace6fd43b469151b4ed5f74e10f9f708086eb52c27295ecb426c12cc02f0cc3d659a4682329fe8a88481a2511b0f4da5ea6fa26c399a721d53ee32bb18f6998e3646a087afef86cd90cf516d65ce82f42b362cb4c247b258d57c1984fadc12cf37d2200b5c15c05292a08fcdbe17316e0cfa03943b7de0b883d86aa9530cf4d43fc112f52cf9e3bc7dcdce017279fb9f42819eb7d90988256a5edc832c30664fe6be18a3451e4f56c644452014c3271f79302b3257c6431aa364746f8e7aa5ac9e2db7e3fd1178972663049fdea4112fac7cee24e6da667e0cf43efef05c7b71e3d210985b4e2270d3c55e320932212562a792560c7f0eac0412008eb71ab09f782ca6fce853890edbcffa953314b6553c8bd598e879ab067ae0b3f54475ff3c32cd4221338b4b34ae797fc76bd2a010e3d425e6eef64ff013c54cc39df09be1dc12234cc642b8ac0e3f448bc0b5b112f2551b05c8365d8faf32efe8c774b9eda031f8e64a63322a92f137a33144dfa96f9920c5a6eb7c9b848cd12a3ab9a19118e74346c42bf0a076b70a5c40fb639aba169ed7978cac7b9c3cecf47f2c1f4d5711533364e2cc49a3fb490c3981097b261f07b70362a1610fb9dde56bb15f270359e7771d004bd57b2dc39b3a3b69f75b83b4d5cebb3ea55f7536b75740a511cc53bd2d5b39c808a87ddad6adba0024d919ca9a2cc307fc2ed3e24a1a6e94b6de98b77c103d0011058026925c77765188dad0c031b3c88ac2f6f650f502ed656a0c7d9fac2b7a465007e9c064fdcb1d5d00365205ea7808e635157f868c9a376a193f73fde08d0b0502725c32d63fdb47d1fa5ba45027ffda170a101860705c0eb0719caf3de578ecd5e0900b4fef72e766a5e325bc5008e07ca9c768ffd8ec5de3b69e345c1d6cfbe204a577c3ccf7d22807e30400c9a70a2ac55a55c67bdf174d69987647b797d60e7a0f4b82729828d120e284a5ac532605afc10bda7091544bb3e4f535dacf3a450b973704d19d2ddd865da72f46412f1e43174ea89ba8a9937f42e7fde34e0354830b56d06939773ab780999e424138d920d2d30979a45c13828e20f035600708061df0361a35f58c3f65670458f290c9599f11fae54b212a63b38c2542a032b0f62c66594515f0b9d014087bdf112062ed1a6ed2f86314804fcfd4627419482ace795338803df9f1ef7d2812badde9f98372225691278cfb1b5ff684053f1400a21a3e40e5c259d892641523a85ca56f3e6dc3e2cf143c822731bf9e717ae10234ded0a4dad9124a828ae8376a81e2f9d7f1d5702b7897891e8952d3a8f0f0076a0a5f6ebba5be05b09ef64576782510c1a3538a91432bed22723dd940ca3291260f23cf77d923d7d75cfff9f04cd4b9016624d768f54d08c52ad2a01e690bf151d4546ff944d7ea3fd131f1913bb02cee5b5e26396e33d699547ae4dd6364d716f4e6ea770cfba97aaa613b285f55994a11b526049ed5c80f22813935953d5333527a1f1f4ee6b1ecb6fbc4ed431943a85734315ac7620c54c4711a2a955c863aa4b86b1ea5f009b90302e6683c4430c014fb71579af9f547d084eab6195155d67eb5702edb16cf1323cf07a7b0cab5bfaaeec90a99b7b33857da079de82882e1c339610c1cbe6ff1b6bf00945ac74565780e6b76cddc7f9fa6a848b28b9e6481e202e4421e7e504d385f93363d0c227fec60c214b0538dfe6e9c28e498ef0f90f6b112ff8e462629495b52c182599090de6d47617aa4ef77bb3efd2ca8ac5a7d638d47d34682b68727d8cd07321cefc6d46b36528f558d2a0a324288ea6c5b3a069073377c01dd61c14ce9139698fc9f8cae161a53c19303670f58283bed9a3070fb65eb0c7f0a462043e902586dd230f6ac85eb7def455de016af706c7c92cfb772f0a4ab232f04bd9bebaadf969381663f34b437a5d51f31a014a4437125cd894f6eae481a6595f7288dc0685fe8de1343a1684a13b72cbcc46caac4ffde2d566a9cde54808e1decfc7e15f06358aefcedff4a561057c5db5a0232a2588e24df0d21f5cc54f986b91c4493af671722a9cb5688894b563b377f5d35e1e2d11c5caefa8f09a416628c12bf03f9f5493c62a88e5b7c1f26566674e57875ec4a5dcd28c835093c268f7019eb0e650262a238cefb2d688292682d21768510a791647b6bdc372306c95fa2f1fe197c2ddc12886022b9f86baae05021800707d99b5cd25c0ac57627cdb63910ae06e520d8544a900c60669cc08a26dd75985ac2bb95da94f8ddcd90ecde89aa4282a7b7d61ec9af5b701e096442e6dbb7d1db837c8faf618bf4feb80ca5b409cc2fe87fec496a09f586b3b0f0e7532341367e10b1f1884852ed84b3a05540a63af49e0467fd423aec94a10aeaab90a42d3e265701542818685301ce1edb82b4105fdf2563ecb3cd7fc4edc7f4ccf00506f6ffc0bbc38021d9ffd48c2591e32cb2aeebef8c266ded70442e62f4930fee9c4e930b2948653d4d18e11102351c46bd1f200ec7b43405c3caf1e9cae17b57cdfa2b873bab81f179f0e4d92745cd46aff7d1422213affe0ae9e882d71922b72d1c1f005f2705e2a677b5fc44be4143a76e9b955ff0ca65caffb243b76780d6069a51d257088f902936144739c8f8b0f78e8bacba9574c1944e95918c0c3dfd02c2ac05f6c71f59d133a09b2f0ba4ea4b6afcdcb0dd4819d20388ed5e8e7881548335064774c49eb53a16f8b4f947906bffb34684237394e2ef872f593e374b960290360158b91f3d5d4d98506bbde3eec4b3ec8d5382f39553a4ea7126a6e6ea47b20d4cf3c98d0d0ff2ca1838136745ae62ccde4afdc501feb7ad84d3a1ac5642a637666ac360f7977fc9f641d55e809433fa0f155786f795e21d7c301bd29fc1af9ce5d77a686def7f00fbece19b13670fba2dbc094a0aebc7a8b69377d7787bf1faaf681f73d2ab9bc690b69ce9a786d0675ac1f1ed3889e1e90428abbdfba84c7f85cab8c7349bf0deb987f1a50d3dda44082bddac85dbaedec4345ddb7be3f47de8c7e514766c63ca294c5ddaa282e95cc099d6e58841ed6f86d56d1960640248e6452cea92dea4af68043dfa931501dbf0d000e044ff2654951c2154b1b665d5b7d945df4e2d044a55c303ba67dde439c547ac57f7c548a295ed9f19482ff875f5b64db9d92bb5d2a0a062b984aa3b21486edf5265ab7e2ac5f5b54619388a6ec6211b0a3dd725dd58533a01a2f27f5a4a65822221203421f3f2faa3fe2f782837ad8dacfc417bb2c06f5a0bb8638badc4f2803d7ecc991d90318ca18c131cf4a3a13a8f71cd1bd65a589c5fa0acb78bf8e0c19aa8a1beeb5fd8fe609bcb0a823f802ad5905c45dcb8c9669039c6cc75ab12c0efc92973d01c8b47c805190420542c05945da2a4f45048df8041abaa22a9d319f694c20b9aea33e2b29bccdbf7d8afde4d35eb1d53f67a30c3cbf4ee93be1bd284c156b7644e76361353afa32b24274e38632af115d13da21ffcc7736c0573f7126df43ff6762f8975cfd4851c2eb2b99d5f113092ca9c4d2f971029ae59271589b1b3a37ec0e667c9e96c500629c4bbb3594cd953a33d767d0242c83931adb61fe2f26b56e935343d71ab9d8c223094b0661a4b2f4356699dbafdcf5e075e884d2cc6e6f1b40c4630ac571bbc08700046aa2e10a924eed2f1000d022ffac9d2d5ba6666213b384f1062a292a323ab5bd3ea0a5e87f4f18c5c447e56e42f9108dbfb63acda58cf6378d19468f7034de531271f913ff203f928b31d96e0e1c743981d9e82a1e1574dfd24eb73175c0b74c09a102f20d46e3c81bbdf70d8896cd3f6ae236ea76f5a72ab23bf5065413b90e0dc2b7f4400830c88bb8df62632a2936e9f5b11bd6fadb4a213c30397d69dd2309135a12870e4ed686dd5291f06d7288f6bcbfa5fdad2df6be7c3edc4637336c074696aebd3acc9c534f4de86b02c23344eb5c9267f01e39a87461a6092fa613f63c8f033a02f14d1793dd8dda6886799ffa8c825f03e6c831afebfb633797515e4c05206c645e2ce5b986ebf9a82d2ae32b1cd714796a835934338febb3931a197b8bb49cf2245a069ea0aee9d551ffac8e6513868a98170b1636a466806d0e5fd6595b93aa4ceb5dad30ab6f05dad56082e262aba9f164f60eefb216c91053a706bf8c35de50f98bec8c143134d6b06f822e164d525834282ebcf7e225ea8c208bda15d723281993cab5aec4a856060f2b9967d3f502ba0fe2f5d141aa3cd7635c2e9e8dbd03ed9941ee69ea48b3e4300b10a9b9c33ede7a9b40d81721123bd5f22120687580b33fd12c857909381ec4a7e8fb95e601513aaf247a07863ff9027a0cb6aead03ba84ace8aac719d91af0bcb54db2fb4805c84b8459f676882d13e1da57ace1e283d2babcd52eb4169f3f19f706e4e3206b9ef76e944d8ace5610b1ebb22c1e50da8b921cd6485f91094d4fc652d9a8c0a740c7941e201278dfdc4aa2bf14fba2a0418b7b7e24794683d9093c06a7591497300f3a85eb963fa7afa72a1f400d1e6de43c7d4bb878bbecb129ee9bac14acab92283302f01f516a92dcebb7824a1a8e0b5dabb788ca67ade239ec83a1e361e1bd066852045d681279e4a17533962307e927a50f166f6a8321ed16f24ea77ea5282f4d6753b34130004ea17ac4f0acc3583d2bd1a8ace0b000e5eba7f88454dae87a486d64650cc2bfb3d038fd2e741fa4b081b8d5b62ff74d7104b6932a0686f5854d9936189f5923430815f5b4948d5d746fb4fec1f8ac04b9b572873c78658a8be096b41839fdf6863f9cd8e8ccd9db78280dc1fcc713c72b47264a90227e6ecb4cdfc6a592565ee51cc83f2f01524c17b4e279170ea77e2e0d5db7262c3ef0b2d241e4bd74e9282b06c6d40b7b561bf6a6817756fe04a9d6d0325091df810dcd0e71a8d05fb67ac69af3ff6cfaa6ff4f97b3677a059350b2dccf8f0f2dc0f452ae295b9276143318adb4fbeca62714c1f6dc7e7cbe92df2f60a468a017e3f03ca7746a5b74e55615dfca67c761f0e613281edf077f1fd00da2db7668eb817fc7e9e3314302b862ff989579c1a339a3a889756d2bdda241cfd8dddd10e09eb29b4df4809a5b9c7c1bc3140034cd40474220d48f674bb3978e6c7c2f189e33ecafed6ad34ba37fced328851f0c7bcd072a896f4de076c7edb50876773863e90f67a780fceb2bf254bd9b7e3f2d2a17e8f250abebb9751392558c5dcedb9607733062e09af9a60cb2760efa2b468a1c393d746c7d1ffa4eafd3da0abc73fd7d18d3a226ecc390dbd31d7fabf43f243aa9f926ae3d356769a770802a68a017e3c16abb76a9e87d68013874ea7a9003700f13d498c0b28c02e1f3addd38102856f087cb281f9d826a92f438e9a5eea8f3422409aab83ea873babc9279805b202122b9d3f34a2a20fcae364b03184b5c8b89689f9d3aba168974a08cdc3afbb149d845b8a8abd4969dfdf46b80b9b618b9c6df0b34e6802ad1539babe2735564d2aeb7fba9cff9d9174ed8d008910f350f3fb1eb130e780f5354c792251b8824f14ebbaf54cebb3198f4fe0a99ff4c11c37fd3411c3c1896b7ff0bb537f884579be8843cef6f129753f419c19ecace313d0cbd0e0e508b933e1b1a46aa82092fcd5a921306dccd6718e79bb7ab05549f9c854ac7d11de1e15d80ad73a00a43d6d677f33c755e70dc1d9bca3aefbfcdb8b6493732a80645091d5be455aa3827f076f1cc8ff2ebba6dbae8cbecf5b82fda0cba8a03b21bf5c34f3eb31dc3106d156055717a7c57e7af12817bf53eb62808877e38c9e15b3af380f8b3d46d03fe8eeb023a84c0de5fad0f7f0d875e1799c4208d926db0e8c5d6d2a0ba512a1f26cd130fe0b18903d4ac51ebd98d82a4a54ba9ce2fb471171caf3da94e4029bc53d129ee09d0ac3c1a982b71b83f31e284b780f5215296c9ac2597d470c65e8114742d664d927af7da2af8a82b8cc03774c59f320120b672feebebc258c20583d39225ccd9622d9bd8ce99574bf55e7ec035b8db870974b4f7930a40e184e8e75b562dbcb97f097fcff1381691a58d7cd42f02047f8c0a8dfeb169f0e6a2b231d9ee86a1f882c4bb6421dc1fcd5ae3119cf82927891684c550e72655685bf2b55442d6b316ffeed75bb712d47f71d83faab8fc90b5f77888baeb0a91a6ac6b05c88fd087dd49e4760a74561118486803f22d0c1c202ea41ce1c2a268326677775ca334dbd075a5585a1ba83c050c2fff4759fb2d794bf6af10cf261beb3db7e134a068d1fca16e699e590bcf5072efb1c40e77085f97c2692d0e235979f54f3946346424279bce79a8cf20d84e836043f43ef039e77faf280f35555e623d636d3e4608814e22d31c4db21c6834ac1379188c82a6e84a11ee339810eb806f09e66fedca34d52b236440c2c4ee48311e8649e08b03495664ced2a0b478bba73fe7504962eb1ae0004d8e2b57ac51c69311b3c0b0f79f343389cd0f4ffd7215773ab158c68e4ca6adc4c92d7734fe4f4360827a7c4407b022fe9ee9bff8d4025b00c9466fde6be693dfdb5d1a788b63cf936ce514ccbd52cd32f55f908768ae184e69d81d35ae561bc07ccfd87dfe48267a68e63811509c5d7d1e6abaef887c4d022b1debeda87735c285e845bf6496ccf48ba9d112c19cada8154c5cd3843e8aeccf5757cd0cf36ddaaa33f9d19536da8a72952ac8b0dfee208d7a3d902f1305ff5ac067739ea3f52d5f4e446b5ecfe91bbf573190816429b6599a3de8170cec8d7e1550efcfe7745a04f43ec5d0761da66443d00e6fc80038e39872339719ab3ef14520c21de0a3d48c84bfd602d7247b531f937141359a15bba5ca47b0e307f7403f5b7255d3e8d5483643db645cbb1d2b35ca6bee3a23348fef9442b67ff455b89fedc66a0a21698481d010d72925e8e41b283a7f82a9c50b3a6016a7f0b284ac30a7a44c7dd6b5ea92809e0d1d9137fe8e627cffe8189d49f452a515f629479fa221774c44afebc4d7bc20ae68a2f3af32589eeaf78fe6f21dd60b0be714b6e47a40197c79e4c4f242fc24871949a2f2bb50a9155bfe26e324a00ed68a462a58dff1b307ea4b1b2401e0f32a029e8d24c89156a752ec766421b602cacd303b6ab3922f1bfade5aeb99d3aba2729901c56c8a846ca8a64b8a86184f428aae8281f1dc64ca2271744e70187195f426075af715e6fd8054097463bb9380c818f1da20a0051cad015881c8ba57dee65c1e5c686b5cddbf0ae5993b83c4a34fd505d513f59314f4d4e312b0790d46aa3cfa927354e382aa28caa54a4c7d55963a0fcecb983a2b9c7b1b3a7749288853c745194ee9871e1270b6c4a18a8acc7170cc9d8a27644f336595cd9750c664a466cd8a3e8dc9b22b7113ebcfa4d11ea2386abb6a14013b4c43912a70c437e0f7d6f31a93ca564713ba283d17c81552b2a5ff812b2c10274047f2b29929d461a4c81517f720227b02eb8da4d64f3b1eb843ace41f0fd2b26d9651fd9e42d451d42a0b94c8953a20e89719d711a6462ce0f3ab6bbaac445d39b672f2c55ae331953a49a372d91b069dc0130c6d3356d19b2d690a707835b5abf0b1f43b437380c5238c591c70fb1cbd8328bd2745167d3ad4dad4c8bf06bc8a9237027ad3a5087ba92bc043296c8c13b4fdf1288dd8513fd62125a366cb05c3fa2ce0693f55fd418cb8817054920f17ca1c493d93f2edb72d043772c15585b0101b519e6d8db087ba41484a301b99697051e166a7431cbf2f182ef3e13eefad921f5315993d8b24c0942fe9f6f5dd89f0290325804a0b37a65d3e4c674ad70598fd59e5f891a90d258eb5e516563a5712b9815bc80edea28248f2ce5e5a7d4896ef6341fb71247f8f7c128dbdad931c5ee0a6e192d57043d81e4b52d3779a27d8e550cfb79acb5a998f173725a8208bfbca1cbab90ddc0c0f0467becc0309c6439467faa5c21da75bc7f262a238369d0e3c208611e29c39df92cebceabd53ca57d30bcd3b69501386e6b1975dc924f89e9136ac4b6070a0721f0a4998852a108417d017bc0eeb980c2e0a9856e3700a13764a554e50a582df57822825807685caa4d6af1890da5fccc8eda38534cd012a6a6c827c2b902acb0849005ee40b703357fd1627ff5357bda8d2267e14f1c04909355432f00133a25dc053a0cc221c45e6e4f2b77be3312a0b013e164f4bf71b2c1e9d41ceb9a0a92f1269bf4479a96ff24f4a9852e3e726db14820be13fd7b58e0b9adb6f95e64a268d4f2751d960f6b4717aa6b4fff8b084aa5023588349eda9260e182d154e2b475c935ba938fc4603e5b07bae8d32496910b874ec58c2062dc47a2cb5328f488ed080d4e9264473f36a17070bd35d93524980169151af0dc531198193dcb0a51201433b818b0f86f19292d7c4571dfff0819ee0966a4f45280ad519bf884b79c6e7cc6f796455cde2bd9ad76d20687fe67c20d46a185222f32342fa4cbb606cbf98da219845b3671d231d31f97755dfa8bb752138840b68a726669f898e1cb1b2e3192ac3864cf4817f79cee60b53bf08adfcbad63e5dba88a402e879655807374f7bb5e86e792ab00bbd41411c1e3b3648078da3d7e0a5a505bfe22090279ac063ded925d71d04f58bcc338f4b38541d494643e7c4ea87f67974d61f4ce34f17611ab00a123d9b153ab992ab7ba87cc54b1ea6ca365945466683c8bd92048769449169ac828e0c64a0f1856b91798ab79377db1ac0ffdea381ed2e17d1f77d7e75a4d35451cbb93572cdae1e749aaae43793d5457cdbe51157b0538e53a191077d60e7b51c979cd9a03d5c440ef60cddb76d7ffbaa9ef5b41e8999c15b00a7fd7d6d1af88e57828360d08cef47b9f257e26bdf42715310c1414ca05113a2c6010605b82406a9c1e431d159f4d1c87ec73d63510dbefd86e2c36fce82d84502c523ebbc7e8c74a3ce6529f3fa54d3193624ec34293a12fe4d383eaf9e34ed9ff30a2293411e91a5d7df30d3691c95bce3f11db12615d20a45334ec3dcd94311008bfb74c0422b524be59f4881088e593a5a47c61a89331962895f6cfc755a7193734d9a62061c8177effd5eefe7149216824286700a454cd5c20f3c69f63bbb42710571bafd4797c98cfc15549865aa93bf47c5de1581e256fb824a54dae85e1d06d5a089ed576e2a5042dad9ad633e5e3f643ef2e87293eca5f6994db6ad253d7bd22424af78f8e499d8a4543b93b679a081718500d95ec367c9b562281119b027b3b4599192d17b3ce240992569c1d8b30493acaa0401a18fc2863d9928ecca4bc2251052180d998161ed566db6c18661b0e3c7dac7c3b9725bd2e97dbd797b07a5b77b32d8f37db59b6f3b2c0625b058eb84f8c4defdc7a7993932d4e5c5b794df2b5c8c6c4b90081faa09cd3c75c0a7ba4f9f8b38e5a9de0c53f137a5574b1bb77c07fb73540e7c926ebc9e0919f0877dcd653dcfa69fd5a7dbaf4d378b519d2a4276c585c858c160432c09956aba503722fcafcb6e406a3da1ab6b2a8f62b0744cd99684e8a5203aba1393aa7066f260370a67a5fb1266283ed3386d0c40ee3e3e9dbb480635f51342871edeca33529934ba1864652cffd85e42e0666c07a551e7ded4559d316b17375740bc71452f29b9861d34465161a3661317cf3350093fd88dd48a2043bcdb723ec72540fb1e0cb9a134b8de15f1d3e387ca3dae80d61d9b13649ccc5b65612c4db0ea62fe70e4e5aedcdbfc616ee0907ffa6e779a28c50020cb1535adb112371204184d6e8937769c21913c7c52adf3475d50522db6772ecb18593a5a2e1da03e841556cd4682e6364d903c8b968df93bdea405a3507977067d837e8e24683d51152a7fbcc605db0861917de01ddb7bb87cee1b6975c66e9580980e7fbc1b718e09f569a3ee5f584a0844f9d6d9004e13bbfbb5a773c118e7ef73ef7ded44abfc2349a6198582151e0ccc835e2823284e10cd013c38e0f4a085a2566eb77c522ea438be0c55286b5dbf68199ebea086a6da807cac517c82d373c50f7403f13720731506b679f83c12fa2994f9bcda1163e6e39fb53e860bb6dfc736c421ff03699d69850497bb3e6e0d6e49ea79dac56c7a85eb755128629b6d9d83a10a8531dc24b9f074837ab185649750e161a264530576776790127e6c7e536c0a01e54b2e8217950a4ac36bdb34bdef5b6c02f863e8482c5afaf543529f090a026d6e9bb675aaeb24ba4e55aad958c7f60e3b13aaf859fe489bf249c590018f001beeedb4eb97c3076eb8b8fde8e80c0eb2d93c2617fcba12a579c25a023a791561eda013533c2906600ac30d28345677d96375cacd394988a998e20ce78d8901a8acb18df579d66f20130c88a2a496489fab374bccb4186d231bf78bd864924016b529ef3f7ff93e72aeeeccdb86969d8074b4efcbb2dbc018c195e6f0c0ccb9c42b17c64da09a049d477d08818b9043630c684d2ed9835f8b5731036e88996d32cc039345743db2525a3f3b4e95abb30d6f6def284a8ebcf2060f429567ef56547bb0ec17882896c4a9a3ce5240ce8b3445525cdcc6f3e25ecd37b8cf0be0ad7ddc8f4d3d2128ef4ec18450afd0a0faac472e48cba78c4adb8878c30fb54417d7894988522a98443705e61aedfbf5214289c0f17e741c05a439bcb57de9038ff5f6c15760596fd926a387600bb9e63d1cdbd41df119c8aa03f83b589772f35c7cc7b88b71ded86aa9f3370604940707af62c487a6be1db65c826156ab5f712fbaae5b04940863fec35858d3f71bd20421a6b8ead66918cea1e1e709a2fc417c7a7e0ed105f032bbf6751efeab0a0e7f9e03358e3b27919d5349863070bc8055179b78c6564f89ef4ae26ce2a57644d8d523de85a6aa55fde7eb06a2a98401965e17c0480117145a7efaea1845a7c869284cc4439de83542467fd47830e71f83981f70c014195f0aed5f62983e6e1a635849171fa0325635e17212caccc40bcd553b7cda85b45eefbc8aa79540b6dd751d14ec756419793ce11e546311757c69d21e29ae78e076abd57efcd6e9047c17957a1f7d3d4c3d2ed5636dee9f243fc2ce79d86d053c767fe2d8651a89fb5e91ee655285de1e197d9890cda903717b6e230305a243f2d3f24997104f95c994a5a9237ab62e373c34ff0ab2d6f3e7081354e12bd324932450106b2825e54f0ab197dcde735f95152a8229a870161639096964ea0dfe08e0a8801b90748368f8c1b8736e013f9bc8d2d80295f556b9c7af91ffa7a81a6af8d8c076d29bec7a1aa8595e959336f41980f9e5968c2ad6850cde012a4fc86928a6e88ae9459e28b92804d3cad3e31ea036f8b68e4e7411073fd419256075ca4ed8c69ecec482b43e36fd61a33983a3dcc7622d803c92af8f0deca339dc5a4f8c280e22a0f2869f74f03c04e72e257be13ff2f815743804e63e4ccea746e49bded0711816e1934bd5faef333dd8d0aa2c15e175b60d89d14e95a9acf88bcd5368c3f42066be0700e957c6a38b473c4bf887218bd14380af2d55084b515cf4c7539edbcb5167a86f6bd9f79956267884652a54ff95b11178195d950b0d79c0709bea206ea11bcfa766745e2f71eae21d5425a36537ddbfdaedb0fb81865c49c70de3d4b6668c9c8ab67300710aa4b6a9a82ab53472241354e4ed6376328125ae37409b63cbf1b2c16c713144d1d4923169799159a268f340a3e4158a17f4baf8a942f7e5ff013d3095189ce1f367fdfc49e9531aa4b639369dc73300a01d027c1aae8dd9c0c39cfd4baca7f708901ebce9b9d7c1306bd5fcadf7f03ce04cb80bcfecd344c1cc94eed2c7397f2f916b5311295e233295f9729674e04ba8944364595fdff620328758853316043092c3ff5b605e7fbba4a7eac7a48c80a1bb2ff06ef9921a86ddfa87cd572572f31d05ed22ddfdd8448ac7c9d7c0dfb2cd14553ee07c9451442b5e8ffdb3f08feb0d0c8cee5cee3312f9d33d1174b6880131e4ef66fc3e1f8ebdbcdb4149212c0b10b6c0f10ed2e7c76ada5a088e92c304c002f0177da6f7bdefa1e09bde144c739c269e7e9e50a3ac8051bb4a4231513bb57929d42e387ca2242bdbf3e1411adcecf3ac3acee579d587318a12dfc649f2f051c08d0f2b4d6e18c5115238caa73d4ecc4d9cf69858f40045c629b58a29d2a35f57144fe998caff9da1b1b3e69cadf175574652a45871cf274440a36155b5d1bcd785c9f46b632a0d95843f87b68bab204c3457db320a20dd028cca440c6b52cfd72a30e08f9ebea593afd8adf270d44c02465cb2e68bd85885bd90f5a48bffd16de72e9d7dd4277a9850992b5c6743fb64f0ba4dd29448f480a1867232a4241770b012ea2ebf551b6863db77ab69383f9f09f556588dd704fb0ce94730e941c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
