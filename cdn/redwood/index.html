<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"820ada0bb58e227f9acd0c8cf65e4ec1d069d9ab8c5efd93b60a5738dc1d85b866117eb41d1ab2acfc64cec8e2e7435288f947936cc870ee647eaba82876ff1eecae395125a796659802f4069059f119d87a7c4e814c0057acdf1af808e4a9a73e35ff8cc58758b1e41b261b66efe4ebc6b15e7234f83767dcf44013b155cacb79b12a069ee228042bbf63bf65398668a6c84d4de2429d698fbf99b49cbc77a6bb5f147c25b7b6f8e127b472bff0023df996e4995c2b89b5a3c8ff6294a0aed553071e98166f42f2f6404f3a425cef5c5c526e40326ca69ad80e6767c05700d4d5d4805ea8ff19efbb4305a1ae56f5391ef9f1e9af410725494d0c8c54334e86f13877e5a2f36a6ff69445e5f6ffd3b486f060e9cac9caf3d5404c1a32900e9c7b813300a49c2ede8b5c2ce43f8665c889ee32e29f2f5682cb92c60e14ffae4d63a6eefca2f7cbccd7c137530036c8ab34bf4d36e074201fc1a95536f14fc6c2770ca36eeb60958dbc443f1e6427853ba380b2e2740db051a7eadeba328e9a0feb3371c5ced6c46b32fd0e18994194560edee4479764bffa2abc8b56305ebab404a0c511f86cf40a90477b1afbf59927ac51695657f2db251fde4267e262bfb4caf0b80365026f300982cd8e2b8bbbdc0fd71d61da4341fb71d2bfa62cbaeabd72b66e53bc3454037953df1be468845fe0a9ed5617dce3c085176181c416ed5d2fafbf80a317daa5a21c2c78567a02ffa92da10578a0e6dac2aba0d5f6dd2a0d0974b32d91e7adb535a3aa09edc50f7bd37403bee17e7ab7dec4d39845eb6fd6cf30eb681d5850ff895af90bf13bac59048e9a5b9026926e4e15d1b70341527855a7a858daa37d408d7cc8bed448dbc9eef23a6283bf099a4d3939b0d32317cfa9c4c25c2b4cb4c8230bd6e75b3667fa980473db3572e8fba8495773d32a7e4f41f25b7642d4cf36cbb714cab9c7060a12ee427a32627bc2c15a74dbe9a1ed8fb2f728d4368840f98eb79c817b028926d02afc897fe3ed176b5aaebd4033f1f1fd4bb27e97ee26827670ab68f36b8514288e930649f9dc5e32f254e96664d8360c71a691b473033c0c404811724558125b83e17af4405980eff53afb9c6e43e17da693f424233c8c9cb314ed3e52a9a5a232531dbf5dafea5697b08dbe191d2b34abc8b40653bce11f4254382722e354a890f1e09a5f1bfd20d1c387da0edaf945c05a663f2c2f6aec34ca5f6b668f9f84fa911452be14b7fbdb6d708c79c171d557e4ab688fbf4e55867a9ccd216bfbe8d370400c90b40c561aa8d91f8f3ca83aab0a52d6854d993edb794366b1f540014036f16fc8bed83169d5e313488938c20598888596b30dcba87ac02642506d04098c803f5be14e6ccb87fd114b1cf8883a0c1a2d44bf16efdba9cfae0f2e0af8115751b9cbc07edf2d6c3895ba02a3b24246dcf2821f9618d4ed863221c7a0502dc7f1448e5a7288c3219492d928e0ad47efd82ad2a0711ce25fc6647829a2611fae0ea5ce76e6f6b0ddb508eafd6840f72eceb6bbb67176b634f95979df8e1b6867a26140f3188f2c025573789e5afede38fd3e87e07826f68046d600c5dccd9754d0b37aeda497b858c0dc146909eaa74039b9b72d3fa50c09aec2eb3db13026fff10eabb5fcb559f44c1b6e5849a9842abf21ccf50cd33a9c59cc73e95fa1d6ec6df8ad40a33c546705fb91597cd9e7cfab5a041ed9aa97441a06d186672dd493280fc2a09851811372e4e8b489259e04fb8b658e0eb10e79c0e34108dada53387c47c44c82ab30357b23de7f9bb2a22f76a1d9e9ea0ff768b4dfc9188136bf947b3553ed1cc95a0a58260d901d376feafd893c9a24046cda25cb809d0288fad7f96df0a369fc86a1ab6c27404a570a9d28169328cdfbefb7c4de081e9ff4da36c3712d9b31fca4a829ac2bdc903c30e63857c20079bd9c9ab146861c409e081dc4df7303aadad13348f2efe7d6648bd72bf6384555c5abc18c243a5acca4a7ceab62069d9962ab8c16e8ceda61f41f916f31d450c2f7015311260398c66b80fcd5b7dc211707e6f06fe5229ad5e08b1e804ad99b7d71b2902319995130140bf6cbcc79b542d7a3e8e786db435b9c0521c25a0620f7881537373b514eaff4bf8ee1dc5a21ddec14f1f39b7096287a47580eb3dbf4c729b18023b180848b6ea42ebaf5a8fa1cb2233fe4900ed7e59c4f8b4fa4e65dacfd524ac7419595ce75419419694e3dfcd7534b49ed4e87bea0f19a6dfe9e689834fa788348ac4a1fe30e7b2b11ed53166040b39ea2425e000549003234475b53ec3e61540383a904a4cba8c6be37ef82670a5370f2734f7f2c78d84bf146a0e649a96acca9fe5b26a771cfeada35acf289c6d09d736b11bcb4c7c1441a7d3e66a1448655647a6981a6f29be584bbbfdec80c9aadac42e59319bfacf534ddbe7f757cae07760a06c191987e357163fcb2b79c47cb54751f30663cc0666eab145c15f85c62f4b4ec3e1a38b7cdc2d7c042ce82b599bfa1a3c48b5f58dfbf896352c20f57f87deea606b380f4f7e5e036b966434f8854240ddb4402e62f9e9f258780f9f448003e53eaff39fd89a1a04be0bf79eaf404690185bf3ea9e06d195d8ab17b4c22b59dbdd246dd8dea427030382306155d482adbca2e999c5387cc9d918c6c46cc9047184d746533177353bc8490a8f0da1be0753d70782b97c6afaf74a969acba960f53a3db4c5f123d280f6a607ab4760863058e435a83a61f697be6a29fe5c5ddf8134c8aad634e8f0957b079381ee3fa40c220f3bfb8fa2a402bae8a0da3f15562b0fbbf44a0b1801f8b045a693a6ab42acee5d4e501eec18531e956f960a60f59dd69fa428f2d24d9c8b0cddc88bf7ac700f677a113c154b8a3dbc12754661591041dead0d725d0c92227787a25b8d717ef55f4b9d8a31ae7e19b29a3859b884d771b86eb93af7461fa4f4cc1db616f9c0575a028d126c227703fd6fb186151d083df9d2179ba11b30de7bea9f947bf60d1f3a175c7c1bed91c489f78ac5c30a14fb1271129f1164dc988bcac9087535ea013c561ae1be1531885c220fa67604d491615fa1a78dea593da7d7cb800e5d730e67806b912949ffd835dc50b99f91fc15bd6245ad746de7da1dc0d490ed9820440b8dab66725391846ec76c93d15a6b3aabf9a92991c67fd500f32124f322a6d01876474d8cfbed3445c80ee235b283f63381f80ecac913626eec12cb896baf69c4719c023ce76040004f9dac212ff6850abfb8e0014376e906d709cec73bbbaf6a9efd2135a5badd70c4b7318b8d40875a4c8b98791e024e6ea012d942e24f5296b5a8867cdf592a1dd1209768d06db0014d5759876cefb3b812accfbf8e2ece2cf539c425e5cf3d8dd9878615583a2644d3b5069b7b65676c7a69619e523cbc58a5039c889149759ab8ba713db1446e82d96d139995c4a46c2df3a08274ebaf6035122e24c9284ff3e45f17ccfbce969e512d634b0cce86685b96a136c7e8fd68730c0cd4b58f4a2efc70e71327d708f35848e3f693aed382d3e5f67e87092a803d6fe10e4a1e46d260011f64ad81e40583e79a830330bbf7fe5c37a3eae8e4839ee751b6cb02f655244ab219f08be1183074cd43fe3a99fff665e6d70c39361c17ba92c743b0a235a572da427e75d8c2bfac7472258463aade73c6a8efbec27166dbc7d45a3cf94bda0b887647a7ca2330452b9fe5780f6a63814a281b699ac680a470054f3246e53d9698c365f410fc33da4e03fa2d2f237925e58581b98b3485a3f70464c54d555452e90d66cfa8e0085815b6757d6bba42bddf6f19e2328190e64049fd4e710ad1e0f1ef00718d3ae8eed131558bf92d765fd62df436ba09e943498dfb3bd407e574e328b1d2fd8645523eaf467e567ced97d5ea96161980ad8517cc55d33278dd338bb737f67e998f1344fbfb2a0bcdf0dcfc8fdd4f760da8e70078cba06f7a6bc73b06a951d558ca1244b9f56e3ef8ed89ef3ecdd4055809031c6b518e9c9c4192d0d14458e24fe4d7e97f7bb80efc1d68f199c2df34778d99ef884f7ea5430ab01e91235715f790258b1745ddd534fabae998026c534cf58760ee96bd64c9c6bac52c0a3bb27edf7d9a83a0ad4608cebbeda84d6667c511398f5ed449b52ae89779181f33adf73c347ace5788a5d68157835a370b13caa86508cf76a3b08c0a0323788b9e219226d0772bc1068cfe7e5417008442435dcc43ad7e01b5b4ff858d49f6129ecbbc61ddd464dca1ddee76f30be36ac61e5b4a4dacc6033838289095769da0e0cd33b2a316cb6e6f9d433383f37b97340c01483fc41b482f248a47def75d1483532ac56748987ab78848c44149a83a3c8ba6114feb5b5e6d5a11d50cb28d655877a17185c1a79945c6f079550f7edd6053f1c7f97c4f57a746d9d97083571565d17afa9b5bb4f5d4f7accc692adaa9a6b5f866c0fe43dcc4efe34658914c2ea25c1915d80e7ed58f49b018480449b37e22edbfd6a85551eaaa7919390c44deddb6d067452b5de3e1d3c6f65787186409dc2f02cf3f2ec4457278700196af92a82941f7d1f9c95df522cebc4f3b600078edd5a6c8d1eb66ca2beb70b6df850b20dea118bc397a17d3880022f6062764c442b0f6978d00a98b7185cc531a1fd7d2edcb4118bea1e07d51adb42457d2c5d6bb1157a636e46b65592290f586cdfc40c7cc83926f808d7514e292c78d15fad0230a2bd316743de2fa363f9d60a03024f4dafa6ca06d2b5535bbd31875c2fd629146f72bd5da8eb20e8b5b22c6e81684c25d5d86f7b3ef4650baf08a91ec2f39d6df7f3e741349435c5a32793b743a49bad5927f6b4aaf24e332e78f6b797d0e26000cbb0cecc361e1beebde8bab5c235dfc6e514a42b37a9e6f36c34d18b15fc9278abec562d26c5820f8ad6ddc6ece4a200a2ab201679bda0b32e2949b448fde1e87be2741eb32b6bd9aab30038c4f233921586b71c5e6dab706a618b1ff559b07c70f3204810aa24def7c5ff6fd04ea463fccb707c011ea5b054ed47aef45f53bbbd5aef7f9801fdaf0bc159645359c51075053b3ef6663745a0f20d83acaed3c8c91a090f5e6790f2b27f397b1ab81597e97b8a778350c6da0d980baeec69d31e9776f6e28d20c456b98eb8b4c0480e744bedc33cd61e36a8ed6ccf80ae1a083456c39c3a8723a9470ffef4d4fee27dcd5a87d07af9da7455466c069b04d90f70f68de9e44d341132813bfa4c8fa382e2da057a3e4f666f259f6a908b62523b21ac3473a830cb40b2bdcd66ca6013378a26275e47526b7eb0a95d02dd551466f6d9cc0be753c7689e69d687cdc6ec0590fe6d45cb7d05adc14f83ba4d829034358a53741f045ab0a38fa3a93c06634d5272ea2b56e34c75e8765d2e35c45d878d39f4b0bbf52ef8c5f52eab361f99c05f409fe29fb65eb53bd107857a499d822da2cd5d2bfba69c7ffb5fbd6063e9280e608eac0e8078c3f9b689b0030bb944b312006cc56ab7f38dae11ab10619db8d067e96c94161b51cbda7e8526747b92c3ab09dfd1b6aa2ee5282be8c48eec8dd30c2a8e878b0d30beddc8e1fc76cdb30bee008ab4934fc588c1219979da85d35dc459d85ee1649f97dd68c8abda1b49a343e3cc26b00b256de15fa6a66203a5da9ccad17ac6c10954b704c30b718a870a8e0fd008c051a9aa85c751109e1ee3ae00eedb93ad1e7be6d72a98884786bb98c0acbb5fee9efb9131425e2be4ba41ef2361ef6f5d644b541066bd302d24adf5bcef936a2f420b45de7ee3ff31a047589fa77aa113f0c4553064c2a5f71083ff3363abefad404ec63af9171f48405e5e7e666c8fe6f337cb800a0025f5d39f47ce83e061321f5d6c06e41ea38f08f028e2a95a1dba3839709921db1779c6cba3624f5bc779d24fd8ba39f5458040ed8ee12129706b08b339eaf2ca77145c7125b056034866963306b57d7b7557172bdbb4de69118321250add13fa7b0df86e378663c21e2bfa177856ee21d1cfe9cdebcd02658d67402a9d1746fd9657f84250341798f1a8f2aaf859892e888bdf776c06609118b0023d09fb47ec6097dbde7be50d85ab36a6069764d2eb4279d1a4dcb4024c5a3f8edf420b100255a8d289c4c09af7b6cdf590d8825bc7d76cdedaacd0efa11a4ee6480aafce9b7f0b1b9b6a41ee90b903265568c466238027e0cca748b2dd1fd987ac77ce81fb6c8a14ed4ef3bdae30cf90b49311b7b585721734a6c082900400d356b07e632dcc93216b013731e789ba27edc0bc2299489732c3f353ad9b77da97c15f81a89af3224a24b2b39ff658c003db603db50082a253a78df95471bdabdefebaff9182470f77a65e15897e7afb5bdd46ba26c633a50f88df9e266d0b39c4530c2fc4699e891c23f9da1321bc3cbfad9c4005984c8cfb5d598a922f3e97b435918fe361ec84f3b3c14267f1ec7c47795899427c67f15ac7f7f8be301d9cc9a89ef52223546efceb3db7f9d27aae6595dd92b963979470b0e6ba626b1208567c0c05b54ca9adf8209f43084490f7fda39e28ecd44c2aae9cfc0379cfa242df7c2acf8df7f411e2f552a5ba75bd71d463da4809a859d73f3b71d25f183152acddd381ef9a991b448669e4157f71d2961fbf0cd2c2de2f98ca6ab008ab51d997aebddb1a6c61b9af4ff8a3ddd234ef6a21203b678eabca9ebf5111e90c6ca5cb243d64e8da6734de0c64db62cd9bbf39df1e31cc559fd75218e99ac2284c685b0aa4792d479c79ec0142bdfe6056da5c096ef692afeb40c75355b4d8b52172d5c39c2582700767593ce24790933bcb65340dd17acc73194c95eaa7be4c436d8fa26fec3c01439926b2d2e5deb6cc33cff8801635543c6f30d1c635ca41e06857eb64504a731b9a0e5e4fbf396d64119e92592f802aff1a6fa9640e234933160d857882a4816c6bea803531f0ce185f1a2321313b901e17c5b87a43e96b10678cccc462f128f3e5451f6bfde637ef512f2833e6deaded3000d94e5083dbae2e1d3d8960415a5e1d7642deb80e71f2bace8808ad29f33335537e3df4e52aa5f3184bc806c001ee375be20397a5eaeb2bb8f871e043fb624ef700fc648683c73cedbcdbab6e87df605ff5d10ed8083afd1e4f729ec28618d6f740c70bfbef96bbe2756322d3c5863c6c4cff6e1909254c5982589f51e3cf5aca07f9aa27901e1cff828cbd09d077ec427a19980b53acfc823c2d664354a7ec4f1ee9f137d1e32d5c444c4e8e947208a97628d5f1a4e716794ee17b41ff612309df63394c5306f90e87b83d4eb6d7f41d4801f547751ceea87db4c76ab2a5babff91fa78aecf104e5654ea002baf0396302aa5e3dfc32ebe9f0cf7c2a3000f60d2d869d5935b0d724b32333fdf246340d36a6a124bf849306bf437053d04913e6ae09df9efb74cbd6e50859f05da8fa667d9d60cee84c6fec6d01734bd596699334b9948dfaa39ebf24e93101ee1bb507c4403adf000ea707a964730ba00489f7b7571fbd3817fbfe13e71e17ba509ec1b623dbf11cb3a1c5ef0b2071fe36fa66676c123a64d2f87e49395a375dcc7dde980df233dc4b26fd1f766bb0e8ef42d9e0c3c53a38e763bef79bdba8b1424d4b9829af853cdb8b279f21da9ab686b9d08cc0ecd32ff1f98970b7e9c8b942aa3ac2c6eef350a8b1263aeb4ced78c5e3bb77c96e5b0c1231ea881488a46c789b234d2ed638d6b32e1f9f98be9d0acc23916ca0646d1b41e974355c176438af1b4a7a5ebb350cb382137f4cf1404079ce02363c5e7c938e05e1daa0419ed9afb9384d490cf0e4866e55eb635c6f3753c165f4babac631d06d18a940447b5fa435ad27c8faad96679ebd7262b072d611f2e76dd75335ae59c03499ae1f11c18f53c8b765c36198ae4749a9ec39035241d91cfdd51ca2141a9204cc3e5ae6b39c997ac200df9e7ffb71819714c7483dad7bb9b6c2e55a5b466dc967b3642770c51c44c80f0cda5ebdd6808c6d63afa0122ad55d3ddbbc5afcd6f922fe3ecf733ba5ab7ac18e3f376d921eafdfbfaa9018611dee62820b3acd04e677b92955c0275a1fbd0231b4b0b9ffc10bf3e0b065b5e9e6e822d464621e7abaee60ace40837b9535b3fa1562cfd55d66aaf8df7af4c53b65c1be0dffa52462dc12bc4af70daf3cc888c6b2ed33e65091f8688385df28227f361cab0559b057ff82d1c3e51d74a705cab1588da2062e8094e6563acd3bc90fc9523bf6235a3a7846a4a5223e9f5567a48cf5c2d6559ef4bfbe9ff3fdca7c87b3f087feabf26db618932f1cf92bb5bb658f27a378d670eadd63d6e7534579c73f48e1d8068b7abe5255484075664f9f12b792219cade401830befbf892c6b13c84cdd3074f2c91aa96f3c4f0bcfbfbb3dc708b70f7d0d6ea8b0516e8a7e025a50a67f3b2114a06241de13abc226c8146735ecc69bd0b1654a96cff880362b4ffc6ade60d7193c183c14789deb077aa24244b04be708d2b35508558b318535a9a32812f27e485b85f456a206b3fddc96e59c19b0c260653deb876e0687c08ce0c6d18ed02512ce00bfc5143cbc109c741ad640286338f6c7ac5f9ae62902af120e341d9d8a5754582908a6ed3f4ec8ae9d9ab2782db81ead2b43093af7b2f14b54db2f1d9480061602581c1970bec8641468545346ec98c1f5ce637917bff07f72caa12e82c0e549d7a84811857474e2f114ce3a778797e2531177abdb700344f6f61b5ec892e221fba967703466d77302660290e491b8bc5c050ee4e9d68379593ec2dc4a445fedd2ea6f409720e83bc0122bed7b9855f5254cc0a6ee4c8e13c97f5953c6ba00137e227980c9e548b0c156818311b678b70d9dc1502187d5ffb9ab5aab5bd02ec6a89526fc576114e602a2105d2784bc990bf4dfaa92772081c464ed7bbd25fa177dc443cd8738d7328f463a8bab4a2540cfe0ef7ed4c3ef060d8dbc40b1060808c27d9f09e2298c5ffef63f5662bd8499d43ced2b6477638d3d1735bc8d2605c2e4bcb5053d118757caad6c01ca29639e93a22f1fa24df2fa83e19b6c449454041c485a7b2a26d71d2a2c0d448d08cb4bd140954013a7da63f489327ed4fd51470d44f43514f17766a454a8492ccb75af4d1bb82f3d62aa8aa4b3fac0bcb9a5691deb3fdd3154ce9840de41da7cb588f2eec44c85a978d1bae0cdb2084fec42c8673d5a129f2370d2fe88e685273541f3ca211b36fd8226c294d319296e81246a61f13ab1830e943fa3cbc67c4b6fe011c9e39589b4990f287e012cff5d0fe3f2168586cfe085cd2dba458a2942b67e56af227eab0d22ec49fd88c9ed92c548e0ba0d2ca81654adb234ef222ff2384adb6d5c4f2785d306097a1d0f6f4d693a09aeb9541bd241ff43e16ca1a49a894499472902abdce54b0ff42abb7ba22cdf4bd0634c6f2109aae00a9e3870b585309d640430c31f3e11757e7936ed6e4b07a92b560ab1c73657d92bb383ee0f1365dbf730b123e8c9edb117a9ef3e70fa214317f4f09e02036026d1154465e128aedad94568456be5956b6aa4f64948901c3d2a9ca3eb67fb08a1da8eb819f841442addb4ea44d753c24f8273e6f96a31d59730db2a96e9d90cc798ff533acc7f89ab0ab9fea27e324c6947e76ce02e4fe4e990be5848a6008e62358ce74ca6774f4a8c3a8f52bec1a68257d94c5a02ad1b998f537413a0ad3f75d036ad78d00d39eb6fc669a2b449348035795ce78bc7a3dbd78977e65cea4d8ca443493223cd27d0a03ba7630ebb80a2fa5c766b1d76970b75133388896d14fbbc96963266f43023e81cceca8b75370e6fac94983f4f612721fbc3b1b380a922c47f2d745743b903df9b073bf55f504c2e9813182150f9b7e6317d237acdacf54c15f39bdca122f70fe46d3ff40de3b46f93e5c8ef1163dd22e2d1aaa73cfcccf932fece66bb68e08d03c66ac203e2ac55674a9e4c8a10750b490615ace7dff9b24da60c8bbcaf732bd227e97b447b1f1b379b8f33342993b0152412e0123636f8b0933a39befaabc785e7050642af6e8d7a89d89cdfee39a448a4210ac84f54c084150f3d9ac88371be0dcc114576ae277f2f7861e1c0917f0f4b691bed7518c4dd2e1f30de718fc5e0117b281b03e585e1ab9f6e2fb54359fc53ed6ffa9899ca757de4946429a1238c88545db4c2e9302ca22e1d470782c4fe88c1beeb3ff252eff9077d894e64204943346a0c3ae3966361a07fc5925b0ec9ece48bb3a3929428277f637a38d94b904513e52e6a8488734b308d1c6f72412fb403732a2078578e00cc563c8af8d64787607ec5449f5b6be5fcf89637ef88b53e4fc25b47293e6b155bf84eb9c63f2b568e099e748fda6eea7f0997dda963116128fdbafbe531fe9c21bf79192d781f49b236ed74e1426f2e0993fee70444bd3901e3877b32ba58eff58640a70fda3181096fbb2e88bc500cce8b6b2dfccacc35b3b319054b3d30ed65500061072d8044bad3c79db7fb7c8824cfed283be33b9c97203b33d1f4062e4e37349eef1c73041125ad6c9f896bc12c13a892adc2699caf6cbb9b7b8ba1767f138c9858f99b95bc834a327540b5ae37b22196300cfca9701b35257b1f35b325802b43b081897b42c644a422d1f52b626624e0ec857b5cda64ae530b48e5dedc323874b653309a19c00a14d301a47ce12d19d318749a9a4cfa5f9a598a1f7ab0c9091be35a75da0f72bf9b8a71885695bdf571beb9f54377022279047b20439af51625740d746b7b607adc5a2a5618262689738e5ab903e6fbad3022801f06be951ad4a82d06d66e7af3c2bdb63d73d5738b2b77225127dabbe201016c5fef18ea3433b650f09f20edf65efdd40fa56cf63c87c822293dc3bb97ee874490f814ba200b8804dda2b57aa6e656c3a9b4c5ee65f93fb31bdfb95c85453307428bdec5fc85c9a965c10632be0b79e500a10a85f80e29ee5e4bb18add702c0b0eea3150b20184392be56958e046bd049333c4259b612c2adafec6de13a6ac4d7e6e1df553b3f596420023f44ddc72a5a9b1aee66a96e818604c52e4fac2ee1fbc11f94fed15cbeef4fe49ddeac516c210fce89c45869fe201aea4ad05263debc96cc9639942e48f797fb0a51af0adeb06ea80eb4907f4dc1742486de3ad58e6e6319b599676193096ac7fff566ebf4c2ee312a7ba7617576df540750f90c7b32532f678a820e6804f4091bb7f217a4931f9a3860d82f8ba3b19ce2b2305c1a4ae4beffab20f335b029969f2e009b8e669544200f41081b3f6d2fdc365690bed0f6b2a92160121889c5bde3cf49797258953420d944837146a037571052c43d644bfffceac5b13b6a512be8f3d38defc2d7a2cfd1f48963335418a5dac68f4995048f9dd6f8d0811b7ae47d5dceb1705058f793501f9b758e3d7d3577242b46708f0398e96aa0a7beed3c1610ff04c9bf4a30fed9a3dad5b85c2b4d219648126f52c3a54b24dfc5629f364c42fd476027723a4f7422a6990d44326a0890113cb36ff713f6752db583be90be2a1a0b74a3593c89ae032ed5aac8a95840edfc8c7115ec085bb103bbd20a11c62bd674ca21c30d34c1cc6feab67f91d489843a1b6cc9f4b68c79eb84a20a01374dc43eef6ad00a62c9e8e3fa471bbd5f7ce3f7986696c5737137ca0459f69b3daead95ed99790564f9ba3d1f872ccf90b6172b83cacdd92cd4d66f8c594b2efd1700fc6426403f05e4d7ba4e93a55fa5605d7fb738beaafb9f01604cf9e70885612836225e79e2774affc604ab744ae463342803e1cf226154de9c47cbea96fc152c560c2739e66155b9b286ff70ceb68deae5502245112d92274ece7a07a24fd4afa349eaa36e0d7cb1673dac118a18ea03c41d7e3f0b2bc7c0c353d5836e9cd393114b83cbbb7c51ac8188dfae65f86a7ed4678beccc0d6f8c8705757fb37df41200c2955d0be18d29a348c79cc6c8969b20cc5dbc53e01873a67bd0ba581f5597be7c655b119aa652a2fc01343131ce050c251eb75c239938169c3999fd1c29556201150ef122975f1041621c03d65caf300bc627816dfae3295abf1e867be979563cc610b55999a464777334154b1f54d6f65fc4c0cb0f4757f6f4be1f27dbb78ea3b5ee35a2f2d9996d40189e7e4eb39d99349410c7ac3dac16b308a49f78f24565b3f45354b9972f35cad1959362022cb6ad17dcba277a63813356421939b2481564ce3748efb15272c6a63b35eafdce7155cdce9043dc2016dcbb61e086213ae0f66f1f19932ee6dc14c49b10bbe90c134561bd8e487fa4e06746be00e82a4c3d9fddeac6ceddcac86d8b72e38b1abf792f89241c94077228a7d85bec8f7b34d336efd918662f38a4eb0167430147d9f4b352d984957c91db94349c32c4d1a04b2975da8cad4c2f8893d0238d53e7b88f6772c53f82fd9a28b917f0fc291049eca6c011cb46ac480aec5c1aebc7d090e598457fbad6db90fa0c1c694d6919e049f1ba351fe9b80a4c5151fcf8c40349d835355153a513d685ebd6ae53dc2ee6b788debe81d2d39c3281957a5f600f513f8ed73a09a08be1b6f79e2e33b9c6c8c0ffc0e6e67ba5bb799f61d7cfd08602e830e8ea14548295acab43053b67d626646a837f0e886d6f17b7cdeedf121755fecf2ced741ebda2b2e0cc4ce711a13ce3afa4e088cb1ae7b3b7d0c626a2c6d371f0e4662fa796462e6d38c4cfcfa802dc8169637d56eb84d9399a30c945a47a832cdb73241b504a6b91dfb68cbd2f9cd3e2abaea1b1a8abb1f5b6b75d5adbeacf3cb2405428265d4aaf9a6d5cf7570542c7f48eea070f2f0f1f46839ec7a46aef0497fc9c7e2019b4c67ac483dc5edebc345270dce1fe3ca346a90b2d5ea25341d38131e3a6c7fdd5ce18c40909f46b0b0a51adb0e019067d9060b14b9f40c4985997b370dfc47f5d4ce8ad93306b6e5dff6144c21154f5a6f6dfc559410caea886552b4ccd95192bdf3a7297d02a94da969847948c1f64665973b494cd017cc11e9c78dc0c480a48f728e5e4e292c1fa8a3304ae01fcccee7187abf4bfce37d187b0dc0fb908a0cc4869eabbe872776c20cdd02713105d6562944d2b8c266cbd0df3c8b5c538afdac7c191f2d26e10145ffa34e17776ae76c996628e75ef0ac8890455ff45c4d2c0303de7e083235e55de5b39adf82b776e2c245de7d4b66456c50f2af14743efcedf240469279c5bdac8f10e2599a7e40b371e370b98ad9b8929ea676c8043a2e6188c1a3fbba0817dd52053e37d9d88b99ff362347863ba0033c7c7b2ca974178055c683b72c2e0dcd88d7f571f03ce9d20bff45befcb5da80addd76ad71d96494a774fee3d6e0c3ef327ae0a355e2b84ff9663b633cb5f45dd496a27e120bf869a6d55509cbdd70bbb4e1761d8e20707a41c42387c49f05d6324c108355b6cee43cb7e790e700061693c691d81e8ead7ad38d19b00f9ce87d3c3c361075ec3c9cd2e082c92d05525ddd5bbfde65378966ed0796a378a4b3f62b228835f2f5e0c6ec32e0509dde3da31173979fab6dfeff5fe60c2ac8e31ffc4f3cc8a2b087dcd091dd9db94a342c854b21b1d407ce4c31465f76b051eef09818e78eafaf1981956f56079ddd9b223982701190ba55240a11f466b1e9ecdc71034ae8334f01e07c586caf0659961943f195a827ca60e7bfe702ad0f0509eb851835754e9d04388a2ecd5d6ccd4771ac3a8e8679eb2274749d2d5d3539994b08276685efe15ca707e2cd411cb7440b1b67b3c4f470a8f0eefbf4c5c123e78ab33fdd6659f9c0b8a59f5c08ff527daa2ad72aa7f60aba058aacb032a3c6f2f337bb2339c477337ac1fc95ba7f774390f144f97190d01ffd3363987a88ef25bc6b9b35721e08f85a22c661dc9d82997339da26fa3c068baaa917a16764fc68bacaf316e5e2fb6451004f1dd4dd05f753aea1960aca898ea49e1af8043404889a4cb73c02108c502552d79d1b85216f5fb4c170ccc53c5e6a8415088b4530ea8db14ed0e0cac25d212340326e563c5bb08b1ae3578cad8fe514d3d292bbdfac1fca5d3f4e50fa6c927331934257652bfdd4c88fbb3f74e92a8c9bd8d1a7b26a489aa33cad2d1c59ad6737c262cd1522dec860645f83bdd3c177f67a0bc6557355f179bfb6402a7057a5977f1b5d2f6a04c19173c28da1d6d07b995ba21e16d25f2a9fc2d50accfcf2a965aab0374de0cc4a1a1d7a6b7c592601356c15bdf954b329d5b74effe21c23844f6128fa8ca9281f272e895b54372b6960046f474de0da747a928514b9fb9610f2b140b06dc0a91cd9a6a0944367a3ba68cf8022f793f8956d241255a91410a11cc5323cf0812ac01a25f096e806330b1e72acebab51f541a8d7b52a55d99560ab2b34bf8faec0cc30428619c2e14bc01cfde85d34e4b11d19a160c70907f2b639b79f2d709b4f33f98a22abf3d7e8023a6db7eb2286fef3a2f830d240015cc613ad544b3decce760f2e1302bb135d9535c2c4710fb9aedd05d03dacda5adbd876c0bebcf0a8363b41f3579312823ca8def0b0db11ed92fdf7cb597fcb118c089428c02716fc54f2880bcee99abf1ed129c3f76845e12f62e6ed2a53ff9278af7256fa093a180b05e3c8db706718b4cb05caf31afda1e739d6796f6eb778e8ab4e2bd32bf105f91bddcf3f5a360788159741375ee550379945d804b347482aced0546c8a1827efab3055e8b28c7dd78ded1843f4148a7ebecf866163db60b70ae05488564406bdff4ce36f09741ea08dfe203c6e22f4d92b705f060c6ba5c9afe8c473fc773449a3189a75c70cc843ae489c23520b0a8851dad9dc53782279fd1985476bfca43dc402ca38e977d3ca5a9863d05b45398c4facc83f95bd4202ebf6331be319b709dee9e8f53c40789a9f628a5fab65386eedeb7fb4f572c44fa537352bde35a002d19c55323a41969f253d3a9be77168e2664a3b085e01e69f5553c48be4fc6785873136662287731310103466c2b7ab49f8e3a67a4bd6be0df1c6fb83061798d51e61c186ffee54834eadc448549f07cca919fe461d1f20f560c83b50fc32e5ac3219bd529fce5033fcfe9b0ad84b2f01ff3fd0890be086d1a75bebaef9cf96392b80ad9f5f32004d403abc7cb778f3d2c86f21b628ad2572157380778b88955fa6f1c08412c68bc10c1e5642464a118c571b95672763f20647d516608582cf0d17af8d756a36d293f26b292d8b313d3c78cad6ee07f7c7c0a3749fb3b68ea07a9f9832de22e1a6d938b4159ee40b63efaf58eee524ea905011abdd7d8b8718ca73487c632b8d050693e706655fe68fdaa5618561ae53ba669f077b0537dde8bb810b6a66c125b07e48ddfe91857de15eecfe2e9ff5c4b44089c125c3df7cbd66773d50516d6b0d6b99a99d4dc46c385f9b7a5ef835fcb321590da489b4bd873526340246a7db8b960b851cf743ae545f3dacd2f8fba93c94896cfb789c299c3f69d78484e661e2870591f3501f308b1c9eae9dedefb4e0b8fb80d6d06888c33e4168c12e1cdb7c7b4c660a57f3c08138e1135d45b28700e85045030f15222a66881e49513620bfd54bb555b94b8c489583cb939e17bdccdeb99e5f8229f7bcc40a347843ac696effe0f0f8055e7123469617d99d8ea1faa4182ba963d4a4fe1ded406f5fd1a88d45960e2e9c3bfadd845f7e77cf0dfbc9e47b5ea80074bf5a1e066002594fc4e740bcb24410760c0572e55521f5c007b96e211ac40398c98b517aa6a0dd01575d3fcc8e48f1a8aa74201e1f1fa11f30aacc1b2ec6fae4a9a4e02d10d46f5e47df3c00fc6cb8a5f36394a10afd59d2b3172a4b7319efebceff4a01fb610c753f2b4769d273c502b8b8cbf93e22bf52ebda56b44219cdc53988e3d1fb196a9a4f94b2adb6154fce3874144c3add8800e123be681655e27be7adb16080d4a970e37d740fdd032cda22298af1de17f1b6cef59a98066baed2e8e9ce50d09103e678c72ba26604227c43044001c394ae0cc56572092760eb40e3604fe6ad761be7828e8a69b0d4a4facc2a67d37cd0f6c69e817272d16b951b004cd59ea062b15351fd6301e6d4b805147a87e26fa9740ed2c87bbd7e6dd6425f1c24d7c3bf6cfd107b7b97b3eee089a8eba1cdf1016564953b54c1c87f4b69b01ad3f90c9cccb6cb5ecc52515136b558b3a46a10139795e32d4de2686db4ffed2687e34dc88b9417ef5ed0641114f47b9ba1c10233e5b6c36c8bf0d2526b7bc38a20498f22a09573407877ed5df5ee278d9a6603fb8af57b1488bac8c02f588e6f74de6c239999301726afff32ac39c28fe9f7847371fad268a23c757029848150d31c82588e63e607ed11d1d2bac6af33580a838ab13e8870aab601f00468f60e778871f2a590bc39352c91396cb7b36edf727147e7ae853ff071ce6bf69b32ba4d02615e696538ed5855b3da00205bff521beb62af3457828ca8f85ea941a3e921918f5aa21adcb38922c679ee4f76b4c073911eec74a35605bdbae2f209a01c5d05a432796e94409aac167dd2807f949cb6405d5260ecbade0f1fbb82017b471f29c853b4e1d3b87f06692a84c22ca45990d524e7e4f90964e69a99d6013b6c12228d30ef797713c91862bcde9ab2006abfeace1cdd18514e0689b27d315b0bd23678ddfe33d4d8beb3daa5687e2198097b25116bd501de13c7335b29918144f37b1c24ce96c7cb7def4a7a98fecd8c9fbe2f0f2f2409b796410780fdcefd5575b97ff080657baf9cd6e489fc2933640a74141297758ae59b66c9bf42fcf6e5fd464dd98bd3c55561b910cf6d6b49465cc144d4eda38a17023c69995fe49355f14b401b9fc9bfb0a5948490ef25e5c4a1f0c51d0797ed92f64b07fce72c62b66b65ee872c7d2277bc72b928f2fb7bc88cab2dc15e6d32237f355222f16ef5a1a65067c06a873e29322680d2ca161a74d58b4cbbfb4e4ff656fa51634f7c843ca9fa27d710ea7150efc4ab7f82ef27daf1cafc5896f8a74cc5b3b37c8afa63929b96a4215f64307f9b9f8ddafd29bac6d91e6a2a10ea029294dbf85d85062ba3c8cdd86425c635b1e4df667c9eea0e07e8d72483d6c4f299311acde1089309e9f1697eefd72ce106ce9ea0e916eca7cb358eebb4bd73a8bcb6f964e47b11562f8cfe502523b79b904fc27531e3b5803564fa9b8cb8824323a28f5677b9453721dd986f71c962569259eb440f907e7d47439febc60d4e45057df334d21fcde4970a5ffd45609b1082c679e902530734f317e3ac400f63c1f8d63ec8c016fb7e4a79f931dd1b06a511c8146e3969ed387d41d7b0287188e4c999d8aaeade9cc29c10a469bc1b619ca65b6df6d5a2d835b00c1e394180203970391f4fdfaf8665280fb7997efc0a92fde08cb8c04e0811b90ec2db9977e8ce5b748c6ac2a5c1ad7a145fce9624e7dcb9513564f8d4d419c37814f651bed46a406cae0cba1d8cb0a29e8ae6c624dca108513f22e743be5962004bbc01fa8d0196d072777b6292080c8ddd85533c654a91961efd0b4e5ef524fe861ea32d8a963d08c9ead3083f1d8146c61e0a537adb748ba522f3ebaa07a24ca5ab0a8ed865b0a81e0939ca934e8385a591f6fb52c96322ed4b12501d3677acda6c3183fd9dfc073da0ba9f8bd87cafd37458f531318353d462df41a845965a0ba0b1fecfb5f47002f83e579809c961e88748fb1dfe842df92e8aa05bf8d28f0a9d8fd71e380b113b9f173297e6306a52308a6cfe22320f410dec84fc5234cd5055efd1cf0aa22117d52cf1093b8723df1b5bbdc9f09b842ea4466747d983b397af887c43242942ef2ab5817951d047903f82ab02a0b507586bfb3e01253ec93c84a8327ad2a2ae6f1b47f15fa10c32c807c0eb6c4ffeb113a32dd9a12c359fbe760dd1a78a720fdf1aa8bdc30a9a8a3357d606b1128d54082738cf54dbe3efb9b33a3beea1dd7d06fe6d7f10c9b692586fc39ff16eda764b91a9d68bdcf570d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
