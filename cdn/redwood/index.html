<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3ff4a2b766c83c81c61bd5e5057260d486c03945afaf3c04220a8e12932ae36bced0bd51b989933695fa9976fec76843d1b02be88b4156238d4a739af0fb13131be5139b1d4af1172ac44450287f3b8a5a962325eda21b8d8067fe05e2ac6e15429e47ab9c80741b631035511badb016035d4442b192edeff1b7cc8cf46cf0cf7e36e203608ca27643d95ff9bb47ca0d7809fefb4b511ee07f75403d1f4e78f9e666c2bf3f56334c9f41a51ac89cae311081c155306c2d7bacaff94c0f99f119dc791e5731414ee0b1b9119a9818d53097a4044af1fddfa14b601f26977a36b78dfe521d3f1fea299bf75fd513bf15235bf4d5e99ee54c534dfde5b002510a66fd005a646c6f5990cbe4418044eb8c80e76b461f3d8ed9b5d6d4f2a8154d5fe932ab34012b0ddb45e6818bfdc1c01aa06cbb62c7dc75425b1373dcc25af7e58c522ff72252d76f33d3470171935eca641df3dab36fcc82f32a2030b951f61f50cec3595b737901f2ddfdf854e282393e0becfda34a48b66b0212a5affcc169c91b89ac290c3a69492dd692a8d496e5db3eed76713f59a025858fe492f80251263f6842b18d48225fbd512e5b764f90e038f26f266e0f2e552737b85bcd21da4c467d9eed00916339705ef5a0ed9797eba8eccaf90ba5fb474f4aaeebfaec01827fed297519372a79dcda9f7ab038b9fabc787ebc13736098db7053df8f0297985f8ab1429c22c6dc8647dd204765edea840278bfa7031105af50e26adffe85e53ac0da7221553b3d987da12dafdcb63047afc99e27503aa5370478b7a7906cdff116dccd79ceb734c81e432b48e9e284ad3a2c2090fb3f552dbbf56fbf7f7d640c6c76333d2056645de7719428a4868c40bf1dd76175d2ffbe4ede517a8337769b9b8b97e537fbf2047c1321a1eb746a4c11bd79dbf9ca06aa75a758a21476f2cb31cc0823f2803e9a55a71e39b3276e9cfd38301b02b4dd7cbb6ae1d01d7b1140a13a843582edfd84dc442a939bdb22b786b126be8e3b0bed18dd34a1a2fab7569b68d0f7a22d4e98e7e11efc57f73a1d9874ebbb4764740fcf679a3f53d644c65ec7b016900a496ad2e3233bc8d6b2f214faa2c79130ed8ed0a257e085d6318c733c4851185e5080b2450a8a134cb33bde9660a709b0db5f0877f4ea88f5b3bac5031c20e03506b3bba40bdccc0c27cb633f598a6126db7233db1098ae5763a6b0d796987f0c49481e90c768edb6484b16e884a05b73055a3dea0caa0e71dc0a47555fe0a9741e256d9c1f11cd93dcb9a259b85635a3b97689b7f8ee6c9168974097862d0b7cd4910d88c83db18fb169cb991f2eb126d192a7add3f0f4eeb0ad70b4868c6f918bf217ece683ea75184bf4c3c3c4fdd5c640e237f830b44008a8d95a3afcb0d2ff37cbc73143150d00602ef75a85985d739ada694227a9dbc273b2dbf1e56c138dbc0f708a5fbcc25841c896c0831847b3b62dd0c0f14068595179b067611fd9b351ecb513a1b6f8547f75941312de748c690d7d0ab1984a8a8cac2033e7607022bf69c34cbc1e0471be0be95ec95bc1c533452d4b8a234dc00df121e1f2592fdd7b0754e33e5a9667f4ccb155791c244a3f3086ab8d8eaa5b11d49762d3df4f23b3ee000936af083f11a27f73246f0e08b261e74edcbabc714e664e45f17321716dfdce04ceade898436ed1adbac3e7a9d8d1df0e53f2bd0bc08d22a17d67c021cca2777126e884ed796455010ee64d51e420c7f9e0b777be249b7f7a368becddb817179892becc1d9a8b1c59553ea80388c3db9ebd63cfe89be89388b1c8a783592a2d617ff2794da2daaf044e6c2932945e5e8842cb78a2c85cfda69574323a573715c10b5e894279149c4c9b48d1151f85efbbf66df999d59271f75f09ea4d13e2f54ffd577018db03095600062ff93196de9660763e224bdf36cb0f3d86eff3afe867488d4c58e51ded07ff98be9f46bfbd97fe27ed0a440a2f51c3e89e29eda5b44277dded592c2db2971ab8735752e94362463c999136737f4233ad4d450fc9b613b01207b09f6c4091c9a83fb23c757c1cc4d5ec297b2d02a5764bbda0634ca7356dbdd4c11234eec913e37a7e4ccc0b0cc1c954ec83c5d338d8e0305f6abe816b8349f8744dd89952ef3e94536ac7dfdc84ba3a85764d9d0287210c052c5e4ad8349b9470add64cdd58a88afc1b8336da2e6898b0970907045f840cf3f620d295e2163f5fe4b49c542204f1d7b1a0c1d0cbb5774500a2e7835aeb66c4eafabc3db0180cb805e42bea781b810d555a621732db7a79cba29e001467262f2ac3c8ceb76f5e4f498690cab7612be40ca73eb90b81aa49ef58abade04eb3180bb4b01f9f630246aa6ac0576ad1139bd8b407283b8d6af146e30f42bd57bf569b43aad20484f4463f11b76669fd12c331c390a7225e4756214cdf4a1e442522dad1b3dee76f473066e6b0e431875812c298f02b792eaf859937f7d06c833c70640c6e307f3f280bc0d0d8221d093b6e1d70db7138c9cb905563f0f43b291fd6d881cd3159421085dc996d07c1b96118ec4522703d1480535852a8449a1213baabaa2a7367a28d50a9809fb46aa4dbdf12aab5e75d504310607c79898d0ddaf5da3e9ba9b3381d22bccb0cb602a3303104cdc2eb4827bd77d85bdad567411112b43bdedda3124162ef0a63a6da82e1cd417ac75001fde7c5a5ecb801fd658f208deedc57ecf42d2b528f73cb491a66f342120601bbc1fbb534a5eff1ef0fdd5102d31bb6d6e019eb95bcfb6a73f6eb2b8f52bde549d2ceb89886947798eefb330dfba84dac22f0d72ce1f94c32074c87240509b509413ad2178a3495b3294fea64202f643f2103a2d47f4b11c02d2fa04c65e87b097610c69b775939e7603d570f16da96ba8b954382c26993d0aa25accc412c3fd906743501e2d957c8186149f5f438d19644b50fbd60ad1973ce64707212955fd03ceb59911f37295e7781f6d7172d4999728a812480bd83d8a59def40c6f2f0079313046c430240cb5749e65b267f08bc3272727ea2ec512490d642441ee80d01b429ca2ec43d476f4a896ec540c65f36640f9b6130fa2672f1956b2c0568927fa8118e7937d94e3565882f99460144e3f6ecf6ffae55c57740b8f5872c013c039064efeb430c34121efc6ece60f168030e6291137a610e2c89f853612f1b91b8d8649b8eb5eba95f6069d71076580cabbf49f667a1de723bfa5cc2184ed3e5c7611b4fcde00494c27f0e3a5938260885b76f4ef88695cffa062ad439a090d89f1529f4acdcef600d0f1b48c28e63cef701a898686109ce70df13b7bf2afb11d474a290e06788930f14a24636916dc72c9e7e23013337fe833d33f5f68f4ab055e634fc04c2c8cccf2c2d5c9388ada3f6c7035c01c745bc0ca656183b2abe825219a7c1dcf408ad317e795694e56c6aa1c37bdf72df1dc951a12d2d70c6df17da7dfbc5c39679278bf4437baa8b79bd7066cc74b3baecf8c7d4973d830e10b1bc06f7e2d05b6ca674f91f308c350e9cabdc4f8b07dbee3e492424d72193dd84fbc8531491aa8ccfb1fc9668d8d980a16089f5b9f372e749b90f539909c9a8054b28781c81f571e025852ca0d209f1aaee728b2032a020bacd396d994a530b8b28a49a7bb9854465a2b821bb6337f566cd61014488a6e80b137188af948b72ca1dd6e27fe79da333bde83ef2d4460ed715a6c5168a53a3f97ba7c498f8c2338d6b4df6028f8752a12ea736c64027c3b7d5951e3e3f9503c9c1c1b4b2542d39bec45dbf5a19ef498e53ec80ba328a65a526f3d8a21a568350d36315876d90534eaecec5630b70f02d136d31a4a315a22dfafddeee9799dbe2c9dc97353b7e488db60c1b582496d3f4a04af2e03445e97fb60c83a6edc6c1953cbf0911d7cc57701c696d6b1760d3aba3e4f8d493174413c2ede5864428994991f9c7e8c1ec566f4d4459c97df61f39a22f2c9a6d56c408c4e52e662f81a5058a0270783f5730099ea6311e893daab7c5a91112ffc4cd9e4aba8100807b837af0d953d516084485fc6a3fff899ba8eee0d2a7d6d3b3187765ea3fc8a9d5ab5bd5e7b4866b46a61cc6ea26f9df32259102c8f8378af2e96e537dfc3c7e0cdfb72ca3d718d67300fd3ab82d62fd57d76ba9424232f5888a95a224d0b2681dc6cc8e7e47a96e0a89d25d329128dee4d805b0d8c2ac5317111a5de5a84358a186313be0b6aa3c403cdd578a00463f5d9ca6e9e1421ecf2cc27487c4f24e74cfe3f4f6a5729a0df70d2a6ecd1f07936a1e8bb943ef83753ab427f9bb9db9a69f96d69618f5eb49106a7a89801da32514e665f84dbc48a424614a6aa90d844efbd86e49c3f49e33ac3e8d26b88e2424c058bc1909a0a2bac63cec95f041dacaf2810755d0740359c6699abcef49deb52899bc8619d3cf9f052b588dda15efab8b7cbb553ef0c5df4856d072f2797c7f5320955bb31f032fa546b393c53ee0a59ab7cc71f6a042f0de47fcb43f7f7d579382d297b8002b8542351a7f7e332c20c1044d338f7641a7b1dce8812fa3de6845c53e612e90beb47a425b573b2bd59457cee6813152fb0e822890aa413f6233041264af8067870a1a42150bcd7ed94887b7413cb34c80332431d0c16ce492681c02092c76ab9ee35b66bda71a5bbe33922e256128fcb204b93ea0dfc207ba8344e903500c028fd922d77f13d8845ef3011fe813d7d4d01f1908ebb04e45c7de89684d74b59dd1070dab405155cc534dcc4c59d9742d601cc357e4a00cffe716748d88be5678a45abc647ac1797e5a8178390a9dbc72df816eb394148d732e88fff2affa5f65c20a7db55b92a7a280c82d2ca94e2b3db2cf99ce7c91694378c913177d7db9668cfb2931c5eea23e5c96cdde5f64f4bfcaa589d966923a2c647873114234fedcb12e82617c863c487b6aba854c30e41afb8b20338eedf749c44febb9a134a2744ac8d9805c122a08fbd210d9a867bcd9612cdee5b1935f3a12159ab5c05125e2c64f6160bd650a36dfd7755fd5e3c6a5b63aa479d309f8572c7f33dc7eb1a50a8371b662043d44401f576adc7f8c7aa9b7bb1a6f96bef76bf13bb116a433bd464a9e1d03e5a04a6c149854799bee9a5217ca6ca036868c1d1ffdb34d261eede8e9ed0f0ac2e472f3c65acb006cd7633ab20c34eb51653340e022be003686352cc18d5c909de2241215cb26a80d0a8d9bbd046580986be5cb488bad3853115455fda9f5ea9ccc94a694c8f07ef725b0008c951abcfe167169b1a4c336bf44bebbe305cc60a66fe2db5b8c84f6c6831c2222a459629cc1c2a53e6a11ddd6f6874f8a361509e463f983646c6980ba2fccbeb304299edbdc957910aab9e132283a8b47c987e69717d27439fa48af4a53ca1ad74a846dd4dc4a25c2551e7a802d17b64487dda1ab2044cd2960120cb6802bed513c0e065c28e2d1f4e89ddef7c552f6c0c0e2b0e31b7547e112b1f40637059ff624ec02debcab530550633e4add17fe64311a4ed7d2b1ee03e0f46271039d341c44d4ddccf616b408332e20afc249ca31b1af484964d3aef66041e922e285275ce11be66bbb525f943129932f4ffdaa4fc1ea6d8205bf15a520a0d78d3ad66b62b0513e4e909d1bf2fd751409a2158e3beb4f4a130e06439bed86839717dab4a7752f7b77b3fd1d456521161519748d4540470379abe44b1647181d7431d3b695932ae1357d37c1e1b141d84a7df5df5ad7b45a407f3c8ed3d9c883f32b10f25d3b9a465bae349ff624ff869e28ba11e170e74028c10f34f45fda0f6ec1b72006161e90555a1164d1faf4a072f87e317879657c9056a239685ead811f24c717f3f9dbd83c649d3f8d4db505327f47b57ea8c486d031d4747674ac4c15c348aeecaf0be09e7a1ee3abaaf3b0b1add506733da0ff45b56b9ac3b7efc43c49f6f3d70795e633ec234a43294392d022430617d5108f873fed7caeca4d3366d4b840fcc9025d795135727eef2cf578f19f763a418ed1d911dc6cb7136e92d6bac340a4b3d57cea4103b0226a786aacea6e69d7284f52d01cda5c47fd77b0660251565fea9d93b471d9e8c16c61eab51b6324b8724405d1cc387dd506b437d92dc8c56412522c65e18b3dc09bb5f3abae65bc5a87ed8269727b7f17315641d728317d806d1adf96f9188d92e1ad38eb5e7fd0fcd829531eda0c555a20f16d19ebb9c14ee44c4d3cee7cde1afaad65cad1721de918f4a921b9450b62e829ec1f8fd9567a55846f33ed529a20cd7e4ef2295add1021ebf63602074049679d3802eda7654f49032dd6ae74644e2f3a67cf6708520b5f764c8227cf28ac08d28fb47eee9e7725f36fb476894e47b9c8aadf0d5ca799b1b21ce98eaa2f93cddc2db57481475ca9085370ed2ae006cd228ad6d851bd83cefc0401ef5999bec6854751e757dc0fcf242eb8aa809f99b1573381b529e71404a7560ccf3bf45288d0272c4b02ca517b5139bb4b5223c998399b5564a95538338de2b48dc43702d690d0743deb295d31ce8aa9a42590a09d9b385b731c6c9ddba44fa90ea75b29e75554d74d6b81e4534a88cf1656d8af7c6acdb12cb2d4d35861f55f5557dd82772639d29c2a57e37c9757558846391c2dd50eaf65da79c9094d1e118d68ce268e80244356729056ed659f987190e4c0935eeacea890c9822966da1706d42708836a3f6e5987bcad417d23b39255f66778ecd7493e87455e00cfb8788f2981a6eec3e824c76b8fb40ead7ff4f67d242a1c8f9e9c0b3cb02c06eae44dc529356508219c1af607cc9c6ff67d929a02daf4a965b2acdddd196f45f2e6b299db4556b198da7f7132d9f57abf9dd66b9a890712af45d14638cf4a26519c335bf6557ef68bae87eb63762e2f6f1472fd2e99c7d85380050daff62479ad7982092593af8dd3c17b86b55073895a221da2468a3b9c4bf22378d95364f41ea522ae05f2fb0e531885a3ee4d4cea971f78c1c2f579e58d20180996e8ce713ad82501b16ffb9b1e5e5e50aa359cd01cc293fb4035c5e3e24ccbdc9a255f744590fbfca31e09f32f6ec5ec1b69e0219e7af02b5f49592285bff44615a9c7d04cba25313db131b07acb9f0e74dec30870c25dbb130dac2ed6049e6fd24a7c60fc312b53107c904261760ff2850e077a2e70aaab0bf336bd8d590954cc1abb31d0a3d6a4fc5447aa3e97363c4524d6ffc3689de6fa050bba0fb7c639b9b1054f8a77537e0a85802ec137954c741a80299dfe49cbc22bdb02f3a65b2a6b712e3c06ad0989688b23654b96c988231b28173ae91ce4f8f6032e45034da3710750289d4d3ad29e7a6935bb63ac85cfa7bc7e43aa09c28f659889aa1271fa1c59679a6c84c47c60be79869aeb058ea1ef32f6b18e73c97a7163dc81dfe640d60f3f0c6b3208b8941b17786c08a4c8824002d5c8c74d7b88c17df2d6601c330bb783872ada74e736c7083aceca6dce81e266e31c43ebdee933b0f649ba84379b35a1a621ff6f69b09a6e0fbb38dd79541a960045bb35bb31c2ea259845ef8d36e58894ce0174a371763bf36f6bc3be0ace3c8524820faae92fc47930d71816490af0464f37f1be71a036342e1a206baea687e59bbcfd699748d841663c65d88e2f099403d3ad3d68137e561ef96ecffb67d72059b974658d87d3a54236e33d93105a76228abd7ae3cff3751bf873dff2ad5804debc32bc872eaa66b1ad1c29a2016d5224a0b0e34bd62af56096cddeb49f63d691ad92c5b7e01a72b27ffdd815b6e7a1def14a2ff73f2ae7d5c2e1292acd57c428863399889fd9528bb3935c4be73b1379aeb1d04c97190ac1832785ff98eda5acd731df6e5f441b52ae4702f55e39feaeded0bc952eacc3777c55c7615967d204c9a85d047d371af137250736df9f8dce0b247cade7096396072ed9c34fbc32d3ae23c96d755a4e008bbf0249484885bbf2041fbb8182e5a552249a8ad2d317b91c2f8891edfdb0df9b64beaf9cd4668c2335775ac95592c72e7faae0292f38e8b2a90a522a96d843784112670b0a063f6f7e24e164b29fdde503b78838478cfaa7a3fb525f5b0fe048482ddce83232d6f5c7174002619b785b7b5617d4d533dd12dbd93b7b0836d3e0417a2bc9eff69b90febb96af81f1951aae80f5bc1c65ec34738c21a7c4a4b5ec0d85e027f5194f0b83462adbcea8c9aa2e6c41e5cf13842e3d51c10b80964ca0f31974a9d1e3372d8e1c0e0e627becaef7ad75c441f624240fc62327ade6993101a24c77099719699a0e2780cf7a0c12c1901dabbe7d656eb846ab22fe671623083b9cf576fd5e37e9b2430c0657dcaec59a1b00423e5397605081988099c7196cca0f5768e04320c4d6ec5732d2ff6b1457c8eb51557eaa8eb783679b86272ce80ca8ec6d701c3c1126c4292a82a6aecf6de555bda36f1d87ea2cc9b5ea4c13d4808174812e8fd7557688bf612288667e1c4b455d0ed4b93f4b82bc6de4cfaba47e24e884a45f3567887708044e3b702550770c2e5abc717774954b7bb07bc4fc8d6ac92da2e93aa19cf685cffc132d0ce729c1179c459135af06727ced668db0e297609a5bc9c8cb732c1e1d6cf6055125880693e1d1e689359193c23953dda954893e6de2888e600356aad7aa57d404c707ecb7b6d029aa056573771fd5f189b0811a8bf52c4605b9a3abeba58b3a6447ba302f26be5082c91eb6fd164005542ebfd867b3bc01d698c7b97e6dcea5a4ca094cfd0b0065cf249644110935432e1aa33d036358f1ccbebdf1952e7c06c9a2a37663b4bec0303772fd46b7ce0b57b207f7eefdde2b43cc0f842899cdf3207b3aa0e31e0db973842745ba7470e6169aa60123271850e6ce058c67038a2b4ea6e25f86a3041959becfe51f909196d20384aff81a0caa80b82ae5178b2ad2a43eeb7cca4f4f6ec529c654b7efd08f923c0f3277584d360ca07620614800049692f2129d37e0e2ca2af2e05e55c0d98f960c70c3222a511d4a23f835b55cb47d36319e53782ae5b963f9b100375b2d374c6bf9da651fbc15bcbec843a61bc247a96a92dad42d1465482e6b2fe36bdb198987d3b9604822c718421cdf0ee466da67f068395f7568632e6369d8cc44f27ee6ce90145bddc621529363d8e1d83bdb1b51ac69faedca299f96a23b1f6ad0c58d7b70ab4901f8b668737f9727b9391d2aa2adbfb3416d98028a3d5e2c377dfbdd4eae185f1533b7004c47e29ea2b2e641d37bc3a6cf8a36c72f656ca017dc2fd75789462f15beae2d4ff15666d8af9c84cf393747eecd9c1c7632ca589b4ae71bfc73d2b3d66d4d8ff60a38fc981934c29b0d05c3018e5d77b53c90b64ac1f841f17bc899a83db01f2344dc4431c518bbf22bf54fd28b658fe2ab33aeb1063621099642399f2528c979297683beb628490a9ffa1a1bff9be62e88af5d96570b2bec9fc8410cfc3b8dfb802a2608b499b3243c451c31b90fa73e4ae6ce1d004f6e68e04583183b37a29362a0704fd8197760beb1d116fceb65f6c078a5c685ec5f17d7fffd2e238ff7d51763b7911bcb0f34e9f9bd0d63f0d4a0641232bae77fee3241b30f954a1ca15f37bf469b39e413a3284fd3e6a9e1a21d1ff2e407d189aa0e96030d63c863602fefbee6103a20923eadfd6c8c47396e231c04f76b02c66f7b1dce6c11bda43014a56ec74c21d84b559c8508c4070d4c2f69a3000d8aac02de2512a0c32cca4e8424b07191309064eff2225734d83a8f16a1046a3fedb8132cc440e310f4fed70e0c6ce78ef75fa499b2963418d9967387d9f768f82afe804106f1055f8035856acbffcc242f8a432e44ef91fa5a1cab345328f790b4fdf74c6922f508737808d2452c20420c0e99dc8c85ba79ed20bc152cad54d916bccbb8fc00f40a34fae43e290056f4ee310a1dae3f4bae686963ff94e15ae444694ad95562a9cff53e630363af6c89375ac9170fc0e7562d58e83e3ede31be0be7cb5d7aaa84aefd8e795bf2c8d6aa4f762852357046bc47c509ef63aff0f65da85d0706b1d8de4c4fc325029c2baa927367d0f634e054c498faa13cb7293fa0f7ced25ffb27583909a18b74fe14c66b479f173e0bfe12d23a561ac956f0133872a07ca49767351425e9c9ca0cde6f44a1b757ec7350ef1d973c30c10bcba15f8ed19eb15c1a19b399bdb803e9142a9216f1ce42515bf4b5e27ad61dcec2c79e70ae889550d31344b1aa1befb2cf4dde1e34884147da2d04b9acc7218a07c1ea3f6b5d68a8f32a4b5b6c9ebe7742dcf77682b335ab7f839227682c6ac5f81a485bf5486c68e0a8a54ed698292b18acc5c238d8ef4005c059aefc679ff8613c530e8815b506a1f7cf9d9817b636beb5c9b90e683c5c7daca2586af85b68e0199b0a5d969fe1d6f6442cae34abaa50394a1039302d47350ec558e0bdee772785c8e0db8bc33755a3dde5325a0d18aa57ba75c2353b317d1e57c7ceffa4825d5dd2851603cc9d9d78472323ff826736f1ee573627c40b7973937bf60352de402e285b4953ef8907d88006e71c1f85af28bcd7f06eea7c119a7f1e3e19d92aa96a208108b3c9442575db98a887630636d04c8ae8e1b5c18c377f7a6630977f514ce9795f9e0139d26f1be496a25aac9cdf8966ff6200d39a938322adf710c25c1e81e9498d62bf3ebf13d2a32c5521ffb4033316d04daf23c2b9ad29c28cb50a9fb92f0d07fcd307b4f9da1816a1a76047a92713ac01a1c8a21dffc041b818221ba339040b86f3a31e2189ba0ef19404645b5c1ae0e74cf01a595e083141a95e4b0c8cdce985357c0c9bbd645d32a76e183d48629aac0ed694a69c4038a22a1c6b498989d9d40fe6e526403a51e8307ba5012f2ee96aa3ecbd0b598e25c77c4672a98390a4007cbb5aefd99dd5f7a1e9aff5fc44add1097f51668cc45cbfadcd25d9709cbf0622fe5fd17582ac137e078a177890afa7fda9cefa9d8bf5c3785f7b732787d0d86a39fbbb38d9473d7e25f24b3a29adcc7c4525bb1b629cad3139a7ef0737a7aa590c03286522d02e9c77007edb4c5bb3be3e916d2b39b2be456f6ffc789051c9e5bfa87b35200c8e877042d8e1d3952fee9aa53098f40170763340d42680006e2d66acb1be346848485950aede58cabe2034e255401a70e7ed342e6648e7e036d233251aa81e54f8dbc8fbd298522d9cae93daa49fea74ae22885393ebb21160a3f8fa5d9532249b8b20a2ee323caa7f5ff27018724fdcf4f5e8b0a25f0a3dcd6cd33b85274205fc780b1862b6dada6218d47ffa8ed947cc9275a1b98df0677c95470d5e499fd8e7d3331beb79da32be86cb376d127d11586093afa2c00c8a0233629bba0cd978249597627fb7a52db26d36be1e35bc806b17d3abb42a9f5c9c699f12e51236c40925eba96ff881d829a69a74a7fe8e9ed9355f6e66ccd6eb518eb25ec236bde4388babfc6008610a4a9c2ac43f8196f3cda7a82a82aae7d3dd18e61e82f837455ae8abe0c9587d6b7ed36a12d6932c70b91a0bc7c48a7f2f1e999508805511fbb9bcd17ffbef747a59fc86e6cadd28da59af906640eff9e1a2b097a85c3172a808c9c1109315ff0084999f5ec9bb4815617ba9b4fe14331295c46aeb4fdd65765307958829727fc75d220032de709afab5faea51705c842b9fec00157965d7b601584aa45111cb0c749ca8d110d0f803f28aab8795fb42af777a264a3daf8f3d78f1a936fc53dc73c402af61ed483ad769fe3f170a2788daba2e803c5f218545f3595ce4aa88e980ace045a5af3e22ee17f15f0194e358f9e0a7e195b1ee7a95969175eca9779fc16374734deb56d6a6b3727629239e4fda4bc10e3e00725c77da4a0ff712f1dd215d6b5bb24be7a7a97069eddc1f05be1b6e36260401f04e45f54994d4e8175260d5d85f745bdf2cd3b58104071ec41d9ba490ef57330b49bdd9beca2a246c9e7051239bdf769d9281b8bcf9f4085b55a072f50a28b11534894c2b297c40b8420748549be366e5d483f68ce6a30c228091a9fc17a1fbb231e1d2ba6c17c024b520b2d5e48e0a56ff82ea5bc9b7e59631ef893b1d498c931ef3077f6acd8a8961ee2e45a6c57cbf1fde15825c4cba8ec9107b0f80a3b9d2a29430cdfa21b97f8c1db1f369962c0c4538e550efaba4cf59986017520e693e00671060fb1b5a2fd0464c9bcf781527fecff5036aefb137f5b8a08371d5f32fbdd3f87e9d6f950d1f3de43dc7f7b56f727c569854d6d3f35d6cb439b83a25396d1fa7c8ea0cea5b07c2df10cc3df11eaad0a535de9afa893e6a3afa0523402b0899f8dacf9a7db02c246117ac1958c3b44ebad7ced2a7904c6ca551fcbdcf8e2ce285ab4d65b996a516541a1d830d5931c0904061dfe93eb471887c33c46d82760af922b6dcf5b01127d1e3adab3463847b596ff773c0246466d0aee8e334a2d0dae94261a16dbc7303cfae4773c11a3bd4377635c94857e53c9cdaf206db28bcacc4a0bef42f5c8f43d921758782a41a25e6fa45ecd49a7d697bb23106d98e0d5a45687ce924fc2b72d50032829d4fe973e329dd46e0af6225999b2ac217c9e593b8e8baebb03d8aea6dffe68aae53e3117197a60ca1dc1d052cf2a81cbedb609574643619251fad948de037daaa6d1cc302a9d0d9212243e94b393f499635696acea987ba21480dc7af72ec881aa478eb0db41c8f3bbe690456595760fe24c268fbabf102704fb21c168307a52c75bd0d1cc87374bae3ad97607e33d1acf5042b6c49d4a2f43c72352df240f3e2c68754e1c79fae06255ea11d8724e5b3d0e42eb6f93f87918e223334a934175ea6fcae06fe9941acb131602257d21a4f82b5444bad38459e2ac1dfa292b8c965228f425400a24c8c7c36a84bc6e37de5980a6f2bbc332b2442f035ae7ab9314c6e6e97d36d79c7814dfed0e0391cd42ba25559f4105d682d8cb50e51a7103e00b3848bb91c33a386602ac4ef0c6e34116ef7cc1cf1da74843a505f1670ce2e9f0e408bc26e732094cd6d0b7de0ba42fc8f87a564aa6488fd3867e306e493405dcc19a315204504f93731673e4ec8eb8e2d2b7a36b3dc03f57b754d5ed92cfe15099e01305aa8a87bc0b4abc75b763ea54965404dca7cf27a52463b127f9617157be8d32b1da6c258a431cd144a2b996cc0f369013f2a5d4a0a51532e72146ce8dfdfe0153b83cabe0eb3f4bc8819c0cbd51c5239d15e1a982c18d0daf280686ecc5ff12505264bf19ea3561a6bc1f217031a7406ea2f77bfec7f13583523d5f8ab73b0f4a36595404b0645ff542950b9cfa849c5805c21f962c673cdc22f3df12580d0153927ba0909796def5fb38bffc3b842cfcb104122cb955f20aa09175a69e96cc1706476d047be457fbb148a6716b888b53a2990acf2f290e740cec058a21d4e4c82d0975db227f1398b171cd66bdfc820e44e99b2d602590e644fa1c8a0d8b8f41a12fbaa7bc3975b38176afa2020317e95cde0dc93e7a296b65e8c132ef1e7dec78056e510cc817c031221f1dcb9da2ff2d7cd0670c0c07267179e83b93b44ca6a0161b96865c3437ef8325dcf06ba12c2e28dbceaa0e20582d48839d66aa1ebcbc43e69036c125115c6f9470553f2588f41344ec48dce90dd692f91d6d158ac2ce2832bead49289b10b321b47d083b48a730a2fe9d2c61fc5de65ab0d79f5308de2899420388da6bf17d0a176127c0251b5cffe82e8cdc84289266b89b91d33f68216a4679a1d4e9c73d92dca1ffe7182d57e49d193991e0768a2be96885b34b58bfaf8c1662c415c032046b7f713540ed2795dbd44388d59f20b782680c214c5bca7cbc30ede278218fcc3f4e73e4831a86b4c320f9e5536e83b0b09dd303b90d5960d7a1a6dda5c4021eddac019f3668ae204ce055c44f9321adcc7e3774d3885701ca60996dfce1d2f48fefe96ec00321596892e133050fdb2bc76bde337c6e829ce5eedcd6ad9487c7665b84a6e56667aca385e992f572396cceb6746485fdfa45df8882c2132178db1beafe45203871df69ba6f5e9ec2f29bea1464c2d61f6c1e449eebe718f868f431041000d0a66f07d52b21d1d303dfdaff3478d74f9763ede594d00a6c22f5c279ff2f7537d606d23d2bc2160c70d3fc219d32a56ce89d6ea3411221c83b83591ed0d95927e6621db3c21a1b8b748bd6f9c98c44245c48f0ecba58ffe2291e40b1a9287d60adff819ac679033a590d552f294dbf666fb72c7b5a9eea5eb97a06258814a5860d971069fbb1519b73f3fd9c093d25b324f7ae220809c843920742c78596dc76b18f3746eb95bbe3e1e6dbe77e799d82dc83c267fbd34e5918da4f845e2123fdd3dbb4320456852b9a56113cd09bd80929ef54a7362945b724f65353969c60fc33909cf78cb7565113802746c7a22c55344dc8595232c84e0568da2a88465af0b999d2a64a586c5649bc18cca819997a9a6067d77bef80a023fab5dd808689c8df467e57c94a0b3cf7ff0678cf307acf23cbee840784dddc7d7d994ebe1a752ef75bab403b6f56b823f731856cdf5852447bb8ced6066c59a022ef57073f8cf066b2480c96dae12bc5f6a3a7cc01795760c99b9f14658123b64e15f46810b63119c60a15f549ebbd03fdce0451368e95fad375da21f96470ff218aa60d84cf86e8e3e9cbfd55130d8f7e450817a07a6630c57a5b688568f9c9f370da16c5e8b3fc56e1345a98a66debc4e0f6c3d7e438db88f00ca59ec2a844a4e75a691f246044a7b085c443739f3c364cbd022b9cff3d5793c2dcea6092618ecb17f56a1ec5c8f1ce35ac89984422f5ba2863ee0df62e9d099a9c52deb8fc6bff49c9fefef89e5c16b024fe78c1724e22377cc71d5bfad7beb20fe5b011131faee73bce52812947123a87625d9f488cd85d9e343da2b299c53ba9fbba90c912b24159668e4e868fdc7b6d5efb393e1f6c50040481b5ed2b0cd5ea561c1bc4068e1982f66a82106eda7f21703ebc1eb721aabab2d51f062ebe64d8be37f1ac55b2fb36918cf73480a817cc92a3217e284431369bc19051050c50eef613d21cc35b62ca0f56592bde95e68e00beac3b4c2cbeacfe80775911194b570221319c1677997607672670adbea7dfa77afabece1080be621ae26570da996c5e568d054de3341aec43897b3fe01d30eaea347f2b8bccaf74606c4c6fab308dd8b322c5f5167135f669c55496a6dc3c1cebbefe3331e2bff9504dcdddee4d458cdc400dd46d1467faeab7b69497255a965b9c18787c5e3c185d3e570084b27a6a0f4933427d4ba9d367f9264761ebfecf04fb51bbaea4c26d96706f127413ec0425f41a7b8b8b89c232107cf73fc6617f80561ba0e8a53ea93788b14810244fbd01179a0ec3331c1ca77568cb39b465fde0f27389cb954a8f6a62fbbfc4e5450096f5aa619f3f4a0e0c25cc67235c3b57e2bd1ed0e282deccddc34cf17d775213ef115e672f2ab6634474137221bb0d6367cd9fcb25fadc26652c44f9ce57ddb556f4ccfad5d0d8ed952e40e6a6ac89b22667b180a24424938d0b5d78e111df0a345b60876db4871ee0cd7e2586235a26a510b9ae234b6a981de24ec34f964388f67a4cbc4378dbd284a1b60cf3571c6c8554fd21a41a9266e57a44c55b96f15e046711a62bd18c6851f3868f74a40c1c5e5efd98b311f8ed9ab2e43fbcad35e048e3397543bdb332bf914e72e4d59fac1d8c3963fb240200a23021b068ebbd48d5905bc67a796cae743b1c834f07755c010f467770f2add4ebdbc4f1f4ecf00a510974259297f1a7e6fdc700e43e550202242cf0195ed34bebecc3c6987a076f1b5ad07535202004480abfc25a2a6b7deef790c6202aef109222c6f3924531048ac52ae9b7f89357915c5cee068be76a4c3c3e964a6b8f673451485d26b79ca0e351a7490fac88115bb1af4c98169290cd6228c0d53d00c3498c5aa55cd25174f033f496090930c0633dd73d7706977f684f94e5f475a83190f7251d4b238d990ea6ff0ed897245813f58c0b4420bd97a6e249c42ea52d273afca2ad75cb43dba74cabe27900210b2265106703bf2aa9a3e416c7d5e0bbd3c509367546e991caabd9949962971f35ff3d925913ece393c6348d07062da5354c0f0b28dd2370e90fda755f13db623bbcd9eb5cd8921c6c05044e04d225e6addcda28cee470ddd45ebac9e7495a40365cca2b89ad803b7f59305579c5664c1d3c8853ec833c993c3569ca388b1793d9d69568e4f60c92d918874946bae916c5e9586b7f442e3357aaf5abd0f1e9a2ff3f3a1c13cc2db5a6efcf4a46dca1d5689e136f4ea9d523297c77f3cdefd3e374a3c34d45641d9f27089af5c7b4fdd9dedd75aaf2c52ba886da81199f0c4105c7b23316d4802ee3629726873b6399986e2ee196a7279e1f5d2a8f755bc282d8898511bdb42666506838649daaa25076b0da3b5b60d2c01ded66f5f7c50559f9e28b2b3ffb14ae3f2804c94d1386a0eee629dc8cb2cb197521938292c503f9fdbdafca547bfb34c36f0aabc4c21f4b9398123355181c51cd248a996a15ce5511694bf4654e0089b975ab544bc00af47d7b591c0598f01f76ce4ee632edc4de51923cb657369e96c12c9616bdea2d20d6255446e323816136d4b7e6bfa379b18b90aeed6b80268a47b2f337195dad31d14bf1aac8a3230dabb37d9719a11fedb44e377e61dc2bff6acd22e42b79157ce270ebfe02b666f23fcd0916f34c5d705b205dcd9d893b44e0ece01800ccf2ebff6695af3b4e232b02441fbcff7e15889dcf2ae2cb0c5cb5507db91b53f64061748d49d3632d1f36e0704af38d1e527b7c72c6ff694bbe8dc1cbdfe77d65088cdc361a709bf5d4bd89d517f1383fed0e49eebbf1b171e84f988d40c6a891f51d6cb29d9ff7d47b5a6df6884abd7281139b656a9cae5d2ffdd57be5b3e827954e8b452a3c82fe0f51ad659512f40e8881084cb3b478a512b15115f22ac074db26a1c2a66a0daeb66f79eb9f3bcfd795379b156d7c84472f82dd5308b55e93b1e5145a3bfe83909a18446a3cb956ef9d084c16a64a203c7f29dce457dfb75e941ca700d190507db9eb879e0fadb44f2b5bffff056c444864624562aa70944631948ff466592b6abac9b900e74fde7557699e11d52b0e1473c09c34b379236c1abec8eb930b1a2bd070034f4cb567a62274d5d25578f0cf0f00ad6a7b2fdd318f76b57445fb1818d5b808c36e1a3153a8b92324ae653ed223a5045aeaee3ce52c94d3d8c56246072864c240eb93555a6bfa5bd24a0d69349d4960409b6df02d25e70e373d47311e6dbcfe3e1d86f6b2fcfda250f2b3f1df32f14f4b1625da31241cd6732fac6bad08459e1142e4a2e9eec7139ac1a6e19ad653fc9436b7476cc7c809e69095dade6761ea39e60fb42d3363c86c2319818502e66030036ad342b0702cd55a41056bee36df79130ac7083d09337145cba79d37797683aea7dba858e695bea04d0f26ea22d95f9be1b8799f7f9ab105a12321b2f60b7ac212e71b110fdeea8dded3a2da125eeeec28bc1234fa55ea3690bdcfc1579c7ab0f412361b2dabf4c8f7a51774523836d5fff0020c432946bd6e7af3315f3c22a528c68566d0de7e0a2b4f0412e8654d83e1db121c8578c18162f731bf362aa69d20865e188cdfa8403a085dc29b061de834b3a01277dc1ee579ffc79b9b3df5c018e653ecb87928e9357c6d60171ec222b80a0be22b6dc3a640d8dd300d083e38793caa54a4aeef83a2656c063c278579f7216d2a3a3b7f6de29001964152f723ad1a4eb4272a9075b95277b3932ee15b5357f7bdff377c3bea9842374ba399c47dc971daaecb7ed8790c3581da4cf7ed584b48cb52027c5bc48d05bc0e9e753481bea7393ecd926adc0b474868373c600951559aab6e87b9be8083da5194f553040dbd6fb6cdac3b4530ccb35d6075874c0e7dddb18d0bcf6ea7f3aa0e2da89aedc44b1ecd5d419528d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
