<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8259be4a4868e564ef281b334bf2c9b6ab0e4ddb855232b4a157340ec67d874e414e96e89536e067200d239fbc0dce04ce75f41e9d978680511c8c8fb3a6302b65aa3bd902770d0f5f6aa26042cb679318edda5303d5e793e54b175587c6a2db367aba2c6119fc5d88eb14f54e0e900693d885dae891ca30e37165e01b3b495261c26972c0a348e56a2160cdd1e8089c39e885e418eb0372dfc66f3d76219113e9e10a04365c079ae2f1d8b72d0b6a65d503b918d9f9081499fe1f7489bf9ce0aec6ede62d9176f4165c9cbf16c6506e2d48f97917212578c1057b464e54bd045a7ec3138e1db8fbee2cc0bc3239c73f4531e78886356a62ab5ae259f01edec4a8217a118f095189f7806b341e766f1c57b7ecfd0a043830fcb44edd7bee7df3ce4736164cb8622cbfe4298f5d26d3b5c8ac9661e97e0632a54ce964476764e145c9ad5ec7840273ae9ad1ae15b1058fff08853b89b52c9233c106bca51a33c7e497fc33bffcd09319d80f98308277878fda64651dd078b4b58f16c1565183b97cea05e85433fb666083675a08a8c60ce1a5912365571600429126c2b61f4c82351b1bfe3692d967b6ea195abdd028ac828486ada6d46c28d3c2646a54478cd3a8764ec9d76ad59b23e178462889de946b6799f9c39ec7d91b170c2993f7f172a81c4c8e1b9a523781307778c4ca3bf336a7e7c5061ff1a83d7a1899af44c46fe4d79fd86fa6fd482e4bd4571ebc3a3440e239f4367a1d2ba1d87346a8fc6a2a17a9efa3a951014893c9cbfcf1718963d89f3b9d9a9247f87724207a8ff0c518fb0e0d9e485d025d41d9892a28e739a7c96ad8209c36aff9bd1cea2d17987c1b29e231067b6f1b3812c57fa37135750554fdd13d4d8bd697918cf052202e429282e8695d22982b5182f134198b1eea45181d38e527a01cfb5a80426af9d2e53c9bf2cb6c2565b7f87e10e903a9546f7ab3858c157f8c2a879a4f45c0524e679f8728b354aff85d1341c6d5176eeaf63bcb5842a7e6260282f27a240f8ba45a1ba54e29067367f086f407ee78ac15bcd493b4e09ea9ae2ceab0851b69a2004c5cc56278f1ee87a24128cc0c1ea2741447bfe635a6b82f899e9b7916cc590ac31f8458f7523991b63512b59c189e98fd2781a2008f922a1cc45feb32b6079ee8e223e170ad8abc1e2da79b53425127e19f1b143b091206f36ed011795686ae95b7aa91a505416a45f3397ba7b2727cbd69a12b43d5db3d321c8f5e020419cc0afe53b8d9dc9e5c9b259ed8f66ac14eee989d97120fb1a63ce666867c115c9d88ef0f2ecd67dc8787918da03ebc93f4e6a651b6cb93dcf9b98852190fee9f439182bc48bd161f052f7c5fdbe2bd552dbf6159480eace345caa8b63277547594f290f917550f25c8e78795b6ef5dd74b590c1e4777abd26468867e36bc5ab65c92d71adcabf6aedaecfd83d1d4eedd6f5799a1cc00d436b431f52d6a75812ab27c772d5819982e9cfbd3f9ee6bbd4692c30dc5991cb28670116144ba3493015a60c00eea5098cb09b1e1a1190453fe22ab5a9ea1feb57c24ded169684156d942f731af99f599d0f0cb4cd4fb8fe68eb0b01e1555411b0c1d8ec9d453ae00d32ab9c8fe627c4308f70849a0b92c0d15467ee266958723239bad666d0719e5681858449c4a290731b452d08997c918468993b544c26b590f5225bf6e900ce458356b81aacc8f7633e904d1f407671e33ead11fef34d6caf179af97fcf5a4e081f5c02ed0fbf3a833150366fc20d58c457e6d997944d817d54f28ec14f6490a4435ac9b52e664c94beb904e053b14572760c27912c78fcedc1c7063eb594e56179652dbd0651442612a219ad8d15948fc7334bec8b66db744c785b751d345742e67c6640795f8f11768ad51d5c8370a6c3b57cd782fe399a84a19609dca011e6b6df1dec8b1571fb77dfc3bd7a1a6f2f23ada7d4c16464193f252635913709f00e3ed5738b4a82df296972429015f353bd96503773ddba38adf5745640466c2687ace24722b0921af2452aeac24e9f37c913f12dcc80fb13c01909d60b70bd11966fa4e1efb4d840895008985c59d5e973a05f4c4b2cb45782bd2a8f78f740152cc87781bbfe4a0e99e77beaa1abf1bd139675c391f86b6f727f8ecf16053e4389abfdf557b1f0d3334c749df70e4d5ec720f0b3039cecfd790fe98828bb44550ec3e4432d2700a616ed0f6bd3cb491b28f6b2dc22e918ad73566e9cbbcd1f995fa64d947dcf422bd68df13b82459528038b2d4b1afe702fc57d278d1ffe2494e083b8a21252bcf0c3ba38906cd7a82eb46843a04fb9de64d632d3fd0a72ae79a65b8d5a092c6a3ab585591cad408c8ecb40300c93ea9aae83a74207f9c21e208f45b879117b2f1da86374bcd0a2c7d0fc8e1aeb89fdb4aea020579a92cfe6cece929559a5cbedd0760ec5e5826aa074491101faa63408445aa28d966bb5fb873e9675b573b5a4972ee5205dfd2c66a70a848acf08b8efa35a5108a31a19d509ce093592c6117ee080ef037f6d7dbe79f77ed737e4b9bb4385fd0f7358d06fd8e7f794fe2b6be44481200cc30231b2372ee58e6fc45330436d58a53a5e1d35c427df69a874ba335a32e2b18ac941f5a30e28eefb124a76cfc903e1ff074e1840f79c6bcc4c393adb7a25d47a572a50f9de0cb9e3d6dd3271688e3c990d4644347c083e4b07317b9488a89e70493e0d6126ff19c33c549a483eac9e52c5058b19f750c11e9d95605624b69df30e955d14a52a4c0cf9e7467bbf449342dc166bac7958fe8ca0d8003a3e6533cee60f8bf9f6a195f18920cc94a92220deec9317c2de5e2edff0112fa651cea179a27dc52a607663e17a31807a9866c6a3b9e02a51ae5184fa4ff1c4ed2982902d6dfb4eb70b031e27999f5da04fbadb017314c9b55b17c6065bdfecba832541b4c383b44803c2c50130b64c268da4c8f669183c34414f32c58f26e5eb14987d3d4f80a1a1ff198f1a05b8701e65ed9ca8d29bdfb14a9f5ed194c7e0f42b12cd0854962309b514f21e482a5b33e702a79cdf9427d3f9a65d73b1ee3d361515c88ba8456f33d4ac41940a2b3381257e6c84021da5b5289fa51e7a1691db3a3cdd38b7157b4781cccb64a31a58346501add6f69daf5a8dd5e79fa33950c934486941f88314daa02dc63b64ca6222c58e8b2118d22641f572e0adcbe3460f276655ac6470a806bebca68ffff5d6148b70455b0f80021c7c166b617d1df88dbc9efeded733cc82eeef309ff63065cb2c7788d46bd45bee880c5876e27967a05f71433991530e139b22b836cf305d5e1c64eff6bd9b77c3aa092984ec519acef66d08ff9d54acb9ddd11ea21a114267b23275d6b2cd01bd09f5a7c2bbebaebce36765229c145082d18332bd3b92e736efbc4670b0bc64633d2115b666f723595caa36cecc1a937c171497cfece0bdf8aca7569fb5ba99f51157db4077cb13394aaced84486c2bc8602e4787212af0874c4b80041c3a7b403f05fb0c9f3daa743c3e1b3a1e2f760bd8115bfc079dc88e7a2b1196e7f164760da06c0afbf75a0adfea4c5a17d94a2796859ce93be2953abb063b79d91141f91dc113e2bc5f00afc76ccbf3143e74f6a7cb81a16a1db3597d4984d2e7942d89a4a1f7ab55fd3d0591d61f4985f0a389ff8555c9e2e78bb56a144d8bab24c793e8067ff94a37bee6024b0830c8d75cf33a993fd35738ea54a1b875bcdec86e50b19b87971877316a5fbcbe7166d7744387711b9700f4d58e01c36650e324fc154bb912eebabcb74ddacfb47e0e143681b8b25b36fc071250d458adde2869cd99e3c58de1553914137ce7156583639f8748a8bdad93db86a95130c4db4f659e7420d814fdf5b67bac4520a1e6b6e54abe0bba45e051518de5962ed7ab6255f171645c84121d34d10574c010de21c498a519b1e177252c9612a2b7b0570ba2cf241b9fb11135e5faf2a836dd7d79cfc9ad0534cc76b050f8ccafea254c4f28d6c824407d3a28294ba0af0614475902d3a2d5275f628659e86351d866e7b4f651b42175b243d031f46ef802f93b168de77fd135a740818d960326cdb684574d7ffca9ca25973f874e0a2e88db2681edabba2c98a4c873c847cf751ce6182bfc72e03358b01059f89e39ef7c526b3e2e49ce1aaa292655d8ba280ca991aa7409dfee8691b40e9cbbf1054a6407c9b71d5b95ef71751aeb6db57a7fa7019180b5f312b8036c660fb0cf245de4c280511df1dfd7172a54238954b63fe9961216bdb39bc14903d6ea631e7b8cf1f83cbef7940966cc6a24e889337f68178b506523fe83b57605b24c780b89bc4566a53a19452de5a28291aff4d2d932db2d2d5c8a61ace4e43256e7713c3d41e4e1295ea470c5aef3dca126f3bb1aec2543939e79feb4977342c4bba4f016000c294362f3d67a1849f5eb1b40f367d43e6c40c8fdf80ac4019451267c62c3df20e157d89fcab9de19e672f6e8a7f5eab00fc92385096cfb2129f45e4a8d8c1b524e1d0a15909013060acc833c7ee8cdd9508542dfa2a0a7cf3baaceb1edaf0869154b8ce84363bae26d566c2fbdec3bb14227f4eded04f471e5bdc376dd9acb8b8ec9fb18ee5f9e5cbb86f0dbd4ac0e6c945c26935e71e9a594c839c4c63afb1dc322cf664ab1afcc74ca43790e3f0d241bb7ed3b514642cee411da94c2de5b4d60836425c4964abb85664e5789d935d22cfa856adc501b4fbf63fb3c7106e17e251788c9ba40fef4c1eb14d7160ab5f590aa30707d296f7586007b7959e98dc77f1cfdd6108c95ab339a6f334d5d8a60d6a3462b92f8aee2d0cb18ac75fe80c2ea7b1ca545d29dca937d11574c58b21f2f3fa8552010f615269f2d7c6830fa30e423568b4e69566b37cc016f19bd3c8bf8e68b8539bde75fd30df4c80035c72a4d145bb2f93d850cc70999d306f6d9baf86fabbe0cd617851466ff71cfd3a8d6199376b721a164883cf809c2192a79f14f079e0db8f67478208579599db5f815c69b437a3e06d54ed438094c03225e631554cb3c5f4089778bae15a389c8e13addd00fc01d8cce0ba1efde75779d65ba837f7e8364c96ae83f401da05bad99e1dbb2d94d48bfc1b3f0ae38cdd2f49ee06faf0728e1491cb836e142658508e51f7b64c3deebad3894b64ce33204905738ab539f448f82beb62da4d40f71c80e94f0558f84bd6d8192759eb177a3949e39bb89e7087ccbd16435bc9c17e64ef9be49d60dd252f3fd0ee5f8d3581cf1c692897e79918a5b4e6241f2032d930d2a58fccdcce54dd427bcf913b5c0d30f13017e49e2c02ee116e729d54b7525e442382d4f7bc29dafd4d6814856b4b1d2eec6c9cf636bba35b6a97f47bdd6fbc644115b8592b734efec52120a611ebdff6b9ae61b0ac725c1343e5a1316544fa954b2ec81a9291fa499f0dd8a8eb35794cdc5923bbef0197d1e05728d0f1f77d9441e4a07aaa0d5d4e39479efa6fd04a8c7f79dba8435b85719f0fc8b6535cb40dc0fb6a6d79f1ca895fad4e75e76073829384364865449775a608bbfd2869440882bc9fbdbea65d0b027615d2dbf2283d0fd3518aeb78d075bfc85ba6d5b561480e75ec2e13851c48e4984e68666c51d7b72e447d6be5be73407ad3e4deafc22f514a12de3b40020fc0cea42f28d5df0d3df37153918631d8aeb4aa28124050fe9368a961921e3ce0810597a267887f85bd7cbe3ecda3c7446b9edc22d0e20379aab9ad39a8ef45e34b7e1a2f8c2a8834f0422976c6a1a983db3417a5336f3ae251809085b1368e5739c50ed83d077483f64aa8049d230b7f4411b3a3fa39335902a1739c0c51397b69510d75af6a3488a927352c001d92d02aed933587b6c11e30817ec0bf300f5b7655a734dcb7c863d8b9a1e01b848a5eb50267bef2ec381decca7a3673045722017b6acbc203c1e20581adcf19376572baefeeb01996064d3a75faf400a6c49d5006456992a0afdf027f217d2cf5f68b145b0ca7df15233a942ad3e04a2fbe1df68f0b2dfe66dfbf21f18eca1aee2e37aa6b8a6974e997a1ac7f2d478a2b8f78e24f8f8987cafa2a775d4bedf43fc86b204ff328d1e358e7a9a6a7ee7cbf32b983a9ceb8bfdcfa22c6bdf1132e7a892fc5aeea110c9322186d16c05753631fc18d563c3ee5702fa83d5aaec6ce2afafe3e5d2e7ddc51cb47ef6e38614c576c5289863de6d701d884b3b3ddc8c2944a0de9184b1dc8bb3d64ef759635f45723e027238d9f7227af679e1b05f9e6efb929da97870747a22f1da5883a7714cc648fa6de76cde384bc5389e4fbc5696fb7e375cf0bdfdae0e73d6bc2aa8d61bda630c0173082615d591ddbbd04b506d8c52247f8b8cbea744c84b5050fa925f00d3d909df58de8bbc1598289cae82e60f3cbe96685804572753918acb086fd86be6bb09f166d523f813e693a441ebdf29e7a851e99dc1dcd1b8c93549229fba1e2e05362957cc21f66d7750766f748b7341f2866667ea643b1b91cea57aa3bdd33e581e61c7748844c587524ad8568c936d7447dcb5a1c9043e5567c3a580a9a4c69839baa37bfb8bf49d90dd712ea252ed4a652c13250385a1ca4bf7057e0f0961f3bfc4838f37b2232a52e0333756381cc62453a5a1a1b0409fbfde10257e465dcdeaff50a1d39f8562c300838ac99fa7e7d93657d7b89aaa75fd8afd14b23e558576e8a17cb4d90db3b5f730895ca5bc0b776c9aa9aad74f86c09091de9cee563848de28094c658e93ea2dd1986e86c4b37a698519627d84a551b52fc8f8cc0a8ae7af51bef669382ee7da791ff3082feb21725c5019c6cc2f1800a8a2973051084e19cc19c2c813c50a066a577350cfbfa001b6a16e7bd8d154c79bd99aa09b54f623868ee6a4b11e7335284ce56d212c5ff766a24b4361c285918c3cb17422926e559bb6959d359b1d5507f773fec81e3f710ac12a15e7a400c586313495c1ef33f1f0c2e52a0e3b15f696fd8cd2ac614a741b64b3f9568182c28bdf327151d497fda03997ef552fc01cb596e87c8608952143e845e96ce9b42731dc9fca907c3916bb77edd526fe2ca6d340f38ef0459678690c4292e271be1574cc8c81fef618101e29da679af10626f2b38e01009ca9c3c2c6ad97db3e807ce38dede5eff08344f78971ce6b1bffb5300eef6bef79993971948b3f410d8b58fbe390f24f2ecb80759fa954fbb0759ed73f7d28267505fe606c53d4c61eacead2834291d24ba171efc1bdad5b22185905a5a4a52259cf28631ac21a7da03a6adcc276b84ccc3827212b2f19d174b1869382414e0f3bfa7bd56079a8c7f74bd69f16a55add6b6ab50c4fe3889b31e63e6d13c80b7228adba4fdfbe3481fc2c275af048d4da38e6ee72067721e48791faa0bdacb7d28418ea9acc47a1449db28b415d038842285539aaac50afa951b76d7d70787ed2f6392def6ce9186b0a658036773270b1f49f1bab89bd2ddca509fd8132c45be2175a22b9f08a688b921d788701347ff51ce35a47d29d4edeb90c6561e0b65d4c387f24187290bc033f62601291b8de06168d44b6688235520564c6e464dec3708ee6ab721998f13886c015e92c7d91671f276cb83fdffbdda6e9994dd9cfb8266d6a2e3105a96470efdd96154902cf064a5ae63d57a7d1c247c90f893659b375e603826b1476905af08b647f9f2e7c228b587312080e17d2ccd1a40437ae5eae846576b40891e3889e9cea7176928e5326977fb69c3cad4570486366f98ecc080bf1f2f861553dafc87a65df5236d6cce2985792ea92b24f20ff33ff610158ce58651441399edd9d86e482789c0bfbd58774431d314000e6e3caaa23ac3f8b1ac4152d7707dc0983117473fcdf23fe3652f5df3f1953e49f08ee07778113018054adc4e83e82b61656079bbd673405c07a4ae7944cb4390154fabfda44847e1e4207fa5c79c5f5839949195ba7cb247785e009a4081b1f1682da974a853591a0dfbe55bca8bf5327997279147b9400a19d67677b5bf639eef29c8e8df45a83526d86a152a6405a79fb3a90f348669ec417b0735f3eba3611e279f74e20f4f21c03183cda92b3144bf30af534e246be76b8291e154807d01a79b951837c7a7e2db2886f9007cfadedcc69e66f6efcb35dcb618314562018d4d6f511d801c9b05fa805e19f6ff158c622a07537cbedb96b3be3fafa45296f701e220c5334cff5c22dc341e7721d44f98a61f8c6fd7bec2b4fff7722d53c3f6aa243b44a1fc82e1e62cc94f0e17c4b4fa228fedb9aa279751d0d16db8bb44d2b060a2d2030927bf8ae733dae5090cb3d07820cd5720b3138092406e92a733b76ed7ffc378d18bb366344ee7ca3f59194f09a713688bedca85dc4b80e90709671a3c50c1f433a0de93f7976fbef3ab4526fb104923dbd2b44b3f5319ca97053d3ffd970687cfd38012b3d4b451ed373b78ae9116dec77fd6f0abc594995d8e13c699c081fcaf180617c467535dd2d2aef462ef4cb79657fe769866feb6a425c6ef12f5b555842aaf1dc21898b0b8973134b2d24609cecfe6a9d063aa9c8202dbaaded68ed5a080abd88f6f2083f769066165287af20d597c9a35e7131484327a14490041bb3885302abe5d1605aed4d522cd7e75eedd46fb1ec36366b8a807e379e1b25480aeb1a266e6ee1cde8056dc5070c2108654a9b7028372a8c64e0f74dcaeaab226c11ff0e311e849adb6c1d4f3191587e08a1329eeaf618c2895926db7890dc407361a36fc659fcd7a8a1e20c20cc338a921888e62a4530e8da012916b2d7f50dccfc5e3d5e8f6e776474b605294a7c584e3c8d9b308352b509c3170d43211067bbcb6fde0b9b9af21ce54c4572a441c7dd6795a6bc6c4c93a3c90639b6bc0c9666a4641b0c69ad33457d28a33a0e0b3f6525d1eb71eecfb7db08a9887c81b21d015da099fbc05c675d48b34c007654cfd270ddebef832f9367585f0b9fd5e6adb17a87c8e642d1240494c4b635c6195a4531c188da8872701fd0ff53cd730851a3bae056679690728f39e507c668cf355a2c40e149b5ee24b4e83c972d6521f8c14e41c79d88f40733e83eb862e0e63fc30c33178075d8711d62bde273901fafe1cb303358f82a9b2bc6958af1623ab0508e61bb6eb3bf7151eb598c665daf9f9c4c7fb73b4e772e0bb8842f5deffa89b106b51d94c83ed21e5ee9cd23f0379700845bd009b30534e5de107ebd6ef4177a03cc189d21ad5a47b4999638297898f37c6ef5af50efbf469d2652d7fb027242ac6a4e652f31c024712e8f26f24151163de91c111ca0850af39558869264212990d1485cdb5a8ce7f43a3d44428d863bc3d9cdf2b74309e171b366ecb16b14792a4aeff83c99224369ffe25abe7feeb26fb294eb867fff8b4338767365f412d484b476d9bc68bb9facdd83f460d7094c12836f82b9df361a14289466884abff1d0de0367c9b760077d2022cf6683bf5fc7fb88d04a13a237b432b064e9b67aa791290988fceac1275349ad2c40882f3b1e71b59cfdd7fa3297ba9ef318c99c3ba4b08bf6a19d67a310c4abb538b90f2097679198174677d83632bf18534c6ff82ce98c936844b1bbd256a2eff72838688ffca23f96a6864db7172aaee4c4bdc6d37ce5130d37bf5814d79fd9982b59a40794fa6377fa110d1db044762e79ef33c5a09b3498487275439ba398e45d46816f65f16941448b61427ea21f1c2dc9de4e12239cec96c0c2de2770361675dddbef48afc31ec0cca7a0a03500f53e2c5860b46addae6c5b5898c1973d1a0611f95ff85b9400608be1a67e738e839a52a242c1abf4f7a79413f794a27fe2b04d0a805ccebc3886ce10c64340c7c802de467282eb07a079cd0cac5f40ffe7528bd986e96c24b8f04649230032dce49001cc4a91cbc85fec63a7644e9ee481f68d24f9f9fd7389b50d2a88df109ca93c0d9be4aab839dbb5d674a337ffd95d0359f68f4e5313aee6ad13aeba3c239b62637d103aa4857cc6b1c989ca7ceb005be97bcdfec90b0d5cb26fc904a9713287afea3600fb69480c505e61c3bc024cf50a731f46cea5d70dd7789eadc08a1bbbd58a8e5d9a69280390f295548b5d77e7f608a2432df9b318d78955b102328f1aef0f3816650336c3c5c60f70d712d1f645b23285391493f6becc286a41e4fd217888e089c6cdb325415a55caa71147194dbc00c470726740e427958885a3ff1ac7ad1bf0fbd288c94b3c83930493aad5f15bd9095abf42decae906f9ff31e9d993dcac094fd7115dbae573a7da9b2566063d181ca4ce9eabefcfc1649e8a79749a8ad0e39d04914add29521b56cfff1c1870628795c46cc864d9016544f163996377dcbb1d16c6c2c291cf512218482242f7ef03996a1f981b70cb9971b5839da3df982dcc6b0cb3be9fad8315f61da28f5b50311c7b40154a70727059a41a2fd37fc2f8a0c22090e302b746d2f1a6a9ef4018d5c4297c9fe22160e503a0bb9305e96f3dcd0897b3572e29c140d9e3895846c80bb151c23eef86275a8184393b5d01906941096f4ba10e2cb9f7d466e68075b3cbe18d6cfa5b6d278b943896448cc2e723e10b3392058dcb696385fcf5b4aa95ceb0bbe7be9bfaf79ec4adf2bf6a11250410770587427be38465f4342e1b7963485b3e24636eeb59427963990baecfd03ef8455c8683093daab0a0820feb478a98758051ed27346454e667d6107b1cf81994edc540e879943a693457d93ea083ea3347de4a0900c247b71531cb882c29512133f767d0f071238fd200374f48e14544eb3e9cc21b677acca9ae8335cd802e109d1d17a78640c6ec7c3377073c52b1f95daecd5737ef2fff8e1810e5422837c63b228f36447d3504c617f5b37063d6432705adc662e252e1f64404a53d0491561a092bb415dc82817a5600e78fcb753dc191af9fb69ca80fc0277dffd35cc08f628ae93011b96b3359112340b45e837e5cc0cfdf35d768ac7ac0bea9cc1cf37b8ee822229f240b77b0e42fd2805dfe3cfbb8b17470c336ea75349a43bb31dea351cb4bbb2ab753ee2d28b38f3d5e35acc0cbb6b7115464c66e73bbc0fcd0fcb1237bb99ce97bfb213df85ac4db6866e3e9e1ee0e49e49a1698477f699e4c6c31ef90f710c521ed75761c49fe67c46bf607851bc34e3e2217148142a95e499ed79c143f11ceaa50a6632d1a257a72ad541a0842b2dd1b47ad2bd2e6e8fe2f913d271ff16f89e24f8ae68e15e9e4b489a8c63fc2349f574836183dd9523442d78b3dcc8bb96e842499422e54669f184588cfaf738d834a7f6510c913524e8664cf0f03b011c2cd61ba8b41f430416e24168dff1d9c44b17789cee890a9556ae7e6a2f5268917bdc0f1a92cea513659a81b791852117fd72f1b562cfd501c78bcee2edb5c21701d69b28a6d829cde99021f7dfe0261f7ee6772b5b4adc9dde4192b502b3ea71c867288642f7d87154e8f87d5ead5b2205d9e0b9ee05eff3f8cd7706f7f4ff93235d6c2a54a317e7ce79f3a798ff12906a8b52f330e8259c95638a7d88969e8dc48d9ff70c91a5fcc127206d851e8ae74dceed01b22bc1a0fc54ac5bd360f9f49f117260b1f57ba7cad51c419443ffba705ca3059eb153dfbb7a6ede129d5db92b7d8131eaef9b743b1b0dd38e35a267a3f8f9fc1436ae47bcb990acb47d5938647a08ea2d2e71a0a27776f7f639447ec4fe136734b2ed9f7d2dbf2b4ba03242b9007b85554a5c4156d0c3e3c46e3da4cc9e2823dfb1c5d9a59aa8d80acb578e072843fb9505d5006d2a0e5c70c7de857a3d8ca3cf896f524780ad712598a146583a6235c1ca6522969bb46df3e36a2d93801da5fe5a744f641d20192fbe10465523b343ca9de95406304a36532549d7fefbe5a310ed26765bc7e8c61ae9fbe10d31d005d20a0c4a63a27fb8122a4947f05f30ca2c8e995b11420eeb3e6522a04970fe0875a654569a8951e877e2391d7de5122a64562066e666f8c49d0946edd9f1a11f6bf5c2108323837356226219f61be126d7d367ac51dd0f620017d22ee9362e0c9e68bcb04680ac1353a3f9908efb4d0da3a5f89d8cffb0dbe102f0c6382e6eae02d89d88dae352ac7ef145b100c66b1756bbb7bde158d539525603521a80b19f3e1f054ac1eb31f5ffb1490e601aba01945cc747a002df5946160d8ed1631250ce1e1a912038c5f82e8f40de77d55fde8fe9920e0ce2d124b0a0a8da1f5047166d2b3cf5b53167b6ea66ff4222803d44fa589794521ee4ea6736f44eeed3c967c8b8da82623cbad472f298256e61be1a3c9a0ae802a7a4597abeaea6dcfda966e5874a4885e41f2adba062fb00aa0c5ebfdb96bb92977070896a87c527b2be50d10895a844ac27e6bd68a5e81dfb343437305e1e9877a9e5ff85e366362b081c5000dc2b86c4dff869392f96c4d5cec7c9fd41dfc87d9bbe2b9d09a96241d4ba8054f20e8b196da5b106f5260bc60b6cf85ea3ea51aef94113ad2e41f40f20effefce8aa432f12d5a13616a82f48b1cd2b4e6d6234839c929c8fc59ef9e1ca6b4a652e35a6333d5818b0ca8517fc566fadde6f9f0c6d13cec65746440d37e6994c020d7cbbbe0346debda724966cfb5c3b10d8c050c4192c87708f0be95546b24321d6d895ce8bd25796eb64f018220cc52f69eb83d5f2a50bb429dd746a215dbba740247d0ac0be53ac30aaf498da4e2d8cce88b99b544c437e5fcd63929c04c54f2f7c3a4f657229c3e86bbd294cc031d0b0fa8e28cc27cc626990a1f7fc90cc56e32a1a93232c55749e2ce53b60e0e2152fab50c635323a2cd2ddda18d8a25801776b1f1141c01a0682ac42646dcde54799de23be7ab715b6897dd96d66ba82fbe75334e5d3a0e0a8e19e1e01f2596582a3885cb68a9a4387a95d6077511381637e761a50b15bdb8efdc3aa3db13e3565a5c7e7559db4b2b49790a20b5c97263979bea04027cb2aafa465f74c461a9f9766c03188b09b8c27931a6554603f5e3ea1149713d6c068688b3854554275c6d09ca6705180e49b993374c52d0d2f3a2d16dd46edb6e2a639b3676363f820a25a7d3abb2d845a595e9d1987a6d67f5dc7e620afa75ba13440d337fd4ec335501eabf168d66b7b943d58550be21068a2b901b8c23ccded0cbcb644726dce7dc9606b31ea026d9413886aaff5875dd4f87d8407af4d52f2ed7ab2e79acb34d624637acd4c063a5766273079b9768c486c241d7b666448150ccb735da7ad1309944122947d287877c5b3ae3419f170d53bcbb004b08eea3bf90f1085ca52955aab150918a14948f70d1a5d84f5942bfcdd331ca46ecaa7738bf512700c07ae92344e339d796f5027b729103cd47be72cb91607b65c49b35cbc58a144221a8e67747691550e0bea1076c872e411b6a64ab7d93ff2c16c608b946187a3e4b98f61a00edd865b1e94f615bbf0060f7d21a211356e8fabd4e611b6508ea9dbb1b5ea669f46f84688571ae1b9285b026e22ab706ba657a5dea39ef10cd6e07b68ff51d302b9b965862f9c6720b2f3658650b067e2c5941d62e01f656dd5c230525c131af8551fb703e4a4f9ad1aa8681a564918b87873e53dd544d758f8960221f4543b170b5a32f283ce27b00684b33cc1a4dfa0b2c1b9da2f38117eb07c493188aa0b2f4895118c8951da6395ebb98a81537aedb3f1bd698676f0d3ed21257c0c9adc27f602ba41d70cf2f794b904ace8b151b20f59c67a9098550f657ecbe9a2b11d16002225f9fa154413d752d7ae6f633440543fe5861f017024af7dc39993c160e5c15b78fdc29a0576fa6f2e46c67f871bf81aa951743471cb5764301ba8f13d290c179be690caa11881f063e8b50ee228af1d9aa2121b44e6d4d96517ba2d8c0992ab4006aa8a53bac2ab97738fd1d2555856bf0255ea929b19b4041281df22c9edde58de1465f04be0ec93ea0e5d5213877f3c8a7a1c283517adfba0e8675a4a2729a6d8c17e069fbb43fbdecafb3f5ea7f13cdeb8203dd192d100e8af3dde97a131f9b1a51383d758966e624b6d8f2dc7b907c5949db637f0ed2e68b340b40822401a1e61388c0a2f54e61cee69f76d2f0ffc90cbc951e0f32fc2c7d481996ee5d0cfbddef7bfb7e5f416ba726b35f0e981a6717baa4253020f9d7ae0ab86abd9242aa7883beb9c1c4bf84194e75794f09d68f20e4f8ac944cee53bbd49097b39e06061a71666b984b5db3d0821b961a5566bb5d6f3f74c3ee28f40bcb5a513e577a15db16fa98ba299c3e566dfdd38064bac32fb2ab1c963ae8b8dd85da95d8008135a7e0dc8a68a922f2774aa8f9b2f950238a8a937dd927041945e18a68a93b9bfc7f0803f3ec6a36f6b9bd99bd7248850b0d348fdc31fbcefcc1bfe5ca5070acdd0e4447a612d84c0f2c640db4b813fdb5ddaa40163b0c35ca8f7afb5755e6ee7e8c44fa7bf213eb3c2370a42e7b32c96b795f242eea02c294fe52ec9e19431a5a4c3fdc1c286a2806386bf5ec6776700af18ec1d6ef42d3e18deb906643c5150d8e072b4d1b155fd9ae2994d12fedfce1b3dc64a34434f511a2c9dc52922457ca3a81dfb6117d1bf5e729f641a9c275679c44ec49125344db0b0ae582093011c7b8644275da3177b4775bed2bb8519e91eebdb54ed99807ce28a764c1ee3531727064be67323784c31f36ac14b512b0ac356c56f77c5e0c0f035e32b8ed01657e4d9c653b9a5ec4e90cdffd075b738dd0a0896b4e6d6ce84de4e878684539a0cd7a2bad7da5e5c2924349633270b19967589ac7ae417ddde5725f7e708fbc672b596c6a1df8d19cd90934e643395de42aa557c383a227b4cc9e149f79a91edd337943422c8a5fc66f07d6bf2322d21acef4c6ef7ecd50b61b67c5c17e5d500ee7afd556283ce45f448d670c384cd40a473976f6f8229ec0e277948502ca9c89edfe3bb5f0d166f2c13b4247933f68b24edabd5e08b62d44bc70f25fc1819498095059b35db85d499bb713b6c5d4d68f5c1adbf0dba19420c08ae9e42bf3dcb432ab395ad183b882d4f84ff57fd78d8d7490cea8988e6c4497e29d9f0241ba5a4e4ba770b62cba2f73bf2fe9db9d8f85a02dd77059ff1ff5daa3dfed1fe6c86611c939b28c2060690c9d74b1d39e26661271b819d7b1a7deee0be145a0d097ce054108b610c12101babc3688c577cba59ba49c6bbe4c1f2f007e508f97831d6926909981bc9a2e199ba6af58fefec72691e05554c4d932d063d47c8e1a0eb1f7cfa2796db569b6da086dbbcc28869e3ab203382bf5d089b4bc110bb597e9f76ac58883f7506635eeeca8fea0d54c205e9b3c36cd95741e81a8327650ed59b3c2922d673f11e037c815823d1381dd21eb32d7b4dda249c865256eeb14e3cf002c4685a38b8d0d931ca65332e71c5bdc98d54197d424b8731f7d46cd699e5e233aed72be7611aeacf0c7c38131c5f7122f274b1386094ce7e0bfbaf6b64a29e2d3983065f689351fa823d6c2e6833657b57af2b7c802abc361ca5b5d68c34b44edf2011a5c196149a505b5662b58c74ae23df3555ea0e59740e608c9244f6b6210a70549b16af12753cfcf6cb37fd14cb3d292c634ac55d00cbf7be8564d10ed45af3ed97117c23b1f14dd9dedad563816fcf3097752704adcb25cf138bdce62f97ba803fe9ef004c654c525f742e891816e693316bfd619a11f3699f36d26ce827156b1446586e91e95364946f646e3b63d8e56782653788c77a9f874123edc521dc5f476b84ad93cda37a57118615d4e7942cdc6c60e044339ce0c03c41a1e434dae868cd88de719f51eaacb6a38b617663bb780fb47acce2aee24ff51456ce5aa112484a2105a7be837dd32a3e1d9b8b714ec53cead821e404e9ba4c42631f5b1c9a25404fdd35c669210c8e565425261a364e104acdfb747041c39e3d8b12c48ce59912c40e69a757dfea17ac9c2bebcd0a0431602afcb6adca1fe7797ab9fb56a219f67c8d995a461a1ff30e8cee28ef794a5d354bb6d4b6cc00c7660818bb80201855ddb7327eb60bb8f0e25212e58fa20e807dbfece5b7323aa9b92d831d82b850f23b8cf070e66c5465862f797b3cf4a24571f287193490ac79eb3017085cab8d399f7c520677ce49e389fd9d195585ecf4895d85e16d5d7c44985eb800405a50b87e368b5dd00223fcd7836ccad7aaa3cd78f8fc4c4bb0c86df17bfb978a90d384a44ed5dd4502b279948548239203979fe2c9a262c5b2ba97b37dc41ca5ab2b6adbad7677feb087f824a127342f5073916615a2aec99ad88bed2f3b3d0899755180646b9903c490d649f05ab4e3302544cd9b5221d8162e64eec3176fc7c93ae671dac98b3169270524976157b0bdb34b690c48aa6b7d320348fdf39f395ea562c77c40c892fa0e0cd9e212b0d553c1de8d20a57feb6453d0d1c7ee9076ac1deb4ddbc6b027cb395f7d1547348325e214f76ab3c27deba5723cb6d5da6f122b6922941194cd808d7d46f3b222ef5faa45acf909de3e0423593dcdb004bf686e6a90af1ed5d807b6b676ba877cbb8cf0a1270a8e7cfb24c5857c10f2f83ef1fda2e2327abfb3a512820cc0ac9363c9f7cbd7ddb32f83c76330910186cd8e822e321494396265112d5ab4f1dce7d0c3b837b70eb536cddba993f553ff340fbdc8ed70e0374b5cbc1e48500bdbeaf31a1c8085c28afa317f6f9d8693d30041d3e82bf0e41b615c236df69b32372b9b76c66996dae344b0933f6255c3f3c73fad7a6b46bfadf31e86985367d8caecebc4b98f93497c6a97e9ff6bcdc98e830ffa10b664f49cb029d04a3d09df3bb5b8193155d84eca506e818af468f9a28a21b08c6ed61265e94dd427249edb0cbada2f3599d4276103c89f71f616832963f47366d7e20b987b886734532a24407b89e9bb158576dbb4644cf8f78386405616300092b5b634b5f86cbcede62e0d3a75ccf55f91036e46656b4679bc86659f739c134271b09828af4c413de96705986771f25544e324b577998be5c31ba0f60b13dd0ca1a363d4ef8b1db0dd5dbd1c5a6e740b0da4d3fcafd3e1174ebf82e8924a8f2c16310c21c505e59f7e4c69f5083f3149af5e3c63b39331eb68ad125173293c0324ddc62084a69014da1ba34e80f0f53a36ed0a56cfbb50dcb6052695cf61c25e9d69a308a8f461a997a733d84c53951bfaffcf7245f2320c868c02926742f2cb64f703ce86ccd217e1aa79775369edfaa67158ed1e11fbef9266ffd65440696adb26815174b20f9ade0dcd8dd15a66db768c9b272cf907ea7665e76fb08e495630fe80548917f098396ae1b0e05acc6d4cb9fa3ab6b8e96a1c5c5ac78a6008a15714986080b2a70f322dc200ce0776ba01ab24e59c3362dad0344e402a499e63ad7192635fc6689073cfee817fab3e41a896ef286c4f5fd29e57518dfbe2b1f6ffe61bd50e41851f7f670eb1229281f65a46cc34ed6c08b3344ecdcfa63649cf146eb804b47b468e6f347996cf036f5d0eb4abedcd9e2d356317a9df903e2cbf03570358e6dc89fdfc919029e539e1abb4afd52f7fd0d6cfb079a94294ef97076b2228816e048a79d09e6baf43663efadf6ae9a1de0d084f4675c8d79220b49326eaefe696dbe9832166a7039b078456024fa27f61db8345396258acc36ea68695133b56e7a70faaa32115d02adac378a99eed0c37f60a6478dcdef6a7fd80d4df95aeba149962df790a9341f0605ac91983174e157ba026f4033aaa08b792d8f1d4ca1e54cdaf2469ef8de6fe3fadfeeaefdc894c691d75104e772caf5496f0e294fd20c133f1f880bed69e681a734c168af81d0d77670d546cb4f73bdf0aedcd3c30c9fea2cd7c4009a165b63e5f43e071c0dc1925280e71e9a355133f3f268fd9d4058eb1c890e22eddbd045088511a6abcf6aba825b4e3acfba2c767b323f14344bda96502aacc06941ca09fbfbda085bb31fedce0bd15fa483f93a2cfae06473d71b9e03185a6ce559bde77c86d62e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
