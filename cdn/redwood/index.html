<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf1303a467851a7cad6e49af427d2d36f2793214e339072ff36cdde34f20fcc92b839aaa5439b9b0042891d96c8c03324e6915cfcd5f84db6467491fb90be72baaf14ca33a1b527d42b2aef626c114c18c333150c5917192b0fa2297d81d2390bddc323fad5181e4dc1d6614df84b479c81d660c7ca50cd1d75829a6dce7e8b3a19a0fc4b6f30fb8bfc47b38ff80c4c48d862ff109ea39f15649fe60ee0fc659416bbb30b133aa82e8558a0e4de15e2d5966abbe12ef5fd626476e3aa4c67f3dd6124a344209fc099deaea47f781137c920577e9d451ac9bf3171bb96e69a6900b8b32c3ca8ed856648082daf39376963164732802577c0ceb43292cb73a41d33f64e146dbb3bd43ae12a3112b9d5a8411da436f0059005bc31ffdda9201fc7bdbe1369fee53073aa2fc3ee6f6cbe4bf3717db481f600600f850953912645d44efaed9fc362bbf45dfea6db3d150dd24325c184237263066a3e6570fe0b08fe7bd1ac1957b7a99c2ac1b5c2fd1455b950039e940400cc669060b302e6f2645670e1de6ed55e5c40ebedeee607b259fa411e8b3907e1fb4ba454abbd9671681da74dd4fbdad1f0db6b218d68f1f9e9f476be7ba9d116372faf1d35e58c742c0a20ad5314b70a3ac6882c3cf5993b1b6b4a927321283ea5e5bb0bd46c064295288a838332d74d25254a739bcbc156849c4f20fab3b21f1478216b2df7928663af0fe1db76cff6c236d0800f4f0278b4b2af85c367401291a814562cecfcdd162068594f2210472712a6c92d830f1951df3617192a2cac9f7669010824e3c5b225b10e201bf10e88752429d40a89bf1a46b4e9e68b98d4ebabe22c0d01e9a89e0be2286fbfa4401be0963ec72a0a16b2b4908e3bfbcec246b3c40967a816b9e74a92f6cbdb25f4a9b54a9347ccae8abb9a14651d5d760a70b0df0d041de5b48af9d619dd1562acfdb1ff108ab30762a88335ed749bde74f75b354404d3172fee9914ede58e4a6d3a215cac8c1e5cd0610a810305e484c47f5b7a1d3f3971b89079ed7c9581518505d1225421e69eaa6e50734f3e38c6ebc66f50b8a831cf833c3ceb46b6547a497f19adad04e2738d6048368b8530638802600b9de7727aaa657770cc56a93ff686c5711780e8a376abfa0b83cf12e2882b2aaff7306d5c1b0c2ebaba161bfb12ee8b46111d423110e2d95a7770b7ff69c1485ba19239a5a96e5c9a8c0f088dfa5f01c2db8eafb94d5b42e9dd658051bfdf188b8721f5bf3a97c8c47a863f6282ec872d8e87e0fa441f6c69dfac23a94f55385004d04096d7fac84e6a5b8b901f83ca94ea22c27e0afe08340ce74022e9c78e375c13b063241a1a454005d57dc9dcf44f6fe69ee1879073d2a3ba8f41cb6fda693d74e4861b2e499c63cc2b926264b780530d5f2c604cfb4ab3590ecd364ae84be52702a4b693beb1d92305a5058e50e2d724c8d7bfdec33212dbda2251d2800aa260664ce2f61b2e7fc15182ff85d39846347e28d2c4c5a70c30e8720d9e12ff747e34f5c13eff0fc2e663faa0f2ee0bc33fe8ac5709f771c471a92b5ac6aa9544cadf9fa363d2ff497a76abadec45a2a939105d08a5d51eba2e5eee100d5584396606746e9f6f8c952b40772728625e48072f4dfb2ad817a9e7e6c4dfdde34b31a119356e29b6fd68dbf11e155d31cc3cdaadb0b3d4d8cf995536b7946a509e383d871032f4b36817a7c9e9aafda175bc58ae5081b30d309d5283ef074a100ecaccd98c751b92f33974b580f5cc7a530412f41d2016863f65f38137e16e75d5e6bf57d760c620114074daad957f0ebea8aa1cb2093767068ad897a770e79e8120fbda3aae3f0ff6d2bcc34c02bcd40c5ce53475d8583ed41ad0b48f5dec154de3c63740f6a78d3bb818350e97bed7ed1639eff567bd2886a96bb3497a0b815e38c6b514f0d35dc25dc238e8b42f0b5a6b68b29b4d9497e9af6db450b40d9f7df616a23aa807deed14f5e6e34f0ee93ce3beac561eb2b0aa90e8b10b5551a78367fa1a8237730c715447e4abc67c414ac595a8cced84447563c152829606e73e598306920c36730e99d7e5c119def8b5cade89f8f199eab295bfdb4177d594d04791fc95f7a64c7391c2b995375883097617d72c8dd5f8d487bfcea24264fca54099f16725d907de50c12e16ff3ddf1b33046478fffc2cdea4b45fcd763169852d2d5133755d950a0f6575d5b7654cb0db5bc37f63b9eabf25b87b79e7d040850c4022ae6de20d25b4bbd9c81039d406367958e12ff3e6fd6a4992632cfd4ed822af72c85213a42258bc0201afb2bc4747c459a17dd6258bff1a2260aba420d7bb675f907e2b18c55fc21d55b0abf089d25b1db3f7bbcb42f84df94d753d6799d9adec92297da071a95f02a77f43d6906c44d9e067aeee2c09b1944dce7270ca16e9844f9aff650ddaa05f83bdc5317c5d4fcb717742dd225d9bfe59e578297cbde29dc4707ff7245f499262d1c642ececf168b9ddbef96afbb825d922e0e3bf46de4b821ddfd6907c4db4805f4e475e87d58fb513ac4ab6084ced6191456f06e6c317ee835721ceeb2f6ef0de67023682c891a1d67587449e6f52f13f9bc4799855ea05c9f1e2c807dbe564104a5993a18fd2500926ed01d024136ea1d584de95ac92a2d211f2dd55dc1176e7161288e0712165dada15a4f037bb7d9117f74bdea49c79e6912f962a8343fedcc0210c817036db40031e532983f6b1dbbdf6bc6a98098f09801c184ead79d0e22f4c35c1f5615b96c17e1049badc29576d63158670c933ee2d6b60ddd11ed1994b850e5b3167c03578be54c297f09201edffa0c7b78a3c8ab4eff3e3c546e6873a987c771f242c7a0bce8a92bff378b7f1ead448bf9c87c7928ce29fec65b01253695448e4b792932d18faa4c3c0a74ef51f843b3fd4b934415aa4fccf9e30139ea7417a32ea32daaf29cd5ff0e636b86da88c4538351824431431f0c276de6f302f55d14156fbcbf2038a485e32ea4b1bd15cbc4d67fc32a70c678f81769a2352622e34440ad65f85f35936a2192b4bf1bcc0ac5dc8fbc455c546fe0f6e1131e7853b922be2d1f46250e3612fbaa9c74ab8829e5eec4ea5cf6868a0c93eee803c2e6e99d888739f60117c22944f4e9a2f9ab3daac351ef99aef83fe4c7a0935241f6e07aaca920a23d031b3c1f8a993bad2661ec447934f2cb29c3ee4cc98e48924e2d222aa701e6ada243bc80afa245742a0f47940da158578645e3c19a32c09725ba2fcdf0260fb0e8d4d5ec0d75cc8e5bc71c567ee45b2ff5436a21a1d6511d02d982d38aa62050dbfbdd156b860841de299a5a757db33737007b18117ba1ba8ce33bdf307e10febf509c2f2e5f920b3db01aac36de216ba1fbe1245f4a90db497c8fc02d0b36164af698ed0751cbae9c8a849f00e66ca5465ef63e0ab255ccdd72a4eeef9a118c091febb3de86a8359996f7f7c5b80596d0d32414dfb8eca3a9c0f7d1a238ceb4282215b7c5b3035933d595ff20e6b1799cc03a4d35ad7a493437e6d44a424ce6fe7d1384bf9c13e685e08ad4c3cfa82b0c83e1fd9ddaf1f30139340397a182c57790b97fe41dac0dcaa76281ae8de2a2b10c34c9fa142da77983192f2f0b5d47a61085aae5e841f29a4f094ee36c690de569bddf17a460bcf0c5d13867424890b428051983f504fb7218cc1a67f71078f213e8f335f5b771860601e1f263fe4651ea081b22f4c4fd5fd73e56018c2fd5a57d3398b7b79e3798a687a8a55e9fc0b4032a31345f350c0502c0494108bfae9ede0eb8ee8cd3fd95ac6c2a0d1ad2b50d8328c63e6c9290734347bb546b33eb04cde9316c7dc55548a73ceb1fa9242f27100bc5d3d1c393b40c8ce19c56b3b520ce1a768853e0982cc19601189576fff41551b0c574b09cf4d01f411160ec2f84b6f85f16b7e807f8e5d5405c75464343a10eec8fe82cb8a0c1314ddfc1b0882e06c2139b928b37dded5d5eecb85cf141e815925a46ada7a08566aa7abfe4bff19c2417b3411c81ab6e6c9300305a816c322365453dc77415ca906de4d1ef152c6fa146c189aba0d708843bafc910daf0b499e9f1205d57af60751bc17f7c0e14a6f27159787b4dd1c3a22496f163b7de5220ed09f6f7947c360ccf02f699a796e3a922e057971dea4679a1bcef0f0b43cd2a9d36a7d98203048fc76b31b51809b52da84957c60cbbf03625f5122d4e94f776063c96479ec84e592499fb80d417d5c858b11f4682ca682fd9a66f300d99b01744ce084041d9837e9aa9a83a57fdb9de610388af7076b7b0d342ad47a06547d8b2fada3e9e36bf4e0ffa4923befe226d9ddc4a3269b589722d44a009e5160950c4726a6029941acf12d4cece9a89352a600487eb32b0c34bd6ba3148b04057bbc9594ea57e79fa0a3813d59cfa42e07b738833c92cb38c791e866a047baec901c02e1a76c744966322efd0d3433845976cca34e93613bc48c92335e354af941d548cee3a57cf8db9600641ca5312f170420e06b4b7948e63387171008768afc105d90c7f75827809b5d5f15e213aa7f6e8db9fb6826a839208115779f2a2377c6b2dc935d373539755750cd1c85f89e1c29ddb5673db17e8bb952d2a14a5d945ba7276989faf6b0f68f8767a9ead92b1e2c1df18e3e371cbaa981f6da13ae43c6414d163662ae002bac6e816770e8732a7d58291539724bea6b0061624aae89f8b3c58ee763372927446a0fc9126c65092ba2e0b6f26581b226f0dbb332d0e63ec06ced4acab8f63edd689b6e8a7d027bdafaf0effefc8aff30ec2c547c1f874fc34bd73b6baf309d67e1d253d58e42a512491cd7b81544cc7fed2573daf518183aa7d5586f6e50b22a44b2167142c3590b308c79eb1355fc76bc88f0b9c791cf8fd6f90a6e1c376323f6f98682d47779cb35de580d0d6095efe6c6ee9f0d6439ffbda7153afce8f8b1a986ecddf09e9a246aca253164457621d2cb7b1d140fd37158c22ea8983defd97debd09618cf2d5cebacb66dfef6b8dd4ca669815d03526d6cd1a94d61b5f1e976d524995ed68bbdcecec095a6f021806a9510aa7458f0a5749f50d081cc4726f4b960be2166af208198bbe71a765209eb61ecbf79c79a9718ade0bab1904172d6b5e9e9698cc9d3c68442b7cf23262bfcedd59536f70e2c2a828a7ddcb61156b21755c61c94f88be714b2062cfa2d4dac5772d154d59ff8c308d946039e035723b81fddaeedce24b9cad1c16e3d9529fd2eb82d126dabe33a1f90f9d212e8b346367178412053e2c707a59d47e462bb5052325cae79c26e9e4246b22e7c49386fc24c9b0acd8a0ae5a7e64cc80950b5edf123942ee491c093643f50b5739a460d24b3e67251cc1667242c0551c2c5cd153719105771693d3ed974e52014f93b67452222931512baeec87a17f54c7d333a30ef7d4df486b9e2fda2c2be36bde16f8172f492b4c84311154894676b386825dbfff69a6fe9babd7fa7d4cbbf3b3294821db5ee5ff3f37e9d414c6513e716443817826692285dfb258138c3ace086285d8b1b580ea4c505003b16bf20bb8cf8aeff254907ee64a89c42ebd1443e46c736e24d1a2ecf6149a0bb58ba7e586fb78d460337bc5eced26a7dcf3cb3071ce280bc1c1cef0c08bd8d935f62ac0accce6b7420cf6b6de02dbd2a5cf3c261082a3bdfb8316381ad9e15e723b38b3462229984f023616322abe20d2ea35cf94472578d7dbf817e52124762350269455fe3016bb19cc52e970d8f1e6e4a2a5f85d6b87502850db7a4c976404c2fa3128bd74b9299861b00fb9d92721b4c86dd0106a61e7f5444286814b78d12a368901d98bae23bf7b55f16e61497cdf47716c824c832821dd5e4b120a4e91e952e7027c36763f958ef49993d0f1e70c04fb81e062408d4b27f42e39cc4386210286c98090c06c0c958f67cd66d6018449e43d887f2f8e563b9da9fb459af556a05f8aceba01d9b6eb277e0f15c27fa32e449f4d5b2261d4a24c0193ec5133955a3524e2b9692ab8d9e9411e5d1c87927f95cbeb6019bdf3c83acd5b8bbf3000c8df539cd669e636d618031139dfa116c9fa2da3fab5a7e88b56511429e32941fe4b680ec82af9184ff1db20978cf2609aba75712407eb0ce66516dc73e8bb4718039f34c2b465f5d23bce1ef0233832ffc6a5631b6258441c0f9e642ea505cf9ad4197285091cb7b47c24525ddb671337671f78511686b4c60e38d7c8ed89692c863fad45ccb24f46e2dc5eb3726bc53e166343ee1446d4481e806fdb131177c139e792fec4a027952c659059811c12e7af4a0df9cb201e4250c482b1c16741e89c74c926a2ce5368a3c804e903863ef7cf532109f4cfcc9eb8f4821a000dd3bf6b729cc2e22d414aba11f2aa2d7f85a2093314c0346c3c760c74c1b8af06ed4a43cd3fc4dc8241f34d96f04b30a2d0f5b63f489437b9f79c6cab4975ef4c14ddbc4b82cf68513ed735c7533525b4d819e4421efbe21312840e566f408aa3e350bd76ac985632bc101c2d2590da2694e8784c76983ab9721a868dce2c4727cb409c1fb20473b176bd3cfe7de3ba7d46b8021bcd82e3b97bcaba5babbfc3e2cd8c7e5a08e0f53150bd0e21c0b5279ee30705548227880384e4e50d7193991b56714c702cd601eddcfdd31f3669ca0b85b32b33f6431b301f16d5d417ec1dcf248cd217ee1d31514b20263e3ae551f99882569212a135067289aa814b3e8344acd500ca6682bbe90f9d0ad8e2174fefb7b42b19cd23c023854307b11f2c443a7bdbc7853d078c94b65daffdf663d58245b05abbbc017683fd17c6eb211bda22c9299e61d8a592a179fb845e58228494004f19736006134bf89f942433fc89a04fd2b559e81eee50a5042d336d5f5d1deb003d9325b3133bc66e12b1329dfa9428ae677d5bab5cfc2edacc0b30fb37654893909d6fc8907403ea0a074e4801870d92aa9a29f18b54965a107c91f42ed81b4262eb220c45a6a7f08a9054c53a188d937fa03e7813aacb01f8ac3bd66f9d8c618c92ec649af70bdca629ad52888ba5a7b069effbed22ab3e9eb8c210544f1f714e78a6c45a8a1f82a50e3c19f521b961d43c6356991e2e98d4ff6e10003b4072dfdb766158a9d69faa97c869307f1a7e0cf1c4924fea3d52813bfb0b83a9fdcb7f5f73e007a509a5b29a2e35a010537145a06d34e57077174d8316371d0e7de3562f214967104307d0c4e156c375c90ab47e397746448f1e9aff44a0ff25c20e468b251e285c1e02005bac4371ed7732da10d1995f33b7106321883b76b3230e1a693f9ff3851aadb0e14b38a8bee6a554da4795c1b40988785f4866831bde26cd6eaa9a8dd9a4ff491d41f3668ecd1dd09d86fbf6c808fadf7680893c3e086e0188bdf5ce64e13ef013fc7ccbea223bf041e83ba980c7c160cffd300d40bbcf015e470acc1f52c6053c594d2b21b2454b5e8872841c519b62fe36d0384595ef7007cc72f9e41f9c899415752ec48efc9893ecd96e062579851e21e9d28b57bb68ac4aeef0873386e6626f2c9a8eeaa33d3c5b00ba014906db020a26d773b0ff9003a849fc1e2efbbae12f818047e82f0f54a333c9daf48403456017e7d2767657eb8d00a39c00ddf862ddf9579452a8531ad905bc48df3db9124471b9d83572b6d6a4025d9b1ffdbb6f9838a8788237871a5273e590a289dc2e0b7f7d400b084ee779581dc86cb75d17dc55a005da4b619c329dcddec43d65081bc06c1e0e8c094fa3d991e4ffbf1389ccfde2c89126fd3f1bc69cb41c60b52d89055aaeeeebd07a639ec434c3f31d1271eaff3645d6c6f1f186b647b6d3d631f3c0edfc9e1764f0fdece759d506d0a1174d4aa749e6e62b44b90941247b9aa89e4c897e5efaecc36aeefb895902affe2395322da0274250d7f7f061cee50d31b52387502420385309705118628ddcf486b665433f3b1338a8e5a512ed3fced19a7444091e6c0afc6d55a963e4ff0a39bfe9e5ff0fd262d2b21031729324476deec54e7ae8f059a46d2f21818aa7ffc612f423d61fb50472672e104e90317f17fa474ebd24ab31ed57bb7102ed6481ceadaf4f3c4ed81233e1875ab03d3bb1be4e238c3cd800c57f070bdfb3bf28f5c709e91487cc61c35af3567f8e95b656936c773ff458aa17d31ea5d65784f1d3fd4c6c6d8ac504a87aa7580a5efc32beea2a45048b79b7b0e188fee14cd4399d7b22d19f5d707af2c19361e5658b82302598cc888a80593ffafec1ac9be83afef02617119858ccc3d7f182d3385ce6e88a1cb883b3bb7eb48281fbed1f790b7fc89428fff22e8c8f6895505eff6d6d784c635a93a39f131f536dc9488676f7dd79a84dd0346ae51991ee8c53795cbd54f7117e651853ab97ff9728d9eda04de44042f45516b2efcb5b3bcd11a3e663daf70ba62c3fa56e6d961ebc6ad81ccd6d8aba59c9b627023ac5606488cb8f097f4a97368cefc098419a139706de78aa15639a523488073199877ccf1c3ed65f64901f63a3f9431eef83e15bc59fc141931c110576efdb94e58083c7446cc72332117bc4d3e6f3f429397a589133041f8220f92f59b9ecaf9ac5a28dc46daacc2d3854d52e19313b3d002f911c042d49927d5756f4747f42423f5f03a77011b9ed4aaa24fed1c344458f6e71f89993a0f3bd8288eb5966276708f41058eb86ea1a0c10c52806999f657fc15a918359d1d5efe0c9fbd47f97f2488e1ee050b07a2840265e83ec5ec997d2c22bf7b2842cb120bebd4d4a427fc5e4f9368a894d080d94558b6c4b646ad3a88690e222728fd04369486946a732f5aeab1b76441990fad7502bd961edad1390dcd69755441aef6afe75138ee291873c5776f198872f5825220c15c0bade6db996d2e9863145f888a7f9ffac3516af2b80e05e0732fe8e4f8ca32e0b3c42e4d35b0b5735e6f8767da9fc676d154832fbfc9e818c230a612d32f39028bb81f3d693cbca26bfe94e7ef04ebea1ad7986bc54575527f2b19f7a714f8edcedaa3b83435e8832b2b76f249e826331b654da777e4cbbc3f2263bb98d7c7319664811cbd96159feb2fef0b08850a756eeb8f22399850389cfe7521f754b0debbd94347c281b5971e136e3a3a368a5087faf94817f3007771cf39b618c36365f50df426651d98bb802d8ecb89779cb200223d348749a92329ece6bd0f74769cf75e928cdffbc018bb39a9470fd50ce512ffc4eb26f6cc0781a4681fbe5bf6b003ceb70afcf87f23f37a569213019995910abe10cfa0fe866bc4054210209dd75b3aab99faafad58846767f4f04d549ca1388e16047e2cfdb1c0b8f7665750ba29d60c7c0faebef6847ce01016dbd74f830cad3f0f3deeec2c9ed24c74693fa012cd80b64a954c3aec6b12af815bc6b4073e78d73eeea99adadf3e51cc461a32fe702db8e0eafd93c3464758d30cd614382ce141e5b09ecb0cf35f8430740263a7357fc2fde1640b51653b71b898560fa1be1c837ac81cb1ac829cfe6e1b813ed83e5b55eda2c56bca1126043758cc18f4f287061ac691ed2e935973d85e8f6cc901056ddb641bb9e50765cb9e5d8f3030b3c16a301fde8d4f9a19a6780d5a704f44d8ea6c93fafbe0adf897515a7208176d634f48153b96be92e4ac1e01ea27709dfc82efc5b29574d55b65d82c18d78360b24363ea1dce14be2c18e95a40a74d0d22266e1896440a99dcc3d4bcced635f0fe1670575a8950e4221bfd2f261a9fce129e2ca423d7ed84f97793065a74c32a2b0a80ab5997d48d7585d043870f1c8bf3776da7441d60425577cf20967a0415a88ee8702da0bc76b754157fe24c9859d7bcac2a35ae87682ed767c4aa002a98bd2ebca8c489ee31d73d8501df9d8123a6e181e8ecee9b477dbb385d0f4abac491dd9e844d7dc4fc426d14e1b599afad641a2cb51f9f9e771869500c9bb6f4f57416ca3be22d3aa49d0ca1b1d1fd4df16d429f3ff32566fe7bbae9c4fb90d6b7fe3aea42623761aca9e11f886ae07680f391a728f16ad3dfab53fec22a1df65b678fed22c4f1fda3fcf94e58dbfaa59d36c905295249ce56e817475bcf8cc72f036804595b2cb4b10cb87f0f0895098d60c9bb69c62ebc354fd9c9906ea37921b87b3d89b55afddea71d2290b841dbda1ee489538491f7db65a78ab4a250bc610074870c9d3416862b53459b21ad361c69cc2252e3e160bc8ab399eba1e24be10232cd0f85cead6fc13b87b6d9c652d7fc7e020374f984354bffb0ebb42eae97be4e20cd8935d38d54966d6eb995f02b6d6df30f0d839a8ff384bebdaa43832d6967c1a87139a9aa282f0e0f3f6bff7bd831b1932995869423b0e212bdd417b2800e9b3e7f9b3e3cf7f594b8f505ee5cbae5202b0e2dae3fbe872821dd02f8b5c446cecceaf710b2b5b3aa085971bf0afe0503b424d735918240829efd01448932a4457fb1fc31b387ced764bc8bd9391a2411c842384bc0155bb663c0d75c64a7713b09699262d26379d64c0f14be0ed34e72da337a1d3b837ec8eda7b8e52bb4b86e64fa231b0fc71bf4c38681d4b70f3d0109781a16f76f536c6c1a62b41d1261334174960157b53a9a5151e576927aaa04e3b21059d66a41b7d57cd8a736b3e17559fee3fabe9b1d56a28a887b6830bcda0efbedd35b25862bfc67ce4b940092102143a1e2ec19f766098c20bc6236769ad59a5ede676d4c9d75287eec82d6737c58b9519b29854c397f4f9c574d94fe5e1dcff9c528669912aa607e0c00e9c3827ae408679cc39f3ab5c00853c954b43259ebb556c74a3459c9e8f25fedb602719e5f68409471d300afeab368274b7dd5ca304861cb3c006df37c3abb3553efba2b210d354c043bddac3df1f59fba8e9d586d79c86c994f065bf9ec7b2c2e2f7f09e001c4ea55aba94625eca661e51b695f984d4ff7f78dfdbac318bdd27d27f31c717038e45a40fd2c48d7de4c5a35cb023f0cf037a2a21eb013a3c8f005e4512fcc056a67e3db8be5e31bed94c5346695b4ee3318b7dc4176612898f6a08e2eccf41a7823cc6e8cebdb0d8f62d33886eed2642642a738752aef3a6eb2d59f160f877beef1434960be6b0bbd6f65cce8dcc21f2907a0207245dcb961f281e5e14651f375a7c19cebc6eca58ae77b894c01f8dc98c88b0f539a7aeda0d455cbb523f0667f8e256a3f889f19020a77c00c2f9322ce5a6925fea420607bdd5bafe06702c45f432984de4a7a2110e5eb5c5903d10c1c264903b08d7ec1301d616e7adde1f7b55f5f30ac0ac5e2555b4f9ddae72ae7959d934adaecdd086b2a712678336b4b53a4eb05cb33ef4018f8fc89b7f644b9cae9bc8ee21a44a2964a01989204889a910357bf324ead1b80d9e470c22668f16cc0d4c7836ebb1b31aacd759616f46b217b82f7d284b7309001a9c702f102b5d0fbb832202ee7d3e96bcbc6c780185aaf0eaae7b93d9f471722af9b7fa90aa0104e68b9c834bf7f6629c5cdfa0631f0e70dbf91b1f2c0bb39fa02424ed89f06defa888906f12f7eb0d7064c5ed5e4728833f81d5cb5581c726c1f2fb7cd2dbc67c144d3a277650e2c670fd52cc65d65807059cd0b324874acf8beb15ea9ffd623ba1f2a73217b938ebb8ca3ad97f72ef0732e992d808fb388fd903f5ef6ce22efc8ca11528e1fadc62e90e55cf3e5462840f57fb2f030f008d8aa029930f12afa4c183803e111f5e6ca0cf79bcfe9600375cef58a71e4673ee8a42c8212d06215e99f212e61a9f8d0c5f07fa61651bd67ea4dfb8b82b067ae5bebb3ad3a620d17d7f42a1a603ae6f460df695b4ba4b3c7742930979db1533316d9333cf85e374638494fdd0b78a989bbaf6f452659a0091145a2223d11a3c901a21821e98cb4e667ad4a008cbc1aea8e18ff35459b742a8fe4dbac5917aef49f81b918399702eb405f624b564252ae41801fcd4acda96da657f2f0d852841e8abf1626138a972c7e8a4210308f1b05a1a5b046e007c6aa00bdc1ecba100e9d4ab8b898f58a7ee7b55aa83d498b707cd080187efeff2dd829a4b82e3b796ca4bcf6e9da245001171334f1e980ae441d4786a6ea35e92775ed18d405ea550c089d10a947b55b0cff78c02484197c611fc399831f41b9910cb3d0ff6ab01e555f7cafa941481bd55a4968bb2b2794f3fd5a106f37675cdca10e70d5504b47fd871e09a2144c0215b0b4e542bc41fded1868b252e375f9ea8856f343d2ed6ea97f7d982742ea00418f0fa31330c5a98127bee94cb6b245d25240fd48555cef48637d4beea5421e66660752025ce27197ff3313b0e4c83dd6b3d7922695ca62bfe52c106091bd32a67935ad7611837d21786fed89b0f4e29f756af9fc4f27520e73681a3418e8927f57810e406f592671a75c6ab01abf844a597b97687e9b1b255c134b36f9661170a11b4244a89940e8048a6279efbc21cbcaa0f20c4a07e09f2755514bddd80e6981a1654edc1f355419584e73dfd15e0c407e50018915eb7c82243f040edc997b836ae7dd6f22731608b6384431213587193f7f1a69d82a60cd6d61c8d229834fd317d9aefd730c6ff3ff3814d14345941d27cbbecaf24f05dcf190a54d370488ee8ebecc6710f144aae09fa95e5363f83f1a063020e5d9d088a762cc28966e3c3d39e18f4b568b8e91e7f21cc8daaa13c811731fa64716d5690fd5dad0b671619953433be0a7fe4135f23535479934693b7a989cab5ad8851a917943ef59448e41ef3d8d24a842db6a8b8b6a561cce0faaa57420b6e096c48a846d661fc7390a7e53902671114d3fc442697b71df6e70cfbf3d29005576d1f1f2c8ac0bff5b01bd842ea93985f551d0ef3d2c95f1c4e1c0fb18e62bbd43ebc7923c2b40c7c665ed28e073cf24972e5d8138c5cab8a644b82868e58d81a4b69bc2226398242afe3410cea944884143aa47f9cb94f764bd480880f92a5d69c440491442b4e7b4e22e29b1b3ff40515c4eb3361a093065b14f23fb5ddb9f99d9bc74ba9fc5685d0d6886c19606378fc881a9b468bee71b464b81c6221eb92d680072d28a3f1b6a5c586ece69d4ecefc3fc178073318314602eb0266965f6ab1b2f9a990fb4011d51fea15cee99ae4d04433803efe81b58aca83971ce91879baed454509de52c4709156b6653860be1df07ec9110732de0e35237984edc095b81d9bf873a78497201e6c987f43a49b760eafb0e5e6c01a7fcdb13372487da342bab99fef8be97869e23f264213cf0b8dee45f348c7d2945ad0b3f0935bdb84662899d3f320d4be886e19a4b896c244bbaef3e7279faa3912ad4c7b23e08370a0ed864cc421de60a234bc533fdc6c0a51945250f7af09dc3c10077c211fa5a0b348d0c3596b2f7f5e165f96a5ee20ae3419386155e59d000f3dd803c4930580f91afbcbb741aa53e963634b3198cb93e8ef47357e9c1b2f229d5860f982d2cba87dec2e42931be80d48ea64ccaadf0d27a43010618afe5c8b78504dc6e97dcccadf23e11c97a37e84dac37c0046cffda670e139d14491fb4e72ad7fca5204edf1a85e7bb13ae89da32511f357ceeb11bccf96dc368a6ddd969c11fd250cacd15055ea2fbe99dfd188d33c54759b2663baa00df9b0d215b9f35c8cda0004f0932d71275cab087e580e79bbd5cc2c239c02b58d4890007561b103b3722dbfb22e288d311bd769c56f1de1623d474a502d82bf25babf022d1a6bd3b00bc2ee94c09fe658fd33debbf7a497feda73ab541e6ca04c4d624975f45ed383e9b1b72d8b9e141c0caa4fab0724752708dafbd3427a28a204b46efd481f5109ddfbd0077126e6634ff636d2aa2159ec45da70d0f067198fcedb257c9a140f1faa11f030c70a7777141e7cde0f8d0ba86e989e6f50dd695ea397dd67f96fee0158d3f1c20d16d66ed03a7242426aa79b7f940e0fdb0e8cda16e93f6d65cdaefde45c0fece1431945946e580547205f53f123453708acdbdd25d3b471861c60ba2cc5cebf930f4eb9de8a5aec81d657fa6b889c2fb67c3758694389109f7108d0a947b5756683981304a4ac76083119e9bcb842e37d1f7d2347599ed05907595da550e4c9f4818871e4eafd5eadc5abdb42301a1c7a8a1ce2f223cc2bb3ed74db49478b0d6d55450003251122774d4a107c865a5f7a3b480b40013214628a121efbc92667982105bb5a6286bf68a03dae64fc82960138a4d2eba85f20c1e5cfd810692f62b2808d430b30e0e478b767d7bb0ccd84aedc44917f2fbea069c792510b7faad8b4fe333c8ccb5d5b99bd996b9e8ce676ffd74b73ccbb28b99b54fbfe51ad7a42589e3aa74a02c5b69e9ec48e8301e3475ff540d776f37247a9df2b78d8d6924bd73a959cc2cf6c987184cef8b1191227289fc75b5cf8729867ea2e2c336172cd35fcb540ad7783171f5bce3d8e20f069f97fcd5ca26f38550b10ef1b2286a8ea8dd9741cb60599cb10866f64f52257b29e84b0ce1473c37f08a93e09762b1a00f33f1e1b122f09c9d4b07d30e25ca20cd87d02d757dfccaa59aadfac99bedbf445414284960c9f9ddd68fa263722535c968aa883849e744b039d02110ccb9eda596203e30363d15eb56826448b44991cbdc9e360740351a21b77ddf2c6b61cc3448610de713685884da84d851e1eb91a2a17c1f628d2ef814b18183f01804a8e111137802c1308d46c18456a524294c192d625e98504d9a336dc7566e19c1eaddb9c007136a82afce8270b3cc722df7e01e3c431e27f982c0b5c599e04f072c36c5d74d3ac9f65fdb7d8a4cb07f35934804c0e0aa0a4c04bb786820dcb8d67fc6b1a869aae2530609b6fde3310ad8448067d9e68c6fa1464b7ca2e045a0c2bff7c103ebcd141f66d6e921db2feff3f6ca15d044b3e6609deea77f6fbd3540c6faa8f9251addd0c4376dac603b482162305cee8550f67c95d7b71b21b35bc240ac2de726853f0db1668727fc88104a342bbfedfc22afbbcbd153ffd63156b64729424fa78bd53b046a5f03ec8c6cd5ad3bcf9e5fe59c385579530718a80b5ba05a1738314dcd8ea2f072bce2b2d24e832a3cada9b929c92d02483ea7cb1f87982125138c497f69d1116da9ac93bbdaa0cfb9c2bb0fb4b9bf2c61c0ed5e95d9472790ba34873dcd603cbfebcf742dee7873efd9f26b4b566afe0eb40d0ec3ad5079b2246cc84de9dca298a3eb2d717873b8deda790a0c78f28f0c042af17a6fd106a07a8e53bcd90cc3899162218ed12750c60729f67cb81b71bc713e9dcd8a7b2fb9181b905f283ed50e6d9bcb1186c85dbb8c84c8e844f72926c622b805851eff5f74335c0706c0b05b0fce560e006216b51349f47b0347bae42456b99916183904abadc84dcd2f4989ebe57bc13a1ea18da0de8fcdcc89176d84b2d2325a61b9d267e3d9c3f5a86b985ad980caf813272dfb0270f43be0fe5f223a0ae88d0b6771d7fb28d476b33db2e6a9f22a9d2d8fb26e2992fb148ad2348683b78409615e43a769072107c9bc45f56497a3561c97185e043a54b65f3a2f34dd37a1ef0c2266f3e92a483e6dc61923e3db566789cd115bbab06781f9da0514a0bc9e07f1124b0ca1b510ceee3bada91c172c1f4d67a9fa98708318895f2b9ce6e7e413df8ff7ac3992596febcbb02325e479c6e56a9c496bb2786f0951eeaf7e15f6010d95c454accedfd92616015dcb7cd939b1b2e39c252ea666c8e082ae333471aa945a40a9540d7b7a045ccafe7009342f3e05e4daf6e2ee8a695195643e623a8f55dcfd915ee0997c7b066399c4323fcce9c8181e04ebcfdbd2c8b63ad74db9bdb9f12e026c6af71bc1d09f059ca2021e1f134b7c0414b6199835ba4ddf2264c63aa7f00b79ef1b7a1e00d8fb4d20ddd0690b7e259d68ffa4010eb89f9ceb21d1f04306773a4c6a6489b3cc0f5b76c0def2ac17d22333354bf736e5681bbea1366df60dfb6415f91626487c36a9fdacc38260913ddaa5cb729d7f1f843a78b2f614d6c45408cf225a69b610c138210ebde6ba7251e7f3125ca89229c83aa1555e56377c691ea61f6d1a75f0c81c9cc3ede0f089da26594028e504e74eda6d68f88bcb60751ede5e6f2db2b3a75ae9c9b8a085c363234a87d00e55bf1069d0d1fc9360624d339570256bf989b0650154894744f8b2675713f02d21b6a4e79520a433fd4ef01951c8bae53b094987a3fc1061f93a69f1f71dbae7a1cd93c90398bb9e36cd5b22b1340c8622bc5b6da918b4b6d5c8df06b6f0d723f2a30dba54ef5c31c14f6005176e7d236f3aced2655aca05349101b710b973526c8ec12e6f7c76c1ea15423ffd6bb637afaa2991d19cee312091898d2980f34533fdc1f07acdf61ab6dd7976bfb15f51d16253961ecc84208b5aeea74573b12da8b6669935e82b2ce2e84e2f28d80ea8f1a74ef0aafbd5af78bb333965bdcea9e57f76fad40bc25ecfea7827fc18ac94b053c95b2cd26b471b6a12c390179351780334cc33b3a6df09a5ad6e7e66545f98170640208dc414172ec86d0e27d4591bc7096c278c51556bfb2e6e8bc2dd9c7f5b384c71eb180aab49eb0edbcf4545dc983e0c15cb6f1894f166a96cceb8be474af36bf5c7f26bf26722de7a1c195c1de06122d3125b7de4dc9c1c923f32004f1839d56914d7564e006955c72b54ece3e3ae715f89e7cd3ea7694f18a80b9d53a7cddb572d2456e7d21a642727df2bec7084e57d70db268c4403617950e17ed9bb62e61924272b2a03c61a0dd3dca8154e5c4a1425cf708ba043fb39dbde5546c28bccaa863d692f2da5c38bbbc95ce02547b729974dc6833e8bd49869fa3cd6ead87c53d07b684057d0fe444b49028677bf133639f267f584dd439c59f54ba055824df59d1874aa0ede9d3cb22e0e01c79417610fe4c363c17b8c6a4b5972ffe91b10a797400af185e36c2d029da72b44358cd8ecdf7146bd561d98ddc0cf553d90ec4a5254e4944fbb975ad8b6dd0b45a18dc658687be8c817b83cfc7576200a91b588a6444962a7459e5a37143b02c3320bd17529387db81b0d4fd86c9916f92f27932351450fcc85734c73961b03df4efeca9e1b4464a86d3b39e3e836673b555de083e926312c76942c889ab5c914383d08c79cf81903b974e3c4392b5c83020f3d56e1ed2f033c69fc06f148a56c9e897f9f7d6f6c0442eb871a021aeb29f78d2238c1117519b3b777c0104c76cf0f53910d81afcb064ca3a698ed6ecb5169d3f577d82f3c56df0b11869fe13211d417ef2d4d4ad1dcc812ee98fe23ce7423029b2b1bda07c41c0977750384b7e22cd091d894c2f0dd689ce26ebe177dbc5e97bf6e2a21db3a0ddbe29ad2d5d2a76f508e0bed37b39b4b894b434540d25b337bc13ce0000e055097f43de86b99b7bd8ce2919f35ba71d92d9b1ef5e550dcbd6c5884be036e8d52f2a93a0e2e10b4f8d59c5576ea1b7955fa9fe98151c90b376d7aeef7c033fe09800cfa655e934eb84467aab71ad6554a55d075d997ef04a69399be5e448a8cd58057e3c8cb89c8ae7ac373c1878f9bba22cc5bdcfec40bbb1e4fdfac030c9976e88f899975b5a39fab57554d8b75bd173b3504be986b9c818b038d22fd7983beb439a20eb0f07951b4f0387c28b2351368f8d6ec38ecfbcb25543774d063b94c433f5212e1b9c4ab5b6b78e042cb6c3a62c5472bead50f958c7a5f2f18969a82f2ef25c3d985cde2c90eb05331f0c00443bf0580004eb318940b7d78357826d4a9396a23a7ff494cde7a2db18c5df91a644680dfc32ee355dc56e92bd121b0b1b2fe6b3cbd0c1c10a1e22e4c488299f335159caac457d2833e5c16e15012d30fde370e3a0abaefe084bf0b3656ca8156c08da7ea3b15ab0007e3c4ba7a64928ab70747586b8454e36567453e8d7a90f0cbe17a526aa04ead5639796b0b18afad36e96d9e0c60dda3ab9aefbd227fa541d0505e318726e01a40c998fb92824899063adf74dbf3c86c177d96371ebbe37c094a2b98f94c76b4a3a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
