<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17a754cbfa96513d40de7029bb9138601642b340e67c34c9797dcedc40dd4f3f022c4c2df85d7fb583bcea7b94545d0181de786f5b57301b88454cafeed2eefad2d8bc7dc5d88a02f2b0c04c3625a21d788ad8e158e478cb6ae06af5c288c79b1c40c28848dfb52779c8ebe57a776ccdb8efcaf72ed9a79eefa942689a53994d179700cd874b488daf1c4a2fbd17be1fca857444d4b71fcf45046b5d325a141aea03bcb10e023b38dcb5eddb7808d5d02046fc67233db7ff359a1bce5c1e14b589d7a61d1c1df241b124140353137b79c075aa4fe0ecdf1a0497451d91fee86c9337bed335d97b01fd6e3ede780177522559a71bdd72dce025de52290fada39705d73a4898e606baca6cb7f2f21d6bab4140b85852385a74e1ee19c3bfa6e538c81f6014626038f6eb26dae0f7de45a01c94b9e1c1a9a0e01f49d40078986af1436988f2c91f01488094b938d80a25aebf11848b2982e52fe30ebb7a3a8784ebb27054f6b5d83253a92ccaff93c74677796435254b0882f3102e223e78c8598c7d8034f29ddb240052ae37d693eafb21163505de1244a5b7ea75c782c4749bdea4c74352b84a0fd15e907649d2c6c4f56f587fa0c4c6776688846298fa70a7ea75670cec2b773d5aaf2f98dec0270b9cfaa2a2b21e68401d1a5127669487aa785096559571acaf7d832017f8951e2a83fe994f67dfce723e588f65e98abe215204a14fe56fae9c942e7a8e7444eab61816b39a4555885f6c907a0eeefab3f732d7944e08ebf542e1852aaec790aa854d64751512ad74f9e0457e9628b86a73d84476a3b5b5306084e861b93a9b370965cf2317207519373bd2ffc82e6de6dc4fa93dba6808af9551b4af17ac92c5fc138bf1e0a9ae2a3531a9248d53a87cb3ac7fca2eba6e68c13ed61cf2ecf9f3b8f9b1a358dd93f95d0f2d1ae4ac6ac27a103be66f87dbc78234e5ab8187c9c585d933f798aef3e02d6d556355dae92a1f952b6f1460bb4db69065f110078c5ddbf4ebae2c90875f661558f030c3f0f0da2f4569dd82b3d14c0b7bbfd3bfa17c80c62d9d93c6d283173ca0d4823715e1b97bff463c4cf185ad3bc5d7222f447c54cc16e2a28e0e76abec62e4ac49843619d31920738a6126e1b9c54b9252d29de64fe44bba1fa6f6997636cd2297c167021e3049def7c70a340a1e544099145e4c3ea71f6fee5a3c5c40fbdfffbef03d5cb26637ceea5a4b5dc19a394528e24eab0fb7afae1689f8fd5ef90e8599256efd21be1b5a12d4c759d81d8714f0af02acc33d5f3a62ff26ce9fcad084fe521f9eda67ff5f26c1dddd40d82d08a3d6bd54bc0e3a18712fbc39c7a73506171889c4b879557f075e738c94ce6cca5c63c5d44a2271571d307aef6d59cc5619c018b4141b31e8c8eab9bb58c01b31738bf6c6bbf310e56ac2724122dec8c5308e3c39a86c3d44c9c71ee30751be4b9522a6745bea8222c14dfc7b2467e9ef381d92e7bc51e8f5e01832466b55025a57be4645ce284dc5c9c5df59f72892b3bbeb3a283497c1aceaa350bd3f76cb1fda1271fe80aa9e1feeb375b2210caa9ac45fec8e96ccdea8458ffefc095f06430fdcc34e39264bd568eaffdd5f27b25a3497a94bd54cf143e43d9e01a49233788e8d41bfffee2965c84c170b6a739216a7f3559ea789a8050f5ecbe1382f6ccd7a0bbe8b90a1c1c5722bbbb316be2abc83570d650644e19958047c2cec36e9c29daf498d296d98486a7b2f351ed491870d6c17dde8fb5c931b967b71b23c7638338b2c118820ea5bc06120c68ea0fe3bc0a8b853a0d8a4ec0c368b40ada0c02c3cdaa2f71d1c26945b29ef5267093e87c4bca7c9f713ab1a547068658a64911651c31f348f5972321f27b5fe3affa21cbfe307581ce362aa91dfa2b9d97750e89a1af99435d278536227f941b9cb4bd6841c8fd8c8d393384380c752b437f944fc59607fa3a31156de71710df538bf3c557ba36bea79a9911a0475d427a3d283f6205c4fc401e954907a6b2bf9bdf4b00b0534cf5feb36254c4a9628c80878ceebe2cef69512f1a4419eb2ab8e871b617efb6b8b1c8b200c4708b143a792b0d38c90b1f0e37fef2fc267d242430f986c64b0745fd1043aa6da514c1885426efdb66099b900504ee773a1308cd3a160d3d1b92f5de228ae766a865c103caaf2a46e73e26e08eb116baba3d52e1272ae5b87d00031a66b9f7ddc36844a7d86eb3e37fca23c43b0159ae6762a4d56dc8f5639fc5e8d271691d5fbabe3e1ff62d3646ae0762cdaaaab7edc2c5d0948408ff38609976454362edd5415e98500b300119caedfa4d7b79fa2eb25488f7d974daefbecb0a0bf912f12e582bc9cadfaae6c557b95d29abd3f5e13ede5037597cd2795cd748f3f5c4491e333726d8d8357809d12c9128bfaa7419c95cd1bd9e26662902966fbc05e1044281a00a3539d0910079a3ef1abbfe78ff4df495db023b84cb52477ec5566ee97ee23f0e11c2314a8dcb69d758f052a04d615311a9dd4026b03dba28de88699b5dda7c9272b3ed389a6e677a693c9c6e65718125da97d3bc8dbd0a79a64f1a817e96108f6d6f456451b03755c763f9c014664e92892c7146b9492967fe847980d48e3dc5786ba03df485186a32ae5f4ba27064b0b56d60530914798de2e50d3685c5e7b009c811c8955e68402eacb7f29af30c034432518e3378f1412d121aeb63c6b0d778fc0b070399a5261f1487295060af3e0d6d76dcab3b9e22d6a9c66abbd02c219a18348c3383284f914c681b083fd779540441e6dc6b1d5492e8784c2ba40eee2d7955e07ef87c9e7aac7fee50ceba2e58afda5ee6ea9ca0ce8b0ee104e80da1520f50f7b073da298302369bfeac6eebb71471e42a3a9a1d15f3a5cfe5574a3b6172da726515e9576d15563d45675d7f99453bede2ee2a15f9511a2348fcce0d92289c8756147867c34fd0eb4b908b3c77216010cd677d5001b2d98061f33ebcc8a7cff6aed14dedbafa9f2bb6bd7a6bd9589b848e1ff15a93cf809868cdff3419f3967aca54663495f0079565207072d310dd79ab762cc68da981fce44fb12fac2f5c3e2a4e5d9d806ee86d6d47b578faca54d3a58cc485fc5a73d425cbfb26c17cea8248d4825a971c21fe9db4eeb41a9fea38b788ba0fd1c6c256a4e03c4fdd1a5eba204cf39e1284a70a5ff2937720dcbf233cdcdb6026ca62f17c56ec26f8b03fc7c6f9738a6fe370a832834311a033517eadf9faaa3ccf4cc840d91eeca15ba5e6728564097cebdeb5d7fb035e35f00b884e94cae36c380fe2ebea382527be66a416541cb80bfcdfabab169d644fb6cbc890b29bbebf8742c2e98284b86d5646cb7bafbaabf0e4a7470c6b4131933b1abac5b31512a75b29cc368ef7986d4feea3083e82fc506b1c19f4a67fa772f8d19775e0d2a61544abb05d1907561eb1119eb6cbd6491970fb9d73a201a8eb4f7a6784f02e61c0c73aadf1c52ea52caecb5adf36518e6ac8b5f5e550db4b9c798cd3ad104238145add4e0ce803ada1f51793baae91fd7de19c76d503d72399ec42e5b1d81880ba932fff02b6de4a41003fe4af5c1ec7adad01f4cf14a9624ec3999acd9140874520910b45323b819d3a551392f1aed9757e270f8fb83ad10535eb973bf365a94fb526715bcbe0c886662d094d1f6d1d2e8c1522902f8f89514404476a100621bb36a89af6306e15f7462a45ceeb27ba9c4aadd4997a78c9e9cd9ff713f9aff08d17db3e981a9e87d5cadc6e36e1e38339828e4991a173e4a816625f8aa0a0a69a674f2c0efeb2586646cc1a20a375a627b23c39a249d25584f39d4f9a4645f77139e968faef1b17a1f178ffcd5bd563acc99ffb5c5f451ad4411e3b99ec5904b9d57a6057956aba07eb3bb2db2f0079ae40169182f1d044260d66fb4f23ffeb366d3761c68638d29b78a778cf03f78fc970c26c10581c73563646f58ee4376fe9d8a71ebadbe2d8111b53fae819cff6f3f42fe57cf217b84067597949cbf274b72d24a1cee4d5ebfa62522f51135c7c970390092fb333f103b1068beaa985d50af3af5bf63ed03260cef124d616c3dca96ac703dea580985d4937556695977affa4d290f8aa6e1675885685bd9c9041c1bae3840f54af2e818c89315200fbd29f41fca642127ac70cba31675ceb5e80d7bd4e78ce075b78df1c7d364c062316a8ec3b8bd363193e2e99aacd1b7bb2164ac0ba477542300002566060447bb700bb8c4dd389f3cbef4dfd2122e636ef7a29d5d41f0412105faf1b99869582f686d6ecbf555e1c03cdf6ad13d61bc663b1d0f66038efa8acf2aa312954a59bbb336d2d8fc5ed67e7afe73eec2473dae3eb8e8488d030b8389594ca4c52f5ca68bbcc29b4ac67904268beeb3a01615d772dc62555debdeb8cf1dcaf737ab33d2741ed255cf759e2ce2b38d17c591703a7bc81be4ebf633a7a06f3c34f3e09423d7389651f01a1e70b685c79587676e5a5dea147d1916a1888d03df65f5a6a27256d9464fadaabea45caf7a3dc92ce2027f6c074b57c56da5d063d51e3da7f15183009e7f3d5a9e13812ccbc9612d66e0a8fe3c82f9d15dac76d81fb03ca41a95488ab05ebf22dd7163b9829186d1761a90565c7e51de002988e62571a80fd631fa62a29dcd0c1d79cdb40e82121d3862fdb8a08c3fa42e8bf53afbcc4e383f8cea7ea6c1a3e7faad5f88fb97ffe9cbbc4d9fa053cc0c07b28d68ebd639416eac67582f95ad275bc44435484df40d3e18284cb80888b59fdc2472755b9c46d1559433cdcbed7cde3ef9811173377e4e3014f283a0a832af2ecdf1bd5f6e9c28f2503ac0636661fc3de5ee91ee1622d60c4f9f4cc96e07e79226dfa2f473fbb165e57530fb1a2270a767eb74406c0d5aeee54e53b4f949f579f66b225904e1afba4990631f3176562f678b7bd191282dde87ab8e70b1dd4031375c546bedcdc0bf90e4bea610698ab0eb1d23be9216b25d23b6a6a9a9d24582bdc386fab8f562c72dbc21c37c2dbf23112f8bb8f0039575a01440e39c37ded6d5072f0e9186fa0ac1421fe90501c88e0534f70ca3f5f0819f8ac166f9f06ff36c0a7538fe94a942efa1faca815347fe1e4af5c4b3b9484baed93167f52eca730fbdb5785a940307a04dad4125f4477829e11767047683a9086033d58427a9480a292fcc03b2a3eff32f37050fd153da1e2a6c1a9b312f6e0fbb8de584e7c8005198866a38e906d1d3e6097e81f6026c18027e444c5d97e9cc9ee19326381105b43250fdeafb61195b6afe7f1fb5bc7f7500d244a376197cac1f9d08dee3de176408286747d56e76ca29bf370b5f645a2d3b1bf61a33615211fc818aa34b42c89b6436eeca623b38cd10956734720ce7f1f5e3946d268a5dbb80c30903731a2b68cb1069cd5cda2836a3a08a899042419798f6e01b50c323b775cb1e4c32ca6e152d3f0375091da787592719e1c15b377233345eb83b7d08c9b3bbf2cf1418b8d23ebd53b2d0d3d68462ef008a68d70a959480e14e1b2ffefd2233e2da9a380fe2c142812488e92946580f0129e923c0a8c559b3c460c55506341b0c5cdbc88e18bec972d7d79714698d5374e0ddc888fe154a4e4861a8b42a74e2c234413f05c2e4b82567ef8ecdcacd5cc5c9d1a1fafa92d03604fefa5cb01dad7d1f6765be617743219736c1bf85fbf08b9314547c14e1e66d76e1db66df571641998fa16afc6d29feba26688c55a59460887e36648ac855f6cef525a2ff8c2d7af54dcf15a8fad5c1c61bd6ac26cf67f4bf159e76af6594cb9d061cd5631debbb2d5be40b42b67576973f39880fdae6d03b1712c50cd1ecd8a73014918fa67c5b26f253dff2b457c8d5b63a402e49e802bf5be349751327abfa423eeb9195e388f7268796b9027884adcb647f60023c703170073c7241eaccb177599ee061f05d19d07cb51d7ca1b46e66b8c9af527d96069648c1f3de70b496d57a309d1bab0ec602f05df5000501d4c56eb272b092d52a96358edc00ec61f94010601c4595262229a4b61348653468358e9b74a8f6bccae94826f98767ac0eeb579883a40930eb8dce38f851f5435ca61b929cc5b7ecfdb9ddf823bf02aa7c60c0f533b9f7dd1d96cf32116476c5eb5f684cbf12639cbdc12888a4db037e295f778af525d876ec60717a7e2673c6cc02464def5e950c547ccf9e866a56bec2760734ac4aedf332c27d2df7cd1b4ed205d5dd244de02d9e9407eadbbb60f32d14d1f982c64a7033f7a1186cb455fe595f404eabfb811a00971a1e06ab692a4cc7f580ac7990677ebe39142323f2845bd343baa3adee2a1b4af5e88a6614668d906538440d1268d5d63556f326c121176c2c331693398ed817e82c6971b2a160d54c90a1d057467f991ea092e6249a60d75c09321ba29d77aac6f7885245b326aa396f0a659768d7b04c69ad3cb49117b98aeb8335ff0d616babf0b4975b6b08a482b9f2ee089c143328cc6f98933347c812e86eaad480e038bd32f9fef1eb59cf379ef837968dd4f27e045e1d1ea3b6c8e2573ba498a1c2097cd67da65df6140561fa50d85732e815a33fdb1efe08ee16bfdf9d6d0e5dad0976f9d6b832f03b5ef40684820f46a1e794120fccae8ffe7c39bc7d2f37aff2bd59b810b5940cd1774ab537bead4f01dae12f524b7e7cc3093a1ce346338888d304d5e081fe86c25231c12f9010c9b772dc98d153140ee29846af45a8ad58f1f9845e3cc4eec4dadce23e89683c87b6fcb8fbb903f6596e2ff0637f6c3d5dcb74303aa2e3e5df290f1757c8352708a27ffb806fe7d14c9d184b448a2f77d0e5916c7a0d04cce8b6b3d81a3d03032d401c6c39f30f23b5acd9916b61f53673336730dd18f7544eb42bbdc88c0b61f5a558fb47062008b48f021d1d2dbe49c29fea50ee26d2c7522872665bede20303d3390bbd39fbbba87d9c0951aa2c6608304cfdd56b8710f869b426c49634567d751853c45bf97ae2d7af371afec3be7e147a791710a86cf3a9a3e9672921d53762eb06f4cbff49e6f75094d17404cb06e5e4d9a78cec8a84fddb17bb91598af8218dd38460a8862a71122cb533238ce7e9ed98e827f91b775a0fb30a600f964d03a30b2d45b02254ea7cd70104c607c5233fafb30f05f07c96e0c1d630c2980c7501e96c5a4d9a863dc31285df4be71f9e26127fd2129288569cc9167fdd6deee3356c678f194abdf333791a5fe0b69f5bf9da23f9d3bf906544c6f9d8b82864240fd152b451e6edfcfbc26be1447437daf2a88ac6bad89c443e191ef8a34cdb74e2130a2d5707f4809e12269981368bec3c48cbbbfa3218e6d8f24b7a9ed9b8388edf2a539963564ef8c4dc9d9f71fd4c6e471a1ceff67242ffba8f435a6649a0a589a06eb633f691931a2d0c5cf1c278c4d476dc7a8b5c92a77240b09d687a158a9fea7eb7e746755907fb727409fc5e477c2399e4f5234363f4f9048c39c28377f808b44750a0b3c81df62909c1ba998869795f46fcc6d38fa49fee3d1ff88e9ae09fc281c1b8949e583a0a445b967e6701f33b3226779a537f3234c66f06d2a1a33f5f2c76e7cf081fb8c2b5134a5e5c535c67f09805b57298b7712352e7a608382bc988b97ab04ebddd78add6dffa208c67cc4630f43613e2752585923d6a0513ab1e62c2077554334590c528e6e9bcd542b11cd8ae703dfea7f594da6cc4a3f8d261a493777fe17e298d53cd8e92e89be51a1fa54ebb4a6470efdc21a7c09c96775183793e4377404ffd3360d49cc2142574800a71efc2acc47feead58f3b11765949f47db6c828d2313ce97c95cd46ff4d8dddb303f26debbcd47401ca4fe2aa23894ae46a67ddfc17fa49621c978c53ba3d0d2b874ecf8bfe4df6f2254d7af8c9ddfb5ce72e25b6a72ef9a8116f96c8e0fb049da9a7b84ff70985781860506a29a4be441e67866789dd8aa35aa4efd14804289e4263619f8e7aec9cd76b51b190a720cbe22f5b21c1b247c5b09257c60d32a47328f47fada5623aba28def7164df035edac6800cd45a799b387e5de355432a5b3d563f132ce7f4d506241579f6a5cc9a14aef7fdf2a4ad8e6bfaaa299c7b685fddf7d435153b3e896e7d28e12b2f60d99d2b60a6cecb882a08a79565ef3adaf5ee533c1aa405f8f2927bf31d3a113b4272782adbe0a598192c23737419c4e10c5981cbe85140cbdb373dd6bb9f11451c06c27598d8f5a519808d1cb5c6a0ad4d721c3a3778995e611a8ffe5682d9569dddaa244fb91a0177fb0baea0d8678883119b5170bd57c89f0aa6503fa56e15171d6aa098197847b6975494c591c8a60576a63099a6260fbb27a3a3f5ee4065f45091bd87479ac94045987d6c70e079a5d9b84df5733b38263c6833491e24d800f0f7908504b18b5c937a5c8cd47774d51dec7469106c10349f6cf91a158102ffb9b6889715d6ca1affe33b2893fe74434789e6a9dbe6821caf22b921a8ed716d5b652c45ca720a6544d1161ccd807439528dab1b4aa6f72d7846fb793aa32ca5ecd821d040adb962f2886d353c50ab8982de826b35b2aa91edfcda56250521232d0e06f6102eafccc059c8f578389decd154108f1e99d6ff94104fa8c4431abcd5d1db8faa4f78062dcf4ef00e3338192019971cafc9e8587eced699e37bab56c3d780cace4fd9ca753d62cccb08f695b9f165e604c260ba753255b3b82152b1576b642d2314e8de32dba2a8913a8cc289d72a3e8c451220fd8001e00604d63268e4cfdc75f0b6e60b15967ae80f92c083ca23c284a5719e3c8df10d8f40d3f6b636f95ee18e76f99275a835788dbdb043f37e26ad441724ff353be0ba160032f5200e91a46ad33d4a141b11f97d8f9f45cc5d061c9aabf2a68013cbb742e385d144364e9c5bea196e012beed763c41d2515c2aa42169103ec7421f81b6899ecbe2f779c3adb90df143b7d2dd4427ddc62bbafa3a65c67bba6560b145445efcd834e219f5e4ca1b311544473a9bcf1f29a22f9a6ba3b5ac145b15abdfa7c16206d8c3406a198711c350c10279b59b87bf1f8e016ffff5cf1b1b1f070600ee4a237841d83faf879f33ff3b2b38004490c161e25d3681dc5f2e2cccd11aa8d8ec9ffff18ccaa44a09452aa99286a3b5f54ad647c3c40c50b02fbb106475f6b511a2a5818be9a017e3fb3a1add100b2f5fbce8609cf516be757fe4b7aeb5a4c51a5ed1c7fd074e9603464bcf3dc20ab08f5c35dc475ad8979ba1097d77ecbb5329099a5a8afaa317a9fbd81d2acae121c29ed8465f86cabe1c1ee8da308bd399ae69d039f80cda6909cea411007b29f9b66ae3e4779f5682579ef2b4ddfa5c219e6943264c558e6e61eb8669578eeef2e69d6a7c21c751788c2219bbf2b4f3b36f3d44f22187990742c86b112c60a4868e0eb694ee4e9f1de2ca4a47be3b9182372c9641bd9515de3edcf2129570361e3a018f69b1f54197fcb05035dddb85fd05d5874d412d01b887e447ebafb9043833b0d4168b23660b4f76cfc3021b8e4a909989023a820f2dc3d2e8f4ca01a4bee10aecc34100e5011c66a40fcc1cd58db8a58f7e42886b3c20aba35216171772d3ef5527303a2c567d6880bd301f577080057e1d3340474c3331aa55994c8ff4688c2ec8450f445e4e4fd0f39706dbbaf3fe9a34aa7acd3d494308aed4daf319aa85e6a7cd73555d5e85a5075c9ce163537b9a505bf37dbe59e8f77f5b2ce4015c516d3b1460ac01a512d4d72cb8c59f984710fa90860f556890b3f0cc2141a26bcd41faabf0bd200b30bd225886690eb25d0aeb2f007518c1dc1b05c4f61396d21506f3312f2af67a9ef290ed73d5ff2253bee4263ae58fcb4671f50042b70cbd0ecd418f79a551e1df4a804f1908022b78171535dd59ef347463f10fea3dcab7ed22115f765a0ac6558e269e2ac9eb2bbca6e45354d3283dac911a7d88a45348160bbe7fc3323dcc190a5502dec2a342905a13a9c86510333558fa5be5f9f88e88d133b637d750323ddd9eb1358a5684e0388fccfb5a4d78760e983697219e5779795ff2767e26ecdb626eaf3ba0724948d1f0186f2c72cbd55c280008dd00789738a336be30e5e53e3d2e169828ad12bcb1e0fe382b1621698c4b6189a685149f09da31497e564a79d8045c376fe88f8b93e3f9bfc75771e14dca89ad5329cd0fef5d448f116eb740d632382f6c39279a6a695c072a5ea51bfacbb9227ca5fa181ffcd6d72d0ca186d0b6252aa32b613cf9e793f248f3f0828218f55c6e064ad453f8e7331defbcf27ea1d6920799c1687a64c5a4622c299a0b1a83fbaaf21f112f6633824649d86a25f0f59a85932a1e39a320c9b01f882269495ca04c1d87ef9ba0eb0f4bbe88bcb7dfb2084bef8f754a296cea6f9873f95e6965e4a45c80d33229e0a696451055da2cc909bce623c5bae4b92e9e2a87e3003edddd3c85871ab398547e8e45a07da7cea01f679581edddecdfb4831e9def9deccea35d2a889fe1bdde36a001545d01f92caaa9848f58a3be07a7a94e0f84ab114fea15fc24dd74ef915f78d7e1430a98d464b6181e918c7b9506a756af48f6f6908cae02e847a745be0efb0ed5441d684102de0788d91859606d97b4b267f2d2ec0f15bb0dde5197dfac6c233f7809cdd052e8be28bb80fb5edb8a8c133fa636d7adced52c4efcf856b715403bd98cbd8f4bb97515a158b5d0e5b7e32cba72bff2947de9182b44f5d979f69a97e581f85cdf41e33b06c75d5ba9b672b32b47e5aaf91bc585e380693726b36220e308169c5cf92889d1bd7aaa7d6bdd87de343888a167b2832a5624069d06b783df69f75e890a594423038853925dd74fca563c9d24a717944aa58fb444823859671cd10dae5f2b57a8ad07627031a476cb4c202048a7bebc2643feff8b7474b7b3d7715e3b416c3b94c53f2f8bfb897feb10f049bfa9f78bce724490398ed04a16008e2eac5d362f79564abe592bfa18290b867e86fc9ff2d4f5bd959531a64ef7047fd6616d8fdee9fc009c9cf7b0cb2e7f68d366901d329593fb2a63b215f2ec81211b740a7c685c377f7184ce1a060e43adb5072396988839b5239844d8e9e6347bce825f352344d872fb8898f0996ba10c3a50359b44e6b1b7734a1657718ba81867985f853e8d7b31cd1d0868540b24a76270fd4aba2a2126e01a19a8ab3debf81bc074a9268d3bc27edb96dc86cd3fe2e2d905b475068b5aa4061ff7d90ca5a9fc1f344621d8f230be5bb13b8f6ded2baa341dbde2e4307113f2beba76301d21c7d995752ff59f3132dfc2b41bde82c917835376e58e2ab258993297ec02fad097339f406abfdd65e9d8df99f60ecbe4e0ae0fae99302b2814709f65c6075beba20f3e953287d04e85279f3c0f084657b821b1f615a433d087c142b1553ac59cc2262245b55fd1d1b72bebeeedbb7ea22d24cdc911350719f8e1d87d9150ae3732baf5c19d6b1417d1f0a102e3d79f6cf6398b378ad148b69f124c3afcacc837c0473ca83d408ab94740a2eaa43609a98e62261c9eec66c9e293c81cdb06706313c9428e78ecad2a602baffee4e323bd82c83d2e5557fce3c57f76e59b9239ce133e07724157491a9d46a641095d568e913a363149b3c5599dc7d1e8d9007ae0205f939c99f2e1bd0239bba5ea6a2106b62220355dde68de059ab4e50ce4a98f2ce51de026da5bbdc3e8b396d0aa59c2ea290c803b37cab3e5f36aa8343b533d699467b14e5662d429c569fde5aad9159e3ae823a482948eee143197858046e70990fa8618da731c924818159bcb242f6fdfaeec426d00612924e46b0a6d52055f4a32cde0b0a62abdcc93ea651830a92d285790756a93be0f148a192e0d4408a55ffffd1a5f55f5434a426b8e5d845c201cead30fb1a3d985c3833e00c1799bccf58463798d53681cded51bf7b2f2ab927adc642f499b23a7eb7316c6a10b6f3af5656760b283e0b44448f9c9b13d307928cf0a6fccb5408afdd5b4c4f3f421fe964a57875376b5524c3f8bcc651585d5d3655c5b8fc0ada4f9b285e7cf4e8eac4bc95dc1b1f41fbafc2965660ffd24c99fe19890c241d628d5d39f2baa5749cbfaa20e4fd75bb685f0f712095348bcc323db031df3fb5e46ab5f8b321350f44f3229b9140ab80e1adc23a54806c5adeebeec7c4fd72dcbd66e254be899c652a17bd35b9c9993acf365fd5e8bf07f9a8c60ba5e398da8778d1d8e7a638555e2d80fcdfc1f0535bdd6e76ddfbaf0ce74c3448fba11a4614055fccc36f0cb36eedfeafc5f98ddeb1e775f3e12f70a779ba4be2e5bc207122c5bbd03ebf2c8159885468ac1b912ed03ea4ada807f1fb9397f3db0777cd27c94ef4cc6e3f0c6721a4ce00f9f7defd0cd8ac500f0a3b35d667804cd200cf2e92d61ef8c24417b65288b4dabc141e106cf9b44ac5d89a51ef7e370427c0dcd2d4069bab1775b7e36db800dcbc24d472d9acdc8eb4d3f0fd55fed1d81cec1efb438d733db4306f6592ecc225a590e5dc0caa1de06c38dd7e69ad46eb57b8aca18a828b4e720493463d771708884fd2e8e67366ff719ae639f09646c69ae020f9f62e855ce8b4adf6fc345543bad5528418742fedf7195cb13e032af04cc13530d5ec3b50d9bbe28b53bcfcc67c3f3581f96a1bb3a4eaa1a29bc424a46c26389c79c489288f4d5a14aefd6040a7bd18a7f5df18bd8406066d3c159615e1eb8f11187f925c6ecf16753e03282ea957b4c2f6647a7bd03c6afea5688f5b5c9bd65934550737333b6ab9fbf87af7c4ec5744e6f542db77cc4ef0d5701c2c763f4f643f9f818ef5071591e77e5873d7c0f8b73cbdc150c8a9656a1b38489c85342de48c5e9e2fbd231d595ca726a4d74e92e6cb676bd6f49c31bc21b6039ffbe7b77ea569f3998b4f9d1536e801ecd96fc4d437a8589d83597b8a5107c8ba19972116cfeebd02b90270d807d61f6bc66e87e2ee533a5f17f5505d8cfdb3048b030b42ff6f6299293ca6df8ef9262943b89df8a020dd1f37f57be2fd430057beb721d7c5c11a988931c7ec7b0cd3d1e9fae257c1e8e30b32b903a887ab0d61916d060032faeb9bd733bead63c3c3a75c8f0b890b8ed4700c8a1a863a104dc616378ce89a5295ad33459cc2d610df1850eff2150074b3fe297e3bcdfd589151b1a2dc98d8f81212fdcc58278c18085f83f56251da642b7383fc07e24f69140a1e327cc0cd79012132737c830871e6e2fd7944a8a1444d6088cd0bebb24afdf9b443d8300aad4c8939dddba423df467d370d7c9548cf37dcf5aeef2dc7acbd4689fd4a044e18a13426f46e52de7028b9b70e0460cb8270447b2ca0fb5e5138c08078ca5deada62e38d3bc265ad77e6808f699169068254320abddbe838fbde7785e1c9649a7ea3b6d737c8d2304f0d3b2401411a212dc0ede372f051e8118e1fd8fda7b2d20bc1f3198352b06bd4ae198ca5d68acda75046fecf3171bc78f899e2339338110b5e937a1bb313f6510e3d4c29d537490156657ba4e40c9d5f2db26476b4e1326c2e538b70a9776a52ad3b923a46aa8bbd2647d9bf4009da3d7321b340ab7b6f647f81937b7a223d49c1f696d4ba07b359a9f7bd34a9849fa4519d046e2927e76dd22617887a429d338e7b11616a8133622a62dfbf4a0dadcbdacc7972daae8e04d77c29240007249be746bcb54c8ae54049d645ee513c91208ecf8b9b3bdb5215612ae6d05796de0ac6cb47882434d8ad6c2cf31ac399cce1e912239c897f650f3e03f0b24b55cdf649742ccaeb04970666b035fb59ff7214eb8d0d10bee14d2f0d29ef83a1c0c3e7804af8e04a78ca06f30c9ed2fdedd213d6742b9db7fa4ad19a877606c26169cb3e94f21682a13a7b746c191e7d17b765877fb6d3cbe0151e4139c0159b78c351c440215c828ea7172b6623e40d96943196a76b41a3e5fac76d58ac168d87a08b0634756a1339b492ba874e87b73e3245669f7c9b136f898e1eb639c8d006724bea773f419bf0c36fc18f0b6b8ed57f6ba38b4bcce7e84290c7afd60f4a15dd9f0a301c31648804b0a6b09437381e467a2e1d32a1fb627bf7dea0cef22d6d9adee8a701ff24ab7e7a35523621c285b10d013da2b6eda0bddcf18e90c12cb62d52379a0ed27737f6d19f973d36f685c4b805c0c08efb806f75a0096830f3d62a0cd1a0578c92a713cac35364b123c4cf38d3864e69ab93c793fd321f0b7bcc0cda347b0062540c91d28e8416902d15d0d3a5ef5e6ede13cd9389ef41006e44e948295e9149ddc2fc80316371216e379b5af3203c9bb5da04b1604ac6c8c834b0749161b43a13a427be56fbdfda59ec44095d17ea9ca723b976faf8b699c28d26bea8313039a6a1d363adffe713915e8d321dadfda86a531065865bfe2b870330407b49059f874060e8d22289b0eb2ad3162bb193b598ef0de77a426a4b108a1bcb9129adf24298ee292f5f17c6a4f586e5bd7fd8458d212aee1b1989665af25dc4bff6a38d59c91cff747e5dc99f5af90891cc33fcecb241ff45066d65cb9042f614972c095f0f5d25e0dcde883d561e2fb2945b2234310577e62ee201b3b8d889ee3080856bb3b38a7ed109e4c92f0c5bfe2d4871e6c8c3479b611cdc7cdbf4fff69e0d3189ca70d7136e3f43380e20b675f9aa03129265be9c158e3e85f956a5f2c8a93cc2a90cd73059e634aee0becf45a120fae6fbfcf60a2d71e9e41bffb9ae591015ff22e99b91999126f884fc26576e6029ba882c252f6bc5b7910a7ff1da8dd207846d35a3112579b8da60f6c6efa11a1d2f9840ed86b741aba35d0517df3ba2e400a92f55236e1049668d4ecc6b8ac56a458df2a46e110340e4636c9ee68e5eab4d3054ba031f11b6a2cebcb0da27e1ef21c0299023f3a69fdc13eaeac2d939674b0d41c90b82d041f492002d90de52a88ac01711708df76d13641de10222d442aaf177ddbba6594f8e010da705efd9b1355a513d8c44a9dc575f466464f315ec9e4857952757dd5a0395d686357e0d963942ef5b61038aea4845a5a7f4c69f2abaeef98bec077c7eba109bd9a2d317d81d13211bda01e1c068a629ef9fbc9c68b3123b70b1dd26ee28f4a13e531ee55cbecb85f903692fd8aa58ff3d86553ccdab33669e2f6a92a1e375f4e163e13881e3a49a98651c0a9f4fbc85ddab9791be00bbf8698ec41b877a1d0a83adc6aaf1e40e5385c59a39ef4e314bb955f473b473683aa51e1d3e0a925404d75b3fdd75785c7ee1038f080493b34698e5ea2112ca20ada55d90625774b60dde3b25e0ed708f57db82188e48f02c1edf4dc1edbd2816423339d6283070756e25f2c5c4fcb97f95c2a13155cbb61dcb9a9536e120fc7d60988e97645168ab24a46c016ccd55f4f045091a75d07e1314f992cbc69f2691b8f0dcd181c9d054849e12878feddec6eb6a2ff3b3f07fb188a828d9a1a4b406c10b2beacd2a2e41e34e35a51b7b8efd5603008168f43f48e23fee76a7ab01f9a141e1d5b5d81b4dc59b0f5772b0e9a8ed4cad979a39577280d5ee465db35d00d217bfbf28d7e0130996c1bc4c75e4f915312bb9558259310569d06ca9e7989eab2c131a0e2d5c472ccc352f551cdd82f5ebb976add66ea323f71b7d06d7e34c430e6e428c7d7bf1be41bd0af013305b75fddc915e864a82b5efb60826a7b4e20cf58f834707c014cc0be79794ee20414b95051d119d1d34af7029608f748f3c228e879aae68388dc91f84c985eadb35aeb2102daab9e232c080857e4afef7caf6950c34b1881d870e7d5397c062b26e1a3aa991c7f11a218c372bceefafd8ae7467f2941e85ae3470dca2d8b82209180cca88fb3d19c72d97b1b7054e86a8c808cbdf8ceecac931ad8931de1a77281f84fac715207e4054eadb4ed3dced7433a16a6a0c32ddf129b9574ffe913941873a43855bfe5d7d1aab7fb90ed6db2682a37aed473227d03ff2207bbd205608298bf3ca68d4ec61c07a802c1d6d0ec7de83e12e2a5e5d17ed9cd99514288c18470039e8147cbcf5e67f3aaa241a4092b2518d6961149859bdbed8a19c68fb97c04f5a3d2f049eb9a6dcefff16a7364ac09619511371faa8f44d88af893d84af0a7840a16a3799bbae5e4b623af7e844c7f9d48923c64b52b9c86191fbcea3b995674caaf139c367335981fc1e0f68e0be09a3b3d6548c6acaedd1497de7603f30c096589123e637201c6cf0f7c56f94c0cf5e234d89a79265a0ef8b349599045d11c789579973a4c2c2f246ef8dbc46e76476c328feba1d803f3568d0deab0ca5a29b758d4b529f4d136bbc180e9b95fd9fd8f928579e599bb08471c2fa15b31958f555816860628f37b26b770002dccb6afb0c3213cfe6695e414ad00d79c64033decf3001a7770fb9b0a94594dd6620524c5153e983e9d492000e2894ac66b30adfc32708b822f89db7186cf0d96dd2ea3ad0414c62bd76debc1896afe020c72490c6a3c8b8b1042f1785da68b62f2d80e490a0f4a428bdb62de330f0311177ccbc56a13e7db46060f936c5dae428145cbeb188131ffe6ecc4f272e20401a86e3f039e4f71f13c420e6602826bba37abba2da544415410453569869310567dd26cacab00e8afb070b4bafce064be1ca74e3c811e03df34a5a2ee4fee10086d98aea90ff74f7a1c716494fa8364f3d80da4e9df06fde2dc785ef573aedd87c7c48ad04424624c7f04f5593ba91869f2911a0122fc8e4fb53970345857512a9c73c8ffad3a98003da453c86716bd37bf9e8466509e9d0766df3ed77bae2bc21a45c4b1642afd4e69ebc456945844ccf75cca034a9e037a2e65dad5b7fe63bfe4ff9cd8c0ac582f5ec5f2bbaff502f7756825c58995d8b76b870c6f4d86d6348d6545b9a0a8cd7a60c515fb7677e759f6478313684188446f67a27a367863342f73dd10eb078d0a50012d3ddb7df9c47a2a7f3ad5e6da62a2c4053779128696a21f1d5b207587c92470a96d4c63ad5d202cf9d8d96544550031f9dbc2ca601e1414e5b3d8d3fb588032141001359c6b1cfa2c209c83fc2d3dafe641b3c84514451bbb4aa849c4acafe7b86845c6270b507c7fe5b6909f84ae104637dbeeb8d0fc6fc6a815f671c8f7bb8861732d8e5f3e47eacbbab6230dfdb933dde095554a194256784d78d266432dc481bf950d7323101604de1cee0df760a1b5b83bef4be8b2da9e1dc1909fbb14e362fc972dc460ed11edeb39263cc432e5cf2d7e924eb99150d36e6b7cfd0174227a3fcc61eb23dde2d74664a4932cf6a3c2e3ed043a31741938ce103c8769cdaa2eb74531d1b0d7d39abad54de6dc82dc1a33dd8e87d519ff90a1611d83f1d25a7493807f912f24a4fd5d08c1bc97d4cbbad9000619d5e5f429b7945f4dc52c105d644cec64065b828522ad9e3e514ddd6373806209268f25132164b48ccf3e42ae3ba035dc71f68daf5d01346be78691812415f467a2f574aabf66e1fa1bff4bc751775a7e59e052d26e346b66d38dea61dfd8e9130775443048fc3d7672f462e0cd91ae3f350bb51fd91556380c62714b1fa7d034b6f6f4e8cba0753e5078a209d11b5ffe508484bc0a3f300a549c336728a2279ba0cd1f48da68f0ac4baf4ac93e243467ddd9912ae0c29240d165eef2aa510417f806f59c493633da24e510f06a849e42864c9be715d95e8bcb069e86c9dae32ef7402aa2df6f679da6199049a5268fe3030b920624ff1865d65e53ce4800bdb236c658597eac712779d1a1b5913e0cd28f9df1e6956eb21e86ed930dea03ae506d696b587ca22f6b09bfb73de2b983e4ab645f7d149962da7fc7cc7982fc1891283ad9aaa32c0b3ac6d0f11b3f65bd219f35ad003c8473303befaca917a873ca72e6a5f5238718696ccddd31a690e9e28f675280707c42b7320a97b3633c4de16bd9fd0350b22116a917336d1e677c9ef56eedd6344ec59469fbd448005cc557ff9b9028206133717b16276bcaf895bd029af253186dab9b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
