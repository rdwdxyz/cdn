<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad49e7067dcda88696f91517f7d0f2ee08d4246d5a2653ce708c2d439a1f44c66cc53acb903c61d9e6e629d6c69a94ae63dde1c465577d9426555f01137b53af874256e29f0b509530508bf736734062bcca40fa1e7b6fd4e71eb99b2564a78de4e837b75f10b389cb2dc8b14a16f0797bec52a92d3c55529d3624b2b2162802f34fb5b5f22269398ab778a40cb74563e89bbe52e1d7e27e22718d92c5c205cc4530cc9ced9a981679eda9ee85ecbb91db4d88d70080b04f11b764449c80359eafa21aa33f961b2c6771b7f9a85bf7179ecca6f083a0cc1cda2c3d2d1b6b7b0642f24a4fc5cbcc1cd7b81fdd1a14ad13449190169ab9e523dbdf20d6c63bfab8bb24ed2f0662bbc977898afbb105e6de68fe3562d3552f93715cc1c706611137ad26506286a8c812f9a34ccbdbdc5e16eaba0523a8beac59f3771f03175a9a3c9acb2ca65b95c548e28175e0d68a355fe75695ccf5535a2f93b2c1ac607035eeccfbd416574afc9cfa8d684aa0e88006d139764864c10326d004b4ccca005165c5129bfabfcee360ddfb03e4e16eba076ac4e64b451d4c87da49a2a8dd7483e5a90e24362011e616222988f55244d6e307b54814623fbf0ed16d8e44985321bbdaa3ff569dc0368c60e7272b8d259a79cd1b51a5adb9bad5d33f9cf0533bc1f7986ee71731314cbd380ccf2bda58fcab990a01be9a356ed942f37fc8a3f4b24169cde101a5616dd19b6de06b4616ba5dff71f1236aecc60bc7a457ac3d8a568b2dc13f2d882489405080418ea9c827eeebd2c9971091bb3a60ac8203f9475021b94379e50db988b9d3c1ed456d7e0af451994801c71b4e65b6fbdae5beda62191e44b1a9b4c1df15e7651b0a2a098b02c85a42e979fd6034b36c11cf569a04296562f7e4778dd3a1704db6d4a7cbfcd7ade0b037f02e8f9f21ff41b21df3f0b92732d9b1c7888c72b012071dcc1ea97312ad8511225e41f450b82748805554d5216f4bc740c829f07e10f36e715fe12a7f4e39d3554fd0de2c349ee6947c1478606d4a3053b1066c95f389b567bac34fc0ae351d03fbc1b8ae755c622d29e9eef31483d7c37224869f6883ed34b942b52045eb0604141a48c28455f5b00687dfc4316d887c7f3be2b6cb895fac49dd74c239a093bc1bed1ca16843e8a872b3869bca967cfcedeb545df4186fde72c964b3a96fa8e9038b1894a9f71c66daae5860c79b56b3b7133771a2d404d71c804dc6b7f26b44fa17c7dfbc6ce0bb350e191ac220bd2afd69625a8e10e9fc31c1c49380e4c7c09f141a6856be8f262edfc975a651967b412a453257a088281402fcbf2c23fe0116c6ae7f19061aa7d3f5642bd3cde50771c19a00120e2b2bb3c10dd0f8f855098bc2c370085486ed337e6f05133eddc7cc4005210403179404196720b4fb3e8f1f0bb7bd9d1cebee48b0f9d620a4cfd8fb2f61eb49ffc61c8c59748275d992ab93d150a16e0989cebe66e5a590e2b32496566c08a8b548ffa3c83949717f1b721b5bd690d43677d4b611599944189b9d54a6750445f0b2f64be742f61784404c83627e9b4ed61b241f32617820ac4f77b037d52d32da7edeed6467505d8c8c8bc42979ba3a778f26f62a400a571824147a5a836b322fed83b248f278b65e861cafd25a6de2bc4a4bee32595b2caeb2a8ea79085f60092f85c59ad1d2b1ee7774b41418ba806d23da9707d68d1f41e8328b8b1e937b035d20dc3649d7046bba40888d131c44456d15cff2bc86251443c4b2c4d902bf54f65723983ccd32965b76745fd81e679904280cbe09d626050da982e6c963aead3a37a7bc30ecbd6ec32b5ce188dda76f54264fcc282df32aa054478ed86211abd09374fabce497908d366cb589766df9a732431281eafd36830962f2734c874ada30093f94b8e47d7d337dcda3238bd36e35e619eb239cf054f68d216c1a1d66dec974e7fecfb21c0a3df5979638e379bbfb6dad89f0a2c91068788c21a19769a4d372e9af0b0fe7e3c195639d1eec0176ad9df107a5e05ac3c40b790778a3729be2f7bda5d9949f51b07152454ad00c1e30ff53848e42e4a6d7df8f033fe6e1236c44ed577468ac3770e3369ac4ee13844416d5dd080b2fd72885f0df328cdac4513f948c4daa5c766aa33566985db6e73d46cf83cfc15b19ab5d9b55da99164890d3c0d5cf9bf971f0db76230d4a01dcb4105de27ffd3d1163f54b2474ed7ef74238911b24e583659014304065b3add63647f11f5f63612af1622cde96b4c1d3ceb63eec41d100b12fa52f792acc98c337e825ca0e6daca51b7c379a1d0fe1fb4e9a55b17cf033ec7cb4488f885aa129ff79d89eb958a740555447427288dd02445106ed4890ac5a98ab9b71d65708272b84b08a33a9aa61d2f049d4decbae2e7308e41d41bf052c08d0445758e58c51bc14c2c2abb0baae8611afa0f64280fe3ddce321e554a23ac3665c3a922a4605359b29d7021517ebe38c9696c6fee3d278126f5d56006ab866ebdd7e91521565ff6ec3eaef96ee3483fcac3fd4dbe845c0dd5cc61e0374425e428c51feac1e3128a73d758455c10d3212d49953ecad015981a704b70fc60402462705cd59496878100a8fc6086db81c39801cadfe76deda904abde75dc76e31a54d1941190df5178fc1201d92064159ca68a3a9e5cdb64a8d59206bcfaa4737258fccc89b731e802d9ae94f2b237120624af21192bebaccabaddcb1a33b28d1218c63ca6ebfb9c93daf9bf8a090be635571ae873cc9a05c54151fbd466e03129af6adb69ed9aa5f3b0ed400eae933811859a00ef01023759c1a66c4ba353d3644e2ec6b480693e6eb978b2455b1a3ece78484da1916e8f22dd3e9f13237a69d40cc25f3fc1c1e25f30f83efd0fed2af7ff90092466466d7d95ffcf9eb987cc8d202376ac9e14dfa103bd9669e213231429c93c97a5938f09f3c43708b07618391537f7fbc3897b9ac24fe0f6a9968863bcd05c4b8d47e11010fd6b8f75cdf67cb7ba967455e210fe366e2e62ab117bbb319addd2292592c2f310aad45e1c4c2b1800e57395a11651dcefd2b7a9fbdada2390574d7e5e2421b31bfcb69d32db8242356bda7cc5d74108356ecea57f080a69cd7e4d327b3d443311178dc357e87d1a4e26e9aeb0c691e2dd43798e1c0a59530a361e4e59ec90cce9fb0907544fabbb812656e0197c21e81317e831946738dd30833d9a698f20c911d50879b714a51df618f2eceef627420b3ac5751f853794d2e4babfb14cb30c37bda7f3a8202b836f4f80845afb040648ce5b50fc7464b8ad251de0c97fcfcb81bb2281d4468f95e51be33f892fc137732a963676f321e898df4e94b0af30c98e28c00d02aeeaa62b547c24d3630cfeb398e6f3d7c4a12702251dae0a900c2cb14bf8612664be5b278a6fbc841251e4720403423439804b93dfcf97e644df820948e9239fa7fa036c67edb386e4201a62882ad33b1e742cc3a429854b4bd12725fff461a06fc91f9c746871816e671d2774b02def48bea1d8d85a6088a4b71f143e954ab1b8883543db786246b2cd8682e8417f667c635157015c5af1151995ac5983e1468e339767cb68b14f534dab64b0103383a0cafffb8c83efbf6f659c1a0185e5b12de8796e5e5fac3ada2d0ebaca5451241c0b818987799fe49bc2c966ac12b0589d324465df9c7d89b1366665085ebc5bcd8ff2cf5ea2bb50ae37b69d3a91bd78ec4b2ed2bf503254c02ac3e6cb01923f350e6aa0532a1b8e01bace7c9470e3d87bbf3c22a44206221cb3a66e2697d921e218100f7bb0186fd25333c2e04f76f41d30a1bec165001bf817da5bf3b848b6d737cdc08854725f8cf3c26442149d8f501de92265663e8d4cc30c9275d44ae45f6bde78c54173ad167f34e5ef4408cd9f0da4edd35124ce7c95ca26380cb5a9bc21f1729f33c878643bed224374bf01cc7dfba00e33f7bbb72701060f559288a78b0f5f46873c641c239c7ddaf4677fa1f918188a8b19efd1ea80c5808968ae8cdbe338b2cebf70407dfd1ec2a9c57554fdf40fc3d6edd6fc6cd06fff50282a843a8c0e62435af7fb0435b8b8e178d58c9e835f7b812d8b5080314712df43683e72a2611d8639f9f56d480ce38aa2143dfe470711ee2dbf74c961b5db08972d270ce201f913d4cae78c2da5e68d583ac39f461e25717a498cbd8beec666ff6aa8fc9f4805860549e21c3266427b295bd494c40a0e840f854a4c5d6e61c17cde52f28eaba4015df51daa85785831908e54ac608b4fbec1d9545c957d609233e5e14ec5da5fa6e023a2e0b4f84a2bdbd0ebc4fe8049f14e85911a13f46dba3313aea079c4c8c1d4759b508d6fd755a564a3ebe3cfd5bd5fc77ec538e500e03b883d95e9fed43ff2869b443862b44b328fad6c0e35c0cc4902ac90123932d33ce486bde718abc2a002a49eea01b777e0f64df970f1474e075354cf5fe60470759152a812c7723f87761ef398feb9d7d4dbde029c9692f0289d17932d777c0e873e06f72b921d769cd831fec2ce58778b20044b04b9331c3e3b3d8e1edc449859f253174b54add4140bd0d4b8c4f8a1427b1821759b2a0593ecc44c74c68368701c4d19f9ab569804969050545a66bbdd61681cd79800377ed79ebd74627682be9b2703d570730f933052e20ebe0b22b05e151a850aba15e61cf95bfd60eb4c82f0f3ea5bcdcc56386f56a78eee6468608f42f6eeed1900325eb041709fc499d1389ba015c44ede082f3181fcebc794f7508e27465cc8be4edf100719d83a71af30dd791468007c4b5cafd9c2c90e8c899b842f72e77a496a71cca81454c814dfcaeaefdd9ad1ce056a43c1cbc3bb79b68d6f3ad92420f3e0d6e6a133baf4a9cc6d99f99ad854313a5ac73b30b7cbd920f5e8e9e3a4e556514ef58096cb7a2615e5a210610ba47210dec3bdca3ab60539c17084000bdbb31a0122b0b040de53d2b6f2efb4773908f1e59de841b78f5b217a47c409cf096489edd7f3eb2b0983057ae0705e8744ea2823d27eb257e13bea8e13ef45a64d7d56677272c2be79c3b1286ef879ef67837f6a4ed9180f20fdf3b66bc278d51b560fbcfcb49e745f591830db7eaf793583705127d15984326c80df4be90081965ace1bd1e45278080c6e5bfd68aa630ff7cf90c1ac75d891abcc47cc3716d5c1b1e17329999e56bc27b2f299dfaaae3a876bcafb032791a6811d1503c382b33c90983b2e03cc17875ab3beef4aae917173579b6f042fefa783fee8654c8da498617c27d00ee69f400f0054942fb51f6890476529cd5b24bccae100547d0ac30e9173974f0683f45ceea6eb9f7e345ff8f73a18d9844001977d4039376ce42a4b131fb2333888e9294f723781e308dde7ed14cea664298f0122ba4b04b81b167afff0d466bf175bdfa20346ac036f5ef33b51879101fb30e34472498f28f14679e173329800859f6c5b755386a3822ec01dead5c34985d69b01097f4b584b4beec0cf86ad5c849afb3b754004a3fccd56050bc268a69b0fd12f03a3b7873623cb75f76f077164e08474e5559c003e31bafc837917a03b266ded84b663343eea4701fb4f0256caf19b8a06c6198de6438993eed3817500f539340c5932b582e7814d8c3dcdddac96c89f4b94fc4693c46db42f4728bddad44813d11ec2ebfaafe311c0b2b03320f0c501d2b9cb65ccfdc6d77971902fbcd534a33477502601b5ca78200aebf076ea33c72dc565af211c5ea1c96c3d9f45ac40c24c7a9011ff9fb587a6648be436173e8df7a4fedcce17aed244fbc173ed59cb34b5e3d1fe8c7e6f70035e6c07dc9d17d9c3fa0103db73a291ff5873c45c3af067887638264dcf0f2ac86083cc5ac49cd999681eb3b6c5b7cc3cc330050a622aaebee30dbcb962368b8075d2901b5af8a71aa209998ef0724fc91673c48fc1ae165dca15e22d89b68618d18aa9b89a1d9a9f3ec277f90f25ec9c67b0c3e145c0e9a8a78a507893290d391a9d123de74b18933c669d8cf4f36ab6392e722c4c65bf3994f82a92c73e23ff48cdb8af793703945801cdde2ff3b230b772aa2335f2e8e43bf26d97a342e64455d119385a0da2c68be344dad5bd90e9172342e63ab8903600ff4ef04a09ee36391a80d81b60f16ed86925b4d3371dc923bc7a6a12e7c77addf482d862b7adfb73630f55d9f563a69288818081d46a058808d0bbcfcdc2f8ebad89954a912f44afa81c16749e77c7e311b25311b3a9756e4a586d734c3e658f407eedb43bd5a2d62729d56632344ccfc3bc8bd4531de2b8fd179d8784b44a970a3f83fe46e128c2f7ec2f7fb80d8da553b059ce531c278e58eb41bba4e0e183da4d2c66d250a532afc78eac41d34bfc936097eb9fc52fdf3bf66f0f33009006e256f796eaec68bc4d31d8af14cd38c4a09e934c146697640297b254419d52aad19ce3c7392d41cc8747203ab0778a9946d3f03312181829cee91d461d152e06c90e2ecaceeb94b471fe68d4d2cdb693141b6273497e214d992b80282656ef5f9247005c5a467a8811595464c799afd5451836285b96d4062ffc1ba45fad85fd8057b6b440937f7673391efd20a947c6e35de084e65e84ac56b9d7c0cb37fae77fc007bfd6a3f2694fe64540d9419aae27c75d0c0ba94ace567cc3e3b382d5e7e3fc2b66a32f62fad7baad744b6c7fefce1b0caa3ce5b4782b316f9a373b35aa8e00bf334da991583701c1b983b4d35b42ca75fbaf6364e60f796fe25f76c7209700f62b48b7191a931edb5948d78bc626ef8095cac62fb641b4cab1f7fd9c7549c51d427877301a31b7a992ed00e009167ede5dbda678a89dc8ae93312e031a332a374b04d28b1d74efc94fcae8acdcc9e132f3e3382850f7a5e2ff1bb37e1f1ed0f8728fa87b418547950321784f53f40ace9b0d4c6e90f66e6666091bfdd37e24159195cdd773bd5272c7ccdd18eae0960c7abcce37781846f3b4c0ea344097f72ad959868d70dcee5dd5802239c0acf2ef458b96a3b8fbf194892fe1ed69ead3f17d3d38086af1b46749c354d6295bed998db9bab62c8327a795f6b7876f9155063f455dc1d3be3cb86495f6b7ab9772b795b4ac382f78309fbf6b85b0751f1ac1e0ad8f96fd3ce61ea1fb20c841306b837efc03f39ce03d1a7ab33cd70236fe621f3c4abc4fc829290105874bf52c5fb0323a5727c730ea5d11e4a11f41b1f55681b661984ce35c47eb0c9627a3b55604f73684b1315867fd5afaa06046b1b7bf522989e55492ea7f2dfb75ff7c9977d7a41b024ea21cad21e1941c2403bb4ef464887ec531467e88dfef59e5df14205c5308f41d1bfc79a5776eff0bce88d25d52c9d434bb313bb93fa21e228c04da7f12403d12a84fdd91d50eeaf8e617e2759425020e53fbfc3f1003415a588fd785f7a6f850b031357204297548ffbc10d8f023c61e5db72e4cc3770d97817d1adc2050cf69dad193d7d766094e9119f01bd79a4c1a9f9a45d1265a8f85c2f68f27afafb4285487b5477e2f913e3526d25d8abea6f891fe3591d08d57464b6fc1e6c51a1129ee509a2419769298d4d9318957e9b9b2584ba0952cb281a53572907b14b784631a8e19e2f9a60bf1e7836877ef1dd09232b48e0fa7543f55c02cdaa81c2926b1cda81aa15ac850b1d735e511285551ec66b6124bcc11703ad485782f92128b84adf68dfedb6322287e0a8a7e7ae0d0a7a5a1b1f173223157274cbc8bc6e30c0452e088ef4aaffb7efdac842e862286dcdd42e5d0de1afa0ba51824e60dcaa18e19de98bd20c932f6fa9048ddd4fbdaeae47c2bf9a4b05f742e0f5e2bfb537feaf7199e09c75a7b1f2b92418bb6ac7383144efa846ce484b381c186463663ea96be6d1175ba0d02275984eb0f0b8e5937ce08ef99155209640b5a82aa121863ae310a66e78479d61bd73ff98d90098a205291291851d523402e6ce93f65f0b961ff65cded6d6edcc60142ba49010eb3c5d6a083f38e1890721591fd36f744e74fd2341a171e32525ea9aad36f136344ad65be4110196dcfc4529210abc3cecc249cfc60f5eb0b397fd4458611543bc448ebce05fc07e15fa0ebd3a6cbb5efd7d80c2398d04955ee65fb0e402893753bb5d4ce73d5b169a8c724ce03379e906dafe1fdd7994cdd81faa5c3bada12cdb9393520ac5bc7f749e18cd26d3ae76073602c1954ce27890b5278639d76a1e79ffca2dfb1ba7dd498403275a25eb3ad952e99c196c921e15cf34292c450a48e15e6df989c091126c83b881bfbd3ffafe6a802599c6033487750060d62c3388e161fa036379b67e81674ba58a1529843d9d4d05884f5248a850d6e4939f9eccb91c8859b8b9de9782ef310538e3151c1beee66ca72dd2b5cac4e808ff34d96f5e183ec5ce38dbe24c8c4517ba709da582ed86ad99c8559750c477cbf9570da763d333d70eae795c748cedd0227578d668206c703759cadf8ef649af0506a31b615bc93537d89dc21f4de8fbfacb730e19e7807483d09ee9cf075f14e5976f2aded93b1cee86b2457e61c3dd8bd690fcc1b22dbcd2168149ca85a12b2d8731bc4240ad8034a9e5aa30076d6014fef05969994ba1d0d3b54869bc977313c1b0d43b1b89a29e233550b2f18dee0553e89e876e16ce035e727081d3e91d8eb7d5d4e8ce71db84862423368a5929f19c8614ac49d19e4b092d04ae5c63266459f6ab110456d959802cc9be853f5cfcf36146ea5e8db2cc54578dfffb9d1c6479e2e249523bfb2277dcd9c0157e41e46ff2226242e1d83a918995fe8a7c85f1b5e16e7af280740ce7dc95f3ee351305f8b13a61733d7aca28aa389a5fede936a6c2fab85dbc3709c4daeee8ad067d0a6f90d7d0a913834b1470a995cc50dc6fe28f22bed92d65189877e2ee9a49e55cd35dfd0bc54013e01251d07788603cb46f99c828ed27f9bd95a38b1fcc2763341ccf4ae4cc024adff7c9a53031a3dee0675c57d6c936ea9fa62ec88857beec970c71788c02bd71c759c3c175c11a97b8151aa0f0ce30b0651dd9a7cbab9a73dee96709812eaf0843584d051005e7a44f56102353170cd3d03d867246c6c1dd29913518278633e0f5740b86b270633101ca6bffda0e6cc9451b786156c4e2dd968c6a9a5dd520844b52fa3a12b68564b8dca22508056088ad1aede9760a52fe8bb3984a9a386fb16d87765b57988c54e3ee5394b5890ce15559d248436446005791a329f9a64a122092284a0e534223bd0eb4441eb57b13f7cad750af5bb200f1ce5cbb460da7ed065efd4ec15e86525aec96093b435084294b086ab9dcffcdb9c45ea1cd085803dd5c424e3d47220ec00e0f0e48203d434db91d123dba56840e0fc0e087f9c7a7397c05463e8dc32fab7c6b25a5432c34fe6b1a1e6969fe892a1a1772d9a8f17213fcac84a190a70bf24277448c56523f1a4d36d60bff15208f214196ecbf3ded8e7662a2ed74578ea7e2960b9ce6555432ccf7ad030a05db5da59ca8676ca3bcecaa162efeb32ba334bfd6f83401609b8b6985a4dace247c649426f800cae8945585cc43583723eab306f6bb3aac9c9e6fc18acb482325f7b0573ee07ca559a60bf903535142c8b9e964839be54800058408d35e6341cbdb0ea970ed12fb7d24d4cd69b8d3b1b6bc063a47b90164bb5694d39ece9b9d81df838502d30e6253b4a096cdde445349d610b858fa0201db065bc0ebb69b0802add385c7d6a6f0ae8a939916eb5fb548cfa9814932dafafae8a176a0915ea6daee6ad1eff55a09d051d2a3c55aafd6a5ff22e6c615cc6608f7c657743ed302a923e3c5d42fb5b69c4d088a1813622d12a9ff7133c0d8015e5a73d1633fd2996b3b605b9b82775fec9443a9ac1ae0b31717680997f194a64afbc8c83109a7a2ced81056934fbe0705043c773829885ae2c56c14725ebb8d058ea3d69c916a979c1086fb524c9f8bac1fe98fde10d597307fe44129996ce0b07f522afdc84791e11d1e5a233281795beb7fe0b4571258d368bf8c37834ff0968ea64cf2934c43116e4ce38ee3b2f60f934c4114965f5c5f9ffb2e22647f2356e285d6defe83b57897786b355850db300064180d9edf0d89b63cc7e67bf1b95eea818a4adf3d132c6e8929289baecfbc6713dfe59929e9075309cdf137d1966a7343b941776caaf94187d4105d923231b4125320ffa587045088b951bdc211dd2e7a2357558bae9cf2b415307013f48ca4cdad9f54097a01c46b8b40cbc40042d5596e2c107fcedcb8445278facae8d82a6003c800eaf7adc27ce966dc9aa947f94d099bc18f01ad61c834583d8453dc39148ed1d52c2e67a7d1d8c3a5b9955917e46b2fb8fce2d68248fbc918383f27f11d799dbd2cc8c47b1deee1b4b5044c76bdf187c497126d765bc6dedde7fd09883fc1c11ab09c23cb76bdf7eed90ca349d5b1471a03d8c15ea5a5ba4139397e07b413b216c56875232a3a1d3ff9733ed3d2f39e377c8a7a1793676c8660a24f50e5aa916f46c1402ad3005a6662521890dddd066413957cd57262b3bc94753f29e582b1efbe3d493506f3554ff5eb235e1da597ed5f11041c6f4e9f3be35693279db9a8489077414eadc608c530283ef347b2c2020bfeee65757fdf1c46401813ab61e22121384c15dba485ba282dc68b52f59fffb3bd2ba5c0950d5e85d98be8b8fde0265a648c8a9216810f81e9f1d0b4c61f77e97a2b1ea4326fce32c552db75d25d2f738d88a1ed04047a92e502164777a88fb86f2dd928e5a1b02237c92453d9382084e29e716d64938cbdb3d233fa27910535d766c318cfd0e512d1ba5c2d3977e2fd919d822fcbd2ca14252611913addca6870ddb8d0888c62c5f690f37a14cf0a160565ad0e1288a6451debf0302c3526444fe3abe27d40dba879f5905c4e7a44d8b9cb2cb5dce882da89b031a7c7005adc71f63f6019c04906a392664a3c00964f3f4e91bb557647ccaed418264659f824b6852489913d05e633939a3193ebcfd5da3d1118f416b9afce355f137dc716a6f0efebfebfb19979542dde6e9f2cd4b2ebec3d178211f193a52aae1a137ef6cd7c9e3fa9f6dff1224dc1957d25d4102858c576d27954b8e4eada2d00779976de4023d494011f482a74a4ed9d4151a5215eaf6681466bfe501185bee437f5e2f7e62abf88497480db9009888261e8fc40dadd78da0b822d34d98c8d7eaa8184725f35239126e8596d1d119b86d891aa1fe96f4bafd290ba646a5c44e114b67abdc80b20e1005e2aa2cee45c97382b4601e74a14aff93d6536b9a9eabf34dc584698353df2aaa5bfd6dd83ccf1ef014ee052fef59ad07cba047359e486510bd088914e7bc0d8a7ed5bc4f52b8b2260476b99ea2227135949ea9b4043d42a60f5c6aa308c40dc55cf87b85f002a2a8c456714609c56d0f82158ca58de818ccd5e55f1553dcff8191762c93d0a68968043ddccd70df2b67afe35685425520978e4261937f0a6a47ab434bbd16ac824a2b5d41183f610fbca061c38e4ac2f5b42dedba99e296d0d4e840b09e71f1d217e458f2a565bc1e6ec57b1f4442a409cf8fa580ba5db114f0e4f0d8ea84ea65bd8629f70f10ff5a04c1279f89386dc25eef760ab4e2b22ca449e1d78664e244e5a03a3a2c195139c1e6479282256112e3654ea3956585a788270d104dd3c882131989e6982da21993d24b5ef55dfa36c31f3e7db6a47d7c5dafbcd1e25bc289562c1f4e4621ef2ea184341ce9e3d1dccdee84a844814813dbf8b785f62d6f15842f5be7a549f4f7a65d5782592104e22dca2ae013d1dc87232a6115b2759536fd7e3b5d5e2c05afc2002f614654a69d481ae4d0e9801c60dd5fb3f045adcb1e221d573c1d31315506c36112b90d890177cfa0daf6d403e79677fe9931cb5c8c1f7c34db8bffb73d8bad149d587ec8da30f98c626c1a643e815147323f3aa2b0b6edd295c9a66b4acd08e4edbe39c7d0d9b658d71839cfed3a0fd9c7013e4a6d5f129da859db40599af6339d3f11f13907b282e9b0627766a1acea7eb14cd2ce557d2af314d83169e46f7628c9986b3a83bfb80915c4915c260c7205461836dbcb797ddfa514798d4b75457f6ed5b05fe686aaae6b5f8459067b7374bad51116a41c71314407334b747a4ece823f13eac82107087d1535564567747a86a76bc69d5936ad6010fa12840589c1f9313552273f675243eb062b9645669cecc010a1719910db4629a5fc6a1641387a1ff6cfa0dde37526fb1c263f347fa30841b7f17019ca87f2e28bd897f037c801018ce8f67912d397d2d2bea0511b80aa98fd9247310534a90fd12bd47dd90a406ddde2f9319ed0f59d15a6001d4752a3f0050c34de9e1f0955d467943522c1f59faa0df5c66842c30355497dfd69eff7cb93d1bcea0cad1b43279ded35f426738240e18675c9364a2d104b3d116a7ccd71921246dd4cb01e55fb41b4040d7087454b6f9ec83bad08a272eccbbf8962999239d04ba453af0761aa3321129307d6318a86e005fca3c9a0ebbf8a0b14992017b36eddfad907492a1de57b15383f896bd99ae6c87f24d8e49857e54ccc460bdb3cd1cb607a08b6c8172cf9b403e22c45694334fd3fe8108c683c9f8aeb8eb66b349be457b82affb6bc754261019f66f12da94da5160cf722408e8b8b5137e34c19999e532800abcd5c604fdd566577c0d4d206e16ac1238b9ec812e6f9b871eae8774b92b431e33796c8673148dc95ea3ea4b46d81755ba21df965806864ac510f919245ea2bf1be42c287f46deeea912f9cb3c8eee6e63e7ebe667377362f3e48144e880c0cd3b3f0858e751d2e615bd1689739235b03eb2ba684c518db6678e13cdcd80234f097b8bccbe9a73aa359897406189fc2f3af281fbb5c0aeebe8fbe88c09241b386725982844ce1ce8b5bffd03cfc4a78c1789e1c0d34a430b5581b3d2dda86fbab39a4b4cc480999fbf1e7cb16348f56f07396461e9c48298ec1cbf9bd8707b6d7a1a5eebc3bb80e9493eb18d7ffb72e9defe09ae1b6d612892295c2a356e5bc40f9721a53efd5d1f3e5a45da088b44a1e4fd41c410606856d1aa739f2701145071aa4f62c986a5357c2d6476391ef727db275cade164b053ef82de45b217a0ca79e65d6769c856e07278877dc249c7f6389ff932f813e8490880f4b1617a4cbc25777f640e1318af5de24850b4aa82d8c709d236f5e567a0905b177d6ff211a149012b7ab2c6a4f3a4f7c4a9da5b566c8e59227f85a9ebb6f35526453a398977bb01f40d59102d759dbd4910b2db2ec246b3d4d1b1b78ec4b2e0a670fb27d704a8821f1296b10d3e7bdf16de6b1f9c54f66856f7ca195b27aa6dcfebd4f4b182449da51d233704a6a721f265f8c0af2e2959a5eb66c8c6636285c5006b43ad713c82a393ced5dbbe3a6162e929b5b05cad30f6b008b60d882c5c00aecb058ae4bb7eb37ab22d9b6df124facdb18299c77cc8f5ef0f181a1e620231a4ea9671444a3eff4bf409eabcc13f6410cf68c39130948384b67e0556bb2bda244d8d2e9805601c7fe8772473f267780df0f17b5891fafd1f0b8017f414ff23124b8af7ac935064b6c281d43ca7db907e7ebb710b4e6268686dbbecc9380627692d91d63961a479c6e3161c217522046f6f2836e10e81fc8e1924476ad19ffc2b04d7cd3e6fd3caa4569148a1c507ca3bffd020a7d25a15e6bfd5ddd4f4ac0200395292d45e239d979845ef6614625c9f18d2489c96537b208d6044dd9794d1989c4a86d526f5e5d31aebbf4f2a7490634cf9e518057e978c7fad59f1f683e31ea70858fd22ef249876b720884e0f8b13bf5aba5b7a66a543df531c575796ecd36cf926a716b17329b0c3f15fc100a0090b794f68f89489db3f6bafa4eb6a8418706a9df96e7d0fab371189c56bcdbcb17dfd64bebc14c8e4e187466c961e1a560cec8cfdd0fca7420b15abe82fc27aa1a265b6dbc696203656085b529872ed9ccc2f1bd4d3dff59336f9d9be7bd52c5eba91edb034700b626dc3e5f19387c3e58e9ecd79b65a0afaf663db72c62c7b7ee5f7983ccdb8784575131e114bef5a5b6d516f8e9c5ae931f83448e3d0ac580121f9170d471cd254fb5bdd56dae25351f66ec96c9ff6d41c41d8f59dc75389dd19cf8a60096e9a164f4de720141c206c555fa7cd9bfac864b93ac0f15abf977db2741dc373f325431f04292615284da81da11bd5fd7bf063aedd8eb7147db0049886ff4c829edccf9a7a3fbaa7e485b8013fe57a7b9511ded6ab858d9951750760b3f097bff965a6e01c37bdc976c40cb91f66a8314e3d6655eb4c00faea7eee06ada9daea900cd1d4f2dda932829d613df5485c33bf5b82b3dec434fd033a6d72fa2baf3c2729df540fbc920a3db919230dc7a03705f91f7bb5b9f9716286367199e9e93dbf537c456aee8f239755bfc7bdbf8215d662a04dff4900adb2e31ab243aafa3d94abf60ea9f95188e9d8c6707d96cc1a0dcd1aecc18afe9d684495d3fea43b19f87dc61539bb2f75c57a43ae0e93c9c7da701c08e8861f466bd4a310ce07356316c62e54330bb76dc2cb549297a9e0f715322f9720f741d42ebcee3ed44b3b45f2af8daaf8de67e3082e926d662960c3cb4ec20efbc6f8c751521a33759f87c77ecdadbaed843eabf86c3535d04ae05aec638d65eb871708805e0f586e6b50fee3e90032ce0f812eb52f912e19857a41e25f7cb830115b38069c4a2b3a7ce213cb1dd0e9485b403cfe9c474aee07b13c34d68c7e55876cf915ab433cc794c63bd76c010c3169e98e5226f8e31071303c264ba93f11d4285babad37306a474663b290723d8a6e82491965c982875d4aca3a18c955e267904d29d496fa818a4558d3cbe8fb7be7d45638e8df39ce0b26fd3f2c00cb99f4c9dec5691c4af4fa3ddd08e8e6e3a113afd7bdff4282f84c4cbbb0de61511099f538648f9d1e3a8ae6fae35c9ccbb06bb0daf37dec771756aa89a5241ee3c5ba1876a66fe895ed02c4d3c748b67d1e34448755cdda9b004f0e167023b6e5ecbcf4751535b47b4ecda37509f9cfb1aff68c0f4cace2af2e350af2977752110dc502b3d6b419079c00450ac6b377db841850773507b673c3563bcfab96a20caa82e63fc026f0bff481ab14e122cc58fa0d7fbfb3d9a3a5bcb6e33f990824e9024080690f46581ad21fd4392a085da65a39297d926538f39464f5095222e9f1c46d3a56a07ff66bf9fd9bc2f7328bf2119b8942679b470dceb8769a1f8300cfea640b7c2d2b8f4e0377db66951dae469ac9dbebcc289b4dd9a2a51d49e062877d428c0cb780efe5f638792e687ccb6b5acdac94f064ae5cf85cbf2c925b1fcddf603ee076850c6feb57694a8c257332d6e11bfe37dba593349ec734ccdb3e1fb3c065c22174e069bcf82c5c366926ca4be8270dd003ff6c5adfd962320b2d5f838091fe1a9707b3141b24dfe18343d42921e18e85242d74a76bf1c3ee36d94fb1266d157b8b9b036a2b39d52c7680dfbd6bdd4b71d0dfceb1b6c5521dbc71e693ed52a8fd60d90c9079c3a6091348c6d604f5a74a8d71bffcb3be037c6311489c2b0c377e609229304e9c41100cc4257aaa1f99b34092662e58cc7a0b07128b4cf7cc175ae2cd54b6d598a63e39ca2e48ebf76a6ff4ead82992e58ca778230bbb28c8ada4495e561bd1e80f61c87bf071f7527766980aee21b8a54780fda387c10fd7750f6ff29f848165827ec767b5df6aa37187bc40824ec476ddf1f116934b640c379698c1c2f4f31d068ef647bf0fa8bd1d6d382cf35bf09bf2ad77bb62a03a7a1e31a7c1f36357e64f1b87da20c520deda53702225daca228e28315aead2b07ad83c6158039a7e35f8658c892a1bf8c9f8144c02c826d8ce3d80782504bf2b89fa82bdc044c9b4605c178a5b85b3690edcd7cf4b5b7d7b9c0adb8e334b07d2671fa2a3b6c0aaee50ac9f244b5c489b18c9b74d5dc1f4f03a224b4dd98c24065081693660dd5b394ad5bdc70146c9340b5c5e5ce435232faca60a2117fe4d0548d9970dfe60cce6c482510e93c3103ec5511487256c2986182bdf8eca5967dc6c9e0cb310c4ade9b74a8f8a6c992600775ee9571d03d27380ab10dc60838f611841131d063b7facd7029ec6bea4b39a8270fd2b192e27eba3a9907dd0c3db69c2dee119914ce0a4f5dd24ea9bb4d05abb7b5e61b916a55d1d2dea12fe2cf90eb454e400a5d35030c15747674305f40bd91af68c6579945a45d1ccbb02bb9102c57c6acd6ba4b0e83b905c67839b8fba8107d4fcb2e5aaa8f8f3ef8b07f0859af1d8e95c2aa192b98960942166adbbdaa35352186e07f3bfebad9d677ad75a02b7f6244188f66c533b3cf67322c74e0233e00aabdc7f4ed4bc8325c9f9961eb371cb5ac8399639edfc5e1f3312a37aabf0ff4d7b69605d71f764dd4f51d385d5bfddaeeb2c8c5473da2f4996a243709252755f90e7bea6f8692b49367922fc4948cb8a75b0b163b46c758e15a9aef37af6001f00e2e50b9249e5065126a90912247f707c5c7a17c1e6fdefda924205b44f0060c3009b75deef37b3b804c66b1eb92dc0a8622cb2e9ceda08f58c6718dc8425b9b2432f88ed06f80a5e4d6c353ba6754fc8dbe2b6f0f03a7046c5bd6466c52ecd85f01cb3743a6a29214979f9db9adee3ebb4e1c0a3d60f7f79e09c208582bc49c1cc74283fa9d0871e7a6363e3118ffacda4a9558906dd0f8f1746f9461007d3441bc6d93dee5037ca10ae1bf7383afdce48826194f08b139613dea8be7eea2de6397bffd8354af744b17b02fa616f92bf513f6915a73a795e88fcd53c781bf13b2d3c471c874f86692eaf0776491a3f510faa0f0fc0356bf26dcdbf95f2f139471decee718ed08d2de214d72dd0da320ebc8760ab225fa55698d3534f98a5e0e2b8c9003688d482f7b73bbc1d2a207ee996c6ea2771e3cee2c1d7b0ea0fc68b30d930eb08efd38aebd59022c2d815130a657f6c50d18f300848924bbf3194fc98b319f2b92a2de8cb816e004e0770238a1748be8d11c070afd31990c37f5e348485664fc967d236f77782535a9131ad09d173afa8d1f0b367def7286245195a150820c7712346658cebae2f52d65388f6113cda4fa818870567560ecc9921b45f012ac914141c4679d4c40f4246dea3e9d0fe1fd0d89d80b2f6905454f9f603a4e9d9a1d05a6e53ecf8dbf934a925213505cc05efe09d6c6513df31286b7e38f532113fe88ecb6c74e039775ceab3ac5c575d7a8795df8fca118ea15afe627c3541fc867c2b0b39c094ba3c609c81ef6410d2fa7302028e86c1b5e36bbe11fa219760b837e233d936faf5ed308249ff80efd37044dbd85831072116a166f2233ba8aa09ebf09e266469137b1cdcecf125c0ac89a8b7ba722e18c438295d821c69534045492d78fd9e8b71e6d142dbac56b2f4d359d87d61d796204251f82130932e2ed29fe32664a2094786c4b4342c50a7af9810534528a5c732905f298ed176af478bab9430a80527e21cd39b26d14e80447f9737329ca67b8961f0c0cdbac3ea5e97163554a3f77f79fb3b9bc78a89ae6f0afe32a4e07cb368997ea32172cbf8389f32be7a61a9e29e205107680b51a9d5ec382e1b8c59e668e4400b666ca27af620693656dc812b808149a9b7e24733a5758521596b4fc85d1a57553c765827b338233ba75b29dfa1f61b11f3a725989843790b0559e8c03c20a959c41ac174277a430463830a30d415662d12ea9d231d4b3bbc6e98158d8994f7aeef5c355df0ec47ab3ae5377af8030f93eded953fa1c75a849c306ef83560731f936815614f752b84414d33002767f7184bf17c4e3bf6f2c6583e2e6d665d088e71f3ee68be2f9d21f665e05ac749e30d4e4c5d1cf04692710bfbcd2af327cc1b1df1f795e98fdaf11a18ee03ad739fe341e6684539c0ce2890fe755c77fcdc47adc57cc18cad9e8c8ae7ae7fd7ffb07505a60715dfa9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
