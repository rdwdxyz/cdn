<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c08ab1e1a3f5a23f6e7e2ba0274b88603f91fdeae90364e298dae9852011c329e0df499ca3fd77a6cd5065da7b59202300acc8625e7f2c20bd233fabced7106d266a839ac523279ad625772adaa85e3460b2f23d868a4f28aa74d14fe7696dc3dce70922d69edb917f3268fa5c06c52516e80cadbe00ebe64f90cc293cd5e4aaae4bb2d5a4f4d18a7ec75f3d05136c4adb10a79a8ff0352bd7e74da5d70255990526d9312b61ae9639bf446e1f43e781f461b8c8a9929f11c3d6285a12d2d3fbe06e3f58b48cb86b4129945c1087b02af91bb49aa32f3b37d1c7b627d67f9ee13dcb95968ac12ff6d982ac053c0f5b0240ebdf1a2eb8243a3660886bf531580da9dcd37b12605cc7f59d7dab7b33ed6d994c60145a919d46c97096bd77a625e33e5b2d46380cf9397f573a29e99f3b451c9b977e2adba7b5cecc1909eed1001355fec87ec484034b82ed563a556eaaeaa1ed1520fa82da5b8d9957cfd5bd97035ec90e3ad5dcac9e80deadb0bb1d241e44bac1a017d4a80b1b2f53531f1c3b6116e4c7ee6bd6d26e67a8603d11f3e7043f8178a1cb090c0dd4cd9bf642b0c46469072784b384f8da03a17f2d56b923bbd68325f6f68920d2c376bb1eb0c484ca9dad3c030a8f052b7f123da912a12cd473e336878901121cc1f5bc7894fc8fe1b85ea953353c1f7f7403fd2dfd04107952f96628e04efbaa694251d02103a2fc7d85c7fd67f7ddaa00c72db703b168ba53180dc2db3dbacba6140e06f47a566c4a3350390c26c0a47935c1263bb5680b838ca3c85aa059e8a2fe70d7c728bae668e5bd9f62649dd7fa8dbf76b60ca86e56c8d67d57e088c9c4f8cfd2995ed7d470eba4d9c8fa48b67ac9331dc9b4d71a9d1309a127f2bc44de52cead30927bb7d20063730ba513b04e66511615ac6049d2bff96e0a43b58ca9a106dcb4bcbe59bc6a00f5d867bb32bf41f2f7019ad69f57e86e3a33b0b52c3fec5b4ceafc43445b79d9b66fb71ece5e14109f0f472609244e004368cdb22e5c8a7e9a245a179217fb588e83fe17442f337f56403209b499fc1207705989f89d916435c08203887f51b4e75840bf3989ffcaf609afc66c07c9dfd2043f92c8b8444ead3c2344f78259d622bff452ed7ead7113a85ef9de5c310b6f8d593085c1b1ddbc44b5066e0f104cc2c79841128a37e329d2f60c915c55842cc145c70f6085525efc833c43e29ec3a7df4fc39cf6cc61e7cace610f04448d081063e7cda51e00bfeefbb881dc0364a9d0b862e41708f8af36f75b5581c7302aaf7c1d340a225a7cea7827f924bdd599623a5b9944b73e516059a94605f99d8af961a19c8e8232b6afb9238850a57e01acfb49479d17d254071f59f491002d37a243a7e7ea6ac9bc8012db79559fe72c48b0ccef34f361e52b4defbfc803e0c894eb7461c9c58f4776644fb25aedf5db5336362eaa997b0be8660e12f6607752459f8a6ce1c4eb6286284c499412276914d48ba375b739f15621e33ccce9b4be0a16c0cd7161039921859c8d08a2d90d0385c58a22f62c98d6aa759e566a79e34a00428ca6d2872a2f5d9a287f426afb99694d709e32f6ee274442d2f75c89944c63e8afb0773282f36c57cbf37b756c28191ad67f0cbd8f26218202090c837da7b4a79d6cf66163efb718da3d41ef826089a08a6ffbd6fdf475149f9e100054ef759a5a3ba3cddd519f16afcc661df609648f58fc9661caa36782b6b3f35b86a5a6ec1dafebb22a8e5c4b45959806196258c6312b59516950c4bdd7585ccd3c3358e4bd382fb7e5f32ecfa02f7fe0777750cd6f14967452c724cc14de707700ca181725f4caf95ae6709d453263b2b9e1c7263842124b8b95a8601e07e4dc2f9d931e99e34c778bd9c8ca28bb2579fd4f9753121fcf861a1e2721a720bbd9cd5e4c162d72d5b1fc0bac9bd9fcde42d5c0909a0748c43affcf5f0890426303e3fa1ea9b2f44440933d418fa377ae5fd2f62830f4a63dd40da46d5c0312e6244f4dffa1553de2aa03a45aa4eb2dc636c31cec78883ef999cd0ce3fde5ca73522d36f3c61bb8de15a0b6f15d37589823ac98079222feab694c5dced61c68888f5624e8a7cd6249a54da94a705605e19b54af46389a69fce823e96febb711828abedecace731ebf92edb9690930b7867c87814faaf39bf97618727c1f1fc200b110befb6b573063afc9d19a62297ecf508ccc0328dd655c8f05ae36d8006b76f7c2598a21fab68b6d17bb76524cf8b652fec1c37377f963a6160506498515377d34a1af73b97d6e84449392f84138948d3f50d3a0329da53aca790197cc264ac00959335af3d227d46b3475e644e477e588d3c8d6fe932e8132966c412773100ab3d96c7fd71521674fe881321e4d06edd0cb5bf382b9f83a0e183dd8ccf132b89c71a5699ed5ae5bfc0a174448f9f5f21e5ea58bdaf386d8ebdc4d2661dc6af8c81f1386cb48394c22fe6ef2534547b5595a4da589fd23b8b664b64c15da1500111c5ffd3cad9ec684fcb396a9b583a8e798c26dcc23275f6b8334aecf6e249a4fad03c066efc8a44dd5e7a8810c0c62d7f5bcfcac74535c39c07487ec0eec7fc656b6e598635d15c6b8340f962bb55703f76549fa5ff0aef115077bcaeae4bcc90acca7eec51922d31bb50f21bb7b183d558aeda83db7ac8235ffb5a7fa2bded8a86a749e201f1626bc25676b528afcf6944a9350be54768989f439f62d47f048219757382e7dd5144c144b86a92981dd9cb3f866eca47a1259df54a7868af62534c5397e6646f79b19af63ced60ec0be87d87379bafbf40365a5a1d0fc51b88f3e3bfa0d48fa8b4fc836614cac950639b9b0d2d5a42e08e8ccab52e5c0da347871ba66de6e5096ba914e71a7a5d40dd90db88bf3bd74faaff93d0b0c14bf11994d882e20179c8879739348e84701caa9d4418a5446818e03f41d3827409326b46001e2f38cd6b6d96ae6f19e8f3932e87407f13955af090cce5a3e95b3e798015dd313658247fa25ded53339ee2478838e67d9c78d84400f6a1f4e6aa0839c36944084c2dff96e3a0baabc8f2067b33145dca919466e4a8780fefc9d7ebb39c706d0eb5bd27a982596038328bc1447f8388101645df19d30d7ecdcb5f2ea65f0f117722f98a3ac528adfa66ef56b729980c92f8ce3722c855ea31ec76afe9a985e1fd5d561b4066af457b1aaa2165afe6d8aca9fc0ec2a3afe0147441652898b43bc5cf59a1a759e3e36755957afe2198af1193980c6defa461a1aebc38815d5d6a182198ea5145bd5af3ae5812cb9c47a260e2d08589f216b2145fb78e76d739e5c78dd2a20557cea82b0c1c20c5e92a845b31a4e73df6c17ced57cf605b91ce930af6fc884b6e262c0af8f689fa8fe6f864ff0370403b5f0e318840dc457a871380079ef5734674b043143d6186c9ba10c194a933275f9539e00ac3ec86ba84a80374229f84141d7c3462abc59c262345a59d1fabf46cc45665d572754090735f8515327bbd11f28a906ae141567f30ecd995f61ae6a451038535638ad58260ebed824fc529faddf3a0275a81020e0565827855629897a847b74ec5ad268d1b4ce57dcddcd2453114384b36dbbc32ae029a8da93443774dec08e6eeddf6cb0174cca10573cab03e07544591d7e3cdf9d193d5d83372df8fd25370475eaa57c912d13dc3fbfe630ef86d7165ea9fee59b8be1dd39fcd545b69a21d71e97318611b935ac3ddb8ce0609866728fd5bba8236a1dfe2e2fe5a32b5d10f7690f268c04e19e0cd09061290fc145bfa8b47b643bd262380fff0a63191849db11c16a3776330adef823882021c93e46f4c7c20c9d363735755ac2dbeb7d0e4bc1d4950adf01d8d638439c2d48487a3d5a1e4a771ecd65fc8bc843ccb88989834a3815c69754bd438025e2bce02bc9a3b0136285a44736c333669f5643a91a1237b10ce7946bd413faee83e4f86954187aed82125c4f19f707a57b7345b9f244815aba39c9503805fd353b50134e9e235e7dc362af3d04a419f9029cf9db2ad1dd0f3a6f0b4d1ccdce6673f3a862883343249f9aad0634bf0c16e243d214e15bb3300df5a5f235bddc2362780366a4b47f096dad3cf9c8ce7b4dde391da27e53d9a6f0321d87628c199d87331f29995572fd97788882439a26fd8f74c0c20d65c1737ea889466e0bda07e8da1ed1d4883c1f9a92865c52f0c33daa99fa83d0e52e05cd1ffe6b92c03069c124a79ea098a32ccbf03a25b9dbf925497772ffcf01dc5c7ab47ff0164527614963bc33a7c0fb33a92d82180028a5e27d2330cbf634e3ac2a37b87d697a982d7734b16f135f6a2c3284d1e4ef2132ed91a96637fd889c05f528a1f68b57dd7a656e8327610e359e4a7ddd0809fc33b1a01cfb5c83d63cc3b28216972cae37b0094bc64b1d805646ca46c31cc542a0015ee8214ce58c15927a69c403081be0e1162d3cadd34cbba21e2f7b0007a8f29ae3a7df4ac667fceb3db85fb7e6bd193e4a0c1f4fd4b334ed0424970934631df13dd12157ca71d516a0d64b3c4db34f15b2ffa8f43160709bcc942e7feaf70eee6b6dc05340f2575a01f39310a513f8cc8118b499c5fcc85125ef1f8f748fd7e6f2346f511b0727b675fc7492bcd1e5801f06e773ad768ab8a75d229522b4b61090e8ca7df0d1989dc3ea3b09f576ff279824f4e130666e30b8ad2f8916edfb31218f86693f3b095315202d846ebf7a33b7b25b39d48a32ca9c3c99967838d00327236e284c3138bfdf5b8a1dfa9acdd3114b1f834be21a6b4b51aeae98d91f05c9b46126c60b78d7df8feefc56e22c572fefc7398e9b1ad5706ec7848b7d04a6a884ffb755f83e506e1e2b205d45eacfcf31e7df6549819a8b3034dcca5790a48c4dc7da55a1b8c8f18926ebab5d80327441107a04c40b656b9ffcc3c0cd0acd93799f61a6e5887cf40562766e5fcf06ae6f8eb48e62f5e908b14e35f50ca6236045f60f410cb8fbc5700743a37fe586a0fd208f5a384371a1cfa1565cff80e1dcbc63af678c040ed5954c34096fa756742621fae6f4786b757eb8523910505be2f374684b91a9459dfca2aafd30997e7f82d8b242ae37db03d4ff4aead1e2ef388636021487f9fb7d783887dd0ddfa2f3fa0b176ca8562b4f5ce96ca988a21df3bca2931b90e17bcd968b52878b5e47059accef889d17846f2c5e746f8ecb78578651bf10c73fd27560e149f0b45b5098ecdcdc8aea8cb72e35c92fdebf3831aefb867fa83a87b43d78fe1e6182b9276075c2f64ee75e7094d983857d66013a6f28dfbab69d824ab6852728aa85af8baf7beb9d679684db017d1239bd5d0f3a70dbc3f7a30c126535ed99e45c4bdeae62bce71237d18dfef685eac53cd6788a119d10bbffeea6b812e921ffdfa62e77fdfa04bcc56c987ecaf0370dde1ae24f3e84fa5de6fd6dd2c4088056b356f6e2ccbeb9472c11e8a7840ea76fe126177ab990546484aeba905fd31e23a8ff71177f68f083ed9704e12a87b94048598dfd3f925903a8bfce88c1742fc77eda15b1920b944ddc913984b9474dee735f11b1068c45f882c7afd8160b0a3a88bec02491f52039e7ed307e2485d69eb80669643955014389a6b12fc95b7a89a5f3f22b57827e19acee74ac674cfbc567f072d0f474902d74b8b75641057e569175d064c073355540ee90269af1d0a866602a28c3384fdbd3d1a37c57c7bcfa37edde71415cf4fbd12330a8154e14a50f0909e41aea0e95e1a60065f3f9316a155b3b9a49cbddd150d442946d552f4c61d75c2f222571f77fd5475d357f5b88d0e632f4c5457968c04ccc8164da28d712a85b8780189afd76fdc3b3343582c1a55216b527c0c307fc88ba2423b3f28a5ff853afcb2fab05c0970baf2579a63f9a6ce3b26bf9c75fd862afe3c0125c42a91c6fa1e227ae960f85da643e098ba991e9517ac75e8f0ca31ca9858b50d82cb6490a80e640fd9298e2813903367b0d0e58e968eeae73fc1cb7514db367ec4146c7f4b2263d698221a6714e37e73ebff10c6762011b97ce5ff47a218be6214ce7b7b93da3e7049dcc082d23afc1cc350c2adcdef88803b1e0d116727b64bfd2ead0ed5166713ad8d57d82bf480fa211b34190d0904c0902982883d7af79dc6f6305f214ed3204d7a6b7c2e4a78affa1243acd76a608988a71c889914cd87aede126269967d16bfdb2a92c0b3e6b3ba5558fcda093eff2186d08d5d0ac580374252fc4693c578cd395d61801a4045fa510cb281675c2fdc46e78d1e9e921f378efda5b27548e1e284421d5cc7261bb04546ad61dbb34ec9f992258434c2bd10545aa2b6fc766e40ca5ae51ba5b75de3d7c4962a1d057b045d935b0b9dd715d40102cefb9d6a0ff4c9db150e9d76f16c1795b5f24d7e7e85ffc6a0b674f9d7708d0c12f301a38db561709cdd7b31a32e2153a2dffe1cb9ea39f6b8e7a36924af897d60a1ae3d8d023b8aeffac1877eec58387106c33425b59ef16f6108564871f25ee632007c76c096550248aca5c195c22266ca2a4ee6a1bf79b8d0f642454f12219e455089f6164408fb200c476c84ed51859251777d24e6ace1b54b524f6923d81d275907968f1cb8c33e3a643decfddf4313a8b81e52934770ee73c60c7a80b90610d9793604b4ed5d8a93fbbbb4a08f7cf3f0dbec8eabc1c0b45563b1cad90b3e7e5e52718438e1b562e659bae40280c4d98aa9cfdcaa730a10c11c913d241d34d730bdb162c2e00fc99025da2c3735f755fd608cce34f7342f695a4fb82e908e01b1b13154be9124e2253a2fc73e11c4b3051f651b810e573bfa30fd2665e5d5af994db0b6f319ad09de6cd8fdceb1b792778e5686a2b3476c15c60e447837054bcbf5d08079c4b326ab32be98f95a2cbe1b01da0dc53935573ba7bbfec8efca464056a4350028f70a0acaa9c4d7ca6d26d6e1db80566f6c8f427316374aca1b1effaba78988b5e25a7fb51f8f6047f207b6372afe41f0761ed2f15392de15bdfc466b281c8ad349131770708389f13f2e9975a7c031c210a0914ce6d2e9ccc289e3169279b073a5ae7f3766fe33849bbcad7d18ae8b73274e98ad20195cb1f287572fbe74f165664a91d522d40939c49b8171a3f8db64ebde5c65245a9e8e2eecb876811f10a26e161467d54bfe0897e9aa94be8ef4fe3e4ce7b90831f068f7dd87d9418531103a5f323d31db07e4b030c096ec44ef1fa83c634e00915c9a899ed5e88b0458ed4634f14efef5cc4318fa79f23872735e7398895ad6b2e456544a23c3d891603e36adafaed9ce3d0f01c360bbda622f9a9d8ba58687bb08b1ea0e455a4db907135246e154d09fb23e2155c59e47d1fd3c3cbe7905554e67686ea3e9d3deede72a735e6d6f0f8244d8ba2060452f06b37ab7a03310740de0bd8684949e93ac32f77dc4fab540a1b25f3589edc2931ca8fbccef8b414542df75910db438cf81e03287c35e76dbf45546ae1fb043c1e768043acd20a2c758b30fe518be9d449035522c6ed024a3d90440af9cd5fb7280476d19203a6af306e1e6d978963806538c2dac8de4a20f460035d508a6a1b1427331346c3340866b968894693e786bdf95059414b99a7a230d2b38d47160b3179611b8d4574c183b79842345941a6f75f47bcf30fb3df5ae4a2e3fab187c561a513e853793df3d9b436ff514438195c1037306db7391ddd4673aba3ed9fe541e2f17d27fe02a5e9627d3c7a5320b38f7210ed1a73f4f03509c363c273e21fb221da2b92bf4459fba2c0441a35873f8ac7a0413063b6645fbe76cd91dde6ff45c86453d2823e3e755e18c48cd2d7d9533ab6cf0d8b8ca3963144ec1ab8ba4b47c2338d670462b42d0de14aece7d718f28970bbdb6dc4c5a0cf39ae15165c97b2589250ee4d74437aef06e96b96345b53815ee1140fde3715ea8fd7cb567fefe30e080967919f3743fd6a0823e23567a810b4b036e13dda2f64ae2608966599c7d3e4a04250ef4ad960bc74adc37e2cce39158497db0a5174142c2a06bfd67c83f5c6b1d636f22fac965f05be5e1a046eb3d4130adfba0ea05147afdf93a0abc0211412dfc23a4592d19fd3a777bb61ca81076162067f5c91060c4ce9ee764279b6d6ee466661b514de020a4d3881bd23afe3c00100e4dddb5097ecfb4ff7832c8d420fd56983f348f580714c7cb0023fbaa5d9c79a7b93a9ad6455f21a6e1b557860acc48c7d6e271d37d6868e4dfcfd521cc8b693db25a2fb0f069fd0f309807ec55560c0aabf5f42b0acd41e9d5a994503fead623ec757abf396e69af6df07b37d6b4335217f7040c099508fcb40f3b6bbd2db864dffa6c428111adc5e2daffc4c8603dd1139651717cdefe5a8af601e78b38f14e70f875c091aee13a04216460635f6d3a32289f2d79352fea23715a3f25bcca3f0b708c4f13e7da8e7a5af92af7582a51d2f622ccfade76a6705060731ab6824d45219200d2cecbc02ee653746059f82a36f17a422952bfb9c160346a01665727f91d953aa68859bd8f319268e21a4891ba35b1d9f801d3febc9855349c54f2baf0ac3dbe619490a289cc5d85c7045800e77034e4734bc18976a22f1559a5946f051e843d31292c1d18d5cc0707abecf74e6b8a09ce0bcd9e2f62af904f24112cf37f34eeec3c9d27be656bb8bc8dc708686d84fab3ffc13541a7b124155092434b80951a0df8253e66ad0ae5dc9542415d30d2c09c487c4718deba03645c12d5d4de8f5ca107de7202db2d32b99b3c6e74726d18ac16042426ed7bedafb3ea7eab20e27079fbf26f51362313b28b2918a4942c02940396fcfa3ed5eed857731975bec5b2a080fba1b69a44136a6b8be0d37547ed717453b78fde1fd1f3f8abaf982326bf433e29e2aaf1fa3be84d3b2994726b0992d4d5d1dfa241189f72ff9f6c198fb981811bccfaa79a1ca3797395dbfcc66765e650f3f48202c14df67e03b249df81e1926726256d7273866f895f1b1777bac1c5c39d53cc9a1fb1fd8cffe1e8889f44f9050de876a211a1451c65925978c30c5b5e26aff14536fa847faddd43d974aa96a293b0d79e3d797a980740e050f5250a79013e6757e0409f6f0c52ad2251e511c40787325bbdc29b2e39f5a008a17dbb3060a615c25fb9e07f3fe0d87f0a0106d7a310d74ea8dc173227ca217a59eeb5d2bbb55e5edf65f43117688cbde572a070ec2a5a76c2e60944be63e6989f9324d674503c4b63f7ecef2ac9c0ecd15a6bc680646720d7cc07c45c4b5ea07a1ee2a6543938e02739b11cc110bc553ac6b619a6058af8863cc93b0519824ac26d858d20f26b964f2229d93627bdd4de101fc96908abb9816314dbba5203207592975eafd04bfcd9f41d9480a42f2b4c8fca0c71c3ed6c1477c73df20ba8438d893e3abe32f8f5e3ea13a865f37cfd295ef209e05d0c451ac194adcd46e542827f646a56506e07b0223188a676fcea0ee9152b4c5689e39f8c41ecb37af974d4b76c310fdcc065f276a0ce82e60e3e291e5846147a453d2a7a807685a9eafd26df85a4109c6b7611b29c8bcfa30c486259cab4c82a2dd42c7df8bfd562313b4820e6ade54d667fe27e759e40a14ac29f1667a4894fe8f1ccb6492a3b58f3813c0f1428081961f16974877af5283e82eda931fa9dc784cc3b84858836a752f63a6fd4ecffe962814fe0393014ceff48e811ef0fc9fa014598bde4beef487739edb27631d1c8d9028c8cb961f28c3b677464c2df4312058ffce2e5c76e0df128867f86641a55066f33b91e7891a49e91bbb023e79ecbb141b5cc7b60902900c29123b8fbdd68f621ffe52d8f32a505d28c8ea34a646f183bd20a2f325a4c9a1c4e96d1bd738abe880ea0c5bab5af899db4b06e87ef698c51f67f8b0f748dd2b8683f1235d65206aa02a98d8a2d29b9d1e01523f4fd9938f5f8618e9a830ea4d91b26b8c2234544bfb3ee2475d81f7929393ec9e81c6d0d21f8653bf673ee9ab0e6cdc830a8596c7b64852bc1705b3c32b796b399f37e89c2aa8c0583b8f4bdc3761dbf9079ea3c6d6c3e7b647cd9282e7dfa5eba0df37c4aec7e27da2758ac2f7e4021a5abfa0e202cafdd4420515e2c76b150f3214a202bfc18c2936d5e95132a8e41679b0cf6d4e82e6fd5040917b2213965213df083b709f1b22a05357430e615bdb0556e1a5ac56c4c1f6682a9c737657985418ceca3c21383eac058a2511a4cbc1e59aaf5e6066785ddbaf704a98618363898dab0e4fe8b10b3874c2c7d7f7f748909c7bfda598439e88c79d872f1b89c190c970f270f969fab00813f5756ea1b70f82af1fecd0777da90d85b377863e6aaadd3e6d94fd1e6da5bf615b937dc1504fb16e71d0a52b0fa75cdd9ef00c148d5d1561c4d537b91ce62079f1b0594ccf7d20325abee4ed164e9e4cb04ad47ea9056b32d3252fe132e01ebb5cfc280fcfb63150f071dfaefa2527d9b1654aa0a5cf1466ebfe0b24591847fc6aa37bc8391de0148736227b013f9d36722bae48ce7488c680d52124b13527755bcd46897c4184179eabdae1882b8a28feeb20de6f551c5141ab6a61cb96202b4d8d78b85b090f9bfcc3aab928e7b7f1fec42f0fe03341c91f6b03f9780391de1df1a9bfd20e02c9c00349ca43cf9df2be14492ace0de3bb9ffe5a953e6a7b5b10cc6ab68b0c012f72612f42256b2fd803b5e9fe34fdcf14613ba8fea5bd88d2b635379c7931a09b8d629b6e439c97bfb40100da9bee9190aba1d0a977998461086ce7cf1a857201b54cf5f7d725d06573ea98fa5c86acbe2ff0eeff8fc83ac54e0cc9361445f034e92444ca6c8b031a9a3e1b2403572d6134ae2e3209cda5f5d7faabc27e6f3ddfb4b2cb4b02347443303d94a3a24a25bf2826c62a62d090c58aee167aa137b877f36d71e02f305bf63d85e575694f92a06c1fd6079c38c506de6efc784a4d2e44913369c271ea8acb3fa03f073535b6e32d265c17cb99d12801773bd2597a5edbae4b82035cd8c3def25b012753f473d5daf04ccae427bb3a719f0555b06a061a57d6e95580f9de9d8a8d57d680f79c6d99d2b3a5a6119911253c62faae43509a64371a0a18df16abed90565d102b169da2def98d67730cdaedec3f04e797b7b6b2f8e1346acfecd6c19a987ef87fe40075c45364559b6abc13254604bae316aecc31aa78cdd65af4c123c5a90ff00eb9855b555a0e0388939b5d6ea5aebb5ed2e6e3d593e6432dc9bdc8d9bc77fb6f089e1e8fb60cd4cf583582c05152a72eb66dddc07ccfc90bc4781eaab668c1a38b79f04e7ad9371a85c6d94db805b3725f884514fef81ea8f76e4887e9b49cdd88edd58cf76ff3cf26f9a8aee3449685ed0fe3f903a0dad56d4f3c48ec56e1c074a13427b53c89ca38fb55c54c414499c470b626b6e42d6d77d3a8ce800058a378853bd3bbe806b7ff3db6b17c4594da402d7d59d91c1a02c52b146260daf4f66cc47da5fb0af2dd6e384b2d774321a8b9d6935b9b8a8762bab35b5f417b8a9753c5a31d0ad2ccbd8df7b3d82f57720954fac67f2a71e4d5f448db773e223b6fcf3e2bdc271ea6961e422bd260f052f09d6bedf2b9fcb17770cad8201c8a08dd087ef451208221b85a6d12a65121f76798313bde0e2d1ec27c917e198188258ca3acea6c9fe4ba1f969cefc7fead9a9c2f4d6409c7d85a0cd261106affee371495a86e8c34e769eb7d2b707990414bebfda6c3175465d00734517cc9b047c9a3986c193417496c7a0f0eb90026d2a0ce1dca6f773ef22515c0c622defdcb435356c7c6bfdd48cb9f8469278d9c972e0ea4866da366310a9e6d23c5eccba47cab259f59ff6271cea240301561d2da3e9ddc5de855d8dedcd19e650df30c8649b899a47b8999fe67d059900497a3bdaa3069e2fca7cdf76149ba410a6dd1052b2702527e617241da43b18a9593f9284ff59ce6be06630058ada0af507f89bff99d60ee0f6a60a698c62021ebf4f3360a7e4fed8f186892560806065b78e341690bdc0338af25aaa1454f70990107ee50f421eaddc38e85519f90b3982a62bf9a32f5b131b1b48326d64b6b2fa835cb8b20f71327398534a0ab8b64df4e58a609df05342414b0c13828b640d0e3f422e92a729dd7028a91289f3c3afe61e80985a6feee30d30544ecdaf172a1eb8e749b9eccba8c247aba602bd711ae18de1093806930d5dceea100edb703f83b3b4193b25632484f0568585008e4487ef3e1bcf45edce4405010f2b33ec42e9242d1451d031091b25aa5dd530c1650efa6500400ca6605a08d7942a8d6e356825f2bc7624af16ed8ed6b449b65778d0c5f1c3a36590b7ab18a100048eb53fa540216b560b5faf192ddb7cae73f20a876d31b7f54c63f36fd60408766104362262cebf3b647b23b6add5001d6f931c6fe4cb7620bfcf3c3eaef46550bdce5edfa8b338ab5350dff656582b850b0a4cf952860fd85127679f4ea7334ee5a3329daf15f91903c945f622c3a432c5bdc192c3a1ca63ebec5a6ff22b8b6615f9f332ab5be66765720ad49a444e2d48c4a1fdcfa88581536fe22651a70adc3aefd3d12f7b9ae6f3cbcca96fa28654c31ab57a3bbe2920ed7dc67066ae00efa665af49df436a5563b78739e4f4c63d4decadd6ad2092992e6ba91e8c2c6f6cde3a99061a6a5fcfc35916c90007c2c337541747fc92ede99015169aed38daa06f3fa4f7a9a711505a1b8f5320bea03ff2ab011c35d28a79e70ce3e0e2688b07d9cbc9b30b6661c4ee8ec08c612cc903b5a5ee20997d14bd4cafe83dc46e0edf3dfc3e4368566e0913210413cdc2b85dfcd2ce9cf154054c20705610453b2dd6597fa8eb6c25dfc2e4f2a7406191da1c4bb10e082f4fb6c462c18f7bbe16d852f4e2fe940a182ceae45abe242f6783c7b3fff1d0380fd02070833a5f7c31dd3bb5183d3ef8e4cda277376976b62f7d085abe4619a763167aee8a25475f33bb5a032bb14aa8bb13f62299be3aecf03034570da5774d7a6fc0fcbf62e862466f14d3b7c62740b758d3695dfb7118f97c5313d949f7d76a0f0e0f5ab64d4dff66c0afee7018dddb14b2382d4943e1696ad027480430057035a12fc0c96d3606da19917f3a5b2a3eaa1eb8da93a6ce1bf6bf4cdd6d0f2fdc75990e68efbc08c9c76f25b6eb95008929ef231aafc1f2352ae0703d73bd6189aefe92e2bc109e4c5fc78fd8536b994085bcee6d09b839d6ab37cf2806a150a4388fdd9879c40035247b9c726defcc73718a4f9112207d00ab6a3ed50eba74feb1793678c6e391005f7a736f702dbbd1a178d832343f3c0ff1b18830ef75dc6de8ddaed681275146ece73b99fc59638bc2be40d6a690681cf6b44b258861af151ef00ba461c41b983be5f9f598d0f614d9a904f8fdf7a7eaa719d709eb0a1dec50828b8a20f56a4fdaa6227e0f9b955dbfe20f71351f7637a8d51632eec2009783bec19eaa9f559d62973a023ef611ab939d7099439022a47af75cd42c8e9b14c662419c3bfbcd4fabb5b8b0a3e186cb2c48588975f0e617c2e6e9e9f4a98acd712183c0b71ba26953e3c1b1b870cf34ed87eb2590b87f853f30a47e88a5e13d716cda431395979989bbeef804600318e5543fe307faf98f0281f4cbf187188986094b367d484a8b3f9774435d31e9e44384fdf9a3ff790fc6ea30524c32f7daa83a8777a073ae0dba4aeebbedbd352f8ca560173779f40c935bb4bac96ab08389a955f02645bc84a53b9e3fc19f35d1637aa93ee8f9de1db4f09d644b8691be26ae735b42f65ae736245c13f38aba79eb71ede0e212f4f7f73714c34a5489772a8bc9331fa2df87d69e5edf8cc48e1bf1021dc8afb5016bcab2ffefca40f34374c50292597723852cc1880074037ab70667345d3a5f8ce74d4ffc2dd6913f64fde4692ea2c2da1b822f6722ed33991a63b3a6d5b5070532d88ae7385e91935945e372e77821d445086f3e5ad24f824e452292b4dc3941f034a49f218e8f9447cf0a58d7571a9faa9e62ed3bd31a00aa850b20acae86a1c6400fa0c635d3b3e4764c135152b93348825d87c707e2cd3d785ebac8aeb7cebe85e7ebff12daa65b7c86437792d68f4dde08cc0730af9a37368711cc6ffc7909c0832e1ee0c155dd742bc9980582e69a8cd779813b949cd1437e0d5fe8d6dceeba9284691b6f0d83be2863f08bb9786804bcfb238bad809104d21f789d888b943d0a7315d1c9a4fde6d3ebf88745da4fea27506dd55ed0ff40c9a28604b07b1a2c652f3e678677ddaac7a7f04e87aba14c516e48c5710668fedd0a3949f37ed1bc62729ccdb6ee13d7bd2e2dddeff4fc6b1865eeec2eeeb5eae651de2eaa11372a148d4b52bff85dd7f1239105e3278e1927bdd2be16c67f2ec1a24e5833c9a7fd4acc96348140c487f959b9327b778a92105aaa5506cd858c537e53f34d23cfdc8f8162d1ce75f08f9cf8f556f100513c8bc884fc834a2cd091e924b44f04d9724cf420ed6da9a4a503f2a03b1618f0664520a14f10cfce6d0e24f3ff0d8df9775cea959785e96205c749bb6fc5abed6985ebc7f0cc526cf3a71ab5045ec4157f4ef302d97a9c3ec6e76f3b23e967f31abec3eafd32617e83b197076b58adb2874aac1b1aaaf7a4c1cac74bc342b5a89c4d2948b2d57ddee01ea50b8ba206653477e132bf31d477f4f0f3d5d66f484defbdde06ae792b0954e0aa2840f11896610b09b39fa036a27a1c85e8a58daa8e64d76c0cecd9492fba2c81b2c4482eacfb4c7651a82c68cd454b988db75b77639b976160b2ae5487dd941fd5ad936a527d4af98385d9670516a6cb1279676d8ea27f0c426c67921dab262dfae9792b7ffc6412b331f1a03738c15228ea33beef6b46647702ad4f69219a1c85db3575afe66ea75f09149d1494cd088686857b2475703eea83d25364848541a08c79ec73a6d4efb3b9ec1ba36b6d1e0bbfcaa74dd4a3e3123925a631abe24ca10f1a4d88fa0f4bb944bf65f707264a85d75ccd32ecae78520775221f07ef02b8146a0ec884e89afb4f32ac1eb4822c8eefe9f47542264f9dd80b04d81e128d7c16be8afc63e6a0f086e5751b2810842095bc5d9b92ed327e8d126dcfc1ed43730c79c12962bd2163e4a363340f7d2f003f3b4259fa992818ef3133361ecd90932256ba0c76efd366540f59a7094a5374cb9b239e20566246ca2c1c289c888c0c22476028b9b9c8e62510fe2ef25528cd983144edb42a90449034647fe4adb384e516360774287142fb4dd79a51940448e543d35dbd2c9be908d8103a4e3315567824a3a42fe2c3da5df785be7790997539eaa67cf52f2d9ae0ede4e52d253fd902ff0a0b8a28befa9527db2d1dd272e9c5872567d63b4bbb78fd04c91b8c7726d4e3dfba2dbb0ded803bbf6eee5ebc9a5490210629115453baf748c806205500dc332e915e6a7c055862c47394597090a340f30b623cdbfbb841d0be2aa7453e041b4a4fc1ae1a510516fd420e1eb06728e1e4bb4e2b5ca65c6bfe373d8e5c882bf1693f8eabc4296c44e69330f579fa05090d17557e2ccf87115bb0ee58bfd8d3f85e6062a705904fa1fc854910d6c4bb413ed0ee3d2022550eb4b7215da9f7a1b9830b5d91e91870196d7fc4e228aad2abde9308b3eafdf6303181857e701997db0a8c8c210b95410b2b4b573d0924d1ce1f830ab41db99172fec43a187369a06a62af837c1f3eff261f0a9cc99df7fb45e81e5c96f20d730068b00785dfd581e2d0d99170d4974a2ab11ac329420538ced420fe89feb9790852b25639192498d9c23c064d984260a686f98a4b7713b1a9b3a2335a55277541eb482cd0ed7aa8a742024c28f5561ef3c7e2dc7b4d8338aa6a445f89c99f1c40b66bab48aa77faff6ff833c421526b557306c45706ac0de8798336a127288d06f1ffab9673489af6b546710e8538cfb575225a14a438b08cc3df81a97b92ff5a642dea594f1426ccec051d80696217d3f736ff7c884cbfc62633bcc381f7404b861aefc2866f582072f5de50412ce9b652b231e6486f8c18f66a67ceb94f929939fdcf1e6f74e47a442c6622f4c1d2f02674bad287ec85d6ee0d3adc38659ac45b6c3bb8634aaa03cda8b1d5c6bdf8446d4aab3de01419f721c6a52c70cced81c558acc06f60a056e5f34b40cd3b4dac6c1bfa7d6d4e326334d1b0fe3694a12235275c877382000244b6608838e160a53fcd95dae95fd950abdf2de9d04fc3406197712a91c00ce8eeb4986bdf4a4e4bfc7c55a72abb6ea9665a7af4a903b29f9f6345ce41bff5f0617af5899148f3eb405abf492b6dc84579aadc8e9972791940868680a6ee44838203d7a18d93f273b6c21e4fa45a02c7895107f27a512979d7b765d48f2d86f8c79c5ee627a756e6fb6f16eb3613527d17f2e036e395bfa33fc8b0a74d0b6e81f4c0214111dbd36f510418942ec8edb3c44baea8aa01ddd4dc9a05fdb9f3fb8ffbab31fe25eb45cd3f4a4c3f2a97adc01312533e1bc9447d13c68401fde2bf1aaa23c5ff63b7eafd4095721b4778afc493a9c220433325fb5fb3f2c924d7ead1092fa53c71e0abf6b6acf0c64b86d0104c0a187ddeaa2b7cd744a2d57b6516ba79f3dc17a9bccd539a635f4119a9d7b6e042beef8d491faffffb70d7418cf39352d39fb98fb4dc71f3099815771f5e2a55886d356d2c4cf54ed781cf820d4298a72a2ed2afd670c179da5b84646be94d523139019fecb1cc57c2095a75a118e4f3cdf5f866070e6d1dc7773aa8a199fba370ffbc5404955451155d65e7ec93be79021e4e516c1ae59af56f5ab4629d38e60a52a44fe21e8c0a87c4a566e4792faa4ecbe5ad8f811aefa4acd2e9c9b144b4964f1e1d339ccefd52b11c5cd03c5cec2780f137fe18df8064359b083aae17042e0040e7dd2b912da8a8676aa8f0e3de92f7d199e1ad7dfa6bcd2b00bd1cc2bdd3056a945a9f36259e20d12a533cdb4b5bf6509e01abd617b478810dc2ee5c98d503aec6333f721735df3d012db0529fe759cf0363d8ff9f7969d599db6216f3757719400b62beeb9f3e239e0ce374b65666554b7a4040585f0a6efa1add7fb534d791fd349aac7f289b85afd6a7fbe3d34e38b6e4ff8d3992825803edc387a8954aa0e167cc52be621514af2c2f75c80af01df2428b5fcb4b0ff6ad86782f06be3203cc5cdef1eb64f42311dbc23398b047dc229756d310a5f1848caa37d6a57c23229d98ee9413cff4e128173ac6b518d250cfd02f09803b2140dbc6759aed5281674134c92e3d19d08cc1cbae7885641e8af03ac07d6ea0ecabe8d12a9899652ea81470cd6c966b3883b23391066a4d8e10498622dd7b8c118f1db1e3865178fe2411a05bc0f7b3a3b2aa9bc04860a0347ef5bc1add886459cb1e625d1aaa47d9c8a6c7b6706e78ba0035da52c77f37e64328f53c49ab70d19b33460e851eae1e93375b2f133bff92500c79817a1b9ab3b3098277b37f811ae9a135561792155590e5aee127f83c837f61dd38a4600d048987875dd046e36d8ea6cb60b668a0a8d3a1242ef017112c4121d486608c0e063d8e1a815fdb1aa42f69cd7d25246fafee38b34f87a659f7e83f43bbbfdedf9bae937933a34327c3ddd3f691eb355c7bdb7f5fcfbea7e08f624137833ae6c42a063840e3f279e257476ff9d5a6036308d302d0bd4f3a9d5597b7d9bbd57c926db54f44e4f9d2bd1f656184b3566b7737811bdd2df0a43b6f6a3892342fa895cc1c9d811a818b9a150aa7d3584a365f9591cc2d2756b1eabe1ecdc931af58a6e1c3352b3adbfe5ce948db718ef43fdc025c79e706bcb9e690c92d8c77fbdc3d701aaf79e368285d4b7561013c477e3ae39ec7ddf2db3a64329461c58a5ecc724675bdf7a3bdd2c41c3cd70a4c0a2dc719e3e7522504f30ad4f326c96eb0cb2264fe09854c9af3b5cbc3b3cbf6a304107b66c054a8e64fd514ccf7d0820fc6577f8b936922d1c9cc0da604cfd1a803","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
