<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14199463e2711920376649c0e8f58ec9d57d0f0bfa531b2b362b64d4bf8885f990b1f0dd9437b80a265568b6a6e5139af70621dbaa4ac0c5f152c73591ce6a1875b860ae08a7e61f972ced9edd7b331124f4999b38846c55d7d8bd9f7544dd02ecf356f7e750644bb8d566c9b9c5e3458a3cb305a660e7d8d41203fe3a567dfd072487a6b80f8c07fba53318966df5035784b28be258073067413fa5edceaa902fd21f15329ae23bc8c22f12127d267daf6c772c8b953cec7b750c62a2f45121541f9c07406b33012e2104785abab82aae6636feec5d1f5a0806b2bd73b7705ae8331816c7e239e55e0799f94372b7c82c2328c4b22604357520a36c6e8333f21643810ea42b64f0b73e928a64d02ba6380cdfacb9d373661e5f16e4c12d93b7001913ed3eba796682253d2435ceb5b1299249dd8dd2079f9c26d48fd21391693e5c821eac1e5b3e560760e4b084769b51905742b2140677fcb26e8481c69ce80ee4c77d560300af9aa5489f5c162000e37a5781d700b182576f56ac82f8a24e05487b0f08cc5e8af2a9fe0b13fa6011d55711eebec72c2c72f149ef332b569f6860dc0fa701b1a46d465360b26dc252e8bdf007ece7e0d4a322cc36851dc21c4220bfaf8a699834f89bd944a341cb595900138e435cbf0ae6ca49eed261654aab007307603e3e2c7128cf1fbdb816231854a5bb92d5d3bf3008dd274e4fe48e4ebd62711423786f1d4718cbd0d179538f94ae1f6f034ba76c8a63dcd11f78c386d990d9f7242be5267d26c71d6fed0663f575f45a3e3d99db55e273f2edb063155830459576a3082632c682443a3822e19b63992637171f7c5f2b40302fe4588eb5ccc95d222ea9780e59fcfb3b018a36c19ce69237fad82f16a0562c8c60103b4b3633a7e085cf6a33a69c9351dbd8fc9e8a3148e40f87b3d7a44a237884be38af75b18b45df8863ee5168adc37454752ecfbf046606f4e0bdd1b5ced3ebdff052ce8dbee67c988b0636eeb21208373ce22d82dfd898ad1790e377b8927239701759e8d044bad8a48ec4683817e434e80be382d84b81683455f9a4454ba35491fdaa39d5246e4ceada27b78d5321320a08ae3bc382a20be2ef434ea9dfefb1213c1f8fb86dc3850199b06288b0b6fa83b8c5937a5980ffc84fa37837efe877e0cc074f9b57555758d44b27dd2be2fc439b05df34666ee5c7b84506a8254c89f283352e7b3fd11a4a54e0e226862f4e3ea30ca6df62dbc47721eb2138a9511c0ee9fc7c13cdba3929d760648f4bec9bf24c647008ffefe1224889ce18f115e3e12681bf1bdfa9c6924d41c623dd109b44159c385eebbcc86e1339539140088cbc5e61a3939a80f158a965cedcf35080ca4d0efe0ea08db6e7e8914a814b065392fb8b086485bc252e497ce1863fd9584c72de4e50c58f767a410183c0b31dfcc9c5bef6487bcb56b232935427483d488634705b32a361157aae5d8d7965b008e4f1023c8ae553bfcfb70e4df5c1a62ea6ef140f2775cdbaaa7372b662dee2352d80048f831b4288abb61f4cdccad33353ab5576c4304297de9b18fef378f12611ae1c7d0e3217f141fdfa4cd1d5923308ef0b081e7491ce4d46696f3888bd95c12f0d4d0748db0a99deefd916bff596419a403020a9d545221e72f916c640beb0f80b1340e95e32d9ed958b2720f91d38934f3bc1d061abe7b7e58dc9121c747ef4e242c86ea704dce54ab79507332cc0f9acd1dbc4062700f74d7ad89a678b17b01909a6035211d2fda7b8fa2cfa5313a8cfa666236ead634768481782317c2ef2d7ce93973a3f2f20d981e5ef51014f6db96fd46969879dbf104d806792cdf15260f0aa783d077ac40bee88bde44fbe8420847898423c073eb0711700c8287cc6e36a0cf06cc403316da9632aea804d0f3748afad4bb9850eb09da2d7b76c53aca1dbe9c5b0b0b7482bafd90be759b1a8252f886722e31a4f984f205a232010d418806dce4360025fbe5d7e3ddae16da0c69fe64d3e935343b7fb4896a4356a7258b5348290a50e16044191b44055f081363ce578e02ec5b7de2d56f228a41dd3732df351de023a4548ce6bafd208b27ba287e4ee4263abfdbd7993123b67051483df692c4f769a0e5a39bb8d2bad4b09209e6256404d3e55e443e25471ede342abce1f0116cde988253ddf2be27d66c27da98b269639ab60be7be83559fe4ed4c9cc2425d5f926b1936837ad1507d4af46cf77c2bdffbd0fcf632384ce51cec295f40691dd22be80945cfd88367a343f32ef0d1059514f3720f0b626c0f74fddf5c0b7c1c9234111da81dfe68ff29f063f77cbfcd297df89a1cc38435b9dd801337e749edf8fbd5c6bf0a5524cae071f71ed4653d807a428f2e9251e99d77d3802b12e34664dd17651c15523fac3b5682b547ced764d2a43d541e806c79c85bed124ca5586541972ee901fbe54668a58bc078f32923a4227660274f44afa81b3f96449aabb068c5483a683b43752497e945b5bba03298fe18f3a8c4b47d24c99238329bf84b306053f625da89a0a2c8dd4f398aca393ef8e00889b82865f2cf22dd7528cf88b74933547b02e2a393a73a1ca443bd879e9d397fe7c61efd89f9fcf71f00df3ddc73fb3b8ee7ce9c49cce678728f05ca88d5c3797ae3c5884bb2967d36b7c8bb71acb290aa16b4a481cf5b0845f7f1fdad8d820fbd5082ea17d3aed36047fe68b2af32ef977190a96aa1e60a681ac67906331b98e3448c97b7673b6abe105934a08fa5b877a5121b0deec262f023420db4063b5e747864cdef2b62a33830bef96918a1d527918cb2975363f9e7de7376275716e5a7bfb0d7c74fab54071208a115fea6a549be6143bd93baaf596207543fae1d4be47a38e7c9f8f1d59f0d8a44b78480adc275feb552ac44cf897d19f68c3383070f7b0929ff406370c0e4692ae9dbeed7ff53bb7ce101b9a954c49cbe6ad7fb4073b202aaa899e2d84792d2be0929c3e115043474ea940940cb71c9df9d4ef16fc5e47a7ffdf4997b42f048725ecb9a0de0a0cc6e8c62632cfba923a0acb7f6380c7c8253d6b7d306a220efcb836c430cac2f6802f91c4d2c6497c5293bce05e68546401fbf45f2da213420fee39eec4a69de2ceb01641942c65e71ab0655d3f28c430428001c0e2fe5bfaac112fbd1ebdb0b06fb6fd682231ac5da5327b2e355e8bd4e88581ff654dd08530b2c683729b2eb0d3e2f4b0e178bb2ba1b59c306eccf4af5d8335a30957052c0130c5d6268d61de4272806f817996ffec82bfb9ed62dfb8f226c43a04aa24c8e1f4c8723f66cab41885575c05b88abeaf5728eb5534269892586561f13f9cffdc51125b08710a4d3e67909967dc2f82f6397e75cfbf4afbbdf3cc317fdb4ad34fc72dfef6e7cbe3902724605ef13300636efa4963a4292bb69255a88f6cb3aac9bdca25267f9328ffa6d1791d107bd7f260521c8bb114293ccf4db7e2957ee2c1ed044e1daed1a5899d106430628981d9bae6b0f19094dfcfaeff9484cf5148e67be873681a232c372d6915cc07580b0e16611d9ba3aeadfac15f120fbec4d7bdb5805911a104dd3089b1b4e4a419bc3aac46321057142cc9701a95ca2830637af30f73e727ffaf030f6c99dfac3968b74aea175ae400927a33af0a7b140ca69c2b3ca7a65a6ac1a2d0335f28171c693cdc452fec09aa8e295ae8082f23a7f88b0a825166a8c740467d951c89c1577ebea4161c61573e08fcb68e1accf7166cfc44758b72e8951177ebfad81144b3dbe8156620ca446ce417f0ceb48c445b8ec1f6c9909fe5e0ed2e55256013b0be93a38437db9e4a1b52b8bad5e9c77b74086124c14d03982b598b254fda5468dde5df36630d0308a80f844782f1281d67b5b5bbe0ea83c6d6d545d704c7052e6aa3d98a537e958151ee10032a0636acdaccc9bc2e3465565eb5adb8a9a28e9879a724ebce717fefd59cb87f7aa3c1f7653a383fc30be96cead8a1f94b982081c99072cc419f00fa0ab8ce52b962a40feb4a98b2d8cfbae8be35a977373f23c323660e925917a17dc6aba5634d451d2e915d19ff0f86b3956f87d8b3661708cb31eb1d370188ff789a27a0654f5d60085dfab8d57dfee704b2dd335919ec223c3ef0e8219009b7e7745ba7a78a0b64115fd830466ecb59a6fdd5b7ae733d361b53a8103607d815dfd4e845d67ec48a9e8619d75d759f3ed99375adbc64b9d4fbf18adf27d72cb49f06becd4723c23621d6bd3be48f2bcb3ff5c679af9c622b3aea1f88342745dc120c58d3909f3a8b3792b736e53038b8a1671ca944c2fd559b33b1af41be847357e5319d62fc1a34dcf19346b5090bdffe44ef662c4f38fdad87ee43d259924385d2b6fab04cb2bd1ebc97bd5dbc3eb8d56ab1ca7fae7825d90159870410e092fe00371dfd991209e9405dd32274183a844800578d7b66c00c485c21fe97a3bd9734053f677b478af8a8ad2597bf2cbfe752b1c19b6952c908fd8d474c81e4380e41c1a6678b4b7f2189cd35f79e291d9d524f46840dea9c6e1c86973fb8a7659baf34fe321394de61bb57444f70b6706e4cce9fef520bf7b5881072a45a19d25b70222283fa5450ccdc45eaceb8f2aecf67541e84c9ba443a795846b7248a0fcdbf3def07dbf9a7d99059a3a0befaa730d4f9752682e40f91034669f70f5f1779636850a6b1bc16902f8e6529ab755b0952164e57d4708eeb1820a344d32befed285db865ae19388b3d01283cc3de5087dc5eaffe02b60e7544ed6051e87450f232fc1a37dde0e7a5fd6ec3bac5569e71fa967129598021eda3affe3c8c7638b8230553845cb44326cf377318c375187a4212ee30965696028a42b771dac772d955edb3efcacd6c2a044dc7233eaf7dd3b6d5a59d51494ea7271e085ad63446b1f155c45b5979a81a14374ccf8f2be3ba5151829d32cdd9c8ca7466c53cdc9283ada2d706361323db9e7d8fbd4af62029540b3b8162dd2e919b782f011ecfaa90b67c41f82726d3c1eb5a2022f0bcef15657ed221c4ce6598b2588df4187807ecdf1ee128854cd27b1a5322d2fc3d5769af53b2cf64439868e7f4d6378a028253333457f207eefe8f7bb092e10a7abc30053a25f29680d9ce6620bc473bdb2f93272adc771c289087035ab30189efb6e6edefba31a24395975ec3f525530b4981adfca4f6f83ce9564f8bed059ca55edf57d4e8e90a84bc5128d3ff9900b4d139a147e54ccd956ae63eb8baff38d6f41b3594ad4cecd523c459283217a8dabdaf4279b60bcb067a0488f367193f1937729d1bd7caa250c15d6e8281661b23190b559302e7daca5b9aeb09d65881987d15e1fc589c8159ace845593a919a042839844e7d058d0456bc5c70c5e78abb623815769d4340876333741bfc17f265f0d751ab5017b5173d33dfad501aedb28f91965d473a6917f24161af4708f5cf8b7615dda6a67216bac1e552db6b2ded2fbff3e20e5283f38e56fe5a68e911d3958053385d99a21f209dc0c113ada944557c23aa4dcfd7635f5d4cec03acd83fe09c26fc3fd08da85c6a49a68ba38b0c7c2aed8977357d6cc5416e3d1ec2eafec8ef3d9d9e3cc0bc07c9136ebea0f216d19458d6ad6676480c3fc2699cbbefaab806eecbbbbdef330b88b1ddd6ae97e6c307209486278a7d3fb7e4c43422a5c662d5fb86aa1af0e5c138ba081a225667aa114747d333cbfac773f460171c10c1dca82dd1e156228174195e9ca453ad6d0e7c7bdc76f189a893873c50c917262cc82edddbb9efd2c12fa683eb400f478ceeac03b235b244e8db312b56f31775476ee19aeedfe1258a84be7a1090e51974ba2e8c6bb9ea9ca999a9c19a9dd0efa2bd72fbee0203965f3ea61b1f3fa4644f2bb1e60e828b0d5a41d2bcea95d200b801937d8499273856a205f1779c5cfe51ac1c01648469211752427d7f03d018104cbf0957752c0f1688f71e01e512d2ab06470114704a24932c370b7c983b1847ff9161638cab51be531172c2554f9edb518f2e31b3a05e5f073e23a454b84a53d427c77533aa86e8da5b042ac9b6c66670d101c8dab4139f95193bccdbdba2ffdc948f7ed9832bada8d1ee232e69e59172ac6191e2de4340e292280a6d588ebe5a78208268a8b6cb73d3c58a9f9bc1f00a48fcf51b5e54d711e6803c6de71504793e15ee21ee7cf8cf5b4f718273cfefb6de8a47c5fedd74475226a7b5ef55b7444f88afd008c0d654c30337ff3276517c7b179bd7ab1d356a94b5717fe9c354e24c853ebd8eaabba696414aa3d24d19dd1cebb9dede08e7fd96b0f9d55a7e0c6ae6a32ce9f905ff7c3f45c5214a7bc706c0521d6a964dde2ac349b1e870514493853bbdbb87a90ac4eb0ae1fc4a94a4e6d66c27238bda37c0b572e49e1c9e531bb8dafad5e4301a2d4d7aee32809f15176ed0abec49f1edd21df870602ca990f2e0c7e19a5d0ba9097dfc2c1493858e00ea9223ec3e73d6e3655f9b1a519a1ac6aa5ad7ce1e78074bc7d1b950ae77f64ea150049a738c063028ca5c82a8ded82180ce15bcacec478e6d9de33376485ca62ac84beeb80668d0efb1b06aca600105313c45f1f5cd783911b8b02e99085a6db8fcc171fcd74753a399703754c0ae2e8dd28b3bdb69364ff90261be1893052cc615b7833e012a97778c2b54d67c516724f57e331bb477281d6feb24710b4f4a303524119d0106b2469f5d4eaae411826a5aa5dfcf8bab9857fca009c66f3f78e97d36288b3087700a65406ef156bf8d055427adf4d9ef8e1fce93647a8ab387d88cf049d5a2fdab5e515eb03fc674e45154478401816688bc5ab5505111fb1368f5bfca4ccd7b21b65afd70a18405d55787b5026f2b95b6e669995d1f2bfd9b4d2eb8379ae6f3dfd064cf65b1312154240221b84722044f8ff0bff1614c7820202dbc73a2e98aa477cac28c69b66b778ab7b6d03f45f713208e6b554f270f3b6035dd97d1c9cd9b3ec4031d32092eb1d9ec0b34cf7e2820b178db218cba1b8c5ac058b6dbf2f3913fa9d5b2c46259ec80eef8415eefb029105f6837cc70848cfc92246f3605996f8891c04ebc8edc16c35940f5e4573c0aeacffd196bd86088e494630e170b3f5b3ed82e333978c4b0a4c9922c5a311e7b43f3ecc193712e0a023da25affacf80f1e931388c3d68daaeeea880ee293a2767486ec22ce28339075dd21694a195dda6be32eddfe7f5789af9c1e3d54b9e3b501071d40742f082dff4bd2e8dea8673125b71b329edbc0835d8e0570eb2b9634fbfa019e6e1dbcc0659f7aa167b2e6989552b60456eff55f5c419aac22ae33a3bac3c8450fc9bce8d83c5d04576fe2233011228d97b74ae01eaea59fa572d39a944f6f9532c4483ee23976edc9e52e3befe4364b096d8ffa7d384f963ba52527cdae95d1c2224a361b64ab490bf90c31c4dcabe596ab58950165a504e193e4bda27b076fc041811ac2b0b1a8ee35e63c99d012daff38c3d6077ec926a41260d3b1b8e83531fafd90e3ada568068d970741b6457c9747b24a5d533077328d863a5ece7a0cb2ffe05e1dc937e5e38ddb776264ea9ea4a5a5730c6f9fcd104676a342d0ee233a60a7cf8187ad68f8a5577380eeb1fa48cde8d971d8bb1b9fc5f36efbd99e28b770acfc7bde3bf7c062d2e6d0b19c1f1f9245e874b0a71c172321d93587c1b808b4232abdb2dacdb9a123d11ff1074133570aecc5be5a72aba0f77ba2a164c5db4a7c3ce129db26bebb9ef2b3d78182a6a315de2aebf0c000607e4ce41f874072c04352d17b249da695f28c5a4c9f0c28968c304fbc222ca0a686106ff4c49ce12ffd576b76c898f577eb32527ca9779ee7f2209537c7d8060a731f69d935a71430faceea0b0a6929d941af4fd5016f9c895f8114728bbb64ad6289d820cd8504f231ad2a76450f9b647c6b8e7af93033de9e2f961fc605a3e4aba59144d67c041a7480c2b63fd50e8a22e11a5c78c483ca827809c1b8e09c82b5c3f4d7b81747aa0c051eb4f359da62f145fddec24420a1ae5ee71aad8c5391433e3ee9e594166a70b11caa1c1fe14844b50708217f7df4dfb040c8cf30d4bf5cf0e6493ce8b609a7a1182d82cc786fee5de5d72a6b5e21bd6a19a24ec879aa399049d993e0e789a5de1793ead8a77d78a3fb033f9a40727e676d32ab42305c136710e124b6212c5eced8fd50c23eafe8e5283f187e0ed9b19466412f27dddd2b1c62c97fbd0dfbf5498545578122abb859432737a9cc39fb318f10e529f87a3e8881ecfd7459c7a60f09f0cf344d217b9ab5a2624927ae54a89050291beadb59e055f35539019b65444c1e7c402eeb9d40e7f7863ad9769fa5a710e766ab4c25fddd0a3d6551e459f2755c7aa16095bb724f0f39a8a5ca8aa680209f7570f7ceb564457267a6b54a556d67f52d740336b2d5c1baa97975c6a7497b53f1c48e409132349024fd528bcc722ccb82ef3d625e4e00fe1065786675ef621189de1d40b1afaac58ebab263dba8a671e44f5ab4083bb5372644bec763172fd52db8011966650e101f873d42d6cd2a61547f86348be5369a17a4764b81c2b853e48de2b292f39157729c9bee993e73bb97d64b2ca9bc030bfaaef870efb176811c36717026bab012510430390d1dbab512be201f87eddaa3573c79916aedffa950c378d47ac0afdb95d320ee6feefd7974bb8cffc325b5070651cad23d08e72509241226ba9a329e6f1040f770f792f171d1c622c25cc7116ccad3d3abfcde7b5d29301c7f951d2abd7b35e506542de45155bea438b77605cef4fbf9f5383f45dd1a90ba685904deb54c9fd10dbaceec74b75862f642191e55b4e5a31dbc82ce1ec0ab2073837ad8f53d6a1ea306c24cb3f21e9dc023c321d3a9856cbc28521f17127d5a99335354a261300c31f06ac15748544254b587525d30463c13949e2908efea5893f47038dd32c3c47188b776e15fb1151d2ba3be0e43074ca0a27953b55c10773a6378da134cae642a5d450a7fad5c527d5a047974686e5704114be66a3df3f9103e881c6d17a158a51fb3226a9b1ec0d71724536bd93cb99e5fab2e10bed5a273858f18ac7ce359c571bbbb43b867fb8d43e3927348958ba32f1f86dafeeee825548ffa82f3cae3893b794e065d2c07b54a2ff3aba18c495f4b5eb462101d64370e7281941bf5d0cbda5fcba6841e3601904c88862231455226c3d839b7f3c3b196dc7ac3faa00f53194f89fd7fe98e757682daa7b970cbc9474caa98dab4b32bcefa5c5cd3ce761eebd175a7aeeb88e16522f03b98b7190046321da092916c355d1781a602d41ab972970ca710b06a53f03fed1a6b46705109f3b213604fa54b5e9e2f050f8fb5fe3f40368cbbcf8e01d22000915b0cf9b8541a6d870c0c99d8c690e69847d5ba2b7e9057c98b55d0f4d28f81db06c726506aab371a665cd59802df9584d868585371555da8eeffa4051bea94c4aeb4e81db371b67e3417a791e6733b8d700cdc654bd816967b8ffecc402b38e5ac7f8f82630916c3741a1abcd6196d21aea2220fbcc7c15b02dd51b1f2a694dea6efea5351a513b3b352ebeaf4c9f5d72ffadf234f86564e14b82183901916f4dd2305d0c4964eb1bd8299e2f8afdb4809f7f1f8370486b91c693fcfa26387cc9a2fab966820feae26e0356c4cbc80ed6d27b0fc0abc099316a241fed3b2d4c0df1549f0fe91bb130ba1817c077c0dad9671411fa56a65505db144fe2417443cd61b04587c3f960fe14e66b64faadad22761e94c8ccc6b0b1d12cb8a870a06a9749a44bce4217f3691b746118d8443fdf400cc2eae8f003c3622ca237a9990baed266e684bd8b266bab099a306e09a042f2c2b5aee253ec52dc04a01f3f4888f54137c2df0757b4d581591fb272928dd079423a75c66bdc5c6fb25c5ad4321371d73868d151d5192567f7bdf1c627e8df155d9174dfdbe9d0f0cd2fd1c3380659f0553ed1b7c708322e8848d41876b5be0a977f2adb4e27c9383bb0889af783bd3b592850d03d11c42bfc20492d17ecaddca60c9d5be3f162c9835d6e8a1a22664040b7b429aa3f6c557698fc2d703ba645f4dbe2cd968f8f14022e87cc2f997441cb5118a0d8ab0684b4ad31072ae1e825b8a870096f797bba85657a526148af0c8a82b2170b82aef548fe8410bf4b758088873d1b6e78576106577d11631b756913552c8de99ee551e191e01e59e8ca17d1168c62b222d618b7696cb42ec53b38dfbff0e034dc7f1212b139d9ab1abbf8e21e73941090f1f1e6e5e38e8512fb5d7305d7630b1f618729d1d8574074e31412fb6d6e1aba09dd8770843d2d41107e7fa59e12dfb82be09511534efc1e7f8e6558d8457477f5eca1fb6480ef2b384428338e50c5be2dc663057f6374649ba95951fefa0686663c4fd204cbdf91d5cf45df526b9259b2ab52e42519479bf58de0b251317895261ae0d7d2fd918ca4cae05fe364a097aab303903a2925e13ae05af824716a958f9f066c4d52288e1882ff11f421009b2991faf8a26c577e4e970779fc4312fa34e84a31a4bc5cb77c674b531fb53631a13919f5caa94d3ac08420e1805c4b8cb6d22b8595ba0a506352ee7e460797857acefad3df59be7018cf2c2a4291a568d4b2985a98375b6180bd38ebc0cc08e45a56ea519b978703cf70d8b77ed3e6add5fe38dfa7e0e24e2c5498e0a3c0fc05f913ffe5ccdccdee97285d51a1dc14ad74a473e6fd055d57814a5804e1ff19263db4ae5792b114e08b50608369f9965ac684641d546a0d98f7903753c79c6df48917cfbe9460933e3e978fa526c323415e36289467a7e3a6fa6b82822584a02ceb3fc21ff4d5d0b24a5040c152c8f894722088db8933c35ed8a09aa83c5cc6db85553bad02ac229f1fa9bee07e623ef3a0d12ce991cfb1a2899383d5a007577c74e2c81b83063e4190ed5cafce06620168e657dd2307c9824e5bc92b9d53eb6bdfe47fac909480b4c6e05a7ad0509f0f5eed3ccc62894bad8d1aef85c80bec6c66bd97f81caffcf19a735d09be12cf2846b5439310fb894895a36d07d73df424d9c741309200622eb13187aac5bcabd77aa269cfb48a6bff5fcef1fe6bfcec3e5088d936f0fca9340c760c6c97b12a4f367531b301e9ed4bdb76f6d79cbd41d2ad428f047bb7eaa46fb23efab544d0dd57bf915ebe691ae55e329dd560d2e6a16a047da52ffd0279eea8da36fef36f1fc0fe539f74f69f07199b0eaaa3271511bf6313fc78b05ed6e2c660511f19587b0e782ee2c81ad6ed2c65c4da7dbdb66f6b8e45bdec4e9ad29e721cbf42cd4a114f48a80c46f465804c59cbee2c97c620cd58235680886c850cf5974b77419f8069206179ae2836439e2f3f811389d970e5b9be2ce7eb66460d12fb93f413bfdc059084ba699dddfdae6eb8513058153780940362d80e4b641768affc09d2460d6025d0987880b3224e5112c0f324d4d0cdd69c8746dfd1db0d91f693af1550c2bfabe8444e46799a8cd1df65f8db19378253c7beebd3c2fa235300f435b36ff05cf2e1349794f83b3f2f46551bfc278f0f1a0498aedaef725ab9e33fc439f96ae94727715399e3672ab612fe2c615bb505e027905eb6d20e5ca9763d52d565785c3c7261bc45739d0c7a3a69908effb346a299ec8df5483fe13b94a86537d3f60d92c3db16e0a1b185cbc2b83d4dcffb6deea5f7f087804c6dfb9a3762668297f7013533699622732a3749345c21fdc3a816b4ebbf2935c2e91092186b84e7f85dd43594e586b4a75bd51e0cd6aff80ff1fc7cd0baf45a1ab5bf9a40297e838f1407ae1196d251caa0c9ffa297a2ed99e5f44200d48b21fd5e5cf23c7d871f528762e0d1f2ec9f1e08e894388b7457485c72e7956b3a2cbd9871ecf9558d8b0607360dcb34f3041ff09b636b672c245e296918c7bb6ec05434757093787f9f8ea408c515c95d3a0a49efc47aa29001fc6320dcc9d83b9ac92b0150c678f9bf9ddfb477d3579dc8a52f7cc92ada62c0a48c3da48293d323188d15a981c9b8b5073bc604550395fd487571036e6168b26d397a63a2e01224fe9a0784ab9bee44a16a614b7a586cafac55a533ab2d8888d64893dc96fe788efa4ac31614fd3b6824f0274f5abfe13dd3b23b722ec22331693419b413735056e0739df1d9a88aa8060f526e8bf8bc36b5bd6563b6a47d0ab72508d26cfeb20739a9a488336492eca658ed6c753734ef0b8e54fa9a2ee7faeabf26afec2c9dc36c052619ef22db19f1f3d74ced6d4a47aa7223e6765d7106a6169f86b59f58d4b50054bd8a3083c9f38f0f009c906893ad122c59f598a50f5627cdfd5da0c1d4ed7d251e1f8278e850704640c93f6d47e8346b97896a1725da3c1f0aab9ebb8ed64c310e614b9eeea6d469d1114c41bb23637d0c437470b7e46d7820b295258391d1074d8f35769048150180a23b3dd28d56727f23a28b14b96c87216772c445383303a5723544e7aac8df36a10d6ccc2f74a0e1f524159cbedd097b8fd437d00d66b67fb2e47b42b239d7a708e8f5d2155fd5db27efa9f60dfa2ce8a39b5d114a3f988d08425f420701d95e9143ea6ac719ac2f2c4526891c39c518f65d73893ac3b02539f95e25fda5121434548105cb59d031e7e53372fccc0aa19300db20568cdca9e425969f172e04fcb97a050761476415187d0fffd7ce476e4a0aa025a700d157875682dd649ddefaa3ffd07cd7ca18b3846059f9ea86fdd364eced93939740d99d9962f7b6a2a32a5eca89b735338f81e4d60a5c00254b888da9adaf7a3ed581993c7a34248b2d3b9a9cc55521b5d35b7549f1c7789aa4fdc9ad5d71a063d187f617aafbd1c1f989a8449a34b8e0149cad474eb5a5160eb62955e71f934f7b8aaf32032a2ded289e6696bedd009756880a40698a32157046ebac091056a8ccae86f578a2f3ce388d825135f5e0d3cf28f7e84f321a91a11bcfebf6dc35e9005941cb11e94a2f011d16a76eb7dd65b806df0860d06f030fe29357f309fb7bb3a98c4eacdf0baf6e22984bd21f8d1b796ed1e0f552872196b6b32f76b0602c1a3f4ff7abd970433f8e2c6c6341c4dd0f0fba67c2d8bb9d3cdf2c546c6462e8120655a70e982a6ad544fc295aaaba82a5171b1cca07962ff4773e7adf655d3cefd859a2710ef30802d86a370133f8b0ae165e2743d258a26d480cc2f84232a54873d89e25670f5f0e708233cbd1f08be959fea466eb195fb3d10b483b680ba50aa9c060f9b367de287048365232b562cbc8f3a21e854d631a17f76bb4b195a4d6c24d50c61048624b6f954c7f05f774460b096630ad2b03f5a5dc698e418b29ee0565ba037682808a846ca51ecef92ce16e2e6b4b8b132e7d3cc951bf4a69540eb4a32f5374e555c47fe7ab1c09690dc12dc9910069389fc82e5e3aa772a16ae9e08361cb945b69df9c578fa91dfbe844ca3bba9044589fc3612e779a84368cdd7f505f0e87a8bda5c7751aba6627928875265e504909c351955b1b02e0b1d64cbe9675f5cf4eb50076039b1df858ad5f98aadd6c3599b697b9d4a5fd07b7542882c6da9de63a4a74420b2bf6223502f5576d1a295cd6ce87745fe71124be2e8718adb972fa6ccdd222fa79d3d4219be39b178330b27d483965e306c5b230ca764b1ff9f68157bc6872047eb666f57166c94fb021ba3342578a85673e6064bba1e8dc0e0f357fcfd90877c5784107089a5d126d509f9740f7aabc7c1a1be628d991832aa04ef104789fa6eb1a57a4a5a6e29c766f779ac595e89fbbc064375f630e268dae716a29ca4d60dcafbdd512cfa1d59faedcb6a6c7ba98883eab2c0f733b3a00fbf9055395a0fcb9044eff2a27e2c0aa5d7a0b292feddd3bbcbad733412a52c57e2c96507f067ae3bb092e540b55214fdef043378e1440cfa42944a13e9f117f183f0c2c10cac6c3ebec5a7841472b28e57d26c815316e0e9bcb856726c0fe3db46b49d8e39fb6ed7fa1147e274d172014d6e50bad9161576cacd3119b8c4d2174bc123071e7766d49cd3980870c0541a5930b1618324227e96de8cb8401fee44ae0c8ef9e62a799d95cf47b34946e27aec6cf0a8a787704fdfb1d267bd80aa624445343c58771a2e0148884fb1a6e92e1dd002ae434cb0f825fd12ec1dc33df23e1061a5d780b0b9de702a2e9bde71d8ba526095dae238dba67b037400c69643947212724d1b8cf4456183177215e26743e430c9a233ee8311adaf1d8c392fba8922887ee39446e0562394904fb0d8083840dd71d4a3f3b6184f98a52cfa649702b65f817261035c0aac40c9f9c3c34962ebe32c058fdf69e8272b2be827dc46355274a578a04ae6e6fe723f0613ba986f01c3a3d054738115491c8d1d41a4ada6ac0753c29c5835bc4217e403450356408d0981db68a727f18525eaf1e4f4438d9071e9ceea042bc61ea5821e94ef362b2556c8d6cc49da6a9892eacb8350f0a63600c581a5d5fc7b05d0ad30300d0e35648b3d6f33cf94ed054cc4dfebefab657fc8d06eda6fc88f5dc083b505a13ac6b47a1767d62e63ad33db4bb860a433966817217f3421d70ca2643c9fe3d2ed7302e77baa18e117fac3a70f38baffc5b62c5494f705c32641a219212a8e34922654c7a20805243ee63333788a990c1aab661fba4a0fa8961046435eba5cdffd4a17c30bd520007b6659a2b036c574c4daa8c7a246ca1e5673aca73ccde139bd5be09607ac854aa0bb930e0d088979e58be50ff9fb8ec57350b5b3907608f8a28e935ae5ff0d825150b4e818b2d5dc4a61bddbe1ee78677da05cc3bedebb4767131b831051b611b6927483cbc75cf743b53170d8ae56255af3f8929d25cd2913ce78784309c2d3f60fb160c75190a17e2e67535ecb1b4bdecd6bdafdb6f58b2616197a58517cf3a4db05832118f8ebb95aed29569b56e541fe70a16cb81228303a083a36f390a1feec8a3436d67199dcdaa88a3352c111f7f03dc1f355c7c01c5d0cb75e53a98cfe50e4d208bd92ddcb3b4b3b5b90289085b291c6caa777e3f76ce8e7f3703868d99e18a0182072fd6667678d097cf1624f61dec98bf6e4d54bbac6579fab7093102434cdfb9eac1b336913d1f39a8520d90d973687d73df1ce6d0c8c11155d5a70f81f1f2f20d2d719fcc6219a1fca63e75f7c9cb4e8d885e2bbfc49c623a9203a63488b636ae675ea00ae7e8ed9cb62090aa5c41d4c012217159399496e3d81a9fb78cd08367d8b80bb62683c032861158afea8b8d757c3d5eb60c60c86e182c03289747c971eac745dd4fa27ae13eaa9ed05e40b720bb82acba7efee29496593f37b50702b85653a3d6890c13682925f05eaef919cac881e646eabe08056a206b16ebb7a144c9e79def23f3391e326fe1fb2347721f1ec116804044ed1791f5bb6f9dacda5346e148a3a4a58702fbaec481d71ea5f94760b875bbc31d7316bedad60624781f580fd08fd62be8778c0d3db47c4a023319630d73314bae3fdb2876c6e585bde34a3ea66dc387e0b6daa360cfb1f43ee81dd9f1409666e11ef8e6d6933864984bde07d187dce5a369085444a87aa15ac4ee07183e44bbee17a6d9868566154fc104121bc628462db85a21d6f43646070afc4feb15cbcced36fc32fd6c7129a32c5cce4029e45be9f8ed57f2a75aa225b0a3fd40254c29d3c673f0e2b7a6c4c79b522384f01e384b75071096d08638e3f53f623f82051f881885a3c09c666f5e476faea6bd30dbb80bcd59f912beb76751e72bba0d1bcaa092ae70b5556020d3bfce2ff0191034dc0b26a65e548746e91070bc67dd0c9bb3dc95e7a30640b8a8d87fad1f5dc50e51cb8e41876b4aaa631fce54f8865d66387ef6543c80aa03deb06491c553ae76f3c53f056c5396f795f55216cdfa69077f80b4fd2b5f2604cabf477ea0fe83e86693b8ea4af06b0644d5328f9b7ed8cc5c549308cdd770a221c35bf7340b4325e4e1fd47187f220c2e374bcca1b2cd555c344d96e06bf7bb1f620825f566d187fa233b87d309fc735f9dc089f7ee0c087ec660be3653607c03e383b2111187595104df8c5a42940533566c4574f86b5f1a8806d641b37f599460d10b8e398a38951ea62fbe5f46de3d2c1e8268ec3100fd89c092b5e2a948d951d26bad39c34a6659fbdd3ce11208c4441c6100ef524155e7ca05fe22a100d91d70df3757b3e4593866e82cc86ccb100e1d39a80fdb4c16ec32d503698612dc5a282f71609f5bcea35730b605e6f47e814c6b6d6c3cc18b79bab9f67ce67fa2d2907ce224847d2a1612e9ed6f3b1a3189ed88dee50dfc87811e470dd43139bd885c2de21856a93c10fd6a4c57000da2a38b8b75c1abebf18cfff0f494f2710923055bdd52c6b9b0335b08100be07100196354c6a6fa43177bb7ee82f8f35bf51aa8287a3e58774bfcd8ea8336893425239e2ec70870d10a049117245b2a6820b58693ee17b8a44668d3694f4a8325e5d65c6e6a7f453b0dec4b85607b13fcae767b59f3714740c518786a7e72965ab48933c8622f65ff43da33821ed0a74d722272b6f6fc19a947754f01f20b9993926fb7d7d374b61042355f5ff05aa34837ae1e96ec53186ba3c416c91b7b1035f096ffd4f9521cec0321f84c9b4ed255acbaeefb0b1a620e8993de4a431bc30267280e5b94618c92c2525e2c964e7d2afb42ead0b472b0e5ced0285ac2c25579d1e79fda4e93acc8f2120777a41f9bcb5eb6fe2a2eb23adb9fdfa14e5ec9fec69350c4b588dae2fa6bb725a02cefe4500288d6697be2f8d78841b7f301dad9a0ae9d7e1ca57a0d3c4d2835f40037e015f2d8c795a426912d780aa6e0956d8e337331752140f3e3f1063507ca891a606f9975ee295497f0ae83fd0c8a8aea3fe733ccc3dc0711c3b8c3170bc4697ae85089815d52647558af194e7bf534cb0cfebd2c224f25109f59d0c2a03d981b3915f5c0a79bb77fa402137d442da8b5353fef9a26cf3653bd9ba909d4f93d9578370e0c8b3337ab9d17d269f2f65430e66342544b1cee785c76e7d79fa9df5a302e29882679663cb867364a94cb96fbaa1bfaa82a7bb94685cbe1a03c0df2ac7efcb53abec492871a5769e4971bf978a1b811066ad76c65f509beb0ededec8419a1eef39eab0499803cc73b003073b22aa497341490ff64b6ceff72442133e8a99775f89da89d58462be0c05be1d936e28bc45c851a6a4e55df204051b227581e778cd9a5f4f5d5817b0f15d9a2e8e043f3a8556cce1b19b8b8e37d49e86cfe3ae11bdc66df421372f0916993547ff7faf6efd013e3fdbd9624261331551f47e6d3bb8fb9aad526b7b94863b59fb054bcef394d67f9f9add8c1160fd3e070cdfd41c25a91034174edb2508312bcf4f6fbd52d36d7cf80c8cdaea6cdcad694c2e03ff066f232e9b42e45108688e987c8851f20595908c6511dff40b503858810ccaa374f203ebd1ca1a3a5fd1ba08c3ca2dc91fddbd4f09a56e3b1fba0a3320898b878eae8d3f8e9a0af042ac8aee0bb847b456d540134331e6e09a1f32735e392c32fccd4a0fd2af37c7683ab284673ef2c27b53f90d72dc6e42e02ab41cb09ef363fb51ca4f23caf8c39b8841a1763261a45ac402230b21a38341514fe4442f608c5ecc94727849f5e1da99929f00bebe63e5161afa20360ef9d38a84001ec3b59a85eb41005e6c7c6a83daa7a706680312ec48c96f5da3cf3ae685b97bd1cdeb9c097860ecd48fdd1aad083fac23b9c1ece0b582fba0d9cb107959f8c424121ad9a25e4dde4dfd135f48163126bfa6c8ee5b4dab3e7eac1036b2d4b48ed1507ee1c9d27113f54868722750ce89fdef95af3b7b00c187e02e9681cc21ad52605701a3f135723b4dce3be4da485ad1bd61704d2b099fca7003bc685db457d8acd94f48d972b98ddd11af29b31400fe9b1b619e8dbd4e0c5a1a87fc8dec6202d3c676f9d11106f9ba180bb33022c93a7797dc8dd9008cb5a39782","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
