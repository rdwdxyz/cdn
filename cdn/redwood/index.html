<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcbdd15e99c3f2156dd81fb7c88de968ff47045a5a15aceb9c4e375e4233c2c64a0b5ac8f1b56a55d56b52c44f7b0bec34499fd372863b7dfd7133218fb48d2caf6f89088470bd93700c712e3dc22aa25bcf6a0b0b6918f4bc07f7e00804714636b1ba744be49a5a4b3c31f12bac2b3b8724768361da048e235aa50fbd037fad9dc361ec3d693d018ea0bb1e6367799085a75fd79f3b01a5174508944e3c0a69dcdbd53642c126c50c8019dfb2da6ff79b2f5aad6bedf5f02f8b32b49e2994d22776916eb9d661a642be219786f9e38546981466a0cae93a89cd675a8230042bd5d7ca4ecf220b50026b01b6e6b3c86c6e8a770ca573ed3671e836d6edaeafe1e76c0b269738e50bc00f68d6415fd7188fdb2accc693365157e9e44c1878501cb72f228af1b7e467ec86e09a807fc2498c4be05fd575a3c0b19d2bede3b23671438133eae5074155559df0b681572611f1c929d1a1a109f24355aaf3844b5e0eaf8ea2b621480c3674de21cf6d56aceea6df35c1d9f46bb55a82b3269f7359f66116c8f9f2f04afa72886106fb299a4d77f96dd79c98496388aa74d697005b6964a69d70f8e722f92f8378bd7ebae10f551a357c8da1acbc9075f05a5bff141193c5f32639fded70f6145894d7af5df5f59da8fcd1282797771591fce8d611dde153bf2402c3d8dbd728ffca73e6a9ee11b462438ef25bca5f9e3d6690601069a031da03608ef144342aaa4f62902ede15bd9ea5a3fb2d1e81c44adcd9e954533233506da5969800dc604673c35c43ed0e9242fdfdfec1bebd9aa2f75dc2d26086aa50922d35c4ad0c87011ea1744c7dbd90381cb3d04d6830be4d3771f9d623d839960d01ac2149a2a77cc127b5c7dcbcf735762b6e58a3d261638c23feffd0c2abd9e2e4e0db76fedaa3f992ad102ffd8d526c66a473587b4b4d6cae1edbf2c98bd0bae85113d2aebc1e1be85c00e86310df0fa9889d98897dce4622c5ecc19d034f641a7d1e9d54c6abe4d54fbcf0fa000da2e6364e6ef3352d5e6f4783b92fd76254a61cb9cd9e40d60d7d95129199294b84554ecef49cba326e4a0410788066a653c02ce9dddeff6641e208a83c364ee2c119407cd76538321e510e0727860227be3ff7e6401544d2e623bfa0fcc21906d0732cd6c200592e3e65a5560fc3af9e7190f3053fe49476add5e01cf1d95f3558f74f69b23de8b4da7286e0df5e1531365e493254826f5ebdc2a7d6b2bf276f1d35e419404669c8a8b01767a87d353f029a158143196e0a0d71d83eac002efa90bc124cda6d9ba2afc14b0b0230e69f78aca26766073ad21150ff5941dc59bf3f4a19ab65ff2a238f75381ea3883ce5bf78affe6501305b81bbe13497d53ca97307e45da957bbe6a6ec219a7b736daabad1d27f8e93a9ce5091d65f57301b5ec181b512b230b7615f5327cbcd4cf1f540e10444578d9ef8d25367829aeedac57811be3d83b5a359175645889b579557c1c3d73d2626501613e9673b60734406b416607ec5c52335dad5c1bd25b0435018782e7c6bbea6057063b7b3e73500bfb5d9de67aa75c511705f1795703c1ec734cf695faf2e6ecdfb277b6a4bbdf92b9768732940ec1a7840cbe339565ba43ee438d834abdd6c47de688d55127da1f0f17b82c04718466f45705bb8c0c1bb49fc546dc84ec6423ef1c876f32510bec6f8ca190db5a3a9aaa9b66beeca2b4cf9613e3469d4eaf258ba76c091f1322137bf806593b24b50c8bc9e750e9d37489d07650c23e0b019c8089e0fc047c2b63c58289ce17b877a880e13c8dd8cf32c3b106d4bd4aa0b3e6bad70989386683a0911f848230f1acb452d9121c8dbaca3338bfc07db5b571a0bcfd81463ef874561fb096c4c6589449488596a0d2b8818402dcdc93c6e76382b6f31f2fee8c35d1dc233205c525542efde7ced9a40630295be2a990dae0a4b8b1a0a6e5ef57ae8d215dcc485ecda01022c48c4d36a3dd4ebf4665c222b1a37bc23675ea94710ca047ee0fbd3b5c70dae291b24fe51c4e3d204701965af94eaa63c4dcf479e82ef20303dda8909996605c5935f19f934beb914b8ceb4a6bfe1f4e482abdfd4f0168cec195289056870e9d55017b9ab5950b8a22dcb660ab842cddf631232bb7ca4f5970ddb64d6d6f436442917e56cd8abb72272619eea807ca5d62e97fa9c41f555dfc01ee7623c522bdbbdf9097a13ebd7227e1ff31c00374b915cc98e1372a6881bb22b6bf23ffa2e70bff7b57e693e8b6660b6c7d92c29a0e340e9e1703abf019e0516c78ae1891a241009c3a3dc50e6a6cc24066fba701d3cc2deb828df11ee70b921f676e9caf105a6603226c31a399675390adfcf0044fca734c9dcc2a6f3ac1978746e091290301da197fc2aa11133e0d11f194214af5b061a89829884b5e0cdec6542eab62313f2617d859a2dd5389653ef6e14daaa79083f4c0e48efbfe816239821fb0de5c60c06bff82e976367d2a93d8ca4426edf6ab575ec7b8acdc854abb75567ccc46b32aa63542404e1d1a9c7f83f356fcf80d341ec39192fb2e06ecb033846174b34722501a39e878e4066d7ac83cb8fa3a13b7834e45ebc22bf8bae710204fd0d44291884b4c79a1c30fc5cbf70bbe15787df9dea40fb1aaa5ba013e9bfd7ad1e15837f10188997e685112af1d8f9d5778cf305e0b38bb97f0cefa9f38d5da78fcf0316d897a5af6f3df5e2ed86d35ecaa1c05c82668671b6a1f2c74f7dba79df55d8dc383019a879539744ea0a816bf0f178b451316eb0d5f382136f2295f2cbeac7226e66944096c1c09871d39555a77df2b7b1cf720c694f78a675283de658c65f083aa5cc404c33528a13281742f2205251a447ae4ffbac1827a1eeda15523ecca196a1253d5aa33263e0d711a7158501c971aa67e1c0dcee9faf7f11a79d46b2194b3ce3245a5e9798acdd2345001cccbb06c7efc6a74dbf6a08bd41c3e3966fe5085568c2a2c5cd451dfb93fe840496dfe8338cb04f921e0d6a9e531ea44e4644a78526872f858d15f44bd4c1a906addc8cba342a9e8d50e6736a8faa64ad663a9b5993e6855c9d5a7286e6861aa9fe77107d5b52b2d9b47610dd321368f3ff62a47f826db5ce197cbcd3c2cc22e1281fc20d55a29ad623b1f517e9810f3019ffa04790ba42b8a7749f75eba785ab040b3a08101619a526a9a567a2bfe727935e9dd6eacc540159967fdf5ab75bc5a803f342b3f825db45dfdb85e02b8aee863ac413f17b0ada48d336d1d0823bf25f137e4f1123eb89612b864a834646a790c09e88d93120b2b1d7b657d4ea821e6bc9c90d5c73dbe1bd0cb7402cd6d8d29823f49175ac8d0f8aca5604eaa97cd967ed9d931d6bd2c15900c52d7742963e94da565cda2aae8b45b48b88fb5ee5870acedd0da74fbcfed45934955cbf2bcc861da4372b74c4fd56fe452dff425ae4954f1775d615d8d4585f0eec798c1764cc168cd2a1feacc9f68f940917c26807ffcb60221b351f479af5871b2914f698cb0c7d1e6a7bacadb89ca0109a2709f0e550ee23317e0e01cbefdfa6c13fc317d0fc8dbd4c0f0fe9c7968580ba20f1738871e8cc36ef1d20796bff1dc26a5f3328d1b1638a890ef10c03f6d5ac95dbdaaab4963911c8c7ab5033b258430f0ec87580f322836efe0e1a32f1905556382d717f1d998f5d5101385688aebcd06937df7f79b4a760a21dceb7124aebdeceb1a1e6c7ba7417bc0f4c5bb4dfddcd1c44a66c1ddfae0ae2c9977576d072c1d2f21ab1cbe060806842b22964adcdf0c26204ff4c746c5f113c21acdda6f8707d7e57be60ef61854109dac36061d9e1669526887cb8d3ead0a42f0fcc1d03ef02c82b89e1e422b2c80cdca0f8562320f6fe403bdc64f3ddebcc0b6fd517618584475bbaa464f98e6ae3ac245d0459193eae6e6784a66af3b61b1e5a8b350682d9d0074aadc13f39aae1364ec9d3fd294803d6acc3606b0dfab4794cfab7473112dc7bcb2fe0b8d3f89e08dd3692e38e47a2925b7de3488b732fadab71f265c97208196b08ba036c75e9c17845a631cbef668f76915132f0b8442493b0e2642daa88dc6feab4be6c46619b4d5aee7d976410094e1d310fd282211b5f167fcb48d576c64384e28d70f50bca4344f023145cada49a4ba2e900c4c56a3854f55344422f1b13b589ebba14730e797297b85c813cbf4bf86eb09a0f9323e3221928da19b662f84191d94e2143214da42cc36ddf77168f21b1edc769916fed847e98305159449fbd72d1f9de29d4d92d186f714ff495fc1dfb18550e9aeb848229e5f63c7248a5cfa9c7ec8e1cc48358069fa601f3c34309584a107a12271d2c0a8586e512cc05d2fb67617f0226902aa3954532d35ada20f807fc435b9b4ef46adf249c69bd4fe41f3d0463c81489193f5bf527684cf7a0ce1144d5d1de39bf31aa71e263e7aa420ac801072c20b2eb6c188a540b1aa07f0203665257c50206aa390ddc3b73d85fe2c905e461e82aea7dc0e66c2dc15f45685113a57662856cfe21f2593587d814cfd440877aa05d2e0bee6860a7487e10579b9b64f8252eb1d9586dd04e08ed345af12c33c27148a5d116ce1dde64a96cd4305586bd47da684e2233b3b7593a012551bbae4a14ec58bb63f81ca11e6269f3b9ca9da908859bc700db3bd63a3145fd2600e2c5404bebe5a6a0a3953cabf317ea754ac0a38f44b8ef9a3e6cda8275fdc0e15bb5c49f4f12c53b2bfee05b914b091e6c32864f19312cc8c59551f62b2079340d163d59b56607cbfcf8722e42236f9450747dab1769b50c065897c833ba5b81b7baebc5b8fd64a7bface804823cd8e659f1057068b7bf0f0dd0686ce510e670d5743177b5f3cd8fce7dd2340d69282e55c57d7f6559e8bf29ebf98ebe2dabee8df1052d02b7e3e4dfe8e7b4052d86222404daf75db6e0ccd2edb7c8c85f73006929f81e80edd8700392f0d10f6d2533b745b11aeb9075e616fd3136790bf8ab05d0dd8193ebf88adcca1193c1fad85bd0c1275c2b42a6050ab71ad979e2e87700f5fedf468b05489d62346bff96df32b92b82fca483edd7521e4996286f8b3c5242944e6dc9909b23d508521557e5e431510dffa839dca7d61ed684ef9abec9e21b73b84c087e6dd9db6f42679864d3913b353bc2cb69e95ee7aeb52390b6a35c695c237fab067eec3399198543d56e0735b4d6c22cdc4e8f7fcea8d28587672969f9c93a320c2a96348787dc68aacc8c728b3ad46b74cd0a61d75f7cf6f67cd24ae20ffdbad331a576e4165582f827049283f061ad4a9cf6445800bee91829c1771ecc303518d34d578aab61868bc5ddcc99d30018274a0a632000154e1f9482b98ad39c0c9a0b692177ab07a2b3adb29313cbc67b2800dd4582c39956b5bdd0e6794a8d9048fb904dfba84f6dcb4aa584eba1a988f702e8e3e037ca558ec78efe8158739b8624fc9d20243a1b2e5c9606258454157bebf3667164d9baaf037325b08bae881cd510db32846e431530a8a22f1159878075d04b7dcab63463f4ad335ebfd9f47f0ba71a0652a42d8c30571c9ac0e93f3f5cc16f448564a4ba4b67694c30c81871ffb2445e36008cc9c3803c4123a178fd31234f044e967fd483f64b2650c56e19da2a6689958355ef1631640eb14591f21ef9a06cdcd1484c9f7d79f61d444b116df61f1ebfd5e54b3b0f6e1acbc95e963b4e60dac68562f31589db6ea073f752fb62d2e123aa3d7d9eeaeff69d160e97628a4299c627a50aa9be7a7361bad99a94c9ec0d866fff6845bf445b50257a3a64d2de65feb02038a19fae5c0e8eb2740cab2bbf8cae6abae561161393953c1c76f6560400b02e7c4d92006824dd36bbab73d237d3b5f351e4531fbc91cb21cfee6d82aef990ee69b0b5faf3651ca92af7e7037e588ced7f7e274f3c8cdb89e7d985562c3365e72d42295393074cefc696b204e7521155b3e770d299e58d9e7dd61b54e12818cf2a6eeac39e853fa81d845ea0a6d960247d65e92bc555a1799331b688c85225a265273a8cb77ea847ad46d2d23715c2f3db06d0fe64ac5b6bef8cff3e85c4a7eb0f115d2d83244765dd7abf26de033c7b290cacf1a2613471fe01d9c08af1ebab853084c6f2d807167edee3814b0ee8565d4b1ed364552f3786c80fbe47749b0eb14aa7d2a26632ab77e8d53d20b5eb10a882bb2ce04cea74d4f2c9a3c6d1a77db70f969955e7c2b461a0cfad5cf0e23d60dc3d81dc02d72ef894955ec2d70858486085b003c1eb55ea8d241b08b541f60b7a3dcffa4e6561b59a4ea126ccd23e3acb327957d8854fa66308eb183756903f967bd904c5d217b2dc6130298086c250e26ee4d158b206e55bd9bd273577d9ebfb67ae665a8cfa25c07c0221dbdfe1d41bdefe8a3d6257d9c7da6515f59f414e7c41fe41d631f30470cc727c91d8e9239e80f54f303c2e227804a928e7d7d97cb86cee88683bee9b7ca07ecdff45962a337d2d0a2d1f627fc02e495e86d7778a1e302ebcfe2f5e7d3ce1f551d4945b6b5595627b8b99eae5b58bfe41cff009b7587363cd2c71d7aee8b4ef010bffba0a8974d1785b84d9b2f122804ca83ad6d941c9ded02eb5db1307d995e1cc90363357c25cf60b18e2c2c59d7836e7d32727ccbdb4ec8bfeb03a6e739f0a307bfcaf29b943bf5e7e1d481bcc32cbbe9de8c166afa105ef122986058daab0ab39c858e23245e15069216e6cd4d380249f41bfed8a30706312f97e1c8c7bfdc156b1e60e684cf47d0186df651f8e9a6f2e13831d726cd01d319946a1fd50219a367910830c11c40bf66cff56754a467ee4be59fe42dcc6c9ead2d3379e3d6865305309249b1e36335f4c1fd8965672b53e417f60000bae68d6ed6d4779f4704419f46f5b14af7174129911a46c80cb0f94a7583e488615b052ac5097d694435e61ea1774ed48b8b98ea7772e25242225fa8b105bc50f8efd3af46e9bf500a829fec94f8b0c97e7e43d38c97ae58103df9f4e9b100092113ba042a165b14080ef8c2e3cfa5b7b543b91266b2537030517816514114971d305d67e8442037fef309d32ac8443aa84a6ac7a169cc5ffcc8797cbb386301576f20124f59988437a4e3321e71ac06565b721c1b19784bee9ffdaa39c121aebfce246aa0c2348a24df6e698772741c888d1400e0f02082ffde404b44b267507b845d1f43662b681a9469ef8fa0d681a3622cc02d2e10170b6acddccca5a5aa18f2e56798f7a8e97de44c39a2bd6bf9557d0488dab30f6be3420bea1c3158eb1329bbc420e992255d06bda388b421643abac7c234619fabc24304eb924025653d47b73b0cfae544c3b78fec484fe3faab6e1ba44d3d2049daef62c6e3fc13bdbea7fa6fda04c508e3c0c37061f2cb3af363b3ef414a1914eb67f60a0bdfc92de566809464728227d3d4ba5669be1a42c40f54b823be201f98bddcef152e7091912a5a550f94317ad12ed9d90d552232aeae6bd5fc831451d3e406a87d475130c4dc417e0afea84597bafb1a05dff9c8bb04b1f53add8b664c509e648cfe83cd95e7fc279dae79f325b957c30cc0638f9407648e621721b28f1bd2af034810a1684c0a8b8b291a591047a109edcc81f703c079eb113ad495f64a35ce6c8fe865d0c10baa562e35ae293cdee71b0ca2fec3b377f2359df75d981a5ab05e82cbe881611f4b6c21ad8cc8768b0aee6594a9b6c22d3f8934cdece90265ffc14fde269e4f73991da0731aff571e65923078953b6be9133cc518ef1e1fcfc432e69ce6f9f96db16079d0bfb0e48e7ddeb77b6d13dd125a923e352c1d5f005ab2bc28be7896863dfb2be12fe401923f3e90674c710a1b0e73e84c416681e95b81de561056a2249519c3224346888007c9ec7ac8c3dc02ac9cd3681c89d0dacc461cb9ce64b8ec1e32697e13154943601b8d7cef1bef335b0a9d9ffccd772ea727f0fe2d2bee1bbaaf006419211fd6b56734f1034195fbb9267f19728c83ce0ec83957dd4a080092481704e7588b2b231ade0f7b6fd8fcaff5658df116b648d513a5b2394a3aff741e27e9861a097e229f8e72cfb12d339ed6d746fcb8cf280da56039e8587f517de39fe1a9d930845979380a38995201e92300e49fb63f2b58a8104b9950e902553737ef703521cb6300599d4733bcb48561f650dd18a0de11bfba4af3e6a4906298a02add18163adc82176336c93d49095fcf5bfb5813ce43c398486d2111ea119070def35558eb8a05eef87c939d3631ca20cc3d3acd8660ea6ade63ba59b1a40383a3b319fe27a2eaf8e9926b00cb542453eeccff9bb61292e1e7be92de416c79dde48fbbb6ab9fbd8ad7686c0630f204f4f47dd523083cd3c2a5c293257dffad18a8bd956060c0c4fccff56c07b2bfc10db23171ae0629d5e6e4221a44001c7a21ac9e9b0c43c8039ee91a625b0e5104ae3ddc8964b81f7bcebfee2412b08c4b81c670a12427fe084e85bb8c3f88991c20439e2822ef5985f2a3f5f05ce81ad6b330f9802e68d56d1fc3c79885183f672b936234ac5393a43108378359bf5ad6cc3323a18c1b55bd4eb82740dfec59bea4a18b7833bc878ee217debd761e26238883dc1cf1e37dfdb7e603b7742eb91df180c2dab5fc5b73b03fe7088d544ee0dadcb1e7653efe867a0f394bfd162107abc6fd1056e1daed32d4a798fba42a153135d520c8d02aecaf8f25f06c67f7afe11ba48f0d5857104cfed9a173859932158b2bb7fbee3b284d8c2940391b6ee8ba3ac865aa7c3a93525899250fca62d6073082299a57600ebbe7ff324fbdb6f6d9d9a036c118494c04eb8559687d283fedf4051f52d1ff377e1ce71255b8b5bbf7a7671dfeaa7d96a931c2762f7213ae26a7448aeff530f4b9864bec25ed093bf09e1c2a12aeaf9c33e62c3ca3d14f8b2dc09298f1cc10f1080bfa10fa605713741a9f58f07302815e85c4e6b88e79141d5c650385c28f5ef9198515c14096ad7d52418277e1229523c5929329f6eab2f91d1a9f99fe718b2d0976587e8177e0b3c45a011899968c6813670c57470532bb5a4664ec2c7bd7fabbcce69f81f6f5f7c23a0d9b8dbed4884e7ed0672ec14a3c3d9490127779c4ad72ad8bb2afecbb37a8e1d77bbcb6746bdfa6a3336a53138ed74abdb79289be85a5f73ae21a16b3035fc231ed51672b01726bed0b744d26cb4b3dbdc74bc7cc7e18bc24ed843048c0e6f3c0ad51e727d02acdbca64b0f6ce89d02f37966b7eff367392c0a10ff1cfaf7266a9d78a50754fa940afd2eaec165ace8d10d24a5af546b77241f05261d002d5cafff76d56246c4eba1057d368cab8ba72b65d60b9743c3ff4681af552dca967e1e673974b0efe20457abcf245939942a5acab26c9835bff075baa9d9119258ced40d387648d2f5c23c26a45d44a81b0e2c46feef3895e26cd1c22a50403b2e48d8b97a6b6c66ff13b23a94a95a9545bbbbef5bd4d8b33e2bed61342ed2af80fb1e8317594e5213df603b8f3f360faaf771013f414ca64f1d3b3052c35d093b213b2797046f29b9289195f1835e4117c53ef7c9db504a737e5691d060e853cb3c3188d6f7073b3f8cee8c088da57031120525683a2ad5c800e7d3bd237d705e081868055706067e9eb48df643029b25c92a4013ea869dd3636152ede60b68da45d2af0e8a055d704d9bc848a2f65234b30315cc9ae7647860e6e152494dd761b0e4522e2f9dbd2113e7a147d694231d9df33a537c29b507fa64bd495793487dae8ac96e2b0535f221a2783efb15b3e42faab96a0c103e8a489e3b0f13f0ddfa93772f6755f88d2bd0233a0671fed0b668924a77cd630426f126d7fb38863649e8a66eeac58ae10b5c7ac1f6993e938820795447c9b0556fa0b0127ed1a804defa94058597877bd899080d753eaa3a5c82f7853b3083189e13aafa8fc68e4b5af7f8e51c3e255eab666b050d528726716c1b1cef730b534ffb42e052682d9ee87d251f7a9a8948cd00bdc4c7f1f902965f44b0c8b04dad28df51a097b9293592e6a06704db1262196d63714d0dc4f5743d446f7b0c50132780f695468df7bd1b3e61b4ac1bae1a5a7aa5a6529b2aa3ea5f1d229da0f75ce21845cc6ed41a3dfa5ab8bf0e89338e62301ffad1d2b64563e43e09c12256ee4c0abf8d7b91c2f993f11ff382ac56424999f4c2eb61aca9b6303548b6c6feb7c5e6d71a1345509508cc0dad0d7d78cddc633332851661038a718e04b213f6efec2dd1a3fdce6ceb035e85b7a80daf804073c8cce0eefab4603a49e47a0418dd1fb7482e789a8fb95a4a70f937661d91f80061b812f1c085eb0c3cbc54e35dbd5945690482e8d627e0d413897789d03c7027b4d1b6f561bba561b2b9694c81027f01fb5634da97a0ff204d5891ddfdd8ba5212396cec4b09124d26072f8bd0927a44d13c613b3022b17e34e5cf33978b42f9e7747f2ea2cedfece14e455cc4be622f546f0df8c4e61a9780ecf2839e7e59d728cffbd1d3cc5c304dba8e9c9aee53bab8d4f6972258ef26ac1ee1c23810c17c896479b6a34b012ac60a245a7773f2e54298cec24885999473a8033d5e20ff7a9a8442128025bb4f71fe221ee8c615ead08276eecc8ce663daa114286381d8ee8cb8602d20648a344f29fa0ff92495b6e407c9fa8e5faff70ffaad8ee08a905fd84934b6d20b038b7e6d617a9a595fd6ec668e1436e6d412b37c27c6fbb6b30415abaabeb62df49aabaa1f4f9985548c60b9eb87363889d0406ba8f22a4b4f072c8fa8039db64f6cec348c7d370bbb8498d819b391594bfd9cef50f53e2428527ab08538ccdd2b6df7eba8d70043882c21cafb5e6f8e0775cc09f9b1114dcdb3dc243465a1ee32395201243e7e0ce7addfe5e90e1f1d8ae9de6d315365bf1d953f625e6fae3c1d47a30ad367bbdc73824acaa3422ff51daae5fb55695a83b30ab43d97535b7edb6d346a0eb4820a4ad158b673f381901b852eb06e58174aac9c97d0e525607cad8ba4b69e3131b06f36d0a6d2685237374c5e46cdf069f40b29efa896ceec4136dc4fcde27b92602954770b096591eefac142feb7fe97b07d8484decad1e0d3b2fc691d2f899497574a654df2ab7d7798011c49522d49364609b005ab230cc09a26d8f3791efddb688c9bd7a6ca02f514990f842a858f548105ae79921c0c686f0f16095c1eef103cc000a3133f4969b92a050011094ee4677f8341dbf33097420272299e6d7b928641a7a22a1d203ada6061c558fd5d8f09488722fcf832374dcd85d2e735d598f55f34fcd290534fce258d011508827764087568c365769847b81476bd5681c471a1b87ae952b7b6089f0091f77b95ce9e882a66b072326c95a42a4ea7a85f5434942d45c359809ddf12c71c6a8719a6377ca6a42d6c44ca746ccf4059474a1d71f4bc1f72eb901e30fd9bbbc8ddb4dc367160ae3c5e0d77239f7808400bb54b5634443ae980866fbb48abc816bde85dae713ea9f06fd8a1bf8a5efcc108fadcc69738b05de1a7fc6a3e5abd4a11c074c528dea7e3b309b3b50eaa2a5c56467e78fff8e5b78f39f7803781ce6a50efc745b70df43de2dfcf1d3e09838c6fd532902953f947abeb71518c2cfe62a2d6143e5e601a414060b73dbf48ff16afcf2c687cc512655c5d5fecf7244b32961518944e6c24ac8071027af0ab10034791f00426de1bc6375c23c4290d93236e586be4a32b293afa635a8cc99abe0b3453f62140ec08e6d53f0a26675548c76b0f8d3560be35478e60a40a33a9eff2a3be7bf5e8537d1bdcd9ff8b951706ee47fb11041c20546e3ce9216f7d23d0619e9d447537929b91ad4373574e71ac5cedef89b824ced5ef2f3fba9dc27172a13cc502a8da76aae08050ae45b2aa534aed012e6c5d4a094ce5a7feeab618d7091420b30e508cdc2e509ce4faf0dfaddb1f28e899fc586f7b7a2c96fbaa587b4dbdcf04b984b255f72b7c5ca942d52cbca74ef2c9951567508283a1ad8f6ec31f97673838a453bc1f2e2c18a6cf2231da0e5618091f8ebf13884d0d3ec6e7e18e7ad02ac3a9a0d97ab23162ef7f51b8e5150ea0d58da3277f5e8560d7a6b3c5cecf3e180d2e95e716481abfb53a738654ee3dba4a0a1cec7846d2c034c6bae2103cc2224b2f9496152987f5df3e4f88b3b026b4b67f470307878fb72be1c7f5b056bef5e0d5c184357d69a7a727b24cd741284e7f72e3cd2eb75e558b446f61d1f31c928d78cf6a86edea50b386117f969c08593b19a7ffd7e545f3e7696afc04ffa3793b7d3f2d748413c202a3db8e81a9f29e15d0e8869a11dd05a7ed75fbd362acf143e118fe4fdd97ae53dee5f28105c7fab774bff70266e3734294bd5ecc3383a847094474cd69a8175782c1f750133ec8eb1618ccb499bd3d4b9c5aae25b9b1beaf680277ac03698c9d769e38746ef5a33dceef3d7c8ac2f340cea7da98eb9d44a55ad565b68f49c60357fce59c5bc9195c75c42349d43a5a89b3f9463380e1122c9dfff5e8c4cd507be903333a3ef5b8147f4bfef63617fd16bacc833707c4830be533c24b0f9f4c414624e367ae4b9c563d99cf4aa495c54c7c8f1fcd82f7fa97d31488428d5631f468c1f1a75555456ef610ee976ef48f10e611f5d125a4d0c15daae50f5a36e312abf21facefeec8e8e9277495793d19a7a71d7f3a4a29387c5f4657c1f3e21f26f6db5e744a60dff368d5e92fd97fe594a75d28aed57731f204a46129562ba2bdcfc33d38a3202a8336ae3cdd44596d01e37f0c8802485c6558bae8dd62853b3339155e4a602e9ccdc238ccc23ce599f1fcd2f11918f684f499f88bfcd2370afa906e3ab5a685513747488067a6edb07955e51937c22c9510d4306aeee22a04d023da233dd1c98470e40a7c358b4939f474e4efa7930e7e9ae9964ea2da80b144bc70c44969a7a8676f8b63865705c9f31c014ce04583a313d9058e2c0f6fa5dd71f4b8de1c0904b61b97e3af6af88710afcbe634d181b10f411c0b06f9afa521ff0fbf6e8cce8c13995d40d8be76091faf80d5af366b08fe9491692685fa58d67c04526e7e46429b5f7b814e6a1aa22910c5e7fb57f97cdb48066e61ed86d03c2297830179d19f12d6b0b10ca7c709d12174c3e6bd48f6eb727dae668ad5f38e9d32dce2e6af68f04c00211ed0f271b912229be28e46aab395d5a8bcc190ab7379c7ec4f602e83f57bc7508b5671ab25b1aa0d79887edd947eed97dbd23c130304119d604477f5ad2cf4a8934909dc1a283633f0848a48a0b51ef6df757c060b40462d48caa5e7b6bcb2b1ca37389fd46b15ef74adf280da67b3471c0c29a994317300dc8fd88e798f04d9763a0d3da8244679fdd19c24f89fa51de1963023e0a07105931f187892a5cd420a2726b3573808b7a59449275e9cc3e7a6f424503031beedaef427edc47a2e9a232b06de17bf6562895f3da8aebee224f534c16203a05cda8046c4f3e6f5021b909790b3e8fb73ec77cdc63280c4f7bb0cf9eef6236653a397d94ecf211cc71b5cf0dedee42553538aaab1f1ffce174ed66a8233f31df5686a4c1eb73ea5f8c75f575941aa553ecd2ab0a5b82a9b47f5a9c2b298fd94a04cb24331b9646e857ae3e26b739661b1eec042e7d3182b0823a73ec41998ff64352487aaf0895c15f3a60fb9509ca13f816e71d5fbca73a502dc7c915da7cb4b5c89875cd91738957f8931de4eb42107dbf99c1d4055e8687d3ab18edc3a05894eeebc8a15c31a9fa92be103c865c7d93f7baeffe7b6cda4bf850936044d0eb14892ca91ba601708835d1396730c3c682a1276c88a3ffc56fa3fc3fd4df662b1f06dde26f31c673e60693dbbd47b88d3e66a637a718f21019215c537e3a03ad3b8c7f62b005486d022ea67f19030632fa55876db97e7d3a8b5d5890f38881b639838c1c9963cd0b0b4f1321d5409af932b810c2c3948cc1dfcbaeb575d26a4c975759f63c426c81e3e4c4cb9b7cc3e90b7f071816e4cc1d8be24a48c2f43737c6b172a73f746effbe168e676f04faf7a0852003924c7eee56a396663d2db7ab8e4317a2665926e957b3bb20d454641fda85364bc709000c2477a590f95be528a8484bf4dc8b2fa9eb246245fdedb618f04d6bcb7187f0878426f8c67708f43b6633324b19a3cd5d9c19db5325824d4d8477adcfc037a8fc5ee8313dc3fe4df5efda9d817875561a8e498542c1b73729857c86838d23f09b199d2341a562c52d4926129a2ed3656aa9cb917b21589fbd68b70ebcd8761cb9b56a82b2f4b33a4e0f9966a8c4ee1e4c76c6c70beb69787203d49499de08637b7ecd437238812e03a2147f4fc9fc5b053ba39b73f639041ede25567310ae6a9045d6a4ba93c85db23dd6c6de3a50fd9d8db1f4d22950cc8525f316b4f7756affb03d33959e3b614399159a6e17edd4a69c7c80e1b3ea6444c8d0790a5cc41cb79dfd9b049f9b672de37a17d65c41a50ec4b25a0bc507d6a42f15d568a517dbf1f6c82241b508fb70e04fefde6bf5ca18ee12f425bbfc50f89b9cda574b788cfd8ed96de6fe708315dd70e56dbe6f6e72a79192ecac07a3f00360e0e53ad1fb6f9ae4ebf59adf10e2733c2bfc3dee6aacc938224edbecc1622dd61448edd7d8a30e78de26afe8f5a7b95e3f70a39d286bb056fa465ddd44880fbbced34567e6cd1cc0d905090bc5697216a0ab8c6355f02104d889f284c56afed512447d964b0fb0856f49d954d19d5451ef26c1f071fca83bb194442c5296dcba951a229c81fbd87b68dd9c13be7598f22d137426747e962f7f384201e9f0044c187f63fef48deeaaf9498f3b5a5ecc30426539c6bcfbd1a9d6737570e47b303e7ce80bd62bd4cb855c4ef01a19ce124f44ba1495ffed46d341a2a45b68659335b9cb1ff857b56f84448b1596fb124c96c9dd146650c9f621e69b34133c8658e3e278cd6de00e9d470ae0e3ad8f4e29ff230d3d6380a0d9f316e40c8d0cadd76684331e63ee933538b815ca3cd0db48ce0ea44eabf5a5351f576c7123cf5300782d236ade262737790e71602def2a6c76af5ed2f18092ca56a27ffccee5b7d222e348","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
