<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00fa694e0b1604f7bf82d9137e49db9d7e11c9e63e7d1413e5ef05b1e3a655e26d9a4ad2d50bcbd8b5aa9f5fa993f700c40d4ebc4cbe9ae64dedec7cc06e53c27cd0ccaebadf384c29d2610e32ef5876eea23da3887fd306fe20189213a7e271efebd65901a3b635810464c6e38217d495d25c5ffdd8ee67921e146d46f0624cbda00e1d02e7e05a0f0910e72f4c3b73cec6e143b11589a1fdc67b0ea0de30e00bb059ab9092b9ba7fe2dc426583c8391c513be51851fed8d7b0c7bfc8532a6afac24fa437ec69ea0d51eefe13d1f53576154bac684bb1bb5a6e1cdd836114ea4f526f25147480f4d5dbb60b3431d5d3f1df9fcca4eb82d0e777e3bdb2b9db9d8725803de521310802d1e912dc633d5b12d9954d1a98e96792ea5adbc4f6d664c9fc0f20c3d631cb26ff67e8980f6ff6d8f0dcd319c96d3a6dd363e1ba84f837d410bc5204ae25759f4374847b6701f62d7a078ab066145cb99a7e979298bfa30b057a0fc4db53287ee1022288fe5b83ac2fe60f636a7788d5e6aea072867137ab2211b18f19ff8e5d1dcbf1cf5fcd82cd1f239fa817c1d3eee17dc16c5ba30530b4f4bf92d5cf203257996578222806a8163f8c3b487db1b06c594ca1035549796e4265674143320ef5fdab2f67ad6e081e42807d61bdcde2cf686a957673b18ba77b69e49bf36795756fd980f24ba6335aef25f93948e615602b03e773c5ad356bee9e90cfc96acad7d4ffa8ab076acb163247b0b50a38217421377742fceb56b19cefcf4a779929800fda7cb63f69a026991455a69dec72cb2f192d5afe6d82f949697375db7d750db4af947acab51a67c461175fc1d787e012ac6bafbb9b4fdc87c0e94b2ac58155012cdea0cfc8ebf4d0724146afff7011ae8eb0c9ed13f23dd2f5a78a37f762fe9d45c48ffc9033f8f5123f3b32b267443d35e6bef8ccb68dec8d6e5af79178b8adc321e6e38828cfe17afb1be848687a825ad69be205d35f135ec154169204e5a18159b55f10f934acd265a45e5262f17db12312cd799eb6a492b47a9a3fd1b05e5c0d569ead7afaea7bb917060653097833ca52a421a14b116b8aa8666d42395d965c74e435165316b63cf110aff1c6bad6010d597b1ea22f013c6aa190b9efb1043b49b4fb6b2d361e53dcc57efa833992676916abf4e679d62abef1f8a6a9ace23469f22ad6d9ef3e850030bb337171e3ab81bb76e47c0843adf820ba5c2a76276c5072b0c2035c043cb336dda795053a4a04a98a17b5e886a0a535a774aa2eb1385f89862be90790ec476d9912bdcd2d1695642ac26f226345cb70edfdf43315873f59a53d4c72d3b4430c58c46853c8f13329fe3f8f801cffc8efe3ea49761c23566928534ac5e40bf7d07f8e3c8af1d678321d954821a52a8117912b911da37f7f2f7c23474e5a4ed58a43e06da87cd21edf10a8469a4aa046e79e3bcaaaed4974135f0b754d1a4fb6e644caf2f24054d5fd8840cc4a575edecd5ba27bb3f63030732eef06bf50c42ccbeecc7239be43f4c79d9fa8408e1ffee35969ceadabe98ff5a3c58a7381b55f656530426e8a1103062d4f78fceb1e133e09106863a48e09d1727296162868c3ed9d29a08f72eded18e325a482ffd3dcd6dc8401c840c682161d5acd53c2ebc43c6fb6886c087e987bad76c71b804a8b6176968448bcc5115767b1596dba13f6384a8af39f8bccbd975899a4da6acccd39a6a59232a4f89277d262485a1f63eb29724f0c3a139b5632d7d7ec61d02539fbf7170624c4e71b394c8bec802926fab1f72ad600f7322eceee9ebfcd2050f909f821c69c7bba294908672c6a7080f806f9f3981cb5c048113b5a2f382733ee907e3ece8fce0db9e20785cce8ca9003418082ed31818cf78a0f3a993be4dbaae2b7ed65582cb618c883ca7ee703ae705626936bb81987113520a193eea023d883cd9ab067646d9cf20b553d0eec4a78b93accf5ac82350fe23ec18a63dd745f460465da15022b7a6ef4db12f451002b30cf0f3bc715c4a77b6a740cc6332d070b4dd162a8873c3656007c4344cf6aeb9e81452007d10ec01abe76907c9271e04120bc49cad73cff48ced87cb374dea893b96f31a75dbcdcb9dead71ee47e3adfa73f73bba1d09202aecd7c89c1d5edfe75c2135c1e950b40bea25576e2f5b11c805df1075bea5829e934c369b551ef60e9e477c4ead7fa7bbbf367387776eaca0d454eb0792f4400701207bda63149f725e44374da812ee82d45a44a656be2a0faea0412bd05638994302217df15958640c8a2b9312b12a0c415fa9eee7d2ae03af12e6ae9ac147e3f4561d3fa6b3b69ece85a4db248c07e0151f97c3ae36b1c672819b25a98ddf6fd5f3dbe5d634db8f24be148ca78a7f7ef0e65309209d98de815793a90c52f15b81c8d512d78bbaef5e0d7081b45c13c4d85d1ae9c4306d9f57e95950627909a6b8c5342c0dc66899e215785dce7f51012374310e7a8b2fe0318b95d96f6964f075ba12b67ecf5cbdf48d6cf7e6eb0ea6c410dbfe825329295292f4807686d0fdf7624ad54ce7c3b3b3815a9ec403636ed4a7ee3ca8156da6fdea3e1deffcd2dca160649e853825d68c246133df8738caf3fd1d80c94ae5272cdd380333d032bf7e02d87231c69cfe81428427cf754718d93fc9eb5e8d9d18f33573845c1ddfd894618295b572be20d80e6086e0aa7fc01c598d85de92b51d02076a45acbf5bf4260302df776d7328396804b9972ac6300804fad0c6af2ea947e02f378f63b2963954be07292886b2684c1a5902347d0996ba3e6c1686a6e4f480c0b96e5b4e74c8a9cd279024b768e2a6af3f159f9d57c5c634db37fd11c6ebe6f6887e8d25db9f1391590b107776d41be1e6a08ccc5b4473a9e00059eb4860bd7e1ed083cdb664e0262f640c3f222c06f5fc2b190d205b00c7862680f57472914c3a30925d82dbc38b28363a3583dc5d1a99026453c625dd579e6abb09ddfb03e7858fbc3f7c4592b07d2205bf6eadbd01b577dd371c159892f242006df2c1844674a229b5c01d293227a13ea0e22bb47ed1f9324a0cedd1cb2d4c7a2003b7b4afbc97600387965caa73ee30fe43e12d69ba0c468648504ac82c90b26382469f8f14cc6f1b0c5a7462249ddcfb6bf19dec1b72685b5ff50c6eae7f15a949e7dca2f675f37ea6b41b114556820d52e278adb71987d0b2f58b646a0a30050c0b460ebd7cb5dddf38ec2a6cabad908757e416e326a32bb6438d5a077bd5040ea2676f2480a141203539cca8d02eb71f317e03a68b4899558ee787fa5548517bf4222f6dbc40ab75f15ad56a0c8b75f8c7a498a3895aaf4216258807a3ca8ba1f730ba7d6096916730aaca72ff9c7dc4490665bdefdadff68401e55aa432c7366e324d2e88215859b9c289e126731260de5ad5a0be75ea7e8d9091b5332badf3a453e24397c13bc4750da6d37e0bbb198cf16eff2332c5c4b9ea9e6db5ef38befcbee337c83510c28870c014f99df5a9cddef8b7a2473f1b0c45e4c378f7dcfd0dd91bcc7c5a42b69c977373846675461b472170c5e3e9705e2eb373bae53fcf70fb2180009e7ed30ab17e967b9c85e8a0ccec36016bf0ddceede0e0af0d56fd7318724517fe7855bfd872b47058cceb33f34c20a8c5420b160ede582e1d03e4079acb3d363b59f79f17930fdbb2dea9ff15af730ece19edae4c15734cb07a0a775b71468cec56731684310724f237ee8f209a977aeb8bfaf34c3ec10533855c8436dcaaf6888beefef3bf75e6b5e9e0616b9575baa8c186415411e550dbaf636ff1ffd996e0abab2fa01a9f5689c946b8f2546faeee77dfd105317e704a08e2de144c194f532e87b411cf60c9ab8a82daf1981eac647f100307f4707fea2d06ac47b12da064a6207046a870e99afe98be0d27a6e83e1d555e352fe8326be098d4cbe149386742f8c138113cb592450f0b24dfdc62b0fb8f7f5073544327b92a582d4b7d89e9186e941eca383e87e923bdda6b1e042e08a2e54763353f89e2cb053d22dca5a89ff07060513c23314d63b7c26fde4472615156226ea146383ce2a06c7444781c3fad221d6bfb8488780cd32d9f3683a1852c2c7aecb60d5c68a24523a6e29ccab17960be33978d0da0da0e4b7503288cca9ef819ba080efb447321ac7c2a82d988d999e944542e5f9165c5f9bc4db7a8e5524ca06a929de32de42a30b349c6a97443108cb43b38930867be064b18c74c06c2ea3726304f48720c45064fb24e391bf1831c6f87f72da2d24146f6a2b28825252c97fa4aca37ff2d58198ecf7423401c39af74d1bc44510eb23920d70c6d15f9ce15c652edaea0d95dc194133a087319b046672b990fdbc02476fd2e9db1fa6137dc393fc06c6c0bc3cb831639d9a309fdd1d6003429b623ab6a9f9c3a13be790e53367a1e1028fb7ac295844d221cbce1558cd32037f606387caca5d28264aeb65343432fdb5d751bed716b74f1f26a5c71956d67fbd8970d0963dc33e5dc760c6b20d24240c4937941cb5e476cea19381ddca3e15112bf699a52776d145907203d160b27e1f2bbc689a0379ca94ebb056830f2b36fcf6a82276e4c5eb8ea5e656ff0239e6adc0b9a494d2f3e758cd212f3b2846e9bed16681f72d84cd526d6e9fdc6993c0a599fe6abe3718b7960d90cfc778e10a2d6eec3e26a84b8c77b83fc14b5a9904c0a8d1d2bd086c5c83285201f0dd9d381edba5831daf81636de81563d671283139a86524feb9442e074b5e5e5e5b2ae93fff3a4a03ef7057647d2acdc344a01120091bee2c4e2ff995ea61317e1a08dac3cfaf3362753e71ce9235e64b80d62bd47336c4b14c61f274dfc31c861bc90c20cd2202069b22a55569676eac29da56d455ce36946fe358b4f3af2fb127c581bf498e6ecfda0369bc20b44ade88cd373a06c3dad320ecd8b27ccd34cddcde519419271fb64e667090414f771dfc8a5406b3b7cad1b46670f7e820299344fcc400b6fb8dd6bca6f02c6fc7d1666144db2d430bd078fe203f31e299f95de33319ca5b56a7251f622e912146be7315e884ef564f6fed32a8e8e5ecb6759d985a9125cdfeda65db46895989741f668da705a0d8a3c4e4b146549a487ed178da223161cf73ccaf195beeb1902b5fa13e3d19365ff2946692f9794080f51d5ac928617b6d34e412450043a33d00614c2426127751abeaf69c7431c0473f2eca6a04a489dc075a6ce92bcca2b86ef85c751902a6f5b7faffecae5984a9addb9e1ebab26723d22e4f89d28036f3e36c2dce554d1aceaa536aea19f61fa9a61e0a4c1331d817c159a1fc7317ccdbf8f3fa62820f48f0b11b3556e1517f0b8d01d3dfbbb20f69ed2465c6e5c6dc08ec1f1693b64650600269938236ab18d5c42c2e33996a57c7b1e09f0cbdad33a95f567e895a695c0812326c968142cc0c94400b65721cc4f6c712ff8a8548ca2722d0235462623bd73a428fdba3a0828420adf91a628ff662d94c4988d3a13a7980ec48b5d7fd4956d9786fe8284bb995bd062d38c97fbb3e28ecb73c4ec65eb473cc2532b12d6d19d185c9500873e9a33e3b3f7fe209e4629a6c74b14478505d8a3cb6c15d303a824f44cd75c0b51e2aa608be386f04d15c93d9b5cdbbcb4d470dda7042194702b478453278136ac78448aaf52735a6d115843ffd37661ec8482b16323f1d84d925b2824ca0fdba490bd310493e41606eb8af3a446df97f8495a5ca5dd3c69eae85712480ac432177c3f5c250cee222e4ed840236216691421e8125579c96f28ffb4817ab50000f01ec2df34fcfa2edb2226b93f5b8cba3d4577ff491852c3fb3cd062f223b9aa836f0f12bdcf3712fdc9003385906f9c1d0c5be18dac342fdab3dd9e2a4d133b0d49cb8ee234cc0e80780ed524e3b9f3915e23cefd0e4ab41ccbe44a0d3a848038e7935839e53b776a3676c3a07f310126f9e84061ad9971e39565df52c7072ade06107367b78b7d7ceaf9387f36e7d5b20d513d5e3bba2bf3f9b2896320fc24acfc1fe928041f652cb0dba2fb3c0407989927d1f1eb30c5eba042cfb037fc1f47876dbebd87b71733203f09247221c64b43d50635a0b243e2ccc95c6c580ec2b02c342f23f38970ce3ae34c6d0a3c876bc845456a5924249e7ed2ae9c81e9db27b0bc0eddd3f0c703b92cb8f0a5af321ac04f60f274e5023814835d055ce798f594fd37b48e62fe2c534ebfb23269f99283854b143ce14a509a59591c018b46d911ff4c803a847d4380750f774326f6287879fba97f0b6acd19e2c33f39a6fb72bb8b3818f646d6ebd0ad07aca1b70e48ac49d27b1c137873a451a4e97d36c115e954cedf1e2022347aa3eab34374659c95da3db68ddf3a9e2cb16ad1a6358b947b24342e9bb813109ef7b8453b18a49605641bd9223f38ce04caaf39b57276c3a18a8c5e3e5b17f859f35047b0b08e7cb3ead059b2ff83fce1ba8082c745142237f219c9a00f43f5ee8da9386c5a34e82369bb8c34df50ecf87f4746f568b1c4c67fdaca38c941ae319f6b16f8ae44cc38a0958cd541fb91286e1b56d6116a4c0f83b33878b916512ba038f59c9e4c01d5dc47703ee659abc3a20248fae3e26e19d66383b96fc307610e26906204c2a5560f62ecc8a38eee707f4d97022f35d0917d99a728ebb58c7b51b933aef531084fa65057c081889b36a07c988d3fe9f2244d9d838cbadb3394bd42c227e83cbcfe8b59a6ee4adfa6990c820748be9ee5637ecf10829480c2dc26cd20dd5bf6e8d5d411855688e72ad68ac9a4f3f3d676e40ec70b3f453bc4073608a40d9c262ec7cb73da7aa1381f3ebaca27888686654682b53eb621259543d70462196d477100b23b6dda1af85a2702a6795e30825f7fcbfd61bccb3dd2864f482d31c6a7b848cf83a91449a0673bb1c93428f9b11c83a89c459b20378beabdef21463ec2539a7bef7d2ede84527441636e7a49f92796e45e1958fbd2e354e26d0fca29e89dcbc46d3b783c3e7beb8c81af64a78b3dd3f4ec6d877be653b51c8b39b02e8ca908d7ffbe5b693fb8c32dee77f754cd3f230b3ec1387077c2bd96847e9c6705b3bd01d8dfff93325e13540d7b6e9083d4b1ff157850e65ca100dcac166d747509850927c46c844ad6a559eea9dd5a4ec8653635c166f3d8d2b648b8a67e225e07a84e5046db8efe1f5751f6f22c05b517e1278fbbd09deb1afda2ad3207d739ce05d0e3d1321336c45e857a16aadfef7f60d03fa4c9bf9ce54dd6fe62be78a50011b2befd0b66d9c03f5e2428226c14e98473893e7e2187dd315ad85951add9ad1c355644748c889ac246d6e41ecc7dc06b9e7c153772ce1b3e8742943456614162616c82b9903d848eb5b8ba68c8f0633c572d837466cb87e4e68265db7ad6830d3aec102bfb6c30d9291ad861c3a2de36d8915a8abb25d55c22a67af1289df99dce48dfd4ed2bcaf4e430bd499bc2bb0d02eb6866af51e54b50401f88cdb112aa42bf32b417022a82ec5062689b0e92439630fdce26d654aed9f14a695bdc073694c7d9acf2dcbe4daa2f08a3ff20de9131f3c1a847ffa7ccb64c2e3bf88e287aba386aa6a304004181a8f5e67b2d49ea8a36c46ded0007219631097d6a9b68484f060cf0135846d1cfe26db4d4e5aff1592047cd4a0c8a0c66c93f3465341b072cc9173697f534f799111e0d3a97139360c670ffc0c6b190b4d5967b0e00bbbdb644ca8c2e59a79ad8e89a62cac616be136d0a9c776cfcfa5a647a17811f09b441216ac256da37667ec69cb28ff599cbf839eea005089413cf5223b99cdd66871696278e84efd913775330669a2fea8f03f7dc321561f47d3778f683f689361fd3b942e18a9f5377c248114b90813b6713b4e3f8587ca166c547047ece093ca0f2e1359f0e241a61dfe9566d1c141f1c9171c31f47638b1afcdce0f06566a2152343fa5df480cfb60ae26a123cbc0b5a1b08e402a571336530f16b2c10114ddc45d4a0865a65254e95a867092990fb4e2022b0db732b45040ed170bed63f515f6396a3f727e679f22f64a1b83cd5c0f7f6f745676b8c09525f561c4b6320d1495f52c341972c1b980571acd360ef61a3143aab8c34fc82a06042b77c19ec36f3afd5ffee95ff746984055d4ee0b3c64216d6962122eecbd09740374ea3203f5887068df162190910575356b42c3252855f97fec9e425ca86416848e9b885eb78996787ea85938b7da906020363ffca8054e8e6257224f5e979cd113395f9e9bc49b1a270669b14cb82a9ef8541d18ee979e23e514ff3f0f66957d1c70b96529f3018a9ab734a424ec51a15499aac296f2cc8e0892cdd63b2752aa90267368917f0499a281223ecb89993666bc391e24c6995b1baf5273c3e80d0cc0925b128fc3e0d9a95663e140c9fc273daa3247e078dae2325311dcf8cc84ac4c014f6544c6b9fb8b84baef1083adabe33c5dc95a28410448ff9cd7d7d6a0e80c578dd6e9d0bb9217f1b0e95091c16d70e217f682dc748f46f3bd88fae91ae58c3ccb326b130d88b102a047e69b56731489b3729227b1a2742cc8180fed3d8321021ed5cd2121a0650b865290f246b204d322daf77f1bccf8cece825182130cc53e5fe7440256ed6d7ab100720a95821bd802066dd904e436cec089970777c0e973871a3a46f887d9715deef24b3f6002fc251ff6e4238f74c604bf93ff43657e9b393de871ce11ae44600bc21d410b495bb6055ee62684534f64659dc38f61030023df9d22675f27f81136748ac2cfd1b9087f7582b8d21d191df3c4006e96b18618568f162fcae6c91a6c3071da56960fcc4377f47e98af3041ce4a8f1b92927c363a9d9abe6e16e1bd4d98f031866f34e97c41a3ec48769eac2377207b90ddf76fb4ade2c66a3a7b1f69e12e8b7cc2341177fd000b75bc44ef9f94fa34d142fa33ed186eca5215fe541931d5e3ca1ee2ba15e6dc8e0ae69414b635676f9a47dc6e8302fdba824e98355e932b0e9367e8a24c3627680a1095d13f14bf55bf0be5756fed07ba08fdcd6ea10f0af6133f944fcb75fed8388d0672fa057103c76d594e564ee589ff58dc22a7bc7baa9d41fd1ae7af418b729c19a18affa71d971ec55ba1fe1f2c96e78b332662440421401c0f8bb52aa2d7a2286c63a076ef11b3054232109c812b4174ad9cb21d0c5272bea95de712fcff756de36cec42d714c9b6197cbcafd49ca540c7d76e4d25f657fe7d38fb83b876c9c4b4d1ec049c71527cf63843893b763942e08b7996288279524403e4328da4620f33182ea08fc42720adee9198b21628f1e449b7d7d66ac00da5f501f2548f9feafcec42a193a39f0a368b6a65f63aaa5aac728f2b2ded966f9a6ebfa1cf46cab1bb4047b8feb56f4ee5405d339fc571bee9e9dc114f49329d2ba880881ceb335a4ce0ee9717184ca41f0fc64085a9cb83535580795e70e5fb5b3e9cfb0ae0aa119b5567afec7c3ccf5ca1783618c6e5bbb65aacacdc612cf1b63db9b6d1c30fed8b2ac2377e5eea32cee63c3ebbde8b1cf91aa2a9ce01fdd7563d0b4c327c2027aa71b5b8961140ed8bc3e411eb8d3a90e738645e3eff6b097566f296322bf23dd1dd20d2d258eee3aaa123a4025831a214c1ddee149cae3e61f4f5c8c31c51b852e23800bec19639cd8bc2ce8238326cef9db37e916dffbe79be490221e8d89a208a17edd912c01d8acb4fff9e357e11621c7be3a823f62e8af5b6a327c847b09f0debefdbdb495201eddfc97d35408909e37f8a273af922d490f68f99fee931ffa6979c6c22618d411f2205ceaa84a9d838598315752b3a490f045a00aa17ae0ad8def3e9e5fe9d7fa61e3c8ad22383a3efa179afa357adcda5eb9d5019e46167d437b6f06925c25ed45b156462303f7aa8d8f56346a728e823f2e2be14ef7d6d8fca0fe434ec1fcad3360343bf426dc82b1723fd520ca4070abb7dd6d297801beacb199d1da615c439049999134dd45ba34569faf680492579619c9a575f2f9979df7d294f125994c6ca036ccaa472ca2a86af542a06878e9181d550150a8a478ec8decace63c4d89087ef20d11885e66a73452e58a0d189e7d3ef41b37d80f51484799e1895fd43a84ce45563ec64b10a7ab2d244578023a445c8359554629bcac806583d21296bda39e964e2a796a08872dc2ece739f676bd33d204aaaf104559509faf4a365a5c27294f30879af47f35dcc5d0fffb8bd2de114c2cb23a3021f720ffa06403defbe6a20d437760d638210551f04f77a84d4c515b9f501b2a1ce38793ce65add23aaaf1acadb97b47cebc023e6f6bd0902d7ca02beec39fdd4055ef4b1985652cc8ed95930a1631feb176b7891f30012e9d5fe5361280dfe4241f10d6b60257402840ec989816e89f4e286a80cc763b853f8b18b9b864bff3b31f1763ddde9d405c2326a89229a187fe97fdf9493b158aad05d7f202b0a7bfdebd5ce4031b66f60112a30b46f44142e6656ba9e33aaeb8fbaa4a612c7e4c6bef9640cd24e8a637446e13569e6afaa56177c608024bcf30d41a60a1b209b1af371eb85d55cf5bf870db65978ab36d8861b17a86c7cb47658ffd9c23e58f4cd04bb951fbcd28ce93df07ea4e4577693ddedff43ac8e93a4eef09f64ab7a67ab848995df551bcdbda4263821cc6763e3ffe6c2b6e70cc24f870618b75b2f3c0f18645ec63e0feaf62dfebaee9dea57af56403e0cea3c57da8d507cb6afeea2f81d2125c44bedc23c21012428476418ddba9d0eae445b665e84b7e22121b88a4774270f559d220a3b40351f12eaecf12245a3c7c228ec9de9de6db3fe976a30f6de0b8da9e6321aae503acd0c804fcb7ccf2be93f4e9c6f9465dd5788c8b2a7e901a473ae844a3b29cd99d9314677bdaea0fe2f3ca9eefdb5cdffbfcb21bc59ccc6b0c1595c43bc7fb4d05f936d88d81a9e438c7375f3eb3b2188ea1d95e51ba91b5ba84b460b9f37e23a6306157ebd3c3aeb71af0a1f0d232ead6e092d3920370b50f13a20442c665989dddb8cd9125d957383dbd362fe6acb9b2834187c9a967b768d92c3daf8a7f246ab63cb634a86c0283131cb78a93a3837a8ab5787136837b9dfd1cbec9ebb9bcca816da45ebf502b87cfce342aec2331e8752422bb435f58362da6f665cbee72312cd65d05df7379b43104996cc8cca6e7af0e27f9a4807651004ae6040f2322e5bcfea2bb8e373f166acfa33596cfe1c0044544ecf17f38bf9c5b54da617619c3db4d97770dfba0f6d6c5e235cdee621ce3625ee6fa0fabc0ae9f97646f2e2625b5821c67e1b7d6e9158848e2a7f4ff93877cbd1a06d4952c8bdad9aaabdcfb7d564a7dbfa9a06b2432118ce1f5b226bbcca35a1371311915456b6b645d12d2084af2ebb5d4cdb173b34e6c6662dae00c7614cb07a793abf0e340bc2a0aded1bef7a4a8220485d88863a65bc674339d758c2194b66b55b3710b1a0e24d8cd8d1ce201e36e2ed9c9d193a0b427617f32e70b8893ea091f46ec49a7e2f7d81b2595cc841b1d643391b1992f7bd70fa079badc1f6adc89a859b3e8497e3cfdff6cac64a728dad7bdef74dfff64f28c55b3ea05492eadcd95826bd0e9a1e07a7296fbbe1b4033de6b39198a4c175e7f267a246e7eea3bfbc332ea134bc6785ae5b30ca7556a0721e8fa86c0a85adb61fac5efcd1194618e65a606386b5f1c8964e7b73f824e5aad43b93e028bb11bf46efcd44d46edda9074184a62defbd995094c3b6f2e5a7530ac99d5aad013665630acb3c2b39d896f5821270d16cc9f2f136525f8fd7e5b5391bf74a376af13acbf57224cddfc8cfd30c4611426b8ae1f75ad7b863282bc5fde1362292e1c679f9afdb0cc4ffeb51cfbba9c56b48db4d761964c13fd42ffca68fe326d6445021448d187a943afeace540e19a61d47e8d9c12ce40e5926a1a3754c4b0809279bed53a48951d59178da3eb0384cb6aa06d9e7533faa38e3ada2d712d4c33ace202d2d2036cb192e99dbbf9ce1de4abe73bad0989ade47499b8d500cf13c2fe29088f76c8f0d2e3d5c6b7f5b90e17d9aa0b939fde6da171f301010e3c51ba056e352722d199beef7eddfe6a253af03aed2222a1950f24c8ef15b785dee7817c407e6bb8c4baae3bbc66e2783a5b7e27e6d5e74e97d8edc95af05479b66dc4634ab8f5d7fd60fdc06a06286a893de13c1b54099c98ab4c18388680ea6e860a973d34c09e6f0d7ced1fe6515ebb33e02e4afc8350f01465e9799c3e5b9ec4490235fa653a631ca6493c716973d74d33a52a5fd3c0c291587a8b09447c232bea5a3c78dfdcb8f4eddf02835bc61910f8b1c6dc19c41f7984b60a4e2384db19808cfe159ba7ead1ba9e4f6f7a825ae9bcf2a951421fd1a2455e8a9ab66ed159e5a02b00508f9af0937f066611ddc60f1bb338fb0a20400fb2e407f8afc5cf8c8da93b1217aa367c3887301233d35ef98e8853efc427c0bc7e40f19c6d17d980a248709f5273bc243d27f9967a3772540be677f16646fa901fdb4224fc2b1e0d65f67423d9a2839039bc750c1b5f329b06ec182397221dc545157f990e0da0d1bace08fd269461c84f85c268567b1ff06fb8474632bbe225e7940551d64d495bf58dbae7cb107876af7ed1016d34244a9b60630856be7c62f3a670bc6605aee177469172b8da0bf391592f57ad3e2eb5a91a1cfc502710a00ce563fc398bd0c3008b2c895dc347e2c7a693b4e7b2d4c6823b9acebfefe62ce56fd205a6722172723725bba584345b89c063f472ef5fc1ad4d1401e8c767be4c86b147acdf992e0a73430493bf062ad1982c6f758f8b6a1e571cf4b101453a4247c092d253e3498d16057553889204b771b132fb012c47299108324282ec3b5bbaed8738af3125b07dca3bfbe3119b3ec08640862bbe9d7812cc18e55d2902dd880e65ef7d3ebb197f2524fdc84f5ee0d9c65d2d3ee46660c694ba5f9bb663c1328e91c926fa6864648f8bd4806a2aa2d64a10fc905a22bfcfb2b950b8bf819f918f636289465c023420ba771e7f5628595f42ef82302f5ec9fb5bfe668f397dc7470cf2f709d97e9d5c61fa2fe158270e4a69d6cce36a0c36c46fd3b94c1a71d325b9301c1ceedbdc2e479b495e7bd860a5f0cbd1454bce58326133e62a89c9bcfca6a0fc599cd83c933fdc4f74bc415fc056a4423967dba2419b19d099a0fc0eed094eb093015f980d457b63292ef05647ec14782c351990fe4aa79316f351b508c24e806ac6b9f2db49bf4948f1189e0e22edb1c40a3ad751ebe99569cc5f372df04ee95bfbe2014c294f8de470fe69e218af556d17baf95169023a578aa4a3090196dee85c9382acc3a8ac1817b0d9c175cc8370f8ba4f4be33df723c611d57d560660ed44fd07a5b0e0275c12926955153d52f3659a8dfa6fc6400ed81c7b2aba58328d8bbf3310654932feef29cc0877e046bcae6f2172a0ac292898ff764fc262c7c3d93a3f994c56cd599f3531a60a29d4a434e5da8731963d8da5f8729c29ab60eb9a2d66f284f5556a81012b44771f440c4388077d2c12e7051f4b312e0c0cef9c39f8dc13fd2b108c752e6c265646e8c1a165336a913456f12ba21c318b2c2ad186d82ad36409d0226f54be9e7162ef9797e4e30e7894d916c1729754ca98e168ef19fa471281b8e105b432baa6822debdd718eb1db0735a5b2497d212e66ef2eb6055b13126e022d35cc0403ddfc586467ad045998a60b19645f265388b559a202c005eba96b7fba024e41a35a33dc84b931f21b21bdd4ceb3bc67aff5c222a29a3e44e6d05e8ff88ad49a2a8021c679fd2acdbe30bf9d2d9a262756bede5beb9d091c8d5f23feaebdf70cd3846d267fd71b7363d85ef768fea6c7283e2be5f45846a18fc705174bb6417da951ad08d7f4b8018fd95997882abb53e53c55ccfc82c323369502970f11bc2542e1c6d3e02af93530affbaa070723686b8efc0a6354fdf2966e7def7f14255f22a64de459c01d77d38169c7119228bfdd095f81771caea9fc41f66e6bf8064aeba24f6ae44c1b0ff8d9cc5fe79346d791de8eff93d002ae8c457477c4f6a07da13c53f2a54960ba2700e2d80e63885fb3cbd7d6537bd3705465c6e09f9a72f5b1a5d193f7ede6cc142619736b9832b7634a3b2a606f227b82695f77759332db2f5115a4df80d0e92bc9f9265a35cd388a8a0e1247e2dc7123341e0d75aa2f43be8a0f81dae3fb8936b4a7923d04ff1917aa32286f8f8cc39713cd94cea5df53a783ef13920b447f28426f604d2368912858436cbded88e473c34839512d15f3045d01d9a2cd5fcedb18f9f05611a7e5f92c23e09ada059a69b13ecf983b38dab3572a7135f7617b4dcc3ff05cc544159bb40fc1d4c4ab7b8886e1953870474e6a6ae7792cd42d404cb7f40bf1a8a5703ea94959e62cc2d3e48535cdc2a9895d6816d366c60bd26f09ba436216d018a20360e9524f5bc13ca9ba0280b721bb170ad3def6a7a952bf7c4b0d1e617ee018e5b4933d29f03ee07dc7652f0e15ee5bc2f9627ae30880bd9c3acbab95c86096f7e912ec85a3cdc4fa3b9417c105341a3a0b94935334dae530ee97ed8cb78b49a7dd27cb10d3e1bb2a7ad857af1b1393d88d0b7a5c803a137ac25d216fce45569d4c0c7ac844fd1f47604debbb9476e7cd59424a45f835059bbe0759e1bb126a0809de424edd9cc886d9550b98c34bcf2e886b67ffa31e3bbb978b12d2676bfc1af5724e3b5dba4cae18359244edca9382d60a6cc7e7977bfaefa5600fccd7942d7cd59b6d66a3a282c7a36d1fe98d1464c46679e64203befab43f393cb1a619493c753e3ddb127f5399d2d2f12907858946f41b60daa4f11f37e2d494dfc5ed71e40e0b1f503bd77c44ba30b09e56322d3c8528f343243108d9ee023db300554086e007f9990e05378793d42f17a31b6d6755db50c348d34002409cceb593f68314039233853c5e2b25401f47d7fb0df959e18462a1f8fdf5e60273733c734f4eb7ad2afbfaf985b687cdd8dafd0d7e4d7a5b62e10a540e2ae22af94e7055adea6bc08520aa8ed941fd3fd94657af4cc6586a52837838489e782015f8085150ee952dbdbb2e741b3a4f15c58c5500d1113a6533bfc7ac4ef3bf54d9d6c24d546c74514f399e445ae1e922ce352579f3d754c05a9a2161a330c67d2601089c62f288ead054ba4ea691dfba7257ee8b220bda0768ef07540d39d4b5eab2f647be00ae6dd4b61189b35a5a0a09682b2e3d6f7d7e1ecf25c80f0e30cd37b3b4fba0b2443214302d1e9f36a1189978936188393f09e10fc796703ae1207c9c84a2be5bff72b98c756f61e1c472e8fb3a7b8dd5a3d88ce9492de50885140d895e7f7b2bc9493b4b5d2971f49aa9d025f4884f0e0f49faa1205ca117639a8b210491be2f71f999021bde520b207b8c2b68225f29934c23e21250169c0dd47bc880677f0d9135da270d9bc87c5dd510e0b4904b57c128d8d5337df19b9365a7bb077af97ce420e26f3e25f29ce23fcff72f1dd8f8cd193bd03bdd5f99c6dc695c1af58295c219cbd5f4e0b9313a992f4dd7a29db12025868c737d9f70b158a8db84287ec015cd1470d81b6c32c9ba24cacc05486e2473630b938d5cc4c77a3e432764b9edba0aab40cac96261ceb7e1a270178bb5f6b9bfd339f8cee3ae6646910eec7df7a2117f040a73a13d9d6baaf9943df4f95987efc293b92b93fd9b1a571a50525ff7fbe6782fda27e3520a84f0b1e7796b89c2aa8024662836e97a9fc29c3624c2a3358c05db021b3434892348eed9298f7b606c536b43314105514f76930cf7419f8cc1acc2b0d1c180ee1f554b09429f45ccc5b9a625faa816606de629e5f6b8ab67eda1a7407342410a8d9135bc6e5284cea542eced35337159fba5abf6b769ff706b0eee1566c8c41b2476df1f8a5adf022b802ddb655506f74e7c7012de4eb4ed3d8de8e91bf933ddb5e39659a8b1e93b925379f434e0d0225d1f233ad94f2eea202fb7c8e70609bf5bc1889db8fa2af35476b18360baf41c13c9e48d3e9f72c4c016c2f906f7bd8ab02a5ca1f0f37b311513d8f9cd3de1ae9458c3bb51f64db92c5e4d79d19fcff80b96bd2500ddd71673154fedb7c269f679bbc31b892fe7035b61bd2d5263633e824a42cfa7576a800222a6f954b0670283a5d5246650a221041bc3f5a120a9b3040beb766d536459f7d97009097bcd5bfb40f2789309fb15300158e829d6753198c89ebb2a9224b3580f2a97356ee05fdbda9c9a69f3ba1c834d292ccf52f7e510d6b4477d1a80b75c10dba15e62d77c19cd9666172e5f163fc102c33faa0b31f548ebfd428a1aa7a9c5f3d666b53696766f7f5516a84d10ee065f65d8454e65f5c2ee9831a5cb7b481666c198fe2c54d5e7a60a7e3b9fedd32048236eb31f8c840a99d4ad3f57a4dcfdcedadb0549e7c47083bc87975e81ff21fa41bcf3accef6169aadb2da7e4effa5dd2c41be2356b7a7969086382af850baad748a80b6309d412f1340ac89bccda6ded0470b01922fc5690df29230e2157a24d9b68d38345cd076af9d0f3eaf8627b83153fcc7d767f14a5adce29aef11ca7f8723280812728f300a71bebaeda61c67c628724a9ddb32d6f2ae17f865b624c3a08a2a8ee0e99848a4bc28ae00bdcfd0ba288f84b311732297e559967a75b1bd5d67a6418ca22dc49ea5414ec978deaf9c144405899e9795eb27f572cec02f8c6a719938bd3f7b5e61aa953ae1c868c983d8c11037bb963abe6d8740d41d3a8016dd3e0dd8fb398cbc2fe0aa21a0f5761bb8ba6191095aec196e400506816e7f16b18af467fd954268d52ea1da61dddda5a69d84d01b433ac6423e07d739bad23d00ecd2ac4d37ce43b6a6da6e9f5b88ae88493d3293e72b03f8fe53d6920e8d718b1f283e9a195ab677d55db4e812f6ded38c2bf763864a599c12adfb4feada1475942836abb3762d476cc1a15c8ea5a58d5d51b7e411bc25a0899d7d333337107b7d71e9e587a9ea83cdca63a8600736f653a82b797e0aaeba3bbb5879f1d892b887ab9eae0c8baa10bd81905efba5ae7db11b432e89fe9ba1badd4ae58e2bc04be5b2828aa4f90f8da2db03034efad987c75ebab53491bf5e31d34230bf028f16cb82b68c09bae84107f2b69a00f5b800010e459fc187d36558bd3a68b6332a30e62a225e2818fd507bde2c9100fe87c7c90f1cd5808106a651e6df564a6c4f0f4812376fdb81df0cd2ae8e41fcf5c3d1ea0ffe1f7af8071b91024ed143f84b87b21d13dc3ab254ab0aaf9f72fe104f7083cf0ca45e28eafae028d67c82f716a5c4f0fe1b10759981683a0781387fca4275ac36759d29d128fc806c546ce679d97a654ab77ae984884538e1913562f507bf1ffb8b339b6f578008657635049afd6f906d0ae7eec3b295ee34466748212553ed937973b3ea8aae807c2ca4f244bf266bf8e86f8532370024ca6d3ed4855e4154eb3fbdbbd3bc98ccd0b2467bd3e890df1f8245f6a8d2877cd0d85dc229934a99d251645b5f6c4181e50eb6f98a391c27553db977bed4a5bd8b1a6a087733c85199ff6f41c0f4f875b7e8ece353b38f021fa6f6ad6310a3e6873396622ad21f295cfb70fe2d4925b81d74fb00d13f82dc189ba80c00ec02888835a2acf370872896a9a46189b6c4656d3388918df355e66ff9d125eaa2e53edaea59ae485fa20f9f5849240a8c4b83d97daf0da991362cbe84717ce6fdc8f7adc0e78b4e0bccdcab8dc8d1dfa54919bb82cf5dd515d3a23162ce3ed97a5374f14d324b6e45e94ff0025035b31a9953adc9901b36762cb3b87461cd1259bd508446b91b71d6baef63086ed67277c6914281b388e5636164a9f3f073160a3b40cd80a6e769a5252d4cbe130b28bedd5f41df170435e63932770e345d59a3b3da3e8c57325014a8c5b9b4666e2a9dba1f610f906d78cb8d5465cf78032832a402fbe581a639fd88c86c7d872fc0e5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
