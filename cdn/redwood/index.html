<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1571218137ef945d67a45a18b68696db4a95aadb0029eaf91bf47a3eee0f0d5974ba920699762b10a8dbc2c16c018278d9c826a57751287414d94685980449a8497d4439cea706210ea854e2074bec19f68f3a5e11c3e5ad02ff55344bd1bc89f293c2ea041cf1ac00996b79b3260bd28fce49f5d27de4ac02a40039097d33c7f785611417412f8c2a9f12cd758498210460270b0e258cef06e60eec1b3d222919f1d4a1e4ac3c4be818e2b685c7c910cf6964f471ac290997b8f16a1ad16591caf82bbaab9e715fbd2638c198acf699a3a000c4129ca63781a6ba5a539d1f5f2a3ed3b2a22c1acfbcec58c9e92525058b7f34995ff9a6aefa575ed4361c6552aceeb2fbba77f2692ea694a7aa347472c5ca8ac9ae4378a47c7cb671d42fc097654d5830b86e16b7736cf99df3199e99490864bd2607efbe01cfd2027f1bab5c4141ab1a41eeafa70f36bb714c925d570d13b4478944e7ee4dfd40cf1bf2b67f2c7c03799a0175dd4e020489e9a3fb03f60b3c35196747585be94167ec2f2d542f5f13280946386d842f9975cc3f8eb323b1242907eea8627a1655b60a0c0bd77165b80194815cb361b109220d8505878b81523806090a19c1ae88220ca67c8a44c037bcae77ab75e1f8752d2fb1c6334ed8a485b5d967430fa7a85ea477b9bcbd6c4217ec7252afdfcc0b5e2086cad5b99f7faa095412869d51123ea9faf410eed3cc7d9f59cca1e2405b96d2a440253ca4bd7c1e39367edb9b4edbb858b2bddedafdd4c684c68d35db47b941fa3002658e2a625dae877fff68f2584f2acf146ab88d6548f03f101e78d232a84c4a04476c7f2f88fd0b2d2af0837eda3a0f126c52ecade1295b2c6151e2fa9dfb6baa76d19f2790678142b0b889cdb9611c277aa56d797d7c7df2ebdaec920546688940cc22fc74e64867ead105b2ae094e2c23a887fc1eda39a7addb31432656794060b87ca4bfa244be32ab830a450a8bde1029d57d1aa2c1e0cca9b451fe26bc10640c6cc95fb3c598b74a5f4983ceffd72f5132de87d4112aa62bc530fbe925dff3e731b56a8ced5fe9d59a7122d3daebf194c907c8359508d10cb683eb42373731895aded3f2c7da055d8a7dc624ae8fe1cb2f9c1a16f023b8224209457c2fb1f4c894903e26cf46562747d5839b79c886e4473eb0d14b8331cc225d2e4feafbeb51dbed3aaf815bf1f98b24376ca3f34817e6aff817aebbf10744a2b8e26033a9a880d1e74334448dcb67d71ef8905de29ceb03887084447c742ff94ad53408877f4c87db84f120794601218ad77bba26e32fb3c0525121405c88459e8ac16c6fc3b67f0a855efbe6d7e4cca3c12496bab8248bfc1c919026fd8818b1064fdcb84f0c7b954f37b4edaa8dfdf3acbea6fa33538f3380903c61d833e1d09a898306d0315061ae574cbd716a7e059d0878aaa96f147f5bf1de2dd0fa55b33b300ef4515d7576b40a0d40c809f2df3f85af7ab528805242873182f208499fa6e6654a2bea2332914132d22699c4662d100b7bf7ffd1f406f75671a695bfb228d02cdfc63058c769e29025bb843fdda0a714f818915258b97825908fecb2669b4d814bc2a86bbcba00fe98219901252e98b7db0c48b339dd862a7131be3e7c359be0d13170c704fec37347de1926a30f399f0c2e2c3981cd0202b05133a54d5f140b76661d85a599822eb3946e12c5b7e7e246388f71ba88164c6b50027f327a3a0957474c0a02a0dac7f75ea24e79ba3b289f0bfd15e032c01e09ecf8be561946bd722d9151e31703623296e3005f76152190a57a04c82ba89c83d94c323abb02454d32f273ea51ef3c7e232d3782f38e0bf5d37abd6de73337da05d8a359d9ead24d81c5e83d7c46e3a4298c4fb95d23b08185ef35de35e5e5d6e6d49ac0e53a82922befb6b28c55bb2f1ad949b0a30e949875c178fb3979f7b73e2ec05b32ced924ce21cf83ba302212320a9c1c1629d86820faab43c1c9709b50c74956ce441fa676ad606a7e8e8accf321488efc80f20537665101855461d3672ce6554d6e852195e94e3a813e78ed4a6d57c5a1416080c41ceda6db8b9d2ec49cb942fde88283f0c77a411f8d62985727b0fa9eec71402a458da0889f0cd241f2eed559fa70a019d5638cef77689860688dd9cba7f5c9355e6aaf33b85937da76ef23444ff77dd217dc22cf4ff2135ad8e97bda046f20580bb8985a2f91d70e489b4101f8c37b967715cf25cdf04b0f08439f87636eec088e82e7d76da485f1d71e216c99b85b08ec56b0e134ed1ec8a4c68fff9525e4679164b5409b9f7f31090a7485e0407674fd505a498bc79ba8b5852d6893c9c4cfe199e3ad923c5e9f8669398593ffdf27fab12527c1d03d7623f6a926a921020b18f6f34bb136eabec82b7cc92fb1f2266d2bd28e077034d776a6777db72ebcc5785a739e02586731cb7a2bb3f0f98bd75827313e638a6179d428f78202d03aa157305e8fa5fe5ab35b94c05f66136f7aa51a8a96e9e740e248507b5142181490b27c9424d6801cb1ee9b0760d738dab72b51f52505a41ef7d4cb1ca814d6cede11417f366981589e88b79c6ca68bfa329da3dc48c409c3b616a50d6a2cd059cb4fcfc76da7567f65afcf6bcce212fd2aa51bd8dc04e8e376704f0d8dc88fdd29f3f38f02b497b296e29ee2393b46ea5acb01b5f6ee104233a290bac95b13eef2b813a6b160077c8dae13203afe5b04c47118b50a22cf7c1b81f9db196c256ce67db1d42e1c4e06133ba3be2569b8fa43a2ab7656fac5ae1e0c3ae0512c9ca199c7f915e7de8f93585bfe0dfaf825cb9faddbb5ec71ac7c93b68d2be12f5ccd3e8959724c0395cddeb49695dbf7a3a7c62dba8e4ec6004987b9f046ce31d61420a49386b5eb59685d16d1410725ef73efa25b26afdaea7f8626115cb5ce8df31fdd0693e956743be7761968a9fb82d2e55d2e283bc5cd9fd391b6f8c4aac3c4d5fae55cbdadecd8c877881e1703b04d90a50368eb6c07e824c04fcd6183164261ab71f1880915a95c1f731df704fe1603cfd76f3f8626c14a422b67aa9a1c4af7abc94bb029f1887dd39e45fc2633f0e391e60f91e339c2f9c5191cfa78d7a18e296811437fb984f44daeb53d6b87b3cbd1bb13d38f5d2a597064603371c5047a82d1acfa4e23b61486d14c8d3df69ac70c09d73d6df0d3c97cd8e0c18a2372829541447f2c24e82e78a60fa3c17c3ee99ee26127047d794be6f01d56663b42e0f6220e0b342e3643a33f0d16ad435813e143bbed0becd6142d1411eff2a95653e9dfef1b32bd13a1b8c42adec26c836318092d62a4be4a10699ee553581846a3898a2373fd9b4b644bdf6a0d47122c54a5f9b9381a5dc07e2596341aa09cc50f5b29d175c5c8f1b824e4fbff43c809c89fbf36aa4c6b400414a730f8b5236e0d0ca92d8d926823bbe5ef6c9c8e7dbf26ca0238265c48175b98ebb9e908a3d42cf3c1005de4ba5e773c30b3b859bb713f65da873f955da1ba43c73f392fca87dacb89010fbd4155cb5de47ca5c32d545827885c51b924d7498397b58beb383281ee58f8dcfa27818ee288bfe79caaff5338099ad821241f45b692ecd26a5bd17b40e057f990a9123b899fa51ea0061e50988371391244cc2ae7cc9d3d7b9c6951f45882343152a85c7f03465cf3cd80ca523b52bcf17a104b26535720eaea0c3b5e903d692b990939f1974dc4ca50b7d630526ef3a8b993748937b6cb5b1c3127eaa75a46a351453988f214f892ddc58956f3656c916b8465a563541104984aef2f437c7007216d4acfb13c9b20c1df78a86189fa8f90e281f675037c5801a77d2b409cb179fe4ea2d9c71086aadf76a98594cc4fc6aabb76b604501c38519854e8ec6183d76704385b5da5b983d132d397f89c75dd8e97c0ea889572560a70b3df8fdc64ce01f22ad71cd5490f00ae7e15443a28fb74840e26eb8ae4cd14451da32664ba595473670506c4df992e184ea793d9715c6cbeb2fa7f391750035cb17ca40acc277d8cf4c244c96c19e9f045a7e814409e0658b55a6a56982f91be97ea05b1bc053108636438ef6824eac190e36fb82bc6c5fbbef047c7f127b2ac06bce04d0af5ccf648dd1dbd7e463db2acea95cc43320f437a7b33bbf152430c6ad0bd5fc102d530ae67d6adbd2f53fa3a146e494c3b090e9fd178b86506cc2bdee20a1ff178b664dc7a408e49563fc7f4b0b49cc8e50efce216f3d0017d4e0a07caec9fa0ee74df6ec3721100e2969487a12c0ba563e8651442d571057d783032997ab078c495d1a4d75f315d3c790357bb8e22f32bbea2ab4a6162a3ba22ee8bc5da12326ae4db6c6ed77f6c505afc6aa3e4ac520d8f1564c4d803ac786bb7253962cc5fb3519023cdb38aaccc9a453988a27ce0459304be2b5a7aa8eb8900d0d8421765dbb455fc19bb5f19bebfc30e5e73cd15dd827819a7150247b18cf1cbb355f082d5c9c18b7e1920d3ccd4e6cd4abb8d6a40eb7b3832435f6c06601cb312860f49c847da718a8e4bc28e3b0a511128fce30db9f1e3440283addcedb34ba8f99aab82c5e7b81a217651a16307ef81fe41403d32c377c9f1143b93d2f00e1321ea7188afb78e6f486f55f21458cfe7c0d26ed578e5aeb5dd236cc73198688115edff4f3823ed8457f22a2974c5fa0526d6a9090c4a8e7c32619c394f05c34e22c72a4246b1499a9d91813a51a325efa329eeb1af07121b4085bb2a0cb12d75094c34ca1d3de9f100a81aee344dd424ee5138877e19473e6c753ee85e6eeb472758ecaf9a7323f0706b4d1afa5dd3ac6003e287ad39e72fcbda869e9600ced528d36701e04e729f2be29f87a2afd75f09e411a28803e3567db9e7e474f638890f42aac47ef1c199d6fad2594a70a8fcb2ecaef551f086ffcf4309f22c9421aee96ede4fbf04efcf0e99e9720ec12833164d5bff4733ddfd055e8b481fdc3c78c427c7366fd5ebb5ae6e25c0fc21a4924b2c2e455409f2741b590d118f315d70403ab9d1746eb25e7c4bcfce0c9dc8251d8e0c90f3bbacee2c488c86559f2168a7858419bbd8d52e32f770e0f804d656d1de54c9d3f31904a7f65701f57c9b424f504f9ede3a57adacda1e9e46e27e9457747b2cce3aaea85b55aa98d97ccebd200bf7e52e84dcaa7ee2871897b97f6261ca46a893789b316a803fe1f230833beaf7856bff53ba399ceb583f703523f884ce1414090df78dcab14f73a9a4ca4105c92bd6ee7fb9d8aee3c4f4f22dcd166e1e6e06875d3b14b614acc8fa2c608fe0ecc26c72bae1dbda8f634561df7b182ad0821ff18f6e20aefa9bf313b4ff3200fcf45ca816a3f28feefbde092268e2e12b8861078fd2799eebd7dc2159a48ca727ccd16c287cde66d55afdf61ebf1c5c3743143003e9d1f9f45f60533892709dc7bc2089ab8c8d5e396aae610f843b1b79d5a256d5cd7a2abc14694ed36b2c4d8e7132d11a4bbac1c4e62996bb52a0c142a8cbe6afe0cdb2139a2c7f9e9d398129e348c3daf6bed9e59f8d617cb105af7853841dddece6423d32d80892f9216660b33a6eb5419cb87e7c75ba680722a1ea244e8816eefdabe2d15c4a3778b6799755e3a7e4fb3acf67352580c1e66f6b034ca0cf58ebc25581db03ad954144e9cf264d01ba7c9779c0e7acdccb7e8e714daae015d258a1b2d2edff1aa29433f311bed76099960e125fc329a272a0220a13f841ba2eaf8e53a36be6de1df27945c3911b7c72a4d96ddd59cfe612ab4c21750b056b8d354a9d6a350218ec8865dfec32005f5197a48c4484faee1e3b233190bbfbff7f324556d2f5a39b3e023d4edfa064003f83a4d3f240760e00b74b865ce4aad9db781a01c436f0cf6b0a1d43035bda68570089248822a730df35bc493dcf53a82956253fc4d2e7eb68322a03d7a81c89c73a9fb111ebd2761a3ee87fa531cd27bf24c1262335652d8f578a0f31ce1b86aa2c94f062e5ba8211ef6941eae5ee1c9db9a51fdf4c58544085397775d4399b0b8e3650aa3217de84e6aaf60746334ed99af3091f5d8a293daeb887becffb3dbfbf9851cbf465b2b13c0ebbb6e91984d21f2f04b52814da8feb36164b4cc075d01657e59c0a1120a245af03328053536d0b6ea96679e9d7e08ec5221b3ec87800d11f0b35183a7cbd9932358014fd79f11f12eec1804371650218e8c0dd1e87ee9dd3cb106c1826e29fecd97ab3ae9664b2fcf10bfdf7803af50249bc533fefbff79b9d10ebe324d262e30cbaca01788647480bf9e15cd7f636ccf59d817309fbed334a1cd74ecec6e0510bfe8fa3ea766480487a6d5b3636662ba051d766b975f457425cc505c6ea6c902e733eeb554c6578e6f5f90b03388da5064c58385fab6afb6c17a55a46ce38fdaf037512c429d67aa2ce6dfbef3f3e8e6592d370888e4e5d3bf4dafd2b37c8891ee18841dac817bb6518597b9a2f59aacaf6c61917cd4a556bf710b8c7847364e92a4feb2af2a29dbb52364416987bfc0cde01ff5c86a42c791d57990924b62e1e31be8ff931f6b56e8c6ba0ab06691a385c8abe3fd1c596ceb75aafe226a52e21ce6ad20188ba540cbd887f7763b4db32c9d96ffbb28d133a93a15b87a5b3be657ae2b5c3902a570b65b789327114047f355fa4189870986970c97f61fc1025735544411d4959704a2e432cc608fe037e2b377d135f6b21cc9c5cfaf80abfefc0a86fc643d5b7a333359eb2c597f3241244d9efd539c640221c4039b9c3ea22b36c7462fb5662621e36a61bf391141f3717257a7e688f5eac36dfc8be78132e2c513abc9af36188b7e83bf438dd3aa737b52400bfbfc059648482c02501a526e575eb90d01a6c249237a0e3e577dc80b6b138f5a0d90638d08549a22ce8ebb27eb7dbe487aa330878547c8f176f8fddd6da02efda08533e54b76d450df08a274581d82d1039ecbce2ea96382f400c2c38785ad79eda7a327264f37ffd6b4347ef79076647937334f2b91636e19dbc2cfeca4501919d438ae5072e503300c509f4c811599c46cee20955574b4db679c65aa12358543558732eec151899bbabac89e5bc8834d56f491f7810ff75b213f6cbe063e4c6a280a0b727634d1391b69ab40085cbf4f07a4f1817b570ed9310f7e45d7e2afe2c4d13fe65e01124252f83f24ca9ce0406297f22489675bd7dd1d593ea7f511acb5fbd160a6c44f15843c48c7a21950a3723a214e9aba4eb6de149f432e575fbf2b5b668d5ceba0b034a927762709a04cdbc113a2e0cbf20f767b5694e2dfb0e3b8a9a71e16bca6895ba43fce7e5faf00e8cd99cd428b4d19c930bb739128035cb90ec6df9e95b370a87168fa731f7029bc13d8c4afc23d0a200962df9bd1a719a5f9ce594a7279254f4c1a64c58cb9148f35bdb9cc33e99b9db68bd494eca0a634e867679ef27e3d2f52fabf2bdd713e0b6893025d3ae04edfd86f8fe1455e9523f89d17f55a75c86d4ab482fb690e2e909d61cc2c5dbf8b87f44e9c6298946373123a518282c86d4770ec6ceb84809aad244ff3cfae98bd4a56b94eca0ecd42ec11f0eac2a18bb91a977a8951c894736c096bd067bd4d5f3083da40b4d1b93ec9dd1e922b7fcba0f169faed325d06cefb2b9f374c0b6dc0963f64fbb91fd08fd086339c33db076788ccca241a9d69fa2c5f455058d9269bbf41af4ecc262e7d2fa40301df93b9128ca6f4801e2aaecb1bf87b8999d9008a76fe63f8acea0541fbd9447e1520df8db248841ce3d66ae594b29fef4d65e2c35ee7c13236691d43f6f230549392565e54485ae403b7dfd59cf7682c690d330b97688c022cd76b1052f5c22c1b334b8a3c385bfd990084aedfefa965022fd05f16a6c1a900190c686ea2cc126260f6e1730454384efb9896d317281b430d87e9a263188239bc164aedc974323c8601795d86e7b01aa1dd5fc15670bd7604748fb064460011b118e8e20b698e54c5dc7a4ad30d8d0844e7035a75976cd41676b92e72596d76170b28415657e404a32070b7ab0efd4dd427bb003575ddd575c2e3f59d269858fbd85ff6431354d397fd34e0827070ecb9f21971eece024c6b97bc71d779ab00e12ba73ecb9cae62d734be33e9603b66a1b4de61be15f685f0301df45da13b0158aa8cc1c62dd143a96b2ffebbb0bd9ae6a3fcb2dbf79bb93204b47226116af426e438b4bab4845da1c766465ccd9e977b34dcc3efc6b4348f1e367341d2a9c2cda71130fe69fddb329bd178fab51a0b5b0e01a853cb683f30fcfefed6e9177735ebff5450956a3b2d4601e108df7bbe1c6dfe5698318e468723644acf9cecb1bbb55c99690811308fb68867c47ea09722431b1bf58d382c88088d53110a82847441c802361c53ab87cc9ee5cde920e22e62e09521d06752ebb2f4d6f5ae7d000bb2b529df607f20ffa89bd986ba7e01b4f92e3743490d2d66aa5e2ea2e49f7dc8e9fcdb63d1766443f74bdb30cb90c108ba0b979924b2dd0f59186da4a98938ab77d1f91ae5b3641c27f176517c54cda663e9acc018c46ff8d4db1c4f7a354658cf20f1d649c13cb17186cad928db17fb9c0d81a6ae7d551016196ee8190fbe297499ab4932bd96395326c57b3b7590aac8d3db463a10adab09459cda41bc357363f59c0a07125838ac8c3b54aeaeba66b5d3281287acd460724782c1c62a3fb5c0075a017ef521187bf035a8cb81dd146d7dbee9b3381646ce3906bb9e48cde840bdbe5a387d719b3a81dd8715905baf3342a07d3609360b09d5aa447cfa5832f51e28d07ee94375d8649735b74ba2c892338ea1d897c1b74ec17ffeba87cc0e3e83becef49f6a1cd8ad5903c586b4fe6b6f40fa4a1b7a7bc27851ff35d5f3ddbded5b23ad8c7764871fcdec253a3a59c76d1b268f86d45c31a1207f4926d6bca727b5adb36bb3947ef3f251c345f56cb89e96d3926840bc19483c25526551d8099b4b1dba960bf19d35698f0ccfacfb52319824c35f3f81e852556ddb66f3da7af615316eee66a754fb2d067d8e5fa6bd513878068ff3765b226e64e870717b32e352e0ae2d161fdf811640f34f9a83864e9b7c9c3adada2488881478aefe7ba2f99fb19ba8b113645fa4c6a5e6724ad5d3c48e6e0adc39b093a993412856bccd43404122e1dacef8f370b0d13d45f816151734d91cf085f66e1d9ecef31e7a82ba0f9b68f3234ee6af9336f7c4a5b5385923c126168332355cc8fee3020288c01e3ac529c207234f9454706fe441ac44129b70a795283c128c052b6579c82acd72b55eb220aef8098841e6e3dd888ba1a60f32e27ed224d18438dd427afc751c60b0f0aa2973d54de44fee346f066c5e6932a816a6419454d0e76a8469f01ed51db25ae5645806677b959a5baa7b818c000a48948fa556600c366cbcd058bd92774ad03559e73eb2d7b8fd29c387303de5a62186f211b4364ba674e997a39594be2099e3b2b40720f5aa86d1ec36f36ef332034840da3e62ce7ce148eb373db4d4dbf2a0a5b4890ee91e759ba8f74bd462148c70fe99f6f89d56168542adc5ae41d07f306f566e4309294bb3d3de7b95c74a5d8ad893c1160b657ccb82da5fda32c17a084e1fe8b41ef7e1091c62ebb885a1003cff2988336adc1bc00462c73261577f4c119ee00ca1ee717a4ba86623d4f72691fa26aa1df310f9275657b66f5a43091e75ae99775854baab88af9e56d0d5b7fff2613e57c45983e3132f7bb59aff791b723bed919fb70b7f5b97cf7006b5cf48abfb776c2595f8d09e394faf08ecb438bc75707d220c534a278affd5140f1568cdd29aa2686f57fe87ec24f730d1f0f313518d9c5e8e888b6af4ecc30f3938329593da9cdd9cd14afa3a82a67be13d98f3607ec28cdd1e33f0ecd05c3d9e8fb8fdf534d7eb0e22e538b24309bb6364f6d679d9231fcec24479715baa97fecb1afafa7540e87f9ec726c8ee475891df448d0e9ca3d3be9094cb806462413efc76b7339d7474977ac5c21be4603b3ef903564cc460a5998fcf79cde9a178c9cf31f3d1341614040bbd20d9cd6009292f244dbd8f951ecbe482781485365ce5dc1f8448b69bf8501e68bb484007ca34259e3cd87fd686d0af4e84796480a648e2372ae5ef5f921c71ea75c32315198204926ca429325fb7899264e428e43fe41ca0b7ea6aab3b183f9fb03bc45d0aace554b208f31af40739703a77ea9c39da8979f640675daeedf6b7d31c0c6afb31046287ac3627164d56b4a3a41ed948fdc52b75488dacbac9e5b2d5811aed8558751de46e6567970284d985c2bee887be7e58814dceb39e273d21aa2baba2471f8ee78dba4ca596267050999fe3e5df776e4a494eb445688887b7cbc654e4b37e0a724692b2caeeaf5a6f53f0a372c014834484022fddacf48a6d6c0ae317c06cf7d39b38ad34ab55c8c228b07074d7042d2abb167d1970cd544f31afbea14382f1f1daebb9c7b53d0cbce4fa4ad1796e36f9c6097ff17fc98c92914c691d0b51e7eb9c145427561d58375d149b9d750db3b5f3ab4f4324e4e41ec1511501fb6e561e54dc41aea91b11672fa33e7a75428079db6ace83ddb051c0a3b91fdec6e2f2b44074ba541d7f68af982f42db4c849cbda0630f147685a66fbed655c5480e77906c43e2b6f1ea95a490762be63e07efd0194f6a80024fb6bb555e275dbe2b976d2745f42afe7af73427deded0af6b31f62368292097796cde7e8fd547cb992ae701f9f8c511a147df24f3dfc2e7f176705ab702a92e686b5a2286f206d2445ed3d45bef8e0299836382d8e8d4d0e229664eb816862b9a6371fcb027067a1dc74080d3ece4119aea9fa43e5720d3ec43e13fa021335fa682c23bc2956fbb8470a862bacbfc9647145565d1308b680e9b5cd000a328aeb8320c20691fb322518fcf58c66c90534a656848e4e6726f4135e8a0c2d70789b81659c5914dfc31495d1a24d80c1ce5e9afa272e4b0e9e3d30ffcc28f87d98f90fd6acaabaecfcac83d93e73de02e13de1176212992d388f1ca75cf938e3bcb0133050af1cfdd3d29065fbef1391592f30da04c80de116f4fa4e7771c91dc0a19142d893a1cd85f593d48134a4a5f0b2e1513064445e03114dba83ca639ca9fc063d0f47128ad7c760ea7da93432ecd0982ec45f61a7bf3c542a1a73d56a7742d5e09ef04d3a4e685aa32acdbdec23027d7b0c4c7e26732e0603e90d6911b04b4305e0e9c8eb3c17771b1b6189b96dbee1410e57f6c08bb81617f5dfefaf4d4f6062e21b55bf6c9f305592849710d8b7a3e9eeddb6616551f8ab82d6e2d8af771a9e2098540a2c297ceebece78d773a5ac82baf68cc7c947b1839f5a88e2c89d214c5b4042d5447455d039defdc32db96228eb77496cd86d9463b89786f411e7b439bf83c6ce71c47fcc86125624668e61d11a3a10a893fe9a3a62e9a2ece7bc7f1fc36d9269fe6a079b522b0326f096b1cc88e0a556352312188de5dfe10352e7427ffc479e79eaaec42f86a9baa9ccd2ee7acf7e607aa2bf6eb7bb77e5b36583bb8d658fb023d3dfb38695426114df3b39a69823f046e00a65d47435300290ac66e4eaa3a4847ec15b8370b67a6090c9dfb9ff7b929fd876173403294c5fc93ade60a61cb5fced82349aceb50f14aac85343ab647558921bf5da00e189a737d9e4d8bae5a16534a2be1bedac241d5146f4a4bfc3f38df78487b6fcb27d464fe7ba57f78c0ed8641def2962010730578336d5b6a9e22104ad94223421807dc715528d18d49fc69c70274ae1fc35624147ce9e3aab13d93066231c719aa77a459f4d7b9b1963c084caa599aed74e9c284bf8020e422a8837524519a5c505f03fbb14a68476c006a4fbb9919612d3f51272370b48bab2b90e64672d99c0038c3d371d0e0ed8499446ebfa1c586419c8e7f562f470feeaa3fe25f31448dabd3a580938c7303f532f649c88dcd2716f1de4b568a9170d866bff7272d005d09725ecf6020742ca912ceff862884982948d0969dc730185ad53f5983c7768a1cec20c3e7e0765ada2ec38eab646aa541db9c398a5c93b51d0c4088e17734272ceed99056a10f34a5537d28ee4d760a6c2c1ed1e122be4a72422c3cec136152a1094f06f6aa963d558408048bb8f0ee977bb961454cd19598a1cda7585e2a14bf5ddf3fee6d7213dbd1f773706448f092b2d5d2fb839c95f1047c005a40b86ea67898edfb6aaa1bf00768a0ed6f742559e395e6d661f84436f8ed43b592a883c1a91a0d8cb0f900876a9d0dec8bd624906999d5752a54b16c2ef6f72d32b6b4c060b0f28b4cb27c7c6e510c1361dd008eea05ef77f230e13b10d7d72d7c992e67170f66ff6a9f021e72a6cc9ec2b5a575b8cf21564a2a727971c4ee57e0dbe7b14ead3ee89dba71a2305fdbab7a7e572ff283c03bbe957a90232c9a3c39dd03d60ea5d934e7b3a5d1ecb261fb64e980a9a721c0974c69aae25cb7cfa98ef7a6490d4b2b004e4e4f1affbc4b1a9df6b4993c0eb1047db9bc0b44a2d732e310465fb149b83ee39954e5463a682f39b8796172c1e3974de210dea7efa058135fa6594e1693d340be2e76242f4f215eef9dfcf4ad2ef98e22bb0d15c88a981c304cb9f0908a1c95f38b9056eae2d3ed04385636b8156bd97bccf352c8b9b68a62ebe8a9904e94d0de35b1e4f72aa96611af80f218c3ecc107642702ddf49739502c2f710482b1452d2acd0e96be66284aa541e4794f5d55cae73da3460c52e4748d7622cf3146ee3b4588f291f778f96064c1a8e5750e740f347af4d3f29bb1bc338727f417c385adda662eff48e8cd4ffa8f11cd33350c56659e070d676dc216ad2834477abc8dcea74bc60f97e3be1513fd43928adc4228267e6a7e5d7ddbad51729492defdef889f084c28003e4771657265628cd0075e834b091ce5a04bb4c2ca3dc6fc34e7bdbe2630a437351dc6937db6f85a04aba999bea5d07a8ceafb97123a883e875d661b6749be14f8509f786c3724e505f8099de0066788d8d33174539d4e1a306e51fb81456182b8417473fe265add96e4a098c447fddc2199b875eec69c2ad7b9f6bce75e0053610c900aaa8f3bfe7bc6f94fcfbab8b2ef35ac10b302c83e3a108abb90c9b0f23321789de3d317072368db0ed6acdd088bc03a4dceb5cde267d5f16de1d4080ae3861069441bd8cec281555647f7daad42437a495369a5a15af92ce30842a8f496d06cb65ed0dfeb6d7d031cc6f7d59c8bd6d9aec9f158c9dee5238e06ae430bbb1ccb239270b693d33997c6e997b547c1c0280ae3102a4799780d5f6bf536fabad495397a413808993d572020a35416781b874b32959bc6559164d75dc38559571a7d8452fd4ec840f052c3fff0901de1937658095595c035c9bbd1d965588a5ca94b853f21d16def29af435510cb8558e2c693a5f763476dbe2327d4a1258b51070cb48078f127ce899183b9c2d590b9903b13a17e43b871ef1571acd9f0a7dd4e5bbf94778da7a658fbf9077a286e7f010711c008e241ea38e676c175a78e42380e162ceeec8b753458375d46247dca1ed277e235c06774b6e3b16704995f1790fd1dc344b4fa80c04a28322fd2a14af89ae755abff12e467f6fd27c6e94c8883a1fdeaac18d4de652697eb0db78f3d94ccffd2ca1ba186b5d10c332c5bd1373d00c31f58fbff2670107753e409d6d897de6d271be3faf4d245d07fdd1bec0dff05a7bf4c043884c97cc3eda330d3f0d0e441533425c993f726bde9bec8383063265fe3f843d543f25d97b5dc29d2c0d50cd6d67af3ba1b47b7f9b5c13558bf22f36a87a3093e0d327a007fe79180e87943336341f5f50d5d7a0b73b93ed87ccddcd4e09b94e645888721e8c976689e5d353d6b95eee74d5f7e6a8d450ceb5e62b5af2a6b9ce4ad06fc52b39236a5ba017c2324380ea06819451a0375f3447402cf57e065b560a129cdb6255b3f8f23a31758ad68625b748f7dfb37e563ac2cd82ae13abb56b4cad1f78aac3cf7dc940870ff08592b2350ce9a317e75a914dddd3fa785e794553892e84393e91ef319a26fecdec88d5d616338c47c8bd736394f797d2dec9aa2c9bd743094a48815f2e375f1fcf45c78b7abac11dc10d8c71f7f98b4b633d979c2d8e0bb156e449a1c660c59972024dfae4fc1e9f87ead605f4e2c49a871e81e69d92b3f877601325110becc7e03c36a10fd0b93e2ad0110aaabb1c5e4caea792f93be46334785c3808f6be88a18e23d042e683efdc8040c429f2803311b0bfb5af76d8b78231299f143e80bc510ad085d3905fd875985b3105fa899f853c58816cd2018f36de1e5c85e3c74ff20f5ad7cadbddd4820ade3514e490759f5129031ca6178a1a2a4714e37ea17d43474b5e22ae039e80b752c418ce0028824a52fd846f61f7b4ef2960183b9fd3dc80dea6c241da688b976c53435294f5a1dd63cc8eb08cfa63315b59bf41df1ff6f95a093b007f0e62156bbe78ad0dfb5ca626a75794e07f0166d2ade509c7fd6511bce311cfbcf2e9864fe4efa575d052639b2a0544eb7e66df231ff554279f342997f3e53d8c4790dc12c0578b7581b50dbeadaabca515237239fa1001e796b0f397071f17372549e22b75da90934e991b1593b60842b698e5ecb11ce79306d716285dbaa492ef7abbf134c87b8ee05b9899d89c9025c23d2493013e5898a62ff67a4864592529d29374796cf9fabf177d92dd3c005b8b78df1e8f5a95f7bcead22fec71a4547efd286d79bf69b3a456eed62b7674d53a1d4e37b3c109ec404cf2c4b6a2feddab8f716e1dcc1691ca80d572e5da07a031190fdd33448304297df8ba7ba84f4879dd31b71f7f2bacc75d14ffce0cbf266c1fb7aaf54665ba7c7cb4c126f4b0a96d1991f962d054cf77d5a272614f4460a32b6e3109a2f3c65c60a3dba38949e4e2031bdf762b7c12804dbae2f63f623ddaac6cd27ed3d2a7c81e669ecbe7c6805a8d61c3a62a0f66c3b3612a88899ca1178282539d76904da28cfe745e79c4cd3dac4784fad5d4a711ac896b101d1c8ef1ef0b3a8a2f45933896ca31346bcec941fc7fe90fed6d6e485942a9304754bf99abc236de6d117d61fbf26b50ac953cd71b816d3fd560dcb239318450c156c2208b13b0e85b4960711720488c80270e232c002c2463cf65686f0873c5d7284d5625ae12332e311ac49ffc10f8eee69debb4355df388ad1d43b012f9d297969257eebdfb38293100de9ff8da82b73a424effc9dee86d31229c6f7a81b610e61e4adb1ce11bd7b38b66c9f0f247dc8b073fea0e9259c935843eb4083b5f4ae8bb1ef7e50cdd9a9490b1e9ab3463649c34e8ffc6df40e1d16ce507035b17f3a0619afe87d7291141c0a916e944363bb2eca8d2dec4d0f3d665ed5754f39ae34017fd6bfa1e5ea123c52c3c5fc8ccc597e72f26b89567b91338b071112a74c2bb70eeadb31bf51bc2ed415d34e76c9e4312b2fec2e809cc2b6be2d089dbe9bf50ecd02ff7ed07a503ef057539a5fe0ec76b203b0a093a42f4d43b6d4450d38668db0e74faca4ad678ad9a1b602ee880e592ec4188a1a8d78cc895422230f83d16dcce95228a06dd398209f0fc52cf4050730d464bdf78a3a197470e3f74c644a3793a2f4deaa35cdf3dca08be1921cde2557022bd9197e9b8d8b683abbe266e29b1719e86a5139241cb6b72ece5190d4f3842d1a8685b3a61bab5e82b546d4dacfcbb9ed4ca19f853f5769fa42b85394e3a20922f3b532e11af0a5f615de9fcde6b1423f3672a44569fbbc9e039f7c3dfeb77e698700a7c72f24a89db0b7bce002b7da25efea5015954d05ec463a7fec1cbcb60f992d7553b3049234f11e32d94017897c55bb515a6b0e6db93419780b3431b16310c187ab55e2a41199778513086add61357ac3579b19c28803ddd92235d1711c3b24a1f0506ede1dcb8ae18ad68ef9e69fc87e22294afa4003e5f73b4afe1dbb97180842c6cd2894c4306cc3f151c19f3ae1602aaa801b815e3ee1df815accea9c9072d416f85b4e94bbfede005ff57c6591db59998142fab4315023b35ee9c14aef851f6347f8b2ebc825b207031b619a9f4eae64285895bc1ec3c7e7225eb2096a4e18c23c5226805c39f99d97f2bd4e01d1c0a9e638a5f7cad4d362698ea850110a86599e1f002bc4dc0d61cf608e1a06cdb717920ece9efe8b9189c20a0ba288771276d8d5a2437bf0590813f27222a7362ca8d8dfaf89dbf8a7a5dd79650a427d865a85d03f9234551228a84d9be6b782c7d3e27eddeb6e7d26ae6e1510d2a991db76e5f5ee766fdc5f0243656ebf80264405eeadb8d5b98568adbda68c25fc3b451122f43934672e1dbf1621a090441e6ff911bb663d6059302067d7129cf4f9b8070fc3d501b0999f17a6e00108a52d96a9936b9dbfbd61f651db41a18c11d2bd323a69ad20ae3860fb1d4760af8c2acd672c764dfc386c85cde33a6a1f544d07d62aa652cb791a55a96bba2ed61429cab5dfeb6d498c407efa10d9b76d0901d53a17ccc82fdade28cf107bd46620519a3af8b219a2768dc15d0247a6396977bc11fa16b48764730043743e6458b803307a767f17a5d87804ec5f5355c10a61bf141a6dfbed14baccf52c918c536ffa542d891db0f1a9a27c3fb946d1c2a693016b78f9a3f158d40a1a05c8c62cc4f3f1670f5126015c49c44fa3a336c0cfb2c8ec7c6fb5f01e56d4e1dfba724b06303d69e52e808a6eda3178d0dfcd32a4624a23bd0bdaf90b670883e1c27ad82f3e7461e4c67faa860739490dec9dcfa931fccef1a3b80590b7457819780ec02870f9f2f64f5d4b48ccc1d63a4ffd4ef9e26170a8f65573b6946f836bc334253d3ea2a495fc5a605b31fa3d1f20eed8a16a5faabdf5db46e064f6f527e9d846d6646c8e9d9b301af6cec597882709b981cceb79f8fbc47cab4d2b8c346a3417ced69306a1668b078d16181d1621757bac26aa97d396072d6e73fcf1f2e72ce524e51948a7c406b389362e489355b2cb0f3a06dca15f011290c4260944fc94bfdd149e15143a79c041af344eda67941e05c9f9be6083c0a1f7b25c9408a92087b330b5cc2d1756b922ff3ab1b7ef03f5ca882cae8d2f8b19131cb616d0426e70b22af8faae065c94df8406746235dbdf5831a9738da963590e955a8506b8bcc3b9878450d0b1c2adff4305b5a8793f153ec718e2cbb1feef04d59c0a856a08a075011d72fab3d21d39783ee7ad8dc4953fdc8a12769b242212be7bda690ef34c0f6bd7cd2a4228893b656310ad445606b316d13390406dfce93bdffe40da3422b111fed3b41490b52b518601c20a44ef9108b5b2930eaa19a4ed704397bb62c24625a1f223cdcdf15a38b24cbcc4922de3e504d1c570b51ccc41f1fe5efe4c4f2aa5f3d27e0f4cbdc371244de2302dba3f5831b07724528c5e8b7797dae7b858bd875c7eb50d890ea80b68e4649f3dc47085744257859131cbb41bf461aea5fe7057cdfce46733f40e92be2c94c9009723adb508e5b1f7478a0a30a8512b9a0f9d38584cd4d55f0ff2923746a19c1886629d0e4abe15dd3a4d7142e68a1ca1220d4b06aa17b795e7be45f0800c30ddf90664e146cd4304a6ab32022df916a84b4b786206f2b603ec347f7558042c29c595ea271ad1275a5c6867235f35c30c6cc1975bc7984e1361de02c59f9c65a52bb37ba192254c537cb8e849cff4afc0905fea57c0db4d70620cc0e18e6e26ea2fc0211f0638b6e8ae114765977bbb64ec9a5a152d947a1cd1a87d52a6224e82fdf9e42eb3373899f8964f28b6ec7bbfde9ec71c8ed9aa83f888b70b174db22622d916a47cb807c418aa7e409c7525c2aeb2207124b176a3eea15374ec406e9679147f75561fcc9f30e30950dd0624496272bd4347d5b142670f29b414eafad40cf8e098b5774b33606e4a7d413031ced8487f2f9031ba7dae06e601c82943b3fefd6a621497f1ad954bc5c18175e4edb1cef759c2ce52e56","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
