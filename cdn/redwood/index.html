<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08f720364d48e71bbea8ea01f8aa4bc50ccbb3d100c10a4c9a4934ae873d2525658793e837542e7e8c144e2314aa70d3de2a222d82d7710df0067c81f89461655bb73f7b8355b7790ddcddf094d9e94dd9af00191346b39e32eaf71e2ed970fed98a51188724cd669983dd0bbd1f138401ef96ac33f3416c8990785311a1ea21556e1ebf018475fa44d240ead8bb2b6e8ba2cef0919e59869139c15b640827f2b161eceb2d0321f6bbc1a6611ad15e4b9829926609fdcb98df6576a0d6c4e490a0a33f6b6f703ddb8b1d5669218c75fb7c7676f1e28bc45b550b4b82cb9d5898254d181f967ebf70cbdde7a20b3cc63efc6cda3913e5bd2fb465580489ab756d8c2366f76f08ae05ed5b7012c648c83959e3b3646835e2ecf0928b385c62c00f4ea3d13845263ab8517ceeb86f2fa75ee34c0b49401389ab3215a556625d731e7eb04244c1d30d050c258f5d60ae279804c4666adcea5b8e1241e0cc286f13b322d21f8365b947fca1bba824dca6313654db19117ba67c52fca682edf3d25059ea410af26bbd1ff13d6204dd1b351c233f8fa1052f25db9fbb3cc39852510401a0e9b26bc47bc77813a1e3f784b727f3db4d44a7a43b47daf88f36108df8380ca2b4c5ead58efb8e315eb97e842f17a922740a80d61db62ba6d3ac1b3d4b6313394002c0762ccbed5df49dc0d52010a0e1438d88aa8a8079671e74bf1af4fe37fe25ffac7d2c22c906b488c09c7cd9240ae1252188e770118164b1adf1ecbeedeea7cfa7820ba15fb17b7451c72ee4c8a13fa5a2ef585e20c09413c856c63ada052d0034b57280b2896216ee46bb6b8199ccbad9f7311e496a5704f0996c802060272dc63ad04f7c2cd502534bbce6e2caffeb3d7101b8dc13f5ff019d5ee44785eb27b4147a90e22fc2bc75eff6514a41ef975ca2fa48d204980d264ad49bd452492d9927913eee3721f6847e5aa253c26f6541cc1982bc0a9c2a9fb90b233d6e12ee90c957fb1051961d0991005eb034e6c3a3c6c91fac61c22e05499e85d742ef41ff35859f7d9270191586df19f0b5129c3d80a7f40285d45a06138bd5e6e59468e7e7a43837e5fbc79a1fc702062109ade7b222a459ca6757b552d375bb7edd1e4209aef64bb3158083a683035485b6a0cc45aadff56eab2950f82832c41fa24fd4b1e781a3356aacc869e4f7192a6c38c968d61416e312ba0db810778282f3851388103c2d21110fca98294bba97eefb254701a792f277331382d3cd4e3c969b0b764742105abcededbf0ac37850edd9ef8b5a08a48716d5f82b7db08888533637a338e98c372b07344bd58332605ae8bcec2194fd5fd889752d7e29e9133f879e34e0c21ccb0d334004f16b4126fb8dabe7c741f5905241cd146eccf849e33d07986322902d8524645b733d0648af960e02f70e2ef91cb69b71078f1998bffa656bcc94250d1c51558e0f4c661f506e4486381a98c23f8177939bb7cfc14b87098563992efb951178f7239f704a3737ffe7b9f46ae5dce477ab542ad727710f1a9bf39af66992ce22ff5d9fbb9742c14da44a47dabbed0c2d038dc000a6a201082862b9c25a24a4c5197d62f5302d520484df486222120ccfeafe077a2fc46b7b0f515e6f542657c49f16a8d629535ca17b82bc0b66c9ed82c99c99069e9d2f504b5da7e89d146b9dc6a1e1eab3aaeb4599bbb07feb2b65fa7fd3f4f7778f089863da975fe4cffd8d2f12516e976c3a258225ad574a4691b260539772bb8dac4eff6af8f386f1ab0257b64c772b241f9a1759b7074fd06fbbd6cbf4e0ddc7c7a7ecc834ce1cde16cc20ed6aaabfe2e86990596928a6d126ab7c5376681bcd75c4491adea8fc6d25714104efd8e85bb36f4f52f05089333a00d7536fac36b4fdee1f068d2b0b121db2da4ba20f696761cb60124bca472d80341e75a02f65f0ac121030900d29c40a7043d16ca1e09054ba57e80a01e8247143cdcf4cdf3075581cd65681bf5db5e2414682b38c44cb65fd1b5841bf7f641131458f1d015e0b6be4f38ebfdcef6047b7626ba5b6a41b6890bce18ec221cf3ec04dd7d9954ddc5b6baf9689de221987e9097e28af88544b3c803e129b25f6f212464280efb2c489b7d0ab59d0656ae3619d0f342e318d208966b504aac84d40c22398c7848845204d4d930255107bd1fcb5d35c2d809f0e3966604ba56fda6ebd3d45e3f54785940b3e8e5f97a87eed48b96c312fa24d293f2b30a6256b402ef6861215043539630b5b2bd391f6c492ba3b2278b97e803265beca3f180e2f13f65e1b2fbf8578c9d94f5faf9577e6239b3c52c541d548ee290ffb6abe6ee7b2f12c88d4da590bb29a82a15806c5d983a6251159b3223345432c5c874ce4feab0eb91afb4661bbc8ffac9f4ab51a03d6f6d0a82e729fa9c08e43c61265dd1c523eded4d6edc971decff12d054a8b2e5492ffd2d56781ca9d1a19ac41de5a8846fc69040413a6962632bc7ef1a39d6c2b953443bffebaf90c291e18cc912dbea94794361c97ae530a49d1aa913d51d82f07a456b36e3dc460d7bd1e9e9c95db5c9062880e21034fd8bbf8fa32b623e89c813f586364bf7d5defc947c3b44722b1f17325b93f99574765b7e08101d4909182c65dad8daa1a5933bb45b2bb6a1d63bd7c6e1208c7c248938df109b0484a2f620bf2d4529b965738c458485adc3687dd5e7e8fc77075d6a360246f78784ee30e7f819c95d603dcce8549873d07a9a10fed9bc3443913081e8b2c3fac2a74b325bcf8ba5ea4f6ab138d5ef43d5c2aaacfb3c7e9154f041d68e2b061305c0e9778a93ceb16390c94ecda5601e127cb5c115ddcb1b7ab74a3f5bcf10ee8721637d71e60c88cbd9ac772651e26307eaf3f91bf33615fa9774ae9c101fe9b1bb8a7d7dbc1ddf8debf2d12d7ac9f1ba11aec8cd82e387953ca3b3a1a8940ada5308b96276d60e7e906dc8c67b4b19f6648011df31b46d6218af99ae8aa66e72af976e6c60f978916a02e3d88aeb520d2813d0173e1790c9c05537964ae1a82714fbe8075e653be438e7deae88b2414cee2fc51337f8bd78ce2ccb8410b2aaeedbbd5586c77ef18436a49fe3d66707ba911de50197bcdeb491141c5a94e27396d791e718d5a45e3d0d8d948a2677acbeb1ebffe46c95598a98ff0055e2f9652b7e68e51e024794584d1396d2417c974da9754b141520db494ccc457b6d88d7fb8e7a8184d10cc7d3dd1f739568ef0ad746186a0c78b31d6bc78cdca35d31e2b884f0be42838fbbfa0c900045faa26f4d5f75de956632e08a35db5f0fe6e51dc1da5c180fc9af16bdcc5c54c8722d379d42349832c6403aa43bb469555c4584ec61069ccc5d3b3fc7153a0322c448a48316d1bc1a7d247162b1ad4ca4f7b3d3c697f25f6d42eb27dcd94fdefe0ea0cd915cf80b13f2c69166ef5c3822db62b5b40fd21e53c0c873fd3cff79a9a013d80dd3f35f37b16c4c8dcc5dc048dc4e414c3f08518ecce2552e8ff0917e40fe722de72e748e80eb37f7d0030fdb37f85a3b968341532eb95e15cd4509e8c423b2e689aaa0f04346618193ce3b96cf8ae57a2b110875c74f2c7ab9aa5cb3b270eb5e55fe2eb7ac371853a2590a0b69d4ec5f44056d1a15dcf0f61c25132cc8f893dd65c674b14c2c8720140f7de252df5ec7d5cc83c85c6835dd39e4dbedc43d04f715b0a536b3dfedc70adc9103998483c40f6fe2dbed7686f26132765286800abe6ec9c94c85b08076004b370b248fe2a6dfc4cedd3f24e3ea77715686399054ecb3dade638785b9c56fb5c20372cf4dd5b3301edb82e2f295e57aae54ed8cce2b49ac1c64c283645d8290944e314f23027ed766266551804846a6c0273710be3d5682f7d643a75dc28e4d94b41be4889867acb99fc213031abd19cc940cf6b6138d3800a2355aa9cf42d3e7e03ae8f471959fc4e821d714aaa93bcfba12e71e04abe81dd220ba8aac2c8a40070ae6afada3f002080c8b63a1c2aa626c0df996b5534e612ab086bf9ac1d72f503ca14abb8ee54ae96c938d5cc5df7029945a71e5dab8f5b91eead01e35fa504717091df061b35714bad6ed1094c4e9c66a19a61fc5dea332b04d61e88f7109626f0f2c1f2b5acba4f42209b5f0f22ad1f635d8399051a8eb5f37f223e5208d342649690933b9dd26a986356e8b60fc6b3835e20b838212d7ad070bc90dce5bea9fcfb19a434d7b170ea1c0dbe6c83afe3719c152dadd6cc1b94d6f9b2673d9d3d5238f73ec3f7b69df05200fc396cf2af5599786e21652491fb6233e9323143f247a9217e4b83a20fe3c1574e13f1320f865ea94f4744d22927645f47017fbda4db500b1c75f2f4680584c375d42b0ab02b5cd8b6479f42747862d6f93d58f06708479b06a91425c980fc86232f6efddd6c33a7888c5c365481b70d973739d6b2c88c034543d50bfa208edccc9bcc0e3c0e6476d9b02ca8556b4435fc94e24b477d90c7526feaa28a60d7efd0c70a0015238caaf2819ad347a819eff4269b5956fe291da53c645b5fa8231035d43d1df13d4d9ec29780e54d77e8cc4a8394672d04e957a2326e0893597cb4e6b6ea753cfc73914e10e6cb72a1dfe743dea9fd047b304ef3c672898b181fd822ce8a75b8a6b68797502ee15a0d064fc2522b943b023cd62d6a42167539e9d89099150ec21aeda03f4c14ffff9370ec14ff0f8baec169fbda8b6f43b16c404a6c210805a7e9dbfbbf03f707f7f112f5b60b9cb5462470e7fe2d1b11a96419dae9d924cf00338525822374cb48245b723e0214242203fa9cb5e2be063f610d9281861963e140e59c98730d0bfb8d265bb6154a54899973dd9e044fc90bb0452315206c8df58bea82d1504d8d12e0424238fe18e478cdf586fc595bd260cdcdc7cf271caf57d6cd3d8ad78c8b4e16496676398c4999409bb78c08e8a727f9aedcc7f09e9f091ab8732367bf77bd9e124ce079674be4df25860bdc5f5d01dd2ec4db064c1cbaafa3527eaed54fe8c7e7168695cbeb536b14df49c4d4ae3ae2774b6ec65e6a0a72ca3e1b3df35440bb1150735cbf3a5c9ebd4b4a0ba4da74b4062a1fbdff81f2b8d00ad3fa31044420ff34ba7743165c196b50df5dfdbf3fcfea81b98cdff94b3f9a90116f9c84bf02a13c23881a08f2cd5ca32b5f3ae8b420d8a9ed9deaee249b6c48f31cc4ad4f5ea0575c7b0ab1bf1a6533733f4d029888ffd28016b74f709fac84aae7319ab5729d537bbdc4bc2a57f23d86f5da93707791cc5727df8f8336b5b01e82b748d0b61ed5cab3e20bf16f6f2463b6ba03b698ac2cfe60b68baba6a60e0d53b4dc9b72962534ca359a22befb9d3ad3efadf915cba5deaf783f7e90654580c37918bbaca55326f510b5055f3e3856a2443120183936463e0c52864b8fdb285bdea21ac6ea8793a4885589fe165348db3f9753814fe6868269830cf64da01bc70cd0a08900adc5bdc662b5e66e9bda85418addbb7b94a0fbabba442ab380cd411ba696c5cbfba03e2939e380d8e5d6e9f1ad8614dc52f5f1fd3f9d7c3c04f7035b9343c261632c6918d5241fea1bdb90063953517e7a921fe445c1936c9830e0cf23484f0adde4e8865b49af24246ad81baba5a49c7aacfeec746f761266d890bb5d619e9e5626247a52d3efa149213822c447d753e1eed45d993ae81c0df7327c434217770999b3c9262e7be7591d966c8cb002302578eb3a280420be82bf6defbdbc39a87bb6dd3958d3a5034217cd09c6053aa4d132e16d1b7c3eb576c9dabdde518781da5a060c165bdd007715f0559f459c6b51f307a98c131d09951bde453fcd61112cf468b3cc8c4bc239463011ecde93e7baefa219951b55344dcf5ac55ef4726497d064e6b233cd4648c1ac5bc41fd3a8478ad002c9ede6c460bfada4f27c366e39817f610a71e8a436d510389303b70a507503dc6b2b57109eaac9bf59af186cab9940bf62f53764397c0f78f1f36047d3688d4bdc6c9b5dc7b52ebbfb95aceee0d3a60c5e2a541aa77cd9e22d1bb243a0ac10f733f3bd9eb704bf795f98a229198038cd680adb099d88d5f1faa551699af7828f8841bb6f8398eec9c4f2fc4ad25c122fe17398deb21e4c7d35848113881a0319675cb7a8660b1197fa030904864f7369c198cbeaba745a9941eec0d612330b6605edf8bd2451495b86a1971706815d41a21629b964e4d93aacdc7e19ad4efed3a75c70e3f5341ebe92e2df9504058633f8c7372de9c67365485feebf05a0b8906e389701f527fde6ce4e4b8eed3dbb4f5fbcd1050fae4ed5357d0ad7a1877eaaff12675d180b4557dbcd9289f936b8e263011d846549ca26cbf23f178fbb3f072516dbf93e23f84ebcc68d4828fce94107ab0f0176a961b7f015f4edf521d23ea096e25ad809008a2c66d66b462793023bb12306e1ebc34ec04c6feee50eeaf256efd6df9b6fc61cb0cf81b76fa2e1341712502e6513d474851742c5ebdf70924878b5bfb50a0466f5ad61754eff8629e25d8ffae45f1e3f662db41465171f8b33f391b65154dee3bec21f37fcaa541780c489d7c364763dfb466d1537f64e3c744e755ed16b5208696aabf61fdde1645615f766e6f0c990d42ae9995e1dd4d4fd047026debbba870e38fe9853904daf6fe06d804715ac082c70675a60dd44739818e3ec0ed7c38642f4397909068cd3f0f1ae0a4a41ba88ac26f5ff57ae3c2647982b5cad481f026b4cf56d3593a9f35fde21dd32317347e3d31999b9c28ef2355095e472e0f65c996df5cf975cbaac110e15bbea83dccb6b1a316e557f8eb066c0e1a398b010d4ab206ac9fdf0f34aeb62220c448db146e841cf1f223a5f4191d5affa6940facf3f66f2d68d15f9f7c5df34a4b8b79beca15430e79455502efe36c8d530c8e33655b93d7efb6b20752ba5389008b35d0363b8a3ccfa431ec78bf681efe71ad7dfea4534037a1ed3668e74b37f7e408b5a2a92ea6b4344321f56b8007102f900d6db4f4e659a169d0f879ebd613e3854d251a0d526fed644811f385c8ea067e4e25627467c89c9ab6b13acd0ff3cf85ed2207544a516f006a1f5ee597f7cf9271cf01b3cfa87219542ffc07ae788b7bae5d8c6863b3b942ca34f2adfd82e30b29257d9cf45dbe9e64f763424bfde9679b743c448e16ded942644d7d5fc9d91ccf84ee6ea832c22e048f7c438d31da08ff223c10db28eb78b96c075a66980b5671071a717248d8fd272173ee4fefec11afa1d1a4b47ca553d52e0add15a67ad30542fe936d97681ed22b8fad8a8c9fd99c0470f4d5c3531545b0a982791c125b235dd24d75e2d110cbd8bfbf0a5ebca92997a6db93c30b9fbbb71fb0798daa0d9b5c4240ef7befb13be4138e44f886167f40d26f1941e6ad4f8514b023c5cadf659431085e9b57c3653409f032095dd377bd7d141a2afcd9150449a7f450e2b118e3e5e46c782273b85861f42657a0b79294e489d79cb1be4219e5791d8988f788726cb43296be08283edafa7adf6350c04066e15d9b561be7667099ec6d18f34fd41867f5ba66a84d74869f8c5ea4a584ab23fab78d023f0a0c2ab10edd799d590e3fd292e918d3e2d5b55583afb8c907e11b0e8dee6c5b4240a18e49d5089d3cd8a07e0298bb2d9ee117e722a772e8fa1a6739e8dd600b46dcdb968634cc4c26e852a37df05b14d8cb7fb616df5feec7759b5a9cb5139073ce819369d2382940331fc3ba58e21c3cd2b847a883a7fe7aacee1ce37f3aba5255aa3b94930ff9eeef509b82555af2c8532546a7f4d9c6352587b660fe0088ab6d277edd4de832d72f6e51d5dc7b44dcc3a94ef288c785402cd5ae1f01e4bfbdb86e761ed6c9d66c3a462240ddfd73789e2b50ba2616eae3c98265eff9446d7d83506de4e657740a4c34f897548a027a28b082cb75363c9b85154945b2a0ba4cb6ac4de691c662ff0370d5e8db189ab5af5f15cf01494749f819b1a7bf15726764c2c4f938cf9ba543b0d5b4dd3e4859a0dc8420c6693419f9624f6d74060bbb24efb3e93973655c82c4af0b396cc653427a92c12426f959b9038b7e1c66383fa78aca90b2b4961b776d4549f1fbebb28e2b0bbba2e0c71f0419193d544f253259ef917e7b249dd122b82dbe186ef6cf67b71ae92b6f3fde428c892ad56d973d13aa25e60be8df74bcbc558fbd5379e674c41adea4e1c78b0e4c1e9026a070c31b9454f1cd171704f8addae3c9320113ba8370ebdc96039cdf0d753c922a9117d738890f3ff6ee2c98ae387b6674317464812155187f92e119c344638b26bdf6481733db550d7409f6e9a14835f2fbec6a9b5dddf0b781b6b4391049fe230517d497fa9657910a9dfca7a94a80cde704b24a7c35a690d96d81b4b075be6cda02d62a302c611615d51a4f3e4d48a7cc6870479604d01d99e7c83d4119635dc1b21f391c2d4f6a7b8d7ea959ae9be5f730bf75da27eaf9db46fe521ad4cae28e273357ae3f15e30db7965595ed4ed4e17445510e286b383d19ed3e48ec72071152bcfc880abc78bb9b8465c19e67bda35549b54c4e48aefe0ed943166203a9e18e5fe53baa1276959d02611c0acfcd6f1ebd9877c71a99c01ec44e22bac9d293a7b331b7812b35004c56f922d7429174cfdbdbd21e3bac2cae46f7e1c9535084b621e418abd01d4f62107b010427cd2cdfe6872fc277a5fcbe1d28a599be8b8821ce5bdcdb03f21e5fe5c63a1f076f5456fdeb0f2da90acb576fdd7fd71d591dd53d3503bd9cef3935ce2c03ed0174bdfbbb214845a4e111164d338ccb05019767a7123c7cfc4bbb10283793008e18714a2e83d2eb5c6772ac3c0f1a8ae4ae6ed53f36663b86ba16073409120aec219da3cc1eb74e9da8810f418339d90f77f0dc9178af2c1a76ff08f3b9fb94aa324fd12ec42680c47cdc3bbdad5bd3f52fb45a3980991c16d865c8406400ff81469d9a4c5f6bc84afd810d1b9882d477ad794a0837c7b5a6f3c68bbb3fb1d460eff8365a81d3b6da2da65b4bef6c4a480b1cceb19b9b07f15b10bdee2a797d312a2b0a0834c3b182e91a50a2f50eea9694381cf699c9c30f120b257918037ef5e579948a876b2a81abca940bd546893607a711d74edabd66cd3f8c0491a0234401d4080540fc17e0c6f23200e8ec776d84589d60899a9bd8a6904e92612f8019b69a12c3f54d620e91b640d40067a810890fdc02d9617f017c7eb11966bf8a6e245e785eb97234cd57fefb88c100e9d95a2d928a81b89cf666355297ea2774323fc52f7319c98d869af400f519e020f45619884fbf64e94c349e35af51162dbfddf5f70f4c85e5399cef1dab0ff1745881b02dfbc37182d9f463894bf5f9d7c77a4c09597768b3f08974993ad8dd40a43685da667de917583b8235e34f0e0e08c58fb1b6a028733f4a80fd843003abe057faf044beb4669f69a24ac7d960af006ecdd4e9d4cc6cddc470da056861a2c46d8ef2d4294918171ec0baee465d5ace3ac701c785f7897f66a644e55613d01bd769422b0d20679546aa9c5d651d6a9b300b4ef6c7c33d302ee82d961978189f12e4e0d8260ae558fa1ba59420236dd1081cfddb5c93c3c246e969808f4f7554e7630f8583914628fc285d9d47d1d17bffad35ae7a54c329ba59cd1c5bd00f070cdc5cd8f71c0d6da9d6a2fa5d8e9478d67f2fec06d76858b2ba617a2265e2184233fc7c45fb1447502ef89a60bbd6254e572df82e251dc4d8b28b081e30ce893b7c6144a16cc3b633851795ac64cd1249f814b9909701de3f2f08c64fb46c56b36e7bdcb5a091362d1b157aeaa9baa53b72a06ef84ff1fc3b8a1a03e8ce3405c67c48fa4d5d40e4f2344d6cc3d5d1339172e377f52438f2a711fc2df0ce26fdb8ac7ecfd4e7f558691a6aa1fd805f1fb2c7684d1fd4c95db53077c7c347990eda78014e8b3fdc0cafa1d7f1eba53b4225780e7ad01e15afe58c4d1ceb88608b92dff448d37d80b646543a2f35c6cd14b7ed8480441b5775398fd636f2f2f288655d7c13039095803aeb962adb3880a421b9aafc752edcdc1c4ebe29755696f1300abf11c0077c9a8905682b121136e32caf8a4266ed2b2ea5b7b0e7c645b6120e883ce729e77a0c6f5ab16762a0ea9c4d1960f355d61c22490266ee02e9c998bd4306749d86a060a3ba1574cd9521b157de8799781d22186324e133771d02cfcc669662e5f47162a3659f86e3d04c250c750fc3998e18d28f52019e9abb1a123833c4a623be3706d67cb5cf36056390531977ba13b559ba4ebd27ae191d587bf1d5ffa60034c4bcd4c6cbc2b441958284674c644be172d47a369cb71c5333f823644751e5973895d1717aee4f19c0c44212c2aca0960eaec3e30f12af494e19123c9ec38c4540824699005cae9e79705a1cf667dc42175bb48f5c456a07895021352e85ed9ce842f65bc59e048d0b760210734d86631ce67faf31306b021d9e0e529c63b16e3fdf77bf871066a2b3ca1952550787e4f382154d610edb11d8df9064b25c7aa83b737ebf50b9f57142d5a354e0c1c841f5066d9eb89210b58832756ae41dab6179fb0ed6ac2727a02da0a7f6c310597006f9cd71ddaac279ef73f32405b1c99e8ecfc35c14c11834612fb1a7bab8ffc4f42d08c1805da2288abf952e05208ae6ad04b748277def1575720879be8fbce84481381b680e527f6eb95d29acd33eadbf31b8f59393f123ee5974732c75b9c4010bcab36b8917c2c9788982bd15ee742dc9774fae7a7d3b89013e3bee8a742158d7d7e6887865cf68b66aec51a20cf0c4d218e73f58eea97f99dc2516d5bf3c06311079beba1852192ff72b8a989cff65c294712da00ba0765f09b7782168c4996d16933e4cfdec4b2380ee3e705fe53d7be8ca4e29d4f3d3fe07b166f2e2e6fd5854eb30a1b28d03b968c335c83a2cccc149b0f571f049308b84e1aea39e2cb79b0d1a43a3c63573412b83043796b361e35031baffe0cf4687fee9585525e0d4c9a3dbab85a40a97a93a69d052e81ef0b026955b8c5e5bbef33f5d0b63dfaf903b2a67e2bed659901d8d1a1b702dbbef80912650a4dadb0dd596d562241a4f096a888ee10c4ae6225604adafba0ba422bc31fb0c37b15d6f6e3ce72265be9b260fa9bc51bd85c123fe7b357f48877c950d904016e384ad29fdf40a35b2fa2672038370086bcf7df9280d72c1fc706062a1650cf4bf6db17e4b37a7abdb4f860595772ac12d1a5a5691505d098d6ed634f9bbc98ac52a55f5f8ffad9bde4499e40f440a9828fd60bf02500eb549cda8b7a5ffe1f8e63246ad24e14dd118f0a8b7a83ecba0298f317fe5a83727a6c8564909742e91f9b860b0c5b9d7cb98976a4f1d2aff90937ed83593bd62a608c2a5255d65e730d5034c0f5069450c10fb8b80566d47f38fa500b4c20f2160bb47206503c25a81f4de1331916d63d3fcf0f62c2ec3aed6699ecd8993eba7e8de5118eb1b18d5269cebd35333bbad7fd5140a2a829615d60583e9418ff180edb2ff4912e47a5e7577a36a19fd126f1f24f62fdaacfaf280ad73457a3fa7b156546b596cb6d447a989061522f19a4e01a34c6a039bb9584652b5c45b684008ec6c10a108592f7f30a27fb8f48423dee0404db97669b8b9994e979d73b756900a6ef8fa08630ebfe18b4ec1e6ebddb1ae1cf86799332d7a7962a7be0b86d0793c83930e8e7f850ccbed7084db9ca2d7c779d4a292cef3a0d5ad452a5ec5ae67b8c4a4d5e9a110f9e238a7b01b256f93bc428e3a059ec55fa5b5f97c7a4024d29af6735fdd54f4f8c2008c92e75a1cf9fd7f62d2e5b0b211e56c265fceca06468d576f6cd6a6a4b2beb44812602b9ddbfad120cb1f211fa4515f2fbab7ad5c6bb92cd841c02dd61ab215b7dffd853c636de49cac62ff95275cfa29cb740382d0814c6f247841781dd09931c33c749ed4b7e2828fc8938b454c0c1adc1be5075ecd0ffa39f3c7a2959e7fe09a31f22641047bb02578e94d8887922e26d14effcde255a523deabec9f549eef55be47520807fc4bc9066c12e86076da6ac1ed3df2fbaa2aaf43bdb80ee7245f3e48f0d3c4488fb4463afc5a951e0570576e19691ba06f2116c9416475419aea4b1a274f988ca4eb2a386b0e7e81340d880193cf0f0fcacbe345e28cc0b120a4c5fdcfaf1b328b40423b7562b5f8cf86be8cdab77f4a3432e78d422de7ee9cf63c167efc5e829eee7fc9cd54e8d46c4c1d1907e3a68c112abd2c9c56c9d41a9b2656e2330bbf9877fb7e3695fbe6222c5598cd1419124a011141ba717c2bd02afae1f6dd0f1fa38664fc8a63fe0d338acf50722bf369b954a7ea8a509d247f7e0dee8e1a644f211c6b60069c5100f08dbeebf1bbefca005646c39416092a096b983a11b888b01308bc25b9e65996a59d11cab8f0f2fee290091e21649a24e03d6d7a61f7d21c96a55affc5dafc835bb7b15e17f9e42646801b993406799bcb0dec8c7d13a5556c821072409769d39717a900acaa3dd7f5b6527102cab3fba229433cd32ce880b3c98d9d349bf4371e173a08b07bb88d49aef82e2d5fa4e171f745935f57d9c892001c567b6c8f62f4f6ed1df8d6c9e6debc914d54475c7d406cf1223452ab717a18e065e2c579733fa84dd129872c2827643462b2ee8f3d51b1d2c33f5f6d3f5fbb6c5e590dca161a4cf32712c17b54d6d991765c6d712c5369e038e24151ab8f2ca326b9cbd704588a3badc7ca566a9f603624c857cf991ee0abe30b240388dfb585d49ecdf3aa3e53f0f5225fb72142275e7fb5c1848efe70ae66b8df1872531756b87e5e8097911df4b74119b45cc35e40cd16cf26ee9d3a5971a5c0e30739be702b24adbe27fee4270ac0d66f576a7bf0e8d8312b8f5fcd29cd03f87a6bba9497521832f8e113215c7b2a5e5f51915941e981ca3c1e2f40b63888837dcb25a1ec5d61a07a5cbf70b6428a71198b5508126e46f028b225fd71b59f6f9d743e143254dff033d8a43836bccdf21087eb2af87ae87c2e8eaa694056699e3c83414e3c8dc40185a4928bdd8249371b682b8e862f173dd24245927b4b811355c247755970a00aaae0f39774fa407d22be00d71d30d29bb1d971d45258db9dc815a0afc1bca564574b8b724ae95371141ac20971830c5aa060e062d05bd651cb0164b798712a293c5c9434de6c1d4f4606326d84d982551f18c113e6ca1555aa7c169928a7840c54fcce378db7e8e07afc8af6aeaef7d09972b186ad50bbe2942763a5d66f3109e56f8bd882beaae39214be8bd3726d571a66a87f7798feddcb85f8848b9eb36a8be32b1eb7ed9a2110e49dd578e8841bacb6fe6d5664fe73064284a1bc2417584fa26ea9e49104cb9a87ae5472111bebd9afeeb1ee998939f876dd93f17061b1aa1de3142fa6500b09339f6dbd0d79950ae5a289f40145069390fc9fedf943208604f44ef42e881cfcbfe64b0302f571ea10f4be53114352ade25fec71fe64699f8d07c0ab45ac210abef042445a42ba54830b822b5bbbec1f27bd67f7ad266c01cf8da0159450729374bc0e3243963944f9666d69ab6be1eb4f61648b5ed9dc08c3a89f41d9d60c5fd163b4e6d6b85e9cd93386ec7e8cf255e29a8f87c50997e1cf610c7305930f02e691dba03e6b49f59db7a5bb4a2f8a47d3f2219b21b413aeecf14fdbef30787704c3cb3d44a62c82271aa132d225a051dbfc7a0172b705da616d7eb85c71ebe0af201e9ba40bf19df4e8335a305c27bcfbea86ee9044a21e95b8874e6909ffa9e14f3f87e7dcb539b26583cc688dcf5dd5c6d2024ac9a1752a722d37490776613675f3f90ca834540d4ae532f6beae958dc70762059337f9d6b494a726337db7fb3703de0533939b955e128a0279598cc7a50084e6e4fd5f644007f83941be098e908a8e451c0db3620365a864389a2d9bdb3a6ae4f41b67d8cfda7a876dd2f39f72e8af7b1076756e3aac0b3eca6312ac9ea8dfc58503efb39871e022f5ca5c07735d74df9c841fe96587b7016549c09498f3e9587dd0aabc07dacf6ebfc76d76b6558ec36fd616d9feaa227daaa714a40a6047fb3cb3cd5d13057c2308ddd66516c0077f88fc45b383e6410b3a343a508d75b373ba836be6afc840c2a4a6af912088c99ba8fa3ba22a7d821471513663b142d6d4f246b64501eaa16914c60df1242a97f1ad1b839950c4934096a68c7bc26d15af8593924581e93f2bd5a29094a4332cf2a449e654e3d57f32fd1260bb0239ae70d92a3cae916b8cab56a2acb2cd8cdf660bf135b3a8481198bae6921c1d37190abb32566ee93303809a844828ba75e88b5dd954c6b4e06696771f9ea3c7576fa44bb5512e4c79a1b6ab229561df7fe9d1226af943619a47a131fb93924a9b14940bd2a11e04b0d881c0e714d1b9080d5b0ba266545ecdf4803e15857f2752640832826ea304f7d7915eb8d58be2f84a9bf980d87cbba0dc66f513b805b278db726c873e6f7c6ab0886ab2c7b9abd1d0b86bc557cffcc179945732e81e50c3b807900fa6fc75a710101893237e976aa7c0fafd36030aa1119d27acf05cb45c1d7e466f065206f6876ae6cd1215962c59033af6d685a69889f31cb6f917821b7bd8e331f3dc905f3d26b8fbb5c8fe785248ed59e2a40e335ff68ecbce3f916ec4f277cb921cf84ae23541dbe616365b5e0a621ac398e8912046f1acb0e6b78f608928328330a8dfc6c003c82edffdde1276fa90630d738a8b9bf80c6ae17574a95070ccd3c0d2dd9cf5f1f866d110cd080d366e6cedfffeab35ebf8f030646123332dbef44dcf3e3cc4ef45c095213c1ea560d79991b43895b73ab706d71213e4b6534d6c73c95dca7cf3d8d6bc83e0bff25d9e49268c436452cac331bab712a124d2773454e898dad9e2e800778cc14948407213d2ebec28267132983b7df4ccd15a4d0d5faa5de926588347cbca84590d9cd782a4bf9e12f7b2f23afc729ebe43a9e1dcb9263b58c3fdd8b97f6dbe531f4b3fdad2f5114ecdf89f3038e65f2e8a3b75f4d0a720fcaa42acb70442d7037365104def9f4df8710eb85e0c475680c509a417c03c4312c8abaede01ce0a3903a4dd28ee17d129c08ac42f208955faf0eb203caa61712e6b3c94d2fca03027b019748db6fb0df7050205cfb846015783f5859d0a0f13c664b76808f2ddf726709bacaccc508dfc2462f4d1225d213ec228774458bbd409de8a896ed57e27ca5d54616d5c4211cf201cb123a81477d880413a904a2cf9b352bcfebd75f82184a9c0b89982148120a974851413143841eac12148b53013bb16f959b49b70f9f2e12612de3907e01862a8d4450cdde51d22cc12f96115d5757a054821f5c8eb72baaf237f688abbb69437ea56814de5ae4dbe65100c54bc6b3bcb60a0864fb0a90bcf55b3e0708ee6eb830fa5f36cc6a430c7b008831306b775bb26fe048e4a6f953f06210160179e599a96e2b6c89d2ef79a17162ef73c777b8d7609280f518a664384ed90520df3559cd63e572e37938f63e4981641009911fd7caddd8fef5f99463c88fd2e6b1ad8a882783f61f31a7fd7ac85e6e0fa53987ab54664605d954619f1fe6882433445b109e93eff28646cd27d8783fef1cd0ec52602e44683dc9445c69d0b58df8225891f7be19a2c1e589580956efe6322b0f14b2df091bb4b12e239f0cf38f3f89ae5d1e838bd8fa91c49cfee4e9544328034ee808e810f54dbd61b96358adb4437e1c2ab1af4d26a51e34d250d3a8cc6cf409f2e93e778dc77cd1f019e639133ef7411a28347278a14b1da5582a257b581c9d66e5c8f13949ff6f02b7e29c4dc54d245f82397c63c946731d5bbadad54e5859785f28b66b8c493aca3ab2dd6d0a077a923bfc4e40563f8ed5624cd6287e3bd3b1709cf41998c68bc125bc13bda79313cb4f87af64894f6abc9e6dceb36a273fc6ead7f783346cb71e7cdb0baa39ffff0d06a244c33316b9939cdfaacaf899be2886137ba51b30fb26e747219ce173d543228e6b72e976374c05ed9085823f514394e127343244557b3e0ce5068b272bf9b3b324bd31399674721af04636d800de941b19e2d6e47f2e77effa562a13fadeae37aa48c8182ee4f319820d6fe438b64668af6626886b9e47953125478b35f897202fc91e5701e50f58f037741c2e01d1279b88b9d202c0f90beaf273f7669d0d8fe9c953863c408ad67891b5f14a1c7e1f4f5f00bdede4483418936d02c8d8364367316fc203c45bf7aca78a55940e838c51ed66d34376bf963692db26fce3e726aa87cd3176f40b9fcd37c6592ed3109787229682908885a9b1c9a505bbd4fd530efeb62594a9bc11c34740f5e00c461d0efe85a5838156c006224b87fa4fd4e6685e06624d005d28dc027cb37817c53970772c2bda4b1d42cf3b9196648185f289c85a1f50681d2b0d23b2340a9de85d6ce353e201a993f4d80bae8c1c7a017a22ad1414d177ae022b7918d28df1a8e779db3575a4b4a2a68eddb5cdd74a5e78e3d10f7c1d3e4bf19fc171e2bcc8731f9f4cb566bd67a57c10d3758b55d75e467b00aa82d4fcf3d4dc4af373098e44d5dcadd26eedd9753daa7b10286883b5092f458817d970899e03ddf34ae8cf070ac036431e08c154c67f429ebe8624d612f1a33e4511fa9b764d86b52b25127884f4d84392adc33e67e11dbb5223d2114077e11fc9b0e3d1cdbdb867dc95ae46cdc8692207832b04a1164e9841e850a68190f312697e7555e32caeb60eb50cd4da741d5b62fcc2ca44aa532af32b38ed4bc148e21da1fa7b1be10264dcf4f8831964c5d7d382a35f6e1d7f370b98c33b9793f43f7e93232f22240b113131807fb92a01e32a20b32ee5327bb2938fe71f26ce7e7cf049bf9328115db12189e65c63b0f5b8f8c74200cc838912be20f7f7fa28985699c872b4b367efb4f3f5490005efbc57d4922f5026c43bf5521e5536ade1f5e2f043935b917a9c5b7865544ea3eecf489c3d7049c7e5182c2140a16fb8a9f7e664dd25f920ecc862cb36f5793f8d5e990a44e4ba6de1986b2cf2592d2980480d28d33af4037503e96daa88798b132f072d0084be97345c723c97d8a6269440e4d46aab02415cadd51ccd7556c4d78fd1e526b8ef7a51ccd3a074c08862d698b8766a58ee5a83a2043c6a3079638debfa7353d7d0af4cb048ab3934d51bcbfd43cd3418a617265e701717fc70499559c165bd22185b73bae06b7cc8c938ac5485d5d4fa488f58d88fe5b73b7230f2b7a95b110ddd6af53060ab4c26f667b1d7f12b5da4c35c5a473576e4090c74611eca2209341eebd26251bc0e2886dcf655519bf0e8f8e4d9e61513e75117821b967efbbb4c0598964fb487a792cef96f73b6366ca35f0a0e0e27c616badf50fb747b47f7f7c51ccd98742c2e707213ca3660592dd1a459784ea28a9f6afded88222245d8fe7e6e1522ca1edf1e07ff020e826247149790cde4f8db15c6a3398913ab2a000b8cd541745872a84551e5cd3563c7e42e553372e8a71d17e8d7ac26edbcfb29e953ad729721fc4f21cd40b41994a6621daa09b9c09deb457ea457f1b152990e0781160fad80becde314578bbc6d146dd6b9bade42449bf3a171f50d0ba5e58f31c7324a1fb059b16069c289ff6f11cbe472c5d8d7d4524228714d013f018ffe1913f377bf27322d8ef590206645e8ecda56c22590da3cd0c35bb47e47e09fc517170f1e93ea20096607832ba86e94351af4a6c2ebcdf6231334ee86072bbefe98373c1b22c49be167291bec2a6ed981cda5be85b7d788d3a0594563b97a52142aeeffe348e42db11dbb4647c70ffbf57a86480fc7d22474ad44d5f939a9408c99cd4b0ae0d8adddc6c11fc9b13e51f0fd202f4c72504f6cd7a9c1dc50c7d1470719d931dd22f052568373e7694dee4a621e583b0153733e1a89b48228460330556191d708f6d234c5baaf3990522cf1c679af4ea8c056e6605175071742d3af1dcff9a07d0ae876","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
