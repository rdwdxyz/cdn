<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0959ecd457c8e7035ef19bddf5315d29e6c284374fb0a141e1361b3141698f6844fc7e4c4d8af2aed322da5e9863a631e3eb1eb4972d817072ce1c83eaf6f4664884c229824f9bb21f99fc68a4b4c66999650c7c67a86a1d34b665314678800c3892f236749994062eb93c215d5aa2eac620473067c25941d3021ecc651b0ced9477c3964bfd2b272ae38e486421145df2fee157049d87002b9aed015d519d97d720023a9780d26128ab9997b314a32b83411a2d3a929b9e6bc16363f0e6ff60ab69c3c9b8f300c81a56310a16c3bf11bf51928098913672020b687b25fbd8da15f632b767ba49dd8575e46c9a96edc136c7a8b88f8bd55e0e56515374756c24173d9f11d0b7b42d1f346a0dc9440f20cad8a7f7776ad47d99e53d14a8a8de1b9c056f9cafc65012d21188236fdfbdbcfecba12e55998bc9aba56d0b17aa467eb17d9ae7ca9d5ec9b9155647e3aa151cd3183b6a393f1673c8f053c2a6bdeca6e4a58e40e6a873c87bd1398d0b8601fb0595bcf4e7ec0be8e41327501595f6ac8fb191ae7fee5e9cecb6d853d662d912704784e0c8eb18da23ff684f7fdc9f405ecf1329748a3d058c32c95a53ab27fe0b128bf37486859514897ccec5505d10b49acc33613ec2ffb561bdc10941e3ee97159b74b8b4fb2b238ef537f55f8acca1bcb545ebc7b3796466f6c075c9bbde983014d93055462e0026a1df2a700aa2962b5f0be81e31552931b41b881f56b28924e3e326820fbd6f0914c9495e5d40f318d5bc38099921b23b5cacf6b6791b5ea7263d292cda9ad670f1b790a493543a72243da0d86fdb7624091e3a572f472065aacc5a49b641bfbe1f46bc583d298bf3699212562f2e00c4fe8093ed814b81e8a36dd1760cc54009c812f25937bfb895a27070846bcee984cfe8780212c43712ba395baba72240d6a9cdc36abb00c5a7c2026796fbec5ea2b4509854d78485cf742ca665f7ef04caf163b3ce907d389a8bd85e4a81ae1fe46893d5d517bdf4c1f5cc01cf2a139ce95322e6166722468edf387b493943714afe8e150529b6fa7d5a2d324a60ebc1c96595baca9822cb13ec3bd8bbe6ec8ab960198c82ddc683948365823091978ca0ef12b4cefaac832e5383791be603de252ba8a9b3a8bfdfb9f27e31e4af20785851bdaf51f7ef9e3051be548193eb3c2f662b2781d387894cdbcb320c8cf0fde05974fd9ff18e245817eefef3a42b72e8e3e3cce1cb0c8b413989469a43918d522bae8ca247b891d8c128c496fee42d628b7c4d5b17f98a69f88236c8a85ede7b18ddbf4f4bb9970863eba8e82fc02439b2136947a611e4ece5bb610ab52b64907fe47feee406730be5f4b1677c422bdf5c2652991fa205a45a08e8d5b130d5ba314ca310c8496d47e01e1e649bb8400ae4f046109aa717d14401cc975678323a744672b85ae54425aa411d7524b8d1e6dc556526d7ebb1d5b7a379040298bd1a23f615659b1b647f32c53afa851ac3b9fe885e19b8aaa785c679300fa4aadbb778df491b2426fa714b24ea9dc157a7d9a41f246cbae7545e1ec90b36a7f998355243b288578c95eada503864f474e7733bce5d7b1103619178c61ca5f18edaff26c0c1201d3e49d7437472d67738cd9bf1c221f459d0160bcdb1209b4eb9d9f03277eef4728d82c533e00e6254609890fb33488dc035a0a2651d930212d6427443dfa622cc28d34024aafc4ebe71e0e5e669b6913781604e5b7a782eb099e32501585a4b1c346a8a8f14fa9db1c8cfd11910c612fc9771a3ed9db9d3707c758078dfa4f901d6c3818750e4cf84ce90f112aa146b0dd510c010e28efcbb7230bdf3a690c4c744812dbd15952885d52fd766c859b0a05ce0abab557af63388c848850090534aa5798dbab34b494f9bb5913e9681fe450be7620f683a372a48eea0ce66ee9c7a458827bd1c50580a4c6127ada7ac22b41ec26011e5068367ca1df96a93e8b372e9617fb61fda7989d8b56c16af6a35054bee539e60be6049158acf1a33a284afd37aa797671a86395c19ba0df35ac2cc16aa2fcbc52709cc4b692ecacabf2955707edaa7bf582485729c5405e1e9cbab39bbe10a38ca5eb254db169bf41bbad7839e92e2a06880fe9a7e66b7125e619db479b0bd8a2aa4f6817a57edc62c9176c5f1dcb89fadb22b1e5aef9e3e10e41c185e7316c5fa00c830a1836b080098252af87ddc39829b077ec48041146c7b177ac838bdb78a6ac129752531d78a1d70a2a5d70aba126755e51939c487694cb55148c5e90b9e06362c4dbbcc3b90a2ee711b7c1672e6d5751106062b881c1b09c0443e6161bd1b329dc7b71acbb5b7ce5ed55a3214fec1a6dc3a5178a29e904430832ccbe3036c88b89b82b0b12d7efa559aa8fcebfe14e9296a9ca0316940431523a9c96f9e3ba778dd49ccf3d429427dc5f0d623b0a1ea74888cf4302e461d0b5e6ffee8a9101680934ca62471fb6b91df9b546cf0bb46739d2b44718448eb3b4a559ef7bb5ec95eaec94ebf10c971dae508415f8d0c658c64c176bfe5c594e30c47fd1afb278dd693b9888d627464c1d169788f0dc431b18d64bb87853db41e210b05dc204891c467bbfaaf9079966135be922beaaf0dbf91eda7a5a48eee0142ae38e4fa1d1f92a00eee9a4d16029846593f716246b70184378d4da20bdec31e7cd5a44dbfe893f1d6859b6e7a7e55c6135d4d714a0dbdb486f3d2ec7a487839988f6ffe24704b243c99f362fd838add2de647f8310c2a756702c45a02ff7e2ffc286d09e6ee9442b1867ce60f2572d5006c8bb62ff16e473dee61688e49dac07be04c2e378cb3c87999098e121155811e5fdf99ec2ba734c89c5a18337a99c6ae7b533e8dd324751feaf396bc5c4f25ff225888f0cbb12f0d2d4a39afc617e187c31efe75f358b85d4e24b0f9e9077a3178da2ce522a02519053ebb39ec1d577878ce6141af50aab56649bcdc628b8cdb2922ee21679b5949603b2a1871a61acd5cb2495f995258798dd404ea2675c983923400334da2d102256ec2181d5db073fe227f9d87c0956f95e1d521eef9ee64f49373f1edf35d33872fd50242a54b11f23b13d25bf00e7393728b6fc2d55d0d37dc77aa730cc88be943be8b6d41940746aa88f4dea09cf8b562c90dcc7b4643b5ab1fa66a6e9c5d58ebe30154fbd298973f7f6710765537ec46ed4ff0bc6840ebbe034212765b84a6b854efb01e73f188674a5fb03de7f24405fa8388729fbf7008bb9534bea22ad917fbcf01312af5ac255a230a1f4266a163eabfacb7a6afaca188a1c43a0c70bfd7fd16a0475f8b18f2b536b029216e7b747f01d6e71ed9a3e7cf34706a19019b6a81834a4175bee6d91c782190be67c98c415548084844a72a37e099206fea3c3f8a197a67d127e2dc6890d42f3e67f8c2eb626d63a54f87eefedc85f588b30223186a48ca25a49ef191740a0c4ed87a4ad6a2e976af96d4714e369a740b078fdd981670799a64aecabb4aac7d786107a92aa57d6014b8aa5bb88680237ea3a6194946dbbcc61565063a8568fa9758122f494e6c3f35289bcb28bb006af5bb6dc26e018fb6075f0bf56739f37643f545e45b7dec0c7c52e5a1545566dfcf5970817829da7cac069963fc41ea5e01346765ce8a9582fb85a342b0e87126edf6d28ff00dd507197ead20454c5c481de868261a8236090a62c2d524d01eaf9be8d0851d5541f31c560905f3fd9cddfbcc0ca704cfcb5b3b1e4fdbd331db0633c07835ecfec45090ea97d18fde19ea46e7af4b95e8b24d00fd12be68f683ace4a4f6f8ddfe72146cd49edd53902b3c5f80c3889e78d8fed37c707f6a6c02b5083695feeeede88d161c8e61d15fdb7f3b04aeb27d3236e3d5a9e99ee9a4455cb3d38a2adb1984190069f0b3a4c9fbc424a6a2ff84f34898a7749bffe6de7feda912eb5df7ae1bd8d24f6bfad6c6a6afce23362d9855662ae3f0326f49dfd10bc996ed82a96232b83f1e0deaea3f87ee5ba6c53034d0974ad1ea42da350e159cd37ac1bd78825c3938e9dfd4e42fe2da2d187a799af678c99b221c77723ace026e7d3d37f03dd93c9f159b6dfa80a4fc8ab9fe8ed9abc5739b24a8b075695ef336976464d6a194f29e5c95cb37cb06f4c2260e3f323a3b23121704f1dfa365d53a62f6e7ceb87e893f5d453eda509b026838fe3554aa8fc0fb2c30c987222e90e8f11229f128d4771300d2e4fa6d7a9edd938f25718cc2268ee35036b0ffee2efc5e25523ef78bb3c0504c2d6dbb9946154fab7c1094e1eab47103004968d11601308fb55c884fdcef4f1241d3f1cd6eeaab09b1bf67ae7767fc36f25e3cacb65395cfad0f55504684266130ee3ced70c47571a8cdc0bbb254f2bd4a3988e869e5737bf064ab96e10cab2ecd37b8daa3f6371c3e2e7cc0eab2ae1f59c87e68ddce192b1774cffaa652d30023d7e395532156e52e79addf7f635009e0eddf0b732ea76c54aaa5d6a25ef96e6171438501bf0d418bcc04e5e4314db1f0590804f87c85d71b66fd27b043f95d8defced429fffe526f326cf8094c77e132173fa5af132588dee7685243835decba1098c03a40fd817a21f723bac0b9e2e6a149327264ccbe324a0242492538cb7922de9f4348e1ddf22225f6b8f2a3056fad24071ed63aaf5c45d8428be984854e0992dbb2bc5fba864932bff03dd330fc4b980953ee4356e4790db705b25526f59545b236b72472fe8f8e450b01589e98a5cf4f6c2d07bc523c2e6c180f28f7549bb288f1104ecf96f3f0b1787cce58ef391624dc86012c6313e656c990366280567dde60f0396fb046e5e277c084632e2cf7e858d08fc4ac6bd609718f0fdee98a6c97991c573f0028e424cd6b5e0f7077d3e926779ba9f9f326f2ee3145fe58f7d12a612f29db022343b7794511dd417005b45928a0ab35c66ddfd275d9ff9c51cf82f74bf193819e0d7baf8469f4b116513155efe58d217fc3f82a4f60c0ccbecfd4663a39d106174d891d514955fbe829ef435e496e21de81f4b406bce09b9d7d34c9b7646acee036906c2fba82082a872ec1d1adb0b7b99c863a3b70ee8e1eb403db123674a61c5ee333d56a193c59e7ee76a0b692f58eebcdff048b910a9553a98c904548c53da7d0123a96e59a5fbb17b3085db50106d9c310151b81e6625c774dea0bee9640cb3f3df3a3ea35971d27d9668a80c8c053dbeb3c6267fed2feecacb162f1c8b9b303733d42328bf0a46cf283939c6f0fda9b0c05a1787f6b9c32a28b2cedc833faab6cdf81e7c8c87d99139a679ca83f609d1b80537efff00986d7d6311cd7718072583df98d9f8f07fa5a0a885386ae1c85a55e17f1881634a5c767ec75721ff9365ce40f6055a84a1dbf1f9d2e9f9f67d02720843bd87aa83e2ccf6ff36590599e150e6612aaece3256a14c0022cf08aaaab931e496564a6862b24678bf016dc1b4e1047cdd98f2b0a41a745efe55d35eda2621c1caa1b2cdd2f8a4354db8dd511447c6e6e2c052d902c60f689bf7257f25987f740dc3ce30ddd148a4322f13f2133474f843fbef45c0179a84ea9defd2f4d3703d3e2a33580fa218338134da241b3a40e7ff2d272be2cd4f3f44dcc2f4555befa531a140dc2fa63effbded44a7ca8375b86c011d4fe99221da9dbbba7d03bd3ad02200176f00de6042dcec669aabc321c4a26afbe084109cb7358c9f3afd02f30f0cc522a02c89b92f2fae09b1ce63381d59f72b123296f3b9c29a54a58fea54371224cabbfa8672015d859368343c6b877fd8370d657d13a4f82717e34b0878b833e2cf17ea1cfe2bda4b35b591b8d01b0a348c59c01c8a471d2860600254c6e5bdfb0a2fb206ab16bce8ff1e959f55b9c5185700113328d85b6c405fb2b5cf7a83f944cb378a208ecd92ec7a20613d3ca490e2ab0dbd80bd75ef281d0584b198fc61024a298e1d7f6cef7be4aa0e2f9575204cd721244bb68715cb9b8d45d6d198b95246cdadab8cb6f02ba41d81e4d42331896f019190c3805733529a480e1c63795409b73753aacc34bcc9d6ce4d1b2078b86c4ae8cd2b09e657cec53039f5202c1e45cdd3009f8098d817bbae7439350619b3755f081804787f41c6ab97bb25159efce2963a18480ea789675704c6f5ef58f22cf61e0c3f1d674a8c8fcfbd35eeaaaab61f81eb76c17e70a2fa3722a1175cde17460c3138ec307591c4dc18401e59dc7527d12913270630f861df528050cced6ab017e26d7c5ca74ddd06ece21c6c053fc96b232893778910f1a741b108cd3fdd6091f1b2a14bdfd0bb2c0f41edce5435c9b5e5705106c96b17d810fb360ac9eb0960361f70b332f86510728a3740845c50e29c8552c595023ead82f2866461d20a199f48f6b1dc44aa02bc5b7d8d04444c08de961a5a94590976afcf6652f7257dd5b1b5e885c00c0152ea2012377bf85608dd727dbb03b77eb6b41dc20ce3473b34e696116f05bf2e8ce72357156c449ce855f7bd3937184f08e817789ee4bd87b40f94b68fea5ffe07f2eefa73f349f15039c5b4f2324edca855733f78a004a857cd98a0331ff1767792992123025f3de2903a74642e63053b07978dc8565039eecf796400db0df78439804845286aaa3ef4b085f3e08ecbd6cd1591721ab05db47a27476445fdc5665b5bc02e60ba3dddd379c254f2b43daa9641a025dde1992bdcbd516c67420b12aa423cc329e34d89c4d2e1f4ad290fcacc73e8f640633287b725d8147ba70e11c97f61b1fbfb7c58621fb2e3d3e50253b18eedc30d8109f0f879bc715bb1e3e334f842603f4c4877ac2a25278599c8e86534c9fcffca2eb2115fdbab7ac1d2e3052e0499d0df8168741a4c9873bd71566fa57feeb71b88029b221a3dbc437bfff05586c80a5300400ef1c65f719dd0c159186cd93359f82f43174f4b0234258c4e2ed9d78a178edd9190ad523799fdc1459004676a1df14bcf89e7bffdee5b15417041367bacbeca75b40e0fdb700dda4129b2d8585138ca1bed9eadf580d6460d73eb545703b05e86836925c94e648ee9a0b0fd728e2df5c4884842e0b3a5a42eb6568061d4e4a57005f32e8a0813e46434b040758544cc27a9e5e94ebd665295d95603b06e26f30c29681ff7dc2baa7c1760c9b3fa5dd7338d92f591cd386e760dfc5ab252a16f34beb7119b551187ac04400d63d1aab67d889ead444c1ecafafecb34d3eba9a5bbedaaf39e59442fc656fec0d4d710d0443143b987462553111d539bfbdb08e6c57e180c59a9ae8afcc94f2d4a4619764e3b2a0ce22a1332cffe74db9645911a5286fd257395ebeeb7395cae769e68e599f58ea2eafb56bc343e690b57bf5b97bfcbb92917fde4dfd1c985a82b0ceea621e778f7266688937cc03233f829886d39bbe4d9646c0235463762c0982844d1d719c3731da0ffc6dc8ca5fbefe59482a1a01f92dede0d5610cbb3c0d191ae6995caeb95e8ce2665e9d771981043fe3fcca8690ab96131ae9b9d20abf492fa2af8c82ad4cde138593784b12d8dc05e4d00a37cfd49eb54c235ff03e15c6bb24df65eaf36dbdf108765b21fc1768e91d7220a5e6ca40569ba648f4f07be55eade3fee06fa631897ae22ee4c3cb28ab7d89ed74da0d0b6d116006e4eaef7e0e3c640ebd712fcacc4259840ac0666458c43fa3b27fccd3d8cf48ef381c7bae98402c2cbb2d2e258039495bcf25822921f4e953abd2bd3f78d0d183a199823c53c7e620a0576142074608d5a1d81cbff3d506992e0607891e4e37543a61047c81dbfe04c93da9b324d5a6766f2a8e4f41be357ce15062791db05ffc703342b6a77ec56787a7d78a80a61bf164b2862521ffde8d9b109bdfe2e55588b0c7797045f7da4537270f80a16f4e986896836c8969f8875742777c91d387950eb6b11981d5438fb9e6cefa938aea5b9a6414b868e3e72a16641f53a8a3dd4582820d583d2b1228c21db7a9ca61c409800ae4397c222ccbc8dd043ec702f3700fc786e13a64a3179270cb09f1edeaae2ebf70d1d102df00a2c1c45b52a6638f3a9a92a821603615d2ec8651c474978ac7417dad47b7c27f410efc33e9be6ee4cef5315d951e84a0795aa1823654e8c77e96e9cdcc29e5647d43a9dba47b4a4bbdcef7f1fd5a661c45b9cdf80ca13888ecac586716bfe485ad5aba8c2ded8233b85b5c62158ab69a1b44d5ae94a1f1fed97aa81f6d227a343869e72125303a8b21f2ca5c1dbf0cc0d16e2ea870d560e87eac11298731d4c3736f54f29c33d967f6ca2378ec0e5cfcfa4c0f7e1618a0feb10835cdf52b6461bd4bba0f174ff73da03a9eb86d9696af07e467cc268d6284e8a77dc2d9d8758f1bad15b85c238f116ce914dba1147b5f47607b247d7cdb83a8bb0d176beea685748fb838b4d3c78903c0d32773254cb488d4c4d5729bc889f9d95f501f3381474d448b1320fb7dcee40dfadf2036711fd888090c3e03eea458d1607e09462f560a92b3f492e0f8a3d6cb2ee611f40e5c6466094fbcc4f8b4cd1fd4d80350dbcc67223b3cd82bbb93982907d0af126074889fec5a7c08dc202947ee06897e90bd230e9a0f88a6d6a978a9cf488836386b7a234d2eb3a6cb56b655231928b8eaaa6c889dc4c8eb9eeceb50bdb870046505fa143215ed88beb7d507affe4870c7880e55f5ac1153a7b1e349df5874034491013187cb17cc2005f27c9f2ab3bf811c88bea60eff766ea27270473b0c972de76df360c44c67525f312a8292521ecfb186fa9600ced3390fc3b7fa1780f27c99f70ed320f4cbf0ab12bd955b6a7cc38e85efccea083fc9c9f89b0dc507debeb7b23ab6f399c8ef1c480d83c9b26ee4319213b66cceac2807d932186d54790bb6d0cbf24d5fbb7183990c846927a939e0f2b19226ceb6d68f3ca16c46931d0fc3791cb6afbd4fb4d68a2277fc43e46765f00e73e444f8d96f1f192735b0748a853eb3b9af7e32458543fbd56486f9bfd0be3c056b33a40d191856cd58ecbc854b53ed1db681920da2aa8208e2090b1c9cc60face1c891765038fbb1d042dd3dd6ba609d97c85a9cfca37ac15e14491fe9ef327111d395f76cba266842d775b4ffe90b9f82ab364ebb1d55545185969c10858db55ab9a6283b37ba8c35ec3e995589c7b73c2f5c103a70c1ea8a425484b7a26a088466faf989edf2d7c9fbc660cc778b2e39d270fa7fd1e661f24d5459e84caeedf2715e787bb1cd94c3a5deef02cf87ceff37157c68129f0045f1c7af7c46004f6b15142cddf9545bc3b7ded98cfcb1acaee5646a3981197770dd91ed57ce8510c37e6ebb32594425f9886822cc343e1e0f8e4e1c0e4402f1baa598c908282721ec14fe7480d7f766ef70a42983a6253c4d75c331bd8dd3daa22e08ccd694d0237ddcd1379fbf198aac9bac595040b457f75e0a88844dd15d6e33da14cb598cac0b61d7534e2c30caeadd9014d7d94a5d7f135061cbd8316c19f29f1929f29505fef38991e5c7063dd40f59689f9bd40025b4b71b38585d698e179be154c9496f039c77ec71d54284aadecc561a6bd7fc9dad5f40ee8525eca530f0c82c5eba1525c0950b980cbaa735b13877374ab2c18b7b575be4def5e65302c91035a1239018c62d7e03bded13dd905a325e2c39160311873c5c7c6dfcccf55384699d50712f7b690e3e48608095cc218062772ac940294cb9173bda54a5aadcaaf9ea7618826999bbc0548f7f52a18fe28782eb9387c450c2ba484bc874b5537e94a89f8965dd853a2ff9f1da7255c5973875643fbc9196564f05d1bc4af80290d931ae1fdb459ab8019c1f17b0d70fae98de193e0764401329850cd924104d8b8b054caf8c1b15f7a49c2c6f4a55ed4183e0689f96a95f29f04504ba80e66641583c9b3e6b993e185a30c9d72946cc34347261c81c9f1049bce273426b758a6d0e2ad6989628c52b2ec1a31bad9e4a0bb9c07f53f7bdc06e6293d44d15586c626b447b29fa0493c8188535ca021a53f9ef9a5af709690f6b3f83859417e2adbcb15c9ecd9fa8bcb9ec0165edbacc656e483fee524232fe47816de6077c494fa7b8e50d1ce3a8110693227e7e41c41c8f0f566312694d6a8e0b4147545f7fab516bf81a9684a86ec83a91dd23e0813bc327fc6902370db8d3a9985745884d5c9c1398d91e5251ec46c48890e9f910c9a6a8e820e572e6f99f09fdae34e418068d37526bba550c9cf9907e3f76af3db330dc35c94de939771d19b227cf7ad1f96de9a38c84ae7235b6417742564b956c61afe94781d29fe32b77c7ba66c1c221a160cc5c581a95215a9b805dabbe1d6102e0c72a33de8a2841a64c1f01153976b2312b5354443a0fe5bff1319277cfef5e1a37afa1d932e6ee3b3f99a8d65fd43c005ce87bcecb330361ef294b279afcf7a7fa6b22f616689200cf22721ede55f5d91a3e1f7208f5901357ef393eb909c745e18ced31b9678e9b135773df4b33e7ea3b1f514224cbe696a3f3838e0c8a01a109efeaddbebf67d7556b5a011f895d0ef7ddfd3339c6c4938abd93d08a02dfb80b31bff97fe9366faddab87ae8ba6f688f6bd07f00aa2b1b84ac97faafc6005e151a8b7d2524b80e20340868e05a7a3330d5386db9ee02e8222bc7f662962c8b7a26a16c4c08389feb31232e07301eeadf862a60e511ef559a8f86be0934d6441ac1f674f8983bb285abed6bdfb6d82fcf8bcda4b9fe02893fa2928a8d4f548d7cf49ec048f2ac58b06a824cfe234b5c1dd274d64503f09b305d27c2f60a7de621b7e5b263de4f7c04db30a18ad485ed5c6dc0371f7022b4b59c91c7f99f9f3494c306cd1173ae7db524a1072d0ad18f7075df8fc04d176a750793703dbee3f3410f2700de1a5716b6312341bc5bbe4904f379544e057149bb126e284ebebc9044ddb4af02406d8add15317976e25096770b9e8bae523fa137d484ff67e2a7cd170ae6d38bd5fc70011e0b7aa16a13a4e602825e5b8287e214a8acd6ecb7301475ec98ea91a49af8ac4b68864b255e5f7ef410a89918a5f167c49ff3a32ea67ad3fc4f0a296e84199881622948923af2191b7088266275e074f81b1b2c7ffc056ccd06fa906456a0b7defd99e6228f1a4f413ec7f160c688cda041d16fdbc9852c711bed31feb89009ac00e39d8ac616d4322a3686aa5ca53009c924de3633fe0028b94e440908c4b0205959c621ec272e4ddc66039494c5030776c386e35f048a574332a6beae49de066b3bcf0c74d6ca15eb19fc9494875efc0a65eb742baf638ba87573026064b9546cda439ef4b2af5182aab78ac2e09430e810a19a1474ccdb21283882026db72fed0bfc5b958b8292c5c8112e1862d304be33349a445c756032fc399baa82396fa34127be186df6145bd8c23197a327640a1181a9b72bd140261b5f89721d6342b56924eff0bd122c4f8c64c687a8e59251903456534fc4473ec32f557a4e17f44490ff3bf1343346a1f1979be21ea2d70e939937804fc44444120a0135f2489bc41644f7b203605a9c9b49ebb7148f56b0af5e9b6b4d303c9ebd5e65ffca4ecbbd94e7faf5de5803ef88b01bfa8ca8a5c0cb550c81c526d771c0694c6b73c391ecd0317832435713f07213cd1ce567758e5aace771d01234bb6eff568208bec4ef2472fca7e31079c3f90280d383380d47dd990f8656f4e3b60505763c63b8c8298a86806b14827e5d5a7f9538030f36a6a6d9987c84015370ebf02372f1173b4d0a2dabc6208f5f51e7046aadd3756c260102c5eef85241dc84c74c7934dd0d4517107009940d2772e4595214cb257576e0e742055a285f52bfb32a7b187db7139ba5c8b41e2eb9a1267bcefb6ce02efbf0d82fa0474cc988de5690f15453393d23e3f899062b94ed0256032e1900489379f306aa23217045e55c846ad9c478e3ed3cc717608cb254b2f7c117a97708af04ae019eff7dd6eb566d2994a6c0dfdef414ccac23d4bdc2f35c4b98dabdde455a233854590f22f7a89f94037e97059b37a79c6ddecd249d9215ebd5e86a1e0866364639975763dc3c9302695fdf635f7379ce90a1a2f54a1ba6ccdd5e22fbe47389f91461592c9d2689751740478dfe1914a6ae34eee010728b8c74100a9ce8945b057333de8c73e9fc1f848fa4e6d8ee4e06f401db305c9bca0b3e173639112d93b2be15784ab3f1aa11d24f5b0022db5c6df2c64b888ca85dcb528ae4a003b2b69fe0a0307b73fece054782b21ee73334332329d26b2ecb0d220a248c4efc7b7bf24a1a80550311fdfeeb91e98e77acb2c41139bbb41360c03b4c8476280048b888c898833ff138accd91bab4fcc18dbe19c04bd57694b5095a42e74440ba7a6bb8ae2da24c666e361ccf5ab195ec4e590f5db3d58e703f93ad35551ad0d7bcbe71f09c8b8a15ae4e349371d46249974e53b96031302add2a6964112153e07f42a31df7bc26310ccf211f4f21aee4d1547f49b6f82867e391c29793a73c44bb0fd91b166c33ca0cee601fee0efb2b6e7729cd851d30929d18caef69ed2b8e39673729b6cc4e7ecec221832de8a808f2a296a2ef87a1d204bab698dd8c3db98d8f5f81dbbfbaf85be0c84f8f3a1c7a53b2bc02ab1ed369e199955eac556254491a818fb56b52183ac4d59af816c5a53ee18c5b11bcc66a658fcfeeca459297040877ae7c68e052e8763f70947147610bf208450e8183f7d8b814da60b968a42aec33fc68b46d40d33a734a115523d2b161e0c5b4330384892208ce0ad2402b8f51d7e03c81d8ee4ad2f7d351a7f5bc56b5c0177b0aa9839b5473027fead6ea89580bf923f86247dca603553b8fcff6a4c968c10e1b5e0eee12ba6788cc057a1a6feb7c9ede2f3a41cea73e142f9b0e43799ad8dcdda80d098a42f4f964eb9f26e1239e01c6c7f274b63f2c239338f30e2d16ca8223fd6251c731ce23e7416fd815c5dec31b418a854535482b525ffdb5ef75fe8385ccfd55348d8b8532995f72f5b4e5889253adf8f4dc8555f5ceb4e63b5bc663e0f8c5e73656758f69cc138d20dbd049fcad88d7374abd3960387d224f3662eb22329d6e43ed06fafe9be8df3b6ce4ab18e1c70cb11da9aaa2f53fb528376e75b8cda305439562d306dcbaf57fb405104842cded75eb034daf1a8d4f512b6d043f0417d2a0a01459884c566ab39e9e9eab7ad47f1d65262655b1e8d3648e61ed6c9186ae1f5dc63e8e8c00355ea17e6ff2d098eb725d5aa805b612dd721f02342d0fa86bf7c127cce879811b293596cd7cb9402d57ec74c3e39e5e6f0346dce0baba358d0ed4d88545661dfada0a13b9509c69472b276a7c70068c4be81986dda38139abc290336de48d0bebf407792693ab254654d503aeaf162ef3e1ec3902dfc41bfb45d49d9b06de44dd6b74536d1d1c9da397d96f7be6cc521c0522d265e799bae1aeb3ba4616eea47b2bac474f4b52c164b3ab9440f6b76ddcfbfbdbfe3fbcef581f0ec9598a9a7f6fba9c57694d1bfb2d7cdc87020b11d7f958705c36fd53601847bf39a2588cb9d69b886c6952e01bd892a8f19b01bb290b0c57e3b63639ea3278efe4a98e3e667a405530b9bad07563314a2bbc4de1e678a9fe9f1ca11c21f9532b445f2628078b8f483a1aa9ea12f9bfe3ecdaa34bedb45453616ea88e689badc5fefbc397dfc9fe503938a918c8d6f83a027942cd964706ddeaad79b9fec706c967c48f878db692276acc313aa70459f61836855be01a6614d8d9895fe34bfe69e5f52b881b47048a7eede5aa905a8058257d6b71e31fb1819a7ad9291451a8df323ca13c77cdeeab3eb34f1626a2fc493228d3562b80faf810cef6f43f5d444b59efa4be8eff72d5137a6ccb224f8e15fcdc566798dcc2f2453b995bce02ffd7ca387fd4516d8c46c8b5917a556daf99668d15c775be9695c984c84c0bc4d6021c060f1db571b1465900cc81b96b407ad0ec3e99b1d544ac10b64c6fa8bf9b52fcb257f25a92c9287b8327ad4c89ecdacdcb12000a60241709cce7eecbb198683e27ef9b68a0733120d1fb61bb7e5e17d142912c2fb37e009f8ddc65c2f2d4d25a1c0947a0a9bfb9168910e74179a1b0ea54d94e11b125a813c75d7749fd5e67229ed8f48b637843f534c5319ab60435f63596e8c600b841445d92ba4dcef11fac1802a69dadb47d68efce8bb19887f0dc4a70a3b3b3f8a5b213ea63cbd056ce4b003c7ba1d295927224a60e352148ab4913927b996c8503d83b4189b719405859307dfb728bdc9cf49dec3f04772aba9e3062db0f17556003e741e3aac3c3ae0d27415b479b1f18e1f140d36650377a5d2239d2b6c1aa4b034bf48a72426cb393d9565eaef0dd08cfe06296cf9adb2edad036f16571850adcaca3c5ffb13d3ad8169576c72e53dd1c5632909b5aa14c3cffd63fd331bedf7b9e0d4442d0eef3f2ac1476105cc65f5599cb1d4b07c7403fe5c4b7d303203c8176a6168da44d5fd2ae18d59c1e8d09cbc5b4186145b974077d582000208c6b35120743b88b8092795c39d8c940be14abfea222680abcd72db5dea457cdb7989754ad04e3cac50afd927ae7246497754ec2e25f96f6d79881249d0dce49c0e3020abced4b446e6803de1b586835e14deb8d026f79611497b6923b3aaeea285eb5d2c30383a7803a9f131094a1e2122f684fd7c9a6f54fa51e8609748b4e7d430bf824c220a5fcfb38b806c762540e6139c85b29a758191492b05288f40fb7ae1c364dd2596b6e9ddeefff815980f0d6be676cfb065b6c122ad3e3f4aa1a39228ce1a38062415b3d823d86b8c3fd56eeabe9122ba673f8d15a02cd992b10baace6bca3b9330e7895fa30a72557286bc3236417f9f4582b141613c3a140866b70399a82988b1cb287ac0441bc5b5387a5aa0b03f81c4fd310e1bcf3f111ff4ac4d017f4b021d0dd1b6ce42fa0e92ce2c179cda34166bfa0bdeac9b8d4d0f37918ff50b5d07ace4789b4528206861c3329e2a20beebde60ebdcfe99157af665b0cf7e52dc7bef23456298a052e8e2e7399907bbd3a97f422368b863da86ed05ed86d262afc6bc0dc271fb5c0b4b85d7746cfecc78a94419d71dccef709c9616a84fa695b44ebb512dbc5adac4ac179fe4fd6c05e2ef0cf3dfd514cacb3fb8c7339c4ad8637f39b8bfe210d46826b9822c55caaff339b08949706ea212632bdc57d9e3d653beec602842037808a7fdfa336edac1a4d0d9237870cc728bd3477303018ec808bb65aa1ef712a21d5d841c63aaa2595ce0612b6a96d430ca02f2cf884e55e8bbd1b01c8f48730aa66cdc4d647930c93ba4c56a395b43b3ee0efa9afcfaa647acdbd6ca97f68d8b58fd4d5d4691798c83596c40721ab952efa1fb08635f27c07b225342c6dccd4114d8c6e1b8f27ebe1276b0fb816d418f87a5676cdb7ec84800f99912adedcdcc3fb490fc02441c79bd031436df0b96f1ec215ac56abe064453191fc0ff85d540150ba19057380aa186fc5940700f3a9e2da1924b6d59a093f64b491dfc7533d23aa6ca42bab7d711b0b2d803a69a14ca1a5008cff188a6f5e438b07c1e629e01056fb2123f40d6c0a6d853857b38ed00f9cbfe0925bbe01418deb209d2cf16679de8fd97b5b75138090361e2da6ea623c444286ad8d17b87338aa6acb0b2807fcfb2abe7d4216e19bc87f81f75829d104cc1dc8949e1b45af15b40097bf2b69f0c05cee5a683358da9cdfc0615b17ef62d62a99a6d50bb2e4291e721db560725d79e22c71744f59b31911beb44be4730fdf5f42f41259dd107fdd80b933cf84a7f806dbc1e97b8738dc2bd1472500ca9fa10f8796570061cdca229c9f02bd0f307c30317bca1a236ec28c5c5e60464c6caf56d75b9aa9b253842b9e5a0e0ec2b6614c15fa711e891cf0c8e98dd8b9d171f50bf48a59e2d412031b31d0a531b58dc7290f71a5fdafb2b3489d2d7544e88589abdc10e1aef0da882d3cace7f04086535cb4bfecf9851a81c58d7ae68f2d966830681ce3acc6e1c07a40cfc06eacfb0979a520b402f060ab224f5a01672bdbb7fd2bf0e6520d0b33b9d25ea7079ec60c26330f5d05970e631b2af60c4b1592560ed1e63c1e804c76c57e58468144491b1411faf87a4e9eac8f7ebee00067025c9a1b1b8f0d0b07d0d9221cbdf677965f260e150c467001c2e6691aaf7a12f118e314829755a9f6e9a91b2c532567eb7880d6923f44d9d0105a8b49d0cd0aba0cd2b5b79d73339cf433a14a1f35ba6002759749df594ec4da2a893131519ed81556a071a80f82c067c51c330cb6cc1c694ee01bfe2b2106148636542cba5465dd52bf78b4aed98d5e6742de08ad28e5e842795cc532b485082c5086bd407ab5baca4f1bbf86ee98d0f65ac5a97b93626ecbd82209087e11d0f1a529d1d4e916cfba42a9ed2b601b919ef1055be051f3f9b3cca405ba03d8bab31246ba71f98d746431ab87338182982dbbc3c5d15709e0754f9990c5a932b7eb140c993341aaafa4dd62206465fbf6f12e831fb18eebda277dc823b321f519f46b3e7590ccea2ada2f66c1f78d74a81febe99d536b6ad7f2bc03de761165d10868e97eda4f941cc603345579906cb27dd3f3d910ecb36f5cc36552d055dd29d9d43c7f2bdde27dede8a646e79a0c646b00096df6f425b977d6a93a29cfb4c7b42d41f2234764646c0c541c4f080760f5c3dceac79c5e884c05b5509a16e9348eb72e09d27293010d62a0e9e9336a79f8232fe6971ad88bcf1b30e681fbb507fdb3dd40201db9110ba88a2f98fcc25dcb34dfc829e7658203834b2efee2703b45cd1b0feae937fbad55cedaea637869c29c4c9c67de53f2036f5c22864ae1b01322f3b325e89b4f7b1509a497685cedd2db6bac2e0bb36690d9b71d761297bb348a191e1f9bc4cf8b0a8c3871d0611a9c05d287156e429ecc91e4ba71c9511b5366cc9de4c88ca3227b3066e8d4b6d6f6f933b1c93885a846f8694907ffb17727ad7af0b495c153e0ac0dfb31d377005c667d2e40d4c03df4f0821e04ee1c68fb72d954fd48ed6f0988e646a4cbe098d6b48a6a42090f1c8042e9d313c7000052df91fd18d9851fe8d326158fd6f94c771df65267f3764db3cd6780cede16c65beef12998cabfab34e808d68bd1d3ac0d5b54d572dda99cc0b9cb124d1a1bb00c8626632e50dda41482ae05b7d6d848e30bd69768f2c7632c4a8dc0ca357f9b1dd086e22efd1d13e7a4c47835b3062613c9dd747df4121f322228d441c474bd50fab14498deed1c347adc782acffa75ed0144b4f20cdb25b79ab082455ceb2b3dc0461a3ba40b91677e68f1230ad2ad2760745ae60b43b845092ac993d3b40aa019bf1384eeeff4edf4256c3097ce3032fc6d480f0478d1da9960ba67af4a7d5917d1afc742d0760a5a2a505c8cb4cf8f022e9b35ff5cedc9838381a068e2d25490103417010d3d259a69a3afed566cac8ddda26489e9ff8b05ff0a3cc3494eec2abbdbf97c3a1e31bebe43d6d93b59ebe654278d5a5c96b8b4660621bce157f653c60884edf7487b0754e9a66cde1c052ac222a761e38c8194b29aaed6639be076e42f494f306d7bfdc5e9410baf4836dfe434a05cbfcd9f3fdab3035a082505505def17f454d18313c91c130d78fcc510510e109ad29ecc0dc3bc44d1199ba36729305534c39d45fa09fa225b0bf1dea2a05df9bac92fda27a70c6f4a88672e32230eb97cd8cbed98557c41db32d0713dc61e87ed23e8fa1cf7e7c0a819009bfb739593b85cc848e0d4642243b6f9df4ed7e7c9ce296a58b0e98df2f0d0141d37ec5fea5d57c5b1873e4c70d532c656cbb7ce6a8235ae2bdd2b65526cf29c6ddbb12801f45fe258a813377c6671d24eefada163a9d5832dfb6aefa262ab3794ab543d1d0402cc7851dda18607ddca195dcd648e9e33cfe2be34824153ab767749ef942ec46b5e4ffd1994c896f5dc4ab5cc8eb312f1b2cabdb683ad798588d35d136d4089d56f28b07ea4e125b5edf8d334","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
