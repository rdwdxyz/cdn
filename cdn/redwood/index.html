<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2150726a5b51c68ef379cde89edc7b8fc80a26e18acb2c5bd792feeb0ffc7d3ac2c16f195476814bb5fdef962553c250d725496e13c7153b9cbefffef79a9f7e1517c86fc1b5160efc1062ba5d1e7e113d1eab9b0bad81c34beb01c9393806285e19b65ad0df5d95c26020da7eb6bc12e1b5d5325512f0f73be525a10b5bbead8824c6f83609e7243a1632a0f606892a2b21b39794bd5239fc3762cea7f5ac9a746f19bbee2ada40826c1ce080b770d82e3974741440211ed08defe9140e2caa6defc9161f3b8f688509890c55bdeac69474a1c04f084cb682f1ad4046c4af4554fdcee3c93329b730508decc14bcbb16ef6ec74992f7f84e083ee902ad2028d3b1b3d5b62fcf20d1b1c53969574cdb95f7a0020196d102d0d54bd7056ec83b5ae41f3e57f68be8338d3f5a8a276cd1102962d57fcb8729d7c21fde5254071eadcc84d42a888b7451e2139869ed4f4ce54426e527c21e36bcdc526af45b69f4e93aa130f806a604799fb842eb4bdcab6f4ca47ee28a7ec4a5cbfd38648a92cc72f7a3cf7679a77fd954f819cc23cb546f9d5a48cc70c4b9389c50f8df3b11739e82ddbddad454e7864fe61c3beb81cf638b232108bd9c97759e8315bdb01525c0fc0ff8120e5e9b87896c890f9519b5fe0390a45d641f66abdb4cfdd1081ac116150ef9b44ed6b43f8f38e4f0ed52bcde2a22bd75a167335595195a354ae0540b71b2d7c3a312bba737549b1b5ea154d00c3e7aa8de60429e94b61baeb90f7845e08dd64f18b7f5f056773f27b686064fb4617f086affefd51218403b0a885399a06bcb909e8406cb5b60c649babdb04d1d1d7975491a33ec21720c2716fc24a4e2484da927420a1c8e7ad40c8f627a22ba7019a2e1d30e7f73bb5fc27611e82fc761732494169abb56000888761123088e9512a712bd2fa511938c93ae3cdec31d4b42ebc37faa3365d4238ad7b97da68f80ba18741a78bf5d518c44ede30d468a1b7e5f38cddca6d10182348e48f4d4fe9cfa9d74f2df236cc51a64442b677428dc9ab658cc463af3df2ff07abb2faa00c1493992c359e058d32911309371513ba5ec3c854dd63f08053b7471769b3f3a283436a2f79116d9b385221926cba24251b569ca6d9e68b802a5b3451411ce9140cd54d9ff6ccee035dfc933117e13992a0c31fd17c416f6fc89f22bd8867db60e5305c84e0086b9f7956eee576ef0c62e1276502b71dadb2ce68ce0276e84f85a634d99907c09483b67fff1369eb0b4438d02c1f14c3601be0af4f50f563d45a91cd15bd9686a95ac0e3286c7437fd3a8a57d386779231cd50ec7b89804a7abeae933e3eeefe227ab337f5f8083d192ed8c8dfeef73a7d6e505212821ae83aacf311519a60e9a9580f2eed2bc950fb4c513c1eb01835ae57bcb23f8f28349af6b2a4f72fd6ec3bb439033dc6724d1139f63d3e83d00daf5dd4f8ee14772814b42055ab6083eee5c1613befedad36b96dfb5c02e03c23c01052e335495f5e42bf11dc41fe6ba3139d738e0ba247429c333e0380430ec2d67cb7f92857e724e3179cb85b0d5c99095ac1a5af7f1bf1dc4c3ae90f662945aeeb4d010c70428d0d78871b9c61d37bbc72d5498979937b0edeaeedbd39095c3ed8b3d3c546c2b8e21c6e424ef2b415528d2f02b2f1f3f410f9e4dd267c5e355d925c35db6be2fc5cd44ea9d05c637a4be016e771a2b75f31e4505590126b97b211a136083d62e777908301b286fde270c9a1ed09c3709c1fc4688fec241c2fa1b15368fabf79a4405b11eb25aa737e6b5faa6bff367b0732fd956e387cc2eabab8028ea9a6acf924b787661dc21f1d739fffe2051e115ab2a5d1a12fc3aadb4229dea6630db69d5cc3e0c8e3198fef107c4162ed773ee0f4031aa8954ee3ace226d46d297778632232b80e4b45627694cf1f59d8106922da62173fe5daf9535efc8409dae64d4b89356ac45adcd82a4e3fa430e433825f8a37bde0354b59c8ad281f210cefccede3485084b229e6d919477228b563aa0238d383f63e002265d66d689de3bf32288dca25e2b40695c543d6c3a96fa2607cb8226651efa4331cf2d8688efa312149d3efaa2044c8989b09b4f6a0fd23f9a849d650991fba42e7f5c4292c7a0898f66356cd01484905d399e558209699959337c0b7e086f6d63353c9a4382bb5a7e055e80dcf3308f4231e6826acbc9d1bb91a495c0ab9197488cfd1d29a3b8c0ceb781aa1c93373ff312e3dcd45deecb603dc4ce98d797ba906650d543534b48d15b701964fc48d4b97599877d0e6edde38bfeb98e8ab97e867e9bbf0542da321702d0323e14f02e1d8bb2a098f3e8682fd4be979b4b9f114d6b83be43ade98fac0e8e6f5120b47f8d38df0da08b9ac9a3fe90a4fd53c787e44266ab6633095d470a3367702eb39ea9327903008dc7563dbacde066dfeef52f2e5566933803972febc11645bfdc5dc75f87b2fd81f5d18362b28bfd32797e1efa06e885573d90bb3f1206143204a8b70c9a747955c9932f49b332b9ba5c8f67acff237cf23a877b5f7b4597b7e55169aa2b6b772cf6d04bd9c717b42424863100d9e90bcc9934c4c53804121170629ab60bb272ce7120ba23fb008018502c2a9ecffaf83bd468ab734e6bffea72deec4def4746a319a048e1b64f60d5c293b6f18b25b439fff3fe5bafd88373d0a898c37bfdfc857ac00df95fb135fd3bc67821d19fbe6474ee358ec410abe21c14903ff2f0ff1f9824e615e1de301ece528e2eaf02e5f09f945ca580955905d34cc69f7caa513bf661c05f183e4c186128a9008e124d2cab15d4f7ae3bddfeb3ed02426e50cf389b6f7b7524f2d1b057bb2fb850afbf7e5cc2fcee0d86d4d404f066c6a664c61a9575ec9b99a236154d965ce0fbc5f8492d0d5b5ff789952c5131ee12f02588ad074ca9f49777aad4dc07201635df9fd465ba1e0be5c88232c8de0e3e6c0f32a72916851bc700df7f6fec46abde330d1e180c8edfa06dd1f5316619f9bf6a8db78933ffbb5d733b2a1c9015406072a38ee28854e2d2a0a9c5aa78ab4e419dc9f242ca87a96e03f7ca0c6ea057b46f0202bc7eb4e66c5be196b464e8e3ee3a7b51b02b0d04d68e933739f2874788cfdd5d2f7a4a99c665b17b2bddbcdf9c6ae37d6d81fb95f68db7ec8fdbe046a6c71b15dfbda0cdd95d65e9376146b9b66726eae7b70a64756783055e95ef49a7df4d698e7e3e1fb07b35acfb1113997658b8304dff65059b5cabc92b17ed56c048b6bea86e1d247bedd9e8597179acd02145145276edb676777c09a365842b01bfe0364e8dd49f6c0adc1e13cd6703aec5590458b47b012c7d3157595d3cef94f54464cea696d786352f3ab83a2b73d0bd2ba2230b46d4becff29452d023c32d206fabeb6ce6d89f61ccab9d1736ba2a5063350e31cf0f8b3587521cd6e312d3180edf29a712a04b2bea263ad512bd96bab6624bda268c8c4aec5e00fcf5de4f97267a0b40cb0fb7ea70120db39b1858ebcb26d761fecef2b9bc9bb3a912363ad197131e081c80a05eddc814df5ffade6137d7b1c4a4d0a3b7a29389b27c7082ffacdef099751219c20d0d52df1f89ece2781c32aa311d639cf1754986d198eea3950713358fab9acf1143f2ba070dbe3a9936f4e5d9e032ef5f800a0d86a2bb90649c72de855f3fc94ed5f8b30452fd54d3fdcd9411a64c9ca8c84ba4dcea50ce84f4cedc4b407909262b88f8adcdab74789176e810a1639c806055dd45d481c9cd5d259412557e02cb9843e3fbdc216767f1dd47cc6c4fb76f65f66ac999c87d0cb3c6063ce26376a8fd21f1b8609657510187176f2680b8398b6025f58acf971b1f9227ffbc1ff6ff8186299938c893a87bc7b46a26a5ebcd744a25c587495c969346f864aea63d5af0369d795cdb292c4504b90d35f4a2bfb23e245b9ad20a5a7614812d3f4bbcb3d0975a82822106a3b63eb9ab682da3c9c0f20feee099bf42ad777d1aba3f94456a3a47cff5701d2ff978735051a68ae8b185e9c25dbb8e9fb68c24b1b91e0275f18e9deff67e1e410ef5a14fbb0f1fce7bedb074c11692e96f315860c9b12279e26be5b4da7a799a95d92eb2cdb631cde43945449ceb54fc11668d7b14e9006697b3f1ff1fe8e2cecd75a82c8c2bb4b911e21b744a597a6a0352747861599b4f66d678c431fad234602d8aea24ac1e00bf2bf0c21341df6f1e23f786e9388d2b1009c4af86cb95afb05808b1734fb0d179dca6d207f5a6bf5ad6d6f07f27ab589751de3661735c115a8881dbfbc0f2d38721feec151ea431dd58d467bed778151d6b1966e0d5e818e08cb1c5ff70c46ef0ab5390f41ca9b72db266ba0dbac8ee1b6c38bc65d7da2f7438df234eabb57d18c923dcc2cf928b07cb6c3c76335604f3080020ea0d69595c8941478fa269a4494b6d1e47ccad299352923d36fa2197a12e9841d8c82775feb312ae47647e19a53a754f720fa4f0660f16421e0a6876f59862e66bc9885b2c890c1cde17a084f1ec1ce5d90c33106c62bc209c3a8a0c64cb0911dfdcad65a246147e7c26aba631d40ffa8cd1c5fd6b04102f1d6186c859dfd2b8967e6f630a17408e1e7a283cf8b6e6777660e63b5712dc893e3e7fc90cd772267ef71c7d81f128f1aa78e4a708886382aa484dc52331e3608fd8e051d151059ceecc8da5a326f283d6608a3cffa78a9096c995ec0a98237af1396c15cd3c63af3bfbeb8c1a7c15397453d4be821471b38610cb13f4b6c2d67facbba5965a674c3402181260a410400bce73192ad4770c8341922cc2542e9338882b18d39be66b2bd40ad4e1d212da740c45268b17e528cf8f4f04750f8dfdb2c4ebb3cb1acd4110fe18e53e4cc0bcd6693cfdd7a934bf0bc2c977589666a58e5074468ab4f865a5bfe3f618a607619cff94bf59dcbf060bfadb848ff092ea447d66a32c1ecce07de99b3787c588e5c0bbf0cd80a8db8fd04311750e38db1d4a85a8e7f85387565261e7e953e6632941e0f7a1cc902016cdefe862dd329bc7e4f45ecabda041455188e62f15816c2f156ae838ad851c2c3d7ef59a57dcb0d0a53ee4a5d0b68650db6e7e6a2a4b7cdc672ade0e5961c8335e5d0e004fda528dee76ad6f5fa333d52551feea97996fb8cdbc4f3574aaac865896c75ac7b6e2c55955750aac07d820d466b0b869a4aece284493afd57723d3378bbe3699035e17fd3ef9a757ff95de5c71d3ae46dcdebc50d8077f3b3ff0e580c5f0a4516fb07dfac38956e0f40bf96ff56bb3b21a5292a687f1e1d780ab6cff77c9642b043199e8d59a93e79b381abd23e786b2a03b792513126de029ae07d0b9ed45a8ad5d6c187ba7f34538f53819542ccfa3b2ef06cfcb875d38356f126cbeedd6d366f8034d55ba082318e55c22602145cb6231d6fcc3c13f7189a4240824cec691d7f93b39c185bd03fc8f309741e95ddcd6b7664a350f9e49bf6f7e207335450b34c583ff396f401adbe1ebe40669b7696ef2443aadd570dcf22e07e12b4fe12a48b8680ffac3c242b670fb1911e02140730d97183abc40567faec9084b6a134915e903bcd6a16bfd3352f810cf916d59dc8f1e10f8f7f156397ee42b6fe30eef08415e968fc0731f8f9ee60512096bf1121657ef2f3eb351af649a56ce61d411a589725b94edce2181250e5047493632a1bf535ffb0f35794fa1579472be50ee014ca059c0a2540ca6e44234bff4e96b634e3b81cfcf2c45237635042d02775d68a9139fac99ad6c0bfc2d4cfe1b32277f96a96f9de4fb2bcc8aff654beef5d494afbbaa0e9195cf347d82a2b1d05316a84a294985be6da1841182c4c6371206293fa8d6268dd32f8cfe44cfbf44cceed163aeebf28bc508b712b12bac8b50aa09ffd133997e800708a61cafc115515371d08518a669ae27d9b3a0d0c32cdb68ae90de605ac29a534307e9819848353580d38454d6c0d69be7af6218cdfe90cc2be1c5e35c96184bdf9f97651d946ac09c5f7e51e0611da66fdee594330a29b4432cc12a49fe4b48c008beada7d2836048327c9d0b3690abe0fbfd932398dfa02985289df58b4d5d9a8d182907d51d568b7ad59e2c9193b22c8f87e188a4cc50a934e3d7eec9adfd34bc0ad8444467ef15a2ce9b2e4f7502e81e3f3d64e46648c98b0b9cb9f883d27aafb2b659434b33f6fd58f1702dfd77d6d34fe66e0f4848e7907af175ad9ddcff0bad27e53271436124086ba0ff1a33cf6b4f037e1f06f08935ffce8fc2bc2ba3f8a4b62cc4e9337fb62cc142fbee212bc855c7e57f011095f517958f9780a95dd88c93221bee0fde7986c98307d9313689064c957c67a6aed35bb59e7b451491ed53d3559c12c45bd00e8f924e15b3c7cb3fd6dec98040dbadae36495a3655c2a8c54805caa386bea5c71e042a9649081c2f91f56ad8860a4a215c19e0948352ec4ef8c45bd12e5fd09b19d370ce20dbd18529c50702a5f02a7aa9f2588adfba37791aa450c03165c2c6972038ab07ae9d3084e0ed5a62792b406d71fad53965ea9c3c988473a304b875417cd494562e1117cc2c8df05ef76963ec5fa00953c9fdb1a81bbc6aba89c16d14fc8446ad6ab26908a9e1f08be4d805e12748f30ba3e28d3f7e0333619975226f5e5acf6d5d2a8cf3fcc98759b1cf282a21d44ef3c6300a58eb0d7d33e3940f7f6dc9cac829152494b47389b14cbda39091596dbcd1df4a7e6022e5b04c74b6a1154a250330fbd5261e704072573a00ecde0d5e57020e9891f6995279e644a409bef614dc280ab8d06eb5a1a382ae4329667ad4bcb1636888057369016efce908b8c1c06544f40a42b1e35aa1c218e9be6ee305eb8dd4a7b883b434df17ba4ec774c4d792b1223aced3becf3b6af2189bc0c984ebdac2a458da77945a187d5fc71d8e397f104a018afe579725391c2e6be9b3960ba905e324e89b342e711f44cdcded8c608e1bc68b5efe877259f1f00802f775711eb43ce663d336e46089a473731c383d6fc356e0ee95f4c6dbc082a32c18c93c78e48c092105867f6f4e29467955bb0e3d7ed03ae9d2bb021c35eb3fd1bc03cb159eb0f93ed2651ac602210a76b68f831fe1a794ae8770f3b7c3e813ea869f62178037706c4de47735b571854d2226ea3f86748a7ce24301295b5157eed096043554496dfcf60174da01082b992fed00ec60aa5da1981ceeabd92554645c4bc21d3de659c61c58daabd7bfe88aa7487bcac8e7a462ca8c86c553c965968e330b6a0932ff0abf4f74064b2b30e0133e864cf460cc46ae1163c2a70800dbbe2803aac8a302e8eb7a00dd25e35836e88fec7d55b27a8e4f3257fbbecfa3f96f3b2711f9b3451b94fc4a2bcbd7208413b34b2ff5f1756e52aaba98a84fa04f0dbc77390677df6f3b103cfd860cfc476ad8b60add97d7117016ee884c1182104cb825c7187ac4ee49a1cccc9168526309ffd9ec9771666d54908dbc85cf75ddb1448d0f0c8efe5560c025140568710c5ca00d06f768b1377b55c3486c8e9ea507d83798825b8bbb503db49bad1d7d1751ac0a1fe3db2a7bca01521785ecea4945c60d4f4940bd94e94d3fc9669f5c1a70d8f0d148c0f38e60dfb4bcbf74a6fb5a9d254ff4906658d1d801fe6d914a9ce84d0a74c417bac53aedfe18da1b62e0816ddb96d61e5a79bf2a7c5d49f9ff7aa262e160638b2e47c33e836090563cbc3786cac2bdb43af671a11f2ace3fc96172cf35e70c436402d0e05a5d2f7372d5b7b66167ab47d10bcdec0b705100dd91a9082bdf279b3d942d7ad8ee4bb0ba050dd8e29e7f4ca865d6b95acc5c67e1901725a4757f74adc5afa186a1c4ab392c432d8419d0ae259c31099d9487d4b6c2170b8066bb7996c188cdfc33d73a067c8e8d8d6ace639a41c6251dc2fbee717b8ff12b9dc7b839e9ca6c2ec1b8320f1893bf77a2f13f8311f68b8866b72836329395f5842205f67d4a8098fd763b490b2e675f4ff8b7a1ebd0a08f600108971b896389f5a7f27cddc9e0197fe7aa4fdf98c3d8b652a4af272bd283e77336efec4e098ab49c7268e0ae879fdc733849f8b6ff31d9f7d391f66432de237652648304271989c7001d2678668904770b3b4392f2d80dc6671146b1b58124bf892f05fac8002fac34399f7ee8e4e0d532041ec402bf6c366b9e51274f637c2aa63e73229e3459ee82c4567368a5a47209364c44c34ca3ea1b457b9317d9faa86c44b53147132bff2c43c6553345acd3372b795d21ce12418426e99293168d9284565df45e2369d3150cd550649b4ee16c3479f3c76be077522d027a380bd588a914cf318439b160483d867b432df31f22c00f3719a26064a4e10a34e906bdd9d8c0a12e20246f53260f05aefc83692ce61351e5db357668793db6e2fd79f9e4dfcbf1a5ca872157ed5d12b53eef5ebc5d192eed9a4f83fc1126d284c245de89e0bb3e4d93cc62f3cc91f24b27e9eeab66331c41a4bcb8ea0a58c2aea691cc8703f4125bf125fd1f054a3743f9819acf64fc8d5cfd6f46b081d51ec29ba39b61ea26f7f970353b12765ed9806403d37f046d17423efb3b41ce0d5aca02a039a14db1c5e36f1d0e7e66f5bf5522866406360da0be740197d78e2ccb21cb56232240d7d19b2c8825b3ade3e0e5f5739627692d846b1392afbe2df9c093ad8734163f17f7050832cbb72e693dc88e70fe97a1f42292aca34ba0417d92a280e2aa2524ca4b9f917e2f907a558e4018de308a5849ce1afe3dd14d9dccd0b94bced91570de1f041a7ad496d3b0a58046df664815a6994c56adde3f68417b30ab1c38a75f7f5af116b5fce03f5431f819a090c4dff66cab06e69a97c3b6da38d5cbf8f1ae94c213c80e1996a6bdd2bd08f1faa3d489f06547127f39685d44cb8d5a7779b1bc14421930b3c77e6febb4a114f324002a9bd1b62b9014da16fc485643f889ff23766ea90e21a51da94e51536761bc2838cc92d2695fc527356e9c8a0f505a2c3f1e6d27ad1869ebca06666fea550caf96a39ae4b545cf1ace0ceb9810b394756c734d9541de8f5f86b03d6a7871cdd7cb498386f50989852e3aed3e494ef6e0eb15a5178125c0a14e2c77b61509bd75091ac112c759a5acfc0736de88d1d330fb8fc9f2813cc117e89ac9bee0e224eabfce171b404370e7d164a9447353f09eada1943e088dda751fa3873f12e7a1669c0430fc68dc709115e125f38f962b7c21603c464459422fa0c1fe9f97a3313945828fe7aa3825bf991dbc7e48269ab6b7102a006c72e9e8c8082f0361174a6771dcfb26abc132d74f94a67d18c9418fe3e4f90f80f7a509d48ac144c5ed45cb9f11dfccc2b77317b6257efbe8df2e728eb52f350fb53780e2333efd4588ad3fbc4a5f1f7d1d88d90d29d82fc4214ecfa18630f805ff92a3f6db40d3af55a65b6313eedc6988e3c23f01902169bb1efd17213af27383faa5381d82f3cd513fea28de5cfa51accc9a96fbb253d66df19f5044a5731088c70645c97f4c5c847e728810e75296d87694cf01029de748a25456ff5c9f4090e466b7533048e96d2007cf637a39827b8495b3e2ef770a0f3754d3623005f752945d115ea338b67ef3c33a1794cee20cfaf467078b2ab8e02b4638f52554762e6876d9b8100f47504a73f2dce544fbbb8c478b7478487922b07dac695dea0b7d0e5fb1686c6b66e98bf0552feb62d51139f2f229561de96b77071686d8765638e4468afb1d65ffe351a7d45369b9338e6e143579d767447f0a2145ac15e011f7d2855c18d912acb382fbc69de850dfae7032b45db63fc640522bd7a11755d4f1146eb9713043a6f29910b3dd29bc9990d48502bc0d0c7fbbdd872fe670fbff68b904f9ec4659b93f96850accdca1785c60490d86f292b45fc87935043dc083e4f95ce78ef0371e7650b2eb625486b6a865887d2060d91019f02c1b554227fa962b1a27ed05057a855740ceebd657798de682d1af2a0d97972736a44e73ac2ab02a294fc172369f9b68084c7504e3644cf3935f8f165ad056aeaf336a64f2e352c854e8597fb666a6b998a0fcee46713f78515c57bae95f24630a4e5ab59991744d7dfdcc8ac9313bcf4f5c79488148d9760479ec6be91380bd433d73ca3a398e9652c9c955ff6f60291d9b25cd09b414a743d2162590fdb438f677b6803883cb8881a5c61f28003ae113da372078e1d326a3507d2c09481cc7c522298fd76311badd3021d9130a2a1e9340eb415cf383a75fe107cd89b4714dd027d7b7cc8edff0ee125495a9c39fbc54f5f0db2f8e4abcfaa50b6fc5e702ece7edad9c50c7de1c4f7f4dd76abd66633f77655e86697444958dcf04a54f1375cdc927bd11d935b2e8bd8ae202c33e4f12dbe07d7198e7c97074f3d4598e702d25e2692c831e47e8fcfacb37df735970b8bc588d2c36589192c078d492021ecb386473b9b29a10a5183d16967aef5ff18c38ee3814b847ba285ba922ff1097ac32a7dbed56bb9514eb96178ea6770d4251bf7b5988e0e9cff8a29a9d72e38a2a1eac2437855b35cf441e342d6b60d905f95693a062a6b14076ef13356d34a8a4c493422ed08e3bdfcb7f052025b8c2a012846622e5902424df49299e9e4d9ef22d79a00cfe682f055b8c411ecb6e7d447b862592fb73216f206ce95228b9282e40c2db093d1bdefc7ab30a5d83f48630a7720bde6f49c4c47060d99993284ea1adef3b7b3047f6ede7d32146ab603b7c5b760698f7dd75fd1a60327d35084129997fb2dafc66fd8b27bbdf83d051a87ea12e6d68b7128f6f4fe09fcf6d71730e6def408872da4ea87a6018b861737f6b5252d6161ff77509556437dc238e265334251ef3e58e017880f2886f96b02d6be1247cd480f56b78aa6be5af7b9a1d60bcbe22f4a443fa018a0282be0e4884fb0205241170bb3e37d12bc4e12d2e942b1f58e1d95585142f49b2a0ef50dea0a52db3f5960ed3163fd71e88d7d1457151253d7cd3744f93ebed98204bb6042316e813b78775f5fd3d0544e38e013ba2472538e20403c2dc13fc858e255f910a03f2bb3230d1d83532a27f3459ec26fe5b79e231f5a352d3cad981a19b17ff6fb1c066014753488ebe57138bbd55c9dead73fd3b1b8380b8a4a8876dfe65f9b82b0a09ac5db404e78ef66193892a63599c18ca10e5d3d31bc5e79d2bfa34187648ade6f711e7ac2d212d94a010bd3f17a4636fee5afce2dec93fa883915e47777da9ebf562e1fbae4c0183e1e85eee40ad66ce47868143fe114e36c33ca1e0e984ae4b2f9611a473dba418db7cdc22c214ca6b4e369c26f4798006cf2b218d8f842d973610113123c9be81a11862e71bc6b671c547fbf9d310ea55f7954b8ca42efbfa48670022d0c1c9b5128c770acb599f2ef8b8d44e0bf66e1f232c6f03a3089e1b3b5cfbf94b294b463d6d84619732bd02f9dc8bc789bd60e917d0e9502c7bc5e9e7996547fac2c662a118217b21aef6b38524a8b9b68aa1db29ae4d32eb1f171534404914b2e251c876d701c1536d9dfff34a8f0d05ddff552cba1aae4cc89286b15b55d789de94d4e3a29fd687724351cdb17eb27e414a38708bb96c8e0d633598d6efd2f817938d25c2e2b33ef9acaa71d450baa418ef774df048b3d199a80bb2b4287b2d254e6a7018316292204f2ceb4a32cdd424eaf6c76a674adbd8ae66719ef27f259d7b3b3fa4b5279eb1ab9d20916b367a31735297a9987433d2afb641b1b63cf9587746bd79515d4284fd0a555ed8436ca49d41fb0ec040e451810f8eea4fb2c25e390dc77dbd70f2016bc087840158ac9a2821b22aab7218ce47b83566af31361c182219588493535e45a9401d87b0466ddb24ff025390216d7fb88ee2a8bc959d38b020e708b5709cccb79f705e5165b7db5bd04aff3751983c0bacf978d17d368e4626eb24a50a3e4ea0b25e6bb38bb9bbaac9251dc550498b2c5619a7582170143420f0587e0268e809ab47958b6409758ca2b490c1130b5d109cbc6791d3f64ab4b89b65b359d8b4cc49bb35c345141a8aae564ecd4a8615e908df8fd8784f6907a5c29b977f217e1f2b298d3859bb81d0a8625bb57a2e89c11340648e639a4a0bdd2211714e6e6db4cb2a32715dc07759a1b2faf183b6eeb7e076962d5f909fa67494cc5d0f1832ada23cb9da5b496cdc0bb26009606ad2984f8dd3a2bd86fbaf12181378d3671c65d9ea85eeb8cc7a3e7e6650e62561153ba520507bbf4328e0626022fbe94af3eec43d34e97292c7c5b975e54904bade58bde70a86e4b5e96e316f8fcd184370b76bad48091b70121f698e049eecd10eb829a37d0003a9760679a9c910f5565820b8d7ce7ffe26148b2691e465f19efbd054393224f96bdf796c93129976c5e8713b23365272123f4fdaba535720f8d50e5956ba4ba110980ad2b3b8a734708a3452110f72b73cb1dc1f3d542e1194dc05622eec109f9d3aae9f7ce2e5bad3f6d706c3d53ee9063b0fe3c4ee9ef87b39301e6e603c3cacadb5f53989ccf46251c89990e7efb4e4722229e27522019b6d26ef5df37b6de46f06f6c7e69f0c65cd637fd58697d3da8dcb578dbcc2dd18463c114c9ece23ed003f2c490e88eb5dbd0b39f4eefd9a99e3cb7feab3ffcf80051432b0c560c9aa6de0280c436a46a8fe195e77193ff549ff86adfbfb513f1e0ceaf192cd35443fc2e6a890f6ae55bc48ca5383c34276c6f42fc0d9f5341f654e7a954556a89431d5a73dea5e24a4e2023a8f1720fd2bba2ada2d2405a227c54f91fa949f954453f6d72b57b7ad516d44c6533862c44c4b5c7d89c7116647504b044b49956abfab29990e9153af15679277d46c69180b2f546f446ae5ce6560f9c26ee2218115201515c8f2258b9acabb05cc0cba138301afbd50c0b931a2a5e44302f1293e5ddf08cb8374dccbf08ef04f356ea32915d6b290c8df594acf10a069b000928cb13a6548c196ebdaa72b5dc07615576ccb750badd26cde90685c1323caea393a252749afdd9f8070359c15e6cd12569958a92e9c9b95b2606e1553f659c3702bc02e11e136a794bc560f053f4949db784f03c811e70198f40170358e28ffe729e712d36fba4c3161eecadbda429ae87f61809d0ef3cbf69765ca584f2fa2023ca968c2261e41c4d07f7414186a5f9321b0d2eac4d9426dc958c907d36f117ab1c544c0968cc366c2f56d3a63198b68de30c6e388d40b3b8dce33f53fdb1c2cd1b93d1a865633eae67f3bab638d52d59ab647b067886c3a8348415c5bfc7893c0d254881152ae59f24abb1b92f493c84821752c5e475b187a85e4f62e99cf10257f1ea7a4451bbb9e11e7f69152e6149728e2f2089ae4f1d9943c1e20e6b212bc7621f230aeb493b8b2ffb155b2989d3bb065586b2c71e7ffc676d3dd2a96da67d3ad1c98b031f52aa06be4d9d95cd5a9825d486003ffaca25ca58f65034fcf67aa24e685757c9dfb99054277c889d944b658c6a614327c8317751034af8c42bbf32b3d393e44845d567ec3c67f17b0f6ea09de5770257186be02e01f2d9d870db10ffe0401290e6c5979dc093e5ca679a99c815e3f731191318b6fb16f6a96284bbc357796667ce1862687ec09bacfa593b0389613c8d51a03a515ce80619e71376e51b4e63696a22401fd0ebeb5d31db576aafe2198345a7531cc98eb4771de2d18070dad26b4b2b5c024aec2483ed38bd9d8e5981db1dd8f2ff1d42522e60a2ca82545ad01439db669d9a42f681b13940e86e6ed9b5cd65474ef702b5b77864c0518eaa1514e1c36132df106d6dc6e62418ffb78ceca78a5b16867644fbb3df554dc36df11da2912678ed7f810354e9c73f34be98ed3e08f6374c2d3444207f871d344a56bc5915d676e94f3000de5179c83c38e35ad26e45a3d335c7ef16207ad81711e5074fb6dc31cfb25f7ef3654a5b476969b8cca98d7eea305247c64739fc58066e71923413094bd21447a95b3f08c80a3b5e5203572e4bc2967cebb14d049fb3107da005b212d5aa3a0e9a9dd27e256bc1e5caece712df6d13478071445cc7b9fe289eedd3329d1148a8580863b164c465e4077d976131c4c3df26f41fc3f0e82a124a1dc703636116df4abed915ce556e5c90d5a3549231f74b42a17769b74cdb4f2a0edd5c1fdebee76c46e9f1d678b933fba0e894b454414ac501a97ab1105acb6e66ee44a371271d2304d038be64c0c873e29c1690c9265ad8d3d8c2a6e1674c9f51c137b8e62d9d311e6a3ce0022cf2da358407b7cff8feb66654e33fbdc88f7bc23e16bf2a681031b86ff7f587c1a2bf1ea10d12590519915981edf580ca6069db3ed36b494698b95a5299a35319844285fe6fd6b9f713a773ee51bb24deb1d1f3aa17a4cc92542155198289a815bfd83e0ca4463f34254dbdd81eb17df102f84cd373b12ffee1ef8dec4d9fc171a80e6c65dfc9c33b3e47e6b22adbf8d07b37c8d23fb390ca4576afb1cf5ca715a5932a10c597a9e0f5c9b91445dcd5f2026e64a5aafb8f2ae3eb9fb7268a7b5242c6eab4d2e2ffac221ba62a2b29376a143533c99cf42d67172b83290d6b63849a756a0a1ecbfdbe6c9308d749715df5ed1d9926ce19b01d2a9419f493ebe0806e5be1ddf42b776188cc5b7001a42ddec2e9c4f30caca9b9875cd18d09cf2f4adad474dc0d99176ee7005134c6a4105c306752a2228d06ee670c407d986577bc9f9dbeb081179a1f23b09300781778f1ea9ccae5875e93a143288eaa626f4d957e198decda975461898284e0d2fb5bc920d47f8ec47ce55ed028d276d45311ae98f0387c1bd4029ce4f7ca273f7920799cb55989af3a54afb59051f30fbf0ed0d97fa70c73cceda7b9096a039a9af554cdcd46a2d4be54697288c73da4759a19a3c1f378647b375f6d07b2092bb6c7039fe16f8b73e7bdb185de22f66639e2926a9e0f6ce6b13e4a942cac11a53f0b189408a0c586f382c8fd63968ffe74b5b6743d25ec7b871cd778f101592c478acf87b8306d04b6ac575c21f41b4185e1f8f3046961e8b07db7628edc22ee8b2581d1f53e271608dc1b93190eb054a6fbcb614748ffbaeca0699d73d630521f5c6e878001d4e1d9acbe14a908253db8d4ef5ec112606b7c222b2134ba1e1f6fe1f029e6e68629eb7f4ad5491816d7a4899241f8a40daa49539c87491d1ff979589655aa9edf188c6b1487d7dd298ebc5b8b63e05730e8357f405b3a3e44bdf1550584b0f357bcc4356915337b6162c821e93abb9d2f6c99530355a03ed772d68a3ec9167dcce8926206cfa53d704034f348ff8a7f82da654671d2454236f232dba3b9c462c5c59249bbbc75b8132ebb13cbd99045afc034e2a382077159b939c23c801351aab78bc8c16e2689c2a85163fce003fc70f89c8e20295ce836a7d05a93fcb03fa67d2c8506328e39fc46c07c63950eded51179def11d0f97ace49628ab43cabd938ab7a69cd748b67a9fde31de3aaeb100f26a59c4dc15b4155b35a68212d77b81146a8d4a6cf31ec56ad44e255db61b436c41c2ff9cc271ea522bc1caa762969835162e44146138abe79004c40f38450a54b3e9bb7cfe79634576d2b12ea58a61c885bfa1262515d2ef229d6f278a1110336418918bfae34099379948af4ee5a7e8eb7bc36870b701a6f14bb0a038ac4cd2ca4062c588d0998353b9470ec3fc88eab76f154ccfeb2bbd7437730dbbc22f13f1a3741b31c4b6682f2eb0fcde800352871b8385c0c85afd8b9cc3ffe7bf12aa262b4dba16c9c10373c6bcaae9e9d63433ef71a438c2c66803d20af33d0f12d2fe8a6340c753524f44e3d2f3ada078847d741b6783fc6bc9757f11589c8daec2df99193652046cd3a8a2cc9c858499b2f408b6a84320ed5cca6f1a9a89ea3f44a2e2c9bd0888a24124d402a6122d145e5a05c4036f8da25f9e6852b8fe6b86c154b6abd3c8e88b70b8ec1692a5fcc8ad95051dd40089cabf6daf27eb760e20ac6a07923680594c0b176ff4ef387edb07cbf37e7c48449b9945bb0a94ed85b01039eac6e696d11ce0b8f4cb7b9971021b650be862998f1ea13c91082cf11ca31e1dffdc98b681855f7338a978d4ddf501d0920b7011906d9cd7d14366390d338f5f1d4926615a12a2ca0753d8b085d70ab250b88316fe42f69457413e14ee1a053d8240458f2b416635a481009f693c28dcd70164b4502bafab023c81099478ecb2097fc182eda5fb8f5a87e0ceb096e824ba8b25678022a9ce46b0ccdf9f27673c61b8fb1559240be2b7a72d035a82729da165f9b5d1e4038946f4cdd96ee7ddbdbb6af19b4a8dc1ac01b63057ca006096765e66e8f63dd3dba7a075c48a395399198366f25f2b41cd3574f58878324b0d85637415814a4f10f3a801a0b4109e56b834039d7313b91c7ec93a8308b4fd1a6a10df94f951b1a6c363c90fbdafdc486e7e9ee5c34d92636a488503245c410c1452c11605c41317e21bd0eb0259b18a7eb822ff0f543f4fc15b6bffef34264a9400e9e87f0dcbac5453f7c1a5ae07c91b24ba6bdabd31c8c2b1cdf0dfdd4c7a03b54e4e757744e56b49c80b40d67348122fe97eb978c984fad7920a491a920b88273856592d94dd4d37dcbffafb9fb8e8b161ff9d8cd5c3029c2dd61635d849ee261e1ac3dd97d017b1a89f43e2b65d2bb35860ed41526d7fc371989eb9e94556e8907294d2cd6c558dcea68e9584277fc7d5c94a33c026356b782afc8606d6605bc053f41151e3b91ab51782d57d422e0da7c7b653b0131fcc5242fc84d2087926d6f867b6093a72ef35b68cc716ddeb070fe84dfaabba81b9a0615e7c6320e87722ada3ad6e37f03ac3bcf34d5c3d6d9a3392764f64375f61e4e0e794a5b3353e38f5ca7a0b8f116c3d2d985b7aa33350798ebc82905857bee05cf1eacb03e1826a31715e5146c69df43dd3a268b68ef39a47c5708eb4efc4de822e54f4c2a0e662d89eeb1da66b845c2497bb58af311c5f1f3a59bad13359765e44ee476675f3ebbe1a8c6b60eab27e45f48cda0c8eda9af91cd17ae8694c7701d6dd7af9351022023a2b2d9d3126b2fe1544e95a7778ce5726c271f062e00ee8c615b16d77b9a6db145625ec3f6a505fb17e1ae5ba14734b664a5d8a4aa52a5e6968014f2e255a3a3d4082ff853987deca167c91c9d8469d2af4b5304d54e5c71d649da2adfaa7f59fb965855625bfc23c09ca161d4aff7240872e13527e0c184df390de2688f89f10e16b8b8708e8d96c8c8af16632b680b0d11c53d2a02e0df6d97f6b96b11ed70cb94e737b0cef9d094edde49c9a83699420c318ca20e79895585a0a041c591207a8187d06e08c21d2fb024f89974046494919403613846a243826b10560c7abdc87e97ba6c64b6e579e96d09226fa2122cfc107fce0568661244fdc64975b01ac31a779f7e57278326e69ca1b80c86d177f5d93444c693cac0b47fb5ba61e6a15ff6a2c121e1e6f58e64385838fd75afe2aabdca7fbfc0a74830588bb8c49af787e326a7d1f61d95cd92e28d088718fab74647e80c6777d0dfd64036a17a85139c15704ce1dd27e5783f71e39c58e26a8ebe54d44665ee46701f279fdf13cb3400b1b14c52fde5dd852908908b681def80c42188b3ab4ec26e4d54a9dc3f7a6d41d1ecd1ffd70b7e4dc7b24e9b67c7b28903d7ca9bd5b43e9a855fdb600c19fd2620c3399451bd3e7ec268de8818526cf0e807a5407101aae0f5fc728f78083bf43b8c2e3f986d4a8e73f7617f86bae31b0731555ce3919f4869466bd9c45c08bbb5e18c027757d742560c831e89ae1c892af03788a5ea7528acd75cfa0bcff221ce38b32f3009eef6520f0699292cfa5a78b28891cdde14cb41fc399aeed31ce38bcc7179d41da1cdee63ba25a39c8d2468e9bdf6b855d5adcd455e24eb78950feb81f7a46bf433d4e4ca03f3c9caf161a5ecb61300efbf42f28fdd63058ea7586556c6d773cf4dace0e6f3a4cab8e097819b67691cd5814130bcd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
