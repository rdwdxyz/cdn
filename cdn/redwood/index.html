<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"177787e8c9e34cec33163e7a08940cccf2fb0c1cd3c6344daad5dabe22990a610841b9066a9086922acfc9b9f47b348b4076cc46025813bff4081829ac18aaa68e90227b40f4349ebaf0c90abbd6e8e3e5e5ca9e91105d466694ba4d520fe5ff0dd7987b82460801b71553267244c0470a3a2574a8778ebfc0895e517907b92c3b321a5271be8766173492035f0427f7c542b42b05d0c0d1ec773be76794d49fa2dfc2097a7ab3a6b75470162174c4f4eabb3012b37f3976dfe8205699660ffdf29b0837dcfe3744b6e31f65fd325b0815432092c52fb36b22a9718071baf7772218fd5b6a02392f15080897c862bc35b5a0e3cc80d93b986af71092586e90b40ab149984b7706107700e83efdab760fdc989b99e13becd21cef0db7ecf41e59bd148ae99e9286265f9f85aa35cbecb4ce2af18dfeedacacabe1e454ed8fd6f188ddf0f5b089465f0f86930344bf6af50ec245a32e597ed536972daedfa8d8657c5af5811f85b77ed799f957583fc35bc513fe9e79bc0494a5b4f7b4f5f7ec6c49014b902519dc759fd1eb7e7f016e145a1c3e4d00fa940d24277c4ac111c654bb033cd756e77da6219da4728bb7f56ec40545067251f297cf58b2d71f012849d8edad6b228f2242b2dbc0ff338636ee874112659aea3fcd2bca39615fa6765381da7485b52f7c061327006259559512b1528fc06b5bd7958ef18752986afad492aefdd27d58668f9f974d353cb78b3a7c9046ac4c3ceafe19c11d7d886ab5161681d5b895f00183d23d84000739fb5ee50d1796cf27597a1afed6a9873f96fc75a82a71e93b40668b89a8f5010d6021d0eb106868fbeba94059036513f1cb55f7aadedef03b74513da2986104d99647eaee59b813f08e156d21ddcffdb361e4f4efc7053dfa405786d20eeca1d3aae7f1aed567488cbb9bfaa7f12d4edcfa80d3392d1238edd919d92937b4c705df773099e5ee7ce5d2aa40e0dece31df7ead748d7ecadbd1a005961a8e3ae8f4bcfd40762884b632c0b7ca9c0091c66a11b57980e382c817e14c8798e23fae920d99350cdd42b67dd36d4926b33ad0d779c4db22f319479a663797b9ff99ef7a49440e76e4eec2d84c78153b622511024866cebd96c70a45879fa73f4078aca4b2bad7217ae154cf81a437204b2a6464803b7c6a271e3988d82df8db76e1aeb7a4a7c863c68f716fc0bfcb32963c6ea56ac76771e986d9d2f8dd3e6da0b278281bf5c939e7c78b3ec371793396fd6420c1b9cbb5dafd929c96b2ea609c378e5376d6f25fb4b873a07eb85e697f7e3b4b9ed3f886e0904ba515fbadb7d6e99093838365356973e310f632dd7bf0ededba24acac9d04d1356889317d6b648eee61434c6f9b962fe76d48f7657eec155733b6911ca3d921422a8561f45ae87d404c99fd90993dd04b52419d0c7e6d33ccc2ab7a0bfc2f88e730f50019a3f9664f324e4ef6e76d9dde78f650e180064c6886fc49aff1a0bcbab1e66e09b29b9e900c2d035963b990c475e9e2498f062e6b6a76a4f81ccbb2c699cf16c5ef5e740b3df79dc5ba25f5363fb11b488e1aeefd05b4d78a180c1fd9e653d3abb82fdfcf7c4fcdaac90b2cdfef59740377b18f729a6b9a7291045ce103022a9b2c03b5995f392544f403f034742e17de91de1817f603f47ab4108ec484bf06af8375279d7d173b6b66733cbaf38051537a2d6180a0357bd8e361729753f715c143f2bbb8ea075837dfebc3689607be37a1bf705f520386a3bf08c751079fbe8e6abfaaac84eaf6c51898f39478909d9e63766b74da9235e10c91de5371320b3344710b8e82ec18194e1953280a1160425d499f67b7609320b8230d681a33a828ba401c78ea6d46b5dbccaf6c6081813c7d9c0ee922bfa92c8fcc246c068e1ccaf16662065fdd349db1cc6a1389c194de51c0cfdf579c3dacea583f5ef1631211f248360d0ffc6489b5518458c756d9cac7061bab366f74131f87c1674d325baa9dc27a3556f73d90af40f5eb033c67e3a0f7be6865fc200aafa1a89ceab5f4898faf07a874627d2b22bd13bffdae89384c0f2a7f69ec1b69964fcc27bbef954aa71b5000c52b31a3f240505033459ada916c344cdbf7c615e874fc12f3b409aa930c096221d1047f758ffe9adcb75ad4860e969fd674f4d2ad6c07c8e7e4a2fbe3f1addce8bb7f0e73f2e48e7da679b86688662f86d3d56bb7b1ba56d0a6c6ca667132d8cb07c4b0009c2eb88bff6e1ffd533fc879e6c9e332ef5a7b1a5f7c6f29af127a38524998ad525d8ab0d8b9a5847456e891be3d3b9255ae1e8af4f2bc07a3ec2509d900fcaff2b3da147b609ede68683265286ec7b280d58916f9cecc4bf17870b3f38af1bb38489f596b4c42317de4ffb54db08811eb8d4ee94d068818271600ce65344f2119bc9333b8341b665caf08e9858874d5e284a76c59b35d69a709a41702077b4489d3187c397f04fd7eb0dab3be6e50174e30038f498bc6373452e25f8536405e1fa0bb90a55945e6c52e387a736324dfc41348981bfe3bfec6a717a16b91eb15ed8da14c10f5a362d9903c8e963479d3a86b99f00e92c3db7c32c9fe00034be7819576b34b589be21cda143b108fb4683d1447a81e06da508a25532722213081aa41fe2aa40b1b45b6b1c9623180636fa66a5211650d5296bc48d9718972f68a4fa56e5d318d0cf6a30fe0c40931d61ab41b3d8b6e99597d7b4411174dc5033c98626da5370b43f5bce8690fd601f6a6729952171764ff7bc655228dd27d9ba7501a5d365acdb3efb11d4f1bf561e89a13f55085aa11d291a0ffe252cee5b8994cb9ea69f3cb408011ab734c43b6cb6dd5e3168287330818e7dfce882e0caee3d62374e42f949bf61cfacaec408662dc0e60a6718f9ca9608961e2f864c5119f0d477bb98d08c507481e5cc03f4265e5b3501fe5e1e28cf1eb57ec3cd715179970cd58f1d630a1c9134fa9f7cdc18046ddc67253e69dd6d7dc5d07716420e3bbc0d5d31f17740c8df6102a7dd9f8bfb63214312b3e0f3c0b707796d9772330969cac98c4a95735c1152bf48550e886a573f2cb91a5f45d1423a5bab22df3e3a73a69fc21e6bd691135c3068bcdb3eac73f1daed2691b50b52e1411d78b8bad741f776b50145241b019d1cc7c80bf438131a3c9fcce7c9a3e48a692b728cd16a1a8a0b8771024cc23492ca2bd1a82eb86e04d7b5d4c16641e27406888f0d3c2afbdc59e01e7dad8e5dd23e02dda7b59fad7b490be89cf29809c62668813cb1160a9651edbfb3762e806725fe32adec79392a8573441ae6af1ba53b277981cdcdd1a6f154163a0f98df3b97d827d3e7cb5e301b2b76004341f0101d7750b7ca1a6e03827695ef74e1e260106ce9fe99121c30b05883f6531b8c023209992f0712a79436c28549200a3856c88737d81e8daa0698b399b00f6057e18dc6114dfe5045329c0f15d161cfd2f4661710f553533525e67f93b3cd9368db590e10acf3d747f0e2d4e0446f5696edf38c8edd6eed32acc98ba765b3799f1187c2d83f4bb9dee06494fe757fdb7c2d752bb2309db7a68a5fe9d62a3e3d75e5b656d9aa3b4256d79eeb732e9d3bcc8f466bc99dc87edea22fcf4716f83fe74a327d6065ea218d6d755e5a5a453ee3ffbb56dcc9923bb3ce10d07c8acbfb96ffbf37087eb7fd0ce022e38a6424c55f0d4034d46d1e5bb201bbe120e52bc70622b76ee3e843fd5027ca60bdc025761f558a842d14b23d0a6dabae85be58679377160ef160575a957a6691515a369d2db8327766d44ecdeba03a4451a2c7379103e82bd0054dbf24d3e94c0640e8f913d80d322d5f769ef65b6057f6c064bf2afce8784ad08bad0072077f82e47aedafb0fa500f2c5d8e56950758ea46f87c5b0a2d308d0566b1ff760c6ea5325e89947891ba6add696d1789664cd33a6b1954a5be94892aa192b23655658898c09783a34eb1582a67374fe1efd82096440e7162d1d1f894a61bcd5fcf5032b49ec1c4849ebe9cfecf3a8299fbc17b4a3c24bdecd8593d5205fec4d3923eedf00b972e3aa680ddfc9bd75956c10ad12e9446760bb79fb6ad1bf5fc066af6a5859928ddd95878e4a0313b7022cb5b461895c9c53582fe17147d6807c5400f91c1ddbc1c6a7d8733f879989f1d1f75ce90b6473506c99e983dbcd47e5533d39c8ca952c55f047f7e56afa8580ed57f4b3d33e0c33f1d804ebbcdfbc8fcdbd7dc62371da8416f83e1c9634c89fc24bcd93f79a80e52e587062250b271a79f68a76f9eeb30150e9698b3095680fcdc7b3ea2b64ab1b89e42a20d74daf018a6ab930cc6d31498767f963ed5e2230d4fba2160819ecc97d952c4130c334785be7d32fc760ef65d8cada4ec5eb5762919ba0e5182ea742b7ea4eb99759739339836562ff1fee5d14c6dcb1d33ff0d09262c87037e02596dd4564db876298a48f764df83a2ad804a3efd4c32daadb57f764c276cc13a928de38c725c84643fe8052ec63d4a94f98b08b3598027429080aa3bde28146470a58e42f03759a73458b74f4dbc820398b8ca6e2b08336931c2776b547192494aedb1de15b271544ee17ffabadf694cbdecfc2a83230975aea8069e4998a8adf34ecca60eb9b44ef94a41e8c639c07849d17203dab7542a4c86d72cec74730a47a4621cc56ea0c5ed7d521f566a5228c4454e67fceb8816adc47d995cf9cf9b19318fe36b5694de0d6d32070ea6c7247e2336474286acf0990805bbc8ce138dec52daf60ffbc6212905ae859a53c34e3dae5792a43c52b39f892e545944e6f43a2df0277c1f4f08e4e28e136d2d46deb7df748e1bd7263edbcf04c62ecf95553a1e25bb5cb45781310e45f305894e16e0b0d9109f0a369fb196ad6369a907cd1543971478bcb6672348f41fa47f838c97fe31c27e29ba2075a544d49d3b7b22c2318e11cc7655d505e88eee1bb49d06ea696a649681e8e1fd0dd1b73d214f4f19cc653e8be413ce6b03805dbb4f87345dbc63d8ddd29b86e88805f803b4b874a6c99dddb59f9bdc6d825b75d3f0c66c53d46ba83eccc715fff283fa11b0c237aadd505d7cc9541dda150fd02c60a29030dfc3af4fdfcf54fe98d6b5db0fda124325687710616299190a4c706b4addb7ec4e6d157b032242711ca45455ff2da8e3a4edfb96495f4e49d7f74ea32d02742e2d6a8d9ea1559990e3fec106f801ce81320c0ce4b34c366d307dc8a865feddf860902f5187aa788a9aaf7e563a8ee5a989282be61e0ddf090cfcd468b8351cc0e892ad17f6c6ecab8e7d0c14a59c1a50a08f07fec54fbbe201d127f8d2386526f127f2e1932f2c8e506bf327274b540773c3f9a195ab0c6126b9cf66f8d66a77ce6ac4c443f691feff306adc6a44787123fb5251f7e93cb6246947d5da2efa59e3fa4feebc0ec25a5f7d5c360b678dae493844d4f84d1b589f106cd31d1a5850738cf695a3b124e3f589e8f44fda6844397592e56ace0c08a5b3a24ce96eaf6968e1880dd51bceba5fd549d681894751010fa63c6a5af7b76659f6063ed3cc2f93f46369a377a643eafcf4b077b394c233e4673e3819866f1cbd39f1ac0150dc3448dc7257c86b0e06ccc58ab3263bb07c8ad01e506c69c955b295ef10026f1a10b4bdf9bd4be48033cb96464c001d83389e84a3288d5bfef7cf94087d40647351fad898ca609aef707c2cd62e1c961d5850e86fae9d5c438a4fbe308bfc0427e5e4b8363dd81f75c380f0eab672198c876d092fb1fb670ce1ea0a5cfde94f7f943ab15b41c1dcad32e55efa593562d36f32e5686c5e1c26ce85d8b74b6101a47b48a529d47a4483106e9153b7964b8ab37077cc96cd5435e0ca4cfa32cc2056a4b24c7e9e8505ff15272336833c77a309bc3c993b5a05bc111e49d9cf174e2d5045488a2dde057619eb31f1b22c804c8b6626dd1e2e410cb75e3524c1dabfb7b53e9bbb570bdb2028d901dfb969f907754b772558a41ef5058443411c5137fa3d8ba9f2336782180605d61ac3f26a168a7d4fe9c1c377cea5a806061bf4eaf503b04f7332cd8d4bf780a919d322a272220ad1fce7b2c95bcbcb26599551848a69432293dfd679267660fb6df38c98f97a50fa7df93deb3c729a44a00ff9672680df5b338d2ecd1a5f0162d1398a468940f5f1f0501351a2be3ed14fde2502558249595e6b579234cb8990b060a630a1d4711fab4460e877d3d9b7d00dae6a8c14b24c2d9504be70fe2f8c316bf7ef60ec10a5c3eb46fc8af24c638cafdf573e15a80083e59722b5c39f0269d23d1564e4d957b3175ef3f24b90f59f45d4cf5b2e420f06cf654feeac1c95f129d17715a17c2c2860d7a6a3c28e6cf9aee2120ca1ed0eaa0aef541bbc678c3a06df9836426552564846e66f233b32a76659b9c62dba6f664c441eb5d7106f7c848343835cbcf91ea062652ab8d54ea409a52abfbe200ce2097ab22edaef56ff8b7165ef784a2535882259e4bb374556a84e6be8288f52009481f9b163c2abd2a57bf858e089f5f1df5f31c8c4fe34c33b2bd228ac9f4ea38c5eceababdd34eb00f52c67842304681719b61279a16cd006f7549223465b151ad9078cca8e7c61a76c93a876c2d3c7a3a05b9227c44eedd7402acaaf26d31c8b999c6c9260f30939947b2b4be28d8d3ec34c6e62ce73b33807bc848db80676ea705d1acd08b3fb7f6ca8be8b800c3ad77538bc4fbb87a7c5496fd86a15854caa328ab68ff924b8fed11188a69c72754a8e8cb884c46657ab25af24c3620d672e848d773856087be30603e5f530aeca72cfa522a0d23b4bed8165bcfd78873f681447a705c019bf068c8d32b9b6a41bf6a6416d7e5cd6b57c7953e2ed2e3c49a3874303d9112c1bbd2cff9497dbe1d9413c0eec1efbf625867ae18f808b360c76ed945334b499a48f871b64193098535cbce21f2a8f945d7342c4de9a942bd81a0a26178b639187121f15cb50d50f21496ee4d0562f4d4e58e34ad12011435e1004a136190cf47876ae07e129c73198df877c9df7744ecf79daf54f8b119838dadf81548fdd18df1232b48fb6988a3c98b2fd41624e5258079b9da53362f74e74ffe82f057a151131a1a2bc16fa091a0a6c8e3b85e75e9b2f69c1fe64e2e3be94537dd9f4874c2e082f35f6d6e2b739bfdd63cdea961f28fec0a6d8410f5106ca30fc746554955c3bcb4298898ac13b71dc7742cba228f0834c3554926f5ef30a7c2183a3de0e08df74b30f2080b1c8eeaecb6e719adaebce94c411d8ce088917c1bb9f0b7c8d5520b9e055848830b84dbe94f6b35f40c46bf235630f306c9d6eb82b36299ea06eb5cd3baaf8898340aadd069dd257afdd13170ee854b69547416de549eed63c3d19655b2fc60544675e96b31630cc7024d09f484410c3c4cd5567f638c19da5934b3e4229c26548240c1c9c214b72f12dce994a5ad75e960c421356d31898eafe8234ce782d3fff6b40c0dc63500c1edc3e38787240c8517d544b61d68b693d89850e58a5c8aa2a01d1cc465b49df82bd6fc15463fc21f43b8a34123022b22e8759274fa350c22456a091db10ee629b31a2f6d731d2a75ee59a764977e3121f7493b1d0e2d812c109d1853a27fec7b2d8858c916ec8437d034d7f339883b52b0c2295132cb976a43edaf9a040f2a4004a4f1886a70393d4bebec2feac1423f9b92ba6b2c198018a0c58d1cc52a8d519f07569674efdf49cfe123ba0fa098158820c50d8ccb570af3d66498bc838fbbdb24479bd2857dadc49ba744b76e19695a5fee121a6c6bbad29f9a7cd58154d8948b5341dd46d087a3c1127298f91bf5ebb53ff7a709c99ad36d2335f3d805747fe26e80e62f25342ae59249e4cb531cb3faee8eb90c32df32cb2f0a2b15ed372e3fc7d19297fac46a682105c88a554d6c45d3ed456d8b5b871faa01e8570fe6892412e9000070b2cc4e9d2cc75acf15457cbaed9d9e5c8ceffee88711ca35ee36fdbf67ad0e9e350837a832fa264d47da516d0af278fcdb121887896931f28af7bcc0b6d619fccdaa6bd3b65faa62ff6e69564f3c2a1feaef8e32276bd17561ffa5c06c1a6ede77a4d468065c3e52a6e73a6bef0e52065d5a6659f8977e22b1e9795f836fad41f8b59a0942e783b70ff1ece9aebfd7c6cfe9554a66928315095cf4f0994207aca43d478cabc9530df3359133fdb5edf65f4b19730f028bad2101599b4fdc42c48628fdd9e6c552ce293cfa89e3b590ef1d273b506e125b1d275d69e0ca0ff04365516903907b71f0c78b811102b96f11725d2dd1884aa4b317231018d4202fc85ed0886c3d1d42963d5bc8f116286173a7f316e315fe7b97e2ec0193134d9a8edac5b5c6d95eb5891b52d98dbfde916bce99f700950be4f215439b5ac2a295bc863dbb2dafd1ee515ebf1d269b1a7077a6107c84f359ae6bc22b8f9fc5c08596425c06e38255a6fadc93e50e133155c7fa50a5623d0e5b3915a7c0c291929545a1164fa98844207c60c16f2f57a2864b18f4ad0f272afbedba8c507ee32c612ec21955fea21c7a4f7bc8d86fc1acc181e2909a83b02dd6a61542430e101d2a84f413a0cb8915067ce9a61641fb4b6fc10d5c9313ff59c80154d98f73eae3d3a0472dea49872f0e621d33fb91b3d84b5521c44b55773f4b3e30edda0ebce28719c70cd19b926a0b2dab28e4d3d6db930393dae588e76459557fe229b4f0a7e12ba9dacaa8c74d4376756192e744838c6db658f933a5f1f97ba93b9723c250d06a398e97042da881573c49b6d32226b0e5d39fbe925f03c6f8e004097e692f6318f760a6beb42138b59acdbf830337aab605426643359e083b2a0b2ba4f1e5a546aa250dd5841bf9f0e1558887528e7756d86b6d2a6a120fa861e2460c7c7837d7b4ccc05ee53dc6fe7274fa72e1e62bae3f91b551e927541c06bc3364b3d7af651f1c4f99bdbc150ef6971853fee22d27edad72042773c28e6c9cdd3acbc01984cf1e77f7c3a18c5b34785b0cb532eab0573dcb6b15016f0030467d7b14b9eb3f7dfd1ed7f30df08fa01be208d6f2adf3393f06daa20e4fc0c031d36c0495bc962a55daf3263bfa9e880cac83aa75a3af3cb74fcd18a46ca93c6ac4329faa255a42e76552907d565f1e292219363ea6219c9350b9b40383f9b1dd5c5a609b482fff1dbea72ef6a7139816fe5fccfcd7b941741babcfd04aeef68a4c92a2168946c03a81bd71d17975dca32f5b44e027f2acae8c1bbd2e62fc81e64f4499895b7812ef760b3fa7a4b178c72a97ff8eb70aaccc238c0193fe3aed7f45cd49e32e0db0aaec71b533da8bd12c0477fe63d4022ec20ae9c97d04629a78c32c511a7bd526ab69a2838ba179355a112ee753d50370c20286cfd64be18f43a51d58e16f8649690a5cfc49073749a49ecb689b3911e19ec261bdef0dbcdc7e850bada98f059eea50a070f5f532f9fffa35bdab09044ed3ab17d554b833385abacf086c949f0ca49f6aaef563bad73dc56761aaa6f99244ca6321c5f7976ad917eab3d2a90bdfe4d57eb7d301bffa0c9bcec231a31b73963f6202a796a92193c4458b44c0b0b3143e6cfa348df159b6534fc85b6067bbd3b518956c2791194f6e47193e4ab6a7540e25ebf74f6d8c989da24947d6eb125648efb3ee22edc8d0c840038b6f8da41b7705e186d43cf8fba3ea68277a17d8880342269b08b7c40ad8d06d7884d87fc42c001ba0d5ab23981e424f68fd1a1d2b6fd30cfbab20079855899f19e22e778aa8df2d25927e0433307ff5d6000d9dee0ac9f8fbaef3a3f331dbdd2caa19d9f124279bfb25e5e7fd7295464b2c8ffecf3e08a933119762903d52e2d32ebfddef6cd80c69bb5c8804b76e9f26f360d70b9dd5d04da0a8d6db51dbd2daf42d0e252c61cf59ab8752df2c2df43ca5e9716a6e5503c6cc7112fe626c93e60c40155aaacf436818abe14eb1f6c800ba3aecb12c5328da4e8efd1652180ce3f1ff6b485f6cdb7aeeec47059f09be4f50e9af98163a9ba4ee77847de9f5fda433261ee7a9050927337aec8e4ad8c5e615215619f4126b69f3f8f186e71b53c06dac1498993f62ff0ff34a4dba69dbfc357595343b6360a363f79d5d1de75a54c9d59a12661a1e32caba66c9271514054c20e3b9677f67c413cc4ce63488f119e816f02426dc641d2defd8922e5fbe11cd45ea7900ebb4d60ae5742a37b6be5dcab0b6628dbfc824c601024005fbcec5098c321bae804d87c7744f67e1955eb96dfce03dbeba4d1c8b56e185279a295787bfb01b8989d0b597c39d61d5078703e382af8da19c322d1650e0d05183f9d95ed2c3d76b9c336286d33291bbd3539a15c4916ecd7336247b71c541ad508200f08a9b65cd59bf0e7f1ccad7c9e4ccdb583f4ac6eb3b025ee5061d207ca239ec64777a44b9ac77818bdd7ce6bd58d17f735e757ab945d8c6876502d4288f75a3722252ad3d2a8b1a3345ab626e7e810408ff108b182e056179d4388630f61657abb27bde3a40ecfbeaa9c162f5959860e56d761a392f686a7cf01462cdf77c2c7291b4e88ddce7f172210cc51af3102ed663c3d1f4465289912613b423977fe213af66394a644171dcad0a883e22076551dd9a886c8e1816e920faaf1df077e04b9164a2f9931e35f6a3e62062b92676e6087f5664575bc2c6bd744ccc3136843105bcbe5862d56c24331db758eafe2328e2318fe3f83025139bda430580b9787e285a03920f88d5c4e59b8c335dbfd6835e6f7c9d064300ab08eea3219b4774a25784d8f44bdc163a9a7dd622ab1d471998c80b23b491a8f702cf5fcc78cdaf2741728bac1e30c070a6146b7c10f877583ca471b016fe38459cc494cfdef9552e6b5c21c8c4f39985ea51bda475ba5b82e8ce6e3ccbecba6be240679d522e072ba4bcc362b348c17eed3d0f6a37b308453c708bc15fda06ad92d8ac8cfd62a40e3bde6ab38dab2f26219ba0c7e0ef3fcf0dddfdfa03a7da2670a27f911689e2f01576023ae76e71139adf6b8d191438bd301cc38a8a28439fe20c0e2a4226d21bad31d16338375d2bec6d6dab1bf509b190e9503f9cbabb5b374c8c7355a7d711e5b94318dd5244285e2c8822d4bd12a100e3f413e05c53f762209c8b5fc17a80cf27db2c9ac752e3314f388aec7cd568f29b6efccb3d2e92a0fedc2c6112ff0151e7cb61315d16a666e9df034a6d69918b249fcc6ee61ca090f9caddbacd1cb5113a26db53eb350293604496a81297961c1323bedcd6f41324229c51e12dc304a311c3384f93f505690a9fea96bb377277cbd8173b8d05d748548e29564c371e84c6af87f21addb95fd0afbeeba85ca7c9beec8b939a57d85bd2d195f9ad4b33f7401f3c7862603f3ebc05d4b20a9a4e351e4a10c18f0d86d6822509d408193419c321ca3be1763dfa721683e0e93c90292c78370eafa17a41a721291ce0a5fcf95ea1bdeb09371a537c493d15168601d57c45363005367a52d064bf04dc907ea82d2a068cf104f808290bb63c471902fa062bd12dee88f10e5c1deeb9c6071a7d0b061b6070633204e3e811545e179399311e5081ff6010216fd5a8cdf5f47ccbe24af8b7d069e90947d92eb867d264a11899d98c28db5b5cbd5b5fa79b62c376e21376f6e77b2ddd5c88d48340f0f30213e2c8bf01c077fae978d2e83ca75c32e8eb1746cb8dbf6b53cd4d5badf96d46c5f55d0bd339fa42026986e5bd22fed9d5bc2781ac6431320e6e923cf1b3703c3ed923b2b84ad92a045e5c3e4a2fda2817c0ee92c0ace6d1e0072364186acd6dbaf9e36e36849e8da5f1db2c3a0e820e491224707e7ffd678a97f61bab2c18d2c455590c11202ad99c5f3b073d93a1202a5ffde5bb26ba3f0b427d083f8543b7db7bb0d322943551e428831f47b2f55414bfc16c790f6713239168da5e07aac1148ed6b44db59f6eb22197bc6148c34ab4c0fdc536910215a90f7b284ca6a527cdb1085fef13e5f9e5398d89770e7cf7d855790077d07ff0bb21e4b64d1fc7c99d2a221ad6893fd14b8216d531272c7b4a2060d30ac473728737268952f926a2ae7c127ad261e3d4c72a44b3ae513b8bff69b15ed27f72acc9bd165c3b743ae0cc43b239decd60b39129c26477bc094d16e4312c93c5bb3196c4239c65fda8537f97241e85c81ee35c3ac03c23584aef81893a0c986353ad07bbb4bc9acfc2e4e4b6737dfb668a0336eeb72da78dc4d3d6844d8f5f1f065ce8449f1451e7afd7377ad36e86f3e7d612646b363762ad3465344bbcc829a796922b278b09a182ffb5085836870b79ced19ddfb9baa6cba4752e0b6bf92d2932b39f0b1594e199b4cbbf821b41685d559840f720fd2d5a4efe822a416bbaca87f0ad3c8972a57b9be7bf90ba3ccad4e425232cf523d7cf361dd439261117e461c8f43c1cb39f7704ff5ab9cd5865456c0e9ca13dfd626a846a9e15c1bcabdd86349825d675eaa523803f70190ee0c0e324c3daf77c619cd6a5ce0e0e4b6237d232a36b1487a0779cf965bc795d8ad26dd9fdcdedc64a08e2b572fe0379a5ac025a55ab6b63284fbd21772e75399b625a07c01227916a528b15561c6efbed1a8a8f091767bfab2d0223c3bdd1ec7f335d7fe6271d32fe70bb64467c32ccfb5db7a8060dc548570ae24852650771964b930711dde349a4b39e172b2615adfe95a458d98732e8623f80248658104c0be04cc1ce89e4380c2dbd5515529904b7af87e386204e64e9520061ce1e38c6e1e243a15473c6483c44f84b7ec7c9c7366b53c74e60608823a0a57038b9ff751d19e927a603c0b7f5226659f66219efbe9502f10b6ec1262066f5c21cefbbaeba58a29927d00d962c6602e21f24400bb38efb357a95f99281221d207058c27a70c065ad3a007cabf8b4b440de40d04a6d600f69c5eea2b9f1dd92507176e93f4e2ca3ef4fc5c05fc9d6705231df28b7eca15a6e9322aaeaf255ff142c70a0fa0e74abd2f4481773717c37192c73031fb4d583601fdd01b7fe3e37679b58bd363681c5b53ef3f70ea13269483f6dfcf22915118776cd71ce1fcaab902237ab203bccff6bfb230c65697f1e010e1e56ea5bdfd9f2f5e852f012a1ce26979f5e3d5f28d98bc2b6ff294a31fb93c7da252f8c1cf4c6c7f8733287260141bfa7288e87ef42da9cc80118f138e30a5630ace6c6543cdd9c11969a205faaa21974413d26b42fe6acddf32e57cde5c8fdbd91425810443b13e84cfb8d2c06c3c7f8e2339a864f1488fedcbd0eb10a7087796b75825777c59b11ba867505917ebfae534d3c19815ff063e30b73c286158b0039cf0c7b33ec296951ba5b4b61fe1135b25b07deb27f9ed204eb274dfd29f047e0aac1e5fd621d72545f6ef41e2e83dbaf479a4ae8ce586a64fd2f9c36e5e0b7f6d502e95136b1f7189e59857d7d6af5290ebc56c261403cb1b7706297b98a8c96bdb8b2e017cef187180fcce36b5da3ae97c1dbb1d2afce706407502be7f1b57c8c861da1b1a78dc42523736c98ecd6825dff6fd43d54fdfa21833902e8731fbd55be665b6335e21ed7599be24ec702f42f5f8cea0884384cad88bdf2188fe36b35200498aace38809ebdea3691157ed6a6fb25c3c508590f613874e8b25cee0fd0de8ba879d71aaba1b63481134f11c1f835ee7e5681a38a426f776416ef469a4f1d10ab2d5feb4db1684f60bd9af6a3cf19c45522a6ac861caa8e43ee84aab5d1c089dafff987ab9e3569093146f5cfb8503943cccfceb55df4cf401c8f9733cd862d5a276d4db04420fb466169895d9a2994a212b8ab2603ee46bfa015258f222da156f2613836e3055bec59d40c2c48c7bc825eed6c86ca2a7d68e2328c1a072ecf64f97ed8e8aaa80ea960407cba8bfc1593dbb254ee9c26926a4248b7b8629baba7c82cf0004815000b2526547698c09a47735cdbf7a9c7a777066ae8cb690c6265d6bf6e228dd612341f32b0f90d13fdd91d9f14343aca8b705105c2d1c8f84da2b7014e4710ff32359c80422d02a09b92167906e12f9b1f90cd48da0b9afd3e145f33e8349d24e60e2ba9b22cabc6c4072d9d41890ea7fa6608d0299f9894fded01bafe2a063f53edff30f85b305806131d78f860c2cad2f75162056722aa5a82fc681795baa7c74247083afa926800834b7dcb00d9d2f48e7ccb44bbaf893fd8d6eaa8a21199780512ce2eeb3e44bee5bb93d88dea9666aa6c5d4b2ffc4d9bd266b405e6e5436f136db617fd17673fe11924531a993367665a8651f2607b1df53a14c4985851aa0fc78bb230a9c5afb8c2df3256889f2148f8b5ab3765af942c1018b3b97aa45085ba5c163198de7c9824a89da2d21260235a8231e24c2f483a009695c06647190f99c9f4e4adf9617434ac982e0ad7ef495ec9c53d6f6bdde20debc10ed3e27edfc5564d9c4dcd830a89b074707407037c03f23e075af958dc53d863e0cb6b4a8bb974bb3002f46a8e451244551a20afe499e1a83fb9f66617392b3311d3ab5631f748def59149819b88da6d2e417ad45811e0dbe4afbde46914ab2cbb21da1269835278f5411cb02241e7fa041016116458c7b3d2162b979ab5064431f3d283afb9b5b2e73f60c03a4e361aa6b349d8a926ca3ce85ba0e25e4b8350b98189fa64594f9759e5cf15e91da2137b7bf6f6f73e9d6eba8e031c78054031d7571fd15e4d3025e97212b976b847a60475d2f7d2bf5af0f16d16f16c766a67ab26de1905a2eae9e6cd66430f445f03c7192750d959907c9fe0727a53aae93564aa7e2e66ce0d85dd651ae74e35c2a1f8046a25989428e7f614c2808e075ecc593225e71ab90e7dae7c9a6ae55163c321a5fe8dccf901653a76fa0f4d16ac9375cef73f4c9f20d88ab26f879986ebff7935df2ee5b1608f82113ff195b70cca782e10f5f24acbacb1c3bac0557b01c3c88a3be049c3db637c6c094a902b080cb4abeb20eb62ac5f1e31ab089bca5f0a7ba2f63b65d65ecebe1d3f90256f3c099f889c15bb1054c1732a6263fc18bb9327336ff7a87d0ffc92af52afb420c31b151aa3222f04e4057c96b9c66a1abf5af442789720872d920b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
