<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1925fef57bc005d811d80eb544e0236ee755fed20c20af6bae939fa64e7d7b5560b663ee466bef817e0a8351656a34c11af87e6c1a3fcb7b91f2601f9fba5c5cbcc3a03d2fc45cd1143426e855753e5f56163fc695a721d60c0992462f0443b836d9dbecd52a831e4a3eba8420376f779597e71e840b1c81ba7321eedc595ad62865673e82de953fdbbcc8ecd071873cf1357ee60d7e59c24a01a9cd580f4ef1e6f1b5d5acd7a7ddf6458f8f42ab17979ad62389b93257c599fa8f89e074698154427ef38bbbd0c7838c4403a02df8cd1ff2d7e9ec7a5822633c973adf7baf758e71feb8cbe8550469d7e85d380ad043a2ea8ccf7676786f6f6c8bfc02864de715d4b551985fb4429e53e4c91827970f17cc8f0c2125d4b5821b52787a08e9209caba463c20523af97bbb9c38a39b8bef069f04732e8c96a99fe30f0c84bae13e0b976cf1cfee160226fe4f847806df838c58004499f1361ad22cfdfbf3193f67a5ab6db18701b197542026de913773140b4cc35bf1f84282f743a07c0798429056d75cf684dbf23e8a0e248f4bd3eaab5ff64346744c00216b8edc0373bbd10881ed6cbe598bd64d1151b68db9b50c47cd68b32018b1791b1fa8eae6ceb41e19180b893ca66438b66188b448911e535d9dd88596673a4d21f0c4c3ae348ec00c04b96221933ab868d78f80ea70364477501022fcd47599db462952b5cdaa24e9f14946be3faee547fa72266ad0ecc9a37acaadc46379c13cc86e7aaf1658865a39b89018d9353967809293756d0e6ecee62ab50fd1f252d24e2a87c3f9beed00278fa8862723a28fa394c3458ad59d924ac9393341f4bd1e13bc9f061938b3e96e8c48608b43b6490c1c28e748a9cc0808f71d97fd93b3e135daaeefda7f0fcc242cc7b1429b85d9dfc9ae808c83f26bba5df0c5e42c74de6aad67c53ed6ea63510f9d5f501cd5336c8b00e7bb0df216af5fa80b528654ed4247b5a8c480f4180331cab857fe380246da019ac9baaaddf3fda9707a3dbdda91b595d5aae509a2ba5f5db9be814e480e5074530e30ed6a199576af12941de43d75c3c7d32b4ca2028c1b4470af595823ba1659e245d27c77d4e3d8183f1f494adbf03c8708a7017f742b90ec4d701cd191fc5d4dc8ca568d619b1eeecf2309c3574cc59a40cd86ebf5ef8e6d25b4ac12c21a431b62cc11e47a0f063be954f899da47fae3d79f384f3c54ab6239e77b29f5e23c08dc963dc6a872a92013d2ea2603a4f2ff02c31ddc49350e46d7bcb1d9aabd14f302a27d715ddcdc845dbbb0d4552dc44da1f4e3db49eb7849ea1ac2b610ed2f75a59f72a22f49913bfd5279754f56ba440ad500c570aec133e0b5d1b9649e7c0699e82f252adbe56f7e7c0da6631ac8dbd8a872b16b11feef07d898fc2e240f43a94bd5491fd29b1480754f1ecd2133b984ff61078d37029514c6dd5abcef7452c034ccb648cf425480ce5f661d6b9ba802c39c75b8d5c0fda04f5d0907c30bc4cb8326e399b176d2351139abb9019bc87b79591a87ca823aa9ed029f19342618a500865c31d9396630bfe0b742e588269a757a3cdcb0a6e82c1dc162cfe7014070e9226d0099532f93a0d2d06ce23df1788921b39a7affec36d2cac656eae3724716c2499ad982d8d5377fb49224187142026a9ec74ce48cc599e1d1037662b4e8d52a4aaf01ebaa4a7d90204d8c13166af4ce73f6d585a375f7d3e73b66babe4eca661e5be733fe7bf33f45397cb09caa12907ebc3b24552c6327c8c40466a609b5a11196e8dd33b4f93c65914fdd1362d05a550332db5ce564d692c95a118ba5282c7d181c7df8663d98999164d188e66443633c27dd18190c370c3d12bd3e828225f84fe322897923995d49f0564f509c07468f5837064ed94b6ce3ec4b67163cd846c65db9e9225c12129b67522e08aac4052cef2fea23f0dad292f4694fc6bcc1ca35112de2aa0cb231744b9f91101fab5f4e7b527cf7c1cdddee806f0ff37c26f630d2d784c9e9be7133b677c80778e524f5add521270eefbfe40c92b4990001d5c7d06f31c1b000fffa86dac311765367c8b5def85d4e4580b7ea4652d38c66eeecda7fe99a54c9993de1eac832b74af81e7cbffca871c7c8341ac680abeda8012f5c681e18235c17ac844408433c0e9100bd7cbb0d02c94b89a9c77d2c00d644ae0d090e1fb7022f9bb720f7211c6f9e2284564c3d72a1bac6ca1f9eb0c2cb4e283f9bc16ab8364bb6c9668eb51aa07dedf0164e1bbcd0da3787d454cd5814f70bd88a1d30234ee26287be2fa7792ececa33b40db4a22027d32222da4105a1cf8b2ce23a6582590df74d68f03ef0597094e3a77b37fee6e80537db0a91dad2a2ebecf7a1539265fa4eb3b5f5a9f73e0ebc56c7bf72570bb21a994248e9726499ac2509285affc55ea2f774428df3be6b4aa4450135d78974e6d1ec39c576473661fbf513fa5868d6eab43f7bb9ead1a7ec009fb975e858b21c57c2294a0c600ca3cb126102e5cc981ce0a500b4bf17e8d2318d51c2978e57686ef60cc77d8eeb5deb10af9d73b5e6788e44ad58f1cb634f3032a8457b30162185ca364b9bc36906c7e5b14cc62d5a1933645bbe24a598f1a30ed605a34c5737e5e0570199da84e1dd38185ae1f1263ac88b50b02cb85251ac2366da4d4e4b1c13497ca317d108e4503b91fa558a9b7aeaca900b9718d91dfd50a5adf270a09a48bd3b8f56be4a989fa6de3acd4e12b99bfb5cbd7e95bbe8e865ea7f4021d518d2251ac71098f9c0ab6a3488c8a37fd3a74095be931de8b525e4ed88d4ec135258c00c0d82e895b9983d33c9e7fd6eae4d3100f023f29dc3dde1e00d645c06fda6f65dd2744523ffc884aba72be3d34d6e999695cd5804229f8d5e0de29293d076ae8bd3533e5d5c006000569adff851873c4357784a80dedc8f111cad2aadb9b515de42c56e8ca3fa6ad4f685e066946f24a2cd5fb2ce7b4eaa8602892bbd466b3128e1a09fb65b365d8f19a5eb843edd0655dfb8be79b3a4c30981ddde2a368b540e411854522365ca22707e9bc2794bb445259d82d3db17cc8c880975ef685434ae5353dc8bd74ee37611421122638548de27db28a0a25ebe7525a7bb5cd1a539c666121e2709be22ba719326dc29ef95134ddb3e4d30f8c1b12915135b2ce0e9d34211bfa3d81b8e2b4a9ef9d305a84ad934e9c38278b6b234b7df22525be15ae92bbd4546b15e321394f2855288cb41ce0b20f6010e71f73522f16d75cc1b7d642fa7041309f783b03d54b71350dfda280d104c78fc788940cc87ba92212f62cfeb6b5fd87e164e8f52f094150d127481065a04d86a2a9ee95d41ceb1ab51b21bdf8dedfa82ac623bc9bcc1452f43bb6b7f4bc080f330180d3078c81d6633731dc61bcd8106c83c352f121ff659e680e08fac215a2359358e589db154c441ebe716def613829af31d566e27e6d8c7f56200b29a700f432ed094bfd50e08ddca8fd1632bd3f5dba1e5a99c5f273c4b8b32535c9bb4511d2850913150b27e526144d5f359b0e33c16fb5dc36173f71f4531ce8a2a378e390ca4262c77fd59e73fba067cddf3736d0f33a22e2c782e3d3424c5b246f1049a6a0aaf3715090ad9eab1049a66bc5aa8b2638853973dfc43a9efed1ae471e66093a8d927d33f00c2af535cc2cb62b2b6843eab58e3d2bf0cf0f6a5862c869e261e6ad122e24578ea801c38becabbdc6d4f875544b4e168ba516f51914844ecc31b4ef61efc3d233ac0412599fc1ab122ae145f9885af2f5505ab9ed4e861eea5430a1def6e288f2c793c4aae9de7b0d5dc2017102748ca08c8dcccdfec5a21996a9792cf6935702674abf39ba50d5dfe2d9a3bf97cf5c5f21ef0c1cabbf3ac87a819dfa8006bb278900b63271d0398799fb6821c1cf99c3047f9478dba067550a534b5a87530a7b0f5fc5d89c25591342eb98321acde98daadf83632b8b9be3117fd2c7a67977aa076a212f14ef0f91c33a65ffddd0a2c8c896cdc89903357175428ff7d30d2ba7a9ec1cccfa8ebaa24a5a2957291ac3990fcf33a9465091397db87f713e6b77b60516148b6f3da57fce1b94d1e02759779aa025db7482fa3628972a00c6a98c2d53a11b7d115b14301bad1a96431e82efb6b97e263d55fabf5586fcdd8afd64072d6aa8937a7c879daf935fbdec98cd464594c10db2a1a211e41f1a85b5c28d5e0acb68390df56828ba7595e1f0c7505a8d3dbbe288df852cdd8049a798b3ab67dc8635702c8c35a2fe0d09a40212e331b7acfc3e9a133c42d624f2695cd71b6ae76c72483d3c6542c60ec32b24d55354c1a3625a4791fcef26205512517f25bca15ee76bc895e14f7ee5675e1c50f42c965ae7ae4248a20752603e76e454d776f6d7da4bcdb4b21d6feda38c0dba6ba8556fa95e55bec345e7700f24028e6cd07a294eef7aaa4893e67ccba90b3cf38ee55f3225af2acd3c79d7fadedcfdd63994d2690d4f9ee46f7c90cc78c15917e49d7747cc40ff8e22ead1629258092bf282bf8acfa23ad4b4c7678a026f429ded3b2855a67cffdd1ff874ee77a843effd01c0feaf44385ee8658114c2447b935a6b585894292be6fc4273af8f4b9836f1fe1f95ed79ca75cc41342f8aaa354cbe6051e526ca1dc20e1c0314ac25b1c9663e49bda48f476fdbd404a913246ae1301e4f1d3f04fea096fd2f233dd697c5d0d653b43c35f5f09cfdadbfa2d5ac20677f44c927e7478b76bb792c0420a49de1f49e96fcf762d4c3fda7f43afc8fc89a0694c0f1f316b0903967d055b49d86f9905f81c887f3209f6bceba46fe38eb61633b7cce2a7d5b125ef42dd9346a0321993b875bba4aa51daf52ce8415051658d38cc7ede19c909d6f1bb59efa5bdfa69c17c21bbbd4b6db519b45b1c9f6703916583509f58c41668bcc6330a57afa65df476d30a6c74ea5721eb3ec9187873d99c5980802898ab41f7ad6e305a835eb77856448f46a9435cc7f72c369bdbf8071a7a035f9cc7fb777d02c2e0b04b5218756b5a511e60d8fc2aaa52cef60fa9dfc6bb44468544e5c8df0d5a73121eedaa87007f172ae55843b9703050505631117f4cb1fa4b4a87d4a90f456c68b4d3a60e47ba2d9106b42e2c345390d1f3c7aa9fee77a803840f96a55c8fede4291e91f2d73805439169bfc0b0184898b828b09b2587e6b3adbc7dc584d04b812e11412de16513f78834f58c6cdc2b6e91408f481c141c47ff61e6399bce94127d8fb9507ed35d5fbacbc319c729fdcce7b66a9835f7d3c2d51bedd9a0ae49fa1f4f479e60af62e6fe3798eb44adb93735aa238c75410d83002f32fbfd6f871343ad14c2aa6fbba1cf2bbc8919ca1c3d38f03199ac935de38487ca54a0567be3f7e769c4d3edabfb2eddd5d2eaf6bd63c15aef62b16626e3a5d185120071a1ca7a9f6b65f504166075a065ff3a6d534d656925f04c979673d9f23302f3b3fbf4142b5e853ea044edd08b0dc58f1e6cb085f717cbfd9cacb37f0d872125d31703d6db6815172fa268db1bd42a29deece1ee2e0f89a761f7ad7257ac132efe1c6ccbd7d98be531ae3695c683c3d5069fe0052b50c4dcc6731a2db713b22a3f0c6fb395d65734cbe0c353d3b1f6d75059c66de4df94196c63e1005607f0ac283ff8d0f76e27af803e8a330bca46e06a130a36460054522c511226100b3ed2b0b883fa8deb53ed1a86c65b8234e8c80fd91d19910c29cbf7d9a00165f4d7d722b0f61d28a5ee7a986a049b81424c85e77d4813662f58afe93fa14a5cce8edf96a12912c4b68c4a1d2b8e8838072f07a7d10f2bf5577421d0373c2c18b0263a64c9e060a4cb9ebbb956a1864b45d803b305db2db1b759e58fc0ee5a17aa631aa11d3ba4855b6d11a8a80dbef9a7525e87ac01113e1a13dbbc0b1a6bdf6eb7a383d611b5dee7c48cf597e31e9e68e5d120ab9649d4613484b18212ccef18a84852aa6ae78bc31f24d195f6d45e7d6e83617f86bed19106303e641936132b78f613d2d57d08928c8511447d073ab9a81e92f22c5ae42ee02daea1f8b024c15f0235c6d07c0fd5aa2b655d0f5bf1750e45837888f9cb78e6fa373fa4cb0124eea342f0714b28757bbd3dc5c234b766d657832f9fe4b54c93893f5c33fabaa3de45dc33314d046b4c28cef1a741d2e7dc7fbdbe314d51f75a5820ed0484cb0177e5477ed40b6aa5a8f8b537ec2766a1b8c9de251f92767d541919efb6a2ecbf21db43b65cfaa52cd3354707e84edc5b262e5440fa60431d35f835dbb7f8063b90be7b832f3065165b9207e4c7fde47f5517ca16bfb21d671fecdfbdfed6b337e11d0ceea4a21670f35f64217455e7779031e5d9ed041fe5eda42be6736806ec876e2c3669a2813dcfa012197d9f8098d61cc2a6af15bb2722a52be9a7795185511de33a6624265a31f22af01bf30034e52b6428fac4bbf087bb03abd267533c9eaa770c7fe2c6049efca1f54254ad4d3b1dd2bb234993e7d8ae6765c688fa7c285884fc4e42680eacd8ea2b638bb0125263e20d6c7dcaee0c353efe7e91a25aff9a554643f290c0d36fca9e8004f87c79a6d6c682e22d40629fa406fc3292eb1af2796f22b1552e4bd5970c4a321893e91ee3551246e6626f479adda2267c171bd23a206bbd7318b545ad4655c114553cfe6ef1990ec6ec807464f44bac1aa5ca3f89e84e435e8e8f47df66d851936162b703b2299c2163c04c22cc4b48d40a285e43f291d104ed2a02bed97b3dcfce54a5e4ccf8c5d4447a02ab45f0dcc20547cb2008331be12f6d20d051938e8dbfdeca6f1c5dfa49e95553640b5c30c33aa66638efbaaad90a38e9b9bd9996b64e6d949b566fa0d28cf9de2e83021aed7def2eea30439fe5b0126a33652f9bf2135d0847f80d7c8377b19173a60b7d725d2003d3a7007433f520288d1773ca67250f7d662ab51e4dcf94a7cd2019cc28004e57ff01919ee04cdac43730f584c215821cae57012fcba7a83f3870d72bf2e3ad45649b6abb47ce42d9b512402c329eb1dda1fe408e3e9d63c925d1d52694ed7d41b00de4d9e79fe3029c801e76ae29d56014af33065f11e259ff7ae8586f0dff985d9b9e6fd5f8fe55ee76ecefc742176293cfd68cabdf377ba547c727a5d871b66e7914e835d36390d0928f116f2f09e4c7ee9d6ad2c26aab8146ff0d78d67d9da7f1253414648adcd62fe49d2127b07e5c9322d05653c3d599626abf4a1d76fb2105222e11df21593a46acb973c3b58a561119a157cec76d2b8f61002830fd2b4fff460a768445f52f7f574c63095ce4919c4c30ece6b7c072bf711a09a754ffc17e42fa437831b8f5033c1409c29db76d82fb78df76c3fc402336eb3bdb284f54595a141d20104f17f2d164505d42047b2e6af98934d017bd814c43054dc67ece8a6bb4c9afca1868f5089cbc5fc943dc72d72effdbe1d3bcd49f03700537d94bddbd4624e0df37de77f47053f75a983bcfcd6ea7ff9401ce9e58106a3ec4e8264478106b7dd3d75e3623cee7238593fac1b02c524847076c575abd232d57015d3a8153a33c9116062e296de24718a81ec2be66592c41a9f4cebb4035410ae011a46263ae00ba77c3106e2bed59e02b910a7d3b70c48e5df3549b5852e10795f4583bdd1044540ffc4545bc7e60671b3816ec395563357e931d3cd610be42432f1715f73a0f2927c7c3b5c7b3f097d3a32400c9eceb649e4e0777292bf4455cb57f59b692ce35531d657ae313a085b379c46e0b1e65cb83bdb4d3bfef46b6c366361b2b094727f9a32decda4987290e5374590ff7535c32afc51d9c75d138622344bf49e0e61b6b8c90ac566f08930d73c274ac99418a8d4c296cbac973d9cc0f9949d86e783dcae208588ea56a2d59792ea2aa7145940d1c91475dc03bf388575263394c41382d3c13fd1a3d16b2d4f4ed9a466b33d6f0f70019aeec58b89afd2d7b5bac9968aa32aa9c26c310e819055558236ca5956771a2fa728473e43650bc711522d89c7cd2e63bf0515db24648ab3b9761dccbf3d90da8d65833620c25a4466eba77b331c04dd859a0f17d5e7af29832c15d3d512d4658f0b423e094eb377af0110021de4605cd19a8c6494aa5f95ef11602e69f023ebbe3cbafacd2180966f3c153aeea55ff3f2e7b3aa59d71b4399996d731ec7c46f1f2a25537a6cd8c3f85e45b287a350346345a32a08a75c93e4bc63017449c398817702e44b8dd6aa64fc4d3d3e5ff5faaa0a05ecff9dc84a6224c8f863b7420c2bd1c00c0a7ebb43a8992124bbf7d6b85f9e37df413b92d5a09fd0f23d04ac626e52b577281226c3b0a7bc1cd60a09d15d6ee888c487f05d98d5b902413fdf8cdeb64d63185268049978c375d7531fb101428aef728774a96bfdd0753761249c1edd99e80ccd2001427c474199c372979f39aaf99672d046b474af7d0ed5849d57233cbcabe454aa050ca9753bf38e7ec90ce8beb841058900f6bd9ba295345e7d5a5248301d97f6c17b6ac1bd15d2bbfba73d0401124ec7dabd70bfc313a5a0fdcfe74992874c046cfb1c4ada441b91bd1e24e4bd91bc9610872bba34c59792ffb3145de9dbf982775d3d5d126c7d197231bf8683a32c4e2cec8131cac057d88d15342e9974d6d11d3f70cf01fd670a8d276c62dbcd37b3df3080e75b26b4f0b3c8055bc502f55799fcf3a30af9a3fe65e08688fbf53ace96d5e16c47c6c2807b0da512acfc5ce02d75048609daa26df2d5afd8255a068b7c351fc203143a7e97f07d4411c0a628d7fb302968091884d4acf51811958602776b8c01ec34d8aa344a3988954c40b70eabf180f5c9a476b99bb04fb5a1b28f250b51296c907530e492e43e92adf6bd66a67b25b8602fa40ddefeb01e3ed0aa9b44feb0b78576b76a09fd33006b970f0e91651723f7651f533d08c9fb4f07de90b1f0b2830b5a8bf1157d3456f6224381a24ccd696aedc5797b03c47406d274b9ac10afd92fc9e9bc33f32faa6eb5daa29ec6e7091b6ebbb4e4ad814db5b959b2270464e973a860e246575d30c925b4e085e2f282dea8f2a3c601ada60257c4e1acf3cd25f5fa591524cec04d9362e359ed427cfc05f431d87d31840110360c03020a838b639f6dd860484ca0e82a2b253d2ca799c08f0ba645cd237211e24f26226530aad34ba9a97085c58597066e4f24abcfe3cded75b80142fcfd8669894ac82ca5ddad5b1b74ad0141fc6cc50a8f592cd4df70e5888572822f8d3fa582558e24bf9f10f198c60ab21ff2c28eba456a3964ce8911abe2dc9ac38d11065da178884aaf14e87f05cbc50d13bf9fc800f337bff04602b89eaa492649daf55e1b2cda2b303ffa6dd864426e92679005ed5d433fcb2bd25f181033cd291e861ebf72260e3510d27ab1b5aae885e1d04d5ba46dc9774b31725d9c9eb554d5e91fd9aef8d8faeb750b69ceda115dce9f22e099fde54986f5d43a07e84f8d3a8d7c6893b3aff83bdecb6d6bf9274fc64456e5e70db9ccada9193a0aee53dd70bc86931120a816ddf214830823b3351a25920d8172839f2c856fd5e7f4f4d47168b05dd97b264abc7c46a8b75c4ea0ca37f093980e807d617fad3f38799880825b07e1bb05d35320dd362dbc038223fdd2a3d1d0eeb2aeeb3ff7e38b3b19cf8a90e5443410dc759208549be4fc2ab312fbbc2ebd49808d032036c6f5d626996698e210c06a2c9104dc7e9741d4be91a3cd87884baf3533d1c12b57d56074b81947147538ba2920da4afa275dd3192e615d8925052b2013cdccee274104ac3094bc59bdd5799946c2bbd7e6ba18decf6c7938a0e999fed6136c533b31a9f82173debfe153515c189fd731d6b522bd6598877e62335000340d127e31707bf2fe8ef53d8706fa73557355152727691fc60450054fc59278560f51a0641faeba54b062c5e990349c5891c32b54cbed2bf3a7bc3d1c1adf0bdb6feef595c08b5f4b7f89292a48e4c94a2a45cd4f6fcbf1841b04c336989b09546c1ca043ddf2c422881fe24bbe7613aabbc7fdaa6ea7ca9503c7d8fc0bd30c12c0947ab8f0fa7ecc7cdf2feac947a7eb862d4d6a8e12019b3acf7e6c65ce88a05dcbde6b9e6d23de8529f54335c6e4e7abfe15a0d54e1999343b7bc44c63a227f5bf74eac7907a4b98c2ce0bc4da33cbfd887933213a313574f275c8d0960356c2d78a23702f793f0c2ca94bf4362a174a0f3eea8af5f05921f9dd359765a79b765d5d85ca90c1ec282a8ab148d086d89605b6ee637e6ef2de0feeaa4ba89e5adf9867ee9d1cb32025f298140b5b62589acf137f56813c54a49f56d9a59efa2c78a3d21640afe30451197263fde5b78a298928297bfd7f43028e9c36189827a312ea7881f08b5028ac8baca006734675dfb27f4170c25a77ff58e644089f7a3aa38d1725a5559a623d559a2a4b0ac9ace21f250806e4a340c03bcd83379746575cec788339c036b24450a96e06258c2af69e55e984890d52d080d560c200bf2eccd2ac780154ca7a997419cda54e7c7e06e7a5205c6333e6da1abc6835f9617622e68c485d7c22068204c4977083a7b70621bed4b0d893eb198b9b30e0cc71909ce578edf2cffde6663372301749f2fea1c9c44a4f0732d68368cdfd1102b9860e80e948703c3d9a071497956d4a37c10abcaa104ad7d5e49b380d6b2b212525cf08a27a06c9a4925c787c3a4a31cb964ac0ddb3dfe150f6e515e9d5c95513ee297105cfacac6a61388e30abcaf9830465cb967959dd55c53855839eb702a6a9c9882ae4ac13095305ba0744965463e8b81d37c6191946082bf2b05a48343d2a607b88b10d551af7816eac366c6741975153bfab1f3a822029601e290d3705d9e0a7febdd095a9aa2e8dc4d14c93a58dc7d3ae76d449b25b382cb50ccbc5d4ad15f9c9674e8c39847f8bb6b690c149439c8eb44b3c1dc7aca7c6b60af67bdbd65aa6d5ecdffc26546ff71ea03daee8f72dc31edca9699c96216a79bccee927d83a3f60a956e7afb361fe24283146aa826f96ded2c3959eaa3c3359c371481e4766d59533f8be6d94bc2184cce06f7a21ac2619acb4e2098ba0c4dc0250e9f864e51b2b84ec7feaa3070259e8c6503197b36b724fee51617cf4e49fa08264a93ae8a440403c325b21df8787fc020f52f4b5c5901925dc4b4ad6b16369f717ebd858f3d54a5f29a63df845010e9387094b9980604becc72ff620403502bfac5f51edc0af4c3a3abb9e9dae04639485d3c957f10bf46a54953463e5ad4f9dbd3def9aa4560373f873ad52e717a7560c68fd69faebad29c549594925305b84b717bb73f8bef2f0f72369af14b29929b521319028980912ecfe183fdaa0b141ac66b77ef3a36e8db9c82372646b772d36cb45b4babbe0107884cc17f0ebfa4d6b08ebb1bc775d5dcf79405ff189bce8b98ffee0bcdf292d15d25c7bc9094c51002a29f32aba3b99b39ec3d5c6595e5cf1698248ce4df00e184fd9a1f475545be412720d044b89c830fb70280fcf84cfe9429c9bcbd1c8f35a465d55c761588f45dc4ea23ac516a2490e8f10dfb7a9c16ac4da8bf67d97a9f3c5ee9911703eecc428e37624d69ee55dd2a906ed80e0adcb6116cb3af762586ef932e3c9d6d9204ba350e5fd5e36d42208ef404f41bd439515430ff9043e1f90c4441bd9c7a5a3c7079465cf5f0e07a6f58beb0add7d804587ac49b3ac6692c8860763a30be55ba742955d8ddaaf15d89f53e97eecd6d860fcea6d5572dd7c9b68362573b9f1e50709fbe458858cbfa1ae839c0b2b964aaa4d8cb010dbe2e5e9e8a1b81e17cca46c028b4959d11301423caef584a7e29bcca851bfdc03969335a21009b70a46b8fb71fb7aabf36b747c33182b4f4a6e178a9d75ed0204bcadfb0235d02aa8ffbce06a170757468877c0a295dd31d10e1615f42d704cba5759771f268b6d4d68646b58632f34b649ec33e3b30c85a5374ec2006241dbecbc634c3d350d482e9af1b6320959c727a32491f32ac6496d5a949d3d52c7cc49987b24d4db249b2d89ecf456931bce38218a2e817fcfde4f49a5a005e7f116cdfedbb899d908d1732f6814d0df154a727823cf4e428fddadbfb289ee219a3e00c7e8ddae406a7254a7f78b7f6fe7f74014d8a51f8f14a339d208db52c48ad405e8b291a72afa5cf33ece97418194e08837937ceb8cb968b37215763cc6aa1838437d1bb20f22aaaebcb3218f6612c6cb92ea5d09bb035884b3e492768e7cb175f07b7b5df858182ebbb9886a31a11f5a191cc68774184faf41c2f4cc45d8c1b7dfc59ae87e9be0661b49b3310a0da6165aac94c86542e2dd77936cbb4759141e936e22a5a999b2f0cdda77f984dcf46899e1800e5ce944f78dd7c58e1fd50488553989e7b9c0fbd6cda7ca39d54ecae4ddbfa42192c88cac5e3787de24c59f55f3b7fd19dd3f57242a2e911b70532782e8449a61eb164b46d761cfd44196d387d9625bec1ba3bf2947297ceb401a19d5f21af52fa8a0e6e2c2d96116b65e43446d1b211497348e86ead3597bd3ef954e3bd1674f565f0fd2fdb97438ec1fdb20f8710e8b5c1e17c694b453b2aa4563559b43551568a0651776621b0aa56f343fedb3eb827c4c6e2927b0e8ffb7c3732396e492a6161e5d7a2a50b94b5e0e5cb085d3a35aec1df644dcce168516ef241d438cabb37b0201d09fa9f3f91cff043549a9b4a42570bb429ce91ed82f18decb274aba4443f0da032b240542642e2ed9692b0faa1124fcd2d7dea91cf961eca4ce47a046e3df7810416be0a29eff3c7866e396e3dcdaa67e97c9f50405f007847f30ae181e02f6b21fb2774a63feee17e91f542c475261cd4e6eca2456e2ffaadc3eec1d44495ccbbed0505de821bacc71f6136a015d64e54d436aa479af52c8b93c955b8f70e65544c98a586de007a28e2ea985edc3aff1f42f08eee4fa6cfdc6c428dfc3c57400292fe02327d6f7f4f8bc5b5724334784cc08ab482c4e0c6e8ea365baa520e2859b39dfeb216193bdb5eb55120e0f1c8b39710e9f4dabbf06c825f8b8b775b9c522bcf6664479e5db7a4491affd1edf2789294dcf7caaa1b4e89fb30bfff0b4356de22598edf96528c6d3fbe92cab8e3b4f68a681a6b94b909910a757318b8054eab86c851afa389d64d8d0ea1ba772e63f1e6b44d470597fc1f9b848385587ff748fa1a04a3167463b2831d45b0d679dde1e0060fe514c737a8dc18c135e193f88d09b865b7309fb9bc2131a9195e62bcce55a2a72afd24629b15ef420fa71b3492d4cdd2d31d083771d389d90acd6d732700e7b787be69d8f4b294423049e38ae521bdd0ae6748e26a5102d90218827309569309abd2b9dc999646ecab9419461afcfbca8b28b3fc2be3f59619934a897167673170e6a8a6ba30817218134d558f8790686d82fc857a7be92935cb3bae3f4dfd0ff5244d6ae922390aa2ac285ff44a3039f27110858b04298a37f306b2985cd1bd8943a872665eeaa4607caeca538b4095b702b29290ec912e0619afa46a83d24138150280eb6cf6f6c91e9fbfca33d0b27d33f36063232eb045618f039a2d5e13a60f8c0f3832de74689541c318189e5442bb785f21a170d95e3ef6a38284d245b0494b1073cdd00098a397f1df17d186d6f7e089f6ff5325d96208900ab83a5750e6c36e691b4d0014815cab9942fe1f0e8237bbe52432c4241cda156460fdaba0f31ae04d80d7ca8896737b7d4d019db305065f83ae20c8f45112801ed80a294a4f5eb55b98711447b1a80c5b7c25fbb21c9586c525435995a4ea3212f5d7f878bc448d79457e43c1d36c061faef263b7e9a1f2b18ecf61b6992c52cd48880a9e157ae3d73eb348ed6c5b5bbdb330c9d44f489248324032eff478f38c14fe09ae3b2a8da1bbf21a71cf5c6466c6449bafa8edb5715a3bfd46666c5bdea3360b8aed760a77c6b694b88b1e82676549e12033d18cbb6e5c4f7d960a1f2cc99f223cac953a7343e244cea304d6108b67ca73667a0214193aa04e31eb1e639e2adf59c393d1173048107423998b27a54d68b367f1c46f63fbf4356f25fd5daa2edb2b4ef3ca7fe77a6f14553ca0ac4a320b010f778789103081278d598f6f60bc1f522054207175893f42f1b9cce1393f1d2e222121aa1f42b6405da0e61fd409281726dd487a84892193712a8c2dce9c37802488ac51616a08ebc478f0b74534d03c8e8c3620e283f8aca463211553e9be82755c1de9ed92ccd015c27cee83fe0a0ed1cbf0c275cbc89a6eb7cd14c2064653f9607415046d4256f28705e95bd4a74176c9d59355abaedaf35842db92e364cb7a22123a09a3d33caf2c17993baf8a88e7fb81e67a2574cd08ade7a28c79091da0fc6b078c79920d5956b8f14c06d481f87718082e249cc9360a22b1957a1b22f0e91d23acf301e859c230b690f3aea5be5120234e6b439e4666f6c9bbdc00d2f7eb15304880549e24c1dc460728423665ed2c05f17f6e58ffafe40d1ffb87309be85f9b2150b2ed59920791fd3532abb8ac146eca25992dbf56056ece2da1c45f72941e58b51463b389d10ea367c4ae9fee84a83ba25e711e7e67c23211adc96b3d3151332e8b9a6fee2fcaa99f1a900b371c4f0aa4a0b6e47d3b069f16693b753afde5dae834310f8d6d7859958de1b2c1ec756cf345ed1fd94b90e9faa8b12f2391ec7737c098c7768c5ef5de52cabc6dc083d641fc412e0eede30079a70951f201afd23c83ac5effc3b8631482d1b9b916c0d7c255ddbe41dd0657f50dcf057651197d9481487de4881db3cc39dec8bb02ca41227e43fc809977a76a9e26d962e7ea9e3c27d178b75aae84f23e7f78048f07f547c6d14cf505a7947f369eefd9dc47a96c03f4a3d4d601b27cb1b90b8a609516367749d1ac8de395c008e2db4c7fbc67462059cecdf46c5eb311b880a6d1b129030bff75f0dc2a296e8f9e01e8a350c637a4b01f685bf458821d47657a5a3be11c1f75a307d3a4eb98a7d496447d0592364be4566efa0dcb7dff00825e4ad51d89dda4377cceb5a096a1deb5d5dac553f6917a84611caae29561df7bb2a320e36f9bc56535be18f8b397fd64200958baa75537d81c7759f1b65e61d1f392e4d1971c5191d70285f24e852a64e3992199dd0dd1d1fa739d3f9a96cadc3e7d0dd12c1160b51613f1886866ace3fc7b01a10de9fc333b8eaae65f1b5f02efa58afd05b1562b1da2c379822442087a582a0ad61b4cc718ebee033dbc961aa113b26cb8e435b821416ac8c9a4c3f5bf201c2838a172020a75640f8964009dbea5dab9537a038cdc3009dbd832bc600f4c72bbcc4e0666f91e4f5608d01eb86c9d38fb383e988292e507d5136438a1d1ced47b5d62a50c52d3940862e50b964f1f01e191c7775b0b29fdabec2017c358cb5b63b7e623cc22622e0aa158e168062b65af5f35189b4a1d7f8ff4b1f1d4ba411808fb80ae99dd849334f2c0c5d0ab620115853f9d4949a582c260113f64d7d8b5aa477417cf3c81f47010b5e087a610cae395cf07b8c4b607437defb70a0d987db5c0677cc5ea185fc064b5a5b3ce3ab8e3a41eeeee6321cfc019a086e1420a2188921de83cc7c2db6c1a3edd821ddfbe65552fc14a967e7d3d6c3400c78c8dd2b8657b36eb97188f55e68dab4a40a27a9ddd936ba896fdb3d88b1358bc6f5f76b24514fd0a317403abf0974808b9d5b591048946c7f26344c6997d7d0722c41a0323daff56448bbaf9d953a0687f5568294af6840dfed42ca2b36a33cd41d1124b4394cfd3df399b53074512b655834e86a79a6f2e703c44ac15ca264c2a92594ad4e47de0df3a6b5b591a1d991cda9448f32357cd151deef921abecf14b70221a686ef8b9a729b2819c2aeb0cd6bec381b506f0a3940c696c95b20fb2c841a6426bf64b00b02fa29de6a8b56125826b8abef8ed77055ca3910d8cae237c4304330296bb41444ae8687850abb0cc5804a84a1a26ff34db9e573d91861d65db4b3660ece674538a8c1eaaf7d37cb275c18172e99f17ed86aa371f2aae5ab1bdb7b520ada1464665e0f0569ef782cd9b08db748450992bc37f48d8e974f1f259fed399bcf04661c22b442ff38767a93c699f036da941b9775af473662e43f60f795036181507938831101b247c74550d7dece0ba2ea63f592318f1bc0391bb10258283dc43701e2fac2b14fba1cea9192c34ace57b6bb3f57223cd76714e207fda2da8d3230d2116a1ba383d56d40c2fb59ea825365c2e5dbbf89d6864a5b4727b2927f247c8e980efde8e0ee3e0e8bbeb9e86cf2cee5a12c5bc5619278f438f5840e68590f637a1f125e276fac4e4b4f9a58442eae8552820a9f7f0f9ec6f52d4aaaae4edf3a0049abf8253728e6035ca65205a4fdbc9c0928a6afd8324411dc6baf293d54aade3ee6d4398dcc819f6e029ec823e272e01400ba931e0448b9ceec9265872703a278f3d0e356863255ab7df0f378c57623d7d948ec17ab130110da68872d880d3c843598dca69d342ba3ec66e540d67e5a711dbf5cef8aae166266f0f6343ed347a3522af07f4babd33df7b1511f85f3a13136a67d0e0d4933fbafecf0ae61cc3f9352a1869dd367ad24eb73e52462394031c3f8f0f46d2c5a6d0c2fe373609e6ff8462fadef90191568c982e2c1a764b65ae3c7b5ddfd57e9d102e9e2bd396b8343a7a68a286d1ee17b5497af1bf1b5889fcaac04396f9994a7d0a5a5ac09f3d578f2acebb4f513005c3470f66d6d596e61394021ea8bc154c1fdb2f9840d5d03bb569bffe8342d5b0d16db96fbd314493904f7696cb38bddc1ccd6d589b0d0cfd9894ae637cd79b3b82fd8bf6a8ed919a80fb346945ff69f98ac4c9d1d9c3ae92db1ab648bd71cba999d5126e1ec98f1244da2b46e35864beb04025e8a63e7a145a0e4f45276411840203c7809c298aca46f63f1dff65f2d7f31818939e1f68ad3f1a09f1e80a462306e76436258d91af5f4e439fe50bef996c1caf07539c360b2687224bb9656075c6072f27e2dec4f1278dbf91748b2795954a3f9cb1247c422e1a0334c4a0356d7ec8e6f84e567f7a1e1d6a1c76d77b8a37120d7a8f46de2165395ab22540cb0219a6a4a3a5176b570d0595022e79d347f50e2c444c245735ae88bf53adaf0e0005f09122a903e6ec4c4bffb80d155d9423b5636352de9a77586b995e4daeddadfd1bce9e1c97bf9da7240973d651b9996ad43cfff1f0ba1bb3f7ba8bbce19d1798e8e54a0e5acad32e321b4423d428f5678a13bfde22e67f2060e69303e91460b43f9b9d0ec32340a6c5149e6976f9c98696780c02abd8b3cc7f7857290fcd63fb9860ea749702bb5e53b76a208bc9244255df359a5fd70c9a5fc4016667198c00587bfd5bd5be8c3aba6209c7aba9b4ff3b90a857134449a22b794e7bf2a4bdd8696dfeaa5c55c23eaa0d43bc10fb651d13228e4576ea17703711c8c93266d8cb83ab276877e02343baf808cb12cfa7c0f6317d58db7b243af667758cd70b8421fd93dac77de61fbbdf12409b8ffec3d8da64b715338dedae6745fe2fc8b41b1c4fb95a6bcdc3853f178524373b639e488f14deb5a9e162709142e69de8a608a3a146b4bb85c383afd9e50e98ea113043556aac329e06fe2f1a3944399444f2cdc5b098abbeb5d45606f8be4045718a608a8065ddcd3c548c7297c00af0349e51c62aea082467e76bf5daf2cf314651246b1794287bb5dc48db2db0b9d3a1af1c81fd59667347d38c7be02afc3e8845f86a2e8cfdef76db3f352834ae3964004dd0b871566d1ce29af6f1398149461a5f61c2847088f273c3435458631e0c6adea659770f6cb1dc39b02ec7ab66953f2141c479592a06486aec855131b2e76e440c33a62ec786862c62f326ac3c612916395f928d63b6b8c62d1c14665d24868b4a30c236fd820a7c5a6d43f8b69481eb317d087eba2fdb4171ba4ccdddc4189eb8db528410ceea0117b1936163c07","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
