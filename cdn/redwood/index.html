<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad9917b679ba084e6bd08e36a1da39ebe9ac69227fd0f301e155616c1d9b8d01d97e92e0fab8716ff3fba3580b83844f6a961485ee04fcd1bc03b9036e0156a5977985905c9509c9dd3bf8b4d07eb30e6b721265c64e94d9934b2c6385c620a6fa95184fe8fe23ef1907fc2276dba17b1e93a3c4d5acfe8606d24f4088ed7e28a3e514d120c84d3c858909319d2422e912ff8ba7d41f65b593a011cc4f4cf5a8690ca2cc89219160792d2aaa0759fee3432119b8ea00ecdd17abf0841c3255bf5881f5fc6df56d2ba6f3c5bd4cd82dd02e35a52865a60868e21fbc1c54d0c03d2fe2d97189da185a10ab90000f89f7ff1d99d6491248ebcdb961263ed3a17de352371879ca973cbfee8fd246f4df7cc6bd7ed2724cc436c310fc3692b32bf5475f82ab2c282dbbdc5a595ff7d36f6e2449beb6792d3b27317c1871824aae7ea9c9fe67ca4bef3fa9b061ce7b800aeb450552216ee9cadbc1ef795330b3339e43b90d8dd15a63ea950845f6695423ee2b48955da7fd665917bcd7f952af8140be70d74bd15a95a964ad6aa8626068d5d5362a31cafa8afa7f857827bf4393579fc910622c8e4d0f28f18a065f79632536669d6e3c4a5fba53e3f5b8ddda9e16be675c3749d7d75a01ce34292ffbec7a39ffcbaa6fffe0df0bd63413504013492d155511d68b8b116fe965aafcc738975d4cccca1f603f4d95602199191e58c80ee56b7dde64ec68922c008f59ac1889479a7c904facc2f0c2c3465d6399ee9ce33cc94adc8853935b7a54294e5f2434ec1f0da054be4cbbf5b80c14e29d686f8d3f1d049e4b758e027cd94a6e44ef422594125769a8debb6533cf38506aba57a908f23c482a1726c17f344d8fe13e797d47b018f3a23aad84d77b35080ac4c1267df1f36e06c0e8bf8ec0711bd0f32e2e0f14d4e79244b8609793276c60184d29ca62d4bb023a6901a5db010f764ac2363be02257e8a7af07b730ef9e79aa661c6fd2f64b46a413b937c2475b69b4c19a35817296edeae26191afee12cecfcca523078f4e997e4d2cf0a11171580c6dc14533e277656cc0f402a6bff898c25e6990f6eebe55e9d3a8e459eae123716bd82ea0d14a6f14d1b88033c75741aaf045f406b806223d24d69c8c552168b7dcfa9019c6617e8be0f6147ce3d2a6f1d0ea137fd5f7704a5670b560a1b5455d9a5f264db3f4dfa41a328afe9de8f4e9b038a7dacfc9e9312d37c6d806501b6e59a52d254f5b65463813ce2e26d4a6a4a879fbdc4537c9c067c11aad18e4c50825808fd8783456c6de8d1e7c397508fcdc5ef2c77254263a429cfbf3b6044cd1365c6ab64ceb517dbcafc1ac2d15b8dff93e4ccba79c9d106fdd608bbf3f19fcf2ba4bbd164c7d86e825e60bca20d5701f978982c8ebb9353beca1119b79c9233f4de10386c97c37072371c1a1899694c255f80d4616c25b91af13e4302fc0df5dd177acf1ec368e1b0a660ab7b6ccf526f2b2da34ec30f48c78afa00c7e6b5b04132e5a044e6b6822a55c3be5cdcba0e13b951d864feeb0acb114de425e2c20701a53ab63692995c5e9193ffe9f042060a3c600cb0a1d0f6c57528e0a6f692dce53a54ddc35f40ad466d6e8f9b2c8a31f339a38328ca6853287933ffeb40d0b2a71bae193928cc4d795ccd184e35cd3ed3fb829d0cd841124cb05a017500ab8d90641b680db8cfbc5d343d9cb7b95f2f7152e7a794f3fd84987ad179c75cb51e705eae981e7df4815294fb27f72a8b53f6b57a5765a8b267ead785db266ab28ceb6d8a3a509cdf3cfbe6ff1d21a020b2602cee8a87f5c081814581ccdcf035d6abbc87dd207d91e35b3780c85322e40f5bb8256f5b1f5d79005697172e089a32609230282f4c57d56e05e44594aeb9133b93f5412890974ef36e2edb933853a2b33e3c84c93e0181c1e2770bbd7b109449fd18616e37a78c7a987225a478ca456765c1552950661be1c049338413afc35741ef98f84a39408b4e6f7cf4cdfc1a95d4f0a29d23b64d2511a4b0f2d08faee35fc579554bfe02361c3cf8e0c1bc4bda390b10383d94ecc4ea2c91f916870ec6594e9b00228b7d7420542d1cbc1776f8e4f61a428657470d513b4ba85d6658b74bfc9f1f1d52fa7e9262a05d33d3260643ab2a7632ca7738cbb4c02e288d81f21b19d819bee5f3c2a7b1186ccf2db007c5d3131dbd5906b917c04cedd0f51477cae17d480d3355ae28b0916c9831eb3d5757d210c24cfea20560d864300b9cebc53b74c831e354013afe71be030a994032a2d5e11e56b1b13dd127bbf85235e0c73ee0f70037b88ed0c8ddfb8b6c3c9e5d453586ef3f3c04960a485e7a27b36c3297e5dd1ec6806610faa446f7f17026d8caf39c0d889b86e68dce54501e567bd596a5bb79bf1826319db41a601f450e8f4c66e58027c46779fa16c55ff813e2fc6f450b12fa54692ad3927bcf6f92ea7e8f4a2256df458eb9a5890e742e3b094c92108a0dc9794688d74ddb3eb8287bff1d2422c3f88d0310d506f4be2f9039a33a5682c87d8953db8167bc76958f61a5443303d3a6afe04c490ae8232cf46947b7ef614c6915356ecf33ff110a0cf1065a5ed7d763e59fd68ff47cf0f6e6a27d5373d95e4f8f61b384cc895501b258d8a4c90466423c1d3d85f452c9e4795884423423f591761fe82f38f020f2f2ac5ca9ac9289d81f12c4993c0ff40c3db3ba11da4c002a64497064201a5a5d39332531496e7559a9895190662db612b216d2170ff06979a255f51105be2e7280e76b94758a880a0d4a1d4a5e0001a6d06bf456ccff3d3afc52666aac491e68bf3779a82758573e02386c074a204dce51d1390b940c80cea865deb7a257017d92eb8bbd3194e51d9e8a1dddfa7f0036657cc4a1b5ff5dc243638d03bfc7e539e13a0600a3baeb098a2a499782835cfbc28b87b0c23c10d64eceb780a8bb4ecd1c68d742cff86e5541407b01b429977f075988dc17e0b188d08d397e32554a954d9d9569fc2da1e2d8596b0e2eda06fa2c546af6ba3b8e3d583aec6377d649b4f695a058742d96923c4a5ea15b3dabd024a4666927bb8f965d7e2bc8ce24bd1d422fda47c0c1da0cdd899850bef82c004242d948f8d8b2d492bacdda7dff459f94c525c3a22ab522e524414ec68f64106e4744c40888686c0d795725c4af43a85cf192470c51c4d3aedcc998daaf338481801fa1d63a82160e1eac030c651a358d1f51d5257fa5606da7f5ea4a695cfd836f4281be05465b9c9d84a8bd419ca9181056308608392a0f03aca1f5f2670b946739c02b5c1c409d77efa83995d681b403c874f0cdf7a7bad9607feab1baac301a8d82ab70d2d823f0d3e66a6dbc60fe7dfbc5b7d150e496d00cb380ec3e309ba5d799782713bea3d975499b32dc801a46725721e6f75a5e8f77a7bddd74235ec106daa21dba0f824d66371de826d370609ca08fa38ab75d67823c3768d907b501c3570f85010f489f560afe42c9a8b21fa8d9c7b10022d507e972163392e97b96b00ce756d5dd100e5a9daef5c95d521164e1fcf2f414a81c820deb93917eb5e02e67324d46ae63190b72de822b0236658cd5889f48d30dea97110ebe28950bdb6646105360649ba46552001c4ccc748f762131a2f0a47b6a3ff43e1f8c75390bf44aa940f3403b0b19d87df4b63ff22bc3323cce146fb70aa64c1b72746ca2d1a54b056cc22100b4e6c4cf99699b208f60fe019f68db9da5eeb859195f17da16126ffbf35510da77f6aa41669fbf7f623891e4ee040fc4d9309a2de10b0fc10815b7f01190873363a8290da0e2d2e21a6196d7610b02737f71e2b852dad96e29f16378cdfb27c17b5cedbe5fda020675aad71fd9c5367f2733c42192764df0551976515fb98644de45acc3b27ec395c107d9717766815af08aa00d175f6e520874c353c7f1e06f6a03afb5a130052e0a6c7942ac19634af58b2c3494fac2c6c1d77e74510f463557b095c0906fa61a736428d3e14ca025a917e3340e4b685d5f49405a2d549f7270f7cafa1f9d0674de3eb75703040d83dbd3f0858845d0840d4bf4dcd9bad9f7364fbddf48a5217136fbe7a25b3fad06b173d763bc9d4b652c7bb3ee614a0b283e99620222880483396b7af8cb532f8f6762136bbdfc01eaa4401be8aa45e67cc66cb33ea098d55ee5b6bc130d1678cad07deacee19acf9b8ab478be6d4d6fda456e68c5b4334caf36673da99de1d195c45da2e670890d9c640b05368459b8cad2542623b6e2820f756c8bc52eeac29d1788bfc0c28fa01828b19a108fc58f623e992b468bbc20a4d3474aa724b74bd8aaddaaae515cdd36f3182fcd24794e76c089f57255885c8f392fcabe85f11ca0af5772ccf82003bb30289657f8ae29613846f2b6dce71537e0ca294d7d1b42e4dbc16ab4e97143b918c8ad261ba88e53db1fc49f85eae00adff5c1c55b7f0924144c0de52a0d986eeefcc8240e157a6b8aaba24f4e84d50dbceb10bed4723686e40a836dcd90a07fbc9edbb928ba23160b6ee4717fb82e2788abcc85823c5a8cf9d457dc8828c2989d5a6868f544663ff7665cac18c842f4d0e1b55e4102a978cbe865571797706c9908652203d8e3da4e57ecbf7292fdf5d2cadd94d8030a95f5e39a3542b4749812316e07b21f6265214f82b85832755b1dfe720d1f85ac1e0db2ddf7ca222a25a498ff19d9970b30236bb8fcd9a9f5416a3fce2dcff1e233988504373a4ea785f2bfc2ca55efb9b7215e39e34243dd10a9814e5f08c1adbb3850f3dd68a2412ac7a12051e73026296666be20d7a1ba63ccae4aeb56892e6b1a69b283a8cf7d380ea9b8450a36908abdca096291f9e4229150f78a4f36bcb68d2c540fd9ee6349a8b0b148310cd5292069e2eefc4795c3a4e1ba883d047ff7e7aac5b770f2dc693bf14feac385cced130990beec1ad7a0b175a8f166f5c4f6d84f50a4721698b71a00531bbb0097e0aa82024b58d497f8f5a2da459616d23868143d7c991e3f93367959a7508532af5ad30bb091d87a50af04d29fc9f2fee06cbb73ab5a598665b34385e6f1982977160a507f4552eebaf00a8a37b6c04cf0f1b0f862f9024b9cb64595cf19d7f67cdeeff4e6cf4fcd3ebfdfc06fa33f54548c3114effed1b2df6a57c7de44b3135af61515e15e0797a3e5a34f99e051ec0a94f04c854f94f3f09ef323c8f87b0384088b845da26e4f5d668a2f62ba60c50260778f685560c1b0cd6dd178ad4ba53b3bcfb67278c459a1f6f4aa7b0566a137021777f82ea349b1195a30f0fd2ec93c923f32fe7df8f3bd71958269b3727c759a9fd2f3f6410af4fb341fd5757f5fbfd4e63d1b52dd8cb486873b2df969eaf26efa801aae277354768302f3000fd950ae495833a18c340ed09e30845d81595287b014afa9f17efb9a88abfe8745ba9b7bfe89a2560318fddaca8df62d2209e24c1d1040c4c29f1777b1c6532cb1d5c5cf77a3ac39198170bf7294be0f419ad5048f0fb3a39ecad1d6ec50db4ef2da85d63adafdb9d9d34d838bbad30deee87520083c02b76d6921c09c41b4436508b82534651af93ade1a514912012c1766007ad45aac6daef404c67af6f527306010879deba6260af1494e09321a9b8005c76b2cf826dee2690c6ca1367922cdab68d921460bf9f59524c00b90aedded4257449268804483e5340065c2200c663a85b82249bd7d50e3f44b7a3c164c789ac5694374265b9b3d9a1cf10ce4f508d91b5215fde4ce5b5df7c2ddd8c597b03cf4516e32e69c4ddc52b6a5eebdc439d64ad0a08b671a854115b29b0871e798a23e1538137724d5e0f88bf6b66e4e20b8446b1b0620f320b7c108915910593b7570cc8e84d2bee723adac2d6c9d13b489bfcaba7de2fbb8cc1366032a782c571773224b7ceda1cc74f8c8741e5ddb943b5774923c4a1b0d9adf27c966428672d6ff4fced93dbbecdbd78f8b8667c25cd3050fa7bcbab8dfa24448a86f02507f2ecc581a77884f46669f45e818adebfdbec2754c9c3d5b0aeb331a73ed766e1fe4260692857bc2dd9fdf7729c6e35dd8706fa194ff35a526685fd800399635927ac65bbb2f8d3c82e4bc404a7af5e4d217de582023286293b50ec44c759c10361268c460dd0c8f29a37f56a76f1af736898146b71070847f39d4300807b8045129ec43d6ab2c43199cfdb61b9fa93e9f937325676838acc34478a5232373ffd350d6c8ed9bbfed6d90e9a6dcadca09d10698e79c94db41db3ce00cb20a109aa2dba23b51a4182725de0d076eb6d964cfa58592817b157cc34862d34140275c8b25d61d2df9cf08af68e274a92b549fe34a18bbd27293e178f352caec7d649bf7e55ae281daa96f20674262e509e89df934ab3e347a77f963d70e350dd8f97b98ff7560ab1903a114c94f84038cb1de7a708bdfd376b8a36924acad96dcb14a34ec1b78b3c88c16b81d65a24a9ab82e54ee06ae1e9d7dce9c4e8531de59d0cc55351c80ce6ccb0929c5c81874666e7e162ee4fd88b2b44a00144983707c2a6e338bf6c53386a448381b49828a381fbc9200f127d3769df7e99de53e46fbb3a7d2360cc3835efb7a47d681a59771951269e815ad71d3408f454d92a47b3d176fb9ff4732b64b300e798b44cfae57f7c3d19589d23df9d7c2118b1c90aca76f40a8d70394c3361f6f9017319da7dd8722f42ddd1859112ab699036624dfb7ec826557c60bfd328e0d12d88ae9fe5aac10014f3fb5e36b0cd8f43c606d1f555342da9346cff53b176e8f9edfb088a9c3fff1bddba20cbc7d52ad5c6e30679a34418ab3af9a42df0795ed4a60fc06cd9c7d28450b82994b6d8f7d1e231a13c5869c38be333d8e8b13ed1c1f87395b89878da9885390c9a9169e1b13f0f625f8213fefffda916beef4c3ee0fd018cab880d69567ff8407e26f89af018a6030e958849efb010531038ad12520630a9de1f2eedd0466b1855246ee6ba2bb2342738f76e15adf0a9efd83031bf82ced2c80740379326ed89daad9cb6b52e8b4b294ac56c2d87f96d7227359f5e563495c0fc797201ace0dc7e3911008acd63eac2f0dfe7f65c81b641f8e35cf6e4445db1379665705febadda64540819d71fb0d22cdf1a8a6ea983ea8c2292dc60ed8577f1659b879f594d3fd764f3439c8739a1055646808ea1f473d46298babe30ca6432a85d3dd73c24e3322acd319cc359cb64187c632227cf108d2fe0261a782980576ee5568382405dbd32da4054440cb59f63f04891146562843bd0b230d49587bc82c16afe4b7821f98bca1f46834618d5a9aa158322d131f698d82db75b395d57a7adf1f65991b392b295807e34df8f47751358f6782dd04d8db66e55271ce928360775a5d3a78d4b862c15bd0959273868dc17b28a9b1a522fdee721f180286b208be37fc7d41038f7e887f789b52c2cac49efe285452aa3f4654e4dbc486da4e413c2099d7998a0aef83b8f7fb978ba323776cd253ccb4fd16808ba439021e38da0635c3188f85aac0a1bc92907e9eb772885a459fee9fd35f78c025d1c1eb779b8b1cd40347b58448546b7fcd86ae94d5a1680ac4c12f8dc9b7a84c0fc0190d797c8fed4c622c824a6c4db8fc27d27532190650e43bd26b8c6fcb59d175901df07ec69aaadba1209663e3348d09067d6e68ca31135f3f99cdf845d475a8c3f91f7ded215a84f70ca264a599937f1e39bed0b28c063110fa818520c8c69f5635a8e2bb5611ffd08ef4a6178407a852b576ec45b1a171d56e05c021ea3b469f041a44ddffecbc97447652e5dbd23a7ce8a5f45769758e937bf3cef046fa5c67f66149cc3bed7cde58c267076fbdaf6f05e571fe07b18383160c810f6604e2f6a63fa1c43b3d9ab2e4d4a6a965e9a948cf416b42b76338a9e3b320e52c401e1653ed4f1709fedf0522ae9687a2fa065bd30c95cbdcdc967c67edfd1168bd3ff0aed7478c14cf54a2e0f4915e7ad6b08ec100ec29f6485640b682666abb207a34bcdad068f8277c9562ae6575f36d4d668d70a577801f876e005f559d17de36e8f20e9329f8e53c1a7144bc66f71469d41121afb0956564e048c94c48c7b3002ec34e17a1b7f2660f99f5e108208331eea2b507d1e862452d43106ada8747af3a85b5fabb1b573680a6fc2e916f6c50b243ca7e1e8212b0fdece5e338a856bb6cbb33a5852e33e2414eb33bd171043eaf56fdc786b8ecbdc5b7a5d4487d91d61e3a0c3f9c19c2ef6385665fffd33a2bbf6b4ae3fddb18e7785a561837f7a6f621d8664e890115765e262c06684ba07c05fc15ad1ec956f5a54a0b187f268124ae90bfad6161016f0b427528f015b42262b1efbffb7e504028ced0cc0f7145f095df6b15e84a66bc46c0a2e934739d44cdf33f6ec010bd025a1b30dbfd880613f1e4c7b66f6df62286876115e1ff28881935c7c11b07c3ccbd895c9b7c324822550d1d5cb37af7c0b40507c6adfc8a0aeded2e0877fdcc028ccad6630435c9e43e8823a165eaf16c4a9f74d24ec91a9d84f87f1a22ec6bbd4cb2ab01053118c797ade043ae068d5f034b50789a7d0ae70942b39f2a2e84fbeee6b0da5581668303dca291f96f1c7134f1ea02ead30eb993e24566a9a8308201192a1c97bbac80431f54e199ce3d7b7626ecda70d0d24aaa0910dfc8f68f398fb43b7dd1cbb4d15a1c4975bfa4e58c268e2b3a45b909f0c15cd4f927ada906b8e5e8ee20a2117253328f13fbda3b6c01752165d46b099b410a13a9f68dc83246aa10425c272b555b6496dd7cf19b17fccbe671d8fe10471cde443cf194ba728f656a0e63850e162fab35ab6dad4aa42388c80f33ac163e553ec063d0d871473e5c59f3a597146c9c114af7c9965272de45bd7614b87c101cd9cad6d6ac6e876d13b787c533a0baa10d9c2b73dd97eee4c87614332fcd85e57ec3d3822a242688af43ac37f39ae1ff76403e011b3bf1e10cf80f872da93fbdc1b7f181027c03d8d539a1f1cb2edaf930ea99a4619de693a803aa9d20a616fa3026a68fb69b9f845cb23e0ad8fdbb5ea6094dc3e9c2cb932d0553a6a8c65da3da29f15f0be82cb6f4611b009ab54d8299a2f469e7bc56f3b04263ed0f534a0c1e57406f4ae0b1ba193c0c9d56daef6ea133ed4d58c0eb90c15eee6adabca89205d9974eafbe34857dfd7c3a700ce10bdb5e88aeaef84a9bae8f455de008acf50e6abb81453bd21b152e5853c16bb27763002121c4859df02240fb543d8dc07641b1e9c2d71df2f9a53527a3bd7dfb10b317382d32743ddf464a97db0a27488bf61680c7412ba03bd3ff20badf4fe31c172a4b8d259015e8bf2894b5c66f8cc720421a7ac60876db0e6d5652eb25e4391d66e724a9a27fd91ff8cd91344caec0411dbccaea3b1b2c0a5e1cf14fc152a3f16cb8ac7530296e8de7b2feb77c41e3fae19360d942a7c701af68afb4215cfa27251b6ffdb10b7e20220af9ba035f2943cf1db3e31ed3cd7518b06fc093b169332cad1fe8cc681685d7e5d1527cd9c4aaa95251d68659b47a5c7a730ec58e5c0b3ede6d9c53cf0bccdb429bd20402de94e0be4f9e9fb9f1915dcf862419a0018d3928b306a6a56ad0bd21d123450fb4ad14e1a1fba91cae7a14b08f24b416299cf3e4ac01500453a5160ff45a3ee4100d1d5fea116915e05da4a9b61243ae17baa56f53636052e5f84b966ccae5fffe279b28850d7341b2ad79087fd009d0462d5459079ab7d1e2693ad9244e523a2722f027cc897fbde6c7e8883cca04ceb16e10906e56a318c762279a838f687e4c1a81fceba455867ef46f18ccaabe7e8dfa0518da90717c6cccce831dbbe536e203dd8fc88a5ac5f848fc12e22204ce889594d47e6c92c5c49fa85550ba0f37b56028eff9b52aac6d1fa0a47be7786c3f5ed6de512a6ace73f78978575e9038e0af35fc146ddff647c3be7cc92757678aa1f6f466701baa1e20c417925bdc4e13c14b99da569fff03df23ffaec5f9a26245274b577de0d503fbe7112e542a4939eb4877336fe80f129f099347ca41cedb3d4d7792de4ea02819b8edca3c83d412545fd079d0ddeac5d83081a2d84171b4f42925e9130690f69103793aa4e755bb88133229e5c54b944557e1bbce2e61d83efb23c5e7f6eb2a23feb9590cf3e878f6216c9ecb5508ad5578951d5068dc971d64db1f688e0a32fc0eeab217e2e2c47c1ed1cc8d88554e2c5f6a948a191d94f8a885d61c19d4e1cd7dd6d28f0ecb0a7496250a2963c2eae3b9ef9e53f9608a83a4d65074da1a9ab2028c1b9c4110431d1bac3c8a6dccd9dd0f64909ce35dd9b60af167a226506d221aeabb77862610ddb4f4575df26cb5de691afaf2c18a27c3f28e718b0307f1e2846b7a4bea3a496c051c3ffd487ff5c766a8ad3409619687d399777bb36a0e2ed6d1eb38bf076c3f64a3614c5169ef968d838bd3ccdeddec8419e499dbca255101efc42235bf69ec03d0b082fd6455e5337aefee1a2039c9bfc78967bff4a1dde0f84f568cb8c6d3bef4d55e1a301be737d4a008c1eb6721f5b726bb64d3091ee8de00c53749a40459733b529bafdbee769ff84550a11ada65edd29a1444dc2d781ad68504b024f70a85082babb43075d8be3af1793fbee19739f6161d623146735357b27f2c16ed108888b12a88f2149d117b52e9e8bd1ed1e3d17d0f2a42e9b2ab27c391150446904b77a1ef697bb6b9ed127bb07889738632dd46c78e5213c2004ba997548d352cf1f1120f4d7c3664de8379418549425064fb97dc3a12a04634b156718aa435fd586236a085ae3f8f00f5a11be7eeb5e2a165be4b1159a83e603162d2bfd1e8d2c03a61aa1b7c8b2d266c914570bbe724bc30cac6d192ca5ab400d1ccd1365279d9163cc2d151562bcb7ee8b7a27e5742f242f0af444e06e66b6dcad8ccdf2ced4f4a7975f6621cd1ae3a031cfc4282a009077768dda0f653912de1360e580ac3ec7a7e533a7ae229912e7ea7e6302da62d2e17b0dbc5cf9c19b8d6b6143ec54c22469f86bd904ac8baf615595a577862ce29d243038de11c57b2068b54491536b60456b9cc3192f0ea15a71d9b523253e0bcbd459e79cc4fff458c70004ce5149e49d241cd245d289551179abf47534e0957de3f8809d6495485bc66a9f2761c51a5dc8c89e6c0ed8a26f5c3403649622e5caffe22dc90c5f8635ca46a78d0696fbdd8ca626fa190f88db37cb4b2cb88e027ebb5a539e06f763f0cacd7b57d7da65344ae865167709e1a76f5dc84807b7b82d1bbb50dc6df8d56b572f69cfc1568a3394a6a8370f6042fcb0f213fc49b904c0bb640b18cdc50d72cdd83281c81ff2c002f18491d3469dd90b1242e3e67b21a1e76fc86db5bd3f6cbbb5e4c1539bd3295cd26de00b6f21ae185f89376d35f1f61e7ebe2a456cd32662179269149171abaafd7b0775bcff8675e4b7241e8d1bcc5c8f86742c75854307835966b2d92d7c1bfa5ccbbfd77186bc40fa349a11e1404a3c546607c11cf66e2832b8ba97799c66d73cc73b6ce9eb3cc02070068bf852d4a327b8bf5c586b46abd6086cbf590334a66da9d69c2828a97123e1628a4e735c9740adb489f21f90866200c981f2eb6947a909ba24b764d88ee7416f6277868597f9166d9d13b31fa936bd0fa2e0308e5afe9d9557ea4fb37669d0ca8f6093f2d08aa374de0e78ac84f6ec03101265b831be4b4aad5cf5a1fe5b7692d73a6568a3a35577736a6b8869e0414f23d12f150f34b34ea91d3fc9325f37210256ae8057511bfb3c75c5aaa5fb5db85c311ea538f517a871826185c96ce28da56ae072dc045126125fbdbd7d7df83124a69e334a39ff757bca522b98483618e2f26c9a68c45febf7befe1406286c3acba58fafa67b8aa69e35a36c84de334c1984b513db4fb91e30431ba9a74def8bc115c0a84851959c8af37942f1603219c1ddbdbd04718c300df0af209773ee71b5873da3e33e3dbd3e7ccbb716f950d18d97d308e1551f8ad5bd7086e2daba850bf958348c2a2ae843bc1bd681ee07564ad35bf48ad2e5deb16ccadc4f33e39b34a60fcd738beaa854e54a05994cd6b1265c8a0c9c3745075fe96a341de655004f56ac2eab5469e83e998c631fc2799b1b659c48ac02b6bb5232f7d598e1444ee9bb07e9deb236e70136c56bd9bffbd581f57ec1c4ed1938c9f3ccac140ea040260e3f522e650798e78f7c4b644786c56a9fe4a588fcc6e1745d80be4270b292dcead980c0b0decc4bfc751c31fe61d0499c7ddeb3a825d003fde6f5a520b740d3464f478d5919a321955706251b7218dafd27f7390a3c93c5e2c71ad4fa0492e640e05b25f4b9a72cbdee7ff642e780b962129cbb030637b5d921e72918512e2f249b9afe5be7263a23ebf0e1dca14681f5ee544c20faf594eb3ee154e9acdff970a06c765f5352133789c028500067e3f12b42586ff01d76ffca214798a2031b6900e3807850558e12a60c9b729f0ed3fb20f88644c6c2efb6c59c519f05c5c88a2e7d8ac4d6d7225741c73742dcc509a3d329a76c595017a26a9d1bc683476ffb1ec8f24bf23891d476d8c8f44117823b6214170494ad685fc16273b4464885c7edd469f019236ef222cb9542359a85e750b794fbad09ea272d17e8cf5b52494eb3c8931c6b587d99240a966a43d6754dd932688afbdc96c26b0c25c493202dd345763cdd805c28a237871e83ac90a6e1961760fc8dfa1fb8fdbc2189d29a517cdee2041d78689bb5912dc524a789c08b1fd78d39d50b48ad22249996c53db7fe4ee8fd7354a4722b9ed772010aecca242e7bd622412b2c50beda95312f09ea36fab0a81467e2ac9ffae2e2bc2dd2eb4d7de81fb2a3c9c0c17b418975348bce69ebb6e2239f1b70714236fdd0d12b6467258df3c60c6fab82f4a5485bf9c2daae1ed47c8d7b2d676b1892e9b6c9e12d06825e04cd58f507abf2bf30c21df70b224bb76571c2ce2fe0a4326b494aa08ae7e1e3be6e08abbaa0cd3524278da99bf2aa8248eb377030bccfb5feb43b33371a206c5d6e02fe07abd663130daebebe7fdbf35bb9a502cfe9ff6b671d9dd4a980be44241223213960b0d6b7dfa8e43a9c682f7e5e81a7d6cdc354fbdbe4a96609646a83a2d0dfd801dc500804777b1248df2f86844e101ea70b2bd4d8491ae9f62460002916dc2eb3676e1103d79e493de1c52b00ccdd3965caf3a25bd0c4ea1ec46dd71658b8a0d8150fe347d0d80a7641bae00ea6280d0501606713535dd456738969d669ea84f24e12cd307f321cb14153dd75d56ff55648d6bace987e756a8802a1873bbfc699d469b8332934bc3ef3fd83bd97543552d2fa9ab6a8697dfe4229fddd44e4bafd9c45f69ad7ec2ffde937dadfdc6e7664089c742c97faeba71d6fc62569a2c8c414fef31f99cf57a4d5af8d2d692bc3d221e74e26c0ffebd5ae6d59e9dbd60e7340b9590ff1bff006464d686612c1b06e03feed56b748c8b9fa23c1ae4ba72622a8375f4530cf54bf57a092676e28adaedaec7df244c540eba41db389558ebdf0ea03e03d275cad4a3ffb2d4fd3efd40771124c668484d14a8a50e1c39b546bcc99775a7bae7496e2f0604179ed281b07af3d1e6f4e976d088f3a338a14f03ebbffc0b39171c209b963cfc4f30e5dd0946e744fc77d401a59e6d23d94e4d980ba3050a2f95521a3ef45fb18e087ea51c774ad56f74bd8c17369badb90b424cf095d1eff1fdc2fc29cd1ad1fa9e915943e93e4100ab74c76ebe7b597c9f774d6ae484520bb08cbee7c1368e1bb1c0f63f55970d7e364fb8c84a8a3a6738eeb9a1f763504457c64fac0172b89d8a30fb46f0666df76157672168b8b6adad9914b9fb4774b50fbcda6bd12a3d115d39b1cfdf3aad74128e277180862d8e539ff945b4fb1a060b94302ff1a3925a067b956831c258d7a800a4dc5df81e5f1f857c6d28d1ee63071c132e617897ff6246ea2221a7903863943cf14c2de5ece7ae2a5853ec4592a6a00ef3dae9a64adfee0d9f8a053bfc1a6abc8022e71f9923ef566379da43efef6288ed3c2a82c19de06f2fa0a6b580e87623fd7e72e95227cea82299ee511f397e87f429df6fd2a93f62272e50c8de0e0bf017db73da889b2a6197cc8a5969c0ab63adf838a7be467cbcc266a06fdc54919cf66ac6d8f07c1554d1d242cf6450a75eb879aa4cc650e1574fec2096168a757fedaf4c915ffd7898aed7ff8d1d892fbf829bc944e8f706fc7e43cfe53a0af8984b7537117bcfcf58ad38b74d3f8537855c77f7a7f913ad48b2d5af260908501562ca60946d4bf5769a334b3d6dc08245542a5d2b853b9794aae5fdddb42cc994ae781e5229f7e4fafcd0029809b90b13a9b88d1ec3fa6580864861572aed251b1e43c0fcb262ec863caeab391c0cbc2691d38fc12edfe3dab778dff09a2377facfab7826a559331e3221ff8257bef471d4cf5b3d8c9f2fdb3281deaafded4649d1692ba666e50dc466b9466a8afd1bbb1a2f8c953fe8c13a2a6b7aefddb4cedf8698e38a0cc1641c994f9c3dbfec34e4aaa5e17647a7670a3d0f687f66519c4f3591847d055925b0bf09d910aa72bd016521dcd4a6ea8d921203b2e31a10c8030530ea490629ba18dc3c5e6d92d02197d4ac57de9f4d365464934d5e7d57b8f974e6add186e0397cb4216e48148dd68a4cb32e8d923487ae5a9ef8f08ec7bb598d3eb734c7e5118e122d8057a05a00baa37c6d1e0ec00ef4df520037907ad2eb04b67dbd7d023a58bc89b77d0ba7f8694d8f78d812f4ca2f280b639e2097c53c5359e9ab33a71e28500c4189facac8c5c36e3c767138b918d79b66a6a04874ea1c61cd40bc002a9210be0706c428377a4fe7e550160e63ff99b05dc9cab968a64249000f12dfe35b1fb580807e994d03688f5a4ebefa4ecf90a25085e6707b033fb99ccaef864409631c86e4cdb559b39eb0ef3ada633d6127d8eac0eb5f1e0d77c566a04630825f598eccc7fbc6b74a9e69b12b54a773c80ff93a87e09fd321a0472059fcf97c0722372ad5e31e2cf2d3dc07648639fcba48bc05ba3d4fe2da4fd8ea7bd0326b3c657a7e346cbe68582901c4386a80650f567c6f49e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
