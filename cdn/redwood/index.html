<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d29a8ba60c65fec8b0877a9d6fb383184d111de35c9af19b4adc67039a26dcbe281e6768582f5e08aa91bd56cd335fadfc03da9bcf73c1bb491e908037a740d62591ba5312a436100356fc2e4fb3763d4fc4a66b7d22e9cab0f08f391ae6674c55ac46fafef178d96633b878316edd62b0d78ed2a00a86c2dea2a1b0afb94af7c16aa3ae72c5f3066c7dc9377c205b25b1ea3f289fe7380e069307f2fbd10b8e39c706896498fa053b61acbcc9040c6233a0d0385c54afa9e95e56b018e9edd39d195d42538f8672e7969d78bef691d216d0a15d0149f820f3ed7b4d7b03f6c4f7591d77103db1189c4a42479024beb8256e2d8015f32e1ccf138b017475b4d09db254749038e832a0d121ffac1675dd51bbeeaf4b94d0d2d2277d64439fb62760a5d5bfe57e705bb2bf9535b40d4233c43a0dc69351fa87f272a5f1baa852aee71eb09a73d194f71ad6f3e0ec19249443e0279d51e3b0eefac1cbd287b15f515c549496199ed398315f812b0defb27d0369be1be027f2cab96b61c76a940df7f43d2910fecb6aa9a0286e2e0421bc803e8abf4c7a28b635dba289554a99769b6a1a6278029e441520435f490185713c8f3464fe58e204ddee113de7b1c07331238d3d2e6d39d26d7b48b4e52fc3c0a2adc10b53ca360c3a24a85c8224eb8ebfe5a7d514498305fb05c50cbb504065f22958466ed0769c495d92d1ec8e3a50e753289ecc735123238ce82b084706e0489e41784e9d641daa98bc38ee626b03d1461897ec5ca9459ca4d061f186083f74557da041eef90f1b9b224690472876b02d580e36e15b8b66debb4b9de1d69f950f18db0eda31c84ae820325c5aba1fc3343fe85ff3e90c7fbc2ce0d992eaa53fbb1aba1196f2f5e965bd66b0263fba41903bba9b6a8ab1e620fcaf817c06b134c8f07aadd253415c7f5cc3a55e66375d903dfefdaf7c12c49e45de163633a19489538f85c54ee434cf26fdfd77ad73aeffca78a3af0caa749811f1736c0e921635bd886e42080e8a9ecd3801018c79a6afc853bc190b76bf14f52baf9c8e889876df4479f3e3ee7d394a9ad5707d54f5bbfcd6fc2396f56450a09ea964f1fa2fa0942be04cba38e394c460642956e0095e6d702ce38e921edb7a2bce2185598f092c1e2611d98cf601aeaa5d597090fe9c6888152265b0372e0ed00adf0061fcdeb78fd2d870805db0fa573adc3f18ab2f0f3dce77d25785053b2e794ab2b80af465924989e52e25b78d8fcbc733802cc55ec0f258135572340469683a9a54bb3eec494d1097f4a5406837ffc9ed348810cf813d1b2e3d9d9b23439abb6598ac2c872287831fd421b7d392c0520a72a58a7fd61066cffbf87e36e14f7c8e0f44825c14275e8fe010eb21d7be80a3fb09eb2fa17344f1e3e7222e0018fa6b163c89d1a276df8afd69d776afb0c89aa5876d8e1e57781462dd9c9118a93ab04e87414518686287981952ffd78b6e0997377bef901a039ebbcd722d424f1cced6ce53e197264c39543015cb7c3f783e210b7f5a05e1bd90c6e4a06bab43355a70135698d1dbbc742d51648998a3925778ebaed8838f5638aa53763279317ac9db129d8a59a2738132177a927d9ecb03c37eeb9d748430b4201e12bd9f0cd480ca6b944b42946652b2162d96f388037b28efbb934245541d2f8559f550ee532cdb88920bc2dc2bc4293b48a8a80e6afff3dc31effb765387ba3103a0226ff12ab1b39bf9fec048284e435aff504a9ceb9aa230f3656b8462d3be068bc7ecce3dadb32c3c7d1f7e30f672ce081faf114abf432f6fb7e0e4e4cb8e517438b15bff842d4d10bcf2e449bd5abf8c6acd217275eea6a48622ebd4891874a4f0ed9fcc152782a41a8ac5d1be9f5d6682edd67a804947a205b53f386fb7d34052a0ee9ed1d0f285e98133108098fab1fa14466e56f1d732a02626fdb00bb7af905968c77c8a998062f51922acaa8a7260f28b6090576ee29a93f5c1726dc9ed7d99287cfbb0044548355079454d8b276006080f8b6b3e33c3396e7ec0a36c716b4f19c369fe44260fa3dca95185fbc13ac28a8a479d90f26ef934761990b20a797212a70959382a0fbaa63b782444fed8f7783fb0417e451fec464c4fc399b4b093cb23afd212c63f92843ff83c85ba3a2a08a8a44397c92141bdca53b2bd61fa3fe7bd85c240a63d13919351914dd1003a610899d400dc6c2474aebde8959af2915edbf5d6823c0e95a45473203c91f61621e72cfad97f176dcf31266c85869e36ce3099a447632c298c6223b9cd95ac2d514fec8ebe123a0567351a374fcbcc1dff81df479d8283d9277c59befe98c573d9bdcab81b999ddbc4bfa43e40462ffdc5feac8d6247c94235a3f266330d605237d112b490727a3300b54b6885651d328377dc7110c0fed047c836a71189b2df62847e3ce3ef107008b8208b06025cc9ddebbe0e78b092b72a132d16c3ccfcd7ecb01ab8dc9325ac1d61f2af4f0c7020a07e7af4dae90ab803e62de5c7005f0a648e1b5f7c905267b06717df5b0fa0c357ba676a85c27faed29feac417c01f441adcd849c44aff5635185fb53b4a5f108bcf536664bdf62b6deae088e60b7503901634472946c64e951a2eeef5f965efce4ac3a2888b8604c3353a205b86fb28d96ee09fe033a63db3359f4b8f725f43be88da8f1eb75e08b36168fa924fe8686c7419631b468589ae2a74033d3f8f5fb801f2c47a9b58339c17fb33ef3b33687fd33057b98a16d5b580a3a94915fedbe8f0d43ddcb0cae4a0087caddc767be0adfc71b3881ebbc31a31916b34c82d061797b71bb419c3318fbe11824500a06065fa4d1f22bfc1f17264328882d69423ddf48da6e2a41f03028158be8e0af8946b9cab8b25621bb478bee1e08dbb7299c2ee2887357a3b9bb226d31943d9e3f6fe46efcfa604a3c22a1fdf6e8f52798468ecc51d5403849d0e0effb4d462877556e476d25da54220b989890e058c9c4c116632c06bcb323c46b493ccb1fc6622a56d2dd73ba5a78845c1b987ac2e8ad314d4e66e0e8095a52b9c0dfeb9c5c647432eef8a4b0e36c2846612ccd113f673d2aca8540a5852d989f80d6efa4c985a5b59c6105fb39e31f3604c23169eecf57afaeb94ecc04e8c4b9136d6e3600a722ca4ef3a359f9962e7fc4fd104af4536ea74ec52c57c5a3283abd4f3fedb0032a297a04606dd32e7b07f79887d602b6122392ff35d9ca654dd08bebbf7b6fbf371b0e7aa078d4e9f3cdd8e39be2b482ee49520e2baede2c13d0d7504c41d99858e12c6c68f01c4421f3a5520d03552b97163a8f12e5bc5fcfaeb215b6ab7ee1d5faaccb83a1e1282e80a74bf97fa58fe62dcedbfd205ab72f9268543a7447464ab46eb09c7b8250d533699882a0e7d4d440d75afd9691a73fd82228fc3e1b36a2b9d71ad1e7bdad0eb960cf9285479653223a8f807e5d2249547b46cbc3c106eb0fb154db5308cf21f873258ee666ee99a633297e419e6db3332a11b513c4384d33a1b60714e1c7dc4cef0a9a209031a6a0eeab70f793a51c5648ba66ec59b26fb109c10ac0f647efc2d21d13392feacf83f8c437ae2fd221ee74604bcebb6b54fa9ef0c883ab5d3dea31222c7f0a869bf38ea0b37afae90a7dc68def11da6c323064ded351f7378d3c61edb12654723cf6f1f7594ee8fb218931bec67f8a8590b709b162d6a0e8b26447584ddf74e7b77461c31e628f3415e7b6ec4bf9dd243f4159d5dfe166aedcd1fd2da5dadce455d062add50c128f02f62a59e323a99e47a86faa5b5d7d118263861ad5843ba6dba1c1f4916ef9332f84da379b07ed103d3e054e23b0dafcd252f4c2663cd67dba6f31b2a375ef52f39f676e8e052eee0db8e7503165ce37fc370650c766161e75d909098e7fbd12a13a6fa373bcd993e2895c989c797bff38c032065537deebc1113cedc41eedea4809ae04d73289f643b931997ecbd09150dcab81e955c518d38cd5fb829c7675d6e9cfb362e1fc326d31eed28b2bbfb9c4d278dbefa64c80584b6ef3fe6b4c3f76ccd4c39f9c98008ba373c1744e830853bd39de9ee9e60997cbb10a7ff3b19f547c9d4f9342eae129f70ab50ad0e4f11cd8010158eb3a2ae5024cdaa3374de1245dbfe976c45a5a083a3ce711762e81f59063b5959e5dd85799c02942b3e06ff9d85a9391f8bf1befd2f0fa0de2b32fb4224a44d38fe7f1b0946071a26ea3a1551bf6e45ae43f5fc6ea9448016e68471648b3d376b587f1d5ed44742f0bcd15b27314659c1d28c9240226b9d397c466cdbc05ca1ceab2a1f630254f8bfb453a5c60d48f8937f843b04e1b0e21ecb07e4e589d8559d8d65d88f21d3ec33013c0767d8a1af6a04a008f9b1b226dc03ccc6f963558fe5adeca17e68ef3ab17b8a2948ff62aec3f73caf1db919b72903d4407c31e58c5149efda5ee935129f061b6f3425b025e806d16a1f6035730f6acbd24a9015fcc12f6d653b3eab582535ed5b904b051413f9dca0917253693fa13bf36b20bf6bfb438ab8f04a803aab71c5a342e73dfcce543c7ffb88942217714f869204a279aa25c37698d2b91b56545da339a650587a9a300bf480021dfe6f429f4c2b594620471b92ce976a3de784bb5514b78ef753bb44e0503791d451f871f8f4610b59166ece7c594db61b62e4d2aeb37fdea1badd64ebdd6de5abcad731876d754ef63b53b5a0d23ecaf7af38154b7ad23c487f560ddda57a760cd324f3d40110a976db82848c515032082a8c7d129c2e1f19c8e980b59c12a7d76958568de55711e400fe1c7b5d44f75052d8adcfd7b17ce5f1f84d7be3520553dcca6852deb935c3ce7f5aeded96fc5637fbf51203239119ec6c90ade313db657314fb92ee15396fc716b280864e0dd21ebd074662703704033e579d82429a126781d83d14216cbf5f1ff771b6b347feb019abbcd9dde4164d066eeb9b86fa15bf63e1585b91902030f49d6839e6300190b95e9943fa6764d222cf4a4aa8912b2dfd14539276c10cb425e153cd73c5d4c7f5c1d34febd8d4b7be33d15e0cff7405a1f6dbe290a262426512f34c324904593a8291a644cd8e0f9246f974531f28db1cd3859065fb79606363b98d26976ed2c7a12cc998a4f9a1ff6b586658b2ea7ed9b9039ca92ff75ad02863496f2b119bcca6fbbd83ee22fbd14c6a67def04dad5ce62c32df41b877af18b8c10799a296663d3a4cdf78c7ee839113a23b7d8aa0b1ebec893bde5943d3e0a07feb1bfafa833986b355e2fb76400d5f45fa9bc9e4798e4b93582e7d1a4d7d9c073d7f04590ab4d8ec0153c75089c1e0b912b809d72e62839a2923db6ef289be17180d4c10e955052b315fe3364ebb7e7eb6909cd72107d1c3fc3ed69d4d079e83c4d93692bd156f64a3517db5c2b5ea2c3f1b9c0440a217cb1c9169e61428c65ac3ffb1ae1c7c46554d8a34e12f7e2aee677473b50423abebfb24bc3085714dc7fa7c5c7382fe5216d908c4843e8219590763987f2640ae828cf501612ea26fef1d7c8ee0c2425be7bf55ade6ecb0c46fdfc9830a95db77482cd8d82f5f1bb83012414adf5cd3d0b2a7218ed0a07497b80623b378f52bbf6a620393225879737610bcbd58ff5d71640364a316f1f254b7170f317ee026e15bd9504c098b20de61a1f09032b981421a633d1a3683b601bd30e17aff7327cf8f843234feb8e188b4d4580e86475ea424295994b80a7cd794e1da928d49a2b5c3b5c50fc615346b3c16db008f9e904c7907824dce68b4fecf03e9b2d08c669d3d6b1a9ee110df7de1825b513004bb28531d69fd5ff497bb25d6514b33fbf08febf920bea3c95eee688fde8f515e8fe2e872fe37f19c67a81ae03a6aa243412b60c760c90cc32b90b407709b113cc77ad6f4c8e04fec2eebd58d84cd5fa1c3d3b836b91f692f917c00bbde17688bec2ecb2955e5abe9c61093fde3f579880e3f6f8aa20a4eb5cbc2df66404cf0644fc0bf58a0580fc5e9c6302f1a7e1e6e152e56cd1d7ccbcc68c91b2e5a09922bdc61517450837f02145908ea2f554efb3c34f86ca10d79212bae46f5851906f4d04050ae6803a5630f307ddfe57b0fe3f3b4fa71847cccbf7b7e16b112f26e806aed0fa87cad439ef796286032a778db93a61d67e41ea8602233a5af766f2dcdea05d0e2bf60b95c9ed7e25ac3a0b9d2bddcaea2dbf62736ef822e857761fb9ce3be28244192a64b1f4b2e362fec2c0df9088b44c82ba9a46f1470cb3c2b48359d5d7bbb2091a19b403901e2486af7a796381dac8b5d97a834e24488ec8e7c781a4c3f72807bb93ffcaea16686b9a86326df49f86486bded5447d7d246ea05525f1674c2b3bbbee2fcb4a1b778d564c6997b6f4908bc924680ed9a5ae1738a042fd5d6ff19d08bd804f9f4aec2e5b846019f372c19783b1f482b462d01b05c4f3a9af6eff8ca1947ac19218629f8596c6d38500dad4c89e680f8561a8ebe9295bc84e5e856f7566314117150dad7b79ceec1af7a9eb94c703ef81f2e082bdf4cb9d515bfaf74f440bf3c6563e6e22ab2cd5120eade93df96a2535fb6224e8002e76d6419e64697f38448a974682660f2b5498c28b839fc678ffdc939cc0f247cb429703e4eb3bdb91f6f921acc384fdd07325700bf1b54f39b3d43bf51af6f6779d3512862feb98b775dcadae87df1f461133989e8dbc7732c232d3f61a59b6f26f9cb12b04440ee64c25f0e6210e6ca47e4dba908f3031f0934672fa5ae524a093e4dfeb1cac55128d51c263d9c5002cde914b292a9c4f786e8460c6180f4d3d53c00ee5ea27563171df8aacfcfe2c86450f78eafa890e072a93bf853672aaa6f609bdb80e3d1f75a1c44e9b05861703020328cbe9d79840cf6754486835e98a349d965950c300193778f116949061bb2d4f7ab3c9b12a1a005832157b6d34520ba6ed9c7bb731db06f459daca2f29e25666f6190bae5ce89e97e6b0252e4ed17b0e17918b68787f75aa2d95f938e3c4070e04c50662467aa2e60fdea11e0fe8f3aa64f1db75ea42224079d33ca298f36ff014c407a18ff394771aeb7b19564eabf18a75a4ff130f59f9f6426c967a9a50d265d175e8d35680a570d376e50bb56c454c1f2d13679291a7ee35b7ea184f6a98a2fae236c3296b4839f89525c1ce0a61a7e5f0123ffe297b62ef7a5c96cf100726b285706595b6e06ba46185df5ba128513fb867e24c555e934b161a9382e4f68243190985ce3cb41abfdadb8e9dc48c8b3bb496bb6d37bee4a929c567805940b3313d493cd2d87829b4c81fbb538e662b8a50e4eb172d14591074b850adcc712623f9ef3e9567ba1246ba905e0503ee40ca75a002735ae4071700352c9730601852f0a9f024f57eedc0c7a78789cf5e6619a1a0d048ef752ed892ee539b510ce7c76d6e4447486130f9cdbb923ba8e882e39affc8271c042420b78f6993ecbdb1cb97d03dfea2158e89342e80bbc2c86ba9360ec875210e5f7f80ca084efda58a45a6ae84b975965b80fdf96b0b4068cb188aad561c944d0b6dd4b908a1616cf6778d5974f9935804ca289838f68bb9cc36b26ea0e5ab68e4e085dddd31135a875add156a03b57efa01a133638fbc1a2ee1205f3c2a68edf3444d4b171b7a5eef1fdfe4c193c7175cc54774e97af5fbdb7a0168ad495db4e7973e9175609759a211e4206697946124ab44754f2d4a55fd5bd5dbc30c765d8c416bcb6bb2e17dca98f21f7d21ef33938a1efeacc1ca419e8eecbe210d7fdb8f9fd656f106cbe21b50a11d4ef90cf3af0d62369e14b7cd2659eb6642ab0a070785def489f17e4f71a7b7cabb05c6814ab768fae35b6f1be83b099d8d426381845ad3bd80ff8d04fae57bb1ba001a8e284ea847a671cebb1650eb8c040de214e13bc335f4a72c651d18e3ab56db9a3d43439e31640cb85f0d710f2e8146bb3f98cb19d88a5398e3f465d7e9a5ac7e101deeb88ef293f73750f6c4f2d87c467b9837c9b4098adbcb926d2fa95be5f7bf428a06f0ce1280b8b6198ea8a45976f152ba7c8011ebd6adc2b83ff3b47b2392ae04fb7bd407baa2f9dfc59eea57aed24932f448904e820ba9b55d4bed8bc5eb1edfc987f93790f2cc8b6b3f508867b000924ab1cc377630d08c3ccb53cba1f2cae461512047a6213d14dc28e9579063cf24a5cf838c96d7a860321c07d46fe837d4dfd15e7f17f052e6cda36515d5c43f82d2d3c5cbfcc1b363f4671b13b532634130cc5de2e249b4ac12f02b6fdf767522e8d41adc541734d828160a4dc1fb4c50aaee008b6b335faee6eced34882fadbc0480c225016a1abf2d83f5f715bd0082d83af1d6d8f103d80107051dbf81d38857662e33e92bf72689a01601e2b783858798a94683e6e10ea6efab820507c480f3d8b45c3e571220e008a8c75b1ae38aa8864e5f93d5d5083ac459006329969ea0b85d619520b75724456a546891548c6a4dbe2a47fac389fa543c9782e3b2198d6001bb2d9387f90a8e974d9cfbcd2cb25992e55a006fb6bfe445ab14d7dc30a327185185d6618fb5f8aee2aa127373c0d9f183f9bd06ed3d0fe078d1014bfda933bc2fa4364d3fb529fba12f9bba418cb2070e25e0b7cb7348953518ca2a01d995a989c41f8ec301656c5e771b00876efb9ff0246df1f24bb27418e2f4c2ebb5ed96479d5e269b106be3c448fb7112b89b50a3bb59b79f4cc80e4f6537246a41d204aa5fd7a5463ada6f705e60cdbca087e7db3d4f940355fd016d1f26c3ec647b11921edc20552bf5ad736282ac159ff9893fe678381b721fa624b90aac761c9d1693f0f27c6275b18e1748dc38e7bfa05ce61c7a4da48f0fb0bb3da1c7217cde4eae2bc961e9575b3c7c57cbae5f12a7b6c6e4dc06d88645b455d303d82eb956825be2c78107419fd3adb1e430a6110635d84c2537327802e5ba6ae41518e9c3f1c64fd6cea904563e61ac733729c89d10cc0e315558388c8cabd33f8b548cb4fe0f533fd96904ad360d064c4cb59233ccacbae8f73de26361812723693ef93b0675caa4774291c2645e24168e3e6c1407cbb936f25aaf18b814e5420615d4234425907aca4ba65ddb7f21dd364ad1deac4ec0ee3822f9b1cc26966a89e791b9ec3d290ba0e7ab16a1221586a1a3d68797604fda158baaabfbba9c754a0a0a77c2058dfcd4e5a77626f9e81e99159663f090af5cb2cf7581f74b115ac8e6f4f151aa5c93f9447e61d359d06b1d7b1ff48bb436bb2686bf66cd677b0066dc168ec94afbd95033cb156f57cf79ea21f06cc8ac641ec549a66199cca097e9aff0bbe4de806a7db7edf7b4153f94981248aa83f874eb43f59c6602f0d8bb7752f8279e9a5ccbd31687474b67395d7fcda3c98f43d25cb990079e839e6ff8a1f60ec77f72b1d0f20f9daaf75ea234762f786faa66945ccf556b7d42157019ce85d21e78e678007814a6c6312b927f48046564321a1a6ef50207fdfc3e7f22d494b5b4e4107dad2930d397a195b28aa371b97f2e22a3299bf64bd2a98fe5bfd2411dc0705b47759dba47bc5418a967a0e5850ef559deeb085cf5802783843e50f4dfa3d7020f3b8977a14621031e43017f25ec9d353f1c334497368365e0c6d3d3a6e6d54a801271d99c2b53aef2964b42e6662a7f2815f1d23b84122145379a9da52911a0f0dfc7055b8d89e7b82ae5e40a57e81e1af521c1b37521ebe7fb8f0b4b493d0bd6592349f8289672b56242b64dd306c37d8b7c4d3a27947d4eef383f4025456951ebd242f86f83f0152f2e8344298fac2417d694e305acb57c1876014041491a824f52aabe5f1c7d69adfa16d2fc98b7c3907dcb33e516b9ac32dc02d23621726e8eb169ed9079047042289b2797c69ffb57f4bb0d12321309e76ea46a394edc4f093fbdf06ebc4008b8687cae543cc252ce31adbc1ab315a07a6b7792728a3b4c4a7179ddf45314a783c65a9699481978ff4171bfcb7d8aa424d0c13f79e71bb9c573a59ccf21913d793bac66b65d2277c1dcbe312ea81ef42eb62f36bc3b616527c6588297817e65204ef99d8c4e0e015d1bcecbbb93a51e23ada785acd6b43f95ff9761a1d0e941611aaee1de2b65a348afd757b12794af4ef888e06454a53238db18f3be5c0b397dfefc214c2d9e3b2956fad917085d8d974ee40e92ae58dc2a2b64c0bf1ad0b5e4b27e8bc7231c870c494392d9b6ac8d88381c91b0e361729c626abe0e49ef4703649872ec1b6f14d4cbd84a920afe424fcf469b2185fc25b58859296cb458837cf9450844bdc1c69742ebc477962d2b7408042f00bd738a1673e8f8d5dc9ff3073c6aa4be3be824d90bade1d514dc555b51d89260cbbfcfeb7550dadc02cfbf8866bee34ae42aa1fe723eb768fb69fd2dbe9506cc6324b0bda63a62bbf4d88a6b641ae7ea5e08c8bcbcf7f2f7f453a327a12bebea461e83b320e3ad9ebf6eb10a378c067a3bad0630ec432b47a916e4becaa989317145d08eb4569d465158587779b459dd556430461d9c77e5ae300f9e1a253054cba1c60bb4572a907db095e03762bf45931f7cdf9cab00410bf14866574bb440fff467ba9d9a690ad1995a686777ef0c047778ef18bf931dec57ee790ff307fd7f94a1268c6d06dbff003e52ee834bb4989b2e95e6c1e6d9b71fc6f51f2d37b684bbd18198153c2e8a084dd8d4cab3c2b959eeed5b9881d647bc08750fba569b86aada4050cc07f1c2ccb79d17d158412b1ca01f0c0b35f9e1819f51d3119819e03493ceb120ee4caf8a637e86e48cf5422259c04c08a1cd1abcc3c7bacfca788ecffc8561637a92e50b4606b8a0a4b71cab12976e7b567709aa5c8fac29cd56bbd88fe69ef5337f246d17a053bdfc498e2b2f06ccbe5cfa051482bda263da7ae0d1c7aff27cefbd80a0e82f326e08cdf2df0830c08ffdd0dad49d0f9e09311d88bcb69c84a1cf6fffa172962176308eee62f1638df80a1add85155a0f3ddf58796125046ebde8bb8e45b7bb15e2788eb8e9730be93d2c98be4b946850a79a47ed04ae25683116c0074d7bbbfdf8a2b723aa6ed99765add87c06e0ffb6d59b12b148770b87059a14d4dcd1b0f1715fe5ccf18f931de0df0f8f544d5539ea451356b8d3c359b799694c1c5b39a6d3e880606acdf009dca9c770b5cd137e5189ce29de290498cf6e53dc7aa4f856f3b215cc17fe38e9fe40540627c5f01a63ec044a4f0e4ef0419d5bb3388ee896de9597e02dec89ae2c0c8d6d2c731e2db9aafbbd344e938dc798a14c16288db83d5b9120216b01f2ec274131b00bcf59de847483284b2c3c21b83ce96f79c0f92efb8bcc1a8883f909362ce8a1f2a6fabe8dd40ba2d2ca6cc8d4933c9181887c7692703e7d3872af90bb510a75bb7d046d1424e8d56f169b5fcee8bd6b507e5a677ef990d874a741f559a59e05e2f0a3a3d1fe10631239277bc0bba5194dbabc1cc6d61e85b0dabfb12aa81b9e8d31d42b918c8347aa775a640b3ecd309f3330967a78fe0a1ef11ec14cff36a3682214866ee643373433962300ada764af3172b78c041f6684381282819acaf66d15d4c37edc6878220279ebc131a7b1b52e3a4f48104d6a618dfdb84f61305b59bd254484e5434b6fc02b38313f65d79d7e247afb9ef8377d0639f9b9e2e90ed3a4f8c6238b317afcfe2f8d62ec8cc7e8f624ee81ac9a7ca9c399237eea05d73943bc3dbfedfd8ede5bf5dad7bf99d8050831143f670bcc6a5217e86fedebc2d8fd7712a4c1a15962464dbe963c4819dfaf9579ae46c6bb2fe8704d674ad7e542ab9cfdc64ed7264548455cc194511a5a2a3b2c38f784675c33deaf979aee941d4111b7c9a8d16bd5e742b264bf471bb96f189177055becd0240beae3ac5f91a8f79d84f03f21cd19826487adea9d0f2b9ccf78ddb0e604d6d194929cba55d8a4bf9c6576d23881fe7a9a53d3c372ea7941716a80d15d45ca80b0c4339111d1a3fceef9c0d8fd8bc1777343f3973f2eb1baeae5522197e5956d7dd9c208129debe40f7b3a19c9cc5ad35f737546d25091297ae5a306ff616399234f748d624af5836bba700f451e0ca7fabcc6df03b56d17b302e84eee4f932066d0679d477cd4a5ff146db1e36d44a55482b66e2153fc5870c694aa5b072ca7f978b4c8e02396307738acafc5a8d6d59f30768c40be586278c660f0dc39fc57ea820afe35d00d71c2bceb47f01484e2b959acbf056192744a8f2a2fffb13fb9134f272fe2fcc359be544ec86ca46878a9b216ed5ff1977bdf361e1b62378a056cc8a3e7d1d286b51a9a635dfb4e481949c9fc3a51ea6d09efcee22d5ac9ab6afe02114e115749e4d1068676ae1832cc11e85bdad4b1dadce6274e83f26f58941570fbb53a0845dae7c6051193c5b9c8603fec04ad054e9a10671495d71361907ea53bb7aea7e0cf9f026be3567d882d034637eeedae7ed9785e7304fb9505b757f9f1c68c307545876c425f7cfc4dc0e1ace6f96b7a82c5e67ebabea8484a5c7b3fd32c0baed4a2f35e84d6ceb435cdc332e5f3774ca8d0ddc7f2a2d6e50d4fccfd7c1d673c8539e352204d5e797db1fa65ca276a5123f1c99ac7dc97c4e9871caef8ee8b97ffd38cd25fde5ee724619dc6bf3cedb3df4a541ab9859022d105a01bbda8b27fd14887263e5e5bea5957a6248b96ca9b4f7920639dfaa2e6920977113309ca75987abc208db8cb370916e21d0df30cfca71c70949f94b650abd7ed287b261a5b57967bc730fcaa0bce0b33533746cee05434a258e105c7d3f24c94843c794c53ec9fdac3120d460c3594795059db49e7f4da632c4904f47ad9a4d227c63f30e00a6c62c1e9d3967ed531d6328cab3a9c44227b7896f1be830e5be41d21dc7882d23e2f435ca85ab712de31634b5fa1d84a689285bff98593f83f082d242dc8f730726c46087f7a658bace53f088f95b32b3042e8ea55367ff9c9c3caf7104f3ca81e99a661238a450b9d8fd41f03756992f2a97673652c12f864147f3b0df8a7981aff37173b409ec700d95dbc9945ad4731e3a7d962a6ba2f557746857ddd7b36b072c2bd31c83f7a106a899a5e646ccc31f230e732eadf9cdce37cefd2bd5499d02f11cec2558e77fa3cd6aa7d16a06c2148b26631e78c3e2f4a7127a36c6f30193fb93a8580756383695a20639573229be8740b38035a1a56052af513d0db25db8d8febca837ac2d3ab43b5389a46d69e9502b6213593f3a0c4263f3006656a62fbdf608926228ada25ae5ca5feee9390c8649ac471e28bbbffeffa4809d3272d5dd8505d93202b147bb202c433aaea50a401b08a31a1afbc49d51d8c3aaffb288b8400cc711ec131895268653877085f0948b4f508ce6698ade32f9385a7e9b2a7079eb6532eb86acdacd8c618fe19cb195e4eb02cbd295b0b8dad9dd00e2343fd6713cbd08a3ca52b649a6291f421d70d49032ee674473d082f7538062e3d0c4260390f3784c01a77153f721c28d1cd5671843b347e2d32f61955b082acbcf7bfedc423992612cf95b883931f86e1f7948e5504cc7656e7be2d8fdd44353c338c36fe1229ff75a421bf90fe05710c5a1949b3ea7a1943714026fe2d7823716a8dcb3c155ae1412aae2aec39a4b0b25071372b8fb7987301b30b76a37a427aad70ec917fa04573ec7216392f15c0562f78cf0dfd64436bda6e7b852208999942a144575f4bef4eab3df33466cb25be7131e2d381f0c949a7d9ce54b1df9283d6f91b95164909c33b6c2567c1b2911d1c352639a82fa19ad13fea04c249bcb480318f776d13703c8b7ac91bba3a4eed38caf4ba2593fe69767cd01950e58f20cb5937c64554a079f7272b96941e0c1d5d02c86263d1ad9df87042e46839a2947e4f468d03ceba91c5570e03aa04485c9446e94df80ddab28a5f74f0d4b0cf729c9f7fea336327c43ac7336e23b08d82ba221b673303d4a46615e04c363d9c2516f789fed7290e45aa97fcc01774c319389656253614e39f527e8ae1ba7097df32e23eb339cc7c9dce48765ed2879cd42c3548a3577ab1f65d1ed146c6c546672cf151c07d798dd04bc690da2cbd1a390ba95b4bcd3c05c1f596696c503a97dc8fd4e35fdcc7f832b928aa0c9abc95afe8d4e5e0afd595b7db24a3ec439129f98c182ecaa3d9527fccbc34aa3879e3717a2d74f59e1069ed546970e54c24ef2ef8157d67f36b91477047ca9904e20d696983ec45863b263cb807483453841d1dcc282a71b610e0cda35e3af5c3d6da512c8340c6edfd76430bb8a54d5dc4d4c5ac421197c0edeb58f5421ddb6a97dc9a78c9d622e5b551eb32d53807dc9575410598647fb27071c8377ec7d966336b44e18150969e9e0ed40e9d575ebd975b9e778e43feab0c5eaea2b3cdbd189a24b70793409d15abfd7c60bbf13a1462adb267c483821f243f9d2f7547aedbc44e493ae15f7c4095274c890bd28c76de3b9fab6b6b7e72a90590322a54f0410c28d831027e1581d7dd3ebe25757860c49c2933336e46208830c4b643f05c761e3b71001c36a13622643b3cd16994593130ed89907d0510b3fb9e405ec4c125f16110669bf73dfac002686d780ad60f57ef168581e642120a84b81f78ed9c6185725e71c283b706757e6959ba380c334914527544b807559a2ff6697912c66b64a1c73371ba6e20619b5973602145b380d35eb53ee2786ff13e6098350d37d43be244de8016852f07dc12c2db613ba4edebaf22af2956c13fa5f7e888c0944edee120bdfe05596160f5ba3769439fde10b20de00326bc6ae66352bb134ce6b420ab7e12978dd31653c14dbb17ba29cf6d8174e66d4edb48b698e7ecca9fa556ec97de3711000092dc38e85230eff7bd6285891843d2d00faf8ece5c54b9e1758f6145eb87c7a2bfbd643f0009453aa5ed3f331adc8f114342a121e3734a13d70ab52f375f46e35967acf9f7b0d909e7d2f944442c2d6e5260066a6bd0b1f7cd83f7d7c261889e867fe2ba738c83d676c4c826052f5755f85531f8fbcc44ee78d8d4685bac6daf720646bbc9bb713f84102973e94df7d9e99175c2b0dfad12ac1e1ef60a8b40b204a498231299cb3b7db96be5b2ee8e2a5d54d9f292a21d03d1333acb8e12e975399b065a69b6cb61b4216df9a90572d3237a470bf7079a4242b823c636d21e9f3773463f5a7476d1075e324c14335000389f82256126b3157132a1659d734c832e227c870affe1cdd27745b48b8d0ab52244dd49d736ee382214bf3b93dcbf2d78ba999a34a4a69ed38ca79c33aca74d8ceaf2b043496b3af6752336b295b8648a8b1c2031d7c69b2c72a8f1293ed1683fb72c6163ca21be556aa70d10b781f81dfbc9069d9f5cc9bc0b8630b0b8c5b7983b3336715b741b138a28fb46842e3bb802b57fedd452775a443acb8961a5fbf99805f38f0e3eea1c55edaef096625a5826525cd7a2bf377ff01ed6712e8d1d0593326605928e61d299f759fe63db4f0e1d6a6d8b5be3758c5a636a22e506c10831798404f665d0136805b6a9f3bb0c5d65542074810c2d625e42e587b9f6789b0154b605d9e5389e7a8516cd9fc514998279be57f68ecd2d81cd837e51cd0bb4ae844df3e12bbc9a6269c3f5f1a699432ee9920eb4057e4fdc3e3c628a05be251d1aad293ea15eeba96b4ad0c89fe6cea6ca90d127987afa6f9dab6ce25df3385d44bb2cea29154529e6c12c7a6e5662e43c3de79b3d560212567d71735c6f508000b81df8e40e9637f87cb3af3040159acf844a91081a6bc2c2efb87088cf897f28698b43235692be89ee8bc190a508874c09f9bebf52ed46bc255d26f5c853a4891afb8deef5849f7df03fe2f1ade0c46c00886f1244bdcc0dc4143407409eea3d6833b6193f61aa4003fb62ba0e68e5a8082f5dfdbcec7dac5855c0fa938912bc685b53cb987b84b553833f9b98d2dd9c0c0ea832f89c79fc1552aacd50b6124b19d977dd2949389d250c1dbd30b617e9c8b661e094730de971a6e4318b8863c4a6af2cb42b5a560b4c828c864af85def048e2663a5c6f724af3efdb49b6d9f8bf398911fe5ff9f707dc95607f23935b23cc83b56f7bce403e813f381a020c05f849af5aca8a527b968c776e999bcae97bbd4c6626ff5ed7e816cefbb19d07b20d197c2b21522f5d15ded82fa0b720a138ed8f14a0b18831227887ffce191ccf59934b684271e362e36e24e7bbdd62db588de639eabcf6eb2bf383ddf2d067932907bad1a446b1a5f415a0820d60033daf612aee3c17b69e6bc4c31c9229837b305a4c56edad193dcffa47b9b1b6cba6ba5fa0e254bdeae89bbef518f16de9a140612866da4c58f27ab4cd731bc470a29c3632fa6b3d57f5cf317507cb3229269f29a12348eeeebaad182ba3a15dd5c9491538beebcc3a246d0035b078ee77b7c191877fa74e92b83718afc973453daa4ab13d9e6876a4d9e25f179bb15066dab9f58086300387423298cd5a39e8a65f9cc919e8ddfdd2429d7c47dfdd397d62dc50536010f5470d4eb5cb86eb61191ac51c59879b7ac0037355e33275cb6ff898333ea428b0af6491e34fb710b12f4a8999cc73f12c5e2b99593d472dd111eb79857317d45cc57f4e4665a9526e9d7b69f217c9199026ed65c6f3d4e8eb7021c282fdb7f292dbbecab05156f8358a7a3da1c0beed122e08fef61e28090f8c2d2e5d4b6d66297e2a4f46c0ed2c8f4868a96ed384061dd6641fc2084519b88c45a2d74e62ee5b312de6535009e8c6ab10f06e91c337bbfe52c376c41d27b8354eeeea1b41bd0afb265a74f75779b1d8d74a65c3c564223387ee836a1c13bfda233f553d65000338f20355d9f334cec0e11dd2b892e05ebce3afc0ebe2e1109c1cbca36aa79ab3b92b8f0f1fd40c5acb0d0cd16b595cb7c14466423fc3590863a7aa31476e128bfa8ec8fcc20bc1d51a915903faf1d7f65a15d83773c56231b98606ef61ef56d7a8c31269b9c2fe4c2edf135883e48c59243b1b17a0a6822798d9de9ef1d7f6d6a108aed0298797a8c75d4c1410ca6167f1859bd9173619f6ae7c9001a0e64fdbe1fb8d172068fda5a9fe9248c509f91bf7f3865699419e0b706d364a9adbb0cbc2f4563773f79b3291ea4a8ea0017d2832bf1ea6227b470321a3b0f3fadaac400ee4c43452f26e7214969a8faaf9c08c0a176cbdbafca5aaa48e97b4ff74e2e1bb44ed5f634e97c56f1ce6a1b3ff7bee92b05ad9dbe4e5f3260275bf2dc1e585381c6d7d469ff52bcd699c03480f9837019886ec3c11e2399720c548b49940d09bae99c7c1d1bca8522392e39db0523cb2fbf6a21a0314e16726dd6dfe6755b07af15da55b34eb851b941fc6d6f8b5f41bf30591e1cbac546d40e6807694c4779680b251db29f3c60f74ff6822d3eedf284fdd5355aa311054add2d9f67c6644004556bfbe6e4716935c516aba1ee4d5481fdacbe800e3f7201711389a5730f73f3013bff47c38fe880bcfe25bd63d9d055144dccf7ae56132732ae7816125673a3dfd1c4b4adda3b43c56dae2535b893b3f83e70e2790a633ab10a1c70875e7dd87f4ccdfe5e2e18ef14564e8170a2f13cf5f68c7ee5c777a4d513aaf2c6692422ffc20fc0f92ac68d1533ac0e35c049f0b647e35bf0609b3dc34a1d1365bf9a63ae78cfc0a9792fb44b46c7c34f67c07f32b9ec2c2f86421a11767ae3bbf6f1ff4ad4e83279041f0e9027b61eb9776f405533383e7e4fd38cb915af3e357490e153fc3a44b2f5981eb12664e9cacbea03fb2957e6891fb3d4b64ff90cd82cc6904e34f120055ecd7c7fbde6b55ad119a7201a8802d2cfd39e11fbde18dd7d7cff7ae08145ddb0d702c718a66ca48811e5a5afc187f3365bb700af31fdaa1f8504191eef4f9b951418981f9f732e03de23ec0681688dc9090279816cabc01815ae72b3701b2b163414b3a6da961389cdb7f594bfd26f3c09e9db140174df1b3f5d159763c073695ec599bd5807b81d62505d2b9b9af7198","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
