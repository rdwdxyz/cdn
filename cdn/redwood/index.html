<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cca1134dccc60eebc20a3d854ffbb009a5ac2220ab1730aa31b716bcc53a04b59acb2e9edf2c562cb32f3a56a6b2f912a312deaa3e61a7b048ffb3e50729f8e4d01b1dce539123219830b05b759cee83872bcf2cb846e96c0e6403aae038d4b4251485d764fddb1b2262e1d78cf317873695ac6946e9844d93c757d3624688d472150a87e1eae3410a8338f09cf6c53cb0e301854ff542593724eeef452abf76b9857143c231f2cef06842d1cba19f6e07dedd48ec64e272f01104d5a377726a20f8cd14f91429407bc62df50387460b90e8d5f3555b7e0a373d6b8fb7b0f1e3a320efafda56388c14e6e2edc6872476b3974b0b06e461db04a7f124a9319ef7395f5f57b2429c66f7b75bea9f3285ee6fa0977c93433b649cfb094fc5b39637e284bf8ed0aaa8d1f4b6e9f0dc8ba328305e72d3b040fba455aa1f9b717d176aa152662c94cea4e702c4830c46f3f06593fca74567197d7e7c871d51046c1bc3e1cffddf911d51a3773b2fcd2c5aa2c06fb17b20022ef656888f11d793c5498c7f8425a7492e6d8f6fcac03c4f09bc05377ad64ded8bccb79ad8068703cc507c3ba7dc8fb8b175633e613820e84ae109166788f839924decd2a23f868448129e8de341b7499094a838a64329d6cd45b54bc15eeac7ac3a319fcc2e8adb6a41590f0d7788bbbd21429a05b200a0bf0e9a4076d7efa6864969cc0ab3681d90502ebe0fe5414e946ce8695de4df58a2938cfe45bc9c49eae21f5c977c448c8de5e35be7caa43e7fa0365bb07af8de34e86a10b0d1d20ef0cc6b018ef188ff7991c510b19a94a776a782c288c38013c8ee36fa33e07443cbcea83e6dce3430acb65e5fd412a3e9298a62a638998d37e269c16d0e4ae2467f445e4478da7c45bf0634efdc0bc7b5bca7a88cd8ac276c3f4925423a6b4e8750959b7677129e43635613ad2c124e49fb2f409d047fa5c667c5fe0b2f62259e9be033bf7d52b3109ca3e4f3c14a4d70ba85141c97ff6623f1d077dd0886615468770c988eeb4d0c173283cfd4ecb10b3cf91eee9315294e99e9fca2075b6455995483dd2774c49fabeeb03aac414aad39d4cf0d1949a61484368e81022878fa1be7fdc4a28e8a72092c1193d5d10b3178d97adc0fb20f231051dfed917b32a8a64720d3c4528280bb2e3dfb3b0bb7d3694293a3c47236ef2647d6093a397ecba9bc1788b30215bbdcc18f03fc4a9fbc17903f3858024b606c80dd8b2a9d7a7d1b29c07f88b5ae2c86451b3472118bd4e4a74a199eedd0ce2686687fe0857a88a5fd1e64193e8fe79f7a290ccae1acabc4979e82534edd0085d2cd2f6c1d6ed2a2706b3f4373395f260d52c4a0e53f9f9a05b0e192a5d5538cd55d3e504b0f85fea756cdf4e23a19e94d6cccdc6df322a0d0185523b2a04d3d7332abe8e927c1f8e17cabfc22a4ad7321b590f23543f58ae6565b41c3609ebaad059bcaa6ef31be3ce4458cf715ce455bc7adbc78b680044dcec1d8f89b174b50c5f309149f0d402628cfa2721f79785440fb2491c75f0ff47c1ff86eade455632bc990f833d83177e36ca6d35ad1ca3d2c9f1610499061d4c778f593739305bb5ea7536d2ee756d59fcc462a9168eae290328bed559dbb0ec6e7fe7cb3f2cfab5d92545e1e385c035a2337c6fb976e89fa12cea0db4eceb7145f4a92c34da729adabc5e1d87e13c4e2595d31c0deaecfb9f154dccb6d637e7d94449087fe96ed86d23c447474740051ae17763b0138a7b7fef1b95196116ef95017843a9fe7b5df34bafe9d7ebb887890d0a3b95d400600562332fc47975a7e0a4e98a2f3d85316d3ff44814c27907a9f828ef9b2b5c029227c30333ff231734b61be69ea5470d912fcf9be7d6f2a55a66a15a70ab397a91265312df787618a897cb05bc873ff3d67276f0df907c10a41c0264354bffa6229cf81d9ff745591ac8ec2938dde4f19a6094d2c248139d7a98059bee1175b5bb684e0c4a924bc28f0a47c8fab2bdf58fd9c2f4730126c1ae3ff6ff45e155656d7324f088f55cbca3ac0896cd67c41b97df0f1b302cd8eefcd841776858be51d1b1f6ff6151c21e3bfed5e3a7a5cb31c4f63d7ff5fb73b1f59c8d5df155bbd3fdc61676dffb4169213bf5850ba6511316a6c35610a227c28e246126984de5170a0364e93172c20dfa26322167e6cd747780006597d45d0739f50a8a240ddeb6b5d037aefc0e969cd2a866fdfea6594583b2d1bf032c2945a32f9bfc73244bfabab60b52dafae75b86c1e32cfa0c8a6e08ebb2c5d0ff0587a5c8a4977f360a1aa62857f1c1aa6617b3150d2d5f8295e71bea38d162ec26388c1c0ea1000272d2cd32c027d50e3826a4db7c3c1c90b29ce75e8e056617129a8c15867ef63056df46ee2c4cb88a68b32de1de870a3744cc6a11fdf6da431bd719635ee155486e632444c43d666746a6defcad4063e45f4685d2bb479903400f97e5cde7dc063b882b078fc0b7cc14a7bf8024d65e3afe053cf47b23c97b3c982f7256f99d8fdd762b30875a09d1700364ad4997ac48ba8e3589dfe49ee5145a38c90eceb8825dc4a9e5bc64af5b450f4a55697bdc5ea59f27989b5943bc5e62036798163a574d87eb6f0f91e5f02957005a20cd9e7456338b8fdc2827dc551244acffdd48a39eb3038a4f7c351ec13121b872ce4d2dccb0f64ce48714c3684bd4f534a604066ff2b796c333cd30e805f4df5f10072dcf5464cf6a76e349473a84b971e1f2d9a6751086921c6df396ad62219bcefb150fd52484caf07206ab205f5726a1d1b676319eb557dfd8915e6183b9bf65c1df302a331482132b160def610fc284edb0d83512ebdbe97b4c3213c0ea4a67edf9006e977746916e6b52b3c07ac33a33bd22e5fb30bef3a0ccce1f08386c187bf6360944b53f577d7859561298cd61e7e6a5f831c42e0dc73a8df049507a2de00ab721d6d836ccad24448c9336f49992a73cdcb366efa79a0fb48a71104f9f3cac2b5aeaf03ebe1d4b556e3d165e9425527e6ae4f4f89721c9400a5137ad86f0530fb6d8c55b26a7180da8524ced29947e1a6f8ecc98eed38f32eb1ad72e694004676e18b47760170ed2f8507b32b0ec35264cdd79cc2822b8d546a4f598f727d8e3b80c81f36b370eb798eba95d0757db801f5b6b04f4885040f50d7408aacb02f3c57184f143d56b9ddd4c597cb94be77e1b0a9a0d9524b75f9cbd4c446bbc3f73913b5cd7c17c96752dc0664cf7e238dd38a0d612f189ee569f40df6c5c313429ea3912a29cfc15e47901db641add117bea01d246ee6d14571f814bf3e74d328a02416cd3087b93190d031d3088e23d00abda750d04e9fc75aacce44a56165b06b20a0af15d0e540231138762648c3a6a40f1a4b5040dc57741361f26a7b8dc8b4d40c5f49825086dc83cd7866a9445774d5205f41e019d3eca8dcc4875845ccd596e0d4c5acacbb314d4f6820cfa4196a3dde297d912afd18ab92c394ea5b0d9d21f464598baec768136b76021c8596b9870c408b215ecdae2cf7944489875ebd1499d0718381e7ed23b93d1a8ffc155be030cf35dd52b0e8abc891a8ea02cff478fff842c41fd3e7074e5ea8f8924111246286a6801db3b3954b286651cd97293b33bf4250a17bf15d4d9086e36c57c8b81850dccbbb38833fe7684d04b509132d5153d0b1b28e1ce7adfe41eeec86f1353c91616c1d1d0ac9b11c7c7a5b604acf57c7323b16834bbf8059b6297d845efe4e7b94d0bc4385c485e42024e9d27dbb726ec1a44f5954a9be16fdac1de8aec4ad27bc092e7aa92f8b7f39330f284513053ba7779ea513fc8b59e11537c2336667ddc24ea635331d698c15e61153eac3fe8775e673d6e99ad64cc13aceeae5fb44bb6c87684b78cbdf75ad99f3e336f993dca6e30e65b2614d351c31c3910ed2a13527204cb0bdbdd0d7a3253a29272a05264b6d393e872b0d259bb0f24f734acf5a4e25fe0651f8c7414d0e7932aef80d153ae2c3d943e7c9557f1d4beae1228ad7700acd15934d61299015d27847617752771dee335621077d5d80a330f522580791d94b15daaf904e8091a4b94f0bf1912f97de8d423ac65e19e9f65ac0f94a4c7b927fa08b66b3365409bcf32513d99cd91f91b2ad826ca96f42fea9d6232fd67b4239228c3a534fe110991ad8c3569080a25a4084cd81379cf771a723be369094e67c5a58a6c218b4907166366eae64bb3dd1f8ce503cfce4d803ccde5060a3a2c890ee3fb86ad024955660bf474cf140a3864eb4712760d28cc5a92baad879e4e0de27c4d2c3df671ccc9c4bbcc73a0c47afe4a61c6c1c2fd7c111606dfa66cb1b639f36780af9f599c67decfa4523c338af13b8dd4a7ff01ce26fff13c45929399c5ea9377b49cf8becdd147902f1db8a76a6e12e62da66bed42d8f6827777e4f598d81d676223585783d9af3fccba7cc08335e55bb1a990dc93c2bdf6764c11e46efba47fd806a8afb2e9c82c28674e402235bcf0600ddd6e0b88134f31ce5f2db37997eab8b93003f555d3d6dedb14bf6d386855bdb23c003019663cf8f91d7fdaafc76a7da7215d1b33853d979095b6e5c29d649fe7d49a06b7ae746d6ece0baaa1e075c6a39be07b43c1b85f507e0f2be2c6e9ff164811be2ad29c7e313d9e3b389317d428c42045bbae066bd4792a6421b0d7fbab2a36fe29409b264981c85df91d3ceb4348bb00d9b8e1a66c95218392282e560136ef2e1aab527343fce3af566bd93e6816da46af0c1a07b6ba13bd85ec2f361da02aea6a3079125aed3daeace71882b1e363f45118ec98a0ef34b568f8cb92fc3d169e35fdce6ead4f1f80b79758808799440d9d5f95ebea0282cea289d307c69af1693d60e79e37ce4a274289748a2efa1dfe2d35046d228c5d7b13cd8711e3d927ce66a5c41728b5a8d9871b97d59f8a643ebcffa6cfb792adcbfeaba041f52f44eca95ba4c9d74fc859b8b1eb238d7b65e0639da07a684ac5feb7a8ceabe65f26b4a2331d769fee1f9557a037cee56bb35beaadce4b91e990883b98c6584acc7fea8abafca5e5bfa91605b779e2e28181db1c0dface9cfd98194d7a646f6d20bdc55cf52a8fe4184c4b84524e0f747da4ec4aa69797f3851c29b47a6b6a6961e139675295fd96878045e60e7edf3fe902bb707c6f22536f43a740157ee6109eef0b0dc1090a4addf38eb7c787ad949d34373568f7c1dff68eacde2b64ec0b360139bfa40eebe8ed1e48375a95326b20e73875e3d1893d64d25c2a2825007628e15021b584df63037be74527ebd5c3d735aa0a822ee653ae70c4421e0511415b5227dba17b8a22ebb7c230b0a92f230ca318ace864baf1976aac6a06da92b2d8ebc7e36e0b13400ecdfba7387a198880d9d84811ab275493a5bf042e9123a9ff806db44105c4743911b34502b59694d19cec200c1ca34948cea28f358d7d67b64153888f13d9de9dd775d57902ed23f143385ff365bbf50a9e20ec348fee57461bbc449d7b5dc032982d1bb3f6d9dd32e566eec025c8931869388fd7846e9fcd216a0c65c406a69f8cad4d5b94c64a94605613595afe3f7fba35affbd6e59209bb4258d3e92a2be46050848ca7536bc81e56b384b2ff4aef4b418bb7ced721da41c72e6c08d7e18a8846b60f2dcf44987cad52935b90c1ffd87326832f6f123819dc9fe9c36fcb85f3297515c48cf0b9de58d966cc028de381d001fbba04490a07553287b807e81103f99a627f63dce39aaafcfed7f087e0ad13ad2f2fd965d916a8f599e6341b80f83f56f141fa844b1b7d1cdc50ab269b1ea054f8e77e5d11cc23ab2cb2d9e2a925289dd166a287c962e7f045f65301198cfd851c3bf2379da8faeb1f113a12634c02ddd7d6f46e053690aad95526deda3687a4ad0d726464d5d95408a058127652fe2264e956ab39c3b406138cfb5cf0e66110e8b71ee3e3859d308469aef04da31da7aded0a3591aaa1e5216ef04994353ae953d289807bae225b43b9e2b2c0fc7403be08bde8ba18d9d22f6dc749d8f3e5abaf885695f571b13c0d555a479bc6e97aa9c8e7c8f0ac1424213a809be46a9f28a603b8b46570f3e709931fba4186ee34eb661f0d5137936236fa1c035e7e5300e540d0e84d36b9e96efd62ca95dbd4dcc2bdeff3b5a8f049fbada0c09f74e07e46ef6f8ae61300af6ee3257e47502bd793315368a7e05f2166271394eab859a2874c0f04a7e63edcd73d3095ce557f38fd988203072e723b5adcf249f2e0c6964938a32fc68aa6e68734b64379c9e2566f8e9eb9d134db0c99b8d452650390fe3ddb6711859d71786aad7adee40655dc89d5dc5a9b1934950c05e68c98d605437d1de6eb757c865a24e72e3e5979de50842da6303409dc59e532ceee7c54cd30191cd1317c8e0a01f091691907298a62b4dba582c8986c293b5964bfe602a760f77bdc71b196721aff5eb15da41e066fec520b01094c2bf31b33e7e359e0adcce54fad7f8228082da5686b64b6d619eb6cdd2c3212bad1e8c879ceacf633827ebb2bf2dda180ded68c477d66cbe7ec5bee981d8d5beee31b44cb46b77f2bb99a738ec3a11d03cd454978e756d0aedd9c0fbb84d50f8f4e597ac1337506f28e24557494c253d0213b489db0457eeb3983ce83a9d5b23d23225ba768d98a81366f1084ada8dd1c3245a0d28aa67e7c936fb15f9a31982061f8c5c2529a9503bb84ada0c7658e11c47a388975d80977f8eb0823e1309d284c114cca643926a92bd8d24c3a84c8f4f9ac297ef588714038f7fdf795013a2bf16c3c112a12fa47165b881be630c4f26d072f706381c87778137dd6db00af0eb068e4763684db9a1320c7ef57086ceaf1c3abc381acadaf6d5f78706541817dcf292f73c91cb42b34f78cbdc79ac6b9f205c2f5c0d5c0fb9b52e539a089f337ffc2185b86ba8a61f612e88aa9d7f2432a8fdc991f6f57803e3f3bc82d452c40f1a6d2b2c9d619b8d8f1e89392d223be13bd0b728b25de07d690786a53cfa77494780799050884ff47012e860f72c87c005ec3e67e1bb8f42c7190adc0353f1638e03f5d5a0a50a820caeb586cf7e7d10830c8f28cd1d07a0ef7d51ee799522752e321224acc1684e08f6f0ee806925697774f8e909ae00089eec9c593ad53a72d53271531ac9006f1905109d83f16de178d66753d3108e5d2b386aa97624e5bb55b458bd1ef0d23cea3b8959bb471d8f01a0932a0606378964739e8b7a377c3c207084c9c99bc0c25227e612430a283295abf87e02f5422d514dc34431c4093f60f1da2cf17b5a5363cbf6b839cff5001b85cff1e7e2b96c4c86e5f1e903c26e53cbd84a44b9d014e5a2bf9be2e4c0427ad2948cd523ea617d2f67a9e4bc75d4e96f3c6ec8f48bee1635f200f0d15a3779cf8f661033e0fde441b51f1413435a4c12516e2e9810388112a743bbb10c5dedad5d41f05cb478bd85143996fbb6eb31b3eb1732fd350ef02553b0be24242d558dc7689df070b35589b7470f3fc4c4aebcca52b1051954b4d1fd97db73a5aabedf03ad3d2ef28cdc34d91e4545074177a448effd44b39c89dfc9098474690a98b67ba5de5d60bd1c09e13e1903addaf2880c2c44a83d34dad3964b4671cb477342df748d5da744f7c68bce88bea28e7f57f5e64abbe64d2ca60189f0e5cced9d3d6412194641a5b4c927428ed09161d4669772ac9f04c2de2f6d3f6dc6ede0a5a4d16a469b014130ade20cbef6e337fd7f6d0b8287f9ce2aecb19f4034818e762a019fb0f3cf546a23e82a0645c1fed6d02867a2f529591a3b62b5a6e229386f8d492066ec299f61199c8f6544f4a62cca2fc02421fec837e4d18ac9a6370a338b9d6c7d2590219441a9f423fdd1ba58afb0a6e83c104665a43d5026e2c9199fa5ae31bd3bbbd3b2d1f6d32ee11c2f33a62b665ad5672433bf957907cf031a14c63c432ff6a45e20fd3b538e4cb47821a9f5981536ea03df3019375d5f83dbf963a05a3e3d36f2e1e09ffb967c4f2d5737b82c7b62c5d44ba196ddb0f4a950ebff8b647bb10d46ec7384ce4e3e5992e30958630e2bf68dc389cc981c2989a0f559658a81120605b83001ab46c149c83787689e636db92671c9a33e343b3fff2aebf21b4459a6df450c0508fa9882656c558da3f7cfc77c97f699f679f510a219073b853f5560183655d86dfb754f51d33690b1043546ea42c869fd15fc2d866405665d036f6c2a0a0ef9718c0b33f23cbcda9d9da1e77628522eafda604a57c2ca611bbd609995ec5b9b00ffca0ed707e1e58bb1d8e2ee29d6868cac61304862398f25d916ba95c7e3f59b50a49468c6c48a8407b9a193cec6027869785abbf5c290b5ee3d5be7d30e0a8651212f86c18526ac5d4bdb1990156a15448c14cb5cf8e95a794bed06d7730f46bca7c134286e008e0b0434cfed16eec1468b3828554b9855fe6e35529ae4742982b5ec863f5da2517b2299abdae2ce59bdfe2ced28f285b9a94bca226a7570319e902a3fba8da67d96130fd8a9a44238cb0f036ac041d8b7e3625a0b5812ca6bb681bf23ef82ea7d748612f5e36a067cd9a058bf9f471d1ff8139617364c8a0c065d6fa68a279a58387d59c7d2b60ecba7723b7547a2d6ea0f331a6ee95ab503ed571d0cb380d9fabb175713efa33eb2192e95a1ec0d778fde9b3a0c84ed7a693305067d20f99deb25851d97108b65b7c77c0d5b91f5133286c33b4229607c389f7158f287284469ac2ea73e6d022c3bc6704a1efc4773025b92592385adb95ddbf0d57ff2d4b67fafe16db47d521989a8157ea7b9e6cfb052dd7c83d3c64226fa22d4c20fbd38c3de968c19291c57d32ee9e4942ed0e630c9d1004a3eaa7841f4e97107125b18136783511cfb17bc348554f6b9d1b4d57b1626fb2a77a509218aa1678454c1a67da4308eaf1419363e1f329064a2ad2d4e5675139947af993b10d9c841513012d0bccddbebaac5927803917a299fb8aec73b51216124a3ec9939270501955e89fcc7cfd8f2de68bc17fff9316c461bbeeae205c473e7969fe75f6745b604855c3e577862327812e9b0cd59999994e4339005964a6efeb50f327f37d95633640c05b8f3fa13b002115c563e62a96539b4fa78eb1a70b455c17121517eaa7cc28eb5ed309d0cbbfbdf33430a76604787be3a8b4da70dba88d84ba2a3178829e4a7bf4038870500035c98728a32129ef5198d9b066dba8e31398af5c00b157edd22e1133da812f295f49e3ccfa70e3c60a141ddea7b94806e51ea9a854f3329954bcf6f5c98f71c553b4c84c075064a69ca8f8487a2b90a13a965feca1e597022cb4fe633c301b08edf4e77265427a3c1926ac8a79259ae015d5049bca340fc402966312d98ea8b9109464961c20510e941234dd06951705bfdec4139b2872fb4ca530d62667333476de3035456370ba4007d29b0c8d90de7bb5c6a9010eb09b661b267df7f82a06fe9bea1a62a374447f17c3ad253b0de6eb9a08d9032b31a3afec5e9300938d50b5065a846904ff1b02d8587a60500756a79fab22d3d69d9f2d1a93b9e46c82ebbbddf4b901c5425aa1312153e807d57694cf03f3f7303ffeb2701d0374857e8a40da9368c9c4fcf7cf08aa7cd1b83adc29f2dbf75a682986260ffa0b2d3fffc9aa28cbd51f3d4df569526c12313e7a57cb9c7367a07058e4585b97f2f7573a2ded23c444b92d93f9b1b35956f0ac8d5e348dfde6d90ed176a794fb66a1492b6e3df3f97a8716c1e21102b46513eb134fec8e3533f41e32264c4e6a5fd8302de37daf82d461418ba61e103a078d6e247d4c86ed87e83d78cfd67cd6dd27374aa45d1117cce4a5b31dea2cc63cc5cc81932dcd469690eea5f4eb7f605f16f0d3cfe1e6e30a376713a33a18992b9ee22203e3861d6ddb8edbcd4c8065fe841e79d2fceb1ddeec2b16c3f724a9e7289e81cb8df461901446c014067f9a1cf0758363aa78682b36ea7fd833f1b156880a2c8fd3dd795176811b6758406ee530c494ddf0a57713c219454540e64867b88d237a1eecf2003ab2968745ea7c36e10f6df8c4209ee5e17c256ebc0fdca6b589b9e0023f73120fea9dddf6a939c82788ad457dfe6df1b377ec1699661142200ba5b7cc33143e2dd91f7250da3c203b56616bf1c278f42c77126b36973cbc2a85f89a39fdcabf92d0cb3a3925cf2797d886a035289f88c64b8dfdbc0995bf0e6aff86c2fcbbadeeccb418278da0b8dde543f86f285aa35a0aaff95f96167ddad1037f4a3c55c9b44384afce09f70d98c102a55688cba5979b80c40db48d1038f6f244d796cb25f4763f70648a43f15350db56d647d59cd08e213b3fcd8e509a615bbf5ceb74f41bd40d564f6f4b995d3c1547c1896d7bad0eef5d83968ed10a22c1478c7fe53b20d427ae06f41f2f8dcb6d5279e6bf827e46d9ff2d3bf2d344f97d5e2a0427c01e346ffa4d651ef0040386e14fb941d8f95dd4907152c8f4d7ae6fe58905b20461d661348de534d9be12b218cd600855943f51558b4bed0e5083be773c987e2f57c5d17cfbf043e03e38ef89827417465d2f8fb9792a170b16581eb66d900ec3ed0d85f8ee3c9b8e0e67fbb353254859944b2486feeedf26129e78703ece1ef59ed8bbf2ec3a17b2d823199c8963d90b20ebd6a9cd3f7661bd7dc08a78d6ad4f6c0e647d739ac8cd3379bba875ab4a971b4a32b2260226bbe31659ed4711bdbd4a20ef2aacd58758bad4297954a1b3aefc28c6edc78ffefd2f41aa1f45a2d5dd54ae8e32f13a7d7e9821a694e01d1f12a1a6117a511ec9d1cf8234ed410fac7a26a90a787b62bd501110f37ac1c1b8f59a2c0ebafe8d464db2ef4f89206dd5d0c4ae6128fa71b972812a2d4e80aad4ba8c41af1828e531bdfa79e8c1f6710fb427d4d8e309964c88cb26a20f59606873b3424de72237b880f0e1e55f6e6de3f6706edd62d1657a863e2202b220b279dd20f5504cd4822d41e739e59236f10b389cea2fe5804dedd3e43e290f108abba1ff9c93389f52770f247c2a508c73c8914c5535d94a08864599e0319b8b9365ff8ddb3ca622144efd6ff3e3050f08986950bf2aadc6329340bf72290a56f00439619189bce2bde97de7ab3fe220ad8265cad590a0821346fde388142ef98b29311cffc7ed757f7b49a63bb5e962af19005e51ed9d9389ccd950fdc1755882fc0fdf45a07daa07caf1859be102b453c196e16dbfbd1aa893b0048180997d3f4825d6156a137f76f6effd93a155c5bd4a2e5e242a6bc19f0f28f37ee4f558612740af749fe9ff642154776ad5b022f0835514d5d0875780cb992874ee02eeb91ecd86e0b2f21e15c7422425cea9c9a7ca58d74d974de12d8b3a5f17d6d376777d82d58ad6b6e8b3e17f234e01e9c4c71a0156b8771b953315ec0cc641bd3d5c06e8d3043ec244d375d17159ddddefe7a32bc1f22227e596d0d313d56c866293a3d1c380189e78f8e2d6e42398e0f7acd42e80ff087f1cca4631808a2616afd1ca14231b87152bf4a1c4e5d172bdce63c47d99506af428fa3697f12856df62bb92683c5993d18f1147c8ecb540039628514af5d84f50d19450a18ffb5edb94bbd7f8992d0c795b8267cbe905fe2f096937c6c15ed23b28a5b0b8e156d95d54f072ea70e7fa97c000ad1ae4740d185aef9b49b8985898e8e679f940499831d4107be99a0e1839de97c4f910caec4855c0f5696f65ab4ed0262c5e8179512f8e15326761cde84cb2202bd424843fb9488e830fefcea1623d688d98b289ab236e6079d5ca0b8ae5a75c73fec7aef9989afd32c94f64d5961fa162fccfe2d3951ee58d5ef5c7bc8c9bfa6914942f34ece685143e7c709a54282deadb7f1b09afdabe3917a45b893716357b3acf2984f13e98122eacd5e7005366d9226a276f47acdd81b52fc0dc2dc330c8a0a5a44635fa848dbb801c063fd08a495d87df9130254493288dcbec5f511d6459dbc2640802dcee1f45aff30149abfd09cea691a1921d2cbf6cc97e1ae4ff3141fc83c8fa0e1004cad6d23ed827b5116ff1bfbed4da09f05ca0e9617d349166c6e2735b6e5be2307322ee9df1a575ddadf615198e5c6aadd5a7b9003c9f8c2628f14bb077e301bc37acddcc7afff827d4fedb966f667ca6df0d92433f468f0787dc005f141d547655cf82b256c799683875da75ce7bb55950029c2cc2116b91fb7d11767f3fd9d2b53179d101fa46a261a6704e2dc343dcceb7500165c6206fbcd0cbc701c2ef6a874d804b7583bd97d59026e707db676854ab15e77f56c7022ad1ba40391a9770e1031b144c3116a976194c58c2121e32a7e9d1d4fc685b956f2b054ec9bcf2c55bf0859d2dfae2ecc8ddde5c5d31e5c8825d898a609f13c889d5772549a0231763579c639304bae6671dbfe549111321955476e2719ab6af7839a91474a2a8f7dbde5ec48089196705eeb019596a6ef96bb79b0dae8504568e6cadc8ce79c9ee77112b69db9c56fdcb2678f205c2d9e5b1f391ca75db536f976db86cad76d352b0698ce785e3ed6c11de69a46c333c6a44c2a5c2ee92f10ba81f91434d3f78d465275d29c8ecea0c6e06f18f1899d7d5ba278dfd2902790a7b14b2afe27bbc4d34635d0214d343b53690120af406cbafa9904e1b0d6a938e7259f44d4530e82a1074458d8f6bb946ca77683449390b5e491e72be8b20196f2e0adadd347299383d7d99d7c0cb7d0697305d76f864db7807b61253f8350d8357bc5e072808ce9c9d4aeb1b45b9522d1c5de48e61a8998b2215a0e0a764b76a2c24739bb48337b95e82aa5d70246311c1f1a4259ea3c3680170276a877046e7c18e9cdf046dda95c0a2234f9f5e3f41c464b2b08a53bdd129f2febf256b5f461235ba97e65563f4d7bd2939364166e442f99b395a1e9a33f790820b68593aabf6f26ac280ec32c34c62c3384dc4d2fd19982d06ce314e64283020a05b510d06f6021a0aab5b6e7c188e8b2d69f87d4d98f3c02c024ad5b905680b5ada1cddfb0653a940d5408452a275892b287940c758d19ef2547836b1faf5f37aaf318c6ad080972b78748d6d05039f9d395ec1b251619415814d1ea5f4e7aa492cc905e161b951aaf7bf7b2eb1cf74bc31231d20a3671011d1cd5c07ef821192d510d63ce7f95e6e078558fe278756e34fc6ed0c4e295b490ec95bf65228e3d6a940b985df27c0005d041ee8bf62656f83dc1084f632e89ad3e87691db4cba874e64293bac317414c8ae5bf3913caca5b89499b68bdfdaa666903159a4db711d75b061d120af97418e81f73ba48e42d830f0c701fc2a4e8999c874d006951ab257447db9138bbab91e98c54b52a3fffac23c6814051f1f8d388b72285bba54e34dee51ce7b64d3f9ccddf6ec2190193f183e7ceb2e9cab08b79a395d296fdc196b49b619ca2bb0860fdf69dad3c9e37e73a72bbb39398cf4ed80eb4f9ae9730565c8e7e3731985b69d582942fcfd1d6658e1d11c554b25d4d39086208b31fb8dd12d6bd52e24e27b213022b902da94679612e52c8b3623599ab4b224f9a17c36c903c1e916bc3b460947479230c9e5a422e4bb7be872b9d8454433f58c3ec76cc31de5348a2454b71e03f4e65d7fd5cbe1e3fdd2b6770d8645cd4883c61bc97cde4d3c00354f319ef17b13072b9466a5382ff545e0685932fd4ef069517a8bc4df296975e0407da1321c7ba211823d48e2be67f95f99f33ddbfbf053e589dfc0255003b4db9fc403c64db84412aef182b00e2849ce8e53e29cc54720dc4ab04536e7ad26b46242ff3753b892d5ac3909ae5c6a9e1bf0e8e709f44c6ab041763b290fa821208556577976cf704157bd5aa12111ddcbf107d9ca643be1479ffdcd3b203d589f27ad51ea466633faab0d41307e5a0f6c850592b146584bed45270a6d16c1da14b6af96804270985397e768a43d211aac9c1d4b22b86edecbb5c017059ab90773a592294d0c5aa6e46bbd59ff8e82376f0428e487966617d25660f363cb222696e3f3f2dad2c4ff43eb40b5bf05ae22ba5cec5846d13bc12a39ca2a057530c8d95a2a9152723b915705510351a9cf7d4a721e949ac67846ad6a8b7ce6f115e59004ffd1a5f57924225a919945f2c124a249fa3f736669e9104f46d803bc6fded02f754d64acb386c95874aecd394bd2e8490013ec2cd3080f5bfdfc3e98cd58ad344a4017a65292162f9b29863e622b235fae5231aede1b77cb45a9705255713568fbb6f58c234cc6e5e390b497e2ab71d1b8eddb00a920a98233cf4ee45bdf10be170e69b6b7bd7e171c990523a57eaee3bbb24bd40577e54763a502e284cfaec64c2a59e0863cc02f017f45285dbe344d59e786842ea5e8b55e2b86223f1e9a86d66af35e0238960aca2234b6a6902b00fa807292330eaa0bd617b3f1c08518f6cc32e0809c3bf1a75933aeebeda9118783ad969aec332cb1b378a25219d67310f438c0e799a44d2a2274bc3d89bdb8652ec4f8a5e907f71ec0f212466eab7dda683d8897edf39ecd913a689f0f868bb91df2a187d9d3c94354dd4a14b4deec81e3feb4bac254fd963947617aa548d4476fe0d775867fe94a62ebb705a83680952e801d6d253a58b265389fb971a613a9fd1cb751891b6c145bd434ec1e16bd1270f722d9babce0bf287400fa1d1dc8bdadead59d09ba3f8700c3e182d232fb5792d791c9db890339a6cc9a5a32704e5957bfa487e49efb9457996644cb498bae876df88342cac04d2c9d72d31af2fc4b28bff0c9adfac41a4d2ec558b1318667b099f8ab68cb1cdb1ea302e98b7abe439fb9d02d4e31eb25d12ec613d71708c42a30d7c8eab922b9e82daf1368da61d48c8d522e75efaa46d0ee9d8e08dcdf886d306c6897dc9f3a9bf890c60892e517051be203fcb84e0913438b6d983293cd3d3683057a17478f54c9832ce6aacb1ae1adc0a5ff7dd03508d6471e0ae59a36ffbbda089c6b0a42a6d22a56db6f67303707962689f9152af5a426bb9fda19d94accda03023df75707ffc5e4d0ac54cd50588c79d4533508831e819d585855c05cf99690a3e0ba3e8348ddc964f5243e701ce35fb196e0b95feb31bfb0a9cd293cc8652a6cd80a847c2112552a28acb574ffe8a1c738ce255b32d4ec29e586ff6eed87f78bdf978db19d2d1239213684a76e358acf8a33d1b6984253ff8fd592c4bb02f2fb7d9da05f9c60b8c40a33b3b7d7c30552d4a9b7a7ba5a0435e9532e1ef8cc7a2ffda93f20ea2c86b22ab7a468d02e7465f1e4ef6878205eea63a74844544c6d7855753b689ca39e9e091feb5ba9b8d943a70147ff899a92fcf60e04661784250fc96a43ed8688a072f944ce4cb607cc0db5843c165cb52cfc49654e73a5435ba1c91a3e9577d546a690d3d733f0b8b463496680e267e54b4d57cd3efb3c59c973588980d1f68f01ec0144c868e4943d38338f6022af7891e0166b9330076d43d0a19e38455d263c76cc48a3d2b214da8e78129ac57e5614c56259a102891f1606599eecd744e32ddc8f8cafe5e1e265f90d8609731bfd49b21c1039ba5a4485ebebc95ae0314cbbd313f1edce587004a09fdba00a7f954fbec742f7a2740dfa60c3621c0bcd508dab6c0fc1d99721e25100e9a9254a65e724e4a53034c46ede13f608cc6d2586db543934f8b4aa0e13dc58d79e229f6d27b2c25eb2cd13f74657d0de2a750eaffdf72bea17b064849d3f54b354164d02f2d859636f4b32db7022c12299c0734384195cb3275d4fb19727ee09cab1e24f126ecd2c0781337f9bb3592aeb6c0a64278079eeec106a7bf5623e37c94f1844774098c627639c05e5de123a0ce287d01d023ceb977cba3228fa459474c719fa813980371a60a04d0d1fe0fc0b7797015c05f329a480c0a84c5dbff8eade1dee6215417a4383685d6967e3f54ce4d9b7519796fdafd893a05750d4d83f863f290046be8b1be6765b2a0e8412b1a37763c2a2086006c4cc72af64e4c4f2cac50e9ed3b7ae8de787f5b49e70071155fa36a05d488b35778f443a8fc30b5e08fbd0d232ce1eac55b2978198d52c0323a7228b2b7b553fd47cabfdc90646609a743a138a3a2ca78f8a881fd730aee222536b387878daba0e0e36c038dd67319eb8eeb637e641515b01027d1264af74d31b48da8ff05f175a7234650e6dda5559ed14cc5aaae3e3053100ba152b7745bbb24b3e534fe07122abe079a5c2623c8e720fcb98a32808ee02e39a87581eedd1e2922cb1008a788a9bd4142e2c37133da8f3d323eca4e92a3678324487dbdb876dc6265dd015b689cf7eb35a7a455604d358a487e30c83a82f91bcc178a74986ee8c06a58ce43b2890e4d7bec3ffb8f79c61d6c660fa6900c602e1898d49d04c4c39d60fb0d0bc1a63fb92688b23d8f9feada0de60423877726b407ab111b5290d6745f6e8eccf1fc3065310d90660d8ec15c9c81a00cd207b7fb4e73b52678302e509bfa4cefa8ba91efd19c87ea4947b5dd9687f9f20c1e8d4d9b93959715456de4a807addab5c9c7d6901ccf794088761227dc37beee77707c1fed7f663b5c4a9472edfcea48c57424cb9a5aebc09dd2caf87570aedd93fff283b29d07ef063a78bcfeff1108b982f11c3c61753a019587b3b8e25caa160abe7b61395fc26757cb9ed83251f6e54e69a89ec0b1d2ab139b5b54143a1a8ad1df4bb97f79583e850526b5405b3e2ccaaf92801c395ceb18859fc27b61e184f472207684c1c97a172eb66326e1fcc2c6e3d3b8fb16528ec710c9840b48c58992df16d0a3b87a68475cdc6035f9d0129f01b37fd73ef6dbd4cb4b475ee9cd664cb123bf3523677f728d43b58505590be7b8285885bd00030ca2e802741a6cabb52a2b595eedb608a274cfd20c59b949a3c91888160e0694657200986e420de0a50afbec3adde3a4d0b7483ff74e295eff20e4207e1ab6866ec2fd47ba7cf403c92653a291f000dc72fe9ec5ba08ea2c83e42d27234005e1b27dd62b3005efc32cff989fc3c12a325a8c38a71969da2be3c68560b2648322411dc8c2fb0a2ffb4c01c05e037cf247872390b14351ec04db772c20308b10aeb36d643ea342f2865a160261d3491838a2850a608d665672a54ecbf9a698518e64eecebbfeb7c86966fe3ee8728c59a74787e1365a842a9fcacf0ad761b3d2c9d5e687febc82d30abde2094cd0da813f9d262697cafc1ee00a610cb91ef39849329c667c3b3fbae46e869aeb5ae0eba48d909fd4bb5b64db74e588ca655d67920076bb02e3dbda973c218817db8eb65ff7fa1a9b5c25c7bc30f6df9d9abb67a8bcf50869f0cdf59a9f94702e52169f69477960057bb52cff0eba754dc20197dfd6dbd61b150b384879843a7fb99ad4c9d9fa2f8716e8761b32ade31ef462cbf55cd1f2381eb86a45ae2c3bea6d81af5c9faa4e01903a96d9ef157cb02ecd2cc767e317829c874c6da958a8e150058ed220bf95511cbf69bac871f640970afdf2848a6080e5b2accd45e275c127ed511e5703528f69f0296f2a0884410eaa4ec1f9425a04580c878ef1d1b6a4f3345b1b1254ee5911d906cbab19b6e3056e208ab740906abc3fb89ff164ee2c0ef212c16ea8fa25485740fda43cca31e54d78fa9e9356853ecaa0265111378dd4f684325625b4c58021bbdd87976f6dcd3f3a4a2b147d302d9272373e937d26f0e2b4e7eeb86147e5b61b6da0d62579d9ae7169c0813d3641c8667a85174005689c3def89b56eb2bf2aa6423200e1051fe37686da2bd0712c7ca0da2f5cf93402806cae696c5f045266617703351e8ff70c2ddcfb52e557d34ddb288df0033d1465117b8549caf41ee93f36217b8030fef9b8a16293c4cd773a5bb8be01b913da3dfb5e816dcf539bd727dd53e1551a164418e3da8badcb80e583e8246e6379f8b96f3e20565fabc0dc55b591c8a88a5ae38c4492bf1eff266fda04a06ef196802ec53d52a4654adf1a4e353b436516b2944abfc80bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
