<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be3673ea110f95ff34b4eb3755e4895edeac1face4e62ef266bc08680b97a8d187c3aba31ed1f1f2daa1dc1e56cae62a4f97f2c07bdac6d16594269f1cb88c2f5c420c2fad71b072718fb0a612a7b61864e4879b976edfcee96253e8651412908a8d9c478c75ab78b3d5fb769c74b3bfed3c562b1faea826185438cb2e079a4cec41ad51c5a6b6b8b8010030ac2a64993c99f6209b3c6937e802f178a243e9d6b8dd290c72d2a5e3e4f464fb9fbcdad9e37948c9ac7531758e39053e2d7ea4bec634d9ecf2fe7d28702a22207341dd22f5efeb02c144e4e4f4a367de1b4961f7adc39174b835707db19ec8a4caf15075d9802df08b90554bff982e5bfc1d0f999dff368115d7a19e4c7a03b6ad0953a667853a9a4ecb8a00e1f3e584a2e0f0cb0f4b8be6057f7f42947034e46259b547699f15a44f8b4351cd1ca6e851a7e81c69f296b6282222e5979ed00d194eb02ef5e969eb2366a892e1e562988147a8a296aadf7e405e15f2e7dbd3a72237cf70323e8f01995a4fc34a86c8aa8b743e31ba25f935c0ee476252fef8f62525fa95a5c6d8dec89a870792068aef51f204b105b6fd4b4d7fd82a95f1a76b03ac568c0125573b52c654c6fe580e9b6a24d0575274a1cb3ab3613fbc3b2c515aa3781e973f43c30d19f15237dcb27d081fd363f31c7116f305f2e5b3229b421f58e61b3956a5e5882390bb28cf13c0a63071b02805ba5e1f3d85083fb903ce4d2f85f3641ee5d546b979b72e9d04e414f9a6cf6d9a5bad5326945f45ac8743e0307a743788ca4b0e2b74dbcf1f5f5c105d1a61f0c95bfd7dd4c6ee77cd1879b2f1d0e35bac397a7a7d5b4e97dd86703a2cef262e43d1f8a2e9ef5d4528484997307a98d565d05e4f44dbc3cfbc4bc65a9e5ea04f92a46b9a253e2fadb74ee8560e4ac49f222ec4bc184e070b41b20091f45e60308dd460c6ce60be263a0c0f9704633273462af137e8753e67b7aeb86b1331fc0aba91ab7a8418300eb36a4f5d110676f1829bc607724ae09411174666b82ed3b5223553e13260cbe7edbcb1d3e3c2b65af5078fe973f99f51fbc0824bf534c46d77156a2c94b68bd72d0a10ce7aa949c6ba6644f8d85446397916ab82e65b65ba020bbbb6403a7d8970a0ce9db7c37b190b3e5f59b8d5419911c083fd2ceecc14648ce80a153040712751d7208b022a99ec0c54e5966e48e22864055d1ad45261851e8a3d63de48431a71ed5653148080210346a64fe70e022f9cddfccd462d1eba79fe109704475534c203b2a6b69ac2ed3cfcfdad6aa44bdfde60f72987abb603fff56b7c8257df7a34d3a392333b91dfb126402ed4d57da31e3484be15a7e2558e35e3d37c720c43bdc1d9de0765ef07dd5502c03eead5a6fd18fbe2e23d898286f9a61ce831fbc523a0aba10dd44943ff817d99fe5d4906bfbb302ed19a2b5007aa2dd4bf4d8df29de63272a18ace247d2ebf378b52fd1d1b2dc097de7e6fe44b940c6026812297e5ec553c0158c2c8470947e4f3ac2217d3effd32734107fbe2ef4c29822be6913dd25948641587f0a5cf55a89128ee13a2e9800e5dbd0c105894466badfad9e4a1acc5c3e1d5d7fed457ce8a21436f847752721573a87aca406c001a59f2c9ee1b2f1036d1807e433353c5f76717f1504293c78ed1c2b5ba1c944d8f5ff77a1e66c68e6742524c53e2039d0f58f00a6a3bee66bcd4c4fb7211d1a4785b2a4b111186adea04e217dddb0c5f46be6415a2c8a973e5702adc3b0121c341896698a4d2f5ab8bd5f0abd2c12c8a1a5eb0226d15dfff54ad5804f9712ebd2c0209383cf38c15565ede9b90fa53cb76cbe9a872d74beed9424c703fdf48c20f7de8d676c091038023c5cec5772a18274b51350f5d661b0b74a6bed6ab9d8d193f421e998928ebfd244ef506615835e91d437e8968931081a9d02bd84484f3e176e7ab7060bc9ac588b04d9e1f1bf98d73104485cbb21c9329ff941101076e045ed0187e822afcc20d0d6edffd4ed19a88e041396bdb84969ed01cea59fddc635df4f428709380a66364be44763676821c09935420bbcf78356856a42d396f021d5052aabc814db65a2811c4f63008504c9c27ef2ce9f4e82282391f2b097148e026637b451f4631b19c48f2c5ed8208e4c83f93577a19468bacd71d279de12dd65207b1540daf426ebfe981e000039cea6fbf4328ef5c48ed9e816f5c045af889d134b70d1f9616a4fdca6eb94c4bcae4a15e4c735c3560f067acf39b0c8e43594fb329db8b014a25cbc85d9e474e807dc57e4b5ddfbe44efd06d8b6e276d575217ae5b090cbbe78de1c7e2440b4237d96ddd5f46a677fb85a86d24babd3d529ce9128504bc9877b1f48486821e9ba1ebb0cb6d2829ec5182bb51f48cd45d3addf5588301e5190e4197cabc15426a313b57753928fe3cf3cba1ad547200864dfa5e9991c6ea4ea459312c0184a8bdd94c7438873d2fe8b084fe6ed7abd14b5cb7abc6f4de11ffc63a029ef15c67d2b5f3411c96ae0df1be846f985dd4264f42e9e2d76e36e0ac5d875fce658072e1c993f360c437690f2247469ea73c6bf85e42fba15cf3bac9a08371d25d1d0c2c4f5bc3ed3992b763eecaf3ce26a33c1fda56ac6910b1b3afd8484af6f7d0c691672df529902803ff3179627d875aee846749409fd9645297417eddb2b6015ce2d2f20380ce072791b361e1514c012ad8f73869020a3003072d4114d290cd78ca9b0764aab05250b48af1147cc693b7c4f7f7d9f28001d666318bcaf7802280cf6e74adc46eaf904a7e2a4ca475472f19e8122b019d7e0d537f5970b3232c53376db3f9cd297a83ad681e1e6663b06c5b99da48479f02e73c8efa30b34d2fa94a91058b83844df56c3ff443ae0e0df39b4c0c1f3048989bbb70033d1b71ecaa64d30452121dbb4abdc91a31bebdb75fe25351dc5b377accf4c6e9ee83b311c48716be3f739b31c9c8200590934e7d4e8575656e012b25b16f7bb55dc74c0028259fd7d1beeeebe67718b1c10b59c7601707fde4a0cec5c1b8e69983c025d5ae39eab111a49abce31198f4884c9cad6045f61c5a0b4171f6ba85bc24b7ab38a8b6541127abd26e6b1205843c1e891e9f2793001bbc9ab19b0f76bdec9eb1ad965318542b342780581bb4dcbd5f84550105d52cb5e9de33eee6b3be869ebb7450fb09a1121c7be357db1a93f31a01c48d78636f7f788d9e7bbc1b9f20eb702444bb9d612a5e3fc617d8f632debe47aa863d24fe1c2c4f3a315838a1571d87910e8c8e7da920d3c777ecce19afaaed261c91d0b1ccba4aeb3a0dd124bb8e001e4f43832c555fa1d9c35640a93532bdbbae0160514a8a03b2ad45ba3d3a1743a0ad73af29ce0aa5516c193b2eebf196a41c0c42b484dae1a4d9db1d2ebf5a456db0504f4e1b306c82b735eb10f9984faf20c0d20903dd41f103c6fec293eb6bc32996d608d0921d7079f71aeb154404d97d573164cff5867cbcd07e69121fbe90e70e471d44b8a432ed3aa175514334b673d0cd868a9a9e1c9773ec5790d100e08b8e1277de5fcdd9a2ae116390401abe4c3edb0be04351b8e3df3b4e5f4a5f1092b1e323f57061f40fea72c5ad7acdbc18d8b040867d29c6dc8a289f0814e16d0d825a4044ac8ea1fdbfea5250e07059f6e8ebd13171ceffc42ddb06d2914e28f5f71602386988707b082d9d7375cf7db9ad519bde6ded9d51205c25860f3c14355ccccab0d51b68f889eafec767f8db05cf5eff4040339864cf7509d8ff8e22fa20618f53f1775268930068421d4479aae7046bd9f8f9c52e130783b495a2b9c49097e1abe8bf5e3afd6262cf16fa1903e80adcdf2891195dcd5c84032721bd31a5cbe62abdc89d0155fe74edbef2c35f82d9d728cd39fb686fb0fd10af2c78a995c204b739af56ffe7879e56e26c65a0456dee6215fe3f928453d39e914792398fbbdf0e2abae66318c9523d21bbfca326dafe47bd4c83b267d0ec1200e76dcbff4cc1384cff168f02908ff2fc1a772cc535fa0bf823d567d5d2d49b6dae0f4a648d7d0944837fb60e836fd7e24660481378eec95e02c7466f390b7a1aef25fc1281bff3a9828717255e21c60b589cf8f139d2d8a2726318bc92d946e3bda86a7559adb0b421abe15084a16fc6b2c78b429841cc8ed82e2893e92496a75a8a6bf18c22454c8ad017d5c917863e367d3998c77df116640810384ee380bdad31cd327eb32150cbd49c2b0cf5804760b253eb1971c360a81e95a5933ee605973eb3c8c18b74e325673723aac66eb0d76cb931584b273ddd9a84a99df13bcfb02c975554e6dbc8ba010da781aea92b132f17bb05a6a428204bf06805d4b87f6e65fe3a309c035bd0c3a369f16779de8322db4a25266649ab88494e2e8433820b60655fdf856127cbdf73147fce63c0c1a0b00d98ffc39298ad14ca199a6354cd76a590e2313479668649c5e574d7c4438a8f9230110c730ddfb702a2b565791b23100bde3f5aeb935fb42f74490eb4a47e6a61ef39827290dc0892d35f3547f7f9f71a5ada18e527e2b91cdb865fab83d611864541744a43d432fa0b9ae7980676135567b42b483d68002460799e1963d5c1d23b44af2422f7e366c25bee39517f601be802142c9d2d343ca37a54de0fe6227eb0d6e934aa76f12f3585379f62e122b63fefd720c3eb949159e20c9344d8e3e031145c70724b7316909c50170a0cb7a39f62dd10451b3ecfe22acdab3b729b23dcfe5be9af3fec8f2d753a8c079a0dcc25e3583ec2e66d7e165d270e8b9ad95859e8640c54e78d85c30f9debbc6c6b873c5a26a1932112b0f9fc212aa85da7dd03086ee06a8417315779a48034427373a3c23e2320ba9333f55a222e089dfd7b1c7381aa19a1a6977d7d554a8a1ef31e8946fb6dc0015110864bd58c6ff01277a062fc79f5742fd9286d68696215dd165cb1c433a1ca590ae492ec3afb1f28071ab84f3f48878d4eff7f84900f988fd63b289c466fa39af23836a32c768af8fa5d0f39a326feab903830afb4ac875888c0f962c6f2fbb9ec2f0c426fa4cf00eb1ab8df20414c8a4e3879075dd87146dfc7c869a11ed98035af0b3719da90723046d71afa7f2a2fbec899ec14deb2788b19e47ee1475f9d0f298cf01858b922095ac6f94bf050055672ae55e683cfd928ec266d8e011789beef5de448629a80387db42dd9f2fb0624ad4eb3e322ee7bf2b88d2371a22e7460f32096a75b02e85147b3ee2334948673d7a6f1572c6ca04245ea3f73119b614c2ffb37c335c2b066214550d1535bc899af7c716de29486e134467a3b6f42557709ed8dae36e7dcfd8a6178b8cfa84da42cd0952bd2e03491b223144beb9fcac9e5fa703d1635657fb8ab42269a981dafeb5d8771816ca0088dd9bdbc85e247bc60195b91fe7bb56a56b04adb645a1a5180956bd73dfd87b369c70a965b320f721de1115a749bacc0e147b975a640f42b5295151f5b9bd2ab1411f5be0bf9e5c18241e6acfd7018a337a7da2a017abf45e1b49ee2f597ab262234a40f82cf9aa995211ad35dfc909816fef6c50b39788adb9cdccfcebfcd8a1432b797966ecd8bb1d7f40a2119470f6006476c08a2ec5ad0a85b664642b44c2a69e2bd28d3afd13986b0df9a025fb3b6041c77fcb0cf4aeeb08b8dcfe218b8f3a745e6b075ef4c7fc23c5c50d8ecf842cef7413db1257b517d47d88b3178466faa63b0213b71f743a510d9b6e453c381d902c9589cc1a1fb1fd4f607acaee6d7bc59db870fc7eaba2d43accaee4ae92c50b3dffb9a0f826135d0d8416defdf151fa137c6893aac0c551342af8bc1da47e1096ad438c62fdb9e15001f15f81d1e549d250fb719bc536c3de6362be90a37603db47ab79b343416f8217b0d4111186456e39f438ef67fdde9dff3e9020911d7b4a1666d5af38dbab2f24243728e704466c255467bbcce62b771f2e087f331beff5c86b35fb5d071377bbfc89f14ba012ab6081106d370b15b49081122ea525f89bc6a6fb195c9f5899a4223209a7e580be395799cb3d6af721b20e055c16563c91dfa43a6047666a33ac83e1bb4a6675bd596551cd77c0961fc69d54a721305a424bbc21b5265ef6e8d99b881b8e51174d8ca06be66470d1cbe4a6096d1ee648e5283cb366a2a3da471c6d1dfb47130890cfd6e598facdb6d080537ba2ac78cc554cd6fc3ecf9a42f5ec8e71668c6b8e950a9e9cf7e3aa24234e87ce0d4b1d02af141b340201ae92214448dee1a080fc08c0e2e44b8100d26c4405b1d309a7ea0776f245bb9fd3f0f5efad4abde4c96030fc10446b617c3f907d6c66b3bcef068306c283b819bb3cb84b6cafaf73245ee4eb8df71d6e9e7cc0a7bdbc69ca2788aa17c84059fc85e21dd58ccd4579aafce333e9fc066daccb7bc0132500f9a78f4d6185584bbd57d6781b850fb95eafdae62b79a70d775fec19cd689f387dfd33dc17bb9bc5d550c8950471242500e629cae1d4ce1c3d986ae81ab18ff0e178e57e853f3a1b2ba3907924efe20b207f57ce45818f77d093156e0df71714aa6fecb8e46aa6ddb673033eb8a63c7973f501b908441e38095b779013e65a23830426253857d13a6018386266f089d61f5956e65894346cf3b6c3afa0d5940326218aeda30051451027a947313892edd2f9a0a15eceb9c10a82c16a60757c1b9cac2a8b1decab901ceaabb9845afe05fbdc56950f6190d2674d0e7b7fa5082f183960ce7cd8331f53747504f8f35d74fdaa8ecc0df6bb26cc8845a3dcf689ae225946e4b8b7d4507d95c9caebb458f2836b1acd03babe6388b0b340044a541cfbd238cbc038a96a7dfe81cf22ca519cc6e1a8f8bd035b1850d5a0edc8abc67cddaab36d920e5614d054566241679799f4601654d3f68ef4a6e2d24f789b52998ae6118d7b7c37d2159b37a90c5a56dd1099ad2f59cb889ba405ebe7e7cb41db1bbf72f00b1854c5238a303cf4e56242c640b3c3255ce864281b849017c9ddfe23f0c65a4a37d3d05045c2677963a3d8fd6f657903eafe04a902a658c7168d3991ca8787904a9c49d4eb502af730c820dee9680d63a6860b9ebd7b2bb365e37e4884c793249ae6cd4a9318de750c2c74ff6017ee1c9225abbab0a4362f07888c521acd7d393686fa6fc5ef98a522f8feb06bcae29819bad1e7f63dec48e5d1db16aa45fbc0ab5779666127e7b9d22dba05de39e6575021dfeeffa4bb14e5fcd8e42400f6d528d12a45ee8316f1eca8cc75b6f223648a22105bdf65bb240760b53585841bd7cdbd35e8c572187d35e69f8a46a5f24d25f7873c429e1cf6f1b48df1fceb45c4e15743a5b0a615712492eb56bfd7e4ac3f953d44d3b42e8bb163d1b15bb10f343a1f6b5b42b7948e71745d7706415d22a7335e748bb431307d9fae024f8a48beaf2526b5f172925713d594db059499fb5e64efa63d04ef64f9bb2ffc37ab536e3292342991125379e56259dc81447f0a318df71f5ff45675aa4219ce1ef815e2243dea01187a6b7a3ca08a3345996d3497d83412e938a2a6e85e8e811a89d3a8d109f6311080fe50b39d18da53d54daeeb5a5d3595e3114107f60819d1cb2d22f81188f903cf719428341c0aa5c44641cf6de618a0ab7704c96a5e5431ee935527cac64f634934d227527c16e621e44f12e5370f2e895b90d49af05c6f650884244447996ec8fe79f3aad2d6cccfedcbc96c19482dff28c1b58d20ad0184cc053271210ad71fa4f2700b8da9935f66a5b9a3d9e34d2644ab2fb094a79d4f26076ca1b9f05473dcca17bfeddbe369acd17720a3cb85169450491043eb308662abe18fc77ce04ed49138dcc196cf9689b8ead297da594e8628db325e973ed77479ae796a7142476c01f9f5558bf3ae561fbce5b4a8f1b0f319b6ea08e5276b69d8bc4595c9b0202c7108c80ef5532fd20b102d0b49d799a1575a5d4d63d37ff66da4dca978bda11641e2e5c44e1dc996f564c6ef8e09e489c4668151717d4de53e93de046f41d1dad0dc8257478acb7327d4b765648231b4d36b67e1b6415ef66631786561c0321fd7db97a826f65fa98a7f255cd0c4ca99e97bf42edc9d58bd3676e0f2c31401bd46f5cfc2b8f3c2cd64495c961b2b955e379129dd535457386140c5856e77745af6087c49365152ef2c87fb63c21bdd95c6a393129f07ff1e275e2b7eb33840610d1c361623d3059e5d31ff3134b3fb0950cd7929b402bb5673188b84c538292abd46e8dfd8d8d9830f6100f8011ff7f9f504f90b19062d84fbfc43a1f90a9b0e4b10f9bf3f9a25bde2241746b4c02ebb0eb8c097e3d7ee49f438992584fd874e48348145ffc842b97cfcf9096eb3bbfde469c550cd0d0e6fe83d1f9aabf27943cb0015995940a98b93d506e75ad2247d48f67664f85da38f645dcd3b82c22821fd37d95b081cb433360c6ff35ec0be81d5327f70f4cafc510ba92ebe4ff1ebdf864cad5f8d99cfc9d2bf0c2c95cc5bb63696b4696a39fa83f61988ffa9303e3ffdabaca8b4f50f11a9a27cd3345de15177c825bb871156de76205d699ceb3a0c664a41144812470b5bf2f12ed88e397ed09db8fbb1d7c5b0682837ec92181e3dbed10fe8b6290f64cda1b308e96a74cc6d2b6027c704635363131c72ba65192d220dc989f9ff0aa47d29afd5225517306228f4c7c988b10a8ca3a7e27024bb34d2ae09c05c55a3dc5e0627af29f58423297e1320e2ddd6db9ae7ba0803bbb9137ea0203dc17ff49a8dd07015989bf2dd9073475a4b4a92a156dbb134f6503a878e73a4ca21b6d7cfcd1e4ed055956c1c73c816499d86e1e54db20cb908aa1cafe768ca7d291655cf6489c79dc156fd5d1b2923f7698a5a02cafc5565217322c8fe9a4c9006d63590a636f2b346afeefb90396679013df460ef0dfc90b4786a8add7a68de486749685a19ff976b55a1113974d12455074b5b954bbabca4763dffc25f3dbf08931855d4a8720659a7bbd0b69d8da4f0c83d671d50e8409e6a71a9c00c09eb1f80e84d6dd98168fa5cd0bf126fa791713a44fae7a478a786e9e1eb10fe0d183a12922e460a93856a33c9cd45a0000ea6b6625f6c534b4842babc65f19706f29c0766afe99051ff148b040ca16df37cc4fac909d646b3300ae68be8147a09718e3454bdaf2d3a495399a93b136e21be86a3c0342b2d470e4af3039e2ad1ccc638cd684d3febdd5cee9bfea63cbe3069d66bece31411c12e4ecdef70b30a81cb51e8bbef1f0e127e82f167f951d6f0dba700f99b2af186a4211cd24cf6681e50612e2a7c861e34c54367be9b1429967354a6ba580d20e287cdabaaf3ee1a0c5f9a71df816c109064e970c9e2484ddf7175f2dd34c6bd9b0328189e6076b4c0b045e38bf22b8189e93508dac1b793fa6605543ae0a931db15cab6b6a0f8bc185761b92d006b98f7da8ad6219d33fcc56c4436891ccd00f310524eccee8e7e23259042e541ac4308e635bf0c485b993f46bd79a2e57c332124b8c6c644fed31b90de95332705a2732927cfb5cf002a6235bdf6fd31a54755028a4d6fcfc3e737f1e666c4bcc9a629a7bb9beb32e758bb2455bead2c653438c730dae909615427040be1c03b5fb6b73e96e07aa31144ba80c772bbd6d2ddc2b2ae976db66b12ca253215027fdc6fa896166865fe098c76851f97fe65bd4411d3104f08b869511dc68fe3e88ca6ab48ba4d723f6ad82b82342a7cea8c9cd12e4f4e434d5abe1e6e583ebcd057c6d51764b64ca67e666fe7ddc3d9c316a5f309a0ba3045de8e8b9ea096de0b0286895d0e3359fd595ae5dc96cf1525224b29a4d9ff7d845c52fa559fcc5595c58683f4972e1e7ae61203163c9b6e7ad9f003ec7644d2201ca05f99effce14f465a9622a73e16345f93dc160a2fa960fcf54553121cb8f78711f329d9be1e410dd07d8553ff67a5b88440dbfa7dfaed8fc6fa6a2447da35dce4eda65e4b8f7fc453067d6e8ddc2e952a1c5f2faec0c526f0f24f1f66110e8ef4d2afb657d851a8b32d66b066a09d42057594bf32c223f7bd9199e9ecaf6a244261830a07df86149bdee6ff30060cad7283790fca46939f3a7e63182462730094d30695ce9ebb9d3c8e59e3469aeb18e6ff32d0626a5d6aa7519cf2b31b1db72a521453730edb7f193c429e391fc773bf5f93b07862343798dc00eba0e3b73f68038d26c27a050286809de74910650c51c717b56630b2997aa911a1438aeefc13f4a2adbff755ab89c42cae5d96fa4fa9ba0469109e13a3495829883fb341afd285716c2c9ab769ef7ef09402ac433b08b4191c199cbef6d4127be70c9dbf5fa38b9652ccf3970cf08b949136aa5bb1649469b493305a5b39f4cf5c0c0e118e3a0e8b8a3e9bbfd4962a7eecee551dc8f5419b6f34decdee1b4f804d0ec4a59391588dc7777f053a2db9d8f6eafc6128b6a382bcaf06fbf99c788914a008bdc7e838db10f26fbd09c4a8308dea3d3a10f72854bbaa531097e6848b8dd32bff45feb08c572d5fa64a771a82471d60d8eb92816ea6fde946778d01c9a9ea350946c7a4c7dbc496438b65aec644dfa26c495ce2259fe5d3dc74ab7144bb7a66f1070f59344aeb89709f524e2885a1e85eace01a9fce096f3a70df849d267e8fe6a214da5a27fe2c43a3052d473bea316bc39e61f0da7e1064c64c33f5ca50a0123e5f52b54b3b5c37a9dcf91501b41fb36bc3d7db4320155a3455c7fae5b8186dae7cace5c5a04214296ec58b94d525ba6b458f8e05ce3281fc2d2573dccba1e9245d472c1987564b82453abd240779fef406c3e797fd8d8ef6f4ae2916a9e6cee77bc88bedc0bb88956310a1d16f45e0931aedb206505ef7f6034c8efb0f9e4dd04190e805eb065ace1f365eaaf2233fc816d45f259afdcbe82ac3c8bbfef19f121e481d9440e5b40ec9d9fc95634c845af5594f9f40dcb4f73251debe7fe1cfb1776806fbe09124a31fc53da90a15502e19ee0e9832cad0b67be44c1bae5d1ca9823a3c6b03800384b10898c96982a307c84c08336fdf06b01f532563e0c334dfe328f8bd01be905b6382f0b3ab04c608a4cc6b6321f851e522b0eec7c2f071edce6054971e441da45c8661a81fe4502f20be2868e00e1e49f93f6cfd545377864776518f482559f0b21975a1b72c6926ea59f51707102c61cb0884ce916df58e26586bf0590c00e6900766f2287229263973c3982636ceabf20fad3c18d63656578a4ed0a894bec0af1dec25a5ccb020782091e857e0d5224ae43a55b7e7d97902d43215d54ff843517b116a85b185927b93770b54f3f58027787e3baecc92c6340a2217b3967a8ffedaaee4a00abfcae1c4c5e7bb6059c18fb696ef02b81a7643aa9ee596f5f0dcd42941fab7c6289032b03b9dea59d59816942c1ff1477601842e65cccfbe535594b8fde199d140f2236839a7484ebd6b2c43a768a472757decb7da3018e1ba2425ad3a1fa55fd89bbe5390bb12161e952ff778cca64b6e46682ba1fbd4f1a9130a1cfdd30c4e38d82d8febd871c6248c8ede1996239260526ada0ced5c0f9a043cb945127b522556bea089aeccd2305c2d739999af3fc99be0af5d8dd4bffd69d74df3ed0e2db76b919c7c4d010fc4c11b2ec52a72f7cf2b5def1a8b4abf21f5c3caa576fa6f51bab7b962fbc2dba2a4abcca4c4a027218b5b162cef3f5d047d679a5cf8b20b03f6b33373a91412031c8a06c3b5fc4263402da2500593b02eafb94003097e8ce9f1bcbf8be82e07ec1c190f64834090ea4f72c7191b94f57574551689a5d0dc681e09fe7f0e53650291da39f6ad5087a15552cc6c44b88f97c1153c9bb9a139fb105ca35f0e5e697aba307834725fa54a426bdf236e39f00ce8d6c5a080342bdf125583abbf928b7f63e709ad745f8df6d4e0ffd2d8ad278543d14806cb613cfb3f1024f3ad331a4506e7aa18c795ac59854929f0f21a4e5964fa28f4270157d35af52bf19a90fb2d235fed8e6b5adffd1fb030d623bfb33dc99ea3f52ee74f38e3f8dd0199cd91f7c1ea16737b4342604fe6a2ee800932992b3a43ff0eaaa76726ca83ee813bdb04349b9591c0fb12a91dd8bedeacd4d70dd59d4bf94fb1307d6efd22b2d87e12bf61d2a90289927c69a46ff9bc3d2d11f32193e94471fa3143539a6c9e63f954bd047b2937bd2dc9df1edc3e8ea90d0712ffea844236158ece78b3e0ce26cfa90b9650dce7ac076383a13a440f5b5b534ab045b48be5426e9aadc1a1c9a8cd74a666908dd971eedf5e3b8209910de71587ce139c3657a8c31851d227c0b572ebf84dbadcfd8ce76d81f3220cba87a05816aee7f49daedd44e9af6f17fb60d7303df51d3b0eb9d4d802fd74e49db7f2a0fc2d5696505a932fb1677b9b258b02e62620ccb2f8dba4e091bf28fe48ffdd870eff5b2eb9985ef1dcd36d98ef075291f92d284811099083543f491936181aba2e725693efd170dfcedf6abb216096fa09f837f131c4fe63f46518b4bf4424fffac2d2441d217be94d56dcad721af0c7f7ec036c15789e77d870f0cd27e08309f04f831cb8ee81ff01c2286391e67b4357ded44d200c23ce2f3c16f95619630d145066bf8064c5e9ba65cb3af841c890270ad0c095d423bc730cc032960d5dde6dc7b8754eae58cd0e3f9449b1defc0bd1d20f3e7efbdc50525cdc8157b45670ef7f597d6afd294ce33d4ee55997f4e2c60924c3eeeffbb838f9ea777900b52a176ba389922041059b9a970a6e830f17713f04acce3f6244d0ea2187032b28002ada77b9a0ecdf2d117f6057ea3644fb8c94bb1590603228b99f443c2603a46154d987d4b6c28cb7ae7ae94979e53c3c7cf9c7ba745c8c7c235a8f05b8205cc6d0204df1e127c6f8f686787c29e299f51f9c88d5ffce7ff4a0a1cec1081b234bfcbf203a1a955ca8e27c138b1c34f78cd3c4b3366cae55cfd36abd7072dd805ffc48cfd028c28947f8eec8d1d7848679d063dea5655712dea183c083b366d7b5b57b70b40f9853848f6fb2d2ce2bdba3332258d093554d2d75d4d4bda47f7b3d458145576a0793abb91854f838f5a3be6f9d160da8e57c1a06ac1c74af7a2ae20d53d4acbec1dd802de2d9a3872b83c0ba594915c3dd59401a83319b76ad2a4c95e291c3369d5e7707a4acec90a731abe6fa7b63dc4c75b72c9c0e4bb6b29f5c4b3bbb5c06314352fb204c1e0b27e85d527384d0ebae12a9d3cb646476804e6ed869d608d7002bf5b1bc7011e57a0233ccd8ad1dce02659e5a3126e97d69493909a63dd34eda4cbf2ed167a5c858203068932ab1bfc28383025cd3baf2c75bc2b320ee97fcb5ef22ac224067e4aff5212528599283997c5afe508fa45b9b13e1469eebb5c7f6ce19abc1afa7efcb01efd7ae322e26df3b12763fab5951a7e4b313a7215eace42aea5de478921c18b0aaa3e62f3734d1781da3772c8caf6bc28fd24907b247d741eabd539f0f266e6f97cedd6d7e21ff7094006a1154e9686a0a14e643acd75d8150d3ff37918f2d25a8391d2479b77b6cf384ce34340001099d77987f5d30c89b49e4a20784e60f47246d12520800b2a64e8c1521a383de64eb9b5305e149a38e4534cebbb085c4efbd6cff8094665135f4200bc4721c4b7b8d8c007d04a4b32d607ff212c1602bb59919591623eb62aedc3cf5b2b622c1fa57c9864c76fc973a4344e15fc96464327c3c9ffad19bdd41e31d8a61afebbb12929b471c07bc958de92f108aed57dc02a4015deb0024e01846aed716ca1059f3628ea0639f71e916567165f14d94ae9dcb66125da78a49ff48e56d322e9d4fef696431c58fbe008a8c5b6f14db9bc3ed3ee14bba4fa219b26bef407a5b8ec3e57e141f5433814742d2926d4d277ec62e71a50299b4fd5738d72e8e15f68ae999293290ad9279cb5b60b6bc35390e00c40cbaca3a81a30075259aff3055cef31faf44aadc7226166f80eb619e7ef2660161dbe5a5852acf1fbb4fea2f3fc933c5bd6c1a739bc1fecd63514be442643eac9ade901f518f9d20842b07740c6fd061e42318f4ee6ec2ac2a38786329fef12b02eee0919067937fbbc92e1129f17e0c12e3a5055d64b5802378a789121fa4d0fa46d15892dac33ffc2484ae0a9c8324de7938e0ac588f4688e7cbe07bc8d1a8f4f32f303c5edbe66da304c2709688709d328513ec79239f17263b644d6bb4337a7e8dbf6a7b78c02d79297663dfff9c8cab3bbe0bfac922a3ad6ee2f4d15c9fa704989697e76fec20b2da03ec96f1b4c1e3e8d675f21f711cf7634f559a42b0a1cd0fed6d41ef7e903bf899fbd3ff542619997fe7f50dbfe9e756204679c6554920fe1e81aaee27fac911fe75047ee9febff0dbfaa72aedf96bf53ae096ed1f3057c7775913fc718a2d1ddd2a5974e1fc601642847a215a1f27c028ff9ed02ebdc2b1e4b7247dca78d9f1967620ff6c797c3a68e6027fecaf32b198ec0478f72934508749265977d78ce1597626f87ff475af22732c5a3144e567e57d0719850bd576f4ed186e57d950d807d0ea152c23a89d75ae70111efb1226b5e6d2d153e84f8f0ba4b55287239db8810948dd7f63b165ca1a8d67f5cf9f1bf8f25723d3465585f1c5974ba923e142771950bd7af44ea85281f7957e980693cfffd735f2d7d52b532ee8bc179983dc92eadafe93fec6b14c463bd2ed023dc97dd3be437a2ed9bd8051d4e7b1ee3d38f7b160073eb9022a80e93cb55c821656e4b7ed1804979b016a228d8812516ceabe2226fe68b11320688c4f7aed113642638689eb4a592452983160612337e80eee0e3c1b58af51e91269f96e73b8769885c7aaac75962ae6d6b6be5490846bf900b47dc92345f2156f68b2573acc73eebab2847baeed0e08d2d045c55b8a04ae3d3ef1e256056df0d87bef0f07f840080cfffcfa6aaef06281bd6f9f44d3e1b9fb67f8d3a677fe4e0f4ef547d4b5b35e71fc4feb9f398deae5fbb9bd2e8ae42395183a176f591a8711135c601cc88dbb19ade50ccfa6c84205f54695d61e5364879c80f37844a28ad8fd876482822dce89b4a55cde4cc9e22e9986d4abe80e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
