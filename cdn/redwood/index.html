<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a090eaeef0fd88179981213fef8e3227beb5ea9b7ccf3618299c4987223f5512b374b60706146b94d3cc9571224f72b1286203155b2d35c77149d64bfc91fcc8cfff7f456f155b31932deee01af6ace0ac7c1a58a65bf7b92a42cb123e7bdac392fdf4365ad4fe99b4f52641a348bc0ce53387d9970e626827bb4972ee4a0b7645c3bb8ee43906c180945cadde6715dafde2d030f7338b1c55185e66059834c1f6b121600f594d36077bb9a642496814221f405cd8c8d1045fff7631e95f5a50bcda9021df73c71ba351e8f66f2e7614e9419139ab0ce398b3a547ed1c7022dbc9cb97084f43ebf04371528e87c46d66e3b610577497feeb582f4452b29441927e11a646c1b6cb5f96589c1ef84d4c154a8bd4b3b5887948a4282326cbc118c9bd80d1c267534e146da6e15a9f915b77a2ec7b3bb098be702de82cf33a59ee2b97a47087670c2472ea699b11c3771053fa0b7dd2e786529cd1bf5ba47e9e70c9b98e41f49443b57a33f836052167cf5f893f64689d3b5c4c2dcecd58040abb4d6753b9afaaa9e42cf3ef32b5fb662a177cb5bf2fed8544003b09247932e7fd01c24f7614cc0c8938cc47fa71715b8d6d0b1b32501dcf3f56c58ea9e9cf50050465d7898c03296bc1f79dcd4583de24e18d555e00a074968f0d45e69f52190d9b5a043b01a9209be9fb782f9a843feb07f4242af3ffcf24aa4e688de7828af3db8762918d5ea598d11c0f81a8adbab3115d638018c7799790220b20cd46001f71f52114e1aa296eb43e4dc3fb91a5cc9d28bcf4aeb1c3d89884f08f2e550ee7c0fa72d12e44797fd895986bfd959f5d59c8ab82ed7afe156a4be9aafb0010bf02a545f187d7d72599e0fbd4ecb1c4b58dd857e0db282eaec74a60169f866823cf870b4ac4e534e3b722360b422489c16206c1392b1a2478c3e7b08f5b518740a2985774265d98c6a23f53ae1d9939cd68d443be75cb6757567dfc32b00c86f1ddd49701ee9b55a0961d27eb6b3f589d9632843494477fd26c21508e8fd84348d0cae9ee2cad77696e81cc84381e6fc5bae7e6c3d9840c86276da6003753465d9e5eed27ce1d26d3b271418e50c267b23790cadbb653b08c436518c06b03ba49f5f9400129077e19447eafae50702927ff44aa48d03dbb434112dd0360022f665341959d4c6cc98d55905210a89b0920252f4b3ef73cc58205f50fc63af1a8166878d9bb1c75e926dba244100e5f59e3710dbb57ef414744555040c0a699983e3e1ebb8d3eeed53ceaa2d4ebaf78ce749d7846903baaefe8ff3e3f3f9fd22436291a9c14808f090075ef1c2d3925654e0fc2e297a56149db56b1d0085ce4b320bbcd524b02ba3a1e19a87c03f8f7a71dc2a9b61268dd3c75eff50e24cd35f750c5d6cdba4505beea7e791328630165e31d25ee01c9721c5e9d923f153a5e634fa5e37abdf946082f8f739e0392e38a8b35904fdd6fc3ea9763d44fa54170a4706d5205f5dbf84ad90069337505ff1d4b41082b0e31d969e5bc37965edc86dcc45ff208f2d3b15408dc5e8a74b7e1207b90a472187e035de08083437dc10f69529c0073067668dd519d3020974ebcc92db5b534e6ec5bcd3026942c5b1d089b63a10ead4642dc509f2a2040cde10b2510e1d082bd81659c4e00905660c43d261752b7a7e2edb007e02dc3ddf6aa8860d149c99624ad85064303b77469aea93946d26e5a9728c72bee58e0d9ab2055e96fd66730a80137da9a6d6cb7d8672c1fd7e780d98f5212f02f5aeecc57fe8591b8c9a6d452a76e59fe24b6516ceb9a7853b1fa588aec339b3d39ea0184ffe27ea631b9d42edfdc9c980f4afde579a389bc5100b5300707ee11bd570b34094545b6683eb3a5569883d8c6c5e68dcc454aaf87a2c9aae2b0da9c8b90eb77faff9acf8c497ab5fa655b3bbda3871c89f2a5ca31f0f3050af5e89fb3e6c18eda441ba0c9daeadf39fb4cf74387928e8acd4a06d8499969892627ff89180ae033931bba7d10db76c5edeaa49a0a7efc8b9542151b07dab803656c9ba0263997c67d63c4ee77f16cd5eade0989d8219df41f48348ba5cab58dbd2ecb7b8b4460118e84bf1284e62ad6d737e2eade0d9aca37c82f3debf1e8d1df9499ed8948c13a18c77bab8815d427213a08ec043d2733161d77ccd7d1b57930e2fae0ce89a9eda097c050dd558e8e25dface304f000bc71a8fa5f88998e121479d23f94bc0fdd224c668daa4e3d5aed01bb1b770a64dbf9fa08821eacdab557c3643e1c9017fda6ac1d421611f5791217d7279613d2707a1c207263ceb10517c3125d62defb5909658416d6e46a509f9b05dceffa36b89e68013cc3a850b7de9cf2f59188014cb3f1616f7dfa4b304fcd4b0178d5756ff1f6cadd63dba07051de027d2e57cd33cd1bf85145299f59207d4edec50761d7bd88ce348b00c03fde68856be5baf9f592541afe6fd496317de504f34df3c3375efa084bb20ef8f1357aac9ca44857e2e6c9d6df999f7975e58a1b289c8e216495219056db0e532d0118e85981bc43fb09eda76d994d6c2c49f7c833a02250595c74259e29fc9bc0854d4a4761946081c001ed114d9d95908f26a3927184812dd084e1483e2a1d22d1cd3e5dabdd5f20694e2b7d7ef4c96c7f64a6f9be8db3e9cdef819052f2c8b67905d72b4c2d7501a8b223113c01314378d3fbf16987fb2f47b23de9dcb369e33086bee73a456bfe4dd666164e2321e175b007db23d71991fb74939c8b3386edaf84a3900edeb54957c38ee6c72faca2503825ef2509f42f809dc50dfc323aa5d88537fda38dbd2598fe49c96168de52e6ff59612af0b352ad44d7b7fb2a7b3fa69e7cff522d38a26fd3a8a39e0ddca66df75d59a5d3ab1584c1e89de279c9c01c86e138a915d6547b0f6ea960c35437ed0b20e2a46f3f1c65debbb2008feda9a16941cd495a1ac2b14334a276edcd1e0b09997bce9a31d30dd1c813ca5e7a26fc3fffa236420185d70f0a506b202922f2ae58487ae21c7932ae27c41be5d90287fee04614801d9f0d9afac218954e72fe4eabc601f91e74517cc67718b99fbbb8bb84c5bb714f4a5cf74612e99a1113d48aae0192f5d8927d43f35694a0b9704d30f92380ba2c0e3eec89f4f184ae939bcf3d82f93008d2e3cae903e2f8d040aeb84e43c4e847bde5e1a7d897505e44ac678f81b03dfdc299e41d5260f042033f0c3869e5ad6a1acfa6e380055c2eeaa4d6519a6fbca6cc260b97a65bdf0df375f66841e5d64cf0208194f3c04e08ba9ad3ee785b093ef3ba3a670450f757c9b1da1ac25d9553b81ad7f0285a556c51850aacbb21778e1db0924fcbc53548412a3c3439437bbd2f78320fc76f2e1ac9f044baa57d90c394e9d3a4d1d1b49a5cee42dc8b280c86caaa0856f37248db0684a392a2d7cef2c2d0ccf4929c8d13f768f5b1c64008b5b9bbe95a394677c1063776ab754d08d566cd0138760c04b141bfdfd578c2d93afc2cfa18d0adb3db925a271d5864f5d5c0a6f694b5d8f623ff37e7fadd2aaff82ad9ee196c666128e86d743331f77d036ae5b7e6734b5a9f4f80fd6e5618dc01b1a8a9d3d4e74d9f6e8d81df45084fcbe8a149fdc098ef339f8370fbe7150f65c7c6d7f672ac06ae167211d546d2eceb9fc12ab3334c7dd1c01772f195de0615db3ee5358e1e1a51446017cc3d233d26e273c83b0a645dfbf0840251757573e216e96acc85e8d96aa301f935b4e257635227cca5b9db74c1444e516867e1fe0914be3578d484637706178224db1b0fb49cfdf88ebe34f0d95dab897129c50ccf776d31aa988e2b95578d691d186fededa59e190e95d60b4c856331a991773067330fdeecfad72858d8c288e645145bce64c585021b6dd3ac2ed18ff8daf14f2eecf97cc8e3bc56297502dd2f71ec0a4e7ee18571a04b7e262bfc1059495fca418207ea095077429c27aad0cf1f8fe9d550e70d27a26a533fce2aebf47862ee6968513e6e61ba921fb12c2b5b9c075dcac80b69b3979e90ad48afcaf12f8b38d57953f6ceb34f8379d22046b8872868a770c130a2685ae1590fef790f4bc1a27368f48dcac2c68b00db673ea83449bacf314cd13fd0b6a872c87dc4aa3d39b6ff5ff13cb0047ddffd1ba7b52aebd6eedf99fd1c17a218700d7c0976bc3dfa5c612d5a3bfacd7543bd13835d92302302d565a52bd6a7985ffcd82e425a99664acb57c917004e172b0eee28fddc95283ca3976f8358543c4813949a1599e553827eddcbe00025e9ceb07151909f90d869e84e5b84a4ca1fce8885190f01c34610c116f4fda31fe5255366ea937611beac6b8ded839b85f899a2a35e885d1b611b535a69fe642a807a51523b8b0b16579be31a303b782fcd4bee8326bbdc7b9ef424d42cec2fb8565fea627f42b01c4a0883e18b54b719ffde30acec93db26fd5b62951f62c780e75aa0ba4494b30c9d48817f5467b30c2c42fd9659d39204ac58b74d9d6b4f09649cfe8772ca17c042f3bc7519185586f77673e5a807005c62db96f8d4fa3d0a792a13798f1807411f028eb5194816156c8933eb6b056908367ae40dab594632b34a43dcb353cddf6e768baf6d5867178af722eba407dcba01ec9a8a5563ca2b2332589e518df922d9fd827ab424225e7eea6e00a8c41d3dd6957d605ba35cc11c2961f4fe9c175fd57d5a04b81c4c4096976026cdae776d6a024bc0cd305aa48ef90eb82b064314d1c3174d4b02f6c3bcdd8884d0f68a19febbca874fc89f27d7218c710b605c685db83c6ed14a7304f5b99431fe236573c15710c7e5c41bcaf534afd7a6f9ed1792a19b5b93d6919665c5986ab97cb96de98e47ae0ea44350909fdfcbc3c9c8062fef23dcf9ee90eeeaabdec12df62d282e1d5d95ecd9ee0bcd759f903f6ad9d4e4e9409d3540750a9c84570893bf223d29006bc9ed1d3d5342c8634ca6be22749d41d28bba343ac18715840892fd43c4224627b68bfc9f777d53250f146222710ba236e13409b371180f1ca939665a9f7fa92722f4d35fe1cea1b214c069034153bedf3164ad77b2edac9c9a95cca25a4ba7ddc86039428fd7449ec690b7c4b2046a6feff88eb13f72d3ca9bf656ea087354510bf766639521bb4e84f6377663efe03d5d963bea9f32164401c719c440b627c093e712f4bdf6b95dfaf7929b27e9e0afbf1a4a06a3bd274df898271e70b2451dc27f57493cc4a4ce92dc6030aaaac6167ce54eb1dfd5d92a6a433c80896e9221b5c2531558e42687ecf5322d28d5924e0f641dadfb489d7de6d1469e7a64e34158dd5fa0fc95051a109de31e0c87897f614c968532b0f1c232a805f04c656b3287e7e80b8914f3fce798a479f2bf46cdc11b7a7012313415ee99cfaef9b498870585a7acbc05c6ca6d1dfc1cb8cef860412ec62b4af430db03f0080eba6a49c566d88a9ac998985f526246fb7a18792c5278dd871fab2a65f8b9d83d188080687afa4e9ce4a47b29c6e89bc86ba91b7a1897a35e4ec968f091d317780da29453c4809bb82ab57456f085396458a752d5e6da1a3b29b146bb283683dbe5e251bf90ed016caa663edc96a8dd3a4f82d2956e4c2be7825e82cdd0ef8c1f70bd41ddaab5dee1c6808bf065319111e380072b91d7a6b219c7ae59e2e9eb3abd9c8018288923dd9e5687beeca5a678a7c556f00caf035294b9efd777d81403606cbee0d9aa0a7e8219ee15d25305b678e22ab58ec55638a5373f26d8a3ed147cd8c1f1f0dea66b5e1d911cd73d496ecc7c4b9834e14869f62d3dc2c82b681b81ed59875f2f81905de0a00bea8ac5bb6b2abce76fe8446e0d9f856f4943175987f73bbb158610b730242ca99641575885476d979bf55106e82dc8e01f20f183ced03a670bac594f2dd84111d01e17fb2e86d0aa08fae5bde309c48cca870a2a211ff29cb72dbd4fe26f1cfee653213436113a9d1a028de39169c790068fceaf3ff8e2d7559b0d89c6c3e24fdebdda1c1d0fcefdd0a4cad481990ee2354970286c4aec030400036ea709ee8f38419bd649261f73ac72ba0f72411e5e643bf7a31f97c8f276ab1a6e8f11f15d8a32f6de282c0d7d10e7d5e347cba6aacd27eba3feac4ed442d801e99bcfea879a88599ff70e4c4f13f1c49613ca060f4957acbcb3e0570bdc55ab209697060a2867bf71e356bfeeab7077ab192de48813ce9c495708b457f84795e443356e4bf87bcc2485f68318b4d91f2007e05a8ae1b3011115b0fb880a0ec3452d8c3d608a17ab974ec935791d8ee85c3137a6785c6ad56e8f1f9464d20b881204c5e2d4c062720aabd6d639ac192d5af8007415f264d250fe176af9c7d8d8be37627de43f2cd507c3332867dfeb76ad4893a001bc7b483f7eb301124959b5e85276fb95d7e8c27d299e6f2e69e9d1b2178df51f08d45571863969079a35a0de59b58eed355d570bc255eb37647916a5a448b5b65ded33326d17c9de7c5e5e8cc9881200b3d07048d961b409c1a09f5161ad4cbe1ca08c56db5de36081b744bf455c9b23f91431df03ee458d3c934ab22656f2a708ac649e27412bbf137b9585fd87e8a24a285755a981d631ae500102d87c0236bedf2ba9caed66f770e69c3800641ca26206ffa8e840a401fb386b7907a69cbd9d83726aaa258aa1dc090f3b64771f024dadef227fbe21161b5c98db37e130e8aa6962b23bb807f8481c0b5d4c1906fcfb73f054471c05f1a078862584fcf8f5e034ec0ba1967af15738700343852330a9e9c78a1d584cbd13bc7f760498f2ddc08b66acd21a3932d82d2164a2028a8bc96f17b0a5175c4a0aa08b72056d286d900204dd4d6de3ea6146e75dfd8d030e5aab02003257c00e57fd979678d4b8d80a8a9965c90c1651c56c63e532275ecba06199721910a595f8d988063afb996c3bee183882e190238210c62a00fc6f7d389e4ba9ffee3948088439faeea608ee3694ba4c4a030e325a38ce94e889d263495dbe533469169c8ca4e80638392d801a43cd5b156ca94f995f8a81c7c83cd957edf95b1aa1d577d441d05b01a78e3ba4ccb3cc2f5016981914ab7349337c48a1b03929521a295be49fd30c46e1e0338bcc5257dcaafbb71268094d2e9960a0f87a3848dada856cfb966ca18476f840ac3d646ec206caa10025098ead80d631956da8610d993b0c3e889b10e10634103c63fa648af03109f47eaa1e993a8bcfcfa29c16b854fbb01d5c76797b82a0bd60fe23619b4a3e007f69ae9ee766a0fbbbce408e6319671a8e545bf89b6a7ff29ee1e73a5bf3b4fdeba6a10cf85133ddb376346b25d5fb6c13d28f1acf86bd2e35061afd427a4d430f4a1d5bdde997981ed6f120cb3a39e2b7f2b956a5c5455d3520895286520a415c01c71013c35b376c73c9d6df0a2029b93d7cf5a554996a82e4994d85c217ff4315b9fb5443aa9e57ece18fd394b645a1d4b74c568c705147a05679ed80d8b106ceb0f5dbaeecdc1479f751681cbb6bcac68161fda7e0e6875a8dfe1c207da1e2db7aec55cb62291d8bd5e5968dc9c121abc06957386800504e1987b80d5ccfcf96cf69bc126d918413581aa0b8d8fb33e2fb6b18cfa3b110a7207775a8b77df702272b3442c82cc36c6a4af2f2c37184d838a3d9d73fe42892311631e63f016798826daa206ff090bbf832db147a2b2ac839ea20f3434bccf549a086281d54c20aba53f53292777744722f0698fee69a3485a76df0da122d94d1e6c1edcba6c1bda32a0dc369d9c451b94d0216f8c1fb27b729d73c6b24a8c2dd6524f69f6ad73f355690da9e999c7ffa64f09a0d10ba18c15daa8bfea3ba2a654a84e76bc5f623e61e6541fec9d1cf44c1b89bfce40a0725a87b7f76bcb869d0a4cdb6f11c797bf3c4d6ce1909aa4994d37a2b85fe84753bdb77feaaba5da3e2de3dc725d889ab4159da369102bc315de195dd11e3bef852fdbab82a6beef7752befaa247e431e2f128d25930fb471a5a840bb5dcbb13010bd91a251f039d0bd068b9e6111f9fd4ff57c4ce71c2339e9efdf632d60979e67b0d3fc49bf06b8e5e70406d7f5540a2c681420cad2f143b450d71cd36d2a07dca95da516cfb48ba51bef9a5f4dee619047b75e352f0128245fd068d6f6501731372e542e0817198932aaa78569a766718cd7ae358a6bbf82044a53c1df745ad9c78e247b96b4df6ad62808e845ea8fa0c304340da28fe3391961c75853cfdd274faaf321e294c337e915407c92df86c7bdc530be6d94fda342402560163e039ca3fd85f9b986de11ead845479577dd24fc40f4da9a77ffc408d0d06b21f22bc8ae1ea4f117563e7e1a0ba1c5256dc8619352bb29938a37f3f64e17f1d1dc5866f7b37e9700aae5950fea7b07e9285ceedaf93b539eb624f7a6460b9a4b8fd18fb5db7efbc09b597c7d7bb8de80bbe79e1f8dad5fd2d6a94bcab24097b495f78fba1143af9923c47127a8b2ad569aa566add7976705064e0b22cdbb7bf2b29adb349f9d1985fc22a617b994542bf56107772d0771988a50721ab7b03a53480c27979a51660d57d18a97b8730632160c86d5307c92875b9252f033554a036261bf3e889794a4bc68600471d9a2b96254d8967b011437d1bbc37fae28ae69f9c59780efff5b1f2c24c8600f739aea233d4d1e570b83e45fde874b23bbd6af25083a02308864acce3a3b9b21687011b2f56648d8135e08493c94cb6e3b8a26611f84a85d89e0dc099da10b2402f626b54b1c1ccda1d048359565595b542c81a4ae1f97ca903102e5fc5ba0383ce4a9299c518c0ecaa9bb1ad974dc12c16583598143cbee890ee7145aae1f91dc49765189187186e7b643d1dfab262cc2813dbd7e4b47849db60f45b71fbeb3b7e691c5be22af8300fc952871b904c6c4d8b9acd1b44188d396f1815aaeb9765b14663d4066e1c143af52d080a685f267ca398de5795562ef50890eb88cf232d90376bf795dbd1b0ef10844e0f34d99060e12d86bb2beb72fa1c457737966a027181de5c5c34a5b524e577904876af235606f990c698c6ec96e3b5f6698157b8684b7881d10e79e7f6b99e2c3fda0d48a82c7f27f99077af622ab7685b94925f8162b03a38db0ad953daab519c8c927f442883d149657e021c487b473ebdbb72f9352c5035276ab4ad626b4f0e770001372cdd76a9f941dbb04eec46c27ee7bcace1570d2e0f8bcca7ef086453469ba8d6c08b2f300aab718d13293ffd4541106b885a8a61aa5cda6d72d9e1683a8edbf18657bf8ea9fc5e26c18a817e6e22f08d76ef5e8185d84d694294e92aa81b4dd8b6eb7cdca025d3ff9f97444ba9ee2e077d012f7bfc6564dcae728877f727fa7e46b50485dde1fe6acf5a0d44a019663c81a83190847ba8702aa0055faf79f411b13c5bca562b971893b53eb60bb36dc8ce36e065b96ffaeee70da8515c6abe9afc3f6fa7068545ed81f6568b75ea16e987801a306456ddd7833b6ecba595ff472709a3b4ad96a4e92e185816be67da1f4494f6cac460f60fd659f14e5ebeb6f4d7361f229a63839a08d9709738dfeb010b3ccc676a55be0b058475669d6f1070afe699a79a7fc238431cd2f8bd2059aa2c4baf0fd0dde5c02452c7a5f3b21d987ed954d13d8e69ff0863f632cef517b5a62663e1f0711e821442ae2b9996e156168fc1563d606b6da54bc91dd7dec84ecd338af425e9c4564767b7e70b910bcb5af82f84c74f071aad3af92c28b28c80a4967e70d27012b0050bb14ce98a3837bd233f708bf347bff629033372749d08abf71cef6595f2de19a7902f39a2ea78ea4d87b9087a2db3e98728ea84d98daf27532046c0946cbcba423971f852eaa194eb0dbf0e625d03cae586879f5663da4143d9b7a795eb9372b74512523919fd1924962daf66da47599325e23be72e478f3d431794bbfdcc80de613501927c81be2a48a5bac0d4806dbe0aba6870f21c43674d943b8a1f33e570705388cb9a000828f1904b0e9d02972bedb87e46c31a7ad2ae60a10c364eb98eb15a6b3a7dc7f8898c4dc8d81aab0f0cb7887af0029bf85b3466a7927a3fdb63e9428f938ee0adc279749356f434be45ccb903dd4a8c5813b648d128098c62f6c48afc1ead1075378fedac5b3f80c6b3db4ee0ecf5cb71f60079c2348e2fdec89b7a1f111a30f9d0b52c32b50eb0da2f786ef20d184feeedd0feb7d76199deb5cbd16f9ba3fcb6889a70bcfe6fb8d23c45591019fd103db0f7a6697764cb864002e1713a11b94e72edd2804f86abaae33910764727227b0cf2811d77122f5a731d20dac3ccbc447d6c52467b95ea4d932b3b7c91836d126c0ad498d2b5d9df0fc1446eabcf4c50e315d69c370df3f831dbd4398735875dcab7f5427a5e6a188f589662f959ac1288aa09ecaf67d85e1dc00a6bfb740dbc0cf70080436213e726e451aa7b19ba6c5da1d3f8df6a9beea34732a92e7b24f6ba7593d64d51517cfb7e9eaf95a1fc5d55cada05cdb212e356f9d57d6bea39da97d5da89f5d1c5a74fc68ed1d50b44476dcfcfd62bb8399f37a344be3f87aa52389acc61b14272682f4ce805c86de5db80d1235298b5dec431eb9056749cdad8ddfa9ea4bc39154c1e4fdcc6037bbbe15c6306b077dfcbab75d7e89da104a7f25f96cca8e36bf6261a4ea88d34f2e71da57c4dc36daa3da8074a345af8309c77499153a4f4ad5affd5351da806958aded695c2166a1f61e2b385ee95d1ad4a4bc7595b228bbb1010c7bf287db74e74c65a143d98925a8cebb20097d6fada87ad542a622e435503f0d9318547a2698613974afeaee222b15732f16e6b29010a00945ab8d81d06dd7cee80613de0b6ef528213569f73cb1559478dace3709daa7514e2aa0c997c7e036692cb4700775a760ad46989f1b644c8c1bbc0edf395c757214f93dc70bd13779c5c27dec605a515c521d3dd8c9b6cbe0802495932c41dcef28bc1f8e9acef0bd611a8a5fd4be34bb73bdda1b91ca193dd0ea3407f1c1c8ba84c078e67796382f7bb4ce7fac61746481c582115a7215384b80ad8c1bb8244a1b7b51fce2961a057049901855136574d36b95a45fbc8fcfea3286c72e4fe0edb62e4a00b9d53e95f5a8d72b440f2be71ec27e6762817129c8264f675fbab1750fbb99f04bc81d48295ddddaac513cf1cd47c0809a0c33fc578a2c0b3f1917fc8b72b684f88daf959656790237bbe17d51277ac7b1568dbc4b4e00757520ea65afe97c6a95c1bfcc839ea4b0fb4ccea15549a16e79059b6ea733ca4e47109f6230e51b8f519f051c313ed2be22aca63f70cf58ee92276b121cb8860fa709a0a190cd1b3077e3513d671fdaf68d6d577d1d6522abfc0a2e68ac40b91299e08676f9e25944cf50eb91f97f9b7b5fff27eab48f7c83705488f9a553a32462f66470e5cde12484c06f62ddca6b4102574f5df61ac57d199cec20b7d9ed9ffa0b9ba16d4be4e9f1f70bac82d80e3e7177f40fd321a5d55649d50d70609af702d933bdfc67cada788fe4d751e4ddc9fecfcd469bbd1dc20254c4c431e26d3aa862133937a701d6cbaab858c78299a02ab4559f833a6268a4eb60748634c94d03b4e4ca2688ea0de42e1db5da324cb06cfbb0279602163b7d766eed405d591ed8c8bfe820ce6f37f060968b7d6e78fa3a2c7cf543898ec7d46d7c6bc8530b64e9d8e1f26a5e4169ae996a836a32ba1a9077c712dae9de930f465a5714ab6625aaf6882d4287b129b9f6bb6a98b2c9c1c9be50a4dbc002fe798055b3d39d1c3ee2ee67ebf47f37ec188b954b361f45bfb4b822a3e491219a2a9b0bb8e4c40fac6a5263f5e04339c9a6777eb93d6e190ddf321746a501e8d22842d777ee913fbe0f8dbd4c96746994ca433aaeba923bbee6e43ed22b94e064b232209a74d9a2df4fcd078b5daaa293fd37026ee292642614f55c90d1a25ea91183675627914ff29e5137bb35f02acfb4a04145f912524b8a771106830d1e9ef8557fb1004dc0bf04bad5ea727d6535a5cf415e3051f75e8a3260a2cfe7ea441e82928a802ef2bda6947b358a0a3aebcbc25793232827a1f6fa147ac87980a144990f140cedd9531c2f29f52be0a5479d56cf8858bce8a911d5b2c7e60869d86a8aa707a6018602b0ba4d9f593c8377b6b575dfb50c540973a2571026cde13ee98712b80589f40f06adfe3cafaa590c0165d287b1fde5d2c69b909c6fb9ebd4f3a04f0d4989c5c57ad5f6bdc0679b9e3a996de8677153078f08f5f824e5ebdea2eea589e0384169c055f02ea27bcd50087ba8a9c06ff93eaeffa5547ea753284c8bc49d59c4a45ec9be220f9fc4326cc16655d004ca353599db942f4c65104606adf01b1d554d749081040637a1c4686d2c586e8c9e70b9240128386d69332aff19fd35d685bbc438ca79a7ee881949e49a0a5a569000834fcf40b05e9aae9af4526f754b02104c44e68ec607545bffd60d3df54495e5462bcf02fb167a86629ebc8e2338305628aa14610f93b64a0280816f8d80a4c582a3844d310e8bec64501acc2c978ef84191ef815f6b294040ccac305001c395d6f0b79a20457726e856f5b26f29983ef0694f99e89c565d15f8fd856c3a7a56da308445a8d3f16f01850ea241e5e06b15ba3c7dde809eb0d7fcbe30c557b141e916b39d8d36a7013f1e2f6f52eb4c8a451a7c4657ee261ffc95769b0e059a53d467741079b96893f3efe59792e46b71ba005f3f788591e1f703df72160da65eb5fa5045f9b693e8473fa0d86539801a0989f604ef9d06239f592a8d7f67299554197c801d454e22cf6a45a7ef26d49db10c2a8c7367a8d6a0dbd90e11a57fc64f4a9a06ce63332154e2ed8a927d66ed21c7873d0f777447c671628959bdaaaccbeb5a2bd2c4042d959bff364070723b31dfc688d08e84ba78a7883f493792b2b18f4373e0cab76f6a42aa62da437bbf79c857fab8d14e38f0eee055c538b912a7f740c15513f99aa0672f61b8f1356e9f4afa4f31d48928f09b51cebd2047ba264d35eedc030d5e8b2f2413a9e607d359a25f75d5e8a7bcdd69d1bae6da6b1fcb2882db5a198fbab1241177dd28e0ed3621b3a1d36e7824aede836ef959d232cdc3792c39ff7be4e4b848f638b6af3a3a7ca4c8947803acf6c457f5b0bc0dd5f200c3d27bf5eb2ab6981ec368fe66fbe7901c6244e7e128e5534def78337b347c94fddc5aad59b72f1cf844b7ea16538af1ede089b49504c1c01ba1eb5498420dc219c9d6af74261194a55165c711a183e4bdb93d507b620b946bc6c12a3fb1703f5ac9a6c797fe9846e08f7d45e42c44301cc9955437b29da504f041d8219d02803cdcf0d7896cd0b8836943bcfe54ab4ade02bc098b90142392602cf8c95f1fdf1e6148890d4c0c57c91ead2e792e7180ccca429e9c4de903d122b3d39044ef80372407671c4bddb0163cfde1e44305cff7afd7c9e5d6c64eebe6a9cd550842d27c6da9eecc7b6b9cf61cf17f19032cefcff0cc53f288d929753e78fd08a7f7e88edeca93d994bee9de578d930e9f307b15819e36e46b8c09277ace6f2e90dd8366588adca0e961e6edb0a510cddc84f2845c5d66b1fc59379c8696ac61884d3ab4d64be262574bb36f1412ad65937741ec66870fc9b5971df292f761d7f72d591194c6600accdf76ddd7dcfcd0f58f7c2086342b1451a25dc32ee0affa439c7532349ad336128b10f99efe63e1e6497d4b39419d61b3a521e6d0dec8096d597c13ca63e88344bad896f116df305c45468cb7264adf54b29201a35ee4e73c615104027d709c366f054ed89df366319db938252c91cdd63013b725066234050979f1fec27eb775a763f1d3a8a91f3ed23c8dfd619b1a41dc10b6b09935fc6923d7f696b63e4a6e97bdb0dd4fad78b60a504bd678ba7ab5efc8da07398a909b03e6c91be7787dc5a923d92e8b4380a61f78c76d40f63214f60d893e44fe9b26003fefc126f275325e44630a53c1d3b51d6cf25b9c7fc0ed713f8118c05348b001fa55af1b622b3a7899ef70ab2cd80692a7d44407ecebf07525893429e62398214b45236020bc42770566ee5bed775062b873f16dccdaad50c9a40e6e53b6c7db55755ab8171b3679b7bb97f69db77d7d31a48209dbc7a366f952fd97b2d86bc94ecbaaa0d847de4f57c2d77e040650b123976b6595d58718a904e252fc634416a7cf4e978d9d389a8568fd2d002ef105bfc55ba10cfc02b8857d1157feacf7f563780b9c4d8e1b7b0deff597541229a4b4a8f9a74a72432c1a7c6cd995e462978d2e0152f64c90357e55a84fda7e90b4d94087c0aece8faea96c4035f2b6a64f0ec4d0bba25deeca6e87e7440864009c7b0796f2d0a27b912830a0b43199176d0490673472fee31ff231f4cfc822979ff62a878a50703745629e78ba443fd3b24eb77cad47e6fd4f21b36f6e1026542b7a202eff715338ec14d35bb981145fa4ecb62c2628e606b57809778a3dd10c4c004c3f299268ae36291f15cc6019c5807cdaaa5831e7d16bdb0cfffd055099fce04759d04198ab3f66067cdf1c1d731cf7f339da87705bfaa6b1b24a2513c5ec48be89fb788052f00486d50177b7c8b712f7d9bfe4b0a7656bd11f74b072f18b43d3b987b26c616ebb4e97212658661531900cf9d89da46329b62a74293b80749a99106735f0706e157f7c96b2ece3353b00df163dff356399c7fd573b1e000867e8afc979765640afa79265af8beb19eca29124351793de383db83cb133288b50a61f7684d8f3bd9c89c7a9e6b227c06643839bd716b2f6d00715bb815b6ebd4345258d2429170854edfbfb9c741b0d135d52851ba2250c154ea85aad014e2739bf7cc0ec8f98efad80075e37c3e91f525d5b576101325ecaad418c9505cb27d0ef80a29210ca0b15624775c04759aedd750f86a76467c6e97adf052b59e398c8635c12e738cbed3e07913e9360b804a1e55fe7f4bd226ad04e5131975738a97b961869f310343862b50dd9fade4aaa69907ca67ecec1402f5636b6932e98c1f09cf4345995cfbd8090da65143154964827335b02185bc79000daa28faf0904380acaabd5cf640465437f16e69b5aeb19facbc5cf2b6b63c5c9bcc44f1b06c7e664e51864eaed68ab2d41017f9759a3bd959a48a86ec6e0d47307f593363a78c20c5d551e9db5b8ec6f7cd3c493cbb7298f96d91cd3197b248b199eb778feb73c7ee290c3c5a5bd4edba90514a1775ef7bd88d250f4354f9c2a0017c9782824feb443b58a509fe2abe7439a87cea03ff771a7cdf8f23ee3d6daba1f97f7ab92829e99a037052fff557130c89441e6ca58a6245591508e0fd0e886a060f9282de3124311af3e408e8a15ddefbae1838237d2b639e3e281ca5fc8ff245517b975450a1056fb7f390a9be0dc2688e6e020c71c624ab6c8fda1989664335dc2dd97638cc4dc3ff44cb698886623f459e1c262f49175f210679dcc27704daf11ec74fba57d19d2b0dc38defb64ff2addae0dc703525133594bde4e92ad7b266eca80538931a887e14a94fb9e763c809ec9b03c0a083171790f88cf260c83d191e5077c51b58776bb50e0030d53d6621fd7f9498000f9565a3881afe48860499f9c5b18a5134ebf30cdf8e37dc7cbe1128539bd0c95d7b993e4435f90d692c8c04320cfffcca184b9425a0a687e1249ba2a760a7f86893df213450e771aa026ae627007083a4051f2337b30bb20eb0231b5e2dd35d46cb8c6b9868560392be4bee5be65fea7cf5f69d036d42138f98f9c5defacdca98f4488bb3730d35cd08fdf734f5c0cb074c4270f256f4312fec9a74b293dd20e0b33a3d53b59f5e7fe7686484f304b82b1970ae76b047f0b0b300c4a6d051bfc245ed0ca4da5661f950fe0115738c7422be1f313720ce3b5dfa0fea849b5b776f7b364eec2f19994cc7495ab8a2fadf7eda1246f37ca0f4416847575e06b50dc71f0d5ac3017f8256adc53f23d56b6fc3776f0d14359fb705b181540304a05f781aa1fe3286a0de485b71106d75ec965600fc7ac41371bd879d4fa414f3c9ce84a97b4bee4b1ba5075878f6e2982c320cc5efd14bc75433d08ae3ebf5e4ddd6864eb4efae1fb1abe75af3eb26bd5f9a76ee384105ebeb96f42d703dda517358d50627de3071420c92429b117f906d18a410431fcd18b1d7392f881d298da38956990e7b33e15f95751df4f5f41a275fd48b51733a357e1dc8fa7b0938666de11f28218ccf6696c7c84ec3867fcbcc6541514690ded4dbe3f77c766482fe081f7b1027e49b98e7f8e7aed9048d9444ecae0ac509e23d3181b8018eea4be5ed85cf94c7969eeb62604561548f2f9a04a9f6094ee1c4ce738f3f8934f6ff55a165016b24392201fbbb4a89fd3b2181102940461ac7512ea617737f92b13316bab24edb60c68dfa6755519e5dbbda29ff73afaf7e78e0061d2023c8dd6cd5592edae73f73fe1fce10ef1e850710ad85b14fe3af4183ffb15348e5a578e077c0d9cbe036f56853ea8ba40811091ec52a38d2da4b9c6eae373f3624767d6c1def6768ae5529fe66a9a4d8eda9316d36ff318d66a1708e89728ae825c9f6f4ad0bd301ddf4b165f94d905876844b6bae8c71ad1df69330ba3a854555496147553ebaf1b5e87fbf7bc6fd10eafc03301d24297f33d14c5dbddd6a70bf9c2a101945cd51accd85ead90fd94291eea14de2c454ce071085e17b3dd5a01c49315387e60295a56138c8d3b0693ffc1dbdb3efea828592aee9e85b82f8a79b01f684ef3f350e3de2ff7fe3ffee9402ea065aeed677ba10aab489268efd074770a3a0c33905be2f3a3f8b0b90144dfb90bb527f9be452e4c7ab03d1279237ff20a2d097bd9b9aad5312f7f2a27c9617912ab6d013ea46990b64ec31c70512d209ad29fbe3607143f46e2a45e83a34b58ee262e16c15deab5de36b23e07b94937bc7bd989a63e181a17309ec16dcc67f345a3dc3b93869dba16146d36eb2bcd5c42f54a92f785728fd3c93969c4d0c5087b65fc6a1eb1333fbc167b718842aa5d795f460b9583ec18e6accbd4e795a7297d05d56fe166ced117c3598215bb99aa422f27c7c589eb63cfa5d067b6a38d615e356e10202db1446d53f4bb79919256843a3e695d5d79a5660b4f8b7ae2a090a6ab35fba3efd051c580fc7f3ff9d1f28ab26b2d1273164c4bbaf8e6c738ff06ad8482d6ed78c84b1a49d89b7acd75512d05b766f47e41e1d6980fcf9d9a2db1463d530a529c73094dfe51dd7c1c885ca4beebe702eaba5e55e049ba754db3d5a7a2d7adfb2d7903a5080c0a02f883d6b56ce427624e45bdacdcee82ec75233b39e5644337e88601371ecdb16242cb8ecda486e4d72e0e98c7436511b6ddd534762636ee3b470b3ffbb7e8e60f251ff7e89e6f8ef305ed8271bf8f55e63e83883a8f27fd6494ac890552c09ddc4f808655323ba3dbfd9695dd313351c81095a94c438f0d7b5578d04d0715275f128e6edbcc9c0947bf834dcdba105244ddbfeabc39e9c453a6d5e5eb221b9ab9e852ce233cf473523c08c1b9a714e022b7b5d7c05d23b18090099a1b2859ddf22e5d9177d572e39bab8bcb04506f5f86c54eb5c92a9c6ce2222c46781d5f5c4c9aa05a9152c099e0ac5da26131b0ac8ee26a8ecbf0e8ba15df46da6532739ff25b8575377674395840b4e0500294e67a1a1a3ddcedb416ff774b2eeb1aea9a4813ffac42ad34b1a34b814a80a2fbc4580236947744b4209a108bed5ae3d5ded5621f3d676d65d8a6c7ccebb8bf1961992b90142b4167c9585d43f55d4cc78eff27d7de7604f206ffd76715c6691924ebf8c761d36ade266a50313365960e83e6155c255ebf423cd10ceebac92f1f8aa911f2162bff71c996b4fdffaaf680e8fa1c6811d6dd78b42c2d8fe0782e309122c170ee5d796f2d7201c0cdcdb0eda753677e195b585160c2f97b0067fb0becb35157be831992edc219837b3f0cda6fd69f5fd17349c2db10896e91dc50f517f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
