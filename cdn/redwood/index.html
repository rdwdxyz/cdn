<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"686999b1a3858a32b22cc1350c2a14170e7350839a1a2dc2cfb9c207b811d55607d793b07e0fb28eac6d1022f1e4c6c23b4a0ac880bd28f9284ece97db5516a44e37baa26ee96bbf107b8fc4382da2f1841ef18de033cd812ca69572b71d90315abbe12b958bcfa143438552de429b04ee910a75e5f069c755fe82dd010915f5439af753db38f9dce6bf9f3c1940178c618a6f3a7bca8d5316ee6d6eaa3c6520830494b499a5e2f780117cb7be0778b3a4040dd77ebcda0ec619cf38cf8149b344fdd32d7a6b5cfb58b31d3b88ee6a7bf5421eca79e183a92d733c6b603a827bd442c5887b28749711321242873ad2ba3787e8a6891cda59eb106bed8be0419283b0a270a055387928f16ac0c958c8c491ad7ec8fc4ec9baacc2e48a141dad3d7468bbfc9ba1e0beb51436f1eb265c2a1f16cb4b3d85248938b34bc47866b0c7766399c8f7fbcd417c968b51816d5b243d76ea30957ac15950120c9ee76db63c9a14c05a076cfb074465a05bcf42e7ac13da7d2de298debf124194b017a776dc59a3c6e6870d5976541e6dcfb2b3935f1731f839d5d632f91c2253e0bbe654cf44992bb675f917a2aa9ba33519f2f7ac3e06b2b5abb33a2d062d60e129da3bbd9acf3b25ea94f53952911f4f88ab5b06c6c66e7cdc8385fd6fc6a4f94c952c05b4f61c2b07d2d35ce6514c1652d0b64e006fc03d5a6d5bcecc98f9244dd6eb15aa87ac2ffc1e9d48d8bbea0d82de94aca1ad4f007bd712eac6a5cd3e93d26f401eec98210dbebb2976062bd295310a1521cc6d28053b0ad20422598968aaed6d6b43345a57fae19a43f7055cd2bb1842e192fcbf699c004414927284f366b6132847c8745c9b56073a690b27ceaf81dcb585527cd93946764fdca5bdb8db7d0f7192affcc900ea9b4857b829c34130812c3b1277475c9a2cada1653a57f563266972734527d4b26e855e7bec9825a1c0311cbee8e7d7826cc71b2520f56a93ec18d8c15ba0730c3b1112685ea15e36a5b367a6ffbfd1e64498adccc9f4b436a34db05eceb6213529f55dd8fc85288d97cdbeaab8bc4d5f1626ad6092ecd1676153458167fb8cf377a18789ce9dae1b9d05ba2ebec5a4a84844f7a8afd79d4c5fd53ead7e2920dc08cc94430c3839e11454c2d448d20d318f85dea3ef5fea34e10bba575eb4605e69f7ef24108d3d088fad9f03b9703bcb3b5e7a94bfe22f0783be6affd9c122a5eded393790a8ed0c56dde857dc4935acab6ac1877a0e459f0eebd25b0d68c5f7ccf17bcd7ca17d874cbe1e8534d36f3b5f91077f92444648b853aa75d6b7bdcf67f63f4c1a8355f4627e40a3ee438616091b2e165c3265af5ddcd3688ef863d5eb10fc021bbdb08db99e8f9926b800627b5fc688182f7c096c39185d18a53d459cc11ae49b20f863d160021f1a093340ba92092262d5790446ce0a1b3a20e4a9c5ed8bdb74e4419a6cc58fc89f5e2e15061e98f4a6eb1f45a0e2c7345c600966bdb7bb8c4fe76d0b3cd9a5d4245602cb797043daa2cec1626355988862503d799bdd4abded60222b9346a48f8991b79adf651425693c2fc3864e0bed9e4849f5e878657c9f164d5cfd9788dcbb80bb26392893bf6fe43202f54ef1bbd7286f0e704992364cf38f17f03fad15a63378d804ae690879e04efc8253f66aee486ae7ba5a8883aff3be3030c71bd82ba6a6e68fd9dbde5892957c105f47191e851ecb6a62b87df8d4e07cb3952abb4f4073b6773dd6e54ed08605306e95536923e92d7b9e4382c6c1180e6d2a03a6278a9ce61dd7768e1af756677bce7b06fe569088c87c0c37c0d7fc476577fdd665d5d07a3220052689a81da1196016f705a763497d49dde100155bfdbc27c202ff63c59fa032592ef21455e49a2814be64bfea67d6fe0c2f51679a1dc7f9eba64b84d25168b4eac6ab5f60112e6bcc64c216fed2f7613af47388c5b5bda4e862821ef9e08aeb412e3df77143ada2c9d114d687173a088a0ca5e0e19539b2df8524f694b94256cc1eab689d850bacbb2d28258a0ea5ce30078032b1916e892c569af0a6d0a74192cc0c7eb585ca82030a115406ddf8f052f89dd38b9210c1c877169a7fd0bdf9341d28415956cfaaae9f0eaef636934078fd7b01ce9f97711ec2250b3e0f37fe39774d4f5b831b7b73dd096ed9a35050ef8424a90c3f5396cfa20851245ac71c8c43365edc6c1c0445082f0e3f658293b1ac961b99b073381e0ece3cf3f6a2cd2798e093da995a7ca1b03b574e50ee8e6d924b8c41fc7df33d05a7a05d552a3fb4ac2fa02028c97c2eb70c4774fd56587a04d1c86bc6b7f5b7a1699b1e509eeadedf60f9a069e8b53c98f181b8c84d73fa919bc7ce1bb89f1873a06fad0019d49ea61597d39b644dae5fb981a7cd78683522e62f3bdf10c2a0c5463420a00671c31bf9b2c2e1d5721b9befc21405afbde8fdcfed78436b8afe99ca68545a34edaabf4098b97d25c820bcb26a5c56a3958121a40f3e547357545a1e955a5176a4297660b341f3d06c3c452639c92f13022e5d902e1f3ec4436e1351613f91ac3bf365ba12be26ad50261afeea99985d87d438106018dc574b8c442a8e50f3f2ac5f5fe4ad578bf454852f550a0ad01a1b024845f113ec3b31536d55ac1e2f8368a770ec4536c8790d89ae89338f257ce8de89bad72d20ec92c3b26bfc4946b2cd9d0592471f7ce6072c16e65ec8ecde9f4a53b5f2dcb08337d736e93edcd0c61fec6764974bb62d45e2322b514f85959cc7475e8a5dca2b7d4dcc77e153554fd8a886fe5d79b268e0784ca788011c2bda0f1a35f88bed8b85d49c252f74f5158799beae2f71fb5950b8caed985b7df3275745aaf8a2becbdd8715bb115db9330fd7dbf5c171d98e3d8fd92d7c0cfb9cbd1a2f3762fe50d6cdc298cd3f2f3762eaa22d6e0cd7e565a5c2c4370fb444bf8407e7c0ecab1a84dbe7d1d2a80686165b439c22e617cd144313d543a80d1850bca8bb064383911217147b11482a866c8f2b61250ef41c0c0d77f163813b0af9ed392574a5d0df4a1a98861fe6f60628cbbca0ca6532826f4b695a5f93f256e4539a9ef9b30be541e524fc4b28f29801ccb3fbd0d670c24c4da53dcb9d48650d55acb2c1b627fdba2c9f4a9c7967a60002db45c83a1ff1e13ca02b42662747c78a404becf2b67c577ea903b8dcecdade8b307bd6da04cfadd59af15d0b8bbe3223f8f0ef84c47be755720d4ba30e627af9b1ebcf01f9efa4fcb55aed87b2a8062c9d00aeef63c896b05c6b9fb784557643976292532be2ca7503fc81582ea50aa9903f765afa38329a3bce74a3c38f95405f050f7bca5b7e4e071b8d30a1b4f2e47abb076fbcf2c67c9adbd73a175685a0adaa6f2dbb20d9a2aee275887b80c952bbc81cf958b371315ba34e069c053476d2e7b3c45b4c745dd325f436f36cd8fa1b68a7998c44889802fa8e778d03c9b0a1d54e24173ebb5535342b1996793ae25f7cc94d2cf10d65027ce46c88ce82b0917aabf287eb10976032213a2f26f90729df3bd198328ef4e8df5859629d2e5ff4f8ce4478245ba5b4d4f4cccd93e784a02542ae89a671a692c2053b71dd2238d2ea481fa58b47dc6b23a03d93ce03f6c9c83ab7fdf10f6c1a9c6814a320e748d55674c30f7ead2b38d487915b2e115e81d2f152b74ef65abfda126820267fa61ae0129319775d80e947473cc7af177155c156dd2672c669d16215c1cfec5e9dc6bd5b19dbc523d6e2079ca46ab6ee8a16710bd4b63924594456a283c77efc7f479826a166241daeb4f8363b8459e53ecdc287a91b5733f768dc5dd3fbfb4162a9050f10b589d5b902ff2f00d1b6da0caec3c9c4e7904ae137f4ef63fdbdfde210d74d4240465e293e56da1e331671a2e418bc785fcac189e3fc3f39141c07d111eaf1d5ec41e036bf9d662fd8cb03051eca734dbeb372f189216a9b18e24f1017d11434dd5287776046a80fdffc32d04d211ddf941c52a117a7383f409d47124a098840b00d8dfdc37ebded7a5a806ceea9d9e390bac7c1c168b04d50ea8077825b6f6758505725839bca5cf3d2ec27498de20c637b4244103ad8ef1b388fa6de4096e75e01ef7827263474897359ac68c3e686f024ddb8f769f9e26984a67051d36c24b6b67a32d0220c5126fdc059acb36376536bbffbe94d4fe9602dfe5c3ee0c3bd9ba9b21d18933e65318d44d1f62a6c3731a5c9c5c96feeff1c65c6ac35b02b54739f007132c2f5260814bb46b12621f869dc0457ec19a6d3a297feee0a2d0c59052686d142d8f3695bd59102c0813eccf331d428d19c3f197413cddffb764985ef6697f79de5cbe68151a7ebc71b240f18b5b1740d1b50fef27e507aa81592141bb0d0fcfc17a4645e3bf08a37798669a6dc3b68d2d6241626ba2b2310dde325dfb5637afda70cad59aba98133c94b9326eb0e4d9503b329a5ae5b5de5f9869dbbcc6888d9993439ea400903041a587c6b0e4d046ebc2f08caf20449dc32a1b8e9c27fa4985b2a5e07a9436b2503815dc42266ef3a3e641490b2e25c3f1764ea341379e1b58ba1200306ceaffbe4d38fb0104fa464dcce88f8e30693afe5f0fd7db31da40b2797a6000dc1bd5b3670991e287aca6bfb73afe617568d24ee4bdd241e4f183dad081a4a02e3542ebf3c7a49867ffa6f736ce0929bb9ecf300d473ec2876d2c4d6df07eeb01d0aef47e6939fe84a01f4c04af6f39c096f043d627bb20aef0ff977ce6074637a4d275c0b0a209a98f52c1cd85cf596785c5d2b272fe41322b0f0aaa45d2a78d2dcf3dc1886d84bed46867420d371371ff3336fed25e84d48a7e51230f473507009c5a88e8af273d5a09264e4eaec4f6e877ad2531a0c3f62fb0b7cd86d87920da2faf3e166df34f39632a86d324e59b1aefdff5adfd814f0f45612af5a45035f60c4211ff48d9ad6b42018a85096f66d5e4e63b69793b4f29f46e671bd21dc4f9f7450713917c092b1b1ac35fd0e0afd86bde6630efc58dd71c6e4cf98a8349feed075b8654a22f432e6554c4af35b08f1fefe6d80f494efb1904bb8705437d34f22eaa36ec2c5d33eb3da4b372b5848c9877095cce8775164b653392306bf71cb45c815e6a7e1922570f22f34cd76158bebfc8750d581763eca2a4bea3f0a5ae27e8e305088e25cabdb0b067479ca3c5d1f851cb242cad3536110c361594a421ee61cbee8396dc498acbf4dc5acaa9e6cef6b2121d9a4c660fbfe2953d9d2f0e9601588b3bb90ec41eb842348f8dd533e073ff4c05656ad503f11a794c051b2b91650b0b18b7f0f455a8b1c7bdee63799b9e312fc33ccc84161b5ea8261d9c210685183d859d28cbf766d49184943f19f4be836b265a48c4f966f766cc40ed28d88b7dcb571e3e0768dac448040607cdc7ff29c4f7e276075d0c166529bceb95b8939ddd8b145bedcbf540d8e2ad91c95d491d8ccbd4d67ad5f8e59f7c95b777da3436d08b017da8d200ed74434cbb6fa43446e13b939568105d29497f8e7c7618eaa7dc3619e7ab781c004589fce11d9f4cd078e1c60dd7c40a8dfbd393c8953f54b96152d4874b2edf0470275e968e4a0a574664069f3b43d634cfdd95896928f9d9f887603f50d569c215c04993cd3d735153ef17b38e040a3cb102d466413a816ae3ede71568705bd145c1045fde489cdc381ac130715175509000f48971132334d0bb54ec65a4c9f1c6f8ddafd9ab6f1db34ebfec733b8c9ada0aa3c86f30fac9f2325dfbeddc543dd079f33dc04fccd78184de26f0f721cce88bc8a41c12c184a477a3ece2c01d203dbeca01741f5aef53eb9f079e55e16689feef30edfa873f377e128548a78ec4511a89cd23976943c471dae576c3a1574122cdb7e6e3d5e8f99360544132758104e3eb4408239050fcb1a8cb2736eb5904ff2f8d4fd0c1e84a74294f8ae6bed4a783e41e10a5f0ad0ee0e71ac545057026e405e742288731312b6053cbac83f1c8d189f9b27cc69fc698e5a891271396ce23e729de445d6b367fd965d2bd08d1955f5f382c7a9fcc16b465878aa1dd26f40d186ba8ef266ad296e7741c7e12554774817df99ba7f9ba2cda5aa0456ddcbd37a8d9036a1c9e5f7c49f78dd7c67017cbbbbde722b49a309df56a1141a931fadef193b3d9d06528d49eaa322d5e35d33bdd036a5f5084c3235b4394c337d045baa4c0200ebece6cb195259ee85cfb8aeac662792d9ba1b0af324ed180be10a77285773aceeadb27b252510e536485374310f0dd21223ece3fab8d9612a3e836565af5a79e1da0cb4bbe10c49c07aa9749d4fa3b3f1d83ebadaeb57568ed7f2b50e4ee13ed59d8ec4a8c342722926ad09368383abcfce5bfe3f3b4bdb4df5e6c68e36059032cdec70960dcae985477cd6e46744fc0e9d8189e5532546073dc3482c8b0520cbd0a900711eca777046fd087534a5fadb3c4b91199b3ff64d40c862793890f2ed289f6400814163f3d50670eb629dfaa33ac53bdc30fa7b84f7ff2908277d017f1f98d38f6d861ddd1988f0db37ec6f266c671f898fba83946832dff3b78cc6046fe8a64d033ab053be0be8208b4d3d6812c1404e354dd7138cb982d923434c705eb2272a1f5cc73fec79c353566e01808510623724120a6624dc641195fe79f3a2da3006869c2497855ad0e7676c2ba010888001cef1920b527a2e985edb23a5fdf47cf2d8ae3deb53e6698cd4e696020d582d9aa1d692db32fd8a7de748b4bbbfd894d58a6d5ea8038576acf4fa3ea61dd1c9786057ec2c36597b9cc48e6a27057dac6a797a5245a06453f49b973eff4bc0bb636f181094b5e7bdbbf50932b6bc12188a575a0381bcb4a9ffc2aee16ac36872668d7a79b93f9bdb4db0aed60c74e604dbff399f86d2f1596d008421ac1d3a1cb79d423143480fba8f14e31ca4f1c40d1de6488a78f19254acfaea3516c26ea16728a123555af8d3a0a4cb264695ca3ac17faefe1fbaac13c38f74662c7e2a21120ab42f583f5a6afcf1ee7bf4add0e9c26262cbb77a214593db7d36c7dc27fe8d448a59896614364d10438c54f54803f30a862b3b0ffc68724d04ff7e8703ee0142121df82a87162bcb85359b5db9d426120b2b2c142baadd59d417b7af869104d65a53dd503909205b8c78c71d618d37283bc1113b43bdee71f54e2b66aae2d4eefb3b2a8ccc78797bb32754d2d139f413ce6825062fd106eb104d7385070a1cf48b9abfd36ece95036cb7b31107274af96dbaf942fa1128128da4cc097557869621ee70d25d7d37a3c362a30ba00ed564acd893b533c47838dd7d4285907563e65444b97d8e0419a96083da24eaa4c46be5d1ae0a4cf34813d78a7653f308dcf56912eee82681053b2f30e8ac56881f4d4b89bdbf537d2073a84b8fa3e5cc49ec4499c0f4a56c0956797502e5c704ea6e61af43a44458ae471adb24dcc776377dae50cf4ec78e04162ad956c5c9293987d0fb7f16121f2be6b2f42211e613665ff0f9742d7deceb1376cbf54df63ef94285ba5cac144b16eb24c6062419f09e500659126244eb219e727a5477d2e7ef02139dc9d028f270668c1822e4f7acdb4a8b0b90fe25cf3f3ad4b289f08db745a19b65550367192df44b2e11edd9c873de2e689f874457cec20f26188517ce8bbb9f78d6e86717d54367b25cf87efd2c6eb898c9369c1a87574a7fe0dca2463df985436c1fd29b4d286f910222050d3bfd586422c602dffe9e390f8624569af08430ceca2fd4539791aa18a0fed5a861209703898e2452b4f1232daa81c4e7297e7e22db554b3d679a300e97e58abaa362ace4e5a9b12236d620bfc165911fe9099d9cb121781aece6f7905ac39f0b849a39e784f595b0e42be193211d58e9f7ee1ffcb5803aaa64e43066f494d90511281630f22bbad0fceb753f523698b79afc0b8649f35d7d14c3c1f3cc6a6cb40af0a752cd934c03918b0d7aa2409b24bf459b303380a173aa3230613789ffd71e08f154c2dcc949e192859919b8a8061228cec38f8754d18997d419446a95e7020725f5913696ec3449e561236f883c4f18b155f6fe34ff828cecfffc24c073e04df104c5d720deb8616b2462f82cde096e0e62f8808e0d4d8292a380e42f463627d8818b86128bdd4c870e7a89fa957b24f44a3086c55143da5c698abbfe12f5e7f438cdc2f865c6d63d45518e075cfdc0fa53964f315f8ca319dccdd8a671745d43ec4a9565c4751fe2d7d6abf5b48efe391f0512ab0390fbfb566a1dff854ad7971df17acfede5408eb4a60b48e0cc5c16ecb31d30aee9834dcfae43fb4dde43825845e0c10e356acffb0f0b42b98ff2e5a36ae0dc5b261dc7588c07f1968f834d9887ee864ed33121db171c98445839222c9071cfb2c646542502d30e9f32a18b40116e2e0c24618ce165b528a566efac3931456543cfe8d4d5864058fce80cdc41c46b9333c3d7b19c6b651ac20e717e880e6de8921bcd90b89ec09a9a3f7662cd982e5bff7c5cf8d5a9d56d0cdcbff25d2c41bd184b891bbe754b42c39a32065d503aa1915823d28fd4c58b24c4775626169d2fa64662538a6225ba4eb4c08cb44b6f12292649242656b3a011ce4d8b853f7c38da888e7582052cbeb0ed6bd53157d52892f5fe90bf865a039abc625582e4e44792ee7c593c82c8c876077d04cefbba6b063dc3e0be3ab1d7122b57a7c05fc0555c0ea248ea59476446e511bd180e8aed7f64c22b8c281a1e3b6a56759cd060d4c8ba0edb4e628ee0bcd4abb2811bdbcca7045b0a7a49dea004d9893b27d41573e0dfab376a6a6fff228a77936406077c9c9bb940490e61af55cc8918be5a73d3fea4da166d25a21d72b2d37a4ea15bfef3c8b7ba7939834528655d14998d0964b61dd0e15bea9a555fe6cfc9c03821260936ac2bae3e531435360ec38bacf966e1d6098ffda5e805e4605ab71add27a72c93cbc08f1cc1859430ff400f70993b413e569e7c47ee84ae29ed52ecb62a2eae73e4beec6a56bd0e8d01f7db1916801f0020dbac414e918909bafe748a6e6d7881744a3aa79296739f2c8ec09e5d98e7da0b386b9169aa2ed70f110e5e466bc0d954002435de8782f12789091ae8bc56b74de82a043cd0d1be590db837ba081aece7f9440c0a9c332120525966fc7ac301442a0b87f08e2d04d577268c40dade267a8e55ffb2fde701b4771556d58a2e43367be818870b309b59972b4d075f7fbf9a1f0fe77655334c2e2fe848fd3b6a31eff2a1d674ae2931cca52dd2ebc93c2b909f7feba7d269d9f285914ec2294c805a9a07f4facddcc9be0965d5518bf3df28d2ceab6a791a96162b053a60eef1ed6e4a03e82f09f3dd19be4a562f4fa810195599963a99c99d44ebf28ef79795a954011a32282b6faee6eae8d5418b3e51bdea73166b56dbbd81eb95d610e98814739df4d396a2ce14f04fc3fefd46db1c3ef016d4d0d1eb824675484dda615fd8a1690c1a4ba7710c63f082468d470287708ba1b4519897e1a25a61f43f7fc3ec7fccfe87cd51269d530e0bc01dd114a11a46a88c9a0baa1d06443eb2112a553f6b1e560eb07973f2e94636a608002e5d486b280af786a7bf229d60d2d0a00fd6af5f4241e0426e5af5705156f175c360e3364e0bf8eb5f707919385e7a4b78e6be3fdf24b34fdce5f78563813b694ba08f7aee2e2da1110c6238784ea0bf42db67da7119a616628d9b6ebc49b0310f44ea565b70efca42e262f1c6d2620c3faf727b3c18c50d95873e1a2f7b310695bfc70750d3be8d82512ff37df60c95ef855ee0b9a33d857c54188f065082cfb358c24c8e344c0c6977fa1874a413499adb4980aab30d8cc5898cadcbbbd926a24d55c8d1b3873f7aebe4b1a7861ec64c0d6d4f92b162e976320a8ff04eeadeece08f39d36e112c4f3bf6c5d52e0cd59ee48beb787c6eae988ded6e6a99e0700d527f8943ec1ce3a051590231ea715ee30563ecc6ed6d93670b44cbc540a73e4ff7e37ecd49f74e102400b903b0323183df744d4db8c244a95f4ad677e3b1c45ac6563defa0857b831383f52d312e88213d675c984bb2381cdc21b9b06b8639452d25bef373f8cf1875976dba2381fe4fcfe9cd1b0d8b50780cb2d47c0d33a946b01d1923286edfce5c2e0d752444c0c38fac259d0d9310480a9038482736da483eaca39fcdeda42f412774ef9c29b7eba7c03a12a76dc1484065d2c08c7580838b47a5611aa2a91f65a9fd48ccb1f7a28925ef0a35e7e2f9159b58afc84bd1fdd6e9f82b9d4f83cf44bba21947cee4e9fb65d524a96aebf9b6942ceba3ff0d6c3ba148f6e6915ef832d5c8db77b092a546aab59c0fcd365609cb27880b2279fb05f40cdb5a3f70bddfd44242f269bdae79392068ef1475fd85f923482b0769a0e74148073fd53e7eca9f76243332704f97412164173826a0dd96e17d69d16f078932481c745f6d5b72d2bfd4faf070ab9d1f48c086a4547079b5560911ba17c84f3cfde387575c14415c130f4a879952c0eadcc1f402a35972c81807cf1ac31f09b33033e0346c2f45f06e79367213867f0106aff9bbeb808bd6e039148192351800b6552241f1e7ba8bf0c50c8a01acfbb5c99841d18acd27829c64799116387b0c2d02c936797025fdefc135832b6c9b3c6ad9bac6fa45451cdd9f5cc67f0fc0161391cfdce3face06ea17fe7612fd6d3ad49eaf2a55386a4e330d53fa9ed1dc2b1d226a7ebae0a0f6d5cb0c2968ee59308a613dd6de5e8c7c31b44598095d1f605904ec1e45235a085e95ab2575c1d8ed3e41d1ef3e801b2232ae6dba81aaebfd0d53a496859306dd7e010cfcfdc22627e17ced9899f7623a3926d19ac348289ad9aaa09e702313d02f3adcfec06f43c3569f3466bfa46b8e93211bb7f210ffa56e26a1e1dd0210c4292a4024cd8b8e5e4092af4e8fcae29d77454b70430ab58a2dabefb219a773b14a4205c1157ac7da381a380ac05fdb6b3f645bd0e76155da1a36f2443abb62cce7727d8ec18d00fb6cf60d42b507182b44710211f1fc75a91c80295eb768507570588e6b270499b09096c5b3ac39d33100dabcd8970a6c74df22cf8ac4cdadb417b7378aa8f897a8a666a8c32457e3b2a26d6a44b58148528b0189da19923841eb8b3ef9520f9193f9628ec791d978b22ac585d25e33ea518d310221a394a91a9d2418a07aee60705665e627181fb9c4eb16785cc98c8a667424e0bd02a1127d076b7a2e58070295f7bc7b7769973790e993cde08c3047242db77d8e8c5de82a650f9315ba92f3f0060d8256f41f04eca5865ec82dca225c8328f318f8e4a16b98723d84fc93e3155778b6bbc2e5a962f9660a0c3a325e2d7e489a1c45c84741d1aeb18111250b23dd2dcc8aee047f3e34c73bdd4b39a14cfd786225c5d6a23e7f7d69d831e9e60f6486d1814890408e8d36eb33d97e477ba0408e9465e5dd6d9553e97eb99c2550422b41c49d8b834f8617dd08b233df44355d3ac72ac71c2071db26240fe327bbc96e2c6e31183ddbeb52fb915184ae55ebc4a32e05bcae6a28faf4e0b47524a4e7b9a61c100d725b5019f6622c82781a2b0bba42de06dcfa1e9ca245fa15e69825f11ad3f40a782f52d3746c980ae5b5757369f7b4c011482baa844cdc81a0995f1faf4390fbc51ae154cae78b1fd6d3b3901cb796f437063ca8ab02f61c616c71621518b3c1538e4b526b9d0967a7872dd8473cc02cd0117e736f22e05a3b838ef722fa11a1f823c509560cd74997854cf59fffd0c1cf454124429fbf5c108e5bd9f0784a699a79700a805d62a76e4e5031a09e3cbc4e9dd9c10004ba1557cfdb3e3664d14cfbebff0341e4f81e94eed7f6b5eb08b3f19351f0e031c8ba946e594ba5b2a2b5331fce50fdc5ae947d0e787535f510bb593f770ee98c3905926d672fe626e3878fbf7c03cadbbbf0938fd0e35797b9742e3e2f23216e3843109ded52a0d32cba8b9fce86c351b8a0eb2183de16dbd55db57adc39ed9f3dcd86c712f396da8a8392d6d72a2465fdb220c6dc8990d90877d4c1062417ec52dd0e16c402e55940d134e281f070a46d23520a6c312ade65b79f3e0bf3048c66b595e2a3ba3b330caeedddfb3336417c414a0e6d14a2df7437edd4ec64f2429ca299cb6ca185ee7d6436a77e16eec73e80c67f50d46df55370107910751d210e3149603664fba3a9871f5fa09e2541c96b31aaeb501e5ac9465a63e8bf95e3651f8b58fff875dc633a71437725d8d209d0d7643a81b3a44284c6a5e8268da38b22777530d88fd5a2afb1ad224ea757a4d81fdbc5f52a428c93c0b1d48cb4834ef86f1d001bf6201361e7a0de7af4f9c7ed246e4955661cc03b7324303a6ccb339a494959c33b6d93364b8f7e0060e40c0da0504ae286670fdaf93bdba9c1716519cf50e6c9af8f690f38a065d7d3a4575187e54f0a30133918ac2c40ea4ace15c8c58bc623385f77aabb924cbb5fbb386805eee4a5f048162f37e6868acb199d48313d9a2ccfff7ec3400893e4d03f938321faed761dac7aa98f24adeed790b06fe13014663db5ba6508b06be0576e3e83f5969955e11e6938cd954c040b9ed58185e065ac2d19edc315af60b475f52d88fb1577c516dbd352cad9f30c6083169179e129b8fa230cdb783fa12f778eaad82a1dc2ef34af6de8e867fefc2b52848ee3168868a98735fbc8bd9a611b7df36ffb95d93cd5d01f85909662ce674a7cecd6c598aa54854fa1f5c7579062cfa139445877375b9f58ffb66d78bdf78e1678ead57f29046fad88b74a6978425582279df79d0685cb2ac1796a0357fa8aacb1e3f63baf00eaaa3f91eddb8d0b1687f14512e75826b78bf9de342f2f186ea74f591337517154dd2256b5d8b7d7d9f08088108893e7f2f0b5988325d110b250b55d914084e62074921ca0f1fa2e96a4c05e645e940b2cf5928c00b2c78857ea3efeb4027e75d8388e00652434915d6ba9ecb8afd92f93cf1452512b50fa8832a990887889eb25079e1c5b31590966324c66f53841f2a9d524dced8f1be553edb19044bbb75bc3ce5397d2447a55a56a9c28a9af60d539988c27124be48bdedbe6744f934e3d8a52aa6c09cb7a804d15177eded1af730df4748a4fc77fda23ab3e89df0e7ed599b6056d2acbae3a455f93da65bd7359de3cdd5645d11560b5c6c1692c2142c7789e885b0c0d8b4bc4edbabc670adefc473ae3d9185979163d3352ad2dc2e613c2b29914a9847621864bbdc5cbb1f6074b6a3401975fd36a7ab78786c62536f903b66f52293d0945b8878edf1b452705e94476df6ee5ca9152d5710b262e7b0898adf9c367ec505d3a3e2f3e9d92d6936eb6eca3cd1237416f3fe626e7c65298d4cd362b367006b17e26368ab13ee24cdaf5a5a628c3a4c494fcab16a5aa7454bbfb5293b81c17bf1c0511b139cd3d6c79c9628612ef4129d36b98a81f42f7ebf8e84f09b3f38815dcb6876ebb40e27c8cd235deb9553ba6269d38f30579e8e7d8724fec860b5b88905e4dd6a65d3abe0d7ab0bca7067cee4d7f1ba7fc28528e7d884dcbd01ca193c94ca421b1d55a358a54740536b38637aa6628f6caea7727553368afeaad3ea1df9ba6b8d81725e58155f57ec7473820751f956af59413422064b1c6eb120b223e22f12137246ca7ba6a69f9ba0389f46a065a159ec3626c725fdc276fdb5f681b35b1a425faca9a4e8860e371549cfb30d7b56274b54c63b78705ac9136cce488600abe92243d5038451907f1a29e5ed6d978945d9ec5fbca75a2c868adc6f84bcb2d6b863d48246dd4cf7e3c64070fcb34fcc390a280bb47402a8dd68d47a977ba0bdb0f52b2d417fa0a714ffcb35088c9ae13e87d6fd50cc138e37c17266ca08f7b8d925e0a3524089f76ae0e9a88c09946ac43be167808933b58f5c113c776139bea7f9a67b9ed98ff7e624e6025e7e9aea6bbd1f0a6b7bae10dd821fe21bb97aedad6cc6c6ba1bde8777390c40d77a94ea0adfa2e44a96e27cac889396b0a78a19d3160d36675b1713bb98784e0324bfc98fdf64901b7d10fa886893ae1f44a4187c8e3e79cfa58ca2abf572503ebd689ec0a7324a1089d1ff5647b53f1c03ba67ab1b8cfa13308312be629d9a56f201c11898731ce29055cb2ac8e446fdd4cb9798bf025e9b53ed6f97678085ba24531a739448fe14b16facb488cf7fecb81ed113709b0411a6753b763c00014887847d18000a3450aa6ec62c7be9c106017e0636bc66fd20568dfe58879ab02a8275439a4499de40f89dd2b8db82dac1f9be7bde330323624b051b524016906370662cc6ffa3ff5c061bf475c8a5ed5c85706c5cd3b259c023953284eb2f848860c1a12ece5d46a195a8b345074ff11f6e358a9be2e2178a1954523e3bb6bffea83f4e53480590b97864402f6c540f58ad836099252c60cf2560fb5ee20de58e084a16fa816ce8a66642be28089ba24cac890a3b0b08a7d73e913781a13b4940beb71565127869007a6df2bcdc592de9eb180351672d260a5d710d222bc303334ffe9da43b250d003d670c3b789d8e0e98c69281abe059f2a450ee5f490b05a0fe6ee71663af4ce3d86b6318568ae717ee3a1d8af348140cd76ff014f808a86d4635e13359822c5e777d21f440ed30b5570106dc1f69f5187e1ebf5124fc33e24cf2b1623f7373e1c8c94f0b55c5f8c3f112c4140b9b3da13a9327e8b4dcc182adea6a31af7c4910daba2e44aa7a8f14a085dcfd3d06e3ff0f199b6b599d25a5d15f5fb85002bf80348f40afcf51c7eefc52e8deb4292da4e8a8dd8e6171b204247c723dc737d16da21a7e7d9bad198ace5e6527c9a91bf19712f7bab3e6d1a98a0e7bea0d5d717f05bddcd0abe5fa5f3d1522aedc8a9f19c01260d5bd828ad20f5e3f91d3b44ccf3936658fbea8294a90b1c3cd4e12ba76f33606c178559d9169ddcda3d118f976bd9fb1882e0871db6bae6039b52162b74a8db89ba2ab0d7ed5200d4b00be515e3fc8d54e7ae188a7c1bcfc8dc497b3bbda1b00e08908c28a9210cdf734ca83445fd3ae44378e8eab6e89f64fecb15758c846555739d57241676f126f66071a7c54e8bef95a3f8754c31de5bb303bc39610b249f7b88ec6243953addc7adffb96958ffa46bc0243007a2e4875927e7287dfa081170c31175096d7539f6e0bca494f3a7663b3a2e6efcafa3ab59c444f53eaf7019f281eff8c048249dff232047c0a1c25fb9b1112dbed62aade4e650ba10087fe22a95711e4f5a5a401d9544c3a749767c26175f6d36f988a647b0b079416191132b3d7062c9f13f0d26620e261dc48f6b1a2e176ad33429b66449b507d131b7bca1b0cce0cc1bb964a7d49b795f5e38ecce0d58087bba7ffff8682e2c88100ab239ba3b2a69d2cfaf1914813742b967f622448e20808bb4dd19e394238541baf6355ca1be2e6027fc76dfb90d1fa6d7953af65d026892bd566ae8f4cd89c0158739454aa614140fdcabea1ad0badc1be841f5187decead82a00c0fccf8e6531523893a82cf2b076d155012ad88f893dd084dcc05a8566100acb393f561a174fa3015f8315d650640954f1814d30c9efe878e24dc723946b8cd08965ba6a4b66d2883dbb91b9ff576eade247d85388042c6dbeda1a52de189dcbdc5a68813700c490d7b01396566f705dfe3e1b87e134b07c88a0bbfe1f9ead8ad3e69848128369cccdc0c261b379e15647012a360a1d865f78a177bbd78cd5cc61d14334fac7eaeff8810fa3e5f05680992fec82003efbe98b772a1856c0f678e62a4dd488154f1880bcd5307061e9f2b2a0c7b52abab7df09d28b5866bc6b5d594991909e3ca8ce35bce3624e167630dc95910e171fc3caf50ab84e7a3a414110d213ed258763809edccaa065222ad0cb5e287acadfaab9f2d478e8d58f7523a791677d570e7a0fd8f7e516095b27fe77d9ff0bbc7475fe36a827049667baf7b76f297b853e8addacbef974a4de13fa5c3533f7f44b77e415d8d7424a17701ebce807c2023eb34749c45e1dde9c3db96ffc7a4c00ac7c1598627787612f1b09d24cdddd08bda344c013260709ff1262263322dff2713ca99abf957eb37b79602c5276c3ff50ab4afdb795b4061f5ae106150f70f7dc2a762cdec337acae3107989d0294f5db36d0584d2c0deaf419aea154a73599726d0e2e30ec715236e9c26b15947656e81908f6b5e0a8dac8083c746bf139503ccd318434cc058d5b363ac773f914eeaa34def1ff10d623870c779c6689f6e8c2c55a7b91110add38a03b211c28ec7d2c234f407fa26f526cefb9e1e6d1ef39ae38d9a37340751b8d11923c610975c13e7c270346d30b902de64f8b759573c4190eec4d1d122ceebb338ad4c9b217a0e552c612f623ed3234d9799107737d84db2a4be9d2c8ae68464db9691ea1ea9898174034b4c8d30950421ee3a984481d678342da403758aedc0f54015c91acd864c48b63ea4f9894af18927783281d5bb3b9f73b6a88604d1c898ea5c52b41c704e9363dbdf5101909731f6050c9d6cccffbb5750e38d9b63efcce74a25851284986048fa71904d57604374dcdb2688cf810eb95632bc8d9363b9225882bc858073ea0647b18c88bc274640d11e7d90e0ae1facb3bbe7f02a9145466e8a8c75a6f2d1c16a0657f0142ccc7feed15dff45fa91081cb438af7baef81d9ca893a4d0e71cc10fe5cdab04ad795e157d44d691df3e4a98cde19bd13d2a2c6287f50baed764c367f7aea1582f102c5f4c78d5d84766a159a3a2754a98a57afd21aa6c1b795c0269f556cbbc3e49b7558ed9271f6da197fd08f414a2b054445fd94ec6530918bf7ee7bf60837bb5e92ac3e1af5805569cc29912c76ae3e1f2f736a897d00352939932cd01e2443a0be3fe988f0069914d9942cb27e02966353e4fffe3d8bcf91753863477dd27a489ba83dced18a7d4673a397ec991be50d0cc9999845d2cc12952af84ef8d3cc9b91442791cd40206d48c7bcdf736a5ba62a358a2cf40bbb2fa59476f0745c59066093363961bcf6073c206845bdd37273f9301c8cb7d547be50c8647d153f94d3854e16dd343dac658fac1ebf8027c55fb96223f31147807300b965a690f40508ac397081825db4a0c8cc49037ec29005fd55ed654f1ed0f8d8a54c3683f315d4f36afa2c4ca10370c184ff8cbb8ed26319983ad884e09c1484c4ee428e237850cd480079ac10e813716351a9da6962ef1ca1f67b78421a468a7fb1d551822e4bd26f3b0d897c55f1c39c9e376a744c2bc158bae3762592df50544b9ea024aa6a586dd8e1a64576f3be16ba54cd93ab59994c6666ba9c4080e9260696a925b2d7a511a8ab943662b21614f095bce2098aade19bd58616194d101ae109cf6cc7420e147f513e6d73eca01957605b0c829cbeddc7d6ebb189447a31e14bd63e3c960cb6d97147074d469fab66597ebe6d0e11986e54579d5c752615da74239d6e5cf0cc6d84d687e5bb7d6487138a1d479d10ced1efc0f08d9bc1f9079d57c3d29e0bc9156214da4f47989f7a1ad4636ced8be1b3e300dceeb5f9938cc6910cbe744bd29a6e9e0dbfe650f6d5619be113baea6752792df195936914be98732eeaeff1b7d33eaa5042d247c4a2e06698bb4a59cae4cad31de726b097c8244872053804edf1c8736ca31a2fa4bf61d7082bc63ab8bd564d05082eafb3f3db32092d4fb394396c9bdcc0feabc51a387266d365a5ddf7852918f1b3528efdd33ee5923bfc47c8c94232c7ae55dcea4b4e035edcbb61e3133e6b4cbf3eaa7861f02ec871d9b39eb730a226824643298febc899e99defad03c14795d1397149d10ca2fff40f520121b53ac7da4452f865ce9e57c5f5265f1f117f96c93589ad77e315534665c1cdc1b124b73a51584022fae3ca66f39fbbaaaeaaeee5742c8d4a25a6733fc4a664003a4fd25cd32a701b16ac955a4cae4786e6ab30d6a05d04168a6258dd06446d6f1f9ba490e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
