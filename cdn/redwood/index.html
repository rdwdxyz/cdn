<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"020f2197ce27afa0473b4945f0c130d8c6641efd61787f954791bec002df9c4551bfcd4b747b646055591b6c4ab1218fe29fbaa9a835076177a73c7cbad25fa54e38eef18a033ad8687c02b7f41080f34db3f79948ea63a2dccc4c66afbd9c8cb958dae42ade31fef14daf079062114fa4de4dabeaa9914457221ecc1079365af589465c48a9ab5436248b6d3b924a49276fa3ddff5f610aa4ff3eb767e0d6f8e209f41d037e04eab910b4f3854806a773f0b116d0ff4a7f76c543232b4cbb8762701f50ef057c7dd2d7036cc08da885215f6e0d1e5d5ddfd8d2fdb36e22bd3f0ec6443afeeb30a0a69f61fd3d7ee50b845ead610eda6ddf89a06aae24beec84dce46731d8d67b949244c3d21a4126bdfe9a07c6d3c51341a578b5f5d098e86859f7374630dfcf16fb9ad4d07ad2f187b00a790ae25a37f6b55c3265b100f8d38c96e3c2faf8ba8f57e017ec6202f4d9f9607351232a60463ced06214e8f4afb99bf8c2e34340969ce21e9e4cc001de40095b136a01212d62d306d507397c63b338f448861ce866c088ac993d3b3cbcea0ce469a73681b5d6dbedf0c42f95d854cac6cb298951fa7a73507fb43d9d2fabba9e6173cb637e8e1b078d1af92de8d468f87d5a0e0ae79002e99b846984f0ca0b0532ba37ab0734437c71c6c072ae30c82fc624cb9b1c02b3052b8d76388cddb40cd40c2f14490410dca1eae3657bcd33c5be37714259605cd09cafaca8af7190fc3aea4869b23f450e0bbfafe313989d1407c45494f6f07a6d41cc38b7b7627e23fa9bf982d8e3ae4759ba615ef4b31964f10061a7563e6bf99f8ccd69dd209e32fa075e266e93692a94b6c9900872de04e21338dc86de190e87bc1f8cf48109fd840a7144b8100bdc49763dfe3f2d2a00a1099908ccf35ee0d1a353c8efa90923b38f24c5951e0d10a65cd00c2ab000279a4ef40cf0b32c9dca7aa7ebc7e00989c2701501faa88054b66b2e46030d1e59582fd1551e8b49937db0192ac3fab116e2b8142275c3f87d483cea723da93256583e19c8f9bf539f0d7b1e07ce2d6b5a36675502778cf2242e07726778205920d703480b53885e26358140258590ac62897d3651d3c446315c2f70abd2f9f04f2c3c9e0c69eecd208ea899583532fe7ef71e8974cf46961eb74eceb0f8a89e15d47830c17c3ab8d851c70be8e3bd00137961a3daa573d592e87b9d9ea3213af63ea3095598ff9c928d9e46669e461a61143655a431c66101276c00ec59cbbbfe1c1bfdbaf31188ab2a538371fb179311b1831237b99108c25478827ed6e15b062a62baf3e14eda44c832479e737b07760be5f4f83d722d7cabeaeba5536c8f8059d71d30dbc22072e98892b3de0c462b30454f6c590b5cd728aaea787e43170d427624205fa2a7c161a995889a91511cedf8ee715794b21b3668fb2c81e935d7956204db3c1ed4f176d2ace313559c06f7c247f897ed64a5142d2df05069fff8c215a47eaf951b0f9f781c4100f184bb45f7fc1706e49942d16d69c1639f4a638c5414d52bcc7000ec6038b543e1326e0fb88affc5a21020892040b2ab550757f7b65642e46d19fe477c9d2c592ec1024271735ccd9f8e9e0cb6f74f40022df25384c6720ff908f49f02ea77db1f953698b8616b26ce7e1ea911d14c02ee3a9f996923616086951e19779606042a5e4f7d76bbe4bf9672ce38b0113bd7c392946664efaff06f2d6a6660c81489de52a8ff4f7ef57d03f068324fc63a1b8f05c481d2b82385bb86f3d5adfe786bc872b00fc184355a81748fb6f40e2296d3d2c16741aee73adab61dc9f03c6b433e434b8f7d469852d364bb73c52ba3d148154fd443d528f1b36f1c045826e9b10def09f83bcd4b2c4a02da0352aedf0445917812673f6c69d02c255560a38336bea69b0f9e86ee127aad844304758f30a5779675ffe874715cba939ab5a4f32d5633db4ebb17240e5eb2c81d28d3f68d64f0232dc2e270f9eac1e13610a6a10c68d041411660168435f23467037b5bdec65fb66edcaac6c5712f4a2a737c158251ec11190217425cfbc865de42b1f5e2f0f99ffe9bdca906420a3609de3d5e4daedcaf2737ef98a57808312198afab73a3e211333b829c75a3a7df22f1aca606a99f502fd6076bff696126f43492ae73de64703df9ee44ffaba9c17288b55baf8d898c1db6ca35dac98a4a6823b83dd4be1d405d3937ad9df3fb2628dd572a10342fa0cfcab29f315608f99798934538cff9b8296482bbc76f0c205b1357e667b12d55ef7ffe815abc564a88bf28e1f64a4b00697b0221d4cfe616970f65bccf0f9e32684c98bc66d5d277a832b0dcc05b45452427976d9423cd6e4fbf0934a44762ad6b7a9f08c6b417e74929ef3996273a7d079f1c7d9a46602575c7dcb3a55bcae9a48b5fe2bc20972ee1dec90ddb5540fef924ffd38055c44fe2bc3ec08c98511c6094806e4e87a702b835a2f49b52076fdb9cc59cd72cef0528fb80018b530bda882ab83c5f5358010929c3f8ef4560cc56c622401bc6d3a8d4bf069d6b47e8db13ec887e307f7f837836afc04711bb14f5e374f15d6ef38b1b2be3d85186045625fa2a28c3520a71c048d462526f40d4dd2aca957b83241712b98dbb9c911234c6aee5376b198b6b8c0967b28a785d4026ce2bd0daf01351d6e42814386f9db5d6a0ab728e927d4fed523b44f521dbaf7bb0f83b19c91f6f4033bafceaab471920954c2898c6ea325f6c03fa4e8511dd1e056584e1978dc69cb0f0c1ad636b713ad838c1bb75596d24e6b39e3a09c4c33211d70e2b61b4f120e009fed05e3354dd0080700603141d4bc180d0a17383949610546e0745324861ab15319e86e9a8bbccf39e23894c8bc1a8a217c2a68e384576b8fb264b612becf572fc8ae56bd601d69356fbf66f67a5787a65bad9d7e50774dd4eae3160ddb5c3f9994cbb9dd8289fa10b89f9a603bd3d73efed34a19a8b99e916644caa70f8e5b6015d9abadaa30c0027010f4c0237885625ace705f873fe69cc1af62c9f15c2bd20165a2454743581f8ec804d9610f0db48d5e89094069ef9e09b3b9a720ad1003e86e219417c2de020014750491626fe4c59bb330b91d9eecdfa02d92a0fca46317eefaa71d18bb31cb9cbad35d7c3aeb04c5e6f2ebd294d1c9d3ba0535c050e59ef444ac570b1c6c968b4bfe0744dcd30473bc29f2d51791d0547d279a3098df4d3074e62ac21759566cd0766dd449aebf7884f87a138f5ebb96db2f88cc49d5dacfabbb960234d972c0406b5cc4b393d58c57e873827c330267703af2be05648fd5fde9bb65207bf2145cd4ea9690aaa6264179732bb3a1f05bd963e2ab15369fd8a80d7a312004169f2d33c8c078f7b33e6c2b8de05d36f78d897a66216235a190c1a6b1324023d85f51bdb792086eea2fe594266a3ef22f30507eb526727fe828029be828afe34da5be04727ade87115b91d5e5a694bf8c955dd9bb9e0202b173dc11f9d2ebb9f8182173153c79d3cc4f587ff9a7eef3a6a44318137bcd7d06a6bf1598be76a7fe2d5c6d1d76916c55c78958a97f66641b9825e1f64a45cfa7542159753cae3b152a2cf48ebb6a9dc903c4ae4eae06a891e772d1ec38a8aaed63e5d38b898b7d3e6d13a2cab810318571006d33f9437d948cee9db1cb0a84186671018d573ec758056a6e5282d1fe349463fd9474f4227ccbe9109b635903c8a837c48208507aebee3dcba36f98f3021a5a45246f28a3e510ca6b8b972f8e654b8a3417e69fb5776555d69186227b6d7641eb2a5344b394082a80927a30cd698e79a3918740888c036cbee0911abc21974b4a2c5db9580f82f591222b8a523ee595637b9ce5812eac250ee6c688fb46496a633d22ad28146e54021c60166b7703beac665598c5ddbfd30ff49a48bfdcbbbc5be292335025880cc069132b4cd5ff072705d0eab18fdeb33a7d3646ec0925e3550d6889452cfec31591a5d1630fc1664e17fd6a95260429e5b4c6ee60de067b32db2a6833fbccdae44b3ec1d810704aa3375eb0eab9b661b76e5c1927aab8f85cda4466b1f57aa5e2fff9aa1dfa8271166a7470e8c9e7a53a2d0eeb3700d7e8958135d9f464dac483d05b6d6bf59b5b5afd3d1f378cdc4b1b8e656bf021354d94faf8670a3330ccd08c1b4b0c1e71901e33ca97b4d4bb3448c76e008f6633129730e1a5be36a37094a192fec19f847cb394ef255f3df8bdea242e5d2bfeee0f9910df713d40a53e670de5b3e1258f3ba93f827504c7c5b6fae0eb27252f9486576915fc0b6de502ba4a59c726595536a3c32d5624de695a848789e58b656574b2095b096d11c93b6ac2f0c1e5d307ecc9fde675b212baa9b3153842cffe0245cbe4e6ca5d5b86b5750643118919a244bed61d5e19d2ee8531ab4ab0eac37a6fe33eea18c2ae5e36f90a6d84c8dcdc787e076fb1d1e54f8d8a8f2cddc72a8b3ce698c7aba4176a916286e8b0ed6d233f9309f5cecb530ca2aad275a928e06bfd626bd0867c38d0943794c55f0bfd73dbb73ebc4c195828d7a56a586c5d719d3d6582bfcb859d31cf85037f55d9e820742520e7635886640b6937003a314be3ddc4a9078a5c194fd03e2b97f077209daa76be3aa8c5205bb2a5b5d5f06cb46d2090142c6b3f70f5905cb3d048f191eeaaaa77bbf32e958ccd5113ca91eb4ae78bc755552456efa39ae8805f569911a64a95a24ca934e078700a00768fe8efade4a518d3adc64ca5dda45c95fd42571a68e9048f42d74605e6b7afbfb79b630c6cb04fd7b921134a6677c2de60d741e773ae94c2a2c11c5214123c97e11002e00ab727260d29d77ee36f2da046c2e525dba3ae8f09c67e4f934aaec6a8f45d2cc8b23b3045125de1d3f6a875d112dce653086254ae89aecc933c42ca5273c549a87b41182b4de0974962ddc08bedbee3fcd2f5ba4a47a4048ffb9ab37667191dcda373dd144f486b87d04330145f83193f85a27fd0e6f1b32a8b040eb55cd3b0899161d437f6a2c4c7653941fc5509092ed9ef08efc20ad9dd3729d680167ae77ccd03addb71fcb93c7984611ca9fd25fd78303b633b5ef12f390b1a9470749e38c44b5f7d710728d52df98e853f4ec3491a21f483b5aecbc3c7201044b4a5f200b523e28ae448afc466c6e639f02d8dee75d098bdde08e94b0d3328835a733c7bb61f0e470d4d41986b732caf71529bfd997c09e2dd662e0722fc781280f1e6b2fc2062c2e367d62a0356a0c5c6eadb0784804694b7b19ae2a0a33cd448721810bc61bfea5542056c02d52806b72dd7c6bbf38304abf1b3f8b3e529396e8cb1d62a9858c2165d739a0266e2fb6d35308e63216ac1285b309229310b8d8d366bb5930cd94cb9f8eb316c8559383ae6e1b6c5e9880b897876b083c760934da6086d0cdbbc14b9bf4599eb4ae57ce5736cd69a5556938b1fe5c3392960dabe96c2b3f23012c3631a8ce45568656d8452687a4b072705ec390ac2a96d69bec937e0e879f934520933f2fb8666516fa3e8878ad1f9443dbdacaec72099739120a707b4d6f445a553fe78fc996f2c25f423dd3afa6b8b9b9dd18830bd1863cbb1e16d0e2c3b6512a87cf04867b52a6fe56e88026e5348de66773138672d4b3fdb7a21e9536686c8240b1b4443990bb42260b1b5dcb9a388a5783802d6266b9a8412fc98f8f5d00b10760d3502eed72f481f10ce4fa9ef702c6fc91d90e59cab44b8cae2fc8cdea99b15fa62e231f5b079f2e9a679527d1bcf726c0fdb875b42dfb5e5f850eadfa30e1a5069173f84bab1e7955f36419c76dcd162ab6efa2f2fa5542b9166552de0f0d3663aea88d33f90300ac874636c5396918c25dbfd45daa242622e11b73ff704a0f34a75b96d031ac311826041700a455c49187b46538c2a6f9a096f8ecf0839878ef948504dbe31b79e9233ab8958796c30d459862cc97ed70f03f3cc38f725df9026dcd41a4e5f98f52ff899a42dc4e7a458b03798cf721767f11f858e067e89d7dff02781e694f25df53d76a779d944cd334b6a99b681ad554129c0b65718f1a3dabac84c48a143c07390d5c34063564c2df37b837f78f5da26923907aabebb0b5f9bbeca99d5c45c23027b5d0dde5d319699ca99921b8dc7062c33cd6e2daa38e933750100726e4f926933cd81a4f7fc71bb38d30ec90296307bae152b1a348d1887bcc6b724e68ebcc6cc529f06b89f3b9462b33c408e1876bd1230c3316d2b0b9c2778ee5cef3fe39cf0e79b9cdffecef8978a6e078ba78f1d181e2063c2ebb0c4b58949191bbbb2216775723273456860e98c580a7cebf9cd730b63aed515f4c1d9682072f974496c701275a7823d98a545b5f8a87d80111f02f6bdc86678fb28ab2b95f48dc7e6a529d158615f895c405ae391f8d4a3abd24e9c70c02b390bd674913112bc5ba95bd7c8533d7b26d080874b9239eb1552b6c200a444de711ca387fb3fe3f77bfcbc1774ad8d4daae8cab8eef583007b58e69f16145ede9ed7fe469759d0f01b5a00066af69f0b0051a08e0393215d11424518d7955a65fc9e320bc0d6d200ffa2698bde117f70e8bcef745bb80b82d67f956c74bac357de9d370d95f8c451ed6106829d518255cf5dd1cf41778dfc7ba36ae91174cdbeffdcfe81577373d5677a55bc3ceb985ac04d8e5a94669ba42903b1593e784a73f822f1ab14b8dd188da68234d802eee207821d22088d262935dd6dfa03434dcf9ef8878ad4b7de8181b2becce119ba7de8f80bf3db3e2ea16beb5ff627c77b0f33a9e6ffe608d40bc993a02470f261dfc9e74cc3fceaa0b35fcc2a6405c4fe8277691810b5e10b814b7bd5a91251f2c5e36bce1bc5128f2706792b1d1e80ff3307d1dd3d91afea75eef3f884fb8fdc7e7e7185ddead0c35633d1caae584d2b68fe663d202509a6179ed6c0291c1ea51e275b5f32325f4f2c28c938f01ca695e6c0ca15b11067069203b7e55181fa0b74d71eb1d9e0f442e9493575c75ec3959c9f528d64b85b84a0b1af965288809c87363af3b6d569b38c68a98b22b80ecb6374c11a06988cf59405add19c32b76c1f9e13ae48da20d5ac80f59d5a362905e2150e077e6fc8bbc7c1c486cf99451ed118000e4d7b85a7ab81228bbc2a319034340816f48120eeccb95b89bf7c2ab344e9c85136c6eb8787209586491323ddd4484ba5bcf28a0ed21c1078579521fe27af58c260cb6cff0c4219c7bf02a835c99b483e6157c84113092da6a98962bd7fb4676decaee6663618532ca4b0ffdc11dfa8149edd7c2614e33f8f87e8669ed81c2626d1b4561ef59060c4082d99ec6b6d782991fc9919fdd7743b40b62204bc86610b4f9367b47541be217c9a65bb57532b0d0906ed2ceb91e40dfecba613a95c7f49e8df3fda05a9e052e27c5fe3e333ce35ce7372b0430082e490d2ab8a05fabe4113d92d47e9b55dd096376047a71c87307fb49db0ac48600df8d2ca624963cc2ff405c4774f4480936f51427c1e757f416cc0853e022bd9e6f5640a483725d351967890659f613ce0d33e261b2cf2754b0ea34becca49497b1619821fa713876aa4842d5acb180f40725c88db90533e4ddca80b5453c3c41ef23e994c4713ac7c5047cf50ec0604b1b4021000ca28b92df3373016ea941ef799e5e3f5de819720ca6a6d33052e41b50f20e3211b646f18e4c3352119e1df64d50a3a1229994ee777d8d5d281f22b4652ba0795088c93bc14128099bd0d629eca8e768ae1e2aca6d7741a4f2eee30de6a1ae074ae93ad913f0997931744d05c3a3a09c9573f75160819ffd917391cb812275f8fa1eb7813fde89bcb6e349e8e0e4064004eeb8d0cf551407927084b0010b7e9afe9274febc77b7dd63b18a18bdb4454044a26cd0f264848d65b8656d3eaca114b8f3496f45c4a425421648771a405dcdba22f2121b287aae0f81f35dd34005865053b5c8fabdbe8c7fc377e3d57f08f00dc0a001c621642b3a5eda25b30344fcdf009d557c5f8477f9c8c766aecb74d29bb52165824ae846344fdcd10bb7f85e29b1d07153adcb249196df0f1104bb703a5fb36906ad86226b1a1feb2bc4ef4c435e698fb8a11b4cfe04e363b25676980a66b89749b17e24d3059e16f282c99ba895c5e51f055cd68ee26343bfc8025fe0e2b38c64c7c73a9ecfb601047f157a453b7575c5ff2fa6dd48c096ae7d089962c0e29a22ac61a773106b40505c46599d2718536c3ffa83b121de9b6b0beb9ba9aa738a342490d51da11c3cc230a8f91c08ce09c5fbec44fc70021b7582ed8213fcad402467f5a0eecc969b07f12cf2ce9bab7375fd5147311fdd98800321d72af201465d0c79b59f55ab4748e06fa077d7433e3eb8618aaf96752a404b49e8cce17c6812d5ff53d6a65f3f4cc836862fa4bbb46c5d8534698c3c65ae3f378a509c5d469b40dde9f72479b21e6e103e5a58a8bb8be219a58163352fee358a9535388e3b23e0e53ba582c60d5715aaeb54ac1d5c95c081e69b503bcbc6cf7a5605b1f60969bddc5ac0c6753bdca672029547cbae399e1eef76216612165461f4ad40b30fb17f80b7e71cd4c5cc1183ab15b19f896694d7c4a977f674993c824f9ad10ba00f729c01513d09134c88cb4e5999c171517ee7f4a815de1805df2772dca6dbed34f5974766cabb067165f13fdb3afd574afeba634b90691b413a7cc6385458597d000b639c972472eb8bdb60505ffb9d1cb834f5bda31ad6ba7d22b87acf943ef7ea12850363a1268276fd385127f55d47b6aba8c8d5d2ddbe5ccb0f6c58d6660823229c5133e4489ce91f41c648546baf7d822dc45391488d7507657d6decec19862ba3b2cbe1044f76eba1af76bb463050cbacfe8ba0576d52b56c2b0ccc4d219b31621700da8249e72ff3641a71695ee31f14c6bb2c31a71a78ac1f731141d819c9d102ed6b8f293081f3ff4db3f011b568af89ea1e8c5716f0e51f49c3d3bee3469d1b2e6f07bad5640c23e1a6439c64d95ca2c0ce99c423f92ce7b9e3b4b359ac4286c58ef0bdf5d32d8d9d0cdb3399e33211f7d028dba237d40b29fefcaf2ac1d51ba948b7fb5bfb0ec3f086579cfd6072d5ed580ee5321ce509589528f057c51e9bcf898ea4dbe3b68fdae05462bdaf3e4f0d1b3b592e2ab68e4a14ae20414c2152979eb081411faf5a383d87def46a642b0ab192e5fae59ad755178480963c6c9edcfa028e5f93c84ff0c7279a008cb7047ae548888e88ed6998ef1184d9740f8f73227fccb0a7da77aa5df7dbf39468412f3944e05dcc785b8ab079bfc7d364ed8a6ebcf70980c3f8a0c769f192d0fa0bd30be8c4cee0531e69f2a43b034172f85ca709fe8f28025a1019df499f445ff026cffdd56b591db20f32a6b63fa35cb98f25177e2601c63d00cd9a4eec9f972f5149d81d955f59542026a3b06498ec21ba1c940cd58df7bae0b146eab2f139ee42b56e02bfb8bbd7e96c406c6385ed4981fa3e63a4f7db7e70c302b3b2258a32c56b4385c02129ab373b4b47c0f45b4dbf3259ed7415fed3eb46a988ea213e9187a540baade0131eb0e76be3d62500161761b24251b3684020a6e5724c2b03dc9deaaef803ec11f5ffc7fb5becd37343f23335db83cf541d60391fa7087981eaa316861805ca5e97aeb889fd0d1312e77aaacb1452e42940d8a25ebf368b1c2ffde38b7ff916bd07a95c537391c00fdf147d7b9031ea68bc209735f5f2c334117bd30bf64a8c41feb4c87d3d57e69ee9491d6adf42c13152fd714888f4ecf0ddbecbff672da0222ac9b96bc2fb17e25ef9f84bce8894546ddd67464c0435dbd4bc1523d52aafa54d80da928572f093e4ea6ecd00160de5050d2ed762b9c33e6d0c5eb3027db8406b35730b9ec05de9d78cfe238221eaa6c32b4e7e71714216fec2c55e52b16a6ca5e7c6d4144ef90ddbac6ae479a35178f4c621d66c6cee204cd01c3cc965866455b486a484982969141e57d5bf8cf1b47ccc15c68d92d8c50c691463d8f7321655c8b83de044f472748c593ca2c037752bf43642b20f27ebb7ae651a83986b9c0801b9bc9eea322690060612af48e07bb5954813c9293cb9b3df6dde8c91e4d14fe88f7728a0b8d00720dd63ad677da1ccb906037c6df511032b47ab90923ba6ef0023ba36e2be0c6dd30c332e003fb5562b9f588574f881a2a8e6dd382e0e2c898baf08549e38301dadbfbbcba9ad2549f0b61e0f23c6cd272edfe056d0d2f44f712f4746946e18d2d6aaa0ef404817a8e80a84ae70dc8a1ea1b1d5957c60a6525660e475b608921fafe1d192443a376298a081ba56601821d96af00ab87c286de5ab65092bf0dea80a7182dd38484a5d00c60ec0e02f0701a24b5ea35feab34e04f3d91a2ceec7e48424cb427909648514558e7efd6375e9ed5500c1ffceff040157296fb4061ee91ce5f2deb1cc10af9d1d10bba7e6c63b89d8e405fb46f4ff776dda74bd96a425399ef994435272fbc6b4d181f9c5243ef7b94ff40ff2f30f24798fa2233d4f7089a3f8b4df4678bee226074441b3b497a5e3c5fd769400252bca05a070c922c58e75c2d7457b0c9e507902270616d47e20bf6bd6181bf2421c4ecf8472485cf43916c8133434f4151d2515901a06975ae2d0801d6ec4ffaed0452b9b60af8d048b314f8c3b7038ea080aeae37e768a26afa0041205677804aea4b9ecd7c88d454b7b7ae9cf2592e42b291c203050de9ec1bf6aba6eb42e6e6e14f58b709384272710459c35e65254da3607ddb24ba25729f6b29375f705d1f09efd1a82aa2cbfed0f443f6ffb38fd76a5b0c6d3bcf672e4c3385122d573f752b7a8beabb83730359fefd7c47262ec6954e312a098ab12d63840c71dbe5a5a15e220874c4cd06eed7c19adfd98160fac5a67d48541175f0554a61b0d219d60992ec49eec2f21fd6be89a389cb369fca3f54f4e9b5bc51f672be08c5f1ebb1afc97ed1d768e746783eb5e468c6f423864b4432807a0f838d6399c19b8e3c2650da2089cacaf421fb6a6026116b3e643f67e9feb7e917b361ada689ef955b7cfdd3431cce322c4e2c2df670bc0d9db7d28d053884bf8a13e95460f568abe43aa9708d163ddb804bace077b7263a59c3d29e30e3bc5f0cc9e2d4816dcb564eb138949540e5256f524776e5bef40b769e1a7718c21e914555baf533b66ca8b048e9cf25d32c508fc1cafa8fce97b92f084c0be933a806d57a29eb956e884a8292c34e3e4e3925a3ee07087b01edc636c5f12fb9d6661417ed4737effcf625e33c2daac0d2b368c0305f7eb998c39bbc2c6c810c0cc7905187f1bc669343544e67f5ede6a44fd011db25b2acd7c1db8c0a26732486d43e7995a6eeab7133cac1f2b22e30c678fc58a1c05fa6ca831ce0b1183172fd257dfa135e2928bcb0d0edba1bb2242d38a9412c2ed1e8fa07c6e323a6c1a5392e3df362569dbfb392bc6fa40ff5a7fd468ba018b94d0e76af17b1421a6da1fc2cf2a8e026b6bf679e190e0b8ef89bc8e66870714ddc9da3d3aa5634547d6bc34b50f920583fa6e9366f032a82bfa887c2255567a378a9876eaf3a64b9e6ae98cc68c8de65a6f23fc54c1d69d776491385cae0b092931f41e7654ebfb18e32e94caf3b7998749fe77c50cb81908feb8b198672210a0ddf2329082fd87b179e166c965e8c95af81668651830122de19bc4997ff2b892b12fddb1101b4f105cabafd006cd7fafba07bc8b7286857510a92d2f5b29cdff269aec0285929caac6e47e3624f8d8d92568c9c895a73ad184c2e260b65c2afe7490ad7f33a31c0ed5cbc2305385710aebebc1ff0bd806619554cd31b3893fed04c94a014923c91e38971835d4d214076aba9aa642d7d60645b3761c888d99b4125932db1f6f023e939e89c497f5d04061b650b17915949db9e8cb8b7803287d920e2fe07f0e39da975398096096f33ddb76e733bc66449f2a3f53dbe1932cbd6b0fc98b8b2b7d9993b9f69f04145df6aa76a2bdef83153f079f8c665b115b17d1a7f93054615424641f00f0638a87c4aa688185116ba1e62d8a089b0a693ec5d2552306a133b85a471e2f25dfef0c9599f15492ec9f288703e453f4b3892d430ac1fb175fb3f27d8f4c2b7d111d6d9f8ef1b75487fe0e3022bd348aca3ed50694a6a202c0837671da0c1b0375ede9cf369094e097e374e8f52167aa5914835be67e09846e109d8f0dff4c0e614ee36f8c5ab56e23093a3f7347b22832e5406908fae271ca9ec98f1d8c53aaeec1ec32a18ee78b9c9b575761e257ceb0fd30fbda6b6727f1936bf36b598722defb4f2b5b3ade97db1b2546ec36b571876313afab1fbd89db344e60d19ea1fd53b9de8878c12f5836345e5e26c8d6956db168639a6599281414db1a431254baecb973ed4c483b3b9e9dbc5bd1d1ffffb7af7003d3b6ef0dce633ae1d900fe4221ecefb69c3cc849e439b9f848fcd726c2b418f4bd04205e161d7889322450eef6fa203d436cf3a1c707a0804ed3229a368fe831aefc9c6da4e7bf95a0e522f1da771115a211b8ca122132d913c8cea80af6e20f86f3114c5f6767c538ededf7fa3e01c8acaf0e93630ff9d1fc6eef8ee5941f2ed7638f8c0730da9db77317e57646d11927e358717752f8a9dcf6381c03e7c8effb3f8b1c1a8300852e3fda7e3ac12ba50a0e08282e92860e20b684b941955066db6978641b132b216e0110846d2d8618c20e31a3e0f68f0e88089865f795bd987e94915f77394d6c0e38bfa0fcaa8bda3d640fe7b5316c4f03d0df538c3ba5ad3a98d184f77e73acca32e4c4df67ad58e2894b31c36a8c95ec641f58dc162372a52ad862b7d91a1d28ac03e87cef148b8c02b463cb34d09fca48ccb5c288f6250035d612bfafc2a491d012cfbdd8e92dc56b106154af410131ffebe9cf400baf7b299ae8a08e8443c465c1ec9ad8cd65baee2ecfd5f6c6520299b60bf2e3305004cdc165f1231b9db40994b26b73898c62e60ad6162fcdb3088e789af5652d104079a4d4bf84520a7f2842386b45d22522e4a13f9b5edb0b3cd459869e74148afc5edca63a1165605e2eb15d0bb3dbfda2d2207b2b3e37a922d7e02f44510f42cfb98309a27cbd21830f01bb8cd5847f07f87e298985a56be8681c8358e645b0f5ede7778704d8ee66ba04e9d0c981fd817de2cbc573ac74d213b1ecfa71585e6ed1ecfc3916cca8bb2e82380e01746e95ab3035224e63b2c0dc52f6a071ba8fb736fd360dda4a674c7031087a7dea314e7d6b5b0550845c762b438f271e8f56916560c1e9137ffaa62049ff5fabe90b38cdace47d7b60267f50edc3ba915652234bd759fdb5fe2559dde27dea5bb8c256038d5d52d03700ff83de62a64b7ec49cb664cf49ade3c7c19ad00a386332a4e2bd6940471d4be71102400ec15571bc087bbefafeec092d09e4d42be66062ed1892d4cd3a444c0e4f48d3d92674274063575f8c15afed5fb2a359c1dd7d3f35abfeda9d46cdd3bec61cceef4954a09a17a35c570dfda4aa09d961d011b65d1ec7068d443d22a43027d533b0cb31b6c9c953e6c7b0021121d97f62a0da1a6d9683dd5d1e4274924856f24e3dcca7030af551d18582a8954177a8ef67ead02028bf9f03249a2d64487c99f5853f80b36890d96d77ff2e990d462361c2d714ba24652eb057b750a9dc68cad2c25f28363edf56a4f7d1832f0a26c266fc1e992af77f81632c8197f2f27dbaf9b3df89a14c0647ee1b4b84673985189cba87755793b958909478bd8b0727d8f9a3ef50e86f889f69bc46a95ecd0c1960484db5aba08c1630c547b7744ad6d1488491be2d032f828aec6c71bb5d23ced91d84d0d58d4f0512551bfa6991bfefeff4febbe4e6bf45f2908fb59073a21008d6130178088bb67a6831dda81842ea7deac23e21eec4bd82d1b2a9a09432711e09b8d7d35618e9a4dca14b88598bd0874abf1a91058479338cdab0ea12734dd884484deecd1bd015dbe00419dae3eaeffe150fcad66e63a181c03b18e1a3025e6faee89c58619d08cb721838312c184472245a83d6690cc8838ce8afbd5a0f8b1f4182251cdd8f768c1659473a2a21155fb3b8efe63126a85359c3dd2c861ccddda004ae60fa71c5a0ebb0bc2b11dc4aaefa15aed801b252af17a012202e868092bc90a67d550c0de6ef10af3e114f06c3f50ae92f73796c45e6e7caf0a45e3bf1f205189870a8801c0ffc9f117cbbf187c5933c7a98bc9ef18d5ea88b0224f8a16d1917a43691986dcecb54dabce7712801fb306a133f312fee5cf674a0707d0ee3b1aef852dcf3f194d8c9f348b617584f2705ae7e6aa1a678fd0144eac2c23e44dc838b4277d51a42b73bf3e0e067333a5a01d890dd0a4e8c9b00225d536cf358814fffa68c7c5236220ba168a7a5fb057fc62a8274a7da35157ca9ce26b53867e09596a3e63d6f2843b1dbe76e753b6f65b2d159207da275364713b5ad33e3cd0ec61e93646118838c7ab7e2ac46400563c8569cb9e14384254b9d8945c7b0321eab40ebabc9b3d805de6c27851856383e79b6e288707317889cefdadc9bf2056378f5637438c5c582255b919cdff656c000395236d92038c975e8ede7f2dedb79f14ca2d57aafa1cbab7b1ba8db1b6a43f6ef7e18c283f7d4497f277181eb8c6874c88c35b01ed2b60cea3c1889b5878f74d6144477aeb5e5f68c479716dcf7c82b2b76090841574832d6b3f6e665f59890f899f17875ddab6acfd9307dca7af44a435a06c73dedaed77f5618747ea19239ccadf8f04a2962c51268fcd698497f90dee4a2b8139c327521a0542a38737ea41716ed40db3e95008158a59fb512297d9ee7a9e90d9b684ed2f6a681ba5bff55b196ba85b116c432ad4eb851cb036907bdc7f4f9bf0926ffb499a85c39fc917976140e2a7a631c7e560da54df6067819b435391218c7de360bd0bbc67a80a69c7b751dfd6e6d6ec244c9a50a64a5f2b68e06d3e3a3dc44939059668cb7a87957aa83cc58cb6597e02c9cc3c8831c1f31624fb08ff7d4ceb00475fb3012b8a987401e079e0e69b3830e7f6888be98e6167a199055cf1cb6e98f6b59d5a0c9415e8d41bb9dccfac8dc186a67e4b428eec76dcb5e8509fe6b4eeb0c11e51f02cc8213d7339583546f4ea409126a543388128865a8e94724420b80347b71d83f984a35587e47a3a85b33f4e2e7660a0f30bcef8f8b8775a1366a0dbeefdfd359d04e13ffdd040568980c5dd519563c3088c82f540823ca8d77e962b538e2a97e0ea63686e74f92d92b87355c9abff32614441d3a1f339f3f855eb6e07e1e8fed3b20862470d579281bec1b748f6f6398f3aaf8590fd0d89a91079f0c06e7bcc63d64b0a1cc742f7894ca5f7e74169de826dbed65a7461dff372b246d3333f186dc5f6b03cba7e20481498be98db9360b5f568efe4fdcf15f7f84538aa7a9078fbed2493934702e9e2aa334cfb526d8750d2991dc33902c9b85d87d9921829fc9bdcd11260a3c5e4958514ba49ff4c53af775a8860706ba90668c991de1f8ea9d1b11f8695e64a2d4947dbe80a6b852ebbf0a5fad5cc630a95468cb37a6ae01dac2ba41f1f1fea8a456d2931efc8b5a650000d0aaa59c797db4c55b0a49b2d32062f07836ddbc2ac82ce0b1c5a4869d9bbaa0acb64041f1c2ce48406c3be8762baded7d358aaa5e4f02153b38525b2adefd70e13464c957164b38a64498f8ca5f978182bf76b41e7f2852e98312706a6e04428c643c4ba03b8a09bedf2edc222fc33498baa7cfe73787116b075df6f710d711ed551b79c5c7b77c257686800b5ed57c2d80bb84f116f2b9f2a5c2e56e2a77b174cfe5c56d4c80939d4e1851a8c09ef5af0c6994f67df0dedbc529b94674cb8f35260129119eb61be099644bfe966b4bcd105a99e18292bb0109b38689eb048253c0920032f970d556e8dfbb5bde250a6732ab802a2a11b9caf1fd030557291e1dee7ea6629e3b4a366f65e52e584d44ecac7b8dde400ce1d96540698f1346c0428444b6cff25532d6580617a0a1d07de8081c61d205e7a1f588eb71f8c7128731b9a4f1d4f414fe3faccb9bd34279b1d28a039775750ab718937c9b9a8068f859f44be687101035d89bef2e48815339f3be56d8beebaadf5bedfb8b36baeca8deb50935c00e02416d26ad482eb03b3b3ef2da235074a839eb7a63351719334ec1b96826f0b3eb3ecc91f7e0630d4ba5070cdae5b89ee5521f11431bb58bedb778a3c49cafc3fbed0f1aa3dd8559b2c8d95efc5040862a42c0f2ef63a04d522060291d93dc1f83e052b3d1ec359582a15c47a2e518df0a12c1ba03bb71c8d2f71bbd79eb116a5f90e5fbb0ef2b19170b8bf191ca70c9186535f854a439a8cc265ad9ec6d25dce87ab474f83885f1b1d12fa184a017ff70a46e5fe33fc56a8dabede823079cbd4ea6f869f7127b20fd1564338949cdd54123d8174ef1ca138e03aa3dca55ed47bfa678aaa9a46b2d3f3d20d227d6d25c28c594361f6115769c6083ec1bffbf393149dfe50356b27683b2448f043762f8a44af7bf54b3a96cd45bd06d162843d48dfe2b261fc3819d6bc8d901a5a37d073414d67d46064aea521871e3b94287f38c8bd693b28326a8e03ec2edf53b1ced5ae72054bed1bf747d5f00f9e24a79476d65951fb99302842f1976e090bee47358b3929ed4829a706ef5a812ad83ca9120320ce434653a68f6e05d8240a53d50e0705fbe0b53a4817bda3cf0fa7944b0e04e85f8c1b82248cb8bdcbd9591db8e4e5744e9e029992b9a5ccad64b1f63f97c6252a897773dec88335244a356db36640027ed21bad065df2a7975ef688ed49bc23f139c8ad7918847c0c6e4f04629d98e96c23623ea679a33757c1f8cd8f87143afedc6ea3128c91d610d781cd8b832ba954ae03f661e4a0cbbaecedc5cd52e109ec2274c68ce54d99c7659f940282e8b0f6275b574a78c4088dbdd3ee27a03ae659ab1811ef14e4fad78ace654a692eb1d25e0174a50b05b42b1c508bb10a1cc2b0a7d757db13912f332b2343b21f859e446551e79757334a46c9bfb0d74543db2c36bb25e97ee2e500c7c118c9395e6cd8b6d86401e3e93774478928218cd21233904d93d2f157b70eb6d36ac7468207968589f75561cccc4e1b0289dd1b5f73e3d2e6b4f5126e9ea47b2a8543f6db57180de0a6ef9325c914bf9a9bc5f474e1ddb63a071a94d8b9e6af69d2863142aea8c5f00ef171576800d0d27f2a747b44d88df878c4114c2a59a08cfdf6a2a4d60b325ad55abf9d887e19063c7a7dc9e333091e5484bb3acdf423be8958213aca684f7cea485615650850e8d1038108c724b194bcdf7047b4c581313fde5d7a3263c197e6164bf642f8e0f0aa3d43caee90aaa298d0f96d7e5f706d1bfafd00545f2b1bd9e7ba84e8f4887c4876160cc0f16569a1d0f75add0c50f6e35ba95f75312b14b7c9dc59b59533acfbc25c6ebd54500936501b5430cae76ad6120487a31b4ffa907e72e1773da4ff4a49ddbe99d19912e35bfbf8c9f1f86dcec25a1d44b6b7875b697a01386701b40b8a26bf3bc94a9191abfbbeefcab9835807e72b142b6325944d70fe02cfcec61079f3341c97d45f054090ee8688fe507ae50e7470421fb75c9e03220f22fa608db257504af6845ba3de1af77f5cab1ef11692a16958fac1a42b6e75870cc2211a7664a3970b4982f1cba43885526874323b7b5e6af4d027781ef166fdac254445713ba9ddecfbba703857ef6c80e43ed04ca9f2d331bef40d02ce780f2d14acff6afe76ca29d6afb67c0af06a9a8e506baafaef49b61ed3e7c0f56651524f1c00c8d5bf49f5f10e22399b9dad546c2ebecf06461463f19363627896e2b4faea4b2b891d10439d94606a84922466c052bf163ff11ae0f803de5ccf6562aa5c0c3bd6e1804ab2aa3121d41bb35baed0ca9926955f7722b393c209ddd3a75f2244618b2035e810f8c10b1f37accf73","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
