<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3bb5c1e93565109c15a0807b70f17e2d12f244f7f35a3283b54856d184c7a94153f15c5338d3a328e0587c8e64799937e1d85e806fc9399c5cf990847fcb508decd30cc56f04daa11514138ddbf2a8379aaf56ab033ff139aa6db910157a76a5638bde6a28f04afc7838f91c349da6fb08c6d37038c2fb679f653de51325f7d251bb4a542f80a68a8e87d87880ee4dbe0cbd206f7bce6e20426e9592e4aec501ac0e770610231a8fc1e0ebe5e5ea97e950c02225ca9d23db6f886a9fc2b851abe24f45b0f47b8913b17263ef27036aa2d0ddaaa9b5af49e4bcca2571e1c6c3a3c30210ee3339779a7b3fbcdd9ac623d4f822e620ba6712db27c00ab068a227d1ede6d28cd0b4cc6372a72f68dfec33a4b1cfda51360ccd1522dbfc85901ca337d9f881a4b104f75c656c88eaa5088f63d62790a79aa8f51a7705a6a5308c6b03b79c976dc9f022da947660c04ea91d33051c07a646e47ed88b53c027c306ea698d551846ced56539d41a7ca025945f2f15546073b11912bbfc516acae2081890897a394d34570244cb37cf22bae97025c1dc3b8bd38c3cd522a3fc7c7136e1ffe3b94e63645c2ab292ce4d3e3dc6e5ffe8339882803362ff40d64411852e860c4919215413122ce3bab2397b831c88819f63dffbc1647be87455d811396f507ae6438a6a5a3d37a9952f062333695617a36b3daab05b5f09a08d5ea56a2ed48b951e3e3205fb76067f8b9bd3b0616ac055f60cea8d090fd4004efd882098cb33ce09dc22461143b35df1bf6faebde355f578c2282d475088eda29b9c995cb17e7dece35548e74f61980ac162bfea8ffe6ee9cd2862e39330533d17f12cbfbb366855d7b5f164dbdbb547ab4f3fc13aec4ee9845ca0d2a0c58c60f8ecb1fdf94995789c01a17b39385c6a78fccf90b3ea785a2f433cc4ed2bb935e123b4214559cea0e5e0071647e5d0cfcdfa539a7ed250560cddf1325321615ddefb6b7506460ed27760d97067b8bd369541d575e9a0860d675080d5513424471d98c23aab8bfa8dd3d3079f6db65eae4b5a05492fdacd8593f43661f473e6ef08557adad380093d5560c209073fa341c1d2cf1796049b2c1d7f47c4ce15fd495aa36b617a21c5983847ad7c7fe47bec57a3463f8991d53e4a8057388df562394b629f5444bc1774f991a1e20b78b0e9698d77e716875ad6607288d83cdb3f066f5441b2398b545f9421a87abc401699038f2566bdfe814ac758852b4f3c276c1af19ba34df2f0258363433f125dc4f18f406f10ae826df053b8788b7b729e4bee0018059e9e81b48c95252f35f0aee8922a622b4a7478b4cc08f85c9895b3ce4c34037d0cc3fba9867dab4768802d32db398c767fd7a04471996e5ab5e3554223ab13def690cdbf895ec43eaeb3d5c7bf9a746c6de9dfbb3f1a5a6aa36ae420fbf5c5c2686d5c539b7a7de6dcfa3f31b3d3cbbe7e1bb81e753ca9d2820b16098ab2daa598b8186b896792ee88d5bea9e4ca456e8020a5e9b6e2645921ac3aeb64598ad4a3638624270d8135bfd464a16797d3a5f088230546e2f97a2efbdec77357d0ecf792ca6c85b3639a8e9633143151fdcf8ae7dd0346464aced11f0b3051f352ed66fcbbc7933fe63b62bcadf37d68fd84ad6cf2e62bdcb2de474978256a9648c660f9a732d628c5927059947bc225ce427cea743bf12e7035d1c13750788aaf28ff70d01fae96a6201045fb980ebedba737a6f9e8699fe8de9311a6fb7d05cbbe939c77e180d15bb3d12aa251ca881db66604237aeecb799f85c7b414e6ed6996ab90c50f0ae8ebbfd1d188cb472de33cf3fdb90b3561c840f6df7485a6584d5ccbc7ee7ba36901ba155d5c203dd7532c3a5ead57153a22750036b5781f6979afa9599c3e6cd4544b9cf50a5297c267db021b1e0a8dc68cb989ab01eb50de8111728cf2c95ee7de1895e1fe1ab9a58490eb1d2ecb63664946bf1e0812a794a4429b41f4441f200f595ec0a9c675ad4cc1ae03a3604c53f01b47a69751b30fada6a0594550420585ed0a4bbf20b8a98f42a4ff9477a9bbfc303104b6e41fdd040e9095dcbea10ebda1e4479df58214d2133b4756f81e9d226aefae89535412754116280df5963b65f5f5edf1bbaf4f189c2c76ddab24106bd318bf81a4690ce01d785bb74f848ed5789ad65b66bbccc6901daffba978d38c5f1ebf8205acb013e7441a3de260e33ead47d462294d2b091abfdfd74e73cd7e98889a1fefb23502bd350246b1f4c5a4018eac73583cfa6f6609de1cfe892e1032a9eee22d865afe90d6f54d47a9ddc6af7de77c826ba66e64e4a7985926506d3adc8780f092c3936afa9348dbdb480f5ec3687ee97b4dce504fb0b80a0b2737faff0e0fc3f6351858347d9fe673cb03eff1c93cfb5adc4784988442395bafe6a80d32743c9f5a1f32a34ba0d45cab6fb7e7f9561334dece1aeb4060957a108a67f963a7e961255e67407e1bb3da57336826e9bb1b4d66ac3185389e1b84686a54fc53c0acba12746418da034cede6c4915995af914436361b06d215536373a69f0d5bbe070278ac270921e4be39d8b66325b8f65cb05d2d9a11b0c2b14e20d56515e73fdb5b5a37e9c8e27a6da5f56b3649ea9e87db29db2a3a80c04631a804476fb15cfabc2932a0f436509079a386b2d812630754dd102dd96886182b309c67ee116ffbaebe5ec12b6edc75aee97e90e1d3f4d51e4e00b4a1286ecd75eb4d27458802270fbffa28b718a5b299efab7b8f8e3fe9b6443b2786145803dcf3a2cc8c516036187f130822f7294374892a18dba1775ed5b1b9c147552ea72fe3f0f5850fa5f036d6802f3bfe75c79c8c81560681f64df8dd9a0a42f2a0ea06b3814bd03ef7d27570d8cea83347624968c91aebf9fa9349c6c5d0571ba6f823d8c06798cf41c5320e916039bdbe1277ca1fde260f565d4a1dcd9f4e1599b722efb47342735df821ef2122606ecc7516aec229d0a4c63de2642763cea741c34f49e596f053cdba3802aeecb7a225b09a6558068cd3d1cbf4be342be068b8ea86565ea3364db8d913c7bbdd12966b8975747d02a9f881e014ab366b79584ca2a23b2df92569a40c9e91f81e11f68b5d9ac28dd4a08c60a809bdf9bad045726f5b682da37dddd56180781b35f54c365d70a9e819f4de5301d93d4c6933a761b752390b6d270b62056040ac9b620a3ad6e350cdd8cdeeed641505353ed0449077fe2cdc71f27fc57c6c07aea2d662012ecd64512de45a2e98e8a18778c59115cb3c39cb109f96019310644e11c429668d08d5e82c510e2650c4b755174a2d64f5addcc809f0be1a5b0e7bb383954ccd0d7f974b9ab81d4038425392e18ef00999492f55f54ab5505b0255f43246b837450d94f410b958555d19f7648141b7c5d4554da9856b6f7a93233c2597319f5e791fbfecd6b48367b7c707545bc46c8db2522e599a2ca01fed7c8948c0a12ad117fdb4ab1b3166e9eccc0cf29caf4d48ce399a5e5be82ad0dc248418a99cc4c3fc834e9291208d01680c9feab8bcc8c37870e8407f66219ba6b9c6ab649902ca3a8257e3dac51995983a89b43debfa428db0e35a16d9ca8723cf134ae300b2d2bb072453304d41592654f90c0b501798dbb63aa7948fadd13c92c273329b93d21538603fb5f5a4ca7c8f72a3bbc663899018e454e38f71ecf52549a8b273cbb3d66cf2cba6a83e1445a8c213eef85f5055895d8d8531a5c4d1e6226954ddb93577657d0ae1218f5f95921da61d0578f36d23735943ad50e1dec883300ac4746fa0b469f1e8eca318428fee2f269970351d00b1a911fe6a6580a44d790c2959a6cdff7b1c48cf966bdc2b58b324d6cff6f0ac37643243a68af1f63d6ca1dbe7eed7eb80b2685964c0cd04321445f33ca9bbe687600afba740d1afd87d74ce9a713096b077ae7639a12e31c3682127c664e8dc33327b932f0fba7ac509b4b31a4669f7bfdd558369b1fe460323e9967dd22da0a42d798c6681ae68078921f71698f31277d92e6e10d1bebc8dc1eb11c0ad23d601d5b2dc535ec53668485b204c370da7ad1ea830a6c9e0c3217a6d650ce59b04e7510b5c3d94307d6cdf304f9d328e04fe43c738888d8d6448dddd17bdc30736bad93041f3721da5ab62211559dd86c893f0fa3d64df12ac6980871ce74b104aff7c8155088d45488d6ed8b39d504202b08702e637dbb938c392ca38d2644b5cd223e43eed5a071c667f869937be702d40706d7b4977f7d188f9d398e42e5621de4c56dac451564e32a35706dbd6b3796e341b37ed03c1e21494d74cf2b9b071a446b3e5c211c0f4957fc7bd7fe94cf7745452712a5f948f988eccd631526b7008f712982fc288247c8a081c350ffe1d6d9638dd5e1f6dcfa95df4d25c59927685ba5f2ba1c43af7d07633a668a9e9f88d8a3d9b19307ef9911ae1288ec325fc8efe12f6e2f9e62bc94bc351d6eb7d39a5fc8703ab80dc9832e43ffd8f28923e19e322376103d64106d60a538ddeeadcf23f903599763ad96c6e26e01afd079cf1efee6bb123835056ece22a10fc6fb888b3edb1b2f1ceefbf8f8d3573de6caf441bee995d1257a5a32e0735f67ee4c50402c66764d901547c58f08d7875ec8a987cd77f023f60ee7b86d57b349344102d4aa526479f9852b60ad9a5150db9ed173c6d3b89b726df475ac1a39b147c4da013e4e69d399381fb200fee2860f0f13fc9a1bdcf49a2a81ffb79ccbce7d9f65d7eefa7c907c5e3f49036b3c68763681e28d8a0f29478ad4b98cc62e2119879e1507ca3f3befc8034850d4b8a483dcdaecfdd21ea003ed96445537a5ed3a280bcfe0f5e0d6987c696b01d4d459708095e9afd059c511c01c62bdfa243b69692f9123629efa94effdb1cffddc12735603d7c1085adaaf3b28d12fd932453d986a28df9eb24f4c34600b94aa4f063b38ac2af6a1506074d85efc57ac3f8646b19a3b173cea329c7e80368894f83a0321caf81f649c042b3590cf31cba532e9fcf633c6b2a5c5f5168bac960464ac3c2e0bd40b39afb7dac9e1c2478d3c5a4c5523ac83311276746dc31399874b90f29b316f51dee43c1ef44fd67dfcc68a561ec5b6660662d8476983c93f4484d15f9f6a4e6f843de30f1bad09ebb97a91a495656d6a4663cdfc13eccee88d3665b5f3715df404a6920f96a9bd8d28e9dcca554db45bd857ba06828d4dee593dc2775508ef86b30b5e9ee85ec5d39dde713f12bf4e4eacaf72845048535d4d40238f7a2323552c4c46f5927d92359747b90b51792b0d4ac9ba3f78a101e4a7e869a0cd53ab13deb2e34b81c4bbf26fa1b13287dadc6e21c8d48b3bf62d5934a8e3a76d29ea3248f68427b05d816046d96d326d624d8b42d9c1c80f9cecab9ad33d317a494f8cb0c5ebf58f8feeeff0b440b9ad534ca0071909b68b18f4301e72011bf1f24c19d84c0ddd1f00cc720df37e488d5703039f623bdcd76a76af7ebd90c68bbca36b97e721f74f27360eb0867b1db83ce57b44e1b2730ecee53d5cd719b61670f7134c32620220926016e3c5c2194be967cfbe17f4ffc196895c27ed57e9cce7f4818060efd9f63aae90f604ca988dae2f03ebae8879a6036c5fec1ef96f115bc179c6985f775015b2f535614ffeb3914956dfb66ad6025e12316f61ad4a0df92b5c17c0d16d2f64af2fb38ddeaceb3643494c49cfad2d382c7c292400e0e47874c928523559cc1ca97766e8131db2ea915ab9a5f7b19c755300ee24ed2a53eebd1dba7ca3015ce5781a365478857abfd748db155bf5c5e41560b4a51ba54ce4289f22ccc6067c56088484d47bf84db93e189740761a2a9b43ced1585938a6a233605bf0b268df5e1fc2a1b4aca52a58b17dfff1ed93f7e35f3e26ffbb8a519ead008171f6d1df2de139dfab8c2f5eaef9dc87d11163c5f427be024dd81b3820f37b7cac20079038cda4500d2b9f7de2396dc3b9c361e65825b5e5e937d420ab1d123f506c4a57ff3a8d151798162683df467f50cef10d0e0e5bd34ae9aa3cbeb786745dc0642759aae3e1a4d64fafe9235d8a3b7eb7cb6b93f03afc68cd0521a508bdcf6c6bebc1d75b82a77d9fb216933ce28ab0c1272ab4a50c87708046d0c3ff88d9152d58e2e3f7ea423c58fe3b77e6f2dcacd755b371faec28ff8ed752cdaf6a2a3a98dd18bc017c529c77d23d03403aae224ae0c0d211042b2d56423d1e6fab6a938a38421a18d8a29799525e34f4457d3e477fa36f37dd7d4021fcb035d25682b65d3ba3958c33404d1db025bc262c9282401d38379d25c69b1435c5af03a7aed34473e5132bbe2da605f0728e0a77d3329a48bcbe2ecd58f8ff44359fdb7cd95b46e33fc4f819c80fe9418006e34e25bdc08eed9700092a46a7835836a4690190fd1a74d5670402383f9bcbe8377b1887059fd7d346f9dc25ed8973cd47a060701ae6e01834497ccdcabe31a741def877fc92e52f26edc443e1fcebc28f182479c62195e34f6a529094c63c8697d7664b26c9b3096d688a5121f1d30bf2f7f9578ca1e3612aed2687e33e51d3f7a86698017fe18e9a171747df9a5271b0f018391e396f6f16f10271ac500149e003115eec02b319a2eaab687bbd23d7da3e881da9fe951d3374fb3e830f9efd225a62eb3811593a1d622f4dda6988e82997e59e391c67e0b1511678aa26df294ca46bd564ed379654ab01cfabe6c1cfbfa411d09caefcd30796ac94e25f4aeb5ac4f855b726db2be1af772da182d34e292c739743673049a9e70da09191ac4416912c5baf1796686bbf2fcfd128123f3790ac668622bbd20d355cd476ce6f6361d46b0d58384233aadc9f6247246e359dbdbbadb3ca1bb97826d69cacdec066106e048feb8f49dabe028a4a661ef5ff0858b942ae85cd11b1d0d45626226c8c7b87a8dffcd4e5e93126c7e102d99a88eafd1a493ed4bec38dab825c194bcf3407afbafad10d79d09ada6fcf5a369b981bcc4dfe35cf848e3296e4303e9e0422b302c12c4fbb9629a6f2eead1e7d8de7fe0ec1772e38667a31d04f4dffc120058e8bf51ee344364b2e3cd41b3e69041f1ea5dc0593b2d189ec1d3e9533f4f38e163f4695b6d8241bbf05c94fa09c9faea1d852aeb2105c4f29b3d87f499313f791fc975c7947640b4013a76866ce3673bee1864213997acc014dfbfcbb78be63ddd24134f1d2580c70580746eb3bb088b4d4710a9c506a7c4ef0e9307e06be9575240aaa2307919d2864c16b09fe81dd9c064549168c1c2f8eb18740fcc397b0a71e51179238eb02d8416446c41f04a0c291186b1af0a252504ad6869570fda3261947414363b16f3fa86758bb2e98197e23140cf15af6547eba673301a9e806cec9a48bdb496100c0b6b8388bb9ba59df4b1b5ce80eb594e2a01006a27e3e1625f46cff74cceed5ba4499deb88fbbd3b0a6fac3f41a55469cff80e85ee80b053d3779b9670be35f18cb9e04f370942da989d213a77322794f173a21ba73c3e606d065ae468bcc1f934de8f2b3a651b0a77147849440c5a0408286c970658eaeca1f351f1e1017283ecc9a0669c3c6bf22cbe14509b53997e081e1b80292a8b1f8cbf04d533f0bff5e14d0a9b420e79a771ed2ee041c742226b1543a479fea507da9326849d371644dfd13341ae13faf553f0bbe93f2eb3de3ca99ecf0421edb699a377233b2b73c746d9548d21c2fb8357e4367a78609d833eafeeba1eafa7ea91ce6143c1574cd9490765164bfedfa3cbf83073d82485db98e40292279029d1fa2d4706a51f631bf93c21a75a249bf43ead440187d2cf3bf7d01e03720477657b01e92e68f368b0b6d91ab26d2ebafd6144d2468886b06a20b676e0d45a8c0c95c96261a0be38497b2b1ddf593880f75cb06fa3db54f3066a707aeca6433ef5ad3cadaa30f80d1f2be95bee4a96305780501a00170f534bcc3fba6074add9cac0355625fc1ac1334d0a8c18df9390bf492763112670d72d5782037dd5a8bc7f68a14ce1c4f4b10d9dbf70d68dbf11a38639e1cabba4fd88dea129ac974bdcc66b894fccdcaaf915a843c43559660e30469129ae16b71ae7059add5f4cac38c47ec1e456e3ecc871b73460bb37366dd71401ea4ef8e51d9a38a17998def4cf031bcfa789108687c37548987141f83a24481576ad1e7acc191d5b7c13401efc97d32c064b827d89f92d638bf3a1fd496fbf20874ec9c4251d0bfb91d04c9214f0dbfad21bbadc743dc1e571f569a6d7277d4db1c3f7ff0e6688db6c8091ed5c302d7acd7299e550a69c7d6d81303dbd0ac22ccff1e1d38a8cefc0c19625bb8f894d6ed79eb565663f58364a6e1fc20f31b132f02c13b7b2b4e746acc84577ff7a7ff474b504c5baab23ae4a6be526f9c579353d38bf7d0cb4d65f382e63ec142a45e51185e71843a4d1603d3dcd6a32eacacb8251d8946a84db9b457149d0a49b5dbbe0247e442eaa13e3cb581abde8d10fbb04f185de74952465b6b53f56956f05e2e79b561809a26e1590610c2a74d28d6d14fb4959a358172c8638f1e9b40200de462445074f3989f84d29272a34252d1d094a9104cae4f09a3d6ca6942225ee6e183ad4d6453c37848bfc4e86ad46568d0c17234eb2474d6ff30238349c587fbdc621530d6ad07b1937b6d560540ac7c208e15931305e3466387408e28e6a630599a13aad4486e95db465d4fa74f7751c40d3b6266bdcffe5b065857096eff86de755fe7a9af3013cebae47e53cc56874ff6cb2ce4b40a020e97223f8323dc74d042aea0cd67b483b3a765e234fb75e5a340db024209a38143bf8005d37e943e33d6b5947ae601ddfa80a9f5931b33357aad2c86f97af7809e91b7e276500c852749620f444fa2ee5ce48ba510923fc19613c25a31a1035041c4c32a21c9be236ac89bbc83f250be38270f70e7022bbfa252899a3462811126ea616c60e99b3e9f49105196e0168246bb22bc3a1ae0f08c924554e385e0e37c367b583c403b7f85f5d92f18fda89c2fc5533f49d4021b705ce85932d964a98b06f52196c8b001f011741d94b578225d078f5c2b0241d6125d7815421ce0e1b91bc81d81087bcf921190ce63d686de14ab61765cee37948b53326a2467fb5391198d1643e9fbe87727c8cb45a93865d7fa584b52c7a5a91312a4e113b3b8e58afd8890a38f75cae6e70721876d4f8795bfe8cfde8eeb62b2cbd7c4ba8249fbf7ee7758a136ba0b883ffeb758497c5e9c0e9804c8ca0554f763d95e08c94eddafcbfa838d8de1dd921e530adeb71a4ddca0037965f1d47e75cf4b33fa3158f093e3510fc201314dc8d4ceb80c6773d86eff0712be24327ec5dbcf654c138021d0a26d668a0c0c8d1dfdcaaf3fbbae51a05917d99e4e708da4002f24347d5b5e50cbb9442effbe6b934cec6069d9056b813fd94c06c068af3d9933698a2731121abd62c730d1800cefb7c36209f2b3d96b9413f4feefad6a50bf9425b3012e1b9b2fdc945ca061d176513a45797f2cda4e40a38853fc5370fd581b22a44cfa2e374a354cbfe98bdeb9545f509f4c5e501499c5d3b946436906972524f6bc0a853a8b5c772dd5c1a44bf1c5690b4d765db89e0b406a434dbebcc0c4dd811081e2d8d3e3d8104952061b12fbb026e6127b75072e4531cf928429aa499d7e56292d3d825bf58633d90929c19aad3aa44180e659ca6330216732b95c78ff0b0f621b9f66af426ca966f56cd809d1b924cfff78c7f7760db53ec1b88985d56b1126ec5e341e14d78a509d3cca9062135fc11e530d568bf83c17dd290963f7f5fcf16378f005e3f1773de4a24f6d3249a23e6c2755d672c07eacfefdfffb2565e1982cd331f5eb0924e6e9755beba8b46c87b0e11199a0baa70a59c928b59b1fe0fa3bbf8a3b0984169aa5cf469b0d3aecd835a733e4d7fa2240021b535f622a4884e066f0a6c9d412d40177626ed0a626cdbc727f4e8dfc6623f12b11a4e52e62549b2336467c63282dd8461089dbc8dc30ca7dc0c9dee8d07f5e00d5661bc22098e3e5f009142694fc4cb68e032d48edf68d0e9f654a3b3936de72ed21d4123c023349ad90e50c8731ff29a404cfb7d687d29c5a427eadf4214ed7ba2a13eb89b26fedf05c6187eff5e7a74a88118b64cc383b6cb500213abb7afb88a2010df5c6feca56d81c78a6d90a1c51a79e61161a7b01320bd086241609d1b27c05bafe44264396517c7c07e6470a026114f58bba73558df0e81c45c079f843af27a6288851a6ddafd81d32ee8da5476e6cf43520540356176177c0fcdcb156f850c65f9d9e518b7f865bb8f04dcb155c50df60198bdd6b3a9b031082210521a529355700b21a1082ea2534b8abab4413eb4a4b0f70e0651878b8890cb9ca6943330a8c5ba9bf59d4dc3c2ad739bfcedde97be41ba717d629870e9c47a473a33750361ae0c952480dc4e2783041889360ddb7937267bbf1608790dcdf24bc74f93e70d24999205d593b18d48284676120b7ad2afb126b75ad8874a97d4dd0217cdf7d468da93f27bc7e5246e972482c8c62ff1e414c21f2a190617643a59659a55749ccafe69749c150c9751af8522bc2e89d5105d78267e6e49c4a2e5effea7854224ecfe541083dbf5b974c8acf17dcb3288ebad36db47f2d727d6be3577ca6c2a2c5c6da810f9bcd3c8284784e90d9f2d88e5c0154ba84b71bd39668c01c1f0a2193e78a0497bda5d948e06cbce0a11e6430949d73d4226bc0eaf0d2691772fda8c8707e8aaefad408da5611e59ecf1430632a1db19302e75aa2e4ad1caa5540a5fdbc606f9a94c0c219bf3bfd44936dc3056f0fcfecdaaaa46a3d660c4a81fe7b8e4b89fa20ed660a611b8ff239b8e0185e0330a7012e0aa9ef962019a96ffc681f20a5f9377230625d595938202d330bf113635e76a62cedaf403aaa80bc153854974105ba28f8aa2f965a1001480f471a15181bb399c2e50413fe84c05a9dc29b9d501a55ebfd07d84b04e8273dfa3f8505a41e0a4ad2db03bbbb2be81407eeac7796bacd1afbe8b9e531ff288ef4b6b3fdf93993c13a20893a69bb7d300c0573787a32a84fdc43d5cfab9d7342ba95475d33c741bdf9cf0a4a60b120e6631c01608174fe6321a92db3d1ffdd24d5902df9001549cedbae9293ced75a9b43a7022a00478ec2e6f42f9e90108ac46109f124407a38fb6f2942121afdfded7d35716d32409965e686b35682f5db609113e4548191d8f30bb90f07614d774182cbaf0e86cfca0675ad3389cf8cc21f40e7abba0d12fc10fa81122833a6c5cfedd8b681d21b76c1fa45408d17b166e11968b8fb2338a12459448cc07756597b218a703f9f0ff36377c1f97f68b994825f1745e21db3dd782a27d7bc0060b8363c7c644bb1bafb8dccac71bb7dffd77854d1bb657647b42f321eeaacffb45885211bab2c554c4b9b088289b3e1602dc43aa5ebce28b58efe077a68b79651a8412fa857517d32ac603de00c6841bf1b2d92a801a55671a782d3c16e91606ef2301fc0ef26a2dafce8992c2f5dc558a75a519500aa2521dcfb72f767341a3038bc11081c86efaabe6b7546bca87fde60eceaae3da58739a37da524d6d31d442da56fa4f2a24548497ca3c6cb4b51d373782e24df8df61059175bf5dc6c91552296c54e3fd36654b4629d2ac22021f15a1b84eb1b19b8bd729d8a4e21f6ae377c5690efeba73791f7d4c27417cf8d2a18612267cc05b1679eab30efb5131f5b6e9b7fc01d3ce39f518677c53b3ed3a407fa1969428d563020b8fb10d0ddc91e8670b692b8805403ac12a0c2b50456cbb096e4b1b872ca8ce2a613e2e00bd0bf74264a32fce5a3b323f9cecb0b850f7b5d4b9ee55e1ee671e292e25c310b3b7c0cc41fb9390e80df92facf7c3dd08aa3f83030df91d9fa3ce0cc043a34139aaa09215455e200aaf9dbbf4d2d10a7c7cccaa107453b70c52f19fd329c150e911f3655f41a5e45654534c29b39910c77b1c009d5b9c24a08956bb7bddb39fb2a1138af090d2b7fe58c6ed83295e4b1ab5a8ad6d5592e4faf179a21e30fe38dd895e1a6211248e4a3e0e215631ca4c679cf9dbf3634b2697523d2cc38eff237cb7dec0daf66f11512e17903da4164a016ed225fe1b2b2c6210cdea52550efd5f683b5229381a9710651f081212f638d7dde979eb8aacde8bbc2532c3e402f70dec4e9a5ee37a5f090693f406122cab4b9f50ab184d7112c390d6293b750bde6db66532cc22b655ce2a0a7a935d161aad684e3c679286f6360d886b037d459a0b905d5a7c7a10197a5ec57d098117707e0d9d6e635154566e3cf5fd5bcfcbbe1edc3031d5d303d436288523bef6c766177c7f0f9fd916d96bad9b2932841152abe7620cb195c47386d5e3a2585cad511577caab17fd38303fb84a8674127a1e1b3467b3a0d89cc0663be38f6234fc0370fb0431d10485e6b31846b5d2924bef3a586c239f6cad7951abb881926a2551428e7fb1601cb96e41921a7562b4ff2ff097df5c1cbfdfd92c88248e4b6f9e412ec3160b72b64be674cd613c67fbfefcc60e919d92f3b932a8cb8112296e839b37c248ef9cbd72167b62f0698e7e632344332615b779d5cfa20f878a02e2c5c2993f943c3c7213a629acbb6a15211e3a12b60250c447c162e182b7b0de509b781ba142d10de289cd7e8a67f9a6e8bb325c8979ba8f5a41d03cdbbb38ec2828cd3b09f5bad3e1d15af9043ecdb763f31999e965870b65068ceb0125c9f38156bd2b63524ca2600e712777dee5973d4cfc47339d38f8ac84fab8b200bdd8cf14e59bf8547a0a51839b84d0fdca76863796e075fc011db38f728eaefa175cbd3a58967ec3273f4e7b7cfd9262ebadda1ea2f00ffdad454221c910483b61cb3b432f3fe35bb0da8692055a7beecef1577f00409ce69e952e38ffca55ba3dee19b9c8d7542ae643016256055b8cd2576789eeef4c2dbf90ffdc25e8734d6c1fbe3b4ec46cd4433f23f7c12bf8e826ff1cb0d5550d96cf481e209d07ef16c0c565bbc74556a982db9cf1271bbab8f1aeb6a9258a74eaa3db69ad5c5f0c4c0494837854a6ec1d78b182189cf208c5147257459c6ca37534f4f6c1c40890b7a992f90bda4cd0a1179db5c55a5b7ffb41174f1ae3d5f1e72bec6124bc836c7ccf0e10dd904884fa8c64a085dbf4b730c3abffe5e2cfed349031c5848ad98fd30c9b9c112ed023a89d1812b9c73e1ba5997a47b0c0bc2a8bb2f7c8e9da9c6216bc0639c733dc89cb97a026538ea3dc033d101be1842486bb89488d61c2d023196d06cb4f1766152094eeb43629d08422880fffc54fa7c8d33dadb2211949951685912ed50d1b4a91f6d65aa892eb31f2b3c7cf13c0cd49fcd9cc5632881c17cb66443d9eb07939fa3907e608200fcd0346fda3cc245519c1d8115d4e3e5eee6a4e3154340d43c44b62c0e0c3fcbf5334605ddca152c1381da533af36e8c14d383aa6d649c1b999817d59cab36bea36b0534b951374b7cfc1d8e1ac0beb3fb29ec77c88fb25d8fe3624989bcf020b6dec2e9c7931083556b60eb52d570ff0739c17a0e8c9ad590ebbb57cb3fcdf5384f95dc9c0807af9478343710c82fd57453ce87b5106b683d8f5104204f36853f5aecfe1a9e2fa108506b40379a442c8b58fc8a61a77c2c603c49698e6da37bb1ae9bd8fab66e3cc450ecf0a04a6781c770093183c94b78d6fc7bc5170fc9e2bd16358302d3d8e370dc01390bd0277eba5a1228b5883d431580a72da989eafc3101fa0207664283fa565ecbdbb7dddfeae712086f4381dca217405da64151b8cde7cbf76be6ff52440f5dd328af8549c48d2358a79b4fb883af3833e985b0abf2ec6c898d6c07a4850749f4e24874d5592c53dc065106421d659ce8763d4ea21b36a11bca4b08b939d68354e0bc54d7d7a84160b9ba1daef30d28de9cd5e0bd2f44b053fbaf348a66302d2ff81f305c9b549d1a6d861f0186e0fe2b5ea8d2be1d130ec4e3ed80ac9484811df0cfe893e99fd58275ecc54aad60589ab9f84a881d4171ff3412fadee6833cd9d1c5e3d5093e5200ddc3953bac533dd78d314b9725a9c4f2c889285bdf4feeb41c80bf520f4ec30fb71f9e96fdd289558ccdc3e08e7ac5bb9a3220964d43a0139697b7525ee20ea169951db5b378140b034506bf880ba86df7c2790122f7c99cd80a37eaac52e58f698d75378913c7e337975b85f5ea925f61c7e7da6542fe25f645044545415f050ecd885381ee819c0a8c2fd01d4d0da285d4892c52c45b4d3781511d644237d90246f9d6f6842bb33bb9843e51c16b097b96ac469d50db0b903dfb9cc7e2cb5faeee7a9359cb675d29229ab46cf68363719de4200ba1ac2d648cc4fa24c8e4bee3f97240316bb91aaa5343266f3ec8561e329ded51e872e1ad5ae5de2933df89698594a80e5fc1f2cbeb8eb4baf9ee94ff8c7a8341efe1698c0eee310ba43fc9e679517ffc3a9d7589f76c2d7deaf93ee08662f0683b8f795352510bde55226607fa9b8dbe55b3b5836650532688a00ea6147de21bbcc11fa650da8133309d1c0c9047bfdbdc6c781e156b0ddb38a28e3e65ed1f0f5ee5937bd0672106719b2a101a4993181f41f9bff4111ca94267af25303b26b60a3e0815fab77a69c82de974bb937816d89e3c8c1eb45411468b8437ffa389bfccc0c54444308980b29fa6af892c0cba9800879db8226ff26e14e550a9bbacfec38ce3a1213fb0ceebeec927c0e196a9effdaacca9e9e3a8e1aa90bbdd19a86f8ced74a3c7501c090cadd8e9b60aca135671533243c8ec7c473baddac8277a8fff4700a5ceca426ae14558b6a11dda09b90f662c24348b51ee6c6b39de81d3bd7671e289a6cf8dda5b9a6ac9ef336b89bdf839e1edbce9146f086b22b54b8646b409e9e3d35c5ed8f26f1ddf2df1167bb4c0eb7f3544d3bd1b8726379ac3d841438ed5a7abe3fe92592e9441f9d855988795d52464aca7913e7e3d705d092a59eae5173c8ada3833e453cbcdcd302fe26e4d0ea58d49c620a57faa9e7d5131aa559505ead807f8f422f33af312d43417725301a7b0740e351c7445cc3485b270fe67acb8dcb09ec845f9592b42b5f79d513ac1d43573d9304e65d81bf7de03290d204ba419c39f5136f5ec508c57af0d32ec94f2770ba03395433cc60510e9c5c34d183c4140754e2f0e08630df97172a6e8f6de48b15e2ff18d7fedda22e4b0f24a7ec1e4f0a72d6d67aa6f885eee22c5cf5c25e772754702561e7df7d9a1787e1a1586df7bf37c39caacf7f0ddcc9e07bcf25c65a957931a07d7e584fe4cafb8806972eccf1969f75271eccc7f0ca22eb10db84441bd4b22ea637eaa1275afb5194f16f754c860ff7b5ae514015add25f5d3d468ad3447c5bdffa3f3d3526f1859cbbacbb7729874252fb0bbf389244a66d6c9ae8ad7e69ea1d594ac3bb2b4650f3044fd9e4fd44f040c452fd7b9fadcdd04ef8c3fde07b7680ed9d9b99fd470b51b6a0f924346b4dbc3d0d785dc273965022494f7a37fc72af50b278a211b074c03bf5195bec4cfe5638c4296cf5b50860ce1d1eb023c4ecf555080446639456bf6b1ef0fba54aaaa77103550ce704e1d757ae1317e09db316d8382ef51322a2b034bbf04678da4e0276fe11c26b9982f77068539e7860487ff8ef4f849c3ec5eda6e791a9ce8eeab8b853d9fcd6a20406c1eb09bde18c61e34ea7c5a8393fa9676c20479a92bcaa74252d83d92fe015294dd73ca8ecebab40629a330d02be900667be427d7283b36a70fa1bc47e4472d6f0390ca803dbf38e2b615ff61e227efe0803eb73b400556d1834ff5cc30ffe9dd3430986cbfc80327d25ed9e18429587a6ff337f5210435d46a1767934105d7b1a996d8b814889218c5746862fded7bac7f9b16bfc44a2b3697dd5cd96793c073cfd5cda0bb78482cf1dc425b6628bac78eaa0c700540d48aef4ed3a7926caf6e3ff3bd32e5d3e492c32184077906bd725cf03c641d5f7c8221ff6d4e1c47d969d4b1e936fa4fbd86849abfd855023556f53bb0f8433cf212c01bb5bfe7df3e4d9d2cc99a2fd4cca236d1d9ab8486b0fde6c38f159d51bbe2674a29e9285d378df9410b9edf0d360302f26297ce9021ff698ba3501d29501dfc968cfcc4c7e02b2402a4fdda0f8dd93de9ccc703641b19d96a931b05bb4737aa4dc7c09c8e7574e76224ac355f36d0b9399f0dc813aa3bb87c97154bc2f7928afcb9b84fa8fdbba8b708c859bdf077cc845982f81dee6968d1b69263f121ca486ed8a28f6a4175b3d31a1a10995c5d2491c2b2ea4ecd4e4ebd8b60958fa663cf844175d69f60d4c6358ad39445d863361200d90112f3e5882e8a52402203a7f52cc49626823e896158dec2f3ce04d976ade3c9695f4dd06c5f09dc6a4b741ec5cb5fd93ff2a901fa741072cc5ba3fcc5737899f8b80d71774fa7e887e78e53a7eec7a681bd87abe6a6d89c642c0037bc86dc528662ee5851cd9c445c5ca56e8b19f587d9f9baa668b529d090bfee9bc50672a666887ec2a956a04f22ab39039fa67d87dabab4e4cc50f6578a44c7947b5dd272d84381f76407a6c72bcc63e0da6fe625b3a92efe84739505a30925cbcfb05285fad4e2cd090bb6478abc4fe9863dc53cfe14025717153b98f4db104efac1859554a4fa12acc3074eba4b65b77eda3b5e7043b72f6c570a4d1541392d8e2b1ed7394a66332d1c574f006986e3a7f2297d4e2108ce3f9a7832eaaa5ab6656bcb5197156ac3569b26a40880d4172c2b24c20fb3eccc62c57c322ed5159a1499875616e0efc4c32d430dc9753fa25432c5df2c3b9eb50a8fa905f87d930ac1afc12914da885fedb1ad6b32ed3fff115042b1fdff24605b71c2fd10a1b874f59ba2acf7062d521e49d970e05c6f1a524a2c7eaeb06a2e401bac0195033ef7ba29c881a3ea8810e92d3f6783304f7ea03ac26752cf807dcb62ddca462fac6d9418c5690c023196a033b72877d0d4936d0cc830b04530427a06fd0330761f29b3524b70d2569cbe98a122c67deb5b7a43b3bdddf2431eff58a63ad8b5beb7ccacb4da376957ee3c107c7f079ffbee8f36d27836217c0a78b5e5a9b7bb2bec120849f59d21542a99cbdea3b7edd5deacfce50fe714deb2f79f78141bab85507ee866d1a8d42aa45381c8d5cec5619445204c36bd9053e1c2d6a1086d9cf04dd281f67d8ef99ceb2c1b37442cd4250ab98876fc6ae5075c670e5e4e6ae4c6cf7d53f8f5899d9fbc809edeebe97ad01322e86513ea696498757aade0b31cf620a152544a34951e5d54b2783ff4e91da67eaf8c6fae326a5e78921589a4060379fcb01f817ad2bc8625d22801e6104ec8c8f843bd2afde677860204e9cec399311ee5edcd7e0151548fd3dae4253817b146f25593d281c3c049a265728037ba5fb2caf86cf174e45efe8298be275d53e903fb304de40cf8d23121018edd61c4a7938bf2ed017fac01243c7bd1db53df46a49745cee97b1a6742fef4dd4497d91fecd4efef048b082a53a025901eca46a99f71a698c7a4144272fa68e35834b36be6b150e6fe8cbaf144f77b779b9fcd54db3a4357b4ab76561f27b4ef24786cdd90b8a6572b0e42ff7a92a2d2f34e967efa80ad480fe4bb1f941a673179a689fd6ea78b6f3651f8d2ef61e34230531fe007a11cd4b25b8c0a909f47dd5570dd58ceecd49326d495e7348941e24cb8e51213aade790439994b6a19801fd0b93887c80676d47c4bb8537779f7121954b16b5d0c97769b186310e8a043c030a2dc03bd9bbdfc50d7a16166936af9877beb640fc294e15893fde54b5babaedb3f6282a27a3cf1da3120326fd57a7fd18ee9564825be44b10d340b31ed27f0359eda627583ae5366cf809122d63b0b7a6d57d0d5a0fa001694fbd8f06fe1ac2af7dd566e420fdd260e18240a76db36777ba9fd33a632d9b1e6491ecdda5d9ab744406aad2215845558d9127e2355bd4675d3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
