<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f7c8ca31e73c703bca102f69d2264d3f945f7adf2dbbdda0411bd4bf0e471a19b9c5cee0268ac9a52a08ec99bb0b73f91e820e94e992aa1e86f8fd997d45171c868ba90392a36736b034b6d558d906e858743d40c91c00355b67b1f75f13d5be379d16bb0e7bc1cf5950786dd74473af65a23bd387572cc575d2fdef22782513d9a663e988e571c7dd62b07d662c2bc736aa7ddb333f4618a0d7c65608237d197663996b438b41cba53630cc817a0bf1d7a22b2a961aac29ed0e568b22420594a18a9bddc038e1c3dcccfaa5b5c0e1b5de925454ed09ccb35f4b9fe5521b39631f138f5002a41219d41f3d48b79cb9c5635a1de32fb47aab64f39f43e24a181661828dd0367fe7c7a5e7cd3a657c362bc2144e5848bbe6ab69f515183676337ce30d3b3247f08ab934f66694533f6548008ceeffc3baf750c40618fc3917a630d59506399f891d695c0736ca9084d0e55d856373b6faa6d3511e2aa3127cb6f2a2b0feadf54e367f401d3d222b3a7ec35516d0a584de43519470f987841541e1b97f1c0595d9f97733196855aa0cef014d3e1593e6a14da85a685410fcf24f5a87dea48783e48d9ac8ba95f6c4c81af4067be212159bd4c6421a175022255dec4ebfaeed6766838902be7c2e9330b9007571afe293c63346ca8bd7442612818cedf08673353535e19e106a67ec4ee95a231350530f87a566a398a9eb71bcc781e60d4e77f897996049b00cb2ff2ee5455fb7dbbd49f93a2ba17e76f72d494430fba185cc210e29289bbf7ff4a044f80cd6f808734ce7b679abfe729a1550a0702ec530ee8d75f547c28d575a8bfe303ac7a7b3c052ba50f3612285eba87f3a7f2e163a591fd254cc84937f5661e707781af1fd016d160354662c54d5727d1a51e64f330b71cfc74e5908efc04bef214d84859084f8e0f57e8aa2aa33160407ab3893c421412b3706498f8b5d7e8f6b9ac1ddcd46089440ed50b4abf97d665a72203a63990c6f7fc4cd9520d5858db65f929f80d56a1e1d7940d770d1ea8c09d2024e83baf4b4474225c5e7629623bda2c813b99da7fb6ae8f4b5820f725976879469eff1651b59bbd00dfd040b655f8931f529d316ac8bfd1974ff403171f992407320a17c14cb108802c7ae75ea36fac037d10ba3c0b782e9c105a08816f53f79517442de90cf16c1d74192d564c340bb25afe39b5ae987a846524acd9a3a9f252cc45ee30a534d12e05cc5a63fd71cade597f436e1ced50ea2a4483f3cc6cf1d22015b673aeccfa07a8ea3e695c7e66840508ee0cf099223c509b9e42c349b25afdcffde58f12ab4dc4db02cde3a63f8e497e3b455cd2f6b746357fdd8e78738ec20f4bbcb76cc50e08a62c5f0d0df77d0fae5140e14c5ee6b2e17fad5c57f162173e1ac53f333f4ec447a797dee8baa06d072e7f7ab1b081b38b280ab278297625621953b50d6d1c2d7215c3cf7cd83acab34e9ab888ced82cf4c86120aefe34d1cbb7b24ba366b9ed63faf1d058905571ba6f2061af6dac248b6403316c5173b0d9cfa02dc8eb6def703522b8633136315c40c7fb99363de84f295606fa78fb198e975e6c893e2a8f414ecd1efa20e14810fa34e6e6e6968c7813879b5cf9f0410dc21508c9126db5f3ea8222d75ed08ecef04a15f0f53bc094eefba2158a33e2d239d746919e2a98bedb793c1bb29deaedbe85f40417c3c297a92c3c9fd0b7b5a8808b5943d2b97906d771022b17845c67e66b4d5b0c8ccfb8ca0f7942bdb376225bcb39bf1ddca40bb76e02810de2c62cd00393c92140a639bf6de44c41b0c11e9cc3661c0f9330851df868b225e45782af2898718326b3402c0ede65550869177b367634edaa56b89f446e5f800630a6a32b7057cb191ad4855f306a3717fc2c8fbf1d21468a0e77cba0a5b15bae165645732a96116d85b1989eb32424a289f2c9e09b6f117d140b54b68a5fdcba85376636e58e1c377e0eb813631160cdefe1cabdb2fb1baf295ea756d4dc9f6100e51dc57f4e13f2a9eb9a1a0741e63cb6fe3c640320c3dfaf7a89d9ee33b672a640fa6144072f574305be40a23a5562f8790f122056fc1b2055d336d5ae5f042f2e7845165498d3623221087947b0caa744f71b3bd85bf3b67cbed7c670cb8dc3b3801ec05717867327d17b9b8856e41cc616857d988491c8faac72b60f2e3dcd9efb9bde18238a6846cc27605711ce82e949981de6996f96cb7310eca6aba86ac60803802bb58c65d585eeb84116a0f7793de76773b6ccf31a8aa92496b8872404ffb7ab7edcd5502df2f03386700e62d384df88b38f411d1e0433a05368864712ff20faa8d85ab42cbc4610c7e04747e98896a195f792a274be385ccb04869a7186d5154810124780fa7e84cff79fa8e96601a98dcf1b037a943ffec4ce453b946e13189f9c7ac4fb57bb9dbac65b84454faddf4a6a768439613c76b31624836ad8422c6be808a44155c7a17d5983343044f6e30315671b81c12e9f84f823c9f9c7f22698138894d9fd65d75abfafac488d1bd6c43b29dd05f283532ffed21a6b05dc02774f9376caa745a51fec69c257bed23f0104618dee45234d21ff535df1cc068ebc4b04b8f1bd0f78fc708597d6100963a692f85706cef0a48e6764e08e42562ccd96a8b2d91baa0b7a6995c84553cd296762db6b0f8c5e5d91429c1cde059c1a71d5e0c2aa2ca4181a973e923f05c2f146bab68da1c808b20373dc4b4c8f7e982561a99dff9eebdda151cab9c8d1005bd14500688033f5944fd1782cec15736949b1226561ca39bb39860227c6884f3e1cdf90ff0d1571c97653db93be7ce28216b628159ef413325e135fece9cd9647f447d6741fff230829450194b41777e056633d52220133097b8587470a72ad232381561d5360f08afacec27b631dd111af71007f4c034b39dad135620219de320a0bd448bff23e07db230cf9783d65c8b3f6595575c91463d7ed85aa6b50d0191731f474e94fc5fc718b1bfe906199a7bd6d3225010d5c28ff19fadd650bc7c0e81ac8124ad8f6c43c0fc7a3de7af7413ca0687132eab6bae70ef85cbb5c30564f13b4510068c86c2734504d11466c7f6b2276c2225add489503bf10f2a315c8805d146526b4e7891b71ed74bd4442b071cada111ac733baf67919a3c810ba68d1c72008ee58682459f0f66df4ef5b3e9de2f19302f3e11fc1348c54b86a1b57e797b941330c18d34f719c604fd5144b4c77488ce21b9412989ff3a1d2088a7e61e616caf5f4fa52130f185b6434b8e82ebe1be258cb4e369c0bb70071137cc9a7c179cd538e7fe3445ff045097a96507ff4a47d0408de121d740199791e8f393e2b722366f5c96d44aed7af14b37f96b847b91a9e9ff20cf24935b3888b06b9232024acfc5589273f63bdcb5cc2ff5eced3b91f9e46fe9e0ac3292a5c49b9f6f710e0a075b5060be1311e49fa03e6f10486048f21517f0b26a17b22e45c83f1da1ef98c53db9ee965ec62862148a3c31c68a9ed404040377d0d20c7ade8fc6b3899f39c4215b0a94d89e45b9cc7edd880ed1489949369e5598925ad5553de5467da318b56f81c174c92e2371b5bf6ea9093f3581a9edf93a0ab21093d729e3dc1457b1d479536a037634a9a11163f9f098bb7a6976e617c241d9637e587b208a6ed91756fffb97e10d9f5e3d0e8c27dbb478ee1e07b491335dc1760c9bcc5a7bcdd64f49a7fcbec4e3f33bc98fd178984271e114c6a0e9d838b541541db295a3fdf31168f5937adb6e2f3c92992ba57877d22e5219c5e529b4cc35e1f26ba5abd48c3be5cae1bd0feaa50de8bb86e62316c26ec28145dd630cd0c4ed0b9df39c45c12f38e8329917aa6c1e1eb00fb469ad58293c1a91ec6a05fe632ed7593af2882e8ae2a7cec04aa5063c5b53b2a2de4ecbd84aa9bfe6a7c46a71b5131fe45f79a05043ff9b47fb02b3f0a1aeb545d3626473c7698af91d67d4646f811a0d1439b8b00472dc898fae40c62ffb8a8ad00af42c85b390e82cad2dcf3b002323664b20a2d1fad04a1d902f92ad0c8a8686305c3a766cdc45baff0958add43f13a2fad50859b74d667be9575e9824db7de68ac12b38df5bc57fb6370397243c484746e359bc63d1ea762a485cfc81320d48c2a2b9b101dffc0eee9a3244f870892f5128a8dd0b36b4ccdf02d48071f7658bbc9c3ddc5d815fa2a3a6487a027ac449ec3a91d0ab2defa6b7732f661feba1db1644d7734f389b757f749deb68e36a9fa89aa814f573db1993df26c8e8acd5934159507fc2bcdfd4b3f215d1433774cc0cec4fbfc42f0cc2c5e2f38f66dcbd037a3ccc504e74c4d62361688f45dad737581ae8a8415922769c80633e7a307e315e629b907b450ca63bb957d182a57922f4530156c7ad27b938d8abff2a3a00b752f0cfdc955eed70d646d5abe354e15addf7814c4391de6c1a98006983afcecbff26e12da1f3625fec43af2430f70cee2fd6963ddcaad1a3089934979893c358c053821a7870dd0a5652c83167eabff051acc5cdd39a47dc4007d8d2f5ad20d08a08c48af656f1af53afc66691f07e57e7583a354c637689632008bc2e0fcea0e2062e764d40c49b460b8119612c0e82dc43a4d5d75f69c497543512c8bfdd6f41595a4e568ed46c2297211c8c09fe0a3d36aad7d264fd7576c27caba914dbf2b2d5ce5d3f0f87106cf71d1999223e024652efa9e2f1777d178d27d6e1ec89bbd6c6a9b8a1b0c21c9aa02c89e003d771edff3af3eb5a6987e76b0140ecb4ae564aff85c5e59fd3d455077602d9536ce4a99f134e49bf31cb7c8464c72caf7b7be8486cfb5aa37b66af2248f30402534034a7313589bd50f5d846eca6cae158c49856000be6e3a0750f2201fe9ef6d0d04f8d13a3c0dfe3392b09044a47c02f68a17b6cfbb434dd18406fd234b2fa8ca087c749a14fad259b6d0066c5a8b0c4701fcfe90cebc369a0350aba639172b520728ca7c74b9e80db440d108e661c81614836fd2e08087c2b03e898f15c36d1a842d2bd678194068d25e79ca294492f68c994b21ac387f63165db619cf7f91e261a3c1a986af988bc89164e56a35ec7a1a4f9206fc1a232a6c1b94014bc2990bb058210f76d80d37b85a08e9acea3571e139d959ca4a8169e4ead41e48fcb032f4e64d29dccd7928d23e9ed584e59d02d761f9228e3792b6b9c69f8cb85c0ac2a4645056c6782727e43f29ca1234d817481d3f18da515f00189c5d62e9f4bf6bb21e3b3072bd228677b98e079f4da1a0b1b4c58b503d44c7003daa79bc0b62baeee46a4f2dca35eeee024932c67201973f152c06efd820ecc1ea445d6d3937a1afd80a6b7cb3a442cbccf194fcc80d1dfd1c7011977be55c655d50f9cca9d21d1dd1edf503c262596b4b7ed1f559c1f7dfb562cbcb84a537ed1c726c38afe0d61aed1fa5f99d94b3525dac6185dbf7961b611f8bd8127bf39b4114148df2c707a8785dd02ddf19c3ede80a5e3e14bf9be2fd87d5247366b402f6ce046422859cb38d4f960f6af7b721650482d55bdc31e0c7fac4cf78f1dc0131449faeb0ae55d028709ffc52cfb33234633a708c6b7ff349f27ec3a1b8e95629cca382334b2fe3f4183be8591aebf62d34cdf6670d4e63aeccf1f55ccfc0f3515f5b43481e9ca70261b17e031997750e7aaa24253486995c9924757941d6f2e0784c9b31e9ecf888ca55adf6d8bdc3aed73f4b11607eb5b9df337f60e8dfd9548dc62e1ec6721e3536596209730f425a9e71723c4333019a60cd57149081a414802c1b3a1365d6df7f3854665cee6d8735279a94ce3dbe018abe032f55c7e37f97f3beccd6a3cc29670949a935df142f0ecd975440b0941c80914c4a3a678fb0b05aa854c0e165ea7128fb1d69cfe1261145fdc70144704c5d32262bc560dfeb987d4b62b8b2a55aaf40f1d6c08dce73f8123ede033ba5607952807a8ee9f745d41dca5f1ec9f6dc0d694d8659a0b0fc0f570a83c8b1d50732ea3a49efa164189dd18365adf116904aa019e17c1410d89d5adcdc67096dbee26bebbe9246298dcdba9fdf6dd876f569e72ccf385adf981edd174179e307f84cf918e1a9c4def1b765e8ac0d430d29e59e28dcfa6fde319f24c5cfc3be382b01965b43c48817406502b0bc1a64deb7da28a171f5c8e3f0e474c189a810c73fcc25232787277279b915f7fce0c6e17c9b6ef097749a47a92fd7ec2c919b0318c95437a652860a1a3bb49d462a6a3346478d77a059113febfa543c682ffbdb561103b0692ed041a3bcf4f0628587681200cd782420e4d0c4bbb39d5e1e061776eab258a86505cc467998eb3bbc596e0abe4dc4f4047a7396a6cdc81bcb7f222c007f0517408c3803d73e491eb89b21ef094cdc15487a822d14fff55c80b888f91da6118c134de61103bbfb21125ac1e5abd60b755e1821e993e0635b550db635714b09e90a6e306d563b8c1bf95a209c9540d0179f5acddb23a3f5053c395886542fbd4f1626eb165bc9389ac170047280769def91ebbe195210cfaac58912e0c68ffa60dca3b0abd743bde8fcb8179751ad3bdf69362a8d54620154587ce8c7381bc3d4cc1f1eee85fd12a3a541b5a83f6347052c91176c940f02b4bd7b4a4d89e098d94db5d9bfc26bf770928ca1320bf7e620c0dd15c9802f422949fb97835f7e82dc4784e6b655bb75b8f3e0e16759f3928c8db857448e8a6e2f4ceff3452ba3b13027c97f8aebb589c3392909e5f6104473d461524b865e34bc7bc0982718604523e58d3732a8e641e9e9575a54074ffc7649517a23dd0de199e6f472c3980f5a973fb1cb42544ee230aa093e9f52f75947204126e2b574607ddaab011651b14987baa055255a46e72cd36e9eed8f945569f77a51e2584223d290f26b40bab3617c025c603db7974aae03ac42c5786b21cf91c7fadd7c4905e83b464f70a24f2fbbadd5707f0bed5cc62d3c5e11f42f08bc10c9c7f2444154ed01def15f0e930b3a6acda0a1b3526d0a217cd9b058a2d4540e9c40137332f5386032340f198c318105a0ae40376c25749a8b5e015813cfc3b9ebeef0dd0b5a9f08451f7f74ed6b6565fb4876524d9230ba9d4494a2fcd030b39f5438ee1f8e13220ad17dc661ba382ee1ede2718a843757fe4411742e102e85a9195fd9a468c972485f488e5fafc02c807f01865ed6630392eba2d4cfa36fc34b724519c186a2a55f0528436e6fe43c3ffd28043a55c64b0ee5488c464330222913309c9a7d87c2dbe867927f99ae4465b11e496e9961fbeb87967806a4f770a734ecf51537f0cb9cc9819d4400f745b0654a2960506928623a33be25bca88d3a2ea38641847ccb3cdd36f3aa2101a65928bd4045afa582a2381428412fe9fb57218454f5abf68e4ea0e3baf132660028822d0a9758f7ae21262ffc129fd75e26af25d245c623807c44143af9b67fd6322fe250b6cfdcf9c0ce632264cc6cc24f37d9bf60b91da2ba52cf3ddea61a3fbfb2c9466c47054dde6efb2a42e2b09887a8f35e1e1c1285569f4a81384977588d438c62375dc1a60d3cc586040846b3a720b4f8d4b1111d4fc4aafd82cbf7741d69606d5f8c4988e88e0f5bd491dab0fb4ae0fbff8458a664c4c0a36d9dab8dc6a2fac3d4b903cffbc8689eb7c2efaa114bf89c99b0f24616a65e485f469e6689ac7f2207426cf1e0780a7abef161cf25d331db6eddcdf72ac427e871adb5407e3e4c3beeb95e04bc7cd99c5b05bad460b26d47f940b12e03bf5e6873c7f166e5fa9b7a41e886ed7361c30e4f27adea3b74581726530596ae454f22be4d55b244f2195e094b497a7194e997c05f9387bd2bebcdb296b3eab33feea7ceece8f3f53dfd98e93f4f41b20cb8c4889ae3c0511437b1f2b84f48232f7ee1adbf4023d413be81e65cc2c4c03df54fa38bd671fd2eb7dcf1a3ba2d8b8f66d285a94e0e48f546c8c0ab611b1676446e585190b5c648367fed04ec99f00d42bcd72a58c76b10c006391426e82239064a4ca7aea52b48c18e720a72fc20f6ffd50277c0bbd6337a211d3784536ecd637e25d6000a3f53fb78efa8f0d1cb5b916115c11b01749772ab55457c6724248bdd54145cc69486aca5ab49e028a7cb0b0a2ff80dd4b8b5c293bfc041b39c47d5b14697f377dc4c55f744d57d933a5fcee5318c1d08fe49597f10518e2350cd1ee0b96837a71df499200612ae6ebcb905a5d9e5f7042cc7e09e3e8cc3a2685f5ebe5dfb9667ba5c9c4a36295d60c59b95e41e6a5770b607a888eeee42b8f596310fa430878673d7e068c229a4dc4351881e4a022e32c5719c92771d303b625da6882cd098e59d3a31340a6ade31dc17995ae2885c0090ceeac9cf9f8560ac2ec51b877fe181bce3c064948e39ec72e72d07749c226bd4678f52268375657617a952822fcce02dc22e88d850baa8e1474ecebb737e8256dea336014448a004a63ff49ebc47ef97d454767a9da93cf24be08a36d2ff96649eaf8453e6274a27defec43b65530f5ef5609fdcf9ecfd34719cd7e0059421a9258dcfa8d9d097c3fb265d07e57fc5c0eeccd3ca8018cfff7681f21bbe8e889741ede68ddcac17e81c5a6d7f651b0520827a358227b38f1e4c4a1fc8a8d19463387e3e9f16c88ab1a742a6511162d248736271eaaae6011e0129bde102fdb2dbc9a21ea16552f59d2e8539c3ab8da2c01fe0bf3e23ce1a3c7512070848b403d8038f6533603e2709a257ef572c6ff8077491c51de100c3ff001e8b27c5f77d6a0d17e2de8603c440791bf8022a5701a29428eb04019e9cd9a3adc4abac70c9f31e335b66ec21790a5e9f0aea20e1ee22f7d000c974cee5b0593eee0ecbc334220383ba13b5f042657d77004af80a7ff2bab914a35fa78175dbc3c13d68c545530b68cd5c3a858c829f0f4301d6f11d1ebbb5eb094570c225e0e4039349048eacf84d8df1ed02a8d17a7d64056210742596b211e820c0e824297def890a4fb6c352ed20f5dfaf71d8552fd7a2108f1766c5c78af7cf95ed649329e48f8f0a706aa60a12c5f854222bfd888f20b544fff8fce33912dc49800a79e83f570b665c41f128ea45aee5dddba44b796a2bfb3bd10d7570884ef664f8490283fa3479f624a20d64b993319c8c3bff3858c9229bc249a043b53f91718626a01450b54609209df96f89a5528442c9dc3f80fd1641eb3eca2d8551845cc9be8377512350acd5aaa0aadce4d835edc66db1351a6bcd01eec8cb3870011cadf2dceecd20fc1295349fe31432f3242b2ec9f9c72c66a01ddb04a89c52b6d188953efd2aa7d12ddaa41832915575e3d01fe14745bce19d121b581c4ad6343626c2ad809257d91b6bd5ee7b223820805ccc73fce2ea2ab6232251a7a95a0c03a5329510a0553ce39374060bdc34508ee228fb2bf091a8722bb2b2901d284e790e76006309acc8ba819e616c8ab9011791e8f2c5478679c72572cb0bfe6c20b15b259be2ca3ee03f3e39f5aceb3a6c76402b9842e64a7a0102f32b33ec11c4fa05cc2281ab2f783850e5df5938ca6a999a161cb18d9171755119d74a9a2582f7eab8f1c6b1f8bc3aee28ed20f0d1fabd34c9ee43e1841904a2aed634e4e36a8c09d8e03bcb2f11edec209902bc08687a071184c4c4a27fccb9289c8dcfd2c44a48dcc66b681aa2a6e2b1d75efc69dcdf45f63de22a2ae924617effc46ca99116e50deea99228f4974ad9d083e6c8b596674871a8490c83827709a328365eac05f72f22f334d729d0276ef5c5c503103159c0534ae1250b18189e487ced7576eeccee288566944ab6672d9fb4f21e2453f66b20645be95cffa969582a0d7d371861a85e408ecab699166f042c217aa7e28d50a9be4f5238808d0cf0eb2e8da70e2877b16e8d874b824624c9868b118b65b78152342a4926189a0dea7eae2de5c3535f1168c7843340928a27ccc5c9633cbf2aac3710a64532d30e1597a80655f237e3986ad42b54777deaf36bed3600a74317a96c6bd1bf60d29a3739c16fe9bbe862f138cd7c9b974bfc644ecf8a13334859fd6ed2c4ce9aae566f58b22b120c707ab5bbd93cb244ff862499dcbf5292538b0fdad2ae4f631400c76306c921e37cefeb40e5b8272eaec81a891f602afe0e239dd9931b0cceaf953f1e5adc02e415fd032aa61b7a6e62053eca787252f687bdc037d355fe54c3128bee1e28841eb9f131feb7a81a4206e72bf6784dbfe2e0743600b46ccfe7983bdc74cfd333f248bebfa60b9993f1788668cc70611c24b3cb7070fae6d76c586d04ba1e7fe6373bf5764c2ec333a0cfa47ba6a86f67d416a398ef2652c36d68808a1cd1ce0c5c629ef0961cc648ffad25c8f543396b937540405f421068dfc1d2062c321dda83fabedd5fe58bd94ab1dbb3a9c627f274a387150f04914cfd638a045d9cb756391660562499f49b3c56cdee3901e60964cc5db58fc9511fc7195692b9420e9f4e68bb62747fcc968efa9c3789dcbb4b3d06f9491ba1798c71f0e2f1b4668e8206ea42f05b28513b5f16c3339920befb37d2ec4faaa6c5272aeaf181088f4efa9d745111577c86414cd060b174ab9bb04dc28a4cc896eb2e919a8d252680a1e4dc51ee280d13fe6e31fa0b43d5c3b79301d40ec30d538018ca62f0094d632cb6478c3a67c8075df7d5dca6b52162f9ddf2dca1d0b429050834556be5c304c7b6dd19b8dd2301e921c4f709de708b133ae6311d6c848c305b01661b6ec64736d8d7a28e12e6ef75079daafde75e94f322d9a08e23f92bf3757b82bc25381e5a73dd8e805dc0c62784ad043214f137b3127aaa8ed0da37d2f1756a06e04398ce118439719dabdbc807b50d040553111a756244f76102429cb00c8a560a330507d3b8247ef84518d29bb3cd492e7cd0ba57ae7ecd1109a31e3b81b970fd0e13c4ba780923773e8781e749aa8d19c4093274a2e148cf665603c92fd96de1dc5cbbe59c3b421d33bfef85a72c48eb186e95ecdba961178f6f979e7b000da77cf6900ddeaab15116085aad0597c013669c4b9bc17454d060fe4ce15e6cbdecf98173fccc49c6b37f92a59714a40aa26931d1d4873737dc5d523071ab37a0bad7424a95b7ceda390b3b33ceb25efcd3df15b6273d686d824a4a718ed997174332be8a7cdd0db2eb5dad58fdbdc90b6d23b4265f924c7204cf744cb631ae6e0bba0f4e9699ea3393a2d6f1da4d5021b1e4680d5e1c21c8c22ab3f95f9f57f31e690e43d2ae6010c673afb0cbefa161664a8a0a5bb8261d5567fec2f4d6a6f20c5969363a60c5d7eb7079e96f77847c24811e9068ed103577736305e537d3ed7a6d060794e755ee7b3f2cf601aa773e8d5c006e09c362313406e24295cd4392823bbf7e6718d98427c5573870d331215d9feb9efb27f37a135dc58e6ec75f6244b54750495f40c713438aa34a867d2be561844a5d8374a42f147a303fe58dbc5d6f9f899b1b901d42797722b8ebe591c2867d9b9c50d9e4625f81e675af07d0cf2374b3caa43370815b388cd137a60ae9b488bdf00a71ce64a147464ed3fbc1b3918b02e314bec0fd3809877d614e348a823dfc3a7270b713ace770effe5d0c5446a0f0ae6a46e79f30e135d4502172373e7144bc1d2997fe83d073e4b077904fbf37e647f4e09af2dd977dce16efaf7003e5f7756c8bfe3ec729171036367e0cf3b56c06bb7cc872008e0fbb0642011ae358b34c8b751c1b57369529c301c80f37669a97c9f7a77a4172f9a938bc6e715eab1f5b5a92ab1876cc5cee8813eee42339e10bd9bfbe5609ef26b9470fffbec19ac675f5498b74a1fed0c14cd703a227d8016f17acb21d0c4ea69be3fb5b349b84e81d8719e9c7ca1c30152f43f574d816478116af709738050e38bd9ad26a4248a06af46e6928adc9746eb4f598240aedc660fbc3d525261faefd652053538c4dad71da0456c09c4909b55e51fc07ee7efa474fd5d2a826f963d7cdd2ad2fa0a34d57e73984d7da559340291df4337eb6d3ec826d76cf3d5bc7c7a47127aef9bf530966fa74e2b5457bf66a502a1896023bfdf5be1e4cc8b4f5805382a718cdb908196f32944cf24643c6227e1d2124a5fdd8c691862ab08beeaa52b46307da373c8bc24985ab5bbb974d461563514805d515887908e541f2143e2fdc94d02a68726406817d0026b0e983c1af597df66e3b37a1398bff6d5d44ae6fca2a70dffaae815331705d6c06024bfca25eed9133fb32309a668accb84725307ac40160ecfde10231c8ea0f0a9eda93e15c92fd33f6ca95f60975b2504c5860da20aad45b19f164b2e7ac8c3d787ae6bb2560c5f75276d410228996f420cb39f231686fa519e483e8357022de6a8f37202a5dbd26366b41708bf1a24de94efd247ab4a9216ea585f75b2ddeb61a4d1879be38396797e4c8cef95b58f697643ef1074b6188db6846a92da2d171bc1024b767238a4e50da9c745987df300d4e7c19a172cb9723375dd125c2188c94320dfd4061147071d3b924f86c75b53c4f7c47d8496abe4b860af2c51583984d6618556a2a6a64b668cedf6780a88538a584b8bcaedde1f778f1a92d2c5eb24887461675171d5da74f31edc4cf16c538b037b083738f534b63b3ccf74b86e7e948f4777f3d21db306643c216acb3a08a33d685e46f513653df2e2124920e25165860b648c6c16d737b63fe64ba871dc10a00f6ffe12b5cef5f94a80f537496d57a762281b83b6f249f2ca673d89f6ce5a39c5178187445ce9c0f0b62e0f8d7b9d3350c168728702d6a72e8355702001d61c2b8592b0142fd01f784b28ab9ef4762102fc3a001e2e5b450e79cb94331a751dd9b5ea60dad6271c56f3345c496c00183e4c8184538cd95a3bfa1695aea2ba26a2740297a0e9e77d3266434e2a3fefc58be66fca864e5da55c11e7c8adb5d3c024a8b65739012d27afabf6af93de67b3c4038ce05163b250f5925d06913018799f84835bec2e198226c6ab25e212e81e4ec913e8a637c5c4ea38d3b63f91cb5c177c8f361a71301aedd43da95b8970e182636bc174901b5a350c3548b2be6720ba210cd4e785b5f12f86fa566ba5cdb748232007e8d9ceaa82e7a48e94743335a5bf5b232a1d1f7ab30bca52df1027367bdd4576f44165fbe7ca0743f9d8f22e8b12d099a644effeb43735820ffbdc43358da5cd0c0801daef90b57c949ad8625314c0e58839412c9e6b8c3ea7340b3a7565626ac29ce6cbb98c5387af00ba06bd6134da0ac0f987010d5fb74665b12bd3105e6ae5712c4513f3d52dfbe90e55e8f99ad32f571bf5da764b8ac51fe8f7f53b87d7510fd274548f41fcce8d2231f69373d4cbfd8f5e56666917be747bcfdf7436187c36492b568587b39d0883151fa8da99e8a6928ec853f2370cd73115a46af3bbaf8db735e924ee86cbe1b43634796334433bab217dbe68820058ad7eee55bab89db7efa7e805bad15b2db8f5b3c597e561cfe3157e66cd8be8c661fbbb474b4ec3755d904b1aa660b3f70c9654b0520c544a5fe59178976b55e70a8c44b72aed4db00f9b1d45ad92cd65200429b76279488bb229e70283358b77d7678a1f2a383f7b16fd6038820e6d34ce42c33304dcabe18971b0f258f58fa80a6540f1158b0d674133718696db8904fde1335a8da460f8e4a6c2c95b388a620309dfc185d0b5d8e21c17de7d1478b66a3f19057d530f14e483ded5d72c1409c4ec6466469aa80535152e023fd69009dde0d066a2609a196bbdb62046ec6e296a11ad50f66f05bfda86e050e7a2f354411c6b13ef99d94cef5e88708af79086e23f4d996f1641a6fa1704024783ec48e04be610cc6a93bcec25d3d64663b36d6673398660f5954163f542e59a2fef341d399a9e677d8b0dcfe03ee99745b60b0180e95fd3e326ba3a8a4a43b52647d11c40e6fb2deee73f72dee9c4e448fadda059215fcfe0da53b46dcf6ac5f494a298eae3316d0daf397f9408ac4594c3e7e1d3415980fceb804faa531d5d8a360e1cf3e1520794b025774db99cd6ddc0f957947e1ee93bb2103106ad35508652a3a83933a0676e93ed8bdb2949e922a4039167ec0f9650d77e266ca0b3b587e8f19fedd8db5698185e7b20c1124dd3974f56e1a6ba45285bd8069cbf5c439789e5b598fcbee4a6ab0f5b090221ee4a975ec9c1622e99eeadffa100844cae5ec2c04584e60d0011c6fb544b6fe8706f9d390ed6a6acd75c47d84521d56a157c5642c4b2de1fbd29a68a0373e17b3d397d181c20c29b72aed4d5fdde81488fdb9d24e0d3eb17a826659d8e21d70c7d058a748b753a54dfe26dee73326186db915ca5cefa7649e8fbec84f0781aa76329725bce151a96456fbd2b47b8384b23398bf7fa09f9aca8f7cf7066b7c4f4f6c0dcc3be203c8d9c8c59a202d2b48bfce898218138881ad341435940587d3383be3799e78a4feb121f9456fa96b338ec8ae2a6606b54a3599a91120c2b82c9f72da9d7b3948e9914366d3553bd73084580f1d171532950cf1c429708a6d5e5c5588f256d048d7c584d91391d67d3a834da773df4ff13795bfd1977607ae2556933e34b023c535b19b4961258f761b139a53d0f99be136ae454014d4fff5743b1a49cc2186a1af0939fe984d3b3673d67f3e73c2742fb3f2ce526a795a3fc2bd8eeb79f7da4c1ce552e5eee809927624a57e3ff88ee07c55bdf0988993fa80556f0d733b7281a0077d108bd84be4702cf803cdfa07169e72ab28e360e9aab00fdeace55e4d3b0c3a6ae680d00fc738fb4181df82823a0150cf61e2f1a82848c9356fa5822ee8e466aa3f572b66764f0aa2ffa472329dad41f2db1111fe34fce5da6b80d9393db1987b667f9c8504323a68ab538c66d1103eed6adb7fd32eeda4c4bfa0b568255fe95f4314dd2ef9d5811ed25b07b5637f25ad757569e330ea1b05c15d8a49bae2992be2c8ed3a97146c97763b450fb7463e446dfb7370a77fc3f5257ad037033aaac691cbf6dc565ec4f1103209b4ae152d2b8344d856f97e1433dfe3b97a26efa6ac70ad7ae7a33e8c2bf4dfef9239a0561b8af14548c84e9a2dc71d9d74924567a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
