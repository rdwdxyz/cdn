<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d63e8acf94e8b92daed572115f2accf53181b6e8a350aa850cc0b2900a95de626dfdc5616837cf90a940eff36c615be934f2dc131f50cada8fcc99326ad4e4fff0b57d9343dbb10b31c79819324e27d1615b4f68412d1d7879620a20fca34f5a31a9aca2ef39abe6c1f4987b91f4548093b7b70fe8ca6c2167a00f4030079537aa3c95fe2f0438980ae1ee9b571031e57177f1e44172f7cd27c3848c3b95973f35bc2ac41fffbc8608014875b04bad0c6f2243041d2bb207af46a80fdfe87cf5792c406578ce1635ef6e0b11d75e43391ea3162cc6e38f08313a58d146c53ab6922ae3e78b283483f4e66df61fdcb7b6f5501814e8bea4f81dd659d44db4caac216ac2bdd1412aeaa7d83f01a0c0cba9d0ad19ee1336344606bedbc863230d5324d2eae3a7e4e2d208d34cdd79c0b99bc1504e69dff1b50b07d281a3b27964bbe0519e34544a8a466d8f128c65bf6fb5527386677422ccd60d99287920a85411a6550d834cbbca813ac72fd9452330c4ccaa4446ada3817ea06ad900f98dc2b3dc6e81a5a2bb0644ff2b6cd653155f46c2dea292792fe189e75c69ff4b936d47f27a7c50761539fb213729be0415a9e81bdd61b9bb68748a2a7e10cd73b760bc7b6c20990f89c4d66072bc76cd8bda03a063c5a3706680f2dbf008929284274f3459ad2a583dbb06380abdb3801de147e2788daa706fa476e77472b91d7633403b37fa9ddb6b58ca11cae1345616f134e848b086510818e0c14fcdc81d873b8cc079a7003a27eab6d567099be7ca2e8bcb06985da9f3160638c9f0528d46248a79f551fd3a64ce96358c6ffa6128c425587012a234dfb6b01a324ad29bf2795605911cde9dec9a6e408bd1539d55daa79bda6431543bc06ff82e38f7c04635401075c766f655f835cf50c4726881d43d644bf98f0aac6398af8a1823648591631353c0b3f512a6a08b1eccfbfecfbf1888735ea282b678da82fd9bdcf9339b9c5b0dfbb7101880bbc3d6d4dfb3c6305deed5a32e5e18d47d5bccfc2c6dd3f4fcd79c21fac0432c45a22f3d9b8e5223718755b1995c299b180fe699c0aabfe5bb1ac2d17a8713e09187bb7f1a59be6d992a1908812eafc215f51491bcc12982d0feb222c70641f7aeb8f54b2fc1eac345fa1f8cfcf7df0bcec89b6d41549c140a2513feac83d53f8848c7999458e1bdd8116fe00c6d5a26148de2e5f7fd726c8829a5d2720c560505bfffdd7cb8547f140809e23bde1c47fee10f2a84945901550283ae025b4b663fda755412cedd048c87403a4115cedbac628a34bf99dac6ac21674311c5bc6bdd1f86ee8dfd6cf5be24b07d4762eb113d18e7a37086f331ce765cc360c881548c791c9176c33f80a0ab145646a3151e915df6a4c1560f9c634703d67792f26af94fbb071a88e3bf4f3e99195ee38c8f9fd79429d5e84624f69b45d11cbbbc52f95f7d7903f03524f6a4969078f12f02723d07a1210f8a019b3a971153807356d7fca9b4156d720f18033c9a6be1924a22bcea087d3ec97b287c00a674d51bfa9831f935aa08d5683cbfbc670b086eb14d6ae0f9789d0d12ed14b6fb7cf32c47c0440df958250719fd17169d1db6c3a29972e88d53c296bc4e3da7379991ce10f4d67a5aab655e386341d9c3427a69e5cfb9c594f49d31f7361e05ec3ea2dac8bcd607e75c4493d84c44271e53abbed659b0cc3a430811e64b54ce7c917db5d4ae640cab2993b240d5ca1499e1338dc0f0ea48922497ed4f3b3f6833751e09d198c272162553333867e0f134d75b3e945668672e39ce913f6a2b21a98c9f470a4e4f149159f57703f5de29a4d7e9360f1065c1af6dad36b544e3dcc5f9de983d8e3a76b468c9339217e0cfc261f182c9b9283e55d99d860ae7d445dbae3cbf7675cabc5402d492d9809df9a63808c80219a64bb6650df5cc29ca19fb31a0ace04bb8035b04ae05288db13755fd611c0876c20249be87c9e0ba8092c2509cb9e70e52106dfbe859fcea93cc19088813f5e87d59b0e8153b8b5c0edaef100e28f845186c9c6d17aa972ecbb4ce2502cd6e9f59b0b95cbc69809419dab67c9996ab1128c2dc03249a2545e0a0bba3a9f696d551da90ea4f02f6b99b1efc5451f8bf57696ad13a3514e8df40178daa067d78c582472c3f79da5dac22572e2802f4aa8d7a934ac8cf9f07450a274a31b4b68587091a790c589f697fa7b1645eec343026a277925cace78b59570428e3da55d7b3e5b74321eff071d16d1cc5fb72d9e797ea749682510951d2fe693b9d06568718306e51a89c1b9bb58773f4a4e004bae359b983198bb7cee082bf150b67bf783ba8be49aa330cfbe544db6de80425462ce4265748fbe29fd3961dbe31fd381adb9788a819b4ed4f4573f8ce029f3364e6d232404adefbf480f3c14794c2c72e9b981e4c80ab7792607967862517f460054755bd00b4bfb8d930332931b9f5cad5fb518bb10991edbf4c50ad5f90191f31ea813fe35b2424d78685072fb28a28a4b6721e935c3579c476d09e49de2930a86f29553ee813983347ab132d61cf5a860cdaea872770bea41df894311843c7b02352070770c8fc295a603e64728ffb3944667b66fb845a064e8904e920b63b2c97f34c98f75bd9ff3c4138c5a8f869aec435711ddda5c017f83a7e72b3d667e78b234c74966e703db43c4d010ccb6cfe6307a5130eaa8a80cb3b32ee785b8d51b9f55721189ccb713195b626a5931de8442a339f818593cb914a9377028b25b76073a2ee242ffed754d066e37fc56d9b9dd5ee87e4de68ec35a811694865ae15e96b06e70338992e1b2da95e6b03e012ab3e3e927db94f9cb6ac65e261a431c0c8a52dec0826c243a24eaef0126f01507b28c33b0707d2dc1151865347455a8c3324036a6a8d6320c6d498942fd424749f1c9cb3833f69c224f26e9138c94f3a912627478c7d0c105892f68897b34b84c5d8721e8fea560a9214a146264d1c731c68de70bc2759861a05cb94bc09b919424cea6617e40d37b39193b3bddd9fd52ac8e53a3b1a7a8cc486056a567784c97f206e4d42d2b58f907aab3fdd1e6ae84f7c6f89d7895c17b99512be25cc4b93868c54bc4cc9e95d0e8beee7eebf4de32d27b7eeac75c1df1a2aa064063f7010c83d1a179d2ac24a59d4ebf1638b680218f68e9a730b0c74d1c0d9bef67db7491d07e6813f0bee2e5c9c65d22fbd84f709258e8cd362849d6b50b736e1470e615ccbbbd5bc776f251750712afce558aeef0923f07ece909f5979359b973217b8a7a379ea29218b08086d5484a0e0136c98e365a6bf156c9b75fdffd1ff50a5c2e3c79854bc26941dbae7cd9c400b22b25990a496d8f44b736c14c524080cbde7490dbd2ef84b39e6da22ad41452381c4418814ae47729b05cdc18bf3afabd5409bfcb76ac3dd0bfd60d183e7cb886d8394cd84d2817a4f17b3854174cd16a6419467260d994a2b4fc5a124890358e872d040f2b90c88991da7523bc7a243cd38211d5529c71d86f9e0505b571b3d1ff1a52265a2f28fa4e7736163a41be87b6f505e92d5d94162e039724f12436087467d0aed5df80663d367025682fa15d200b58fd595bda809247d6cee24b6c2c9d238ffeccec8ff486acc29276f8ecc8b814a2509aebff3be7f598ed94b94a12aab84664dd988b9ab7f68188be9157b5970bf6cf663a42e9a07fa2b812c402dd616572f06ff28e3b363216fdd8d5b4e9ed86a15375abebbc1f313cdbc8c138bdd06c41b3f649e8c745d7966cb8736ae27fe8605099c5421db6e35b5fdebb83624cc0876e313968a61d3fb3f23e8b9e62d8b58528ea961367c912eab4481980f8dfbd76f337ccf4f375de58b545647eb74d71f98f50e4e8fe63a829235c6fda177821d9efd1336c576d158888939c4805fb37e0d878dc9bcb3c7e7d7e7cc90d9a12cc83e8ae0c3c1a283c3b3d9b2d2914885e9bcaf7a353872081fe9c54fc22ed41d59d064b955faf2789ef14752efa3f5e3b59b7603ab4e8f6c6c26f711a92377fa45db6099456286faf3a45308eacc98ec3b6366c331efc574f0d3da2c1e51a0182e53612cd1858350bd7dfd82c98cdcd04a1052c051bc137ce4f28700e32b95d298e8aaa65ce6e864fb1fc5a0b6c0a953a114663fc066cb00a683b9a746896a24cbc086eaabe4daaa9cff34df8cd4c319dc830c5f6d69c4c4d0f1879d37a1c83856cd63162b1a17e6835accb9c5d362ed833ace2f4bbee7fd1ec8bedf6780d9b88ef78030573b2b7ff572376d33850e9dc3e2ff0ef4e29cc73fc513116bed967bc47e63f373e2dec215fd40dbf8691752bcd8443073ea5eed2a8db6b6e03c77b890c92519648804d17ef6c3259833a93b793ac8827b3e366cb624436f1c4a93cff5f6b70d7150628c4da08ae9721151cde670de337737d9e3d4b9c143cc62abd379ca459e5968285dff35354abdc4f31d0b6718cf4f877d5f0c26ffaabe6c554ab82f3199f97864216168b9478c64f4e7da5086ab6df56753f926285b5badeeb09429b04ce98530d03761ab5f8fc6fcf761549f033322a0d776cf71945a4e959e6a36fa6365edc9a134fb9a53a7c6abe705c630bb1351f5c1998c6729ca87234f85d756944e007d41a694ef9de993bb9604a0e6adb3a8f8ca2dedc4211528b21e1c7c995a0a563db2db13c0b79fe67758b0b9009c142988f8ebe9097c4e704216527855c8984a31e194ee8075b50eb1564befa4f6cdff9a7b78f2fa78a674335b7a6e397b66a071d2e31b07a6dc19c79c5091052fad7fa230737e2f426f8b2943661776f022f64b318c1f386ab8eedef45d7fd209454db7c13d55bbe798888c0432b27729f08d745158f544828f1d671b6c3b99a531023831d422d71da5b055f989cd328a9fb4f02d7344bb739c41e1a7d3a8747b8f14c6f32edcd84d624d70611435de02a281828d7c09ceb136925b7575afa40f596b14b7080f9d0436f9197eea86912e9a97698aa0b0dc722f7488af75930cec6e2a20df01f0100d0488a94d37e9821839399cb71b28acae1a13e9c4f4de887a2486085007860e3c814f33fea7c871a86f3f43d306d594092d079686824bcd9178ab6487d937dccecfa48652de6c0ed18084632cdcfe040b59b65f734b062eb1995d6754e18f31bef9df3bbf2355af24ff43b2854486cdee16804b351df8637087d83128610e82612d9d214fdf937eadb6acb03cb56b7d1e4686f463319d9b4b6a1148e4cd0f3c2a1c31db6fd273462fcf12fc2418e7522f2fcc67dea774f42eaf64d3bf66e9714fcfd3cf858aad0f50b78932958d1a336c8da50e38ef61bf3436532e1326ffc98d72b6d597d73c66d9d264dd633b518f7a22da149b5e68c10e528643e9faefe2c8641a978de7d323df9419c3787f024baaa84924400930a6c9f7ecb286f8642a006b8c084a3327e1c6d340c64a821483c8069a303fc9f89979d1210d0714e6045131bb018f9dcddba6e1a57d98b21a847b58961a5838d5bc87b8ce6d67b46ada085e3f7cfc2d3aa0d67a055377e70e290b809cfd6c508d655c149107367ef4fec74247f5fae1c145755f481b0234b020ae326837edd86f9a12b80ea518e345e7f16c3fedca2a21f7550111b535181d20514ff55e56149922c8a63e29d0d1af265b3f8e158a7015b76ce54e6c26038745335cdd1935e538c00bdc8d5d17c67521f1f72674a4401b87ba3165c7dc39d19151ec244f452620cf613115b7fceaf46314846dda609a1b31050bd80712549b2da50dfb1a0a241f9b2f73aeb0ec9eef2c78f38f93958de949cbe3045b74229d25b8fc390af24442f2c04ba28fd4336ccee1fe475139f87996689c964abc1ca285266c2f9daace863d78425a1cd6977cd6f7a3fea1fb86b7d9aebb2a090b7039cde73fb2bcf459582be4075467f447d5f1c7f897e4e05322f82e7a9205a17575170f0e7a014783f42a5f1db4db14bc82a9cc5eac6b3d751f0fcce3538b4328ca3d7ae917fe499cf9e16ab0a6c75cf9cfead3eff8730cfa4181024d85af30ef0a86292d18bbbfef3e7f7bb2224f872649803756800a0273d1d250ffa7327d30c36e6338485043c33ebd545f3dcc15dd1c5ae7e3267b318c70137d43a9b994abe51045c3966f4254ef55cc1150a535702cf4b710b187faf892731a4e135cf543d6fe2a365e262c5ad2f43b5e1d9897fcf7cc9c103ea549c3a88accb2bd72be0dab9e2018bee55427b1579a43ede3cdf71fcee3b920c65d9a5d95d2f2955046e9330ad4959c25395603f155e7c44a7fcd120d21e32b5bb426452f8602ba1da9afa2002a370d91a0e2b14514ece033eeb5ba371d25d5ca9caca88df47b1bcbdd2662f74b1a2c76fc3db72895e9927c2c42caf427aa7b0dbea7208b58ceb96fc362e2415f08e432d0b078db5d53fd334dfaa67bd1712621e63e9f661faae3e166ac4b0b00f64763b95cb909a8af2ced6759b20f1f55255812bb1ea2e33d826190078b85423f6612349224c8ffa3caf660eabf16c95853a9a996850b1dec046c41a4219053102ad66dbe980f1c0e6dd5a7f9f8773745b315d47fba4a45f3ab78de26f4101321ecb67366d1c8cdf234fe0d3cb69e6860d2d90715da973a2b7b209b56a48bb2d308f352bd4c6d874de16a976164eba713b588f97b705c46e2768126cd233f8be67e5c758ae5d005a062538e11d95778040bfee01a85d2f2bcf562356ec24bb17f518a30c948718aedd18235ad33b9bf53b6eb31314f29ac542d5d5dda1574cf5c1a32a66058b62ba751f36bca53d911543a2ff33054fec9b9a6ad2a7621dfd114942cabe42cb8eb5cc3af903f35f208c2f0fb398c4ccb694c2f909531e1d5bc492194dd8f2d9b725203d78d51b1a0ab34dbca0b5902b5050ab2ae23f7a2b89a90c3b35047ce2e5870fd5b0fca0727b707f29ca1157ff65a61ca8fa35328b331c22ef8533fe6d76a0bd47b979e9c81dee75f28bb36bac86abef1a46a88ab1f180588cc89e1c66bbc2a8728588c10bd387442be6f4ba2362db1d2691256d76e37f44fab3e85273c59ea0af29745ccf2f878055f09431c3b1f00e95867e630969684281ac593e6c3ca517eb3ea9531322bee69080cc94e0bf52fdd909150023ed4cc1a07bc2fc8a394ea6bf4b740696eb29496bb357c94b788fcb5161c43e554bc2cd398d9df810e51172a0a55b7f799434cfdaf530d36316731144eeeb6ed41475e32752c4c08b9dc49a18a055d285818f3984d8942a5126bbf6fa729e6b55db2336e5a35741144ee1fb4d65121c4b8a9f47f92aaabdf79dbf91ee9b701d9f54b7c93ba47b15b13c238c1b37b70e3db800c86c5c935efea17230416c786aa73e545d7f8ab1188c2ead2c28bb61d8fb28bae35806e22e75eabb162e3f34c65ec6bdf3b782db4ad288a8b3defd2ad907ddacff02c91134cd675da770eb0e0605302c5bde882c1a27f13a0c375fe9cbde6e6789fdd790e021421c9f0688647b4d5da1b8732f7bacc78fb1b9b244dc978dac569d4ee4f642608bcc36ffd08bd84d534516683a3d7940640906cde992750926aeab8ac1e2612772b293f2e8a363b09f7bb9c931f38e2459888fc3d42b7be1ed2ce6993be30ec7c1ffcb2045ff06fd0ec62e4a3cca442d7164448f968c893716bd7b9f22c3a22dfa007ffdaf7d44108a5dcc3cf7bb6358eeb2f5c3a219a4e2aea70f219d879ee8db46d37a19425cd14f99d2495d5dd7100779f8506469c2774222080a72fa7225f8300937468b63debaa9584ef68d65ed22bce9f80d22c77ad5be1ce081e3edcbbbb346ca625f0258e6864a384fc2ea43ec8ae927f09ae01e51ea5153fc21dcdb7d2b185d1bd20190fbcf52676d2c003a7045b2844ddada3052ee9be1f9c819d884b87ac60ccbe9e7f2ff7707a3ce02c8e8067ec0c98027c9f07141e8267baf2ff4c1a3fb578c6adb74829b3d5d2f7ebd2c4f8d9ba530e80853060421c5f05de76153a7df1c83233d4d62b8fb412ad3fe0c7e8001400529ba79347c23d0d6b01c21c666a7823c5041974701fe031a76cfe1b20350a0dafe926c41dd400f8ec73bec8485e634d322cdfbd777b68b9a551b4f9442cf2157a4462212da95247d71f95888c1d4524d903db3310f0b226533408783b722a455c7972d2ce427d7dbcc68bb5ee188332d618aa5458ec9c0a4fede115387540ddd12741988bf33fed8d935e6380f53b314c1b504d4ece6dc37730805d824208c79fca6834d3b456592777321f3f52af01f2eb4e29b34f3d10a1ae6558ba3405c4ceac756644dc61bbb966b6369bde0f16795974fea3c25edffb0b0d273e7f70d3506e5acc18e0f9d73edeb533ac46208403f361cd0faa3f9df0ea5295a1c7bc19335d60d007c4a7b147a44768c45e62424f5d48e3102586c99435b98627b70a7d51ae3e8e5be0dd8d126255dea85ee2eae8706203e02a1e0b331fdaa1634e8d3ab534d834863bd7a801aec75223b999d5796a464fffc5444d78d642f12828256c77605f26883a405368cae145d9c28f42bf9a98db8a532c76da0a26f555e645e79a9e28ae8287eed0e158bf2593b7bc9e02086921c15318e6bcf84fc4b2bae76a6d89b0446713b12245562bbd0cd481e9925b0a82c540e34a4c43520f7f91cff89d143c7d5fb616a51659b59a1c1380bc08320b02fd31016ccb3f5d648dda20cc2b1b45c5689cd6676bcc017815329ecfe96008b83c08528ecaf5d0fec73a44c38f443dacf720bda78915f63947a390465c9f01cff7de1050212807ebf527dc946edf6454084cc30289a5f71f21c2386b23c6947439d4e9f9f2654a2661d6700893b224456c243f391ae4b4dac87797ee9e465ef792362dd56c082f4c05ef11a21fd001a65dd5f64f477ff83416f38792c394607186a800b93f80f8a73313de260384e4d68a0e3e88230ea78229b598b596da403918eeb08b57a2e66b4fbb32a3301765e5f1ca261d5125b0aa7231b5a4f492d26c0fb6149a5d0965928b0c65c0406cee4f98e432673eec90d698b094787645e8fa29d7c1231fdf2b830d9273683f556eeaa5a8f94e3f71f22f2e7f179fd6073ba888cd40778e496a722e47b36d0d03d5f30552ae28c22ac8ecaae4c450699a663952ee33fcfeed98742185b214f48c1e5afdb0c41f6d17f2b67239866257d259fa58933398ada637fdc3c72cb36cd9d925f7caa38551df341b26b69d10396087f20d2b831082e0c02f72349d4b508761acdb9b937b84915810a68dccadcf2781ca43babd84c810c3b8dc4fac36e6feff0ea60a5759fb97cd2b7c425c6ef5d47ffafef7a6401cff431fe488955236b759baeabe1e08da3daa2f3e14a63a8ee944507ffbaa01b032a017fe299ec271c7101b94d5127cb522ff450f3b6785c0baba0c522049c62cd984fd9c3a85a2a000e3addac6c4ce63fe82f66da41858a7fcdfa147a5e3200c0a0ef26a864e0269e98cdaded7cba02c29998aded3db26b09e9ee44f07dd0af424b96b0f088be2292bb1fd5164e80ba34d8784459c543815ca20f20a4c9040ff30bb49200cfaeeb6a73479be96ead12fd311308aaa429013c4894b9f65fd50c63d6819054a07a6c6e2e9335be6f901b1c90c69163fce58ac69a827eaf6af6d5a1de9674fa20467f4b2a565ae09eda4ec34c9eaee221f166a6a8ca656393bbc5828ae78213086358955997163e9fe0d37a79592fe31a0a1d07a7bb2b986e551b10c88aa9b3f7fd6f8649c7c2d8f65c5f710d0482ddf2bc21aa8aff1176c9d31bc9e50cf7b401c7df75ab445605deeccf289c0f6c535316fdf87b32b84c39e6231609868b337012a8fa54e602f276312a713a6044283533bce7937f5e143384992d9b2b31f4eb622a154e050f2eda965f1bf891130cb3c03d648ee72c9fc09d8bc600e75257b40ddda5864293647be0f4a187b9830316e24a12c6c4c40321da3f44b16cfa37ed38f1a6a6410eb3cf1f0538dd2b9d009d705abbf8f6274215e89779e2f506a86df7a0b19d9917ccb28563116cceea8f0eb8aee8a9ae895635493e6b7d1ab670e2c31b17c6302ee3bfa6fa137e19e30784674e78a239123b696132d3f7477fe90fb56379563f1f2cb529df8333ae280e5dd994fd924cb2cc424ba47b2fa0bef6bfc2e57a9050cc0eaad09f06af1ccc5b66c4d4c0721112203071ef0c1005fc6f7e49c4b5c8f6dbc6e7352a13198789e52e5d0b925d859ee7cce4a48fb990154837bb83857a9fd6a8b097ee03842fc5a84e86ae0e779f896ae87384ee944a148ec04b552e3f7f80a5d137951e2add538c349f4fee97ec195aa555dc5727b2e8eb6543f9c4a81e1c07a9ed5c37c4c56807ef968fc57f2dcc58c8f02720c0a653f667af0230730b4d76c5b668ad5feb79e6f826046345806e21f33fbfb689014732cee5511fe6f89963c27af44115b6ff563eddbfb479bac8ab39f292999d4dd695feb38178aaa6363891d931bdf2e075265c7be4484655e6ebfc1c1d20e01537836343725010c56ec140af87ffae6a699b575b569a423297e815ea92690872776ae43340ff9204ebe70ef9f3e26dadd231a01ea5933d15897a51b3197c509db4be6b9ba65ce6ba4e208e1f42ea3b3d6912a53ece49340d828b2313737d93c867f716be948e20142086eeab340edb1fe210803272bc542b4fbc5882a582c59bece070a7e5a0218c239ec5455701f84049aaf68f10a9ef16a4b38b3edf97cad0f47f1ad19b5a771976092ce83b1719b047c79621c19b61bd7485b4c5b2440eed5b2fadfa87d65e221dfa2f129540073160bb2005fa4926d3233f3bf43879af02737c1777f1acc2b2ef04498de932ab56f9649381b55d87861eaf14937f2aef6f12b50e645b01443a8c25b667561c8d7ef511cde8a464257b1cf5951ce7f3ad674b729b091714be89f4f9d06664ac0a176403105bad014fed5eb5024d23edfad5f4b92ea368bbe11c225d435bb54ad3f05c54a5405104c9dc66703ee7d344370fc229bda73353ae8b2d26a9d1140e9a61a0bb977a6c23e0156964b104b8c5e73d03b2ddce23cfc47745be9b1c2971a2724e065d5441f947c841ebefe561ff151296cdd5e12b0b89c1d895099afdd685380e062f83318b45f623e87ff3d8695b5cda51b4d3bef2b391998c82f094ef5258aaa5c9264bfa522e9565a4504ff579c9c12d181345503af0c9e92a9921f9b37d9c875ff78fd59da9de04f75780b1d51d5fb5bd8b25a9e280f98a35a34e6f35c964c08b5c72c9085f49da01a8f41b2e90c3bfdff181d69def3ea33a662c2ce3ef192e1d66e05b7f6381c96951394ea5dcd4fe58252c1d045a95105d3d143327947564e39f219315c221b7503e2e21302108835bc6f627f0ea41639e75021719cd976f7f5a01b34d2dc3ab52b5856908fbcd7fb61a0eea08bd6808ea604f163b054a179f448bb938bcfd799f389a611767f9f23a120068e8e80679754e2cdbc39b73b5a9ba01f910b605d412ccd7b38eefc861ec36eb879b1533e9b16dea206194ba57c62f9da6db601836bad6db28e95e8a65b04d3a453c27a44eabcb6abf4779d050fa6eebf188350dd8386d063d2dca4416da9a044ee01eb8402ba4be3b67fc37e1da6ea99cfb75005ad7df1fcd5ed9b1bb43a14b27707542a189913cbea116d0f4c0d81ee8dde77fc632f5a5a4ee1fe10be9d78f7d7f74d04739c2869d46e5b0e4034ada32874bc29b05a36d97e391c9c5615a75439816f33b806722c81e0ac5bd2ffce9a233baf02a7717234ed10ea477904931255b2ac2c0f7a513b8d8d5c9c949d1413281049e21c6b156a2e8d082817df798a13a3329a174ba5ab52904dca513852db027167c143f24ed60dae1a1ef300009134193555ea072ffa0d09472aa537f12063b0053b30c45b8cf779457479846303cd4faa9b53749eaa121a21a368a963fe7a2fa88cba5b981be08d437df750865f3eb129fce7763a07bfb8572d256d4a36e26cb06878e6725e4ca58a5f4b7bd9ba56e146c863bc0876516d88cf6efc52f847de8df5fb5b83e30d55665714edaf6d977e0e441702254629b28dfff4ba8f92f0e6f01d658cb2e42637b0788607138c7b2511f9eca04dc2f35d3a1ee350c7928d41a5aebba4207470fead39f13792b166221998f66d475f023021aeeb44065c7608b9d63a7d570522b8c6dc28fda88d587c778ac7240fbc3bd7f651104149ff774c3c89971150d46b6cef13a830a0b63eaf26bdbd5027e21f5074bf7722d67a306d039039ca4c65006395df10be657ee30e34129dc5324214812984e15d62c380d635c28401d3ba45de521ddc6192849a8abfedd5d3fb6b8613773eb8bb956d8755d46bd3674155d54aa34c46ea7534bac41e0b2e89fdc2d04f36624e5249bba4e103446da2cb2b6930a0c4958fd4d61f08e32dfaec01fbe4aaeae52c7b9e6cc80719e94e7f520090f57fa778f1bd527eec2096e4fac59e02efc28e62757a597cab970f6cc3a48a46aece43bf9bb9ae0d6629a97b3604c7ce8e1b32b0015f47e5823b16596dc3e1a7d6e77d8233c341b890e0970e2eb6991ed6462c7a2b5bac9a1effeb56d55d04182184b6607765c057b24701ebc57bbc3619650301644b02e41b8ab973e4d433c254019f32b9a6c2a8b2bb8ce55eeee308606f99b918fa07e12c31417930f7db492bbc46c478f75c19dccbe1d979f0e2a7942e34fcdc67dc17072a8cfd7ba2f0c9a0be5d1ba6c40ddbbaa80837a470491940d0412e28bfe590aa21805e9f5d4e5de1319df694c050a34d5a250647e4262a456e4c0bb08c06ab7ac38bc9971abc4841d4c71ab6245171955d19f36c3d68b6f9102f6f86491b014cc71c296fc42f54d385c93c81893c1e4c93dc8e20c037f29748b1c51c0bc5ba4fb57aa190fc5543888311b6b1772a5f2d7c3f5922e1ba06534460942dee41a0460c2a9cfb850ea02187163df6b8a67d87f970b906a24ef9b5f9e2aeced6c694e09287ea9683138dbc50d3c2871ef06f7af8fd7c47190b5868e949b21a9391278e4f933fa993ffc73d40d7ee2f354f235e84e97f9084418cec07168a897f6bc5a5dc68b4201a5caad6413c672521d7d20654823c1368761a36d97e771f536ada49e64db1211c5dd926e5931254e511bc313ca7f97e6a6775c6ff293ea4a4fb0250646d90a127bdf92a9e9472126a086c881d85a176550ef496ef63a7466cc0c48a562570b2cda18a95dfaed9ad5d440dbf3eace1436e58e9dc454dfbb4796421d85a5bf2895de715badf3b653892ffb7cbd7b8d0dc82d3d585f80b4fd68dc0ac084161fab21478de02cc9137e93e0679f7081e5efee3d634a24d97bb64ca64e78148065e5c95feb91aa4e9085a170ade86d1ff9da9fc54597aba25b3f24ab86b38b42473b821c1d239190af36d99c474e6df303f3c335447db455a4f76ab370223b63c767f3e3fca1d6a45f309d7f01ed00078800db3c16545ae5f859c54457c9d90596933c4e4f7871e134fe232bf1364223dcb0563fe535e016833ff120f0e4f398880de22a0755a787cbcdba4fd17dbf84cf6a1ff95f9103ac5ea20b9cd5a4cc23f8ea8476842763133734ad4ec3652117821b9fe23a2f73f82919b61316abc8924aa7a8d9c035d855d61b2b0e491e11134a7831397e25f69c4d2e0c8efc950becf26707eb1f32a6fbcbc4d9751a6bb294e2de009b14e9f5942fc738b523ea6ff8fefb4902c2d2c6a03c9fdacfb110832ce7d978f47849b370d18a03331852c28f4ba538d68756c745365d07eee6b2f1e35317f9dbe7bf8f0e9c3f365bb6dc61c598e5149fe7edacedda92097d1005e3338e4f03cfebbc3158bab07fadc695338e5278ef85c15d341a718ce596e88fbb74b7ea664bd1e146952d7a404d6df9e18de9dcec083a4ee6581e520997eafb653f5e3d671c4ef7ae6034a823e6871281c706e867dc50391c54fa4e88f9fb9b0214490af62ce18e2f9c22e5cdfb9c6fb46c149a801415f40ca2e178fd542382b1dd520c19e6e0e2d760e7d89e399f445afdb3cd4e2e7a5d22aa759afff6c437999678a456570f4265a5b789800abe069bd66c3428cbe3f4c85a4a59644fe64335663fb6d735d6f334139a625d65527d1959ceb7849fc66ee1d29f1260dd39363cb65f99ea10fef66f40d2053ea5f857aa85601a26a93a4f2e87248237768e7a6ad18446103d3921074460866012a74d8534c64add38c9f3189afc01b160cecba889b458bc2aa16c680024b6d086bab402eecc2d1a8f7fde4489a11667db200c9e635384e6d14b0e80341f392594b4201bbb6b150da77407d4d8c2881e327f2c589db7fffc35d7478315521fc9fc1a3d0dde8ed5fa382b7c27cfab57c62a965653b15df278032862b8d25c3807e56f9804d57dde1d98847e40c0fcdaedfed68fd76399b092dba901c879bb43bc3e9c64d34805b1e6b2021715e8872abebb2878f37340fd3c94750514ed334369d6945524a248334f8fde3371ef5c2a298a5bb4d7a6ba7f8c6ba123fe3ad509c1fd977ffc2abc917d6f2de65e5811656c2e05639f83c4820c1e4ee27824609c3a30452d82513f8a8c4986ec8b660f128036ef29bb21c616e8aeb8a40619e5adcde73ab3aafa309e373074bea4bc096226bfb2954240d4ecacbd25c308ff0a356c24909f2c5c4b18bf2a9f9e5cd3d8d545ac6e67bda8175bf8a5e5c4295193eca5bbc69d7735745b44946b45086d948e76e1273a2ece6511bbf0e36adbf267f073496411fcdac43f4bad8161937b853331583ae6072f8c79393989ddc29e49660611983f5246cec3450a22fcfb442f74a226b6ec0af5788b604ad8c2d303f26f64dcb3f605535660508b76c4c625ad9943d977aa69dcf30479d783e55ed4ddd9d854c2a03d01b92a48aaa517821c5ed2b23d6366b1199c561d9ebddf4ea7322fedf60b9d6472c50769051f568046ce7a569f7926744774851aa3e70478f29d0333d6a9bf60768e1e28d836393fff35c9e53f585ff08dd68b84c3b20bf673ddc81f24b3703dee50a328f18b7dbc490c23bd02d06bf2a92c0e30d4f4cd9c91f440d9cf4079e174df1c1d51c22022cb88ae581fed6982cc3cad904564c1a70694859726d5fbae30878f949bea41cb685301f784a19490cdee1c192fafa3f5cee22b7a42eb4d934f12ae8aa5b3fc01131c5a115fa8f456c0a25f1424fee4fdf82a665701d3d281262e8184ca93c2c9d95888048435e7a077702c51e320f3c65007fe5a474e9547c487602fcf29542633054ea1c2a04df19938d92f6328418b3418cfe00b74e3c2c29bb6864ebe6d18c1cbb8acc350af6c2840fe2bdcc18b63dc12db7531523edb5ff8d5c39b17cd4168c4f0a4b14c865f4ff2e850169ca68f8d0418529009ad4fd101ab12db183c387ceb57e60d4dd8cfcda3c600765b0699a9859c3367842a26141cb520c8ad4369d98d2f265a51ae6d0b38281b7862b7bc77fe44e99148bc914a3e23352c4b8e16bfdda233a9605b45765d28df4fe6b12a27be0486863a31242ecc9c295a83f080c651c48068c510acb82a52cffdeae9d2d831f7229e848b428644a240ffbee00f32b45e5285c9df998fffbb74e222c20f9f9e5785998c0951488b5178f1c89f29ff879e1c3df63268b7f59effb17d1be8e883bb25acfcb2b0e290bc7836cdb612fc458d5a139ea77c7cb361f3a38685b6d796d134d679f4174adaeb876b831d23b4cda557e73b6ea8d60844f9b9d91f84de5c1dc0ca7c6942f0f07970457299e33628677e3faaf9576ec1643bf843fced85023ffda85599823513553f3019654966384a571106d2a3ebd22f9646f4568194031b56d3363f746830929222689ff64076edcc9f175875e58e8a088f76f0a9dad364539fd59ccb9c545dc17f8b892ee3de7f8e3dbde003c630abf929c74895a3982864528a9fefba94a9ba07a04b6eec6b2079e483430a71f94c63c4e6650b4a9b191d55c67462135ffef68207c5329be2812314d7b5c5c3224158e2e83c0834de52c3ebc4920df8acd9579d29356ed6e35906b1295eaf27ebe951a3515e28a557e70d7aff84e25bd105675da1f1d2313390b7cd17bf0274174196452c9ddc91ef198421132ba77472975da207377d9d00fcecb72cf047e90620637ba92141aabc62467aa797cb4334f91d5fe3b3763c8e528f3dac357e3c8b5ee8137389cb9ae9202aacb18c4fc0dc4d131ab4f1ff853c616f0ae00820db050bbf0f8b8114a83d4ddffe8ed23317a21d06ad19684293de38f4b428ffc9d6a75cfa249d3ecb898e966b356248ccd739884bbdc485326d8116443ba74a50240ef656e0f3128ea6472f6b52960ca92f231f421cb976a547fd9e3c22944c475ba384b2843c27e81c3e911f317b01ae441e0cbd172aeaa607bd9999bd0ae3406bf76ba005626daaeb86afbc0b8bee994fbba11dad0aabddff06076c821401582e31c5251cc1dfab1faf86148ba2f52752840c66a7819eaebe0c9c46583e4ded0e55c2d20cb2531a28fc24f8d5eb1886521a06b25c6b7263bd5d38728ced23aa5b040f16807fe83c87f433dbf6b3457dbc2c947202c32a74def9f2e27639606689e2688b3fdd0c1014362dd8ffcd7e14f5c5039a147e8766713ee422cbb6db39988f80655059b6c306ba4d898efeaf6cab11bc6a180aa3e3af99d0ab7142f7ed9f2b72def235ed3172867723e352602510aa0f742112ba906db7e590f98d6b850e76e065d3b6e1b97ad2cf41f42ecdecc8f11f38e01422df9b3ede698fbed68596d47a69c84ee6b9d2ab32e3321281fb8c3d8d8ec01e171a8a2627486cee62ff015dac28ee77ca96499c762cb6d4f1bf96ca8afa325fa816c528d331d3f4bd3337dcf49bf35b01939da4dd46674077e8013bf8ce9b6e261eb00b99e33aaea4cff5619c90ab9c9cb98f96d16588eb15556294be01adc57d3de9f67004c73e24d62bd7b3be522dd409da4fb5f7770f948794d94e02705d4143f70cd2c507547a375001a5aa864fa94615b19905f6aeebf87f6ff79760cd8b0432f153c81f32c4629ffe10732b3bfff17284a1493075a582221dd209dfe391c449676812373ad4eb87f04a953d456ce5e52ac4c00ea30fcd4fc2dafd00e59386ce7f0cf9dd30940b0023518539713dd7ec267011fa599154062b1628938ad556e5d8fb5fdc7b6297bc58b4a3a0a20b5c97ecdc35b65129c426fd46dbf7422985ed0429ebdd286c1b9854fed5f913da5e053c65662e8ac5c54a50f5cdd4e6184130b54c0da326ba84ba41edfd97460319d60dc86582dac5f08bb7a605595c6c9af0a7a74dfdad653475cb63bd5364682ba28f6a8b2be83bd54e92608408efb801326f36f483c6550978be1606e256fc61398e199e82105667302731d8dfb1140feccba110d2ca8311200565ebb122fcd1393bedc9dcb05eb34d11334e0bd47a117a976cd59163bf99ad1a04725121a3dddc4f5675b8c2a3e65efba23fa0d3314cfad21d7b4664d8cdf1e0f786f39307da36c2486b4bbd6ebddd0067ea24e03891088ea7f30ecfba13b4ba4fd34d26e22fcc278f2fa8b6d7cbb1d4b7bb682892cba04e3c94c141ec46827d3e8f9520ebb7ea282353146fa92bf0480d16b599a60d3d2ab65e0fc8084c2733537e112301ed5833d8933db0aeea0463fc851386a6618e3fff0b617a5f76571c750f03bde0b1a716aca898abb8b2282a28225515d2504fd9b3b97bf87f74e0f54570095fda5d3d3a15be87c3c28899fe4ca80fd6a8643d058ae30c4e5a4cbe505c10520d55b9d5e013ae80383cbbc5f1295d1d6b97fa1e9502fac780154e3145b15020ec7255c58a5edf8d114740f7bd71ae46d3fd4dc1cc169ef5b37c38da1222a77b378310d9e9848986902e45037d1ef268fd08c99af1ca245dd8d4d5448a33ed29aee2fed7808574d436b4624c1acb748c7524dddf1d8b3e55686a018305a71ae7237d3352bf7acc6e4b06aa12cc99bba93e8b82a3e6d8e1bba3611fc0ac0047ab74081493bc4d80d0ee4478999b5892a76d4a7db99d8a9ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
