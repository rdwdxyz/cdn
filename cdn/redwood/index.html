<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fc8acde975b746d347d78ba7dd1c7758e338f6d7f3a953212f814d17fed5868015ca9c83236e05dbd7c07a6e2dc0408838fefdbd2698c84c72af8c06d3a4a0b025da2f0003821416873f3f57bd79110a90b6ba45acb9be25b6580cbed392b39c0c215d4a5f621c83b8dcf8d30a799069afc0da9a47e5de969986b365ec3a886382a320e675746e3b0361ef286f1b745943dd0b3a07bb7d8233c2ff89ca6eb2d2e3d5fd4c08275e84f428eb7ab02a0be3655af311337adb630929ceeeaf5eab74dbee367237d3e2b698fd6bea136e99235c247ca216d2bb19a77a0f7961d47ec5f513118dd3f6f9e4a43b864bde1f186da3e40aeca848e4328011b2c9474c2dd3a583846cd3961a933970e8eedd07f55e1ec6bccd64a87a7934443126aeed10ea801537ee3c41cfa9f435dc3f840045aacf536bc8e790165fc027cc0314c3d7429849565f81a4a59ce4b1210d75ebad11f952bac6bc99c49ff36bb8199d5d0fd156477a86273e49fa83f49ebf5d9cc95e399ad972f8af197b7ffae08a9098568393076f266ddbadcff579f71044f91899365550365909b52c4ee0223f337582944814431e2d53eb245ab3ee8bd8a1c99412396711355615976c84ea4f5f280515ef6591dfed04b6c240f6ec7b1b8f6880a2e8734de1c7f7e1c71753b67a9825374561c7ea5daec16377e6d4d6977411b8e11b1625cf30e88df6802031bbbf7b2f6bbfc577b46caee2bd979b3edede1d1197e0201864fb54df4bb35dcd9d2725943feb5d85814c141d3b2a426abe5d92c7637566b65f788f9905a9c4d3cc51ef0d3ebf913d6a8cade871030cf9f732f038cc79b38dc62d440a5acfab570eaefa665b22f119d3ec9521f514ca41750e4299fdaf0b1186f07af9361d75d81e44afd29b004ac587483eeac4d2f0d013a3f9941d0b9d4b809fff5069b3ca94bd01cb0aae80969b0abe2917384be8590eaa49f4429e0ff51bbccc309ea939f4c303f6be95daf7b227b1b6581b52848684c9b992dac3b77dff1b35f00df30d3738e43bd81dadd0b6e747a5e5f902c6c2e91c908c171fb309296f9ff90502d00874c5ccb8e1e2e6bcd6b84241d1c44357828ad6a79126b0183c7ea89097bcc6d321189068f3e2a1bcea9049bff06d676b937a1aa3e0c69d7ec70bea7ce8c88feff9a2e89bca4ce485e2f2e4b3ab6e82e833685d30d11c5c508efef2fe378bfd8d3a770bb525f19f4fc0d0a8c2c7cbdc49d3ec8c6f49ca9ebd1df57e295a26a14c22bc5fff8551003c00a5361a9b4b9c016659210ab86734a6bb4c2f085b36095836b57cae4f40112b595fedeb44421a2050953c427dd38c64847717b49ab896ccb4799083641e21d276823253b98cfed37b352b8c4d9b3cd25f879318a18b21c7bdd2a0aade9592dd2b62dc7127ebb773807ea94f2844884dd6b23a6f1ee7ef66f669db3e5c29e9ef4e3a14ed21face39667f31ed2ae12b8f8207478c9b71e7690d59d062205fc553ee55932f30332237993bf10ec01d5c4197713c956d5bcbd06e7c1dcefcd51cedf5d5755769b4cdb9f0ebbe9a9a2afb90ea73f6d227b232537fb4d0bb0f401c86f3af537c0b903e48312bb3b1fc8f70eb2cf73bd19138db00a2b8b77c3c5e72f45e396a40ce4c436a3a4730a198a10cd9833cfb22b520a6a30cbe0560298592a7b3d977ea8504786f1d70dd7074f2511d49c1fd3eea56fd82dbccbd00deb7b31c7c4bf32701b3fe239a10f7609d5486edecd4b740cb679bbdc08866ab11fbc0a08c21faf76c29f6ce72ca2b391a144df38b6ba008cfe75c956499ef885951cb581fa3096db24811b63aabe396d884d32a88652525412201d73134dc09e2566f7ac3bfd9b2e87fc628ac50f6cc06657d368159fc9289a8db2832532716929b56fe15f43431fdef58740bc0ac6e28987fbc124692b41cf23ef682de4f2a12ed02716a259fbf81cf3b96bcceed1f1553049dde6d882ff85d14c1d583f3ff5c62014800f9bf4ef7b07ec59c0fb00be36f386068570b4ceef740712f05726f5125adeb2f810cddbd5bb2609937122733eb3d54613c537d8dcb0c203d60b347921b09c00ff16d5a4ed0f5fea56cb49af01a963a18b76a3267c1fb0e1f896fb463be98854970d2216ce29273061255c1736b1ef6c81817d8502b89a7c3782a4ab0bec933c2d72619d0a435fec9d34421cb2a9782dcdbd02c84fcf79ea5150779d1dd2ed842b136b9c888652292076428728fc4ccbd8b1bc43160711d5bd1126f83318574a6e55c6bc48fed94227fb0c1d516a93cf83811d537447fa6227324318187626df415202a23659401462161e4847daaaf447e430f29997c424cc40b842fd018beb3871d0219861421136380a08a28d016c82a7e35ef3c69cb64a78b30c06072822c2b4e382a8f5c9166528a423515063667d20c2a9ad23d27891a72ad9e447bea225748bec48f7e4055dc7780281341f6d8abf90d1fc3e3451afce5d01eaae8dc8649c15c56dbda7be38ee784424e4f7ade7775dd45752896726e5619615efe22e9c2a95102c662efba3f25ed29ebc68429f7e444977a4fa77178db79a0c167d67efb3078ddafef5d89c1dfc25e4ed7926f457f7b27832b192c4d1c09fb7ca5fac37bdeb5dee6db3ce08a0f878409ca70c6fe9f64446f9ed34839d75b9fc8afe9123c7ee7643b03a7192ba98f5cb116eb4a6d8cc2f8400e500b523b2ae84c9154bfbe8a89fae44d3d9b4a22ef24b6b7a25a4200236393c654c9fc5b48b814e7de892f6e7e1f0f6e690492003ce93b5f15b57054ad3ae03cef5ca8f42856033e9ab42b6236c41b4093092aff6c63d3e45da610a8953e0749f2692e3e77bc9f600c125b2ea7ebdb88b54a2a9e6eea4f144927109d3e1d69a922abcfc7a923ebaa5d2aaf358dd26ce60edcaa06c5e42adc5d6c0347c3d7d70fe5eeb749899589311a67474fbb1917d19129ca39eaa9af5d97bde07749cdd2a196d3ebb9e8861678a10c583da074ca41f6943bb0fa446ac1ad4f575f7a70e7410f77b1957035e5ced6deb93a1b5f62a5ff47a6997aea5fcb76d4226315a0e1ffc182c6ab7eff942ddc15a0a39cdaacebcdcb97ab175bece242c2385257cab0202885de5e08c7d6fffa5640503e658058d25f760682f30a47306e1024affa0d8513fb9f67085a22b9114b8fcfe6fde310cf4e3e9dd2c48c06a078dd4c5c28445bb1aa0511db9a9f00859159ffc21e4ffaf6f4b0af480c36693039915dc7ef0dee936e6cab944064421439d789eb5f63b4d4d5d1e703b81512706fbe91b6a6f8e0aa4c3b842bddf5323b44ed689778d74cd6d959cead237d3ccf09eb4e0ae874a10f3e7d2f451916889dfc1297b954ebfdd7e4555c37edb8ab9a4526a3fb3d7259251829adc9cdb6442f0858c1d18f883ab774eaba5fd25ba231e0a1bbeeb531118de4c4854d2760b5a05c0495684a6ffb88edb985cb4919f5bf0b5fa05a909b649c45ca756f8882b498aee26af9f938c28d119f0a27d8aa72df14c53e7c256e82e6f30057de517145444da7926b9115d73b85ecf5388fbda3c9cdf81051890bfcb1c78b63f30edc76adc74c78ceb1d005a8f816bb498cce1a65d81c58e725347d83c2fc40d675b6db6c8f1cf85e75a9813a57ebb9dd656223af77770d0a70209161e921b050e4de9ef3273dfd541c60a6e9ab8cabd6dd2d8af44c42aa9e06e984697486feeadf494592cf55d68053d13c95b0b8a4a1b9c29fc0a6c5de1a689b57c66c3fedc120a0e021c1f3a58ae9a8c4f1806772f0db2c31370caa6a0a42dc0e0440b380e5886d31e6fa3e230632061a702a8f2531dfa2f093adfa6cc1a37d0ce709167adb2eda35a07b29bd64f866dfb9616924d9aeb9a2779c37e6ac608b8c8fa5bc54deef1f669de46e5eecf30c0e04c87d0be9a1705832b7b7e120b13e683460acbb540ea7bbe74d536128bef67cdd58b0e9d6e6836d1110f0dbe6ac0f14e250637620333615777da4c54cb412fb7ffdf425998c66184d2bb3e464c6c62c2f301792372191841232469506d50f083d2c00d2d015bd1facbc5b034c2d76401709ba35392478e9e699168aa26ece4251adecaca06a55a6509f1e41e1b08fa728593732b4aa74af36f4a93db9f3983b7c38cf16f0d8010696cd1bf49562f38266d5c38a97d7b877f7e718ed61ac50c7702b30a5b653c3976ac86fd2ee875e04837cbbf7c9f2e23d29603d4ce7417be1715ef821e3eda5ef3497458d03078a4e5523b955636f6c33846ac1e6a93457a680bc24fd9e30b5fc7707502109879bdd3c9ac7d284264340c61014594af7a91189c91054ca26825d272660474362c2b1b03a4c93dc9c7099e5ec5c62ce2f84f5983b2d856b94fcbd5fe89f775d94c473ebda60c3e20ba74bfbb6ba5fd524fcf0825b3c38c0734c42c0333d946cd3cbb217d2424d66a182afde03725988d2f52a51e1ade8706213260c849b01a793f8fbf8a88ee6c09c7ac717fb4f2255e2a7877188d2e31233310f747a903abeeaeba8dfb4ac82bf43685f2d201603afcce72117ba27e91153a821bdae251b3585d201d360d6f4e57c9ef170f5bac96bc18c8f4751419361fbb7a8256d5b975a398b6b3567077fb83e1254fb17dc3dfde1919da65eadb51979a678c583bf351e90ecd08168e8b386fd8db2efac88badcd5f0b3ef3cd540d06b13feb63cc54a62637c979a56f818e3a6995069ab9f2a865e4096cfb3019b5c4021c03fedbec45f9cb08843d005756ae60c91899432ab6affb2700a6076200662d70a734fd0438eb0adb2a62aea72f4230fc6c0bccccfec35f7fa0666d412c5b99a9a789b2a593751b47ba39a6ae6cfcf32c3bd8d542e07f28235d5e9ce334627c4a7646bf6b4fff8480ddfe039c660a5e20ce9e5b3b7afb0e34ca5314fbd43c0119c881b3277412ecbfae2fa57e77574abf4e666caf92a4426cec178bf19c3f1d0e719f7b608e12a67522c8b702237430d2e2ec15dcee610e0d9f34d7bc103ff4aeaec27669d606e3608297394c73c79b3e0446e8e1d3baf19aab45dc874b223b242c6750ab2e12577dbf71acd69aaf34e7047978ecaea831fdb66c44d50480e9e14f48abcf1322858dc2d15a3cdf32f6a3a8e807aed633efa6d6002647457e717f2f4dfc1c8c6d4e3c0e769af1c6283ff23f0e9f666dd23e662cdbc124d9dd52de1066278d13db56b76f6e39d6c871e6f3c1894ebaf8e4cd5b943fc2b97458d1f04db2f95b714667235aca1f1d481456f1dc154bc25c8112838a657cdb2a8151833ed6c92959aef6081762188e2a79ae03b85820690665d8ef025a870a3ad80f33d00c2ac7a7be40baf27a738f8c9f84e832f510392848acfadc8c415aef01da86c9ff6d5d8ae582fa6b70764b0fb0562e8843b4a29d281ce90019983410a67579410b9c5b6ec00a18c8fd760d992ba27c04f9f8999caaa789490f916e4b1101afafa02836464d78e63ad1ab3c060df4d6d8a84fb1a3c71b28cf735d4b47d239ba967b7e1461dc99f140b441c2f226dbb85688af33f47a35fc1bc957ec1f99b9602ad0c5029d6e07dda10a09013c83ce84bb61626861c042c9bfd679f93d68128f4177f0adc228fa434c582697aa1f938170bf6301b3f91697436112a85b7d4f671c57b921256839e1c5621a0be2e23ac9054cf4f2798f135bd0c54eb80517df835a9361abe92b2eb840f0a8d3e37db3eda5cfab44dd6c614552db4b197eb590111173d6fc03366cfea7966635f56ba7b8de188fed70744d22b03116a05d3b7da09f9a98b7c1b63bd7c8745c6001f21fb2889a404bb76c726b3b5848f168ce1f6d93b052b03c778389ba373131d72b1521b6304ce14df6978f2132bfc8bf9c5fdd8ccbf8cca3fd344df8750c0997cec30cd79d0d71bde1f08ae047be12ca29585335d624b8c25e3eee24e87a4692db7d0bc77dd9918bc0151945648d88fd918aa8f5461c168c970e61b8e562f44884cb230bcc8689ae677c9328f14803eca90059ba40cb45047ad73b68b256c35cfd7f3df0d1c64183780ecf44aff168dc753554a0ff5246bf9abfd6bb2c2d1a6265ac8f029a2467cadafd86350bd3dc8c587aefe605765be24f5a43447f06f1899c71ff57db861610137040d87d2f458d738f3da2d5fa55435885d2fa0c2bf1e61f2ce74f84d2d448e04f09a3232f94a67dea44b893c2fd1cffdee2330fbddda227ecec3f3d18481edc848c9d6291c57f57c1d425fc43f5945813b9c3762a08c133bad564ac50d17baf54d3a3cb8d60342a7585c9476cc80784cf23931a52080de111ad055308e1178d49b19c1636080310a59b54712fc004453a03a4a55a5e2bfedd2b6b5042b292155510c1714002b8d0e36265d9ec9886f552b095c2c855c0d57f129ad16ce254b364f1a17b7b1ef889481950eab1b5971b66202937454f577b67a922a6a6d055e8003e8af1b8521c3d3f09bd6427cc6f71fd70223bb549aee8513a71fa294b4aceabc70950ac526611acc591f26f091ff2fd6e1c1423eef64b2f937660bfd94b1091f663bd72cbd9320ad380b25ae4df1b67711fbd045c6d79b59a403b4e9419c5909719309d467e6c42be7f2025453cc6b9b3bdb4ba8657ba45b9ba11a1afee0100f18a71f24672a0e619703825339e777d93e2595475f5e94ebdbeb31487e3ed40ebea5b85a576fd639b1a13eacdf34c6831fe9a352ffe43a631c174481e9caed46d2a968df8a81f6c551362e050e66c3c4fd999a3e54e4e3b0cd2e97af89eeed2f500a250fe0cd754d1d1815d23e3c52b3ac16535095dfe7f853044fbb5283b48fc925e71924b50188f24374788d625ec34270719d5ba3b18616ed97c09553dd0a93bfaec2f3b528f54f56134d6ed1f3c0b9b90e993a19f8984b3c87ccb7a29bcd4d60a885e4e79874a3e79cd6081d38558fd0d47063762b6bde85a08511e5460259434cefbbcf0bde9219766a8774dc17142635c6e1d31aff7d4b29ba72cbf5eccbc47a5020d169c46c1932884d6d3bdac059a20978f69b62df02d29d0fdf48b34347405dbc60c5b81a46948366868c99405a57b00220add7c055c406d77c064f7906ca5b3092840b032065ba8817acf87798ca19b6d43416c4957056615ad3ec7e07eedbe3dfc949834658c25db9cc3f7a9d67e2b58f6ad29d120e995c12d4121452c905d8bcff0f0409a2cf6b945103b7102cb3ec9f10b495f7f94b0340c1206331d502c754cf1693348eede01377cdebdae51e0fca5b472b1de2bd62641e54da41cc6d9b44255ab7ea72e694c6777aeda2aa5c66a6cd2247fd6aae9c04317b473f0d358e345dad52d14ea75b7aa717bff24a8c032083c0b6cc47291628d25f9994961f4dffba581b641f9a36cecf07990cb3ab9dd3f14388ac97b668b9bed8d40aa81aa41cee5574f01c94f09f07d26dfef68d581c17e73e01775c6da18e26842307d9d45fb42f992fa016c27a5f1b833141ad385c5e04f8c6d79e1d1791d4a590b0a33d99f488d4b1266902ae0580c16d1233f081a15d78e07014323a3f566c3fc9ce038402455ed6d781dfed97a801e04dee199ddabca5351814e7bc567ef854e0b6448c005317eda536869537bf61d9af334758cc4990a2956810204be8c6aece7abc842994d50f914c6bda9a79021ef380746e494703ea135f875c6d856db42a895d889028ec32a4461d73221e807fcad62acd0df47bd725ffeec8eec98a4c52023cc7924bcddbee9053dd2b5f0713161ee77650d5948d78bba02c395c3e9e66fd6d95a61a8ffe85f27c26beaa77db904a48e4d5c5fad22635eb3dc60f9a99c6e87e83f42df6b224222868563458d35833b799cdeb5ec2f3eb448c083b3bac28340b7090fc282fea23d47ac40e5dfb110e89a14f350180adb627f58119d05abbb66ae8e6b7349202feefdf50538f415122ec2babee0c9e3a76a3db7df94da32f942fb9c160cfceec87fae4a80342a1982bb94053bba0baac6c97155d07fdee520f4013c8693c1b6c582bf451b3b2ab6dc29e21a54079c2efa7e89ef65894dd034e9cba041c278aabc00cef63d73443d910677e6d3d79c8c9d5a022158aad0fd98be66fedbd309e2e7bfec1a231ebf31823409c66384f0cd9a65a25231d2600d22448fab316cddca62c7324363c24120d9ad55a83631fbd92728d4f3cd7f44581d3f9a4cc6d4124cc2bd38738db37400c6f7019c4edbf2e0e8e9fb0bca95c282d66d5ec2fe9df4add6ee941d4a577c4b77eb38f74376398c9e1b5728f4cfb38d44286605a68739246d06ced09d12abdef22897d66922d48b42d814e72faf82ff945749f3195554f274db3545163697bf6ad4bf1346385024fc4997aefc7eac81f9610cd88d1719c2c5cf58092df2fbd31d05b2718c6eee54a7bf16651a2e1f0a8823b38aaba45f82d89b29cd0b3699a76448ebfefec50e1c29f967ee59bf75b238de6394f67f149a37e0e85a95bc27f5e533003e8e771c6dea919fe8d19289df86789000e3de19266cd53f6e0c34910f3b4da43c7b99496de2c44f6091a2add4982fa169c01c357ce9c38407b1f46210dc9d9e78ef604feee0ab8ee74dc789eb182795d76160fa9a1d2b9ac87dc498af99556f385417ea322eec8794b159185e366e3f86e15b1f802f273313d11847ed198aa639016e67235eb6b6cf9dcb60bcb9f3e5e86d49c571f29d84a5d5e9fc470fa6735e90b1e8dec131fe0ee62bf8438b5204dece4a1b4c452c2a8c95c479e6b8ebe578420c1dab3c6b36b2478dd53a447e6e202442c62e33865656f6c8d54888a590f4e437acfd52f8b2d96116efbf26f53634481ba03d0a30efbda1612a46373fd7ff3f86a29e8f6c5f4295a7b4f0d9e34fea902e851b19b2cbdc7e679be8194a06bca7bbf90c22936bf2f1ed6db35bfb7fe9587961e94c6d136990fdb27c7ec8d21f8c6f1c5b66e8ad8fb9764dd897ce56b248006f2699b6f31cbe12ef8ae2d964cf2b661cf695021307aa8c719238f99b43a336ed9c3627a2e058749f65365864b443a080e677d137b1140b5a880b6131f015a6fb0586af302b6a8f1ca7787b240dd785252a066242c7349134f028cbac631e92d7b84dad33230bea8e1eaad058786015184845f4aab635b6e95866626f40067ad5b1437692b2c186aa2392be84e904fb337792da25b37e3b314744453f4248017f32ef8602787556dd1953dd056a305800cf8944d7fa3150bccaba08a9717555811e74bbb86dfcab95e172bfff9d3dc84aaac4e36c9ea3e126a7a9bdffa15d10f47e34618063c36dcfe02d2946d1f042cb866cc6f04b6de535309eb3f7af884d67f2b753a2ab36321fe262d15df138b162f5e0e0dd206ba7c8c557977383998e3b33729028ef3d17199b07e3d88d9dc69ef3d8f18de3095c480602b6294e119a0ed8cf04f19a4f0841ebd61d301cdc374c35e40c4d92b9a6b953cda010e1dd61a16c8a31e30ccf777b7ccd75bcca947fc14ee6c2cfcbfc23266caba63882f0a110628a5c73fe48790d220fcdaedd5a6f3331773479a5d65b1fe888e1c907803b60bc2a4285658b5a92e42fde05c7beecb1de2f2f9661901eba602603718f2476615e41eb07477c71001871372d018b44227a9d78981ee0b3671a187a2a44afe860a507bf8aca2c9bcbc22ca811bedee033654f77d7a7e5718b79a062e094d723804af7101c9310689cc7e202c6b8baabb70dfd0e2adab9a513016a3b01a9c4bde42025bc6fad55a1595e05111b7b6958149129450bf3802a50ce024e8d68529722d3d54eef584857ab96714df8bc5bb02b35c94d42a2f4e932f78efa0e5b016f2972d8a8b8ef794a1d0d9d66e6f247f4496b2813cb50cfa7146ac1afb9cf1399c1bea00f5d11c3bf5de74d0baffa158fdb18c2c36f0d5bf591d12d48ae55e88678f27f21a4d0493224751679969a8cd50d98df5986f485c9223ae31b5a273a8c088dea3b0bdc150d509459c506c36b550eec061fa42442485d56da278298f6ef608361711a6ab4099a750f667cf6b838dad7456147d558f47474186da9b6b3929b13b9d95e5e9946b079e016bea5cc9eccd229c45a3f40afd4ebe6b840462f6e355e0087e9e9faaded15a834f018920d200737cb57d43dddc2a178161ed00ad88f43e26f0337509a87454b4a71e9be763cd654de5d08a46b526605f9787cba95f2964f03273fc222629bb3d0565e79272f2aa844096b27cde5a6218d686f9e8ded2b51af0c3f28dbacfa34dac67df9800b3c09373bac6958e1011ea6e65ecfbd3cdb9ba9b8f77dddce77125d112b9d1aad8302aeabaad618e52cc27211f75af6bb12c1d7a544dac631a9840191dd5137579331ac7fc68121a3e7ccbe9b7a3c779d665f65fa806398126061db333fa3fab9ef8838aeb13a407726a166649ed586524b76274a5704f4dc670a02938d0ba493d26ad7f6fd71e6ef6c87d69f8657ed53b7adca8ecb91f31f998f26ab49ab14a0c3c891c6affa30662eaec60af9024d8458c4aea6d421d1d4ca1fbe0949265132331630b9541a324d1d9c90fa1ef0a5bfca251d92b193c52f792487f628ee0997b65307f15e21f8b491934f9c41552005ba25ef06d0fd4ce61d96edbfc0d7a017332d45fce2623899cbce0ed1e925b2c74ef4f0dbf8c4c454e304be92d5cae26790ddb4450db3040477e4c01e40b184ab734b8d1844f19042568fd946e62fa36d6affdb1c672e7aa40ce44602a2c1503b6f19c856a006555c1272150bc2d9dcf30c25ca626847def120eb574d2de021ea8a363a9bd1237eba7d5d8d6c841795f23f4d5bab13d61beb98d0da1c7de610eccf66951a4e170bb514502e5de3eb19caa8fb7370b5c18952ed7590b9b40e6a6d2495c53458bd658437bbc28177eed822a095914b1a760db63da3027c26ceabfe4c16829d0a5353a31cb72e50820eccc4663be207dc503e2d3ce1bc809b4a098b920e3afef34ec8fa71145670f25dfd33c7e86a68f539e843ee64c2bae144f62cb9514fe3d77dd2d31ae84637ea2449c7396866da8bfcd11b4dc16b1aab3c1c8c57141418e5adc48ce303b28fe723c445605eed2cc3d7eb50c4a127787c74a574f1b029d07852ab12b6b7338eac9baf6b7f0e40b7c795229df5afdd42352d07de7cda99e44a7b6a4397e20ff69277613d4944bc83b88b3b412edb89d30e45cb614c20d507fd5e130af22dc0fcbf331d82984313025ae47e0f3ff7beb940f54fd62593b34c67d08f5bdac9e16e658694813ad0a87a5ed296a2e8aeb7b359f8f1180c562182628e7a6cb4006f478421f0a6dffee437fa8fdee9c3c273d1980d626870dc704c95d6da0204d50e712d566c21a887c3911662efb256888af6a9953d61816e2c51a61c5106477b52322cb6d9fdc12b418142234f2cc86b7594b9c25a66e2458ac1b34c678d357f7b4d004dbd283234e4d08d1bc08dd841d8309025815a873b609dee780481b858107474d0c0c75dbac86ee3cb63ce5d0374863d3d6ab3183d34ba10dc1527669b37a988f187b8dbb9074a8416e0aa7db4541f15903041863617c3b0c37cc2c69f55afc8d936f3cb6ad26b2c3420eda5d90ef942fb6aa1e86eaf43824d5120b8b3b396ccf54519b9e849e78f6d1083ff0edf16100550f37983c59d9f7b9d037eef77b3e88385d0962ee11460e3a421bc71d6a549b68401c03a629d2cdf05bfb2800bcf0af1dbcb7ad1483db7ca7dbd91ac44705bdb37f58657ecde9804a164688379e0aeeffccbc45e3b4d7bc93df3170ee4badd7dfda321966e5362889e55629fad7a476fdbc797f03e4cd4675ca3ba9b4b9084de5f3e3fe55ef0c79228df8f793f026e622570a9d7ab3d55b4c309b2539d90dcd35fedddab488da3517686b20c4304e83e683bd85eb7c58087687737952fad856cb1f1d9c89039ad904b6da53449643ace5ec79c63d016b2bdb014d6b7ceca7a728072c091547d0b00377d732c438d95039c4386e5808a9814624bd54441966bbcfbcf6870f8da4c30d0046c5980d59d263a1be1716d8ec4e293218b2ddcb24f2fa882d6c25f9bfe60b902176a461178da9efae635b6570504f0e4881af72eeff5ab331c4288994353b0d5f697a8faa17073b9a69f701b7876edce2d6b9bb280a377e97a01457253f7e595fbd8558da442b5db7c1bb8ca9e78f296e96e8c4562f56f2a18b03de5a48c23b92a3d70735f7dbfe30287f920d79756220cb48e64d66e73433b8a0ca2cf8ebdb968359f38f4d63538bf2010587766d20cf11f9f0f74688d8d3ff863fb267440fdcfc4932c5d94d7b1b27554ef4332d53f2366879fd694e12e310a6abfecb943e3af515f4a1a6562ce4654729e2f2c8609f301c0ecc49ad0acb4f56f3ac54f91e12fea88727e447dbc66e473af291c40489a469c95e8c51ff08b54e52d9e1cc405f91a4acd655312a89ba913114ecea163ef8c94f95478e31c90651961993cb85cb60e92e3612b44862e4d02011fac38b5c16d74c42725c78fe087211e091dd1642970f082629ec3bb14a561ae0e7104a7521e307d63b4970a5dbadda56f5590710c42af8d9b3dca95ff03ea001bcc21f0f7f3190b77273cd34228bfed9295578f28ebe5b9af21dad571b4ca58f4086a77c52a46f957a1dea833e8045d624a2149f6d596e131e790cb489fdb2a082ad315a6fc868169a4954def37d99eb9f21b2fbaf45a799042829931cc4dc2af5b817b5bda241c71c4dcae4ce2720932b3dd7cef96e85ba5296f3d84ed3f61b9a40d44a4e97f19cea841fcdec5401692668854689c55d7486a7b79153a13e984c991cf6d05b111286e5950bc63b2c1b28e5c043c7b9ec6d111428169f854709772467e9ab4f4a67750c7dc19d9fce98fd5799040904001600eff4add7d08c02d2bbb18c2951820599bd0acaf34c16f6f6fa9f31542bd104566514282f64dde54110ac73a3d87fbb107d62235aa3c1c441b92f5a9bb836549e72eacde239994c86e076684405fa2d1e062b0700d57ee89e84ab5d9e35a86f74aadd42222a583ed9b384a102317e72c7a3ad033b46c65aa49e7d6878f2a96979deaa47fd1559176e3e23fa51111ddfcfa8b74e43492eb0ffff38cc979c6469e28428d39bb98681633453464f134ed4bf08e180c5e6f84e32283346cce00f677fde7d1022b44fa605c94f95ca7341833779c03e8c7443e766dbb8419b4306c2cd5693ded08d47c3b77f455d1ca216cb3b7672c18e92b687b8af74cb02d1ca2ef11b72c215a55befe7fe8f379c4256f21113b5a9d944a22a4b181805be4097e18347061dc25a8d006a00101ece78954c90f4f419bc524455d8beef7753b59b6f36e356fc50d551c60dc5d1d4d98169559a35f5121aeedcb6b0aaddb612d8793715558704be4a2fbfd22e4dac7ad01391fcfbd38b50d3d288e47342c4691f50dbfd3391762f681b7651507403627f6a409a44a91f758da197143187e8595017efba9730df04c3723ab74ffbe941061077cc80764e878512ce323ce89aef4288d853eda23dd12c9bf08a09b07e95b0a6be824865fa05e7ab7d7567995fd0968ce5d8ff1a3b39c4595b047da9f6f1f4416954b30249382385e152a04721168da2153a2c3fd6d154eb7662fff034ec6b29f78c6da7ff19ca56947d7a73332535dc085d7ec45ba7db8b6bd09b3f7e76f0663af94d5d6649b22fda4aefc72e1a9288bbc53ed67f016fb991c9e3398ed1a8d4c347ef334f4a08130ec076f593a7bca629fe0fdc8dcb9446673af1c17bac8244ac29d74124738a26ffe9a338109e53811bcfa481691f1830cdff661e50118cbdfed119197f9d94b0d412b54bd4fc37e299af2da3dcffdad2ab3419e80b7e21ed5fb50c1ba4f983b628a23451d761f3c0094120c590661a88c93b2c22358c3dafc3ae6cb0872e2b051085eeff5362d9a4bcedaad34d05e786893698da7ea65f2cd0a41b8bd53eba472eeb29f478246e1b335bf040651e1d6b321fa64ac29032339d7c47962e91a496a644c513461adc2969a27bdd69968476bff6eaaab1cb40b697bec201f645112d97290b26d3a886c5891dec9a55dd753b00e1f63ddba285e76bd343a317a865ddf05630cfdb58800625d08a01bef1deee51a7d219b4f206ca20cf2ed989f8c7eaf507b309630fd88ff0d9cb473148b7dc67dc58341e3ce4ea987ddbc1a32dbfcf3c8fbf98f662cfe723faaa5a9d19124d1e805eaa40e70f97011975334387ce2308ac687d7ce72be2282eb6aa28f251856202b9a49aa0620c716db82a2c7d1ede93d61bef6f73497c389a87f84ec5b73facda7b997f640c5ea4c53b163ee1690bf5a32a9ae6ae39e3b6cd836e116db22b38fe4ae3d9a750a52b10f79c17194f2548386d1672b008103ba4b18b63c89dd27fa1ef75e82ef67a1cadd703447b7bd2f99d4ad3d67a1092937ec97cc55a4f4ac9fe42ac31902951204da99737f19484efd5fc0506585d4f1970b4dff2f768c4596f07eb643ea9f43a9aa7709682878b10e340e72235507dfebe34a06d3428277569fbc8ce38de8b6244081917a2f1214477e44a16af03641f2a3458f7f5c0c77659f6b2c95c2452e38ef31e3a7beaf806442da40460b93a54a2ca73222dd93c2339febfa89c19d582000df9b4215b5c9e3a7cf377a4989deac937b09a05eba319ec44d118b64caba2c514ad8cab6c42b36a87e73214b45f0f9d741e7b3642aad2b820d59963221f0312a20dcc214cc9e7e55826fc7b072076aaad109a171c5cf68e2f09a48f517180a6368cbf125c839e22b6ddcf1a77c5266c92a8348b69887206be552148ac71d9c54d5657525c7b5cde48c49eac366d024ebe108743740c575b0094dd549ca72696bca1abd37a2324c6e0ce60614f0dbab7f3d8323098cfc9faa231fa329229f04a5b8a14dc2418a1a1fa8a9d0e6e5632ea3da1770b166b9836b923a9ae2e1267c452a0b3803907a17aa4595e67fe58d3fc87be1b0aab17af188ba14884bfcf6858fa407e89ed0f617ec29beaf951047f7851d5f0df7b7f7436d3c87433be4955b3ddbcb65dc29696a29b1ee65fdbabe335296392716e2527ad1093e386acc1e75962ee5c04d39fd3843b446d2832951dcd74ea1b56e8526061137e3ace4219a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
