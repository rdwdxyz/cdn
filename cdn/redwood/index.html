<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ea0899919e9277aaba50fcc2b7ce0780f8fe490f1d5ed5c76c68a81e2778c3cddec8bc727ae989643dadfb4a452f736b8c64aec88787c1251771b3dc6adbad4b3c16355cddb673d3f0df96ed4dfc6737ea821625656885263516c485709fc2160243e6b728565d1d6240a9748cda5cbd852b6353edc89dac1b328b180e6cc87b2dce25821d9ec31be49f3f834ba3b607550aefbbed39d1e82b98e0f8a1f575d78f0d2b47a1921c08aebcf06ad9aa10a43cf7f110fba00875e07355e45dc4f8d50d8e9ce32bdc4ea16e3e2065c5dd91ecdfb86a054faac0268ad61c9079a4129b907ddb610938dcdd8ec9cbb0e05debfc8284629de6eefba24a145bc7e6a8bc0476ff4e944a921171b469c8548d02e10bd25ad95b2604c7af2768854c407891f6499a96ba2deb83805f64da73580bd592655d0a26be95a43bbb4072b44df20278a7a3cf959e485d07ef81774dd30bd05302a278a56eebd59971ed7518cad28aa356b681adaa505796a575b85a900e50ecc2da3c924b45b13995deb08ddd7df34050722fca7e85346823500aa09d87b956d8df47b1d2897625472a612c4b85d6cae56c9a205f33dc4e54ffa9baf5e819a2e004431473fd863a29759fb2a08e75718115b1b287487da466444950f565a6e0537a01da3db081b1e1bf71c8d91201b90d2fc57d4e454e02ee8145a39dcf3e1b911d7e4dda8d1a859a85c5f36968d7965d24631fda08f00a75e8ed0ec68d1e1a648caddf9267ef2354a895896f265a776cabade081d0ce47ba595a9fe00015c1ff47dd24c6d37b3773d0d79de1a57f9f5eb9db4a58d2b9b6fc67bac198deda8a4755927bae0a3e6bddfbc3cb72b84fcca72646d673e88c6470a7d11043e086904021ef7fd7b2fe4496d3561ecb83d18bc44f3f5073caac88ba559fa4c46ae125e3f916fe395f8a691bc353df0b0bcaa5926d3d0b26489b6925cd06c191cf64dcaa39ba075ef5457121561228aa457a044391d010a1d94f1602c4346fcc84b41060b3755393ea9c525c93fcb5ab25a9e0a79b509ab730d24ed8ef1c5d4f8171d34d17565a2571932bcd4dd2e0197b9875d1cb42e37036257be2a85ad5947ade50d1995d7722432fd6a22649072e26a0ff762acbc80c59c8544b7d866b71b147fea1f9f1107a8feb9b92e85a7d72c88c7959e43851a326e579c55855c8172815e6b10ae6299d9f863ebeb5d57ba1ea54ce3452372934a56e167a6be3bdd757c0b68c3af43a640e857562884d59d378ca02be1f00cde5bd512542ede21e24254a86c30bc914de40d994ee8262e2e9dfd521482565de0b2621eb2572b283db61c9afe633e34826e0d4a9463303e2fa671e0c202f4c04f414a097d4e2d44c8dd3959a9e063ddc4c8da09a9311f6f1e3c6047f7207ccf8db14234c7e0594866ab062bd03e5abdddb449926c575bdd266fbde48ac5701b57c992e6497c4a8fdc90e4d10e90c565dfa9d65a3413de9b754d321593ed0814620fb939a35e4ede6930541a03bb42565c537fe14f2dad7afe9ba0b02a917e79f4e27fa48c55984659051f5275075bb163de00e48dbce93cf33bbc8ff3b0a5c03d341c2b4d35d04a214cb796576aadb9ab3593a7d5689f873fc66726ee08de9a0601e13beffd682b667267277dc509edfff88612e3a58e82deacf0d5e249c98798e7e71e610c940c327f7870b8b2ec7922f111ff90d5836988db0cb4895855ee32bd61449c9df73fd700751c890bbff32a3ffb8145efdd6819416a6e72be7b5bcf844cc2c61ddeffab198f8c3e651320f9cd2818643be676062570e2f371a731f9fbd7ca3aae31a8f5b6881bed5e6ce421a5e96dd07bfa2d9b61aaea31eef2a00b9c3361ff7916c3a7c21a90c80d35f953924da8362d914047adf62b93b64780c72e2b5b0bc33e99e44e0d594a908aa874ced2adc49e8695a2e383477fe7cb1a8d866299e1209651edabe93a19eed2edb445e7f1575f4b746b24aa4030750674794088652726bf82c9902f211a8985a7db630252f27263a68865ac6400fc73a47663227813b2c4d5f7fb5696122561b29a3b8ab2f75d4a1826d320664142b7bbe84a1478f3a575aa0d4b70bbec72c7351e787eebcfbc8c84d185e956356236b00e7c66fd7bb69d18545722dec6afa15712f324ba0a65084409ff33c5ec7dc4c0634f30909376b952ef264bba2083deca733181ca6b38be95f3665fd0fdf27d55d463a22accd0690679e872a52c2f5c1499c29a0dc6eb3a27c94eb9fb3ed0557758d37d2060129273698cc99f4b43dbbb021673fce2642bdb65a96e65a9f2a533b8b9fcc8cbd4382d638d964462656715a564a9ab4bbeee89fca0fc6f3c6533e525529f878649bdcc055a5a512e21437cfdcc02417ef125c3b6133e096af19bd9c1f252ca2182e2e9873b15a2678a63698d1aba55cc54f8fc2c20416f7b3fd8a4a441c1a7dd35be10ef94da5c76d8d4ee833abb15bd0d8d89aa0faa2dfc2f49fcfcd65b4d47c296842e792f9f1362484a2c08bd08eb547af1e4961c40a6b0fdfe0ed92e5b4d2094fab471b9a4f81a83000818546d3130722629b90d52d95838402b3a019dea949d7dd1a33bcbd9a6aceae9fb6d1c7c5fad0de132dd20032589d0714200375477ae2a681e75f5581bd5ab3256f282a1c15fbbc8b6cfb460da0fc1393388bafc6e83792a899b9762cf2577268aa53aef67824a13ee66b952c1302e65f21624e8b1aa38426a2dd1b6f853f730bc954c206342d8a8232c3b3ba9894b13133fe33e118b4a76a84da36c916435c56652561ed91e2dd7161d0c0e082c4ed4ebe8300b3a99821d08b247f028e41587fc677a8ac6fd416515f833929bc4a119af7a0d97702ac5b8c889ded841087386e1c3253d36700081c74c03b9573438d800bc4844b5f06bb79d44cab46ebf944778220f88d321e65490239a8d1b2dedbaf26a014144f3044a665dc974c45e8888040a727daee38c087ebde69bf92eae5cf4cb2c8dbf90940527e2a72c354886fed03fb7440092ca947e59430a1a201f7048f7ee347daf2aa4fa9186c7d59cda18d36dd3db7df31243b076a53de8e7951392fdd54e55463b3c271bac8e1e33c422b38655832be8f8038c83069a3a22ecb7d2ead6debf9bd5dc7e156e1a47e6e94dd8882b13c35aa2c3e6734cb7396668ebfbc57a1605fb957583eacb86f80259e36cbaf2829b3869789d8454aa17a679af1402b3500c218c2734a480a63e61af8e155c22a7066c2c12046311e6175f7b89c2c9a947a6ec66f0af0fe3b3921c60d85c7451df69012a04e1a993a5456392eaee054651eaeef15a6b6521e2e4f9f8a26c4d6144d53d9f1f482fe99b9e9ddb1e26da454916fc9697195b3f50e34944d474a03ca2276c2ab665777fee3cb91c503715ba2b3ffdc100aa4307c2514337c6df3e289ea6953a3218495182142836a6d8a603dcd374a1cf8e5d23cb8eab221e0574bcde1591f4e212d3650a73e0ae7cb6ba99987b3c48057111aebfaed3fbe902427d1101712fbad16031e3fc8d4ab406381d5ca65349f1a56b4f2b75d5ae95b75d2d92b524ba7d6c65f8bd833615ee56d8314ea2b4165187a22200c3a46a45a15c28fe1670ae78b1e09356f575fda21ff647c3acb9615c8558f5f6033e297532a74448a58c683b37db297d8ab985c0c8b4006017dbfcf10ac0cb24d6fd872a27869fb91c4f0fd87735589006c90acd4c7a7a508f7421bbe9ea4f3ed964610fba2621a53b1064701f69073bda2223f86804589e531e286674d5aa75bc12b6921494f6d316069eecb724d4c9ca43ccce44d9341c3560dc7f94579cc6e5c740684858a85ebc16ee4acca1424a5849b07d5c2a9046574bf57f954156c44a33b179ddaafc52aaab39a6538c6cbff57f44b2b61e5402958bf1de92f52d989f6f622973a18601f867fda195af8686ae32f64da68db84be67633336e06428dbe2fe7abf1984313ebfdd054007d058a4004f0514fc265fdd7b7c7b5970e2c8cc1cdd713eb18f13351c9e8fbd812598c94e1cca64a5dbc6cb741aa20ce88ce912b07d72e82b315e6ff26a0d57f8a670a509884d64a76cab3f1c37666b0100b00a1f57030d626e60a0da3bcce19b4fc2d35dabeb3125a309b1c7c03c38ee83739eef63965b1f3e3ea559bd2b89df08e09b58feeee6e7f2fe802639039976560c5d5d9ddbe022dac97614d9ea7fb42e5a25adcb9d14dc70b1d008e87d6b4c6b33bab3eb566c718338d720030e9237bf88fd46bbc1eb9e11442355d836f2b3b2f4afcfc5734fd50eb7e6fc06155ef976007eda9bf2b2eee8f4d30029c07571ce606309a35960b8a8d4ffbbed1608a20d86fec8601e3004269b91e1547c9b8f06e412e492458b667b46f3b75dec32c8f76d99039c9d49b0f52279e587fb822bf657733c9545fa0ce0b8c9aaf452250002215a802f7a74c6042640401c483ad903d78ba536bdd36886e2eb8d400ae5c0a97518c881a680a1c4f902ad754880980da63d75012d50e079e035041f3f7ca11cf72aa7701de26c93b13b0e424478ec99d4000df82022e53a618b6ed328354738c061931df75d90b7b72522d687eb9a504e857ba84b3519cef58507a947c934f7ca852b44bee3288e8b9b135efd6b99bc6f9b2874300157643e20dd7e18f6e7ab54235a100567ccc16abe982fb1692009a081e5e0292f9a8737abc91de383981bc9fc3b3273c04e905cf210937f6e0ad044519677ac4545ad0b2187c3c45678c0202f0f1982f9fa0b425bb7ec36912c82aaba878bfcddee2ebc2424816ea2e24bf72813d60a7cb3a96656aaac6a3314341a016bf7572cbfde717b7143177e3c72904eb0b28b6a7d22b415cd4c62de2e34a57bb4aa48fe69dec96ecb281b88df16a6662ad88a7590a52605b5a55f0d3dca2705ace3be546b752becd4e45c41a4e0e7c87e94c09222d1f1e8efb34dcac13e9aa09b1cfab51c3307fec44821b281aafbb49d076ff81d3dcbd9f46ef8e88e0b3397b1c43e32b0ba44b6571f441f5f1967ce463dc37eb3d3dd8b762f31f3f0bd149a1170ba85afccf89471fbc9f14b0514e5580c3e1193e1289319acf51917b79465e0b17ee0f7496a199fbe64d6b5ebb1cd742a4631dfb90bac0c04c3a2ffeacd7886cbb7e1574c8fb674563d5641f10fa606da3c24eb4ec85e23d628ff45383815f137ae132c3d18c7d61c19d42fd954829f3ef6339d8929c8d432955fd1d5974bdb431acee1b131292b41df8244a053d5055c74c07311ea9da049d9064526272027d844fdaf120f8064a881df00591abbff23fa72b501a8a06bc8f78960eadcbfbf8535be85d3f55b21babadbf857b0f8bc8cdf4580ccb7e8ba17b0e54ab503d142c41d68f6cba6a502e79a62cee33c427d3440304cd3fa48cd64f7e1f99fd34f03207046fe3341d9e82c7b756ec1afda3c42378c9ac54682ea6502f1b5f726154017d36c6b36d629eac83c071e8f82094ab72e04dc6947598a06f6fcce305334de8984844b5c6a19aae138d52c1b6781754994289ba7cff9ef65efb0231736b8a51844c7d43732efe849e2f2995dd60f43bf2d2674754083b9a2e3608c340ae800ca94046a39735a18ec50d5a5f909e6ffe371da9348c7953789c4514534f1be4a06f4dd7a754020f8422d3496daefbc1594be7044b60bd631592f8d08a506468b27b56c5a30c5fdfdcfd52bfb84de57a4dc5a78f4a091d3b00137fde07c7701391f66f897339f1d3dcd6f93dc721ee1a24a55fc45c37a2e2c5010ca0b9ea668acc4e92e0bcc6c639e662267c7f8bcba4d6b1adb0b629ade0d1ac86ff1bf58f5c0a41b5207683ec151802da390f10fc608e0c550acc00a6068cfd471eefa7f61cbac53e869fe4dff5db12c72d9bb9ec8bc381665cd77934497264fefdf9705b51cf278abb9514b1da593055d5ef3d62419f53142528a47905e57f44f6e318cc62eeb6b9b040b138b60263a8c978734bd45596504a103757c948502b47e73dee42bacaa601baada89ac86d6fd76279da87da76a739b44cf4ee8f13df12ce3e0dfe7c7b24ce546e33e62bb37c3edc7bc1897bd62e0789c07a4de9780383252b4ea90514a2cb74ef00a1bdbaea9ba1b28c9e137f847b76f00c7cfec25983a9a114ab4c93ab8b9f463fd995c7c4c6af1ecb4d8d42e9e2061e0effc7ab845c9be459df97d5bbfa58661c84e6b41241f26c725badc0047aac879be32056f345d174fed23b31c7872948bb07f04712b2604757daa101fb0710feeaeb9b1b86c18bc2d0bb566f7aca4304ec39de37b1a7b7f260b8ea862b0294fde6d7d526cabc96da9bcbda5ff091d6060d60479c381e7768d0e92a192b4c02b9645ad4e79b779eccf56230a7f7ada403a3eb5d53809568a6a63e2436f17151706e69a16f2c2799843f960ff52e78af68a6be369cf418cf6bba2c78f25de524b94ef67f274fcf3687270add910782290b0bfc26685a70f5c73793743dd319ea02f22d49b2de1b367a93a43c8b8ecf1ee4fc3ffe318d6481773fe420baeb0181c2564a251407b9c6646c2aedcdf7e87baf0442e9f23fb03e4569df1ac614aba554eeb084186a31a618433b06ad8b91705a7855fd4c2baf996bf45639ea380dbb901284638ead2f6d851846a07670c773531b6c0beeed03c68d06fd477312b33b84efb826d47023813e79ead8e7b3bf7347220ec1354ad738faa7c9a789c99f1a2e64f56ffa257a152e4f775a15c3a7a1e4c91244b2250ad9529c0403c0d6587c35d729a0301638fc0beff4f5806b9727c5054c6bc7e193e063e0ae8fc9ea445a66474ee504243477dc7b72704ff91f142fe80709a2a281698321b91f853841f6a50e2150b1f285ab31b5ded3ab00fe43adde2c2ef166b974ec19cad46a8922aaf804374ef28aca9a97f5666a4d60d4df339a554691344da8bb453d7bd91eafbb9a509dea836e6a0b1697c1c89d0fd95af00bd4877e2242feebf1e00b66a68292fb8be9240bf8b7201b88ece3326ecb81c90a71bee7174affce109fbb17ac948784cdb543f0d021c13ad95fcf20b9d76ebcccdfb993b049d10044300284ee48d91f57e248cef8f41097bf18ccbcb979af1aaa6a96d85699707dea852ba80f74bfa023fd33d142259dba7dd613db2494a4bbaaaf892deea730220a6710e97feac82af23e51353fbdd1b80feda309901404fd4a51fceba89bd7045a58444b977392abc684f91fad85d185368d5ca3d236d733e8255776de3245210b3f376bb76c1160263cc332e2128c346b7dc21b391921561d79cbe5db01eb6f8c91d1b6444417ae13c13dd64b2926ba923dd2cf4dcc92df36cb479e85421cd6b40f180e784cbacd4d90421b661571f243fec3cdf56350cebf98da0160abede6a3903413ffb704eed4c4522dc29610ec6573bb4bb6850607f81f693c28b031d2cb80e9214aeb11abd72510c089ab6e587c0c2f9c710d2baa15e92743eb63b6c77247fd172d46c2de44b1e719de95c32e3a8960bb8dd7b540fca7327bae87522d0bca5ee8006d2400b893f917cbd15ac0999b3ae00cab667c71d9620836df2c36fb9c1f0c91340f115d83858e2c1121f23e879d673379a98102fe9a6d7179a328c04f5d64d42dab383d87e388b638c1ebdd47588e325ea5ea7d91e9b03e3b6a276344f663a089b69955544c05a2c90118c51bcdca821f32dfcb8bfd7d00a7792b076a878ab6a1e6acec26b67a80c26c457ffd23b66009f2a2b9b47e1d43cabc57322f3721ed2118e2f5de22953825d081563a4d2f1a60ea40c7557e8866a97884d14e586653e4572c746ee836c47e2e1ff3fb1016b6bcd1fdaad894c6871327f4878e9981b429e5493c20b247d8d8304961b673f7e2092bf2fe4bac9e2a440e4a37f7da9dd4009f79b6c68fbe9adc116810f5b14edab5f0904f00a5c2d912ab81d7e1ddf58875fc638dd13006eaa0c3b945caf4704101be29cbd66df76ea1dffa39d97623fe7313622cc1a1994fc16ecdad62e30907ac9d40acd57387c38ce5716734a92ec7ee23244505abbf37137fda0d47d9d79d57fc2b88bad51b3f75e12265fa6b38af7e749df41b1b03eff23f0bb450cf609c1f8215af72966ee5a76297047b2384df9a12550417e6ae9d7d6590b501b867662b3a179e74211a9622312f605cd792f48b8ef9abd6aa112bf8191f05b02fa5083468dbc4056678711a02b3d4ae74225caf3d2351bc6fb375d160716981674ab4c425e73ed73a59f8a3817667cef081b874911127e66d061e29815f73e9db94a614ae7fdf4cfd19833546ddf12008b88ee852308f40a075400b9dbbf492d2155965f6be03ee52d750ea667c3873549a03d8eaa971ceede5c41b07035f1b0d2f118791242bdbce2d4db456793d39e1c3e8017dc1740b2228588a00a477d65e864ccc02d8bcfd30e7aa14d410b30c3de660f6d8a1410fba84250ccf8753fd7395cf985d401a16bd75d3ae2fdae5a5a5d1b8e2bcde4b53a7c602c68e37867b7d12ce19f56ebbf61c538327b84dc08a29bcea807e81810a8fdec4838552721b30e2665c7d1bd077738b6f53fe4287c894575673ce6a09943430dfd70b18813f86f6279777e8dd77cdde69695628921077fee93012ebe3c8b3406ed156dea5945789e4497217ca454a82e843b56e61e5d8396b29c65550c5eb0de624a597cb8cd9000fc977e15fb1a74817394015ad5e5c41a6592178d053d33dce0a5532db9ab7d4516f43f135ec40bb740929f10426764003af6c52f0c0d1f5e768d185168700cf9032a0a7507eb162e7a23ca9dc0b11e9aa46b69605d3cc72ce2f580bee2916d7b970a7c22e0837f5ae377793ad1220bbd0400bd0297e92c87e5ef7f4091d6688a2e662f1dc68e5ac194f1748ad2af26b7421c171d38c7e3ce745aa306584bf22420d6d2011c990eff751d46063d784d4a7d0af1b996ed7c897289dd1924847941cb20757557985e56f01abfb512356097585ee27c35da4202a48dde0768637e3eca1c56c973045587cfd2b22745290953d6b321d07a299e043cfabbe7dd2d80a8ce4f3acaa9f4bd9d56cbff8309cc51531c22534eb0e5b7b425ef6ee154cfda5fd4a30341951561959103c61a4e00b060d081e90548cee75072ab90ea0516ff076d872f05cac167621b38c54ab57681947f46cc0a2002d28417d443a7bb6db536f13f88dd99a84c2c481eb6ed0cc263c418f38fe370a38617fa073a61b4e202189ef6da2e33cb181bace0d9b9aa61afa17343b851e3a659392de5dced2ec9722c25c76e8bb8b59e38d11dbe670ba7f3017024a188cd51e5995cd6115e0965cab030a6b49dcdf9a9a79b54b693fea043898e3064aa31c693400e3f87cd4f27c9f212fffcf19c3697a8324c0d5902e7fa92ff3f40bd5c6a9def6bfc861f97d076f9254167c8084f9797fec4d97a658070cc71714facbb00570dda392b971509c6fdd393d525ac59d0de6ea1c1cd8cb76ec38528c721119277a221f3d1bc732838cf1817936da84709d2e48c1043724a88692199d4ae0d668ad7942e071eca431106855af0467b079ee53154ba275f5d2b531c4d385b44d20b23c9c53d4a732fc7de7c23426cc7867a91f9fb5634e378a6ea2c9e14832e45d817065da873ac174e46fd16afa454b0dba19cff226e27cf2b1db0e4cf0834f38ece61b8d721c42a9ba8d1b557e525dc08c17ab6f2d1e5f0f3d0ae2b8a5f110e1143d9d3e5378d167eb5a6edebbc0f8ac17746cadbeeea40178bb89bb8a32d0bd467f49f82551025d1bf802e0fc3c21e8d18b577a8c077b9429a70831acaaf8a032fd703d2a6f75e6fc0add2efd4959fd7a27fbac5db79db833276c03b26d3184385315063f36b5a7c922632aa8a657170d1e608336e4b16538290b2e7475496e780632e1a3c62776e3618180a339e9a447ae93e9b977aca53655980fcbcf9bd444b53516dce9ab5b599da16293707262cff28386559d202353cde10628ae1a6dbde66bc6275eaa0dfb0ea3ab2137a9b14d6a8e3fd7a14c345993eb0b00596ec268d8f16684e574d502d001c26f4f00e41689db03139d7e0cde62fd6ad8b4c27d2a573496d8f5f165327ec2366043ed5b2832a9eaca7c18c2fbfe8a66474d733d8f05d84236a518d0b6eabc3c876c68ffd52d13a914520f361b01e4529614071aac97f9edba6a192e35b9a65cf3db5e07030950191124cb0611212f7b78a86bf39c1de5762233c4b56a0ef4f13d757bfd116bf3667636556f3dbeffd56c5ecc6835a0327d4b11b58ea5bea9fcea4e28daf22d5135af58313cb55ab1d72f4d20c722fe29cad4f8ee21e5aaafc1fe815948f4cb9e00074d34ecaee7a4e77580424640517a5b854e35f60354d93bd697c6aca5590bb3bea8ae4666675f7c4724fda3495535262f92e5f8c0d61d95bc214c705975a30d9996dc1cc5289704f5c6af7bd45765ec39a077f759af715bf13406b385c370ab99f1c073f6cff0267a0320282c4384bdca82fa0f5b464974fd831464d16711d0dce0b02cac7c70b8bec86b4d126f445e7791e7e84c832362eff8f483a22b1bb753ec6991bcb4db6c70087e72fb9f5626d7704be73648da4c68e2b40922e3d3f52dd22df9d9abc9cf58a69a2e417f9e5850a5d3272e8b96712a82e1e1146c75eba892f077bf92aeb48deb6171e1e9a55205d0bdcd8473daf37b6816cc644d36b7a6d34e1407cbadd1ccdac914b271bb16d9af63fef675ac3b4ee09919b05ee5af7e8de71b96c0279a323f8e2c6da2656bd68747de9327847766387161ab723ace3d5816f8363bd7647fb9e6a1badc259babad0b701c96c35a605537a87ab3903e439280776229ef20dd17c8a3af2abbdd7239e4baddafe01575b9e056286a2f122735be7cb46d6b9bfbcf9b42fcc536a7560af4710a1bb4a367fd71c7af9c11b7cecb9f390b9a25bd7eed58738f9ae964857e73e491fb0693517f79fc00e303f08923d41324bc719893045aa2a8a91307b7f614e57c2b1f875c1d271f3ad9d810535881128af8744b7361cf5ff49854d5cd82ad70f218a0f2d6f34c10055473d791fd8fa67105d8ec218678e8955dee2380b65c46cb56f801f2df903af52ba96bfb3f37eb975dcb5abf0938b2e79416fc112e92802e86fb2a765ea7b78386cd1ed241ba9e6cd23d2a1f5bdb977d3d97be7215b6067b8036792edfa76ee5c3c3f95c7fc547bcd39122811faaaa5ed5249aff35d76ef7f8c8fbd4ba85be7a7d2cc8a4a0761fcb92effe22febed730e3fd19c278e3221bf79e879f575441dbc2939540b1b05304919aee8c429992357edc28d5ca40648ba38c102855b8af2b489453060aa911324f3965fa8829a8ae67f493d4bb356c3c0878ce4c17a43ca5884eeab879b1354f5e6a3cc1a91e237b6367cbf6c1869bc2dd60cb73b286febf512ae0ea6002317ac5b543f08630f75035c177ba5ce623242ce5d74d8a3b4f3034a6980c8dcfbe36a5d445f8fa86d6aeb8bcee8ad5ec737575122946467bdee03aeb8ef0376f13631d4ca68e525726930c7d0ad7ab1447ea7db2a8a7d42352219263f7080277f3e7180963fe7eb77df4fde7e013359e7fd42abd346fb9b2593da18f9a875a28984622d7027cef085dcfec317aa756caaadea66caf0c84e0fa20667ad6e6108ed3fe7a160de8b5c475a00a7ee35f16e0b428d6705b794ff0a3c24b53a47014730eeef98f0d08ca400c1564c65cc7241993bc398754a6056bd6abca44e637cb0e44c2b49bfea56448e1f1a0e83016101b3ea899c9cc9fd6df2f288f86d9bdb79b2c266b1944885dbf09df6a98c6d07c62285ca21b388762841ea9dd1eae23eebbf2ec4c79194c3803057fe31574bd6e581051b5955ac574952edcd586fc330e261d24b4b5540f9b0cf8b40513bc57bc009388a6dca28fccd7af2ecb23ba37bb7a194f847f847f803f9571ba2a53f40aad21468db63e0b5e92790d7999cce283cd9cc74f0a485771862f24972a19b659989adbef0410cecf6b709f003fd6adac22d3b5d4bac3b2261b010d61c4cbb2bf1f66da422d35c038b5ebc919ad9a67d0e48a9444ec19ad2584a4b2e68ff38699bf3428491854493e6fa4011199b6ea6a4208e9d1011cea696834925c412fb370086cfa716ed6137e4819ae6ffd8de30da7b4f1d27e163ebf543a3ad362ce1f3e9c664e0cdd119b444eb6ccb9bb5fb05b7e2d3a9fdfdcb2a0b9ad3d2789e4740f36a8171301991fb8e593a5d8795722868a933968c44d45e253b8c158ef1a8662c9e689729f33b61177b2262351a76bfa54beaa9021f4cc79fec04939371b2a99d3a7b4ff5fba74384caee3b6bcbf43164abe69ea4c51f825286554e86cfa5f6d185e39ce8c5525016a9f5f48ed9be0e66fb2502abf325bed971b69d89f4f5c6024f75cf22ed33e7df3c175dbfda75a60c790331b5ff9cbeabacf2ddd15f9ab03b312534ec11d51e3922c70058d7f1906b7bf3ba32f49daa7c55f202bb3922dc07ca11b156120bcf0b72d8d3c4cbf264371fca73e97503ceaef520d36c7f48834f44ca6a9f5fea332108a5f7a2463b6a2b5d30a701630fe179840be0cafaffda50af41af0a54cd31a4c1252a58685c66967f50f5262ee0ab89b20e7d0693420d8c32eb393b456d28a772d480f12c57be8aba229f1e7a571d5ac185e73d9394bebd7b1f4b9d52f1dd7f8c101cf3f557303c26239d14a296f9955b5cc4661f4b49faec7a9d994eecad69ae9873eeb9476314bd8872839a8839d956a678403b35e098e6efe926248addac4c963725ac5b5625888933fa600afbbf58f8a9701b3607fe2ce8fa46665499d1471c89a7f912fd173d7b8034a34dd7ba4c8062157a8f3eee5644c82e16e5a114ca23bd69fd2a6b4e2afcf4dae3d3c9dd7017913b10666811e1dea63be443ef2973a6dac9f358d97b052fc142074099c63052147dd01510c27ac60501779a2423f9b6525b8315235d4781027deadf4162fb0f86a39750a419a95968a58a9563d554120ed4e2ca3cbb00333bbdafff4b74dd608689e013a365c4afab96d68e112c2ead0c74742ee5d68a812a09e98a62eacabb9f1c39e706833f3477c7e8db139f6009110b8abc6bb18cb8d36aec80a2b0b1a344b964735626d00072a725c5a60df4b28d1d2390665b6e070e4cb0f256fb47f001e43ab6a4298a23d4cebeb670194336a0442846c21e577abf88c563a4311199011ec137bf9b4d44bebc401ddb9534f2e537ec1cccf6a379bedd6a9a580171e78a2627af0838fa910b47e5ec366045042ea19a011df082d4be5248abd41ddbcaced204bf122cf3bd822515b4878b2e29245f3d8a584f51719e63cf5cb34400452293623b7780d1c837db5681644b5b4253020ce99e59b74bad14f335e018b26ad0fc78c72f2bc243dad7550750d0e560f1177712f707b2bc6e131a613e9f1cbeedc4f008cb54a609a0b70c8170d193c5d7ee9b5386ba14b490e9b346fd597ab32e7d900479fff50f07546e8a466a69fe95e576dcbb74efdfc6148cdea97116684231faf90f211b6bfa145132ac78cdbd3424df35d2b14ce269742ed9c9ec7e8f50d38ab360198e62be38c62f1858834df6d1c5a94e4087e789147d6b12214302d8caee355ea606edfb20a8097de9011324516dafc929a5e6598c2f1ccc2b445ea1906125f3bdebc7fdedf44b7e14b42ed1eb97924ecd02c7daffd3d4c6aa9b5a6f73358cc960390105214175d35bfd675b2bf2f8672d27ec0e52d01260c53936dc502bfc968f74a8a874277989940213c71d2637f19b54c818c1d98a6069792d02a5f2ef883f01947a1a457fdb4fc9696c1f23193084a2263f62bb2e3fc183fc25b1720231c262743f83b4597183c6939e12cffcdf3d05e04a12a94c716f53829df3f5a22aeb9b900d9d68968de9020efb58b655b2a1b9e8c6060084c32e7b5cca542bc97f9a61badfda602d39ebeb0b21b83c862cf08986aeaf5452435662c554d7fd17b7d4f2d9e423addf4c16b796030e5c85d1c4971707a7ae1c38eaa2dc0cc4368242d551fdcb3650e2ce547e902cb831591c51f9c4fdc5dd9df97b7ff0a99a4b14dde86d314d94bcfae136c147a327958002151873844085693f5f9c5375a83bc2efa3ef6e7787732cdc20342ae38054a778cef8ca909439cbb8651e8887b80d6a81493f892b2432c919d30a2220f8a1f1b9423e55a542a7c099320dec2330d5985862509636829548eefe87bb0283358a4daa4d2ed2dafd47dd92468a1b7eded0476891b52015ddb20c1eae6fdaa431244fa0509ab91411aa59a1c5ffc9d378564b1319593518d28ed298a683f15508dea7d1e9a18a70557588585590cf93f141d3148a5a404ff3e6fb3cc23540ab0661b0b9439e8012d148537ca1be0d11f46616362d8f47f04bdb0521794fe3f9a5fd3b1e74712f3b2c43f33494fe325c90b8046ec4d0adc659e6309d7b15d10fb85fd06745fe787e5c507d4107f73717869453de9a45cd6bd4996afc2a762f103781701dbed4330a4de6a891e964acf056aa03c3c55d655d90b053852432b38856865c037fb57ea8cb994c846d2df3ef2065f5778f91a9ff0492f56a7ccdee987df75e7366a94f7e64da828dfe28430983edf260ab5e7a9a52789bbf78d7a1fbe4717887ca1392359b5e99cdb735d99d349c9cfb516f204f25e93f2c94c04c2b0583f4344392be82655de3de033358d15f5ab9f428be54f8d572d60c74048b27ed86cdf853c36c5d419cc79446a282bd4b6d8dcee2732681a93766e1a303770b781191fcfeb91a7ddb78500fdf3910c05254751fdb27feea3838183bdb1b0d12ca16c78998ea25b8ea91ef3d7880612bfb9a8b8d7db4db7e466a295d15eaf8c38c3407828b0aa3820d8a9e8445a9ddc838e1ab5745f5caea995d2fdee9368e439e4a9dbd98433aa451de225c0855cbe78921d11c9e8b91af5b9a282ec5f022adb02ee6e4956ad57520c0cc730e8352523b31f1b9752d93858aa15f593a6efa96a05d808e2b9f82522e950528f822120c4772de759b6a851dad0ac4764ba9193ea9d58ee7c87481290bd989bcf2ecaff5f4ae75a06960d7624d2826fd7997db916014706f46dbc9def1a1de3271dce8cc570d6e8d85b64e76b4669462134aa27a0e034fa6b7ab3359c4ebe59fd637ff95bf766a6a8c9a4513b8a7c73a57de0683b63a4578fbd436ff8853db47f8187f5feedeb2a4d9e23f05e42a48071a7c068373ae9200a8a1328c70eea6b33767b54b81a23762ef40c276203b5c12d9c26d6840508d7a89096d8aefd06d4405a145da4e295d083bd3657f3ce1be863e7030bbb1ee9ca28499b9a304f3fcc37fd182641e48e88133b5bbd0a7ff5836c02bb851bd602122f2d08ea7a3fbd8958950fae354b393141ae52bd833772dc0ed53ac946dc3ba72f0a5be1af542010d8fb7da5e921fa233148c0ecafb565cb95b7f778209c150be197cbdd92c9dadb8ca584ef5fe615b1ebdfb3347d97d3add4cdb0a4be793bef9d0570a483a00e6a6d7a43c97ce713dd10179ec44cd05835530631b033ea976e0a595c4e85b0ab327b32ef6d1705fd4d2fd064c33b991bad34c1550d088efc98fccfcb9ad1b5c1a3e916d013fe3eea851fe6a64de31ed7ad4bd78f251430c51c488426ebfadbe1aa8ddd0755b8063c1f8c93aec6e523fd1d57812fdd47e7329073f16046961e651c133fe187594c61c73e5d2bc2f4a8b918ed7dc03ece1e98d6e0c17805279fb359ab1619477c576c44542ec2ddd22e14f681358c3842d84d2476eda7d3ad84e422c7771bd2e3135d09759040b38383f381e89d22319781cfa8c7f507424987b7d5bda6253dd64f866216c9d0f23389c645b6505417ebc23f927c43d3548eb433cbed08dfbae3be1b50e8b42f69fdfb3f0ea854c3570bf0e20dcd65a3fdde24a2371353a15b8e67c8e9ec97faea3ce4d2d8ccd735082ae496b6b11122a3b7d13141a014f4730bfd291f8975bc9f762b44b176ea3c14448332842e5175f198b4ee891a9a23be66548537d75075f3a79953c85bb4394b857943665b57e9e9bdda99682b1583e416f66946cbd3af7dd7718cd94958568a0752bf32aa4d058f28385c19e086c0309bf9427fe17c15911e9ad39ea61c14a399b1e2d616aee81aab0e21d275a2ea3eaf86087e086bde4fb84db9846d87304c390b6c106136b2d870b029bca1de1a55f415aea77f288db25cbdd2b3ff2aed4e87e3ca0944d006b463a1ec4b5dbf17682232bf1ded1713d3808e9121c7030ec4af9cb759e376ffa431be607c4b3be3f210d4fd11bbec59e341f040a3da30b0bddf98760897788c9a2218913e5de5439f31515092dbba0f161bf3e310f9298ef61235fb04feee3a5cea6e5d1bb232164f5f2aca404cb8addc5a316e0106d3ebb4d926dabc97837152380b8d7c1a4abaaa5f4ec0744983f97550f17c993c54cba01df8b00c94b167d73f3d26b616f3473c9b668e90dd8fd2e85046539e6d5bda70f8c22383e4835e8cbca6f3f1dc0d59ec10e9c40abdbabc2a31c1095b81bfdcdb26a02246e4d59989542a1cd24d12ab3cfa5bb37080655d78c5472c223e43cf9b1384fde463023d535e7212de6a74da8470351d08635434b03ba1749d9141953046a7a56ff863f55a1b5f6da47a5316b6c083647ea882b07adbfe543462b5dc5c00b7a1914de1794290fed40673e300de414a9dcbebc0e94f14c45adf48eefb1c63edf3b35a9f8e37a82f17e21d0c2697afc772a482be6ea0bc7fa78b860683cc71f03a369215fa318d45041812ab5d681eda90ecfabefbcd7c1d3bccc5312a6592af9cdc7880842d8d465c0d42635f65c4d25ef5fabb1f627894ede38a35ba38bc97e122cf99583685eac7d21e888e3c69702719cfbdf8ea689f44ed06bf78df98166a8702f234ac06400260a7d709427053ac0bac32455edd4478d2f3eb4f4ae3b807751ce10b469e72cb6d0e2b802da4db386a019949d548ed0454e2c623b75a22c7658f595d04d1a78056338a0285c3f13b3e1b8e557ad71df7b8a10ffaa1d6dd368bc7c0897a87f61cea89c354b91fa7fdc1aff7110aa6c38b6e5b0be2275531b5ff61c551f4fce2681c934d1b145021247c9e81c5f9b314fe389cf1babeea6d9c211bf40265c55a3b6c3ead213f65e62476c1dab1360125d8f6cea5b81ca1d6a61de46c8d310a18e7df260873c361125f3adb470f59763dbfa6f66bd85d5f9c30607c10d076c7e51176a21c6d7b251c7061525c1fdfcb399cb42c3070a2c4938550ed37937e7e259b5da053aea0ab9aa8fac7b15b126c8dac4d1979b1cf1cfe0d6680fa01d779ce307ce37c4a463dd4cf36811d7e8b9ec43feb91ae9ba615aab8580878bc0174890e2f417d9f5d62eef74c5d04c88541826b631b6751493f456e82407bbe31d4f438cfbe4a96fef265a7c3fc35c04379250a45d2e0d3452f4914212ac6061f7f32147f3f5f12592cae50d2e21ba65427c856ead056a528c98f2fc6a844bc78a88e4f3f7b3fa52b6817d10d66fff45baa76cf634be2d4ef09d4b7ce86af5fa73c3c368134de1b4342af6b9de3d77cada03613ad3fd68693b272c3bdfd9822f1b45642fbdd77d6b38969c2c510e36eec6088c7b93460cd5edaa27298fc478db4df8e9bbff8b6535fd82707fd9710e66c6473e96c40bfec607de3cf1441f085b25a3cf62f3b5917c5cb37b80da8a28a23dc30e77cfd5ace9940af8f8f0a399355ef36f97ec43b574ebb8ec0d43134fc12b0196fce79f9c781836685d3a7545e14e03c176db696991e9986deb52994011fd75a3806cd993cfc558e771a49607668356535ac9d59e76dfca6179bdff19f7b1c0a0a17a4eed87a314a475830ab71cacd8cafb8b665bae40518f61994040270186c047e038143d87187e5be26dc7470feff022ea33a75d3e0f53d3bc4320d377430bfe65182b98920f98c894bc821c9cbc537ed618f4da343b73493862258aabbfaefae0765f8e299d65a1a8a94bcb37d4daa0dae09e853fac50072cfb949f620888e80d81f73562676d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
