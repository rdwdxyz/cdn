<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5eff8cb35a3efb6bddc3cd778c9ff48f36ebeeb78fc4056b4b0e0df4eb2bdc826e65028df5f5d1ff3b4fd39c22d34ff913153feb26e1612f781be5b1899f6bd28de6d9b5e1c87d6f506872488a5230d7c30fc0e5b415f4fd90a771506bee0538fa18d8092918668644407dde13ec84656eb7bb91ab94f7b5afb04682344561817d9b658b67e1ceccbf4a1b5d24ae03d09772843ed9817760b879a2d4a18432fe61be42f6cbbaca2a44df8688e3c7b246953cc60301ecea061b6a0af1cb2e83c0d28c6a0eb48ad83259cff582ce6ccb355b3f6bf17e119e36bb9ca6bbad2f38af15e2599477aec50b703965a4e3bd9ed9ee53d7628b7953d9942ae22c73b38ff7a70f1870d7dee933e047ef304d08efa6723580bd3180a2acc505ee87fb8ec5a57a202629f509c5bd3ca6ca78c79012253621cd1b0bdf73e43bbdb323590d850b1e6219e959cc01348c606185f9fab93e91fb3393caa5d4fdf0e22ab9c90cde76cebc8308309b6c53d3f415c895757201856d846c0a621cfe2a6c048ddad260965b52c2171d2715d37abf2f99b2f4fe88af230fbec0d972b028177362132a9b5eb2fcce7665ca63bd86304a7d5aa13b4130b5c12907ba98a84fe05c5ce1cfadc5fa3e35fbbec458b5f9b6c8ae8e78670c6457b455f2a38d8dfaaab301a66528e03f07d5398bba02ed345f4b2ec5dd449333cbcc3211a9083f088ab7406867476819d4fc4ce209a30cce91d655b3f42ae270367aa993c3c33489e48741100d6dd756889ea334c553b4654ed81ee64778ddf1c46467bbf9ddba3010971d78bb91f35765ab35bea0c2709031edd1d9de5cec1fca17800d04dd8d7f4d21d294e223309d93845eca1c038cd8079e26616da44e36e095f65176e6f4880887e038982ce6d0e2cad5c824dc18b1d85238e1b6d3f30dbabf69006bb1fe1df948f8e4dead70c0325cec538a791e85eacf5b8e9c78f29c0e87ee2cd38ead513e80b91eb37fdafa84916e0ba729838b563ea75dd86ed3b88792561dd131612a9b28ff82e3f3703197be828d8f41d1e61a079fef9f846d198ab09fa29d5e3384c62ab2e12b77e06a6ab9a74495abe553d121bf49e39f0d9aef8b6911a50f94e545db385fe45ee4cc0763566cdc7f9f50ef48626d506af547b4ab1735d7676bfef8112f6cf73ef4f06319a1c8ecfbdc6ee67b706d0d368ca2f7f39fa6be2f3f6d3e8a2a56384e6befde69636fc35eb01dfce1b2161da1788f4fdb1bc750b6b40a93a287776fd4c9ad63617df924fe873dbebb041b9873fcb55caf7356d1061091fbde15e31159efa41da4688f21f8d2f96418ab77d5be49eb31b8ef5e98db3be1e831edc3573ab90d77148a4c8a1d75f9e544597b508fcabec4a3b0da6cc9346423d00335afe9b101553bec6a3190d6b0e568355614da2b9c69bed770c34fb7476ef1b6e8b16119a1d5e7c49a97b156ec239f05d5a9e5c54c2fbe88218b2849f9c03b7d062d32877d68189b6b46bafee65dc2f7afb239da0c5d61b37ea7489f966da119d46105aa9c42adc90c0c6286235cd601b8a7946fb39ed988bbf338995154d3fd01b88f1432f65c676b2db8eb9c221f19d7355ee47c33ba55c9a380ba989002ba0592d7178362ea663c2b463a38392a4e034f37379a6fc99d88ea691faf9a9e5bab4fdc2ff32b84a60955711d91f1c922ee4bfcd7ebd51c2fba40bfd002910568a777fb730414656b10ff7dabd83c45de535f6cd7ee263b27d50ae8c88b5af81a780018f74b90902f97ae24c6a0fc1c6dbcfe5eb469d565e3ff8d34172714eb49fe25baf83a1fe833264f8e2b9c3365baf04f8d615353eca22e23c37dabf9f059cb5211422401f18188935f8486606228b29ad0c3564bb73e5ab875f8188fe6b5f4e7eece221f3e0391fe3c58eac7504f14cea93e0c602d462335db04e3e6899a1db743434e550761ab5b7980be19cdfb5d8ac29fd7326992e4780af9a7cbefc9f8570c0ea5bb75515d6cd8e0826528dbf7a29c8b46af576648ee22feccdb1836a796527c5852da25bf300ea1a5911e7d8d2ca00cb7ebe3fffcfa16c852110e962e8383b4d6106d83936e786d0010aae267134c5697645512c5b60adec08127445f59f663f571552df01319cbe08091cc8182bdc67f7aeb0f9c14598c3c2d9090e259d59494b9be0798f01031d9d3eef9d1961c16b5e68607a6d8504e800b5cdadbe8ee10c8df7750c7e2f7ba626a937c962f7aeb65614b162a9996004051cbfe9b6f45ee6be26f0f3365ce12e9c490ae3c215ac47313770e85a2fd815799074042e76a9e019997eafb0af593b5198c6eaa8abf1b01cc86ae043030632c037c51660a4ae4c282804c54f1e01f49c59b64a1b0d229de99fa999f7db8c8016a6160af076cc0083ffaf3c057104ba8973698d9d6f125b9b37445094e89f6ef9c01c41745388728838c60a724d62260b2633c433370b75e8377b2eb8a5a41faffd18f6bab3182139b6afaae3d3bd0de44a8ecb86c0c8cef6427528eca41dcf359b25f67c211b1bf3ae83a47dd1f40a522cc9b91870573fa9c3b7278d829af3bbe87e3fb430455a5f49e75119d7c6de3b3534d7a09073298c570a3a49d3d08746ebe873c4ebe6a8e85bd19d68b34b1ea370e2780278caacfad9e0520d5083095269446dcaa023cb86ce2c9bcf7d29d1cc307051b55c75fec71cab60b45ac6234b9a8548cef4c173691b23739596c7297262e03f4a778984be5c465fc0412a63fadcf2d85eea44b4d6b6b9ffe1fb11ca2e70a2e6c8e027699139589f3058f1a35116f2c7d467d5272e29bb98dd5dd7613770f25dd333d49fc13686b2c40d79dc5bcaed685898a449b0f344027670bb52a3220dcdf3609364536d8257182b07f0972a41cc91330d58a96eb18be1ff3760a558cdee0e6d1d4c6b67df1f1f66a6c82c4508cd7e209853133a4f7114c8b9b82a67081012ef2525e228429691c3de0edd30b63a1644f368db656b26df86d8b45bd44a8de9ad24929ee0f11abdda03b51ce39a3f599426d12782b3981798defacd677a2751a823303cf47572d340c33537362fc74ac0cfe2663584dfb0b214606919830b5053ddd6a3303e0184aa41ae6128c017c602a308bd91fd4c0de577174aad8dcdb756577835bbe3c4d954207e41c8c2308e1edecb10e8ea841f4f0f481fe47ec1fec1c27444ba6af3f81c9ae8a763cab90e03da5176b1f9eef05143ebf94238db925c924959c984334bd3db76a0a7b0794c39beb817e29c5d85b5809a0d08b9a984a91f9f2558b90dec106ca0033e45a9dc6754a2911bb1a3642fdd40a07bf615b78e2e78a5d651bc7bba396e88298ac971191c910a88827fe8bb29bfeb2e36e7e50147cbe85130f34fa025bd94fc5f626056a0801c24da7ef7179cd90e923c6bb836314d5e473a3a44185515fc0d2df87a3b0a88ddc86bfae19cf6d531ebe933620922c20e70bacdcb7ffc1c0b8dcd11e6793068b79258a839ecfcfe3523a5813d43d109a291d7632950103623dee472f010dd18499297ab75e14e27a6f688de25c1c7e0e7248c7367ee43d5b5ba5767185c11034454c1028b400b93ff8b2789ac8b9eb068b4f9f08485965fd4b2d08e878ac89768bf4e274c69966acad5531fb98e3ad51eb33476ea6bb3d7e4d61b87332ce2af5a3c36807c1701b5715ece05ef68988c0cdd0eb1b467182b5d2d1cedb67763874ad34f9e35ad3bff4a648d623db5bd0151718fb2aadd3035bb27dee0d402c9cd4267e854a25398c0593a6967b238392cdde403bd4b28143d39d8b402fd30876a95fb871b4552195e1cc04faf1a363b697c09d1319853666b76bd42b84cc384efc2fe01f9a346680b9adf836e8d10eba0e1eb96799aac7e02d67e3ca09b0d74a2688ce1345adc145d8c16320aa51a1a60984248f6b48fc738bc0aa0f73c8559d2df6153cbd71c76c90eae221403c8144b2aac4fa0be2d6948528ee4b372d002ce33a4d2a2f0622dec1dbca287ef79dc53e63e2f04784d0aeba50f583c2ec0246d407b91db955c0cc972ffdf4e2c4ebdfa19393c7ba0f74041ce220175e928bb2d495df3adda03c1d2008998ca56da85cd55e491acf133291bad24edcc343e1c7431b2a67c175faefa7f6b40033ab827428cdd6beb6628225ec674f51f7750c673e3361a2013e6a7f0368dbbeed4f98faa54a49b7320ff3290794a584f649a8a2b94578b313b7ab0f8ffd674fc422f45eec0469f7e495a519b2859e130e924a28c85d22302977c9fef63db18c0ce05dcf3a4427d8d7fe75568abc2f5651ee7e68fe64404185aca24b66cc4830092f4a9673cd519289f5164cc94d3721e9a54ac035c6076a914cee3e9e2100e4ef5581f0044309e757cf6786a10562e11f494bed6584a1e9661f61badf7740eba9b9a2a9998d24e1c4f20e947e68ab223c160592b5e8b5a466d9896da2b9000b4d3d54e00360500904921dbff9e79a5c0cdef90f881c46973b881888068566d989e45009a69b3da0002bcc1b62351c55c964457d453a70d7f345b97184572f2daad240b3a610b2d9d50b1bd709ed3d2c9b4e0f010ba79fd41172e58e1bf53f3981a32c2c4f0b79c32dc818d936151eedb9994493117ed996253f9a90a1be6966aebcfd7bccbd82a97ee4d0c89a82f410b9b97b32100bc79e8658a22d315ad3a8d668fb96709ead34c9369a4ba7736294d68739d43f269f430729e3033d4b6dda2e695eeb9eabf7bb12e2c6e009e14f5d72d2f13a20c39d57250333837c95db49a038b4a04ce8255c0bff6c496c71da59c06d3ff3e283e19f73373def8bfa10a2a4c6d20bc7fc6b0b7db19bfa1e014708169d97c3e43ebfebd335cf25208fa4477da83f2b48c6384ad358e110f25c6a8dddd1fd6f4750f291b2a5dd75703b890bb367a1b3ef0e029bfd621933d045ad6b44922235a9f0e41c95ad150b768e3110dbceb8486579ea05a018fde893acc7238c763155e9824c0c187bc4770d45f161510541386a7987a4177472837926c79cc0cba207f34c73da5fd7f3c5e5fae6cc4a6af4cfcabcbea6ccd2d7e5eca5a071e2c6ec00674331501e315077cbbbc9a1074e82b502911ebc07788c0b7690f157c23410827e4483d706a2f67ff52c5c710a36e1f4ca60a0124b3c648e7eb9a0966e96c35f72542aee4190d935b3bda0d9c5fa94d63fa53dfabcdcf4d41d51e7a7c628da9e3456ca8b5ef6d4ac7bcd35d16fb3c1061d2cc3121a1e0850facd642bd8293073f45da4dec6f99f54941ec703a3d542bd97f0983352174dff2fa65f0cfdf8d71755751e3e6d5676c4ac065f06a96fe3287e9e89514a9682a5e1fa81cb3838ab38d94914e3978539f07519f00ea9ab74cf2434ac3709319bc56d2bd18b6ed1e1ad2971eb89c0e54afea74b12cb722b3e462b7d09b9fb9700bbd41989ef1ec80f5b319bb5755e2d2b4e37c3976848dd38a1b5351f06e56148926fb71e7eb5ead9e7dd45cfbf7c42e3d9dd538fa9163a0922e278c548a74de17e5caa74b3ff056423610d162e58368af645e6fb899af8d0a0821dbccacac884efdb1b742e37a97a00c8aea2b0c5287c05427a673b7a1978c8b0226cba6ec836e5fff481cbecbd536509b273736a2f28c11d41ccb547bb1da33be5101a137e77529ca3f1d4206c2d9f8932bdff2bfa9bcb9923e981b40255c308d9af132ea234801767aebb0c698c3ab4a3e18a1b8a6e9a5287db5923c10ef1758e028eaf5b737dcf6cd18c90ffbf7d0ad967f92cb35e0c030c8db1fd35c2c2f4949f765a4f506adc61382a9a26e09456b4fedf1cac1ef116913b3168210e7555f8d30f855fa6ef069df6da769fae83ad7a2fb2351ef6e8d1adbfb979b45f9df444ce84f00a6796efdddf2a463430b61b04cc0a0f2711482049ce6cdc9289e96ce7e084beac22acf0de3572ff04d8b7a3d1b2613d60a78b8b20b0dac0dbef94729b15f6245f2b4deb99a6d24ddc2eb048f42f269b2efbd91bb77f76fc3d938f9177169494670e1bd0091295e5b9be43f6ee00a546cbfa4d541333a6ec0ff6c6aef4882d1c88dc83ea3879d1b785d15cd6164550c7ce609fe5f3531bbf44c94b8e6796c6232fdb5f2d1771caa4bd4a4b703831afe752e913bd06a681b06bb5116a59e709c6b2ed8f781d632aa2dc0d0709da186e8d11f5011e4280edcf9de656dce2f6228372649473abd00b9b54c5ff55608d2c2ba5441e7990a7c25f7817dea739f493c1932e69f23378d99a695eacc9aebacbf4115a8316690711bab2510f50a6615c0394fa8fef4ab1b4143d9b63a893497bebd937fa8ab40e00310b0e3c8e10caa65465bdc2a6672a71e0019bb3bf507fbab3018dc48cb2b6fd8691c4afeb88ec13ca5405fe02db89456afdb93862b34cfad8dfd5697462f958b795c6b1233016c3fe9ef9970a68665e9f2a416aae0a4a53d3f10550b68b23f6378b22368be0273d8f0a39a6145e984d301a4d84ede9d0162f3b735d18ce7ff54f547c212d1dafb99384296307dc1c77f8dafb5644cb22fd4bdece6ba3f698190764776c84fdc44feb9c71684017f023f4232f8aa82deba8c756a8aff2e32da241377216c076b90efc15ca74ca6fea71e14c5c356e7af1784bc25d6682a80bf4f5cbbffa2ab5388514f2ad2605e2968b202cc7858cb21fbb623696053f11906d2e2ce7800e0253f9255d1badadf4fd6c3d3a93a5c337314b4aacc938e0ae54bac342260bb835ea0f978dfcd63f7b0172dc4fde220dea1a4a70bab319b07cb5e9ede47bb9917ecfdde673fcdf6e9ed04527c26d191893dd73f6ee48b77cc2b24829ce5bb1c8b7b438f788eed05836ea8e179394c53c2cb348e62d91018c61ab7dc79c4ef6a29644f13fb384dd8b79df27b3073f674c988b0878009b939ad07117112b389083ec00acded24631b3ea0c894768ea97d281ff532332630072c2e16b01df52a77382b95c9f51140a3182c33f400d5ed34dc4ad1966cfabe66b0b4d9be5fd7ca776dfdd845319d6f9d129705f1e41e4125c26d5c5608a028bfa78bb20fd826c79ee82005354abb346bde65922fd2107712340f0530468fcd1e01df5a3c867f0ec6481e6b0edc78c288ead4824002ff0a4186d6ec241c32e22b01fbed4b1fb649d724ca9164f715993f5c278a8c440320b3e459feac98b4877b87d0796005135a034dd522de001d65614c07a4351e30932d811133f12b937114f6ad5935e010f3a32109f3e65481df8ff18fcc00ac629ec89f18ea96575fc29be94a255d8eb89c2f28f525d6212c346d1ee1d72bed3e95c29321c771dae7d60797b616d8dcf703106cf49db886de48fcf823cfaf6223c316ac489370015b2af4bc0512be3020e4085293344d7bd4e1dc1934a1ce271d4c19588fac0575eee309e959b4f35087f4deb2a7ea7d9717a7f073581deb0e3aa0cc4faac264c3fb44bf4ac0d4873292290b2f430f0536031b780292ec1b5caf7297cf795bd8c591c2881df66353912e3a6f003efeff85928fefc4a6828a2d6948278016b585e910536953210edd95356200bcfe8f5f89276199bb821c6ed006e0feea67507eecb2d41344f1740b73d4b4cf8e85d6b4e477c9dd769a55554ed3bba5da4224c11f5456e0a508ab18b06d3607644c414f2dbca48c87d77f1070e7a2665017ba9c3a90ba05f25f91ee2cb119a5eb803f440acb3aef46f9deabe4d7b633199421b0ea3688e813736d27395df57382dffb9cf1cad006e5a001bbe9a0bb5cf85d36941e8328d94b2cb2f24961a543b3c0b8a59ea0f74ea112a2ae30e00954f3f5633f4e19eaa7ab6100adf5d4e7d6442658304446651f95f73d266ca23a753e57b3cd1f51a191cdbeeffb8060af76f1227678bc9d5bdae5faa0544068c66049ea3e0124721eebe9eb47ee1a95825951c98af47ed5905693cd0ea46219f3847ff3838e5fcb6ddc5e488768e19a8b683ee1cc8bb151c934ad0f60c21c1738689d6ce9e16460c2295026f2b06c990126d00a196e3a8ccad6811f590f30ec11974aa12189480118004a417cb826643eccc85aa761185523d8533db0f9886df560c0caae9110d9be29f7481893815b3c9bed9715e9a5b9473560f7beb46dd5cba6bfca236dd2272efd42c17aa9e8da370eef41ef807461714f740eb8a4484df8b38b968e1a742771675e9f34ece4abb8beb016637fdfdf7445b251af39b7b91ac9fcb4e359d64e0240b26b54519154f57218ad04ee6254b0876f8c45cabefb44dc3ad8ff83d9f4c32482bb2b86e7ea6a92261d258162d2899ad8054f3689dfeb238cd2bce53df3f8dad7ae95cb95f05a42440d344a19c3b7f7237039df96cd4331025afb39cd7daaa444a787a83539906b1476506fdbc6440b342448ef082e5d48d1c4eceaa98c924a9150d4421a5bdb6559162708c621e0f25e8234be12eb47d1e958e6052f1c699e5b06319a57429bf437b108f08b0e27df83b95be7f5a86b0f7575a6c2e363d2e1871494b00bc6d11613c1304b0196bacf877559e5c522a0da983016f6e1deb84d9bbda8fc77fcdd5f2625b19e8b0a07ea26c4d1cf75e4868efc5d5840b3887c9edaba8fe4ccede0064e37f3b8358805c0412844e90d3b1ebc12bdc31092ffa00259e09af14187d1442ae484d95bfdd3ca0b09019dd0a2ba3ba57c44ae47a8452f9fd870b7318eb3a893a4d7bf99ed2ea10e23d2b6f2d102d96d79f61fdb5601b90417b1e73f284134d374bae75c316bf24f90cfac2f9aed3a165d6596125bd3d3cf4e8256add602454d764755b573dd786addcd217262074a3ca780d68e4f347f37eb8224bb6789f9aa1d1053f37caffe4c2c11fd412a8bf7c0507cbacb6c09a99e7edd21caabae84e8005858d60b2c032e7696dd90443751220a8c3020685aab8ec94d52ce8606f9cde3f1545256676df716a0d4b3b9b25246eaec8a4766e9296e50298ee4cf7fbc55831d4d062c70a34f0ee79720fe6d535568af9119664efe16944306398c8548f1ad4702a4cc7889015bd943813d0ee750168bc883c07c68a8a0a485e1e48d872cae94a3f21cd76bc17cd41d7c3fd8d9b4636bedb4c0e2de8f527ee40560d59c78631e1e428ba951551e4f45cfabbf35e776d67792d1eaa75b5ad084d6872ecb9cb7fed97466da08f8c0b5e87fcdaad8c465e9d70c2c3e622a90397301ab5dd4529b2f3689763f6c6958216f3b6d2d33d180b29cc0bbbbaab967ebea61db0b546c9e2e4726a2b42208f3ba5eb5d387d805624ed71b131f7985725bb279f2147e62011ecea510e67dfb16aa89c007bb2fc34c44f4e07d231e6a83712e73689e188b8c1475c07baa58a4e4eb75da992e2e2930c239b6432f69c7628cef4d6bdf748e33826c1f09e812109178e1d34662c4cf651b0d60b133ae659f06fbc92ba5190ee7f9419a3b4ba44a85efdda82f7928e5f2de4a4cf224cbbc7c383447043e5b4541f3abe62e87d3c5aa2e40be6236291d8d5d5f8c62ead18941185a10785069fdd4011edf67cf50ee66de34868fde1184fc6a7e02e2f10e0fe10cd96cdf1b5515673b099dd5fe691264038487fc8461c6ef01b1a95dfb00c00ee21577dd07fc9c4ddbcab18155a83f82e680ce627e00efc67c10b9dd9d1b1eab4e103ca419d9acc3e82f4ce1a90a02764c6fc08a52943695c49747024466191569d52ef1aaa0b9c24931ae06e9301453b5baa1c484df62945bae9891b6540504b958bee57513f7570643abbb5b63f90524464774253bbc76ac51e6fcf2f46fb725f5876f936db554304fe8b1c189d674f3ff923c3fa6f79765b201c47932e2313fb39ac4cb3361f7b67ea81721d681dee9cb70303ed95ae9e55662b63e3934b88679db25ba4916c2e3aa07021b7218f4c3c2c0809a2c19d5eba2aa910f423a64aa8c4d8483ae5b08ab63f535c141c8fd941c1c289f0419d7fcfc44cb7850b2eca2908cec03a92d03a666e65ae689e4b1154eb81e5bdf873b4b5f2840eaedec2a60eee2e6c673d97b728a8254771eb7b32cd95dd8072a6e9c98df8dbf41e2268596b9a2fd7f2ae3af86150204744096743f0cac649a289a6b934aa4c0dd7a03b27efe0b46de37d365655cda565550f407c467b86330dc9ca43174bed4d314cf42c659ca4836f9239044cb10f4d7fc26315416d176002c94d497bf86ea2603246ec5abe6fb5de5c5bfefab4df7810fef14f17c9a72ee00bb1faf672fbaffd9fce21c89b95478f2b1a196d4def8da0f4fbea2d801c45ea6f3a520eee0c4c2c0ddb87e37b5ab94bd2563fe0cfbe10790a6c9f7d7c3a327ec6378c0a60a2d9740bc20f15983786eaf8ccea62fe976165e81d27bff320edfdea466011a2264de550f4ae53601d2aa20b7faf231c4ffbda42cb0196dd5d0016880afa814e6cefeac931fac6d767c7c181721db098ef81a206306f66e9b75bfe6d03fca0fb209643709d4b0255d573443ff956c0777b7300bcc7770e26b939bbb9ce381cebe536ab21ab304bf5cd487cdd30980f69d15cae2c70b32608cd04e87a0358907056dd068fc285fef13656decf484489805327e87ae5bd98937027fa294068cbd8b8370c93d81d050114bc768ac1cd0d4261daafadc65662df969a01ec2a50e9c0b247b560c7862b868868a0dc8a1efe51217b6f7f1c18e01e367c5b75223e89369a73341dfdf2252472f2c449437974c90124e941097fae6427d069fcd4d66b1723ffe52460334485f8c62fc899bba17ab374f7819e1bf4e27168ba0483fb566390dc694acc616038eb6b6bdcd1755a4b3c45244973abea2114e7e4a81743c59d9575dae59911273fc122ce63c26a35e7d600fd7a1d6b8492121ba24b51be1dd7c570dbc97ab981ae7373decd2d00c7286bf2d04a16352fe95eae4b2ef6ccfd517a4938db17a63b28aab40fa53e2948f1e4c4a01bd7cae05047e1d455bccb61e556e4ecbc7929020bfcf18a4d9be19a69a6b5c4eb7b7ca31b5bf3cf259d1192d483c569de6bbb4bfbf6a8417c91352178c10c7534144ba8dc0b1d2d3ead67d456763338c17637b20ef3d98b0a700df8e98e46bd42398d6bad8cacfb588ddbd8fdf8c7dece3fef75c2067da52ef8b74deeaae20e9e2bf7aebccf0f596d5130e967a9a510320741bbc52ebaefb97ff8ee44cca5f30e1a8e7a371ff7ac42df822bcf40cc1b5b0c69fa13c8793828be492e8c73b9235ef1669f4a9be47584e660aad559086c319f703132fe1d5e2225bb3f1136f1949fafc8db17fbf289a6ce0ca1254aac8e433b8d1f87ebf49e13da71aaf47f349a92294da8e6c6d9be6e315f6ed9bbaaf1939135105aa489fc48d7394e36e6788c99516cdf2c62ddc484abfb597cd5ea668732dd7790fc9ee394bf080d98094a81703910303bf1115782fca147949310ca506b354870f16bfadee4d37b87eb9ea48a5b50f318f619c24be217cce8df293490c4b02dc56a0d2e4ac7314600822cb8bac259a2815f6dbef673827db74cf1bcbe4fea1344db757cf4178f737c73dc9cd4cae54f1bd3edb04243b0c6785ab2e9057ccfcfece6e7f8a49289db917a160c1bb580e2376c58792900853cf1d4b7186e022e8a36c418c94ff3f0e92aaf96690b5e15059dd59caf33b5d3548a9eca0a664c73c0523c121cba007970f596599bf86e19bc2200aa73b314e7c7d878d5c510725b994f3d2d899787b7528bcfaed6da9a79486f016dc4f426470beda900993196e576e84fc76b0a936c7601421625065dd75fb97e3a21d46f4d82ea905d7c6eb081dd842f1b889508b474f8127ddcbede6eb93da2ea5fd953b2d9982654e2d5f13795969308abf6ed30e8f7b73908c8791d41a02e0b7fcf364b413dcb0e3c4fb7886166c7265216a7a58945cfba1deb35311a6751faa34a55c864c3f0fdd0c04b37d822c6dc12e1f25d17980f82948c4325b80df106a605f274778e6b15c4bdebcd293f7a720b435702f54a37b6cd49913e6cea3a1300112f8c9f5097dea807b864978d96b739431e3c18fca5a9aa4225817efa855f548ff0a7124b38db394bf7f3a720296a7ab35aa7c0f25070c0b04af1fdc2e9a376e01ecbc15a57e3dd2223df4a606b9d67244292c3ed267f67e61e1a1911a989257f7c9a711b61ba2181425b4335162dc44b939ab2083f4425a7b9a0769f7bd64dbb6ae8710f09796b0dc72707d078804dce10dfa344633824355c5342a8cd27756f26b451f6afe3231e088e0fb3431e23a47253230c402047019002bbd686fae3166470d0d9d0864953305f60aa09f2912803dda4966770162b6270408a14b7d1f6a4f0e180dfaf405ed9687b705364330f2fb808107d15c0c7270dc49a28e61b76219e509d0c008f17f39bd831a285e2189dc2a2cb48baa4c78a885a94007e27f0ae1e23b91ffeb91f9fdac77e2d42fde6c44ac8b5e588a5ba19ad8fcf28e4054f9928f129003bd77c04634310e41c1adedf8eca19dbe22cda5ac691600e1e4dae92bdbcff0cc3e5bd86637f82ce2a96a3dfafe4b6d6e4ccd9bad257618f5d24ff1d68220d54287c9c49254ae684657ead7359dcf7a6ad8a9dc6abc681c304ca83d918b14502dd7bb7aee6033c0a45c258d7fd0d4d9e5d1ce85edec56a5e1dcfad503b84ed83a84cb46e14396ac8f139eff6ef82a04bf994d2d6de20388db762e4f7db71ae49e770b12223752ceb401569648d91df88bbda5dcf002c1e3cda37e9e9b01ca20fb5d390d7bfca5c2b1e2e8a3551b63083d3017853b841d927c61f6663cad333b1c20e3a12034c7f51b84d272ceb8bff5f36f4dfc36243fde0a9255ed3eafc1a6b1aa4355bbcc983b01c0d76549a36995fbe75de2b3eff8a4fedbfc9bfb17f9974d243664c9b639e09718b968c88f12549013f20e31014ed5dd56f4795cc67c9e66d7665767a01216b4dc32b211e3bad2e3729a13996a044cb93c3162a64f008039b8ca5c922aefccb731d36fca531be087190cf7f129ebadc6690afc88466b7a53e72c85dbcc1cc807a1aed398603b4c9f814d4bb3de7f65438e03484e496e7795ebe423159b73b5cf1d9f8eabefaad94db8e978e9fffb049d03b7de83a46441b0f9704c7dc4f5a46424e2da42126f06d774ddcb42f6fa9b8ab15a1c68a8c671d739be75c43c85d42d8be4aeaa1ffcd485d2b509f406b1a33c9285c493bc12df13de74d5010dd0f7b642fab9b3d9d2c99da25077bcebf04736e7898112fa000b1f09afcd3c4f85b506ceba87fc7e2d9e7cfb7a1ccb94a11d8976ca2634abd8709f2ffc594a5315949418995a0b962c631949745c5f7e577c2671140dbb6f01ee5a3838343be0cf1d5559533d38266c20c2493dc56f9eb9e419b8589b3bd37ab8905793de7abcb1af48c7fceb66a85f8ddf1e6c12624f2f7c6a1b78e98c79ad853628edb00d31b63e813faea735c0b2cc3bad67b03296cd40f369dd0f8155ed3e53380b2ee258ca3eae623ad2bd0feffa582ca93e66d138da536ce1ec94431f6ee2080a25def716c7524954de5dad86b59c44b15d0ce16ca9c2a8f22f51e8ba5ac8df9abff0c8b3c38a0e0c15cc2987d8d88b4a1a39d8ccf783699fc15e210105db05d224726bcbf61f03c6a6daa62436a50e3d81bfb5429f96f53ecd0914c9e98d16b2fc01ee739ae79084003e9e866e871ebf107f9fe6d8a85bd80b8eef2ec6b38d1b87e6541328ff2dc638ede0f513f902148f9c0a19236c719de1ba4708224170e147e94c17d508a29769fecb42b2b8ba5601ed05c9cf87933dbbfef438f508c127a119cdc7788981113ec711246bb4a0d46d66086b392a3eca71f12c8132d045266ee99addcc1dd918fc6bc2a52472afcb84e6434d6e49f8efd7f67a29bf364a5adbaed1a974276713f82a0afc75b1635076d974e44850c1a6761a074969b3ddca519c246ef568f819517435fb44010d04ba758f73c49e2724d1af803fa72f82c74fa3e92bd9e20405fe24e6ec7953293659bc427f78fd97c3b9f973eff33ca0d89cd3652ee8447536f482e93df2db6df53e0c7eed5d6ae7d3e823af38db1aa01428a258cf53be23e705c80e98d42c4000b78f62441a107766664db566233ca59536adee8d1ce9256383f8d1d885d445b66db96b99e304478a21b1263446db0c5a868c3e7ce9f98f4e7e065b5511ab4d8970aedea22c7cd5fb44c88713d924274b979696cd527ca9c2405b33e9859efc1d063d33db2ce39decc617727eaf372ab38b35219f0c78ba81cee6ad1e16110a5cffe6661fb504070c498e86f6a29ae1166954537b1caa35ecf13faaa49d06f211d4b9a8ade8c4b9f0bb11da4fbdf08d75992b0d12c1dca819bef6b3a948f5073e93643e0e6ebd9e246de28cb7bcb54ae9d7a6cff9e4e95720e485dfdf2533397f8aa63c2d08d3a994a5a876911783579de551027416380be564fe98fe4e516e95dbfb51633858dc66b26a64b09a81d4ea4ff37df0111fc28a6d6ffe947aa1c076fd3677f719aa62890cb45b074ac6598d2016268e87684c765734ec35a63627b92044ac64ffb4a41822b4b766de716e625c5e232ebdf41c9ae5ce018bd91fdb93d6c4aa783d4becc2398fc308acfb655cb7dd906ed79a3695d2f17d4533d8440ab7055b296ef44c713c4a4dd22f2766f75fb23b24b03b0e82c43133734c182d25a586691d48e5bcf1f9ec49fa2abb834f8b93619bf3ab7b9aeaeaf9e4baf1bb134261eda4890dd583eb00b6b787d6eddb46cffd343eedfe23e0cf0cf15bf3e9dc53a480d09f982a3b1dc290b8322624812a02ca8b6808cf1284122e34d3cb3afbfdec17c5d44511ea26133cd9f2f9e69916c469c0327187d51dbd731da1c728fcacd945928b6c2e0600a9743e7521140f21c6bc4af3d5b7b42bd454ee8573cb7a87032ee54bf8720abcb08a761bd1996e2df2e0dff1b1eb0e8406b9587918614c5b1cc79edba7ac268fa4c4eedcdc27ff0e31f2b4cc160d25e251477d7e6a92d3408d88954fdeddf41ca570ba01e129dfab076e36f17dfe6622541e40fca25158f9a722a492569899f5bf110adc2a73498b2b37ae7e954a58ea2ead570ee0b73bd087f764ee2ec8230037806f002d9a782c8a26074e025d6785fd82fd18593b78ba5c55c87bfc12a7688408ceff68ccfd9423ac2d55fa31fded33dbd9d00cb19ef8a85bda6fcf0ae6d224b93bb94799d1308edc844a53b15a37587b97b08704c14aa282b56e470158e1e1662c8c72611098c5818bbb9021b382603aa99b57f4a597f6551c7fd54719f2d6ac7b1522609e44eec6a4bdfc85b3329f90c1ba4ce0449bb09ecd2124ab9e5a0cc091df7ec64064f13ed8c57adf81eb74d4d819e33f61a43570b04f68880c01f9d054272d93ed2c46afcd40261773b4ad8d95c9d31c51f670c7656111acf2a166acc9d80b587a8c6ca163f7ed7244945230b19cc041b8b8d869bfe46e32dd4424cd57bf26a834ac09c296fcfafe3551a40c69e485416a8b794025bac7232d61d4905eb1d079dd7e2a01f7b57c8e5fd1fd13d72dc0378562351b191c6d06420907e27ab78b52800e03f22e31fd5ab01dd54558276107260596bc0f4b367d7e44244c6e649566f24add931c15392d7e64c45239faf5999a138839e557994c9b05e5554fffb109566a3cff1c7d73109031cb10505c14a0eb4283b8e98bf03349ff87210723f61e99d74152856a779ad94ca6392065c4a88a76ed5ebbad8d3fea7cbeeba61ddb10db223e16ece865a256c882e8ad0f66a0c2ccd3c4ffa374b61b0cbcd8707af7fe03ee0ec2201cbf96e740bd60a971066b40c8bb0375f49a744cb28a3d67c2c22471c87490d7eae605f21db6534893386da8e561da95d097ef82218b7e097a2dded51250337f07d34c26f7a97a73d3fd002addabd4fdd60a072387444db3d9516389958d199daf0871e4fada20cf869151348e4dccf0cd9969330c0b11c0487d62207590633a53b5ad871b51ebdf94752216b02d002066fa854ab23d3c43918e70da9c539cc0dff3136f1611e1142e91fc4761ff521de7f3349de17ec6df8591691953a6ffddc84b708d36cd9c79e913b8f02869280c0c966748d5dfd34efbcec44364fc121f0ae4e204cf30707e31ba22bf87927de0a246eb1efc2518b5b54fb545a70e54b803ba41de67dac14aeec7f4e546d9ba0c7e162bb4f0e30f6dbafa04904c656ba154ef6b51e89f0d986ad5673a85f8a65d738c2217ce57d458e1172a6c6ad1f1bc57a447ec7a2d6ce2ec06b59fb492bc875b6303b4916d0e0038f34010a4edc949dc15eef5f5212376f515ba54718091c0f29373306b59eda22ca48a1f15f292564f32966580f44a5c0ad5a09cccd3ca1a98a7d232de8bd4f87c691b4f44d6618356d77d618c1ca2ec0c991fae3795f24632c2b0fa01fe88a580d69ab4d4616c0d63db58e4123929074fa99ef38d9aaf724a2b77407fd1adb4b818128423338468579fcd7e69c8e85536fa6139a668f24c24cbe989b84ee50701d3239cbb4f884a01ba0a664253c8c101ff68466eed03e48f77e25c1d3da75124a32300238a67bfb433562c1f9e2f54e8785558d684196bd52cfa8a385b36d58af365dde019b156f77a502d39da640657ebfa5d71cf3010824996b53c62cfe7d7f68e8648f3a2ba4e019363055fb191972e3368eb53b8ed28a3a10110c3a79f76a7363e1a11acc2d8794f824f4b5b0227b2d403114e645b4dd3daf9d75c3b3f473e184dbb184fb0566616b0619ad5a6e40144fd5b27d9670eecabc932217394f0ffea4c3269b86e62c792fb86ebc8a00313f7a575ca543e6bea6ebf2cd0606e4605c91e7cbc1e32f68c311d11577c313b14b4a73c97bcf64a217bbecc55b66b449b1f331fbdbeb074a338bcdb6d39e74e3b0a28270d7cee0bac125942eabdc463017b60619d5709a6b0763e02dfe98822d6981b7674a212368d7ddbd2d50b14373bd10471eb6b2fb6a94d21fc7d673b1a09003ea768440e807327431b12ab68e25f7ce03ad32e4b80d73c417c78aab1a117e452953e537569ddd11e312405f857703917f07ceba286f5beb4601574a708908dbc6388f316e7a0b9ac142f91f0658bd8bb073e26897e50accb6d40dddb79761103d38c26149505f3769ec93386e3a0494a1394aa11eb39aa22cad0d4e76425b89d4c3355ae683c7d6ba4ab6b8d0675b3c91750b6e5b9ed2d9db6e0dcc2c298e6be487659c102a6c75730c09e15c502e18c7d5903a2f9cdc4521356689fe98908606f95f4add9ebb92d2afe3b8b6008afd6288112f9c1d0ee05e7c4d80cc37ac08390a4617e80c4a874a7a70d20456f4364c82a3840300392f8fa58a421c5c6eedb7f3e1e6cb4a31a83ad7b58f4c336e0372bdcceefa328011210fd008bba69bcb086d5232d5cc6647fda69c24bd9e773d37f09f2f82bf5dd3d103c773862ad421d4c2765b82747fb17fb77589887930cf6bdb6854e62692f389aec7165d47beddf6238806dbf4bc51fbca74e7137fbad4a1925a72e35ab6b70f18269081f3c61439935f7636947fe9ec9be6923c0e679089747ff48e2de253f09bdcc16f89cd7b0575ef5541f1c887d73113de9934b7aa5f0eadab623d4fe0986d5d07c34da742d739bdc6e7e27f9c3ec9a2165c916911d6e48d978bc4e33fc123dfa69f073eb8a6fbeae7d214cb9aafeaabdfe45ed6830ad6360d16391a7ab97b16f64d49bf3843286a0f0e6c4258528ea6281c8fd72a0fd2f7401723471bad40f5a00e89562710c73d2f30911495989ba1ac9929f0ba4ef25e0eb32384da6fe0157ec313964c15ce999c120f5c8de46a83be7213299f987423409131c557362671993c9be80164fd6c2b5cc6d702e624effe47f7df7b0fbdea747b5e801ca1a1a2f401b7349fbec8c895498f1eed90cb5209f255cd0d27f22d6c7b56078946e820890335610df3257cedf78c0d05e3f9c1bc88e094a0dad65d291595e55accde5f60f9863585af03caed14a9de2e942a75169d152c0fa4d1940bb3cf8ad6df7fd21f2362b13333ed418fc45a0d1679189fcafa5132b1dd2c7951bac1f3102b5bafb115a3434e7f5483cefebeafa3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
