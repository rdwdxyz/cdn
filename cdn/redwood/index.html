<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f20340b272b40c51df987f3f94b61a6df6d0cabb06aa789f9f1e35cb5cdb90b07b465a4ed6c56ef1da7e6da99fbe4c457fde109249b652c2ab24bd0f332215bf4e2427cfe8027235a0998c06c556d8d870c87a3c656d5e838d6b313f530575ab89c5e4817c6950aa085d124f004c3cecc6179797c81cdc0c2f6d5e383c4fd1479152815382f732285a709d75d4072ad71c8ca8859ad3cf53dbfc14569efc2867780914fb07115cad0e2a679b04feb031d2e68a1d4dd1b2b2c9d2f7a2042691ec4e0069fb154a98378152ec95b30f0bd947943d025c0389d09440edf1829cfeb1564666811dc77206559eeec6511eaf599b3e710547265a66e5634901908d9ea8d3cdcc731c23310f1435e6ab3e35ef4ac9858611d4bd4194631c4f255c6c1614f1745c85bf08e84240229b552d910d9903e1efb9e881b73f934ae961e1f996a142e94665ce4a31feff7fe2fc9038ce232326f36073deaff8830b6bbe93d53347a3e354ea979120183889fb2613e2ab7fe4d5bd41d03c93c6ea18750e15c3c0cfaa9616d64dd019609f352f37e3e4d09b3e444bf55e15f21742b63d56e9266d4cab93ceb6298d9e51f147f27581d720c2ec5d8482fd6e9652da22497ef50bcd6aaf514c8cdce0c5acbad1e6d3d62e42c44134f78423aff6a71e9351bf8133caa5911c4ecb3c9c1f352367f116af0cfdc2fdbebe5aec3d02a5749a11395554a2e227a703033105e4608c6b17f0fe7a1ebb3910cf6103c562213f81cac430034b761d790e07537c012ccdc1d99ce8ad5e02c703c0072ccb2d544b56916b98c1cc7adb53a04e1b20f00eb1beb0c1293a1c8af4a05ae8ce0d074e39e6f5e9a213ac9b0e4cf4dc22d6306876e6af13556d91f782348ed3672fff64bbeeb7ad32e0db224127fdd77d983c416911b606670339eb2cfb80e0d97b58c46933fbe31fd2f2fca28e4abc39404a3b1662b2bcc979ad9c587f74917b4f85d923c004ee06230991ebda51dc64f5d3b7f4f94d21f19e8d3a5743f501f2c682059457a6d3db238c0254592c1bb5151bd203d45a0714a88e1c282f894cdd370027c7a9a0b579c98385b917f66ef27c13002dad41a535f709e54ef0544846d17625ed31f7dc915d75be808614fd91ac45025ff946d7bd86f87623e939eb4a5a0f7e4db32e3d067d13c6563931d5e0997e4a7f17248f0a8999e46dbb5c0614edd4f6f8d8b1f2a8faf9d03eaae7ef44d1325b6358ef796799a99947dc85e7703c19d070e026a3a5c208d1dc2093fa0e351a1379d626d052064798158bb4db2087b230fceaf752812f7040987747e03f28a87a831279d7473470906e5d3218104248f654596df26ca38462ea594c3323f08361bf93da7a3bb4f14c6ab25e8b3b848b5c2097357d1af9c472f78d5324b44a90cfc05f09462cd59055db16e4db9008828f60100e9fc2ccfe2bae645c9bcd94b262d0c8a7f4e6e660d03467e6817543b3dc99003ff7c800f45931bc5fcc3b866284f32451fbeffab770d4c7ac51e079cac2f43c9e51d65bd04adf99c964433192bed2c45d61de7d7615a1c4c29ce8adc9973e0a5cd3f246f4a0e74fe3611425a8aede6e63b829342ab2f72db28366857d306c9581790afe073c9cb0e700b787d28e5be94764cea4d715bf0db5d206ddc5e80ae2fd0f8f8f8283368d3671a513ffbb4b90f3ef034af9fbee26a1c103c8708cac7fd4eb4a535acf41fd313b10bb7e447bd233565b0f2386fb550fdd43ab7f4b1001d205e5f10457566026ec57586d824ce025af569e7a25e5cbd495a3439e95b97245d61af77b04e6693d556da14cc765e708bf653045abce1a38b04b1a871102ec492b200604dc9895186b826221986185d647f95f6aa3632fb30438ebd86746c4c6d0cb6483350a1c98c8ccdd0cd345056da22550df32d695e25367f60c88590839eecdbb720daae4e659118331be55fd71e8224f57046e2d4c7af62e52f5a8d69afeee7628be4505a22bf89186980ce39a1306aebdd7677c5264a9481a1a6f9804adfb935c49432cc487ef73da3dea3845a994ea8dffb52ec76ee2af879a8a65ff7bb387808cb9d8f8721dff2e5906a7eabccf3bb3709d5735cb3e70163aa8d700bab008be3dd6e8a26da176a114baf515955247f7ee72a2252bc50323278586ca62ec4e0f2e1d201b38fdab0cca359e111ff2c199768ecb380afbac8d922d2df6941767fe05994f0d5a526dc311864cb0b06970dae02ba4b90c807b8ed3827977b93b8a6e863630ed63e978f5cb39ec36b9e213bd92cd2dbffc5ed17eaa1d8f501041a4a81df230b965fe34797d3cead2d2aba890b29b6d88935b21df77fd569b1116e18fc4ce3521977af5412d06c0703414b148dc8aa197be98bb96fc330ee530dda8253b4143aae7513dc687e369d38d96bc67c1173dafe15bbcb91294cd98822e0f32b6e69ff2c83408902c67a0f7ce3fb90590c4e5edd31c62a57a0f1f1f0c2903d533b46fa1ed940479bb52f4cfd750421f4c7814ce7a3e4f0267c78f21509b4ce188b53a319ffff38c64d1d58962a4116d274e37435d0533b6ee3d2b1cefef03ba865711f7829c805af77b0159ba83fcb71e6427e5ef9ba9661a80fe1989278d63b25d425adfe5a934581b93a2eccbb20997c832322e73c8c5412255cda001dfba48faf912c567e1e7aecd066d9733c6674f8eb2ec3065601a0c3a120e4eaffdfe8ad6dbcff08780b5df05bdcb544dc4b9a407e7101379efe8ef0c13b1ffa6a59fadaf96b55f293af8824477a8b7f9aa1f89ca3258e310c48d3cc81462ddb1247747c50b351b613024d71952426b317b66e6cf3747cd10f33636c0d15dd1310cd877b25cc201e00e604449aa9578e61ceae7662ea1d640f610c83dbff448f7b664f995854852994ec770bf769142e7961f6e91860e0133fd43d179d3406aaf9541bbdec259c7b3896aec863fd8e5077ad114f3d966bf39fad15511ed7faf06b207ba0df04b4ff7bf4c13431285d4d3fc357350b52aada623d86b1ae46342db4609242c8d8c2e2421bd828be37d352448e24ffbd3481d63e6d46eda72b5995a61a6dcc56647961a41e4dc307448912ae629e6690440ac774ee7a4c42eebed0fb7f5c6b396a8f594bc7ba568bdfed0465a5b5bf7115aa7496eb0d317c03306d02dbfe42e3a5dbc0b61bb4e15cb1dfbc6c48e0305b15abb26bf5c487fc83729987e30fda40c60ad4f3133fada5dd127c2799a3853ce8187c95962e28bcaa3dcbcd8118de00a4d2072f97a3432b43dca4fe6bcf72877d1f6f791a430a003bac2b84eeea8478ee204934ae79ffbb98055444a95c8e441e95ca1ea0a2182952af45fc973356bfdfc57fdb745fe278bc834fa7faea2150657b4b3dbd91ec03cdacbe63079d7ab97836ce88f776c1415e74ec270ff06ded4177cc181ccb4b7257e0e66ad049cf5fdbe80b689e21155ec80dfda0665d63ce969e1183fa8fd67d6ea5993a6c6b9d908a1e3d72c03012d9cd47ee9d0894c1765ab157b55647ea43f71629f7593dcdd2cbc9a5c955aea2c8dfec68ca3abdbd86e5b3e582c65c1b125fa50542a149bc4bab7fa5f903d0c89f202c84be62dcab4c2424f02d944c14536c637c960abe79d4c10b1afe72bcd81633803737b0c3f5cfa8e44f8e8558be3a6fcecac09aa6e43d8030e6eeeedd9d07ce28756c3c6930ad5db00e94635a2d75f134feab541283ca01679735c5adeebad98ce077a12f82de813593d929d2bf136270a488816f4b65346bd137cf3f19078d990b2ebc180e768d221e8e22f8b95ba029b221bf6bb16bf49b7ab093f15c795ae1478d8662db88725a1ae2b921251920cc2ad8b3cb8a71039cbc7d043ab085fba6f0279bd5b6ca399f551f223045683526d03e4f21d012c0b59c40f0f0b37af625c6ac5d62f7d6eba4e4cf2a59c704dbddadf750831421a11a8de820a0418fe75010f9e7a55e71c3affeb359ec9e086b9d9d2031e4b85a3bc3642083763b15461cce330dd18b6eaddb0396ad77b58cb7df27ea0a3f0086a80e69f0fa8197563b3a91b9e42fee9902b4f63d1c216d8b2deb9edcdfe2134da359135c2be88bd0e14907f93cb0e2b12a262133bbb8264843ccab14615695843eaf7b1841e5e89e1892898bec7b4d934f05664398c94867ebd2c0d4192c5dff3fa18a82f7414ce53a10f01448f2ba2e2c76567e7a5a527424f2939d60453a25c875cbcb834df12bf04c8b91690507e23bc4733fe5439d5c783dcd9ada1b895b6e32ade84eb786a47826ba6274d66896698c12fc8492236a8c95025e982da4d12d3fbe6f04f71785177cfc076bca708870a2e86d048db959523c5e2a7b0165a1c321cc3a9285bd3489ad69062acae29a27299cd5dd3a8b32501bdfa77680532311cf4be3f39c68ba2e7ce433ea5cebee53efaf2787e4d27c25129fdf541bf9bed813d15f571554e0691fe508c078fdcb22648374e2cdcfb06b925c52f3eecef47b1e7974cf0cbac0ff2c766422be191f5630022dbfb92687b66412f9969b7a2e70fad7774301bd87d165ed7b6bc66469bb06cbbb5716feeb924c2c5771581af4107a8e854efca8e96c5364d3923a03f9d9254aa8e6b447538e31591b0969a9dd9e7faf82a44e83af737e1869e5e70b8a13a0e39183720e16765a49ac3bd5b2054140093093150d192de36421154d70450a5f924dbd464795cf44a89e2fbdbe314c007565820b881e87c5b0d6aaec500a300ee7fdabf53f8bdcf59d2d0eb53576e76bb5a809c86e065953795a85d9b0137b9e27a3bdd34cc922da5cd87320c1f615b42cce0d6f60792c4a1e00b6d3c623983c0bbe65765cda5fec5c946269dd536a3be4879428b951d8acb1076f83ca7bdedb43ff98517ff8816885f7521bb4751ecad372e5df6fb8ef3ef9d0676284fb8e15145e75a0221ce6a45cff92b1e8d21f6e4e84829b3d536bf6eaac509eee6ba35df73cc996063a50c4fcfc6b730157a7e854c841d60d2d0823a867fde78372d75dba4cfda87232b2ebb90332ac8461991137c9571b1f0a0e0ef6ce1badf3d7118ddf41ff7938cdca42636c616759d1cf6c7134e57fbd9754fcaec41e1b1a21a22a29ca4c0763db91b9e2e4a2a9e7dd19bf91cdcc0f7fcfc6f55522cb8558b13b9c24db662e347972b0849cef413fb3eac6368852093dd2a29f9cb6ef0f2eddbe145a211e10540653de36d5d041038f0acca72be8e255609c33d791c281c0c89a9774cc336943c918dc67cdf57ac1b9fafb58e72c83770e613237a1b8cb46247cbac21489c1682026f6121ebfbf568d579b6f1600812b77d8f4d82fa9c97e763ee82b0e375775f9189e02c03b4a501e3245778b6b4ad4336c9ddf591690b50b250cb51d0f169d79b83394bc4bfc59b362cd11cabbddfed449c4e6b5a06cd074c2d498400041677292fe71dac04b7bedd34e3ce4c9fd93002cc9f8fb0f5fc7c1dab992a6a78c1bd567c12e010362462e48969b1d10e7b54bac117767be14648f6ef415a65f65ad8272d3c8f29aee050228f9b295725ee31bbc219783bc7b4ae40dd20bd959d1426be4c3a937ef1588926f4661e02181c65140b42ea7fddc13e07a9b567f92241ccfda7c1e001d6dfa02fe5057d6261e3550b0e23040ce13defd1cbaff9f30fc1395c89a7f9c3ce8bd67e89f64e69843a72b2b7dc96eef425f1fe772d257c3000663819b82cf48ec2bef84d422f495980f39e4d9f902c40701f7e5fc9e424ba1fae7823e1f5bb7d9be9e6245b57425ad7522ee93bd6fee0493e7a8c95a2df94f1ab4912f884f1191eb86f18a5ececf4bf9e79eb9f6e9c0d003406d002f5b3942e95d67342b6929c8752b545e5689ae5a7616f4e118cad1cca951afe8bc1d99030c9f39f530396f55efa7f53f88be381e74f3102da54967f2fd69e9c87eb2177c311dac8780bda1d0b37b06246cb8493a99e4dfb33ce63ac107475fb1117d7cf8702a6ea9cf89684a5d4769988bda941795203b20c9fb4bff617217ff35b3bd8258e8e9d4457719067a87c0ffef4ed66c18dbf4fc3ced980c67733960fbf536f469579ca509474d204c35c0f79718b90e09e112baee363eaa06ed7dd476255e651cd5f1990161ca70ddfe869a24a436e0d2aeeae960ab6ca28c020e327f52d33b29f38d28c9d2eaae00b6880ac45743724410bde9be6b3fa96776daf366455daec0dd5b0ae857d61b24acb7ac15802ed41f42bed74985692f92b1cbeec8cb67312cdcdc2e98f8d81d619262d02800da727806dfe0b97d59c999e75e81f0511ee58e5076dcea59f534ab9bd3f04f12fe5c2c849bba562570f692ed2dae0b8a0f53794d6e35fdcec4da2ff990e4141bcbbb400b11a4d57bc2b8589c110561cc7a359f1e24738867df5e621eac9d29831381fbc59ad81a338eafe5058c3a3b7c1fc2be7c7b255475f88b13743a4551ab029838670f2e4113a18578f4e0cfe6f6397f1aaa35e3364eb4b03b65ea89a4d60aac6bf69fa2adebe44ced583b2ff3686e8b8d84f0b6923d8576be204dca9f1c13c24d9c8a43d2f591b44e5490dea5346718f2b74d3045e1d50ecd060b2d5305af752bd5ba604dec1c13117938742b12c89afde2c8c9a84505707fa6c95ecac41fbcaff39dad6725db9ccf35feba82674da09bbe8111c87fc5f01c99120ab7ebd38dce5339294311e453d6557b0018976ffdaa01d8c8608af320c3e5d6d3a93ee1a2d73ee13e81e61427ebb5e2da7b7cf6a3bc80ae52fae48ba7516867f804eacfe6359ab4c43a5fd532109039a036f8c57e61487e44606f602b59a809a53c4d2920f05fdbf2fc652def2926f1216ae756945c619ce253d42eeb9ef6c0701151cb2fc7b7d62e7f37f54c51355ab37f709c582e6d604c2a8f53d3d511f0b68df43a08062e5017319ea3531c364ff8f74244654a95168bd239c2f25fb885c73a9794e05765deec323a78a722135414b205cd64bb33913447fd3ef8a6e89b6da56ca524efc02c55b410e4a5443c02bc624a25dead0b6cab087d26cb51b5d7489a5de6d93712113aa929268ab79a6a92e57dee9d158a8f289133c1d9ecd7ae77eae10e982d3bb667b535d4c0e6eb41d8b28c96660813f18a61631d7908779689eaed2d5a125d69074b8dbc722499ea7c29b7755b471f5417be8d0dd6f09afc9235fe31c1d51642f5a08440e10b0ad7c1c072c83b882fceeb57d6f9063fd9db629ebb39ae75bce4556e4fbafd881722504f2a739b3a500226a00f9ebd713afd8b725965da1b1adfe89afb039a0054926a99e3620dd6556b5964a19251ae5112b23ccedb901af4940b1e2ebbe87326ad7e068458c6b8c9464caa14be633a9bb647f8d1bd4d3b0f014d502a2cac42b2f0fa2befaa449bd9b126cf2ab9531b00335dfbe2f6cbc971baf176025667c740724f89660386554a6d390a95b60f7562c616c2af57e3572995f0118d49db8a8319360f4f1840c702f557ab0803a7a03a56ba559dc9be42b3d36c10c0234b0b2ff8b172d3994c66608e4b1c7c31574830a28d55936ef98e25d37126bdd1f1cf3cabf6fa43a4dad64d470df83929c90cf1503562fa145379f2008adab3a411a5ac4e22d1aa9036e583fc4cbd9ff2a971a962355ee2f3dc595332265e2f047e3448f6d966ac0b5d82dee8be27231e52859a5ee6122c10caa0d8f75270077ac338bf8e517784054833690fe9db47cb0cde56c0b1676138976dd00c937cf9465f6844709c0ed4838ca8febd0e8c8bec30c309713c6d2b300a1aa0dce9aa09118d6d7973749d658f6c8e13e94b6284e899417751bf14d8e1907c6594081a7010b0baeb989869945d43dbe19eb321dbcd54c3f791857d1ae9fdd7de22191cf2b35014abc4a11890b7cf7f112031a82ce5fda9172965d653566391308482522c6f74969516217fcda587a1933dd0255fc13ffd313fa82d5a6b4a5516fa870d81dace3f2bf9dd06e1b1e66c97776c4718665193862b093802ce0e8d10fc9b548dff512813cc2d1b904470b9c62d582c4359c3a94badb94890cc8f9c31dece8a26c14a1accc74d546542755f12adaaca84f96b48e743600f9fcb26d9e19039f14b876cee243b3458a2280ff195fb4d5a2b7b721224dc00f0606695955d34a8f7a1600651897d7dc3b5e706054dedbb257248ccd68daf6370b16a136143f5e00c975317445efbb7335c19442405131dcc0e1643b81a5b605db257c4243a55190705ee61209b545df8e7ac64bc21c00864c591b9581219e5a361e852ae812bbddba15e1c0529a5e006069dd44e608921f54d39efb7f12eb3ada30dc35a6bdb28b733b6f831d7382b018f549b379ea36e8e86d27ea7cb71b3b454fff72221ed18703e974aebd05d576d1a73cb6627748662599bce62ef62a71ff231ee38aa4413255e74b4844ee91927af388ee6ba69703925c9d0649d578000a24544ceedbec13e7116837524c07ec043b7ef8adf16bdaff9c35ee049c193b733063f7d7dfb49a4c4e5ad2d3c883f0293ad86145708ebf84e6e178e33eb77c252c8b8f0decbf9d58a99e8e319a56164c166fcf82beb15107f5bd8feec8410aa0129c93f1798d8b1e79507ab0dc6cf817b7e39532cae3106a12885c4d5ff52da4beea7df5b531b1d531254cf0efef57517bdad3f1044eb23a43fc8e7011beb4a4affb7f26731094e733d31407e40e02de37f3624926ad7434943637bb41f8d61f8d43e7907ad2fadcf019394d65db1cca3b4eed1a86068708ca78f599cddf25530e326bc33814d79efb0f1465cb2910065044828e1dd954de5750e1e4507ef99738aa3e90eb825012ecff59867ce9291512162e74213ad7f77f421c5f5dfc355fe30d79b2f4caac6d065b017fe88e89c73a73c48fa6f1683cdeaef2530fc78d7628a7a4e81f8f037a9ec0a4a91dc4f4d1f8fa3763f7f9fc8223155eb00d40b7e46998fe4f51192b50f957859a5c2d513918a1fcca71890219754339634d4fb1941b58701225ce69edd0b0b5f9e5a9b2e277002f5459281ea6adf1b8dfc15a3de9729d0c06b1c5d2fae385dc031bd647ed7e807e64a26515dbe7e2112cb4fb0e67b5a6a6e4426d83c3a48984f9e20acc874b256c04094d96e15020a27feac6deeb45ab7e1975ce1727f6a92a176200efa074e866c9d38c425fecec4053e816ede8cd4054a2add0ccb96965f950c391410fa8153dd4c803a82ce7de41b930bb942bc0029877a0b6c7bc65f2fa3d75cd930fb50356dde1e200332ac78fac11044db4fc712066f4a543b522ad9c27d54f81088081f5fc0d31a2aa43f40286953e33e16058c81732d3f004e4693581f1cfc9fc289915268adeb5c5dbc319b3b36e86b30358e492e408ca7ef74f2843f4ed63f5f5cbadf9a59a039d78b27e8338ddf87c19fc0dacc64f37eaa83c90e1f191ec86989faf47e071978c623e18ebc0c33d9c3f11ad9129368c2b092c4e3f056de1d9074b9ca67b9eb64e9a3009f8234a65403d33c88425f2a987865e8863f74b6a6babc73fc7656db23672139175a3031714966ed149159bb1c8d4d73de4a5daabc90877d6ecd80af43fdfa4379c783c6097ef71d60d235a814c16a96ae4c31c87c74723db482af02273a37c21f2527385d5e72cac6c0dd8e6657a6d8294d960a082c4f8e8b8e4cf8dcca006d680a7548e27c615b9bcbaaa4f20d9a962191000a42b2e8c46d3326fb544ee1cfe88b0a695ff31ebd0d45167d56c31443e8e1dbc62036b6025d9f54acd7bf6a196d517986bf5e2fd22c8c0d28d397fe86ab189ddf26560c9a50ae463a6099053df25384d8011cfc8c43d695bf97a1a5bd85736159934608c9af7e8df80075a2823a70e8ecf9f74fa5641c695a12d45e68c85cb51ff59ab5e8a1767e0883d804bc8b0fe881dc252c942e0d392ecbab7a2b65eb182502e259008f45c29775c6520086c5f769da2fcac7f53858cd6a806d3d964e5941250f7fd23e5cd749823145872d6e93a9435a07c39454ac287be1704abafc88b7e31bd44980a90ed684f7a095eab340707857963ba0ca75f878d368f74501cf9e2223c0135b4e99f348549a508f3b3c703b0945b3c9ca30f2f9d7058574fbb952fb2f904b87e607392fb4a803c23877c3606fc974030cd4c8b448513cdcab513482cb49d9e11a38e879ae22936b7019dedbab12eba66203559cc90e44f0bbfd1b57bc6f9bd03816037214d7f6b281d4cd2897d62c37939a17262eabe3dd17079028fcf7bec6d92aff2aeb73730a5e094eb35ed9f625bfab9d9e3f160bb46a929748f5eeecde09a68c978cc1814e71e9d3be0d47469c166451d7aa0913dbac5ce5495f628d5f26eadc9f9c38b31e7592f57e59511711d633ca372f3bb26f27c30cde69f8cf03dcfe645bdc2411dfb5bbf20c8c964d85ea4dc36d1bfa379f2431e13526ebc4b6e5e4ea9fa7c65caf1bdbfa28f2f2c57cdcbc1079336cf75ff781ffefc089c16dda3a125867d0eab94df95773174a46714bbdc2adeebdb8bff3c2b34cb9ad5a02472d4a2007d6df336e3a5dba28535ded747bf555d4370695e773f73c76a1100c7cb8370dc224e0ad00d6dc831967a63bb92186bbd424831c9b40010528bc155a38ad9d66e53023045b009310db2b23ca65ed7d220ecab9bcd59e7c4a1fc1942fda57c9e04667d60a1d2267081bb58630bf4c79f049b0199f35a5a5d0a246e0f2e5332ea591756c04f6bbd0f94c2a2389e1caad912074812929c04bc20de28972db414bd0ca7660fedbf7d4b0e8a66cd2505e34aaf87382e1e7088b21b78ebccba46e23fac230ed49753c1d2d1e459de2dea40602ab01c17483cb62516dadf0aa8a6b653dc3c2a0ed5d26a152a217018677e5cbfb4a80aaaa37eca379db6c5eb5ebf2884b6f092fb48e41c4e8d611fee3706b84993600ea383b9721685b54a80e94c01a7563c1c826688add0c32a975a198f3987d3a670e1ea4c9492ba1278c77f154fcfaba791b417fdb59d27a09a90e53d861efc77c63c2c07becd90590e8ebac326192a381d1aea8ceb70d839471e13add6eb654774278d330663c28e28e0fb64483cdc5045c6234cbd13631cb8b8968ac5e89f72b116932a5241f146e85a890c725886e729a11c3f70233181321340e5993f6f2d95d96b3a2e63df3a3401b29c193a22457853e879a6234273a6c2392808ba170617c1731c0df624e6c304baa382fa6ddff8fcbb80955645f3a0f854a4216abef0a2f97b32227cf52294bda75acd9b3beb4b4a374b9502059927a5d126a1bb7286943ef9e7f7ed2f00feb4527f03c651696cf5204dcf62217b904bd58b76745328fdc732e947881001a44ec6e45b7d9f07735b18566d8ac112ca3fc7210c962bf3df194231181bbc7274af6b1832e2c6e807896db3362a7a9d5e70b3b48d49b2cdc5542363cc11f863c3a1512b98aa9e843ff6e63f903d5455afe02e810d1bb1bb7420f406de341753abb6909a8001c76b589c2fc3920165fe52b0f815a6df3d6700f58267d16f294366811b5785b34f485ef156cd90ff7ab56c857ddd895ab74685803c6dbb520f4f56f1a5f47411229f4ff379a1fef020926e1c52415acff6f6331a3898f9853750c6c4856a2a1384d260b46490a4686e5f51ac6f6c12c518edf06e6e7267f3010b6faed6e5109ee6da0172abb455d07b6164cd98961c38389fa6309b24d15a46f53181ad4dde4000eab3d44d3e3e772776618f136a42d08e8190b62c6c46523d4682c267133b54e8af6a888501f74674b4f0772beb588f2fdd349a23eb112870425d93c94d150604c509bfb857acb84d1343fd84e976ecb35bf331abc40250adccb429b9552f4489f37d6cc900c22bbd00e97be6d654a4ce2536a5ba957989041a27961bf68bb9d99be2a9b9a35e1946b8868115dc419e073d5e8f0f81978f5bf2b507e543cb061f6f3171b1110f4a2a534bb16c3574cbbbb7b0b125509f1b5d29bf6fff2e7b6920072c766605c017c3a815a8736e5882bdd0135847edbb747c7e2ef18e26d11d7ef0f85a9ddb0ce055275019f41f8b6fe65d03aa1782938c4aedfd0d84d86c023a05308e46da89cc9d927bb286a0cba76c193cac614f0b8ea2d57d58c9c1e9022e1ffaad59bdb6f5eaba4a54a3e1ff42e513d611debd1581fc27e88ec00fcb1be2a13153b7a1e39205ead8c58630145c0b34a3e1d36ffeb97855dacd24f3777b4d54d056674e144f56a3f6bafb515eff5dab9b2a857512bdba3b27c2d76cf56ffdb02b79e1a2155a02ff91abfab794c1758cc273d8b00280e75902e3a1cd1eeacb3216d2a869b1e2adf016378426d1cd70a79e764e8abc36f330e62985647c1922622e2e38caedd9c9346df241321b676ac140bc2237650bb8d1d91d0c207914a7a08531f93cda6fac6f5c36709254df87adb294e00eda2cd339005602d578c2f94593d2b1ae02b4e043e8acff78bb5f9ee16e908b5330014841f87c4781e0298cd8dcd71dc385f2b1679650a716506fbf300b764809bea636d8dfbca1b1ff4d28bd812c481707a2981560e2c3670b28b4833ee8871b3779c122a39757ed9f9f9fd01ad2fd989a3ce061b8d046148d5976fe9165bdb060916e95cd09ca560c637fad6f64f194289ef626f4d82b32e8abd78dcf23387319d12930f12de99157a8f04ab90f6e3063123edae084e0bc1f2c3f410ab6ff6318c2b20f523541d2c47f02b724e996c73b674024e8c8e324de55fe9dd1599686dcb6253eb432d475a3d3855698a8ab73eb98176e1f6656d2f2ff004168f88e37b3c2235f4041f95cde0a7d8eb8c96f31bb7c45b7de3cbc91157b1a3dc5ce58e83b7e762da3df521112e483da885566707467b2db5491476e6e10b3ec441592d8db006bba1a702db427e0338e0d378b4327e089b136104996edf32404942c62a24116511d49277f39ddc4c01cd580522481fb0399e14742380969358b43a1cba278f168f434c242e1e3fe38af361a5c5b9daa11973c059839b83224170a468ca95276d39ff4dfaf8c90f1e3365f4f83bb8572f03a92c574c05547c5e468771de789153580b330667bbaa6ad846ecc69be19e34d530618bb115fdf5b5ab168dc4518bce834a835486131b9e120e90cbebd356ca23c53c375d0e345c90702469eca6278e57b73e6a811217e98b85ea9951c26c931b49793a30dee059b59b5b1f8dd6251cec6b7ee59a5acb7bbf100321b9592133f1ac043a1aa90b5bf5c73c15858b269b343ed7a39988d7fcab5a3ba7174d78f56c65f9275ad6907db6a006ca651d8c15ea2d41392d0d5fb202bc1483d7a999c1df388b3450c3c24c2c83adfb865dc202fabbef4a79790af96b387720713a47cb00c3fb3df40c3ee74668e9db6d12cc7a0fb57ca0641f1ef74db18977213560afb73bc6d429e6320f132cdbaac04adcfaed2261e0d5fd15af5ccd52b96d9392249e344c20b56f6af24be19af6efedad08ade5baba8cbd76192d6ac3ac1c5a7455b3a1cb29a963b0e79739be42ee6f9b597d724c9ff664e33b4d4295dd20a1174467cfc728b0b0968f1c0f781d8299465ff639c02beea8a15c773080d441e549b320acdd7e0cdaeddc4b8cdcbfc1953dcb613df5bf6f7bced5082981d74bead424ea9f56e6dc6679c0b927e93ae4f75632cf9037ef07fed2242d3bec2ff726f3db67d18d41b796180114368741bcd4a52a400b5757bb2efe0f7f44567a68a36c0e9a14a9722020f066485d03c0bc379151ff24b1540e0e6396d4dafb8d06a7a9994bb614dc59cba8eace1c431e908917687a8c55e27c0f77b983dfeeafeb66de20e9b83bc7e158fd7f5bd646dbfa6beddfe0f2dacd2cc22f302fa0734e67fa9e586c812c3a9e6ef904bef19a2e9b5e40bf622ec1ff7e88fa69bca5e9dda49776f09e625762b896f735d7cd1697816a1b92dab76fccfba69510c9cc731619fd7619ed1c5933b4fe6821b87bc818c81071a15f3ee82bca9c8a3961fc261f270bb7c83bcccb9902d6b139d8a24e856747d4785e960b260efdf3a6ac152b065c1e0b19e321b62abf8737a127fb476f6bbb315d5f0daae634182a9dea8eff72e212b0ab954c467c43b31254c2d1628b0f09bb0831f59a388bcafba5299b7394750c26f8f891889c4b359bb89c35654dec612ed0aaa06c4d6e4becb941d74c6c5617963e2730fa2a389c0c78aa809385c98aaef2b825b68e7b52f662509205e4b74988e75cacf6dd90fc9e625d8f793904d0ac132dda5b96f15348836d54118a3396fb7c9b650a091cce4daf7bd4255c08abfa35f57f5624308d9433856404ed507fe1d5623ba0a2e929343bf2c5db4d7d08051b874485d7bbee304cd874a415f8828b0a835b59348a30a25eb18ad9cb6a56f793353542b3f701ecf834880f7a0c792e7473c7b26a6f8ff62ec46436d2917ffcd25c599db5d2b165f1d063489601f5f4d1507882ee9116d3dda8998f7e1ef83362ec63880f13287765707ec3650e330937c6676276063d96ef6d25031a893dd6f49016a07de865c0db35a85da2ce37b8b2d0944e07ed6d018fdfc7ca10f7f854826dcdacb680e53bc5eafeaa28cf670bc0a7fc45b7d7f5cff4f62d1f2d4f87482f5890457197f22dcc699632c1a589561d682dbe6ada7cbfffde133695902ec9e3a5b980702ac9311b5b3ba39ade0563e4d9077b89b334f7b9eea8c3e729bf84c2ba0794aa83a3d525ed0eb3212912e6515fd624a7504c7fa798f216f0549b5b3b5a55c28d090939b0c110607b0cf639c581d67bcadb4949a00ceb25c6d3576643f171fababd6dbb6eea542c2d05b9ed2a7c9c945643a7a603b65a7d127761b5c681e4b5c418a44f7c1b750f7205e50621c674e72aa66495c874de716da85c6c2ff952b65ea5765fe7c3b24e491438da995006f88fc67e72d9f64f6c8bfe3d73956ec574d94911af607aa6707c8ca41aaf77f2631df8a7079d3bbecb1b3cee82950d2a90c15879d540eabb075d2e63604daead5130fd22661c9defacbefb6245928ae17f2d5caed55ffa46151c76f40ebeb65bad3fca21c63a6fd3ae9a86d8d5d9db81e1dd7c4b8c7c417ceaec79baaf412fc19fa9ca058a15a0a4b9a53ae3ba2a715140c60d2a28019abd704b4f1a5798ec55a37134f57c0c8537279991b05eb975d3d15cd530e1d8ee7e61c6cd395a6238ae94284dc00dfbe3e4c79e416af21586597026b4b714925eccfadaaf73108fec171f8114dd63076a2e967034284d64b8728763482500dbda92b4fcb134b1213bc95736de938e07d261e9df5b44561197a480c5355b21691d692c33fb5284d39bef8d5e4c58e35f119e967b0187d688ca91979a9a325ac6afabcf625136cdeffc6b9deda21f05848da16f7d8be9164461ef1aa511a3a1e9e3eeb2a8071b998697a943323c06d593accaf43709b000ed51cc03dbf720f2654b851dc54426dd86f34294d3cf6f951b4ad29c9712792c1ee54537d8a085a762c97a9c66ebacece902897ea7be428270e854381267065778fe559cfe2ec8495084c035d5027e9f5e781bb0495a0847d997a2edf181f6dd133dffacdbbeadcab78a352df22fff4da76fb7f05bda8617c8b02b7fe7b1cd96c921cbe37665433d39b8be94b872a20888e383b998754eab133c1e076ebdbfc251c4bd389565772af6971b3ce5afcabb6d133ade52e53b2b3f12a25d61dcb2fe52b78a386c150b28628c1d553e3ca8a60d55831381c8121e840b0309db4436ee31702823a580afca356da409767665a17ad1cdf6075fb14dbb1ab87cb901fe964774b0feb2239fe42b63d8fdd3eed7e41502835c230adf293a7ca068d1f203f3c389f1772ee1c26c91ba20cd6719a008c70e21d74c8d9e5128e5e08fe2034e8d3db6b9609ca5abf1fe5445090204b0ad42276224fdb8f7c870ec901a280812aa8448237d9f013cee1245cf3e6b6f264285f52e90b59b188c85ba57b1d140ca2c14d2588b88afaf4efb8fd98083e2db62559188d7391610f06f27eb60c0209409b10a4f620d09c8901c4d19b91f1a70750618975a085ac5286bee192da851272717dbc5ce3ae588af51b958cb9a1513061a1047f0db08b57b18982d33b3b1d4f00b02297bdd96ef246603964d90960b1e135607d3e0fbd29730964cd4a4908e468c37659b95a29655731cdbc02b1b5a196ecb8791d66b1e9aa09a8358dce4760ce2d9c518745c3e6ffde6515fc0b03159fbf95835dcf0b04e58cacfcd4f53f676f544bb6f6fc0cfe3a2315c1a805a11f1f01f1255ca91cc17d10b3e0cc0aee93af608067c3a7bf77bffeeeb058e6d4a5f836ecda4744e34b67bec65fc71743646e239b09bf26b76a92dccc07d15018090fd14bdfb25b3a5a9d465a30beefcbeb912e9e96c0f71a5a664c885fe2f90d2301ccc5fd4995826748f791b7088d1e929ae6bb691008bdee56448a1a842d605446e3ab915b0b2c95aa90de2e767c6171de886e89857113b59e252b01efab7fc819310f96bbe51735bd1f5dc9449f53a8c0dc6e40681de7a1f294591f90ed1f8c7b01f891fc34326041c72b2897f6ccdb16f915883753265e5303d84d1c3b6d7e3d5c1be5903c1a461c0212a217556fd44c4a473fa4d4969e5eb91debdb6face2ff00c435a5dcafe5e76aa4f1cee7b485a6ce1e1ead38f57843a1fe7304cae6a8165d027363bcaa6081f51f7c54d7c0c03d4402266ed8e1dbe418284590e34e74f4d4720f1cb8c7b3ba4ca1946ce4c652af6895f30eea29b48090c3db92dc7eb92467626d5827e487117c226a27871bc5432ccd9e5a5daeab64011f46310682c0448f5e6bb4200753dba4e89376ebb859c2a677cc75f0d65e5ad4dfa22de5201518f186d8e33de5cc671c351b42b65e14da24b4317fbe503f92f474350b7f93172847ad0301dcc6e0ca4a931ca9a3850d7285c21cf7a9c666bba66668b5ed71d35e481c54371c8fb4090c1d61eaf5fe4249524e5ae5155f210ce8216bbb4b0ff3dc330e6ce39e5bfae659d87236d40321f0a60e0ff7850cc87d6d041ca472694280131e1149773de15f48bb9abac563a9fb2c7eaa6ee604921c04f4d4364e3de4a6bb7afb483c8f04d0540210ee7ed8bf0a349c42bcdb455487cc4066da11c82fab680e7fd7e7734b78aa39a4a4d977b9326116d17622093fc1373bb14b2303937b080fc02e289ba2f06f9f4bfe2b65c1c248e987c066179d4608ad9f4456a7f8e9dfe9a8463c7a9ddf61cbd776154f539ce934953b422b83e3928ef81086bf01ebfbee42ab8af913e67b0663504e007873e5ccd0be7e70e2b0ece7cbeddb309dd9a18184e235d77661d46446b3e40caad187b7de991208df06a20ef003a6cda78212222a6e39c1dd3015750856c2fcbaef53327c754cf4f938b86853263892b447cb6da0c68a278dbaf18add6cea1fc8b0021af91b83ef28693d4236a71db90b54bd6c5a0817fc2483953c80c72746e7b90e6b6c72e67f8a45f41eef24510fef83c715f351f093195e8f3d5aa6275d5176ad903ef1c099cc29004efce55c77387581b5689f963bf3d2f080b98483b7d532fd4ecc47d4bb6e797ee6f47023622a0eb275d0e2597507454602c65cfbeb831b2e5830a17b838ebdb6e07c05198a3e4baae1bf68f868819571e04355dedcbbd23bf1346ab111e81ea51cc38ba131a0cdde9d14c83e61c6edf74a46ab3e9e62a07af338d69dd87a0c15a1f282f0804b4ffc562ec817ca886e57b59577149279aef5200b3c42094e36aa4d2656d919d407487955bb9463b3c093584c40d38b9567762ae5ae30660939fa56c8f1a79e590f8859ed2b5822cfe4717a70a0700dfc1eb178a896a3293b0de9ec9dc9eb071fc4ef48c436aa8258114f8715adc209edfdc2fcc7285d82a23bcb9f9d437c90b7fba45ab095353bfc74fb0de64f37ac120c446827b26a415e61acad0e84ebf4bb2a03b86178c9e4a551cae415f3d7ad00e3dbabf47471fbb161b4252181d85f99ea6a0c52ba54d481f71fd77a03ed25e58a5ba0c10a76468152e4cf063be4d19d2005cabfd6141e6fc9cb466d9644bf2423564730061e42faca657ad29a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
