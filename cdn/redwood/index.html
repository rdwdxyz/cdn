<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8f69762c8f18bb44376b89529dfa200b7b5718484546ca92a2f81ace9e7bea5867829466aafd983241019c2b308befbd61a90fdff7903e3cb2e1de02c3a11f536a2f8d29fce290459336062cb61d759f40d6d342ccd2431613f06041097c21bb50aee3f48f3208bf970a0786fbf536342bf9d4e4d0d52185b7ce12a3ff6a1d6b513b07b70ff4da3ee494efced8ab1c22090db1e688335899a283ade3ea26f2ac6f8ec088f22b42a49f502c8ea512b44d26b747e975ff746ebebd970b1b4210b55da78e996d208b1a4b49cfbc23ee09e25ed133f90ef4b0f7a4dd9fa5c7cc33c81a79d8ebe9266d9fa43c78a41edcf08a79340af02f8cdcd2208e7aa166eab95a04f4c1e525786d3fdfed208d436971fc191fa9d1b92b3395f37af8873f7b9c8408e1ac719dc5640b8f8e353ba5fea30e5d78c3e66db2d2c974c12d5269f2447b82e9c70eedf3113fa3d6764045302d5cef31aaf296d7ba873b4de492032a5f5effe62ad0ad6b0ddce079e0ac840391373a15527f69b24f28358000fe705d41ebc5fd021e89a42d019ccc1fa20b12e0c013b959c6644bf1da6a30aefc6e0807bad9d6b7925f921b001ad748217a4b1c1abc952c2d6fec8cf10f2ef5d53356edf8d4e26ad64f4d4154774d35cc3548f387b4c356e420ae884e0caca9aa04695963dcba67f4907d6ce26e8b4e1c2ca34043acd5f037f4b695b3908a1ef860840c6f8d4319f9214819cab73f15f803d36dd7778af6e0e20d8ef4218aa172ac9ca941bf529ee0c688cd0feeb4ae81e3e05c73c44534ad523ae873110abc059e0fabb3c0f6e8ce515aecf8d3e19474b7295279fe10d36c7af5a8c8eee55355288f18eccc2725c409075cfb56fd59cc36a30bdc69490c75736020e58b9f5f241ff49e57ab973c073f61797985f81a096ef6900354c3105d3a2ef9de26aee169ba999e93b5a8666e0121d99da9a1d6e49f29b7d5e2d9c10edfd82f675d21aac7eb43a949515c896d267a1e90810e3422cf1836d5e44ec7219b764554a696ea0d19fcf343d828fde054e0487cf9381c0d6b4d18adcf197ec21987f1bf0f17f2b07ff88d9b6a395de4eb7f92a0edf88b4219e5dc67039a6fade6632d143d1188364d4edfeb2e4b8baa1f4542043902cea11b04fa59d9229dd964abc8e9c2a9402cdef57d93e4cfda4b7d6d6241c5407e43bf9ce62f32ecc1812f1d77851e7f6e6e2d8bc813294a53de9233fdd5c5c5eaad343c6a16643b503d3b2bb0e75c92b5a3679623d2dac297dba9b0262f98efe57f410eba7b580aa5ba48182ce7a3ba2075b37cdde9e5cfb8bcf8c08d02182389d712ca3f0c5baccd45eb44145fb32fc558384ea9ac2e5570a6fba18c02b36e3a6eb20cb742dda3f1bc674de159e6ea13917ed49332f1a9276cb07236ef91a0a29012e480f77048d7cab0826001b7efeefeafc818d761d524d1c2d153c6da779de0629c554c54b784c2a7f33f928453a7ffccfa24a5bc032687b8af2a8f9c693d38ed5bc400e23c6403461017fc6d482095c9f077a89b15e18d4de6c33adf4014b3924b50810e3590ed94e1be3acf32e50956b0c9f750aea59dc0b24c0d5294baea4560be0d14c245680d2974714ffb300aa69df296f70a7ec049c974eb1624d27c5fcb765d8d9d8cb5c5909a24ed8daf9e759e6dde0807a0d9293835db8ae702af9fb8f780f5a8903d811fa47fd49f5b341925782d64e09223c4d5b0c7acaa591863b1cdc3d906b52a8072047640824fa642d021cb656651a642ac57e2192eb10969301733d2b571620aecac762a3225dd4ab6a121a96379c447efac620f582ddb544e44440aa10dbdf9c7bdc14a14ed7f936267edc18674b8d6dd8b2cb0e734cc73c1ab7d468a44acff62f96da6211721e0c8796bd12454a4d75761eef5fd5b5afed8614a13e2301e4383e5823d998d4d46c639b2b55960a020c2644be9d6419cfe119285759c45e2a9f47f608a7497fbccac6fadd7ebeda62296d943fe028beeee5b0c011b4c0b3bbc81ceccadd0aff4bfe2441acf6dc1f2cdc870a17cd0a90c64cbe9c14bb33f20f37ebdaa43c8fc7496db40a5ec23842cabefae9743f0294f3e2957af7d0b7f548a7073ef709ed3f0b03095a457547dc90e0f7f839bf943707224723880da7a19e5683523319b08bb10f649f371b3ea30969a26c30e67892e6bc54f5d0236d4801852da74098325c57636a651db988b5db10deedb8b66a443ac02b2ff3ac90e548798ff344646f55535d126140b23823127a0d232a9aaf4525db641095207d04e2cc02e421171baa7fdb6e145563e98c5c94e8be4de185a24ec2aa96e2ddbb0b151dfc53924bb7d7d2245aad00e3fd6838ee99be4a567dd1952e8072bb38898cb19c2a28ec8daaebf031db80453a1ad193262120d15daf8358a441a7b0710bf39e819390791186399c67b40ec7f7b755b64dc765b5debd05cb9374415c88095c02b3a9e64b01b03b210f089ac5771ed7a0dc39610372bb2e79b68f5889cb0e1573bab738d6017c6f259e39cc5faf17a320d091325c31a55492aca20138d98edb289121ed85261449af9ac94f56837697d1e5e24d95095e5af927d5e1da350ab9a8544de4acc5878811efe4d958075feccf75d2e4e7d81ba4364a19252a5e5e4fc1a83afb2f0e1296c0e8c9522f6087647b369b094e412a317d11fbe2885dde3266b6ebff1f95ee6bb6ebc812c0ed5adcfad4a6008885f7948be7096408c4b9500d47e8b258193258047b76cd835a062b20b7a613bfc8958a23c7c506771e5ee5e261632f79785b77743270c1c7abf641e110b11a7bc5492452ccbdabb6f70dce41ef5675e57ad30f5b05006892f0fc9e3ad09b87409ee10fef8447f8d38c05f6debc70613297b93610bae1c163f624f5b32e52ee8eaeadc2b4ab6860d4594a6abac022c8a7bf353b28beb005496c908020aab41be162ae1bb4a931ae1770748a5ff9a15b6690c9d4b7355d84b0fff6d45baf201bbdabe23b6f87777c660b035a07af58b0b58e58888c24b192f4c5d1733ebc801323f96dd197ca406db93d2769dec52217208cd4eb6b49f289bf0422be478b3af465a16696e9e219c53262eb7a04f3ca6971786aa2d378b61c34103be0b38d752dcc58e6fb8c5ddf6c23df0a8c8a59f28c69f9d9cdf7d0f5cafc7a18708f6547f57f1d479b114c0f2794231cba594ff10b60166800c4789da0d5baf62b496379299b6bd77e12331d66a0380f2cac66337eee482fc83f7bca5fefd164f55d48d3c5b33fceaae1f5d8782483363ef58e9f665ef0c11aed3a05e56e82607339c7b2e69ee094af7394a27173bb8c9685f13945840ee60cd53a600edf099220afd2a96e35ce416e71439de74089b3ced7b5f743a9f76c436ac3bc498b30421a8f4558c158a6e70ca25bc52c973de65c44ad2a89e2701a5bb2996ba14e4c517df4574e6b465a2def231088dc01aec34ebcb75ec5950995f2b637f1368fbc5d1c760ad3b536a61633aa3eeeabc5944e12513441c5bc7595b15b80ae5a15205e903d88260090594c023875268c1e0f169928a752fdffcb7e52f1b79e01e42198ddfe8a2a3484c0ddc78c4f1553ea4c23321a760a962eb8f81792424e14bf92c54acea37c4506fd2fb735e58784855a8f963defb1a37984f6ac28357840d021bbb78093f09ccb251bed3ae8327b6302af6aaa6998e537122229afeb32622511c7f4078ab913e7724051146c07690a5ba58287f53e1336d6943f0642af4d70fcb49479e1fc8ff679b62396f0628e6af4d9fef69342e18387021c68ae9b1eaa85dbfd467ce19f53a181604ed4808272d33e55805403ff5b7c379e141065e19b1eccc059210e1bbcde04733bd4ca50f41a453d6a4d72c2cb89a4b8929abb45bd7ff24941bc7b62e2bb420e3e6703a2fa996a545eed56451f35b2877143f1f074df81a7f2010821eaa0b452f27560af57e1722bff7822099a15a7ed235dae4f06ad33ee315ef397eaf6ddbde660d3c801d707e692fc2eea2771213d1c4710b4f56b073723b5d78c16ec06e697aa4a0f91f996849a82a1937708c1b4e0b18a0a7c02391b389fd1d67dcf503c2725ea5f30b2b9bb526d206710c2bc51442accf5ff328ab7f7dd687197a42e14c13bd0761ba41fcf1252502e5e70b9a50c3e92528fe95c85d9ed55f9f84f2288420189a02bf9960f1dc7edafe7e85250bfa4897da3c58b957df0d26250fedc0e37671621686ab14005a70ceb20d9905924debd5c524df2f435bee88a8dee9289ed0afa8b93ff85a12c9babfd2acc43c69cc0c9684510e374655b8e837ce0c0f9532460f1502628efc1a1185d51d079713915be459ccf2f7ddef0885ebf0485e2faaa21ef1b2a369ad90226d20427f7f85e62adc375dc26b086a7a116577501bfb3b3651688dc829dfc4c182cdec414a646ff0669740f71edc0b0c03da6b6a165a4877b2a798065608dfe3c4cd537fee76cba6fa8901e196bd9b1e2f998f96b709894b80c0dd119bdd3efeafbf716fea3754306ae64b1c4a4c30c14e96c03cbbe7a9f20c2d301df76ebb2067b7fe99955eff1c9596e028999d0b867b0028609426f3bf1fbd7a7eac74edd3e8b4c91b3743e158d11c4fd28dd6f53afc74364cd8da7dc05747aa2519c209aa7352e724d9ecaaf866f3fe75c1d2cb922ade24843d1aa5e70049858b2eda75854c6f1ad14cd30c2da63d1cae972fef4f63145caacb06535745bc866d1a43bf0af694854f09b2b4b9d65a537c0faa4d5d2703b901bb9b83fb02bbb64bee33a8eb38817432b7d58cb9ee34058003725e2933786b2701568a0d060c40bfc0ecbad40963ce7586abc63f33079459916fb21f1eb39f144190e72d223282c8dc4db33ca082956931c4f00b2215b15ad14356d1656511527526731b7bd0669562853c1b2d9f61c05fe4d7eed17a9b2eb0f141851df7898e03b686d9ada7316111fbea69046ae212ca57bb49a8509f002e9f99c7e9e9375a0ece499d43ad8207d5ea011fb59d47abc30e1a12baa61540b3f554340396b30e5e6ef83d69631a47a8972eb516cb7bcfffd50edc96d91c1575ef628fcc7cd85a52b7719fb75586a0c9a37d5126ce513bfb2e1722950f68e7f7b6710474d403cae202fae6517d13603d9a65935dc7785b25cb6bf28358b4b69ef9e6f542fa5763458beec61d47ce32451496362f127780af4389181d8e8fdb8956d2ec0acdfde531393d9c6aaf79969f6538ad75914825582527582f23c163366d14a392a5348efff2846cd2e37651b3891d84d6a72f08e15a49f4761bf88351c9508c8d49386b71d9a11dff27df40888e16c241418eef60b905dbf15a93f95cd74ed51dfdb6aa595a9d81012e16db25b1fae5682c268396101d67dfda430fd3967be506915674f27cb7cafcab4d55ec8e816e6439c5608013df3ce71854cf01c6f21c9c46e757f5012fb2b06f5558edd26019c1cac7a7ccb1e829bdf2ce17626c5fb0d1940e0f8e234b5a7a4babbfe33cd4bf5a7e23246aa61a3c83e50368579c394dc2e2353e5810d5c5de9febf711613d72a05ec0d42055c56457b2744531ca970b47b4e5a24e93515bd71478d986961cec7dd4de2c3ee357430aa669ec5fc4fb7112cd2d90dc9683b0237709fbd57bd81104d9e99e21f652994541357861360cab403a081c6010c564194437d3ffb5ceed70154db9edf2bf420dd2d15e21fe53cac810a29c236a3443c80610a936e41bbb4c4cd866c3b96d37476775024a4ac74d56b45a432384b79fe1e6372025653eaa32b6efa5fdcd564d86871d30a166ff3f08266b6f8b731a4715a03625ae7bc7a4aab5c3b6e0d76e0e495cebf802b36e2ff06569ddc7d87188a2f59695e5cdca325424a44c34a6c73874cd0d5ad331193ba9ffee43a77994d95dbc469c2d49022adc98772d47a72db828e47eba0b3172a234a32a366fe0a5251aa7ad46bdadd253f82b91d4490132dbc584e41266bfc8e526ea043b54cc5e9f63f18bba6a8ec4e098b352f3b9bed0c70a206494384fbacccec3b98bb9f0d6decfb3589ef138e9db1d088aac525a1d50dae01d7b1c532abf63d8ce1f628898d75513b12606c84ac1ac1dc5f35207bf4902c1531efac1d30cd810a4c248152033c200f733acdde0c6d1de294e2af933cac17ecde14b4638dfd28c51740806af49f26e8e5168b6d8210d50f4ffdc2a8a64dfb69a488019ee7a2785504d3f5d8c430918110773707e7a644c69e11731e46026f6150bde4c714ea4c2e559437149fc40279d11a7f88ca5a56338520ad9586a9d9886f77d2c0a892f16633d9a50167a476d57ddc800fcf9f137f873e99c61198cf26d25d7ec589fd303a1d49cef0c2d6ab32e1957ecc2a67ad9636dacac6df319fd64f798f403c0bcfedc2b84e23c4a077816a940a5765e81f410d046dcda1639bcb54eae7c18b284fe83e8651eff0464c7909756ebf5f3b870ced4fff48cbf072fdf6c05be33c840162c9db6be9c54f23ce29fd7c511b59783bce2886f9da640b9e40f34e0b6ded50884063fd0032f6d9831d81f490b832ae1b0f1744b6b209908ce02b3336498c35add1a37493476f3979cf0d5ecc9aa6191431f2db9a03818507f1e6b4668f112106cffebc96b69ebcba4cee63e85bd0e56f824a52026de18144abb8ff0531b5a48fd76417fb3a49de2bba9ae949c7f941c612a1ff3dcfcc7ecdd6191cf5529dc2d3283bce832b034b52151899bf66bd64be3225ec6e5bef8c01e9a35e0928b803f84cf5adba19126332a194a1cf48d8fd7e6a2ae91efd7f775b99023b6fb88bbf31d02046f4df612476dd97f5344e4a26c1c639b3fdcd0c90073217c650aa9e7f812bdac90ca9b9f9428b6d801e530d759fc261261a3adb454ec471269da8b46a0751afc6675f3e4b671184aedf08776dde23c8d48715c5fb66b9ae006681310feae0d29d33069dee9f1689933d215595ffd3d0bcdc9db29a128e8995e03cb5598edcbe66aee1b03007f3a226da03d84c6ea50ecfbb6b65da5fec12948fd85f7980bc6befcc19ebac2f31cca98d4c7e5ac04e9fbfa2a9d4963b41b3c76c505142b505e252ee26f6ef5885f444085473989b02ecb48346615fe8b52d83675ea66414018d48ecca131d9177e61c5c1372198e07ce8693e2a04eef7f931e45e19ce76413fe5a02281a0a8f3dfabf890bb4fbe2a1db9139c6a42a85cb8dd2d6fa8d7d3bfa4c2f77be5ef46478282033989b0f6e41f00a038af7919a99aa55415f67f5ab30752d4466d1f71e664d1b66ae2373c21f5e1c1de5f4e7ec20394c70cfb0a03c10f6edf453c3b9b7ff2f3dabb874d667276523a96f2f7a90bdf6c39a6f3e14ce7396264aeacd84212bf37f33d61de1c6d21ff5bebe1a20a00f40596b6c48fa5306ea15068dffcd7020bbf0355949606711852ff84a9432fa9475ccf76a3ef33bcdc3564e794d55e0d6f2c80395da1c2d056f13ca75f100c9ab739e954010fc91a0497caccc70eb94bd32ae951cf893bb4029c55df36131a81ffe2daf83fbfe69e1a7d72e21a0c783c067269479daf138eccb5a9f62544776d29d1e642c7e7a1fe970e1a5a7095ffc3353986b223463a401fc6f1e2c2d7e4103417ae094849622252aa397a17ff97aa96bfb8ca63f2a9fe0616fc2d450e35303c6a214e673b7836a256b2883b9469d3a06fa2e5c1a44ef3bdd1eebab5d34bd9cfff66eb9abb49ee10197d3654e4caf1a15650daccf5d3f93769fc136c3adf2db7f2214a4b93ef1cb82932c92ef373a76d36ddb078678e528be5707c44202c3e00b2982eac7b07354d07b8e9ef9da0d65d6a9b2c00c973cb15fc2af0e7c3b846fa6f285ca26a19ff3bd4730f0e569cd0478990b13790175f6c935b5b52da7309d8fb0f916de58738857e414f29353c729a622d22b065ba41224c856cea9d4a4bc58bab9bfb4d49f5763a71e93431b5d5e47c4031a9f1bdded8d3e304cab274a430c0e9c4d7f243b0db6dfc47394c98785a80bfc30ad5c669ae828f4e62b6d4b26127266fc1dd8b0d70b69f7fecb82d06cedc38856f90dd8deb9ed6125ab322edc5d3f5e5cf73b7c6e469247b7668432447b398235cb4fd52fcf9309dab60530702f62e425bb6c09bac9f53b278e0c7e72ddc0a32daae25ce11b4acc6487a86937db6e075bbb468c6e51aaecbd831e1913fe903adaf8e6abef1a579959eab57b8423bb18135da4a1527e28dc49708cbdb6f4d6adcc04c090b5d45a67769b95b25ab6d29e9f018815334678778242c7879455b6299ecb300220c11d52b38c15791f1cfdc8163488d174a5d152047c75e2e03f5a3d7def151d3e3d39a44b13782247d16497e50846aec54c7faf15ec4f7c4b5120febd9d4dd4dfe80427c1e5ea1f68f9dad2946c22e04eefd1606b816f9dee66cc878050f67ebc0141e43b126c61d41c7ee6cdf141279cccc4d5d809d8da395c834b56f26ab1c9614fcdea31d80841417067e4f19db537ab027b37adf53cb894fd45f08ff470df9b7fafa0f678e5e0d0418b5ab5a536c4ca4f88701c8be570b04074fdb3b9e8a66b19420df2f953e3210e9c4f2c27dca88a525df7395f67ca9f9437846b83deb6c1280694f31a73769f4bce7c2bb3b33b076defbe5d51a72be18ede14ddd11eee3e48af788426d69c9303c1222ff9b36118cecace9db95b3601dea44d7695fef9b0f6dc3ca60c76ed68942750104daf24df49309ec812265e6a7d80426237869da30d065dfe82f7d207501d6c4cfc0e8dbc795e219851455cbbea05a577c5e2609ab2cce248cd05b6a46cfee4a4f3c7c1e01c6eda9ee059ca0ec8a81a807e927f05a30ebaa7c2cf00806ff254b10daa52f03ff5c4ad33cecc6144d8b24c08d5494bfb8f3ac35fb52f7409dc35b92c7987ee8c2e0300486614cc90d70633149d5df04c19980579a03fdcb4550393a5e1565171a85fad8c27ba66b5335cc94875b3ae3c95af1a570da20ae31584aba0d2b8d525c3b2173aa768ec31444ca95e664bef0e3eb48ee18df2a7d856e987e39c29d67bc50e5b9ec83b7f279ca4d7315bf30c930f9c4dc696d62bf483dc6772d9298de8aea09688d5e1e14c15e7a1a2f7c0c3f49ad67cb72cf2d081443f7cd46df8642718f3b30bf5c9f3fdf51d3eb681de16a4915636b3b680ed08df3943ceaab30ea8fbc62e1ca1948344a29a88a102c181b3c4ebfe84c00d1c5bf53be82505137085528c34bac6d4ec08c5d8d34905bac748f020404c381f825591ad67c6d1842a1d287f3ffdd8de37526ddaa74e13645476c7f031607481283fc79be6148ac6da6f77ab48b4996b19bf847bfa846f5de5064aa5cefc0d24bc2f645407f2135171040672de525fd7e4ede33e76000490ec844388fa2ce6b50e690b746c8b158cf2f82cc9e9ee343e976c8a45226b1d947b149f0b06f0f9c4fe7444dbd2f602d0245623917845348eb460b706b3206bf6e2bb766a38b9e18c88d1ab21d679a3f0fa0037e05e80af4ef65e4d2d73bb4e56aa8685670d01913fa8c56296f03c4d9075f290b9c89e644ae83b271718ff9150d5e69bef2474ca260b87c31261f4052021dc90a4baf519003b054fbea4db80cd44580074ac36d6beba2bd89779ca6020d309b0f9c21bf2f20b3ddec1e9269f00f30dafcfb8661cb1cc08893652fc3fa4913d96664b3a55f5c00e0a07f5b62472c20be50deb9cdc86c60b5cff5db4ff5c974562da0fc39c89e677af7905c5ba9144bb765d01b35a4fc2c0e4366fd46769122aefea8314adde0dd9a9dda756f3c7a59c79d39c9d22c52fedf07cbd47fff6a748c7291de0075818d83e8414b9879f57b89e07f6ac959d8f4c84ba22b45fae0b78bb176ab1ea64ad3fe1e127f4bc50ae3d10b561d3c75616f6d1ad47b830b7b116645ad11d19d2945835281970dce52f53bbf9de33c7b2727b616b8cc2bfadc47ee052481f96082fcfbfe34d42ca3b47c19b2bb584ca8e5189ad18482fd51bd0d2487b41d241a938a042fe8a8ea641a4dddf874898ed1d797ad3e7fdca572c668e1b1b5eb1776aa856c4bfde863038a8ebfde80ac8f7fa7f4a164943a3b0bfd639510f8ad41345bda361a2977799fe146f4087ebd40133f9af67cfb7153c383d85bdd393aa4ce309c21d59552cf3eefa856df636f0e519b0aecc5ebf67d2f66ccacd63a25bc88548db4a386cdfd0118b6568a4c94af18900507cac191ec87fd2245041a124668df054307df86b02ce2e2200b9ae56c290c1f92d1be083ddebe029a124327aa50eef377d2e308e2743fedeece655a0067d8cd63d9129fed979395f2ea51d1b9ba4d9468bc7becab184e82d5729a036f3f9752941c15af9dcd7cefc5f7ae0e4e209e44431737c0e8fed488459b45567470180974f89ea5507336b61d592c0c1d907427381c1f4a259d0a91a8c11466ecf4e68232ddf134f1380c04759da951560d517063475a0700ba838ac5c054ac7ea56c1ed39e7dc50b5d290fbfd7cbd4522a983c648ce50a587d39e9065caa56d9b4cf0d44247c482681536bda5a071a6ca348252a3b8f7b5f44edf387aee515fc068637708bd11a45dd6870d3c86b0011b1be3d749c74866baaed4c2c701f0ac0ac52d083f0aaf6d89cbcb5224f8176e3db761d7652cc51c08dc2507190b636056a2ea79888507a1341ae79c91043c0d64e1418f8c87215fcbe8a439f64c7fbfc44180c544a74772289e5da94f9b4d54826fd2c8d786015d8201311a8c5146d26e452bca9a2e250709565e9b966e68b7d3352cb469f17c859dacf35c01d6a77bafbf4c55d4712b62f7b528d78f5862801b0d0bcba6f361bf3c21190bb607ee03737a0efd5d3ad20e3c40c36493e713b612ba53690cddf587c2fb2df63d16a7c8913be9dee6feb1d9260d42368e9aa0afe35ef26b470d0d656e1e48f153520f9f3fec6fa96ecedccc25b3c67bddb3e08a05f8d51cfbf2e75e6c5f0b38bc2be0aba4465cb496ad5af19efe842abb322a76b0380eca8dbbbd912c7c9ea4a487e1c49246d5b3def34b5af3b638602165b470f525c424d59763f5de78c78f36028f1a936d45b1d630cf35757ae3b9428cc4f33e7401e63a3cc7eff3eb8cb532978b9def41168cf5674f56d60e6fe1adc89171c3279faa2f6e3eb5bd7fc3538966f9388739b06d0404bb66baf2a89b141f441541a0120159f9e4d6988b63d0706e8f2572dc74e9d987c16446dfdac69cb665f82efc2644431cd78c56363365de5962c4b3d06eec97fd0ca10f500e7563cb4cca318ff39b32f23a74bc9cac36c303cef4816c847eff0d1b81aeec3280be5b33bb59b63d5c92c3a4faee2d626b6a7f01afae53996d5e329aecf0ebe70cfc07cfdb3e27da3c048fdc16833bd261085df9e2da91c6c9c0c20d92c29736557ff6134562e1379595c3c74d8c5d40aa4ca82f2ef1fa717b61f421ade5d691eb3eeb7032f2601f669c6f3d3385954f84fddfac7f1066db498eb401ed78f4bbb1ec4f9e98f3098d558b4193ef79ea787763aeb8359571e601521d59feea954418150a2bb4f91a34015e4caa8de3599736603b085f4d129c4867084b6af7d3fda4153a48ce3a6a91202d715bb37c751297fb58bb576dba4b703285f3cf41abde0a9804a90eea14fa477cc52049cbe93422128156dbc28238ff5ed54edf47991a0cd98a44dcc3bed08b461e2e62b203ebfc3793456271c6735a4cbc64f4e37d6985cdacb8ae54981a8d4f069fc5bfeef1ff9ef031bdfc6d67d5a2720fb6e9190ea5905f1a464c02939a6aab437c139a89cde8cc656e00fcb66d1bad4181bf1d765cca77067df6d568858cd4eb1ec3ef2cda66faed1d3bbaa365c03a1e18f276dd8107d1706e6ca941bbfba4423a80cfa28eee15382156047f6b637dfcc5207037ceb5aeb352ed0badfb5efdce53f2c9b45b653868222da61847baf704c7d3d110e837b4dd67acdb61c1c431c3ba95fe5adc919f58773d50c32ade4a53fce5193be3dc91d60788e161228f3d354b2c39c510dc447a208e7f600a14adde13253e26053254733dbaf01dbf5ee69dbe84b5f2e6043622923b5c46e5c9a8f0121f115493f16106e878ea7676c8357e3027df3cda613b3cc0da86e7d8d201462cc4accf2816891589ee8f5b5570f099e99064d96c1813fefd8fa0e61d3dd0c12ab9836862c2b3e76a068ccc118c914b3eacf5f0b88285fef9f12fc30ca9f697d19d0351269bd8dff4ae07ac7c850a15c7cae5b90ad414920ed29711ed2c7b92b21442a31432f69d98b2ba706be7fe6236048e8df1b0fd1fee034db00ec03c32abe7ac7bd0c16f5ab957cc8cfc1815a276340bc81dcf45a2b5a965ba51d227af72e9a7c40d20e9744bea2402178ba95c6b9ab7791201d7de945112f85824ca4d91e9aaa8d41b96681f381b87922068945c314c63e3401b63794042b1e2cf4f3616cc38692d4c4ef8f5db177e6940dc1367753cd3521dbb8162de0fccf81b45ed7ecbdf5dc4677b5c2c5180a95ffe3917d114b83c839b7238cfa7ab03a4097d8293408b2dca7ec8272bf068f63c7fc49934cea1381b05225e53bacb790ef9a3b2349eeb298a29a0f922cac081db811594432516e40380cf7fa0a54cf05e382c7ec8b409ef90accea25cb9354c21ce63afe15342b4a0ce94c203066f2b8469e9665be3bf82d533b6b1b67c298515f1608d00c33e637807ae57c7b250180832c53e973c4812b677e9fc16381c294e5eea3722464484a00fd4bfbce80515a1a22319c9a427ed94192b8de1ee339e81b0e889b669918504080bef66791100f27c996d1f78788ae01e02f29c2be4c05b7d60c553282e94cacc5dec38382d694fed80e4e876c45fe6b70d4ccf0e149b1c12d9ca99fdfb78737e0824d1ec4b480eb162055c09a0dbb9a9f3e5b5373947df2b1dcc3c39e91a93e0e55c74fecb1eff26fc6bee3e30b79048e0e4cb1f12721477f4af5e885d083bdbe0740b16e99d741912d346ad5eec37b03ad903772c9d12cb302d1b66ee5b3958a36a0b48fa125127fd578532f7af0d630994f3b91ffc9c0def308fa35a8e4b819752edd336040c0050076cf7d1a2dc0a43b812d2410c6f75e80465db2345f963864b58b142b0ca8e577ddd131724f164fc1dcc7ad7958750dfb2d5d9bbbf555817d86400db140e7259e6861563a2dd982a6ed2cbe1441ddde947b11b8e06c13dfb90d02d5e5b3e65525634897e8763bfe46e1cc5ba3613bc3101b1af33aa1ff9940a9d71f4181bfd84719e03e251b7be6eee9239316e0a42f5d514fb699af1d7fed7e893608ebcc1dfba835ae1aed217513d4b9615e25e9ed066ff9cc26a2a231fe5e637b9b7b7ef49030d55f89110ea3efdbdd032ee329841a6b85065c6bdb161026dbb2e529bf5119d10f43ab777d920d799f1cc453d742ad3b8758e6745ce109a77674d0bceb4c61dd0f5837f3a2fdb7baa7f41a767b2b6d9aa2daaffc2194f865412235d730a795699c983d0e32eff2695ea69b9a32e45e8b97c811c300369c8a022e94a4d29916771de917bcbd619417233a6d560c1c70ff9650a7d8b7fafeffd791924343d71b367673940f7a1d2a81d166b5e1ba4e1aca20e052ff9bf9637e4cb1f9f1d2d709007bbfb6b4df50509c44f0d386e4c835fe282c8317a439377748d355c3d64b9e8f74231df66f02e1a79529e835ce264848e3ea55ed7d5e42d1cc4f8b6258aaa0eef6691dee35675bdea00a289f3c414143b06cd3ac67c9accc16e60593c0e7dde2b0a0c5984b36e69ab8a45f953f600503aeb1a37af2f17b43ad2cb7dfc12148f6c7b4d45b5afa854a28331c7bcd5cf17bf0b9c053c9619cd21e3c0ae94c4f5fe502ff7431b66c9a85c7a114452db37589098b08407d91b85b03086f961533191decde7b2d9eac6130a2ec82e4063c057a23fac2c7f91f781895139e55649d2afdbb10dcd44de6349b1ba8b951f829ef376b49c7650960c0ad134f672991b1ff857ff0c59ee71caeec348e4d2e257e7b276ad95cecc46d7243cebed235012e76fdefbb604ffbb80f2645f409307756cc9de109173a19e2c248ba8687107e6a15809478379b0b0263fef90cbc761bc6004efc6766913857e5677fc73387779b6de1aa85d2ba24f2bcecf5913ee040a6ed9343520fe414db9b8611f5d80ba980d034a56d383af19ea503649ad9afbc9fc970d834f59806c4c829fdc9db734adbd8ac8208f015bc884de7c4aff36a1e43b29d58d0018376c41e8bd5e76ae0805ed07ade767c18774fb0da0646862fb88ebe264163a482d24d731db36e4d7aedeaa2de83771cffb149d8c5114f2b6e9af22de3b015a673df6effd0874143f55a282ebaf706b638c3eb758d3349e265d93457d40ee1761fe292623535631ced6d559b40dbcae426d7b28365aef48d5f3f23cd31b231b2d967765073edee66f9a4f862c4457babb67fa8e24b625216ef9e53e31e6117f5bce32dac9f3b0bbe6b73ef098416a9849ddb3140c68b6b8175744f899c488b3c167443ebb4de72797b9ee1d19db7a40633aa9a5b5d447919d054ee1f3e5d90727d4d739b97eba03d356a7ecf9fe8618d8803e9b40a6504e5c5c99291420e0e662cb51cb26dcab7e2cb01d17e79e66cb459c89a0ea72a41a44ebb1bd4f2c68d2c42d6c9d3942ee20a2a641069c34bd6324e576a33f9d2094a8a68ebbbe709c9348ef52d1834200c3b126270fa2e42bb320bb7d3f64b5812e9bad60f7fd67dd655e3e93e310a90c1300ff3e79e0d19aca86e96ff13b8206f27f956b30d8a003b8ab97b22b7bb7271d3611f5af6548772980e26c58295a70d6c7d6c9f0b166d9aa6651b358ab837ca76706635fcd0383e3a5eaaa244c2106db1fc31d116bca7c8bec9d094a346ea264e4ffe3672aa9b4b9d67cabecef44d458927da2c21488c883730bf092656c03a723151138a954a30844bf87eb33a04ba07ada7ce89afae05856800315a49d21a43e39280d6025d3d1c3d2bfcd7c707d6043b00244dabb469e96df1043fb8b4e0426ed6f8cd7bef444f77bb613b718b86ee9ecf20f2c0c53deed2baec942a0549502deb9328bed55c488b6f887fac98795f134bab72e8cd0d06fe644cccee8f4fa83c29f6dfcfd8218d84e569e22d4a9b08d1238ac679f6008f20af933e29c3a78fc451ed33fccfed460d6794c6a3a1214b2b6c90531b6e4a92ad2a55284bdec2e6eef24b1268ea891041ea67968908ea893deed3c6023d02b8414d442b6742a593aaf27b9f690026b38d12c664f3cacabe0a2b7c006dbfd6accb0586d9f04deca1f1957512985b51b48e5e76c107e44fc2157aea9eb2fe519960e331f37ab6b2c01b36ac1f5c6bed5bcbdebce34df1a8aee1a96d2075e36f0f61a3081496993d97fddce16a0608e1b78ca1339427c90c2482e0ece9767b83d1a14621cbdf2e2f560630e19e5a7140a5a24ae6e25bfc59c31be0e6e4aadba542ceba21e20c1d0f8c94f4cd1d887c6f4c6056d10d5b380349a84aa955d8db9e68898b278c5df44d6583fa89131e17d335424e4d5a98949428ddda93867f843ec6a73969c40e234ae35181b9b7cad1a263f1741c11234c0aea1df9ec1739cc139e642788adeeb2db0f1b9e6f7c6b4cc846eb564706259ca98e16a373975b8c241df29b517cf9964a688feeee3106b3470d4d44ac90d6a610c9fbd6e2108f4299de035370ee2ff9b44c478a9c09762fbf2c307d743fe7ab41e690ece98456db697d2ffdde56ff39b8a843232721029d1b4fecff1496e58a393c5810f520c4418868446684d75585d6969b924519c5671f043f3e731b4016805ebf4ea8863e673e99c41b4901caea8a3a0741192d21792ac44d3a857718ace19efc69d99891fd489b01e141f0c895317581add17d19dae011a843684dcd05e525e5ac66fc05465f2dcc7502e0fdf8dab513f4c10c8f6faad6db7bb2480e09f337811f3fa3dd3be5d0f5b7dad97a60f61b5c5dae3e87e9aedd1c90cfc6e0ec4fa09c7af4a5bdbf32629046e2f3bafb6abcddb32a51776e7bc3986ff3d62fe8a8fb545c2e56c81481c1903333826ed4818e93f142639f509c780e88147bc7447a04c81873ec87c90aa1cb4cc7c3282621dce9673317ccf1d261c47abab4b0cadb01fb2b82f58e2334722f1b45c9f4fed106e451f93cd0b9cd421213a8aa5b95898d8cde2f9780d893025a2908ced659c3ed32c097a5068e4cf271566fa8196d25bd3c154db4fcac10f0c25197a8a5bb505048a2e494d475232fc5909f67e131b5058cac9a08af7c6e200a1c0fb7f6a74cc2c56a5cdb032ac0c03381ed0b4e7b5a4040cf422efb53fd5256cde49e70d441362d255ee138ef9ee65724c6ad069cec20f9ed10b106b5c7028e6c5e40b6aaaa7cedebcf1494b29bea11492ec2e440841aefd55581b56d9257e37ca1c1b0038129a97c2a8041bb4dfa63823678091ddcaa8c0685cb2042e8b4d6dfdb0bf4c26e6e965bb840a52ac1a2f665a56f4299ebd0298d795282711c2aa47b21d1da7b6233ebcf684a1d0081962443fe71cbc80dba480e9521076d57607892390631090a5dceed0ffc838f26a80866986d86f5a232bc6a50784d4dde2e2778e4bc8ea76d18f873a9a1c15c08c96f9df0b0ebb7dfbf2cd045e2323e6336a99a106248d9ca1a4357bdf67a32a190c3e1f583cddb85c773323edbfaafcc22514a6398c3001c18bd37ec01dc6955800f598700f759da052d3134676a0fb3ef535317d008fc4088cb4619ce56aa93af4b8ea299971ce2c850c6d0307aa18880865c8f67c7c466b68efb75afa2c2d2160bc3df69c438852f450a041eb4eec199c044c45a7799905a390688eda7c52b35b4eb33f154bd633ed8635df92aec8e1a5a9816a31c4c7e35fa9bfe63d62afabd35604ccb616011689ab9774f0e8cdc19d7b5923f32cf0e0c45c8dda109fa358e934385474a627b41fda9430ff5ef781c1a31db164cafc8c8c93b95f4850de93e5d52346e11112ac68d10206ca5f507b05952bc663c381d596842e9510fe0e30038f61dd1e274e9d3009909e56c0bf768a1d116f913621ded20097571a5d83075be934852bdfcaaf453ff0b483dc6d761b77ab7b7860a1cdf34890f8ecf7de9b7b1c9bc5939b4a7f8ec3ad720a88b649d75e6ba65762183174bd3eea93289cf1d7e5b923fdcb204014de418b11d05ce4664258ed5b312ea9ae2ebfc6dc77141d7bc26a3004cdcb2f204d4dbd09405a4b306ad086cfaf0cc4ddfc0879f03f571173c3b8b2b6b950d3fc449ca0e702343d300acfcf85f9a9a30693ebb933a481550236c99fd08f16c3d3ccba289a65c822055b165b54288b42b56593738d80372e22829261315b3359d9690c85814e04f451663d020913bed48c1e3b100dddb9c2420ddfe0db0b87e79f3287d85da05625c54c4180cf6a1374628d85c696ac6e671384bb9b740e5838391bc34472641aa90c777e581a1dc0113b9cca18557a40a6e1e02c3559b521db5fefffd43dbaf08600cf7d85b8022775839e5368db99685fc2a20a0a4241179213b7d121cbf0d3da1f0ca7ca15862d0df348bee6042860fbab9c458c7958a862c717968efbcf5c1da80c428d64bcba141760f025ba433cb943c0c339819bcac90bdb8863a8effd80b25b50fdce7a85870104fdf275de083d907b64aec376b5ea9e78043002617cc26a6b0975006271a0ba15751b9f7d4d89cfdd96e3ff95bb38e773b9ca1e381e220090a33bc2558cbb60c40185ea00b4df4ce5d2e8e797dc626e8b7b573b9eeaaa43edd92e3ffb7cf9e398d0320d4a5380602d8225c878d71c509583943b158bf289cada81f8ab3a35efcd5588ec92988110368a44703d12167b8feeb94963fb79085ad04af668a0a7c3ac554bd7a1ff46b93656da6e6de9820515599f2500a84605fa91ebebfef8c4276361229fa86db3580c8c6a8ef90a6fd6c813a61c762d90deb19dc90913f365a3093e8e2457e638bbc91e298b0ff047bd4c97f08b35982c96498a004f1ee485fff2932d8bbf963f18805fda5f2c1bca91a8a34edb8900feee49add8c467f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
