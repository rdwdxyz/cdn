<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1eedd1ae4ed61c141cee799fde558c9d735a65b536d9cebc8b645ce8b6eec3a223228b90cf20f2f3f6f4d8776c613c2fde832ce0cd05d615292394642948faf319d1a13724a9ef063c71c9fcc2ea7ea308148ef652884d38f642a0cb5afb66afb7d621b957f51345d2b44519ccb9698beeaa208af22635aac3b22b28bb7caf90532bc65ccb0a09ac5a4ee9a7ad1026f13810c93c1de57f48ffbe007f45cfdcaf100cbbb218a82247bb6f777c1e4d88d6af6f08ad369e3baf752d5183864346cf4e8692c69f5bc376e069f0068833c964be08e77e358ada39adddc5ffaba93b7216b55956782141db1348a87affa37dca437e5024453579f20bd3dab3a7d3310884e36674712e7feb7904a99bef6c94f8b99bd6760402d68ead5b254ee538aa575702d4debee0f02e47f4407cf9773ff0ff17846688e89016b22c968a3edacab49275f57ea9068860d1ff0927c7d162c408f2d8672aeb1a6566a8c6c806f8afb25daab9ec8faf2591f522531daba610f43849768a669b0b98e5badfc9a14ad02be73d73affc7b8db3b560bf830f1ed4b440a4782f0789f9c867ec61c2a0793383e7bc740b3b7dca317ef9514802cac6d5c3c44d2b3fef18cb955c2e6bbe1b68a47a541315192cea8ee5972e514c22fba949ca2365f41e8a67e80542c11041d1d47a55308b9ff9aa03000c82f7400c9ce0a613595b8760550badbf56f18b6a62792f24d13a3afbd458dc4d13dbff24e03d27051d27517eba690eae53dc2e0f7c47204654a2f48d67b675af5fd88d0f1e0d853231544ce6e182a06b1ddae2dd31695e956f1b2b563dd303032268866b9fd1109101f21f541f5ce0db0617475a6d1858aaababc68d11ca7fde6c2e369f4aafbc73247b449e3f1fbac08145b02b1655899a4d1c988bf424b15dc72e68fa4fc2f31a0d1557914a936a6cd8bb907317158cb5c2b956eddb469931cf655314200623b4ab4bef6df2f8b4b46bbdf88d56b193356090d5dc8e69289b1984b159e7866d69765482733ebebbc232dde830c2af730cf4c665bf890a87770449661a1d9d4cff1c3307c387c726bb85c13845f52401edd54657c3213113218bea5f824e5bfdc5a7360e92e025406825b1fafd2e52769ae64e300e29404224b74d3f9584952d6cc2bf578ec35454e17da91c55b4c6b7ec162b07bf572e6e76ab9929febad39292c8205527ec65a3ede9426a0baf57fbc71f7f71c47342ae7992b291676d53bbbb1d2922821ad211c84910b424276a6c28920bdafdb0d4905e7be115342cca5921180c6481a6d4da2b22b5d7e91ab3d6d9d0bf558343ceacecbeb29d7058b263cbac92460f0bc27afdd45f4f088c0049b869f7230add5b62eab991a23e7ac646e4d8d9280166159b7b570372813b881d9607c2152965947a622f2b7c706c5c2e0d346b459c03e9e20a2c12a7a2f665a76a814ed5a473d4bed3b2a2be986c73b7f34e85f4184378aafbfc625a84481ab6a2b91f4aef054fb2d641a9cf729da99dcb8472db2fdf4cb3c58953b9afbf3a0e3f25ce07b37854aa47ff465387678f5193342883aa6fbf454a15973366140fc7ab5822eabcdc822ca51026ed241c14fd015bcde5f72d446e4b6eaf4f07c3a336849a64aa5bfa222cb810ae055a6cf0dcf4551127160258dc6712f748f9175fb2f4090bf820ca2f7481c3941cfd5bb8bd1e63c2cc395448b812b6bf292426a35fa79a9ad18a2e70ceeb27145e33f3b0dddf1889427804c4492ee23134080857e3fffbdc1842813ec8ac6b49c74e2062ea8659ab1ae45f1eef3835ae0c0b30886421636e186d30e779d2180dab53ab023dea0a7ebd29a839d1736e0bcae809bff5734cf98c9854790d771415111ac27050198de73428aead7bf44be53ecefba959b8f291b360346bc59dfa4b235b48dc09882c1e86b185dc12c01c7dfe5e93cbe7473721b2a7f19bf7cf7813b39dfa81321bc4d61fbf1880c8c6f0bab885498c63f83cb3454b401a891d9308a6ef6fb01cb1c15528327370eb596a4d0ee404e91befa1f304d0e9b322a00bbb75892264f05db6965632d56ef493aefc24bb0d60aa38830ec9bffe07179964d656173222dce9c64a2b2f9e361fe6732c1f71c9a01aace0e373e6a45399b857ab230282b89d496dc9e1b1c1350b78c05abde39762095659170226cd4714beb421bee7497edc9c4c6a1d2d0fb6f68d499018a293f5cd815ab3c68237f6732bc8243268457b51443ba722cd4a80d5ef1f4dcd9d7796798c0ed9570d505f01b44359b0b87bb34247cac6e5d1d3d3a03e6a3f094d82fd3c1c805d79eafe6f2c8e0c578a060a7852f04f42626872a0b8a6369d29f1588e372c8c58927fcf5ae5ce151f80db149cc9bb954884709a5869f769bc76ed19171c66694970cc32af38814bb09573b4e351d232d25b79df178df392b627455dac02aec9b25a9f9a0c1c9bf48a16f7e0345f32a9e58de4aa9c9331b5c39105739814954fcfd58885ded306fa659b450bd750bc62c544f7bbaa41d55d9b52a85318607d36b96821c75e3ece86199724d5ed4f46d5b16848c0910f2740a9ed17475f8de57c70fc7cf0ea54ec1654398eda02dafbb52436ccf8cf710873b74a656e8edd24a2eda61c3ff511899e1228658dde7372c39eb57593a634dd971433d26e1a6c0215b23f8e83ec5120284dd296c1257f0b5515a4e28356b82e6eeae2f86b0f46486d1bb2e1270c75dc59a6421aaf47095dae512c849a840d1b60e93468cfb1530abd1eddda8b9f15bda39d68f33be24cbabd7aba6496976763f2e43aed39af43487d60f84f912fb9a9263e7efb8da9f8f74959f114da2f92cec955b1744dd9b0d6b71bc17fe6af09beff1bb32f7d9bb2c1822cb54bef330647abfc0dea9eb4132d0e705ee56a3ca4b65d18260c4ce252399a453bbb005153a35e22c89cfe1310c98565f8431d513b64775ec5d011dec5d529d6665a167799c67341196bec71ac3afffc16e204e5876eeead58fb96f8033e6fd84e5e8e475dac93e6fc1f16f6044a407e5b5ce311dcd4326acfea50cf119a4f6b5cc09d58d2c18af29221f695ff47129ac8e2bbdad40777bcfcb2a5cf06502c3aceaabac0a33eb99a04f3639c83337166755e89846b97f2656bdf1c0f648f4b82597085a16067474930136e901f880cf831cc76851bbb5b97413381436aa2c893b5a69cb0dae50102ff6fc472498cf3b428aa9d95a5903b9eee44863f949a64056078e6a5ed5ef1712807933c768ba07230e8d36cc67c06a760fb5414c4aa32eeaf17067d90dacf0927bcdf98ce60a51524e813d7ae7ddc2705ce0fd44ae6458340ea7239cdb28c2377ec6278f6891b128d6ac006bbb4c1cd44c9fe79c310ca689f12a60fa79bf095a97e1cb3d81e2e935209786d3c4004b95ab322085af932f5ed0fbda43c8c27fb03f1e357e738ede3488dcbaed37604e4b971e4fa714be23f3599f7401fbadde215c7deece84534ecddbe27b8e21580a836e94b691f33330493987cf2f7f774444a73ad17dbcac1a95257b99f3dd5f1b584198bc3c16666b7f3e62fcd836e6e18a4e72075bd25648c7da4629046f57c19ed43ed39ee06cf387a5226f46201db3937dc76e61e75af1dedba07c4d4d99395146ca7cc402a8c4f5ba70a589ba27280bf0883e6a9595bf8af86c105688ae1ea93e924261eccde28393a9ed6f07211fb7572f15334d1fcb3630555d8ab645cd7b6096a92f2ab607e79d59b46f950ac1dc674d13b09efa2a2d854c66c7ea37710f099898d4fc70eb60ba27cb1dfd0e7b66f90d3e6adbef4502b9a8e1e84746d0b7c4d1b75b01c454188d9cc093c97044faca36c4568619560a5ee67da1189cff6bcf57b4d6723d16725ae7ee66b9b4ef6c8b4993c966af9e6087061f591ce37445043b66b53cb05381736671a8c7337c37c6328f662d60c275165d845f49d70ac81cc1a5799a87642bb86b0e7de49c8e79ed6a74dc0faba9d70aab4e803207a3d0e9e6794e460cea837fa53076efcd76e653bdccd266e21835e5b7527f81a372665dc63f1c8ff1e2294f91a8678c0ee4303b96e131e1a6789ce408c5170313a67e2d64e41e5f79e4bf7e90fb650ab09e3245c3e201e23b1542859913c7fa78d5af26b38429482105923c74f3bbec4edefb86ea0039e2f7177f7a48668991698cf41d9275ef7fb2c9c5b9a411bfdee49777a09dc54d2c4036c11954e3df542d17a95d2402ca5c157518069eeccf409e2703ff7c01f1fffe592b2c09685a8ad09748210aa3afce0c34c49fdd7cacc8536d9b7e1d5ea92e2973c379e70f2392c7b839126b833aaf3e0da6487d2c351f062c7c43487b56d88a529465ddfd2fbab981ea90498aa89bf2d3f86a3ae85fa64728900c3811aabf75f51eb81be036923c999cc6720318e5a01fc68d1bb335e4c31d7d17e3eaa15a599545d8aa7846f4ef30b916ace1894c63a3902cd47cda4ed953e2229d8187807bb96826588dab5efee7fe2fcc97272074c9c6e7c5fbd0c9cd58f7574295d7edb3a71a7c2b2f6f498dff0553a2cfa4c9097712a884d01d41ad0688bed43ff142cc6403a8c9e3b598a069166e9a30996b446803e7a98614f035951e987090d720123132eeeba82c2e1a80813d41fa2e30dce49a4d25d8d9cffdde9542fa6e8be14649f86e938caee90d74b1b78a0edbc16645b893f2e69eaa14b44a2456071602bbfbc6c1b28cdedf5f468d29a9d9bb7989c8cf6e484e9783c907cb159a404416940bb976806656ffaa9cccbe6a46530f3318fdb3f8470e9bdd7b70212bfd975510ccfd5897d9bd24e045d63517975be8b00e4e8be1d73dc59926f9ee9ec179a2b5f8c0bc8982185c66226e45bbc938e9879ba1006e8c1111f0e2f88acd25ef6b697e3f555e01fa499a406e62166cbe99885cccfed1321b1e57566525f32a46f2a937b59e73e5a6487c09f36582498ced9d83557ddcf38c0971c6afbc31799159634fa95fa18aa7d4d0942c53d52523b59338d4f17b164f828e8a294cb2aa97fb881534725a8b40dfe9dc678a96ecbf56057da3d68642f5f03f0d15d5b7fef0eac7b175df756e79812ee9ad6a48bd47f92781053b8d9caad8f5e3af5b9b21006dc9ea7bf85c0764699972e12b00c6b7f77412943819010efadbee25522537f456fdf64603589da22692237c24f1e53ef8980730b280394d207d13955a2f2dae53a7b2ae229cf7ad527b1d08e7b04a42cee28e5e084e29131cde5267934584c21576b4d68f5cfe9da989cc89c3d50f6ee42f3d1f3f76ef981819ea6a02ebc1bfe02602bff86edd8c26e470d75f3af5fd6d019d7b9955a9217072cc24872bb3bc694ae05d4749bed154a2fce2e9fdf2c0be85cda3e3598cd21d7d9ed36090f15d8773720425b92382a239c11a43074241b770753cd0d1d4bc4050989a0f76eec032709be1bc3e779b3ea3bfa55c15ac4656e5243f7747f2b81c3b80d05fea867f7bf465348cfcad1312336c897af0ad0361f382ee4f3968ba64e31b8736fcceead1c667c565f17157a19a855150ad3b429a3994c8b9088a8ad767a927c42a3b6f03b619381547ddf14d1807e3de9c0778bd88255be58b19392daa3d0de4285c718f0d0bf5ef54d40b544bd531adb000018510d3a0c1a4b68bf88feca85db49e082442492b64f9f2c93afa76e37728e552830e589676441b8074e81767ffb506165359ac8801643bdcaea26248115117e28ee0de17d508d71181ac870e095bf2a8a0a70d3f38764744798046070ea8173c8bc97e9eed623871263a992d958706e2bc1ab29388a4bd7ab96ecb4c32b97428ffd9ad68527ffa3788775df04994467542b24db165b66659b47611d77b1e33a80951a7ebaea43f359c30695d1d93a4082d12e776f74993e3ab10e1ab41fdcef616af1a749de6aa12bb27f71eaad4ac3c908fc804f0891f34173ce2d252f88666f2e4b2a5cdf8060410c270f956ccfa9d23e9cf181f8eefcd31fe6551c5131b170106ec695299cf2135afd954082fb5db0675bfa4f87801b96d372114cc5d72259a3b780c3f8e2aec5b2a1e4c1eb03646b20a1d282b7c19dc4d763f7a7e1e061710e1462e88045684ae01f888ce2d6e63e5ce0a79250441b355b48475354dbf7a5c2e7ae9de41990c2ac43d1bf5089ffa0604c0afeb6c5bed180486fcd0a87bf6bcd9596b0b0115791f09ef719d79fccdd481b17afd9dd6e43594b976d3d3fc39b6679902380ac2d5e8d2d5f37e097e151f2f2fecef78471420ff00fe1869f5faa13e1513568bf158e232681d5d6d071b81378445b64fa98e875d0470500cf5bf157ddcb311e25fe75dbb56808811f084093f9a5e220a9702e96bde6ed3e0db97c8fccd59ef3107698a5af7fd7f03046e7614f7be0f4db217b4148f097e88a4b63f909639a270a8ac3449bf6aaedc56365e3a9090aa39a36b4e63cec048ff555b457c7549261c276dd1843c9afc30d740fea4e5694c69480233aaab97300c26c2f16e1dff86e7ef284318fb9f75fb3f2786edacfcf347b43d337a68ab45316e2729055b8eb6c1a1107f9a6887567b6afb525658033ce34548b7fccd6e7334e63dbbf55abb1651ebe8e8fb5bee27a01f394fd312119d37b4bb4e5b38b8b93f30c7144194741638a474fb7ff2fea314e153829b417b4542376aa5a164cd4da9390c59fc8d571ec32ada90e56284ef143b0f2609c31518a66368a1b79fe89de35145850ebd21864f207335ad8c1f756298e2270d2897f0ed71047b7710b698fafe4034781278535defb432ba745e1425fa736c666e0eca6a51ae71ea974e8fa047d8bdde658be8c67eb78cabaeb8bcb0dc24aa58e510b3441194a3874dc6094d301363a68e27c4859803665d4b076abcc530f70e1477815ba09ed637460711065dc7f48d4e08b747f93e56cc9598f230f82327bbba24bbe5c8ac37aac253f8e3e3f4b4ff967c52f5828efaa6c0421dd066e2887fffcae0f443a3160d8734fef8512f073536f2b8d51330b6308fa8ce4351d11174bfe3eae0572a5984290e80675bcd4886578d52d99c003cb537728b256bd4c3ad7b31f04995fa107a77277199c75be2e88df467f4c4315f9e7b67cfbe93eb588bf1e85e9829da7b1cc995e6e5fc5b590e5e41d8429309b87859f721dabaf10afd333e44373665b16ae1e17b2f93328c8a471006507300329d927f2af7cf7f3e3c0d3bce3ec39a7e6643fb485fd40feec01c1dd9e0cf9b5a14a49ad3274987db1871513d504cd6e9c282219e075d6ca53200935b4bd6b1642aea1b16cc6cfbde033479937ac7b02110264a014a5e3fcd124a08cdb74abe5dc67e1c79931ab7bd81c754266b0bac6cdbdb792688667ff65737ff2ddb00ad851c163d39eb682f5ccfc33b7e2083e0a88de47d5185cb9a4663cf6cdd3d2150d03fbd387959cf5103ffa2065f9ff8c1a7e84be2281dc681472945b7f608b080097aa087f5332c248db0bb7739eadb489c66dfb8bf6e5d90d980b3b1e9905af126c9470cbbdb6a7592bbd910f0cab67b911d675e33cc05ac439172382c561fa0dd4df54b55ea6783e5bbeef73566b366629bb7d65217622cb32e0e0ed3fadb33e9ad0ca1d4191e0ab0e644a485383363f9865c2cfa2149509824e5b8895d19a19a48dbbc925feb016a0234fceff9251f767affc4b1db7523aa036104f4d81ffa066dea01c794438f9c072795da60a896d7f4404a1ee42182a776d2f896a5bf11d12c8f6e40e4523da2d9d0c1ad891b5b6df0ae6e51d7f39c58a6b22a578d8098f779658a81961c8990bc386687d2f94e9a5b9ad3e2ab908ca79153c16f592f306e03fe1c3eea91f6186a012444260859c43e8926a7c827cf4a7540ad993d60638ba36704b3a8aaa5d31fa2f8faf1abc542f43cc0c7854596b060addf817ca43a7fff6e72f29483770ea79a2c6caf0487d2c143cce51fe8d4c42dc86b3f33e6e94bc0ac9631853a5253df4f1a49e2b51ceff6a669a8a487ce1345ea9cb814d35798ece899388862d2eb827819b5fcf0111c4dec57231e44e716d252db9134c8a4ab3cd7afc0c2a59005279c6befebc43c7d27c60e87b99edb4a225faab61a0f4c6e4c6596caa5a666b034614851e8db1182b273e9bc588610a9cf77d723ac557818b968cb29b8c617d7d0983fca7d5559a03b955d456425e89f301de4b0d24214af97c9b5170e4d4c7064d67f6d61a009ea9cc659e194b29d40b2c2658de29269164116f992dae59da4d000638c224d87ed6038d5bd30fb0393dba31a7f35a26fc732ba6000b673d41e4671e520b6cfbe91ce76adb8b5e0c15467c6c74df55b99f43f162e37c609f37670046ef07b5304838b8f55b256146700b3e8e48fc881cf70adac029c2b425be6282f8eb3e7d50aadf87aa369804911bd57416ca6cc42352ad0a2cdfd041b26f452026fcade7bde5ab6bf0dca5e3740dd5d96724ac707806b8b09f616397d2a3b2a764474687a1b72fb408c1fe9cc93981609cbde53a0c6e6f1013cc496d81109a7c7d80ba0e942709d501f25bd42a523001f5f7e90cd531a2d5e14ead9e43b5e2cdf68a02658d662fea9fc1b589b70cce3b133ed5fb6cdf932e24cb7bc74c34b78b2f28bd58d96cad33e9422c37560afa18260021a8349c6347bcf36f12955217cb08eb8f9b6e24da2cdf104fd0f031b2a0fcbf82d91f083b1a3e86861ff4390edb06a15fc9acfe6d2a38ed02e108c5f8f313a8bbdb1d7ff82a8c90f2c5d59965b76c15cfc7872adefeba3ac5b62257f652c7ef1349b7bb62cdff40f870b42752b3ba075b00fb6f56da244094499a21a93c673e6ce505bbdac33ec21dd34bcb01c820170187d154d8aaabd8e576bc4c245143349ebaf1070be23ad6fe43460aa00af7fcfc96f6beb1a67dfe9e07bafd533c7cb8d0e419d8865e6d83ebf49c04146b3578b25b593582b3c58de291f5361551ab507df44611ef26fd19fb058e8ba6eb1d09c43153eea79482ec033be483c63c1e15874a25691abe9e4aa146313c774a52875bc070b799dc72b35322872ae1f6c91c4d636950fa3ddf177743e582e7d88608e3c4926fa69750ddbfb50a289fc2abd4ca536398fb1f78040fb85e9d19116af6e92dd6307ee61fb0bbc935fb1ea7d98fefd64b8f7ed8fe192135efc32f3010f39508749d7d4a04537a4132e8653bb1d65ab35e1b13d00eb222a5aae1f2a42f25081cf0f71d7790afdaf2fde3fbeb5c8e6dd1b0f28c2301f4d462356e4e31f451a3b8f6986c4c2f9c7b5e9158576faff290497b84f516e49135a252af590d1d2357d08a703f1a662f96d374f949511a873f1514229158b6a9d3aca4763492716d3ea30dcb50182cf32ba0b7112e673b44c5a2e196eaa085da3d5e3869f0bf99330e32884d0877f4dc00257362dccf43a93edfc902a8612671bb4e03b7145d3e7f31f53e674f59b3ec2491d85cae05b516b3a9a2499107c9b672f6143c31852fdf80f03beeb45bce7b17e251e40efd64b705fbaae339d2eb091f371284652e0b09f7fe7a8e88ac760638c2c36ea3824e6f40d0c7da5d25fe6437979fc590de9ca3e8d1977c3f4856f6f4628c577feb72c2e4a7d4cc70d653754c9567aa8d78e5398eed27b6fb4be9d8669aadc69592f03f887fc7c150afb91858a70e787004fd47bcc258b7e909c48556d5d4764ee440697bc37a4a8ebb15a0a1b90ccb38e339315104d722eb4bbc81cb42bb2649e4175aa257df4d7c5f056c7635a2217a349c9c2f2450ce01d47346832f6f932214c975dccb12542dd8be895ddf6f7dab9f22233cf2d3d151aae1930085745b1853d78f4c8a1cf586648e3b43b4a7454b4f9b1fba6515a4ea8e47eeb04a7db8605eb790f764b0e5a81c8921574e93b8790ef280ea92e02c57b90f281e258c546ca438e9d7fa9631fba47b3aec3e9c2780116637c183091dcdbc6245b146f257887930f94aff3fe5db206d18a434cde2c3223de52aec293ba832b680233335a7f4b7235191878f831cfbddb36e14ac52d0a140ccdc9ec1d32f8d7cdecc270cb83dca2da90c767e040812fa99036d4b45a799112966cbde0c1b6e1560a33991acbe79191954d8156ce7a55a7d532c697d1b8101436c579479b5f503c45576dfa2a5eb36c81386ff92720ae5bce638b144885ba54bdd1928eaba87d7c5b44f643a11e8ed17d5b736fb01a3524169625857b6ff1ec1938c1f47a9d5ebdc67fe99e9a340fffa01b33da3e0909dd668d2276e96e03b846e13be6a19ef4d25cd3a5841f2c8d40ae70830699bee938d415c276a7a04fb07de28d6639a96ca2e8eb216f7749d3c7ea2aaa20a948f12fb8a94cc29a6581315ef9d01f16dcb4d6d77919d641749553d012065d1eb94586f137cc873d8a73f29aeac36784e90b7a6b3417dbe080838a8899e048cb9d61be0d794059985edfcf31fa8bf0c3c10a7eef414b87ed4b310eb4893c26a45681648cf1243fe9f979b95559d8027d8bbc8a4513acff4e7662a4bb866d5d93e19316ac25369cfe0a66abf529eb08aa3d41814bf9db16c096f715fc23a35a1e0fb0d8ff80b80c94a817a9743c96c03a8bf7f35727b6f9bd52929da3d8cab5759a22e0bfcd0229c4dd315ed69784e9b140063dde8fa965d83be2c76fc49eacc800b163ff0174af9a86d37caa74705786f25afae139b0655c7f5a1fb69edd7fb42d3f6171ba37858e5528099fb485ce2d6f6852eeee9f90adeeb203bef5b8fb10b9369f635e8a3b8f8d09e3fd1a5d3a0f7a81c706bb557eeeddff8fa7084094d2543615e617b396bdbe3d29962599e238aceea10feedb73a3d462f4a3c8577db3f743ec3161b33a223aa0b7ce539d97b67bcc54218b20b872fc97683c0f236abe15dba53763be6fb787c3b6398623a83468c38d5776e196ca4c2a56aa64b84be72a0c68a2bd5285185431eead5029dcbf983fa4465bd079ec0e1fceb0e107aa0982e2143cd1a6f9588a804509b6a83787e0471b1b4dacae5f116666749a835bbe60f83a1ea927029363d077c07170d04c4e392a8d6315663915572468260bdd07d65f3a06ee5d550b51de7048843fbb1bb9067100cc2ca02772f8ae4fdc07c15d843c60175b0136afd6da6d10c1d28d2a0cf67e3dc8e7bda31592e9fcd19944eb1ebc256493216e5e3256a3fb7b6be8cece4650377376f11ece3c07b8d8f83d2ea9ae605772bc75f4fd016ffa1b1e62793bc424569233aceec41b4ad42fad570b160c9c3cb6b87156d069607c16e26cbb266e6f398de44d2185b8d3066fec847d4ebc5ba25dedc37bb2fb5ec7b696a44070aefcb73ff307502fc5ef0e0ce9943a92f77cf992c3fdefb7f3ecb3cc381e7108606e6106689accc629a003462a5403682b2264d4b7130a7b79d08d88785f42f255ae984bc0e2f3ad97ea5686dac5b735f6c67fa0fa16762e0073a1ede1204ada56c2cf979c604b30a8a838e292fac6d651aa59ac1ce3f5e78ceced7fee8d80b7b874b13ddf23b2067c5e4380a0289205f5ebb527f5c7fbadc2e9ebef093706197e9091acdc00c4244ee8d2f239d5073d292b898a9263cb37cd0e46a7d90bd94c9ff235420e5e56e24c09c766cc32cef7409aab4c9f3359e20b4621846a3a702b34b82ab04d00a334bbfc0b7df73c48f5342c5d1a4ec997475558a15d71f47fb8eb5b39db6421fd5592e468c395e16f8094efed28031945ee7ca910fd0a59a4a5fd0aec92ff6b2125434c3c477ccdcf0aab094a189d1e5349a57c2fe95c1c73f2a152fb4faaee4eea5ebe681cf3ea7a1fc7c7b3dbc042611b273e24f94d8061fe764f29a42257ccc689c7ed8fd6499b5b358377fc6cbe7fd5cb192b7902470c816f5585e85e0a4634c755b8c840665e831271b482b7641a5a79d1fef57858dbe0242f5008212a8074c755fc93a40261c42bee0d5627ab2b19f8a2a9b0f8b34f90acbe8a2c2894b89ce98e3df00a32f202b705e50bd0ea8f8843733d030e258eebf61c8dde26e5cf49a7ebeb02fa30fac7656f4be6a03e69ef4b953bcdfc14e6d23524b75cfe4522258582567ebb0bdf6c2419e78898facc412208102f5844320e65d5f3ba1dbb11e903a1847ab55fcab8bba342e152c1ed5b0fbe4c74620c27775cfac228128bd7c6b4469b99e3cda748e77ac3c1bf3580a2142c66e4e011c32dcd87be82533ff5cb2c4799d11dcf939036426f507fe184961aadba6ddb1d7e203ed97990963753a515c7897d204d5df08cd741ff47d619fddcb9b3c1f764262b4d76d4ebff22af88399ae41269b691eb828fb8f6346d0aa09ce34da77c1283906f4716607f6bc7f17c20f7142cb4dce37e0f06744abe766559a81d82d7c368d34f148e473c6ea2175295c3537c905cba68b429b28e454ca0b0b37f474f13b15573e808bf66f3e812cc7bb34f6b41761d49c68f8131de6bc389da9177003a69ffafa1e82cf24d8e628f24107b8c3ad065b3e94b48e7ea33e885bb87facd448684c7fba5d367f92fb712a2317ba33c70339157a9b8b964d0448843705d923ee4af5a36913219867e75d4c340ee2bb2365ab98eb5e2080e422ce41fc8ca848ac429174c6d5c4c34900253ad93564f9e1f0924eb3b82dc906a81291117dd04793f7661baef61c86963ca9ed680b0370e457e94186bdaa4b16990371fabb3b93ca66d8e6e7eae5e93d4ae2e9d8eb250e33b9f88d7583fba41ac96e8a3dc3f0a83cc545c4067f2b9d9157b29fe5a1452ef684255e8f1c9627c31082d7ce03db7733e34e4abfadd26cbd795b4e7982bccb36d83a52657e9c03b6d7ca39d90983fc9b04dbe791dfa5a527d6e33f6caa6dc7ccdea714e54e9a04dce8ab5ac3e54f0e204444b0adf993cee4d84129dc2609dde7107067928a13d9fc4f2b5fc122ee9267eebb68522dda648b172f30118ddf93e498c42ec871c234c45d0afb833db6433dce04ee4ebf1b62c96f33d164986e99708835b078ac269211ee9ce0a085e5b77429911d339f673dc002af4b7ab0c9709ad2aa97e46f3ae748f6a519caedd1a10246559abd3fd04e1a542408b6d32abb86a092b3e97ab9fa3aae5865689bde25841b02121edd00f26a7ee124dcae2099e48fd43c09d08e5ea6f8889ef8284bc0b043d168fb16c7b62749c71465531514499f04cdbe9efa4bd638ac4705edc3e2cd8e30afd7804837f2d23ee99a81dc6b43d6415bb4ef08388944c955f539f0f9e69cc869f6183748233df734ac26b44f0d18d586488cb8333eadaa4f1bcec3b53534ec075d06a76c441910bd3dc84e5becfbc72d5e926bbff301db00502a69bf7cde4277bbf68ce4f41225a3df6db7b080e9b81c2811d088681e8cdc4a7013b52cdd111804c7aabdf090aa79c29526ed9caf9a135511c0634695d2c07260043e0c7b0a6d3d954bc7a3c54473cb5b148dc92287a4f1026adb4e918a4b1a42ff1059549e880d55799797424ea42d2c560bd595c69f640e9b5f371549b1cc6d78c33f5bce1e8924918ec75df2148f7d8828c59ef71dee0adff9ebaf2f191e012dd052885f0ba299d7f9badbdbb763ecca573d4aad574b971f37500b742246a1505f88f66b73a8479afc6f0336e03ff8da04070faa634e26334dbfd5bc8cf0c80bbac0f6f344decea8efc3ddedd2dcdc96bbcbf865ec6527b336b86115fadde153bec53aa4408946c29c4995f2c471a9a05740c9ca0b77d38db2466a78762e6f44734b0a14e7f641a31fe5ba0af70b2e21796560061545247ac7d365350dbe7d2b31ba606bf5cb3fcc6d9ac142ff92ef29140116e1224d35da9df38d0c2e8eca7c752630f46ff9a44d9541069706ba571553f50948f7e021675e10db867a291543f96613c552696288220951ea4f31f219a64b26595c55a2cd05f1dadf0f5c4d6123474a4df9eba32cf0698f9b2432563ecae11c9388af2f4654649449fd5ac2a83af31711f1039ab671248eb881f82e902fa520298c0aa958f6a4291ec2453ca285094448f80f27a56cc2dce9019c43ccd25b95674bf68942aedb3c8836c5406790dcdf4084052ab08b921b93b0e7664b506a535f04551865a1a1fff13d3e239a466796d7cd51b60af3c425d506a0fb7f8e6ce1d6747b1fc47eb7c2640dfd6f1b7f19842691b11ecc9268bf1d639adfb3adf94ba33be6c3efc6ab97b817ed61543e0b846b99ba1ecc4245320c41ab5f52054fe166dab084e25fba067ed3a44d7dfe39cfc99dbccb3fec818b9efe89a386d9763f0cfd4472445d8ad24c06557f3d1737d388e47f6ede0e92a290a2f2c77f4c60790d7528ec08ccc90d7fe62ce5f963a17d0a598340c8819bf06a7d9dbe8dba12d7191f7f8dc1ef4534d66c1e08feba9a3b9ac4a660e342945c50ba2eb5ce3d8cfcdc7401b9d3550fe5545f5b45d956f7f3c0db8cc1ef93a97c9c5dbc26d14b0b0499beb977f2b30f445a2b46ef9605f0fd6dcf2ab30ef9695b40b2a514a519648e042f4a90460d23edb8d0982fad99a7af82b39dc8b471bc9049e63cca1d4108d0ab0d490798a62a2fea3efcc9b9d334ae98231c07aa90c53cb00f642eb56b18c8eaae389d0eb9f97a03b04daab367f180c4376afbe4941396cca6fe9f5e3f31fc501656d4d13c95a9b184ed6bb00cddebefe6d150b70e919a4a08be5cf3310939c60f0db00c6122846213e640dcc718cf282bcba078a5008b9e9e2fddbfb21496c28e4cda3862a664b982f50ba6f4ae8b751f47da3fa113d2d0d57f5c71cb775d6cc5574a8340e11f0222294fc9b57ab6f31f4250286f69d4928e338c2f8198afb0fff01b3046ebe305c98c71247937b1c19d7afbf026fad6ad3c38c96ca263b5a8f03451c8812985c35cf03cae08c060877c8b5ad4c90ef924848e1790a1873f3621fdfa7cd11975ae51b6d9b10cb4a9c80b76f2a95ae7330187154893a83e8506d3a1ed1a9458d5d5554c8f3950b4dd0637637dd1b724c92a70a0b7628c41a8e7f47e3e316d420d63921007d8482839ebc5a799cda70146752c8cf926a8b38a7f2f8d7787c90815690b571e3968d400b8df9aba13691e2010535377b941d175ce1adea2cbc28f5df24e6b3af091a79c45410700e19ef1dde366e78106097eb76e48a381e22e74ce35482efd9dfcee0301a73428411","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
