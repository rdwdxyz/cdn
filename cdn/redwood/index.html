<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90d2e9a538272105d8def3d6e322947c3c7184786ff961de47d1657d1243a958dbb08de43f03ee62a7dfb76bccf0c4d14a7451442f5bf5c9fe2b64e2f6b3c4d4ee33b5afc7f989b77e42b27cd304c2e1b379c88330fdc6d9297d2ba13f1b9c928b935067e968247f2dd9c2ff48fd8adedd2d8ef29b69812ce7ee7573322afb5dc05098e1bf650fde5888dcbb6e6c827f6a8f5c363ebf274c7158f4c5eb16c4748021a39c310e0c855f41d9eccffc2bb34731165b14713b88feb46804f4aa6e09a751c096042da17188be74a3b75391308b076ac1365c88d986492e1b224fc18b1641994f51cb6908965b00bdb2f28007166aaa18115f64871f0173f386a25b67f065fd9db8d0974c19cfc4198b74162cb80fde1e185b814cfd95d38da7eece39bfe5fa2f8d04750c9e20e2b3496f55dc26bf9fa9f763c651070201a3bf942f9c5ec16f707c18383fe22297ea8370c2be7e4b26615ba7d2048d4f53426b2331634d474a5588c2e30a068e0c97179ffcc730b904aeb9702c88c291c9a39508d85c84ee379ed28c93a493e097fb1b2ecbfcc427ae8be98112c5c96fd841dae046ce24f8620689873819076e6ad7fac8bcc8da0ad0395684ab2093dc04fd3daebee6823d965815dd49887475592582a210b8f99291ccca520150587f151f0c2e53d6dd50cb2480802015d809ebb00e961784955d43603b03198d035d248e49b3ef59496aeeefd21c70164f7aedda38258247176d93c17934fabfbc6cb477c622803463ed6b03757f304e68141a707110a3cdf5a4be9b1e1eb658ab74c9299c3c24876b73eb511e6a70eff782459af43c63f37bfd14f09f938841b09d4a8f406cededa9d0d9353affe9e6253c182e2b0e7a785dd24fc04ff1c219b450f962c4f8b86c7a456589647210cc7e9966e085165860f4017cb218aaa1e247b11d8ad096ac59b358dcd0b3613aafb3c6713d66d1d554028ce7dbe15587dd835d013d2b2a5c8845c949bfb2a751460b8626d80be480ea1ca49c2fb0fb95cef24db56b61bf304248849115dbd24c086d2212349d3cb4a867d68649fc8b4a1d84e31cccf3851bab7c66000ab570835975757351b1ff670f0a900fdc6c8a6e03e601901072bc87e62fa92b739cc5c47ed6efbd1db24a64c748f7861debd809a89ee9d8d70a8196731130605901abf939614a7dd4ff8fc1f69ea2e473092c4647454b11ff47c774a238ae712d70742138b48633750ea7ffef25500ddbeea69d692931c50c0fb2facb1e12b1134bd7391897d622f4d5dc5499bd6cd2fbe5e0ed98c8003af2ecfa2e683d3ef90bdd60fb9ba7879fe8bda923c2b3703929f2b8cca572a8672cd3caa790b951978d79e24fc3c8b8a19112cd9d6ff061f7da4ff793bb1fc82e06c26217c8e9bccb42cdee7a178fc8221fbfc4eb47d5c6423d7555aa1be4d88702fe8309e826e689cf14fa9d20111989cda59017d46af76fcb9a28337971df4f356077ce4a2a88dc3752eb0090095b81658da878aa2a70cae38611548185e83c9158a5fb620a19ec9a7c49600ca1eb868cb0933133d1cb63d8b584ad0c00a5298a9635b84399250e26647ff278ec219cb2372167ce31c0e362ba7bc8c363135e1c68240f4207b021e6778a2e8d8e5f3a11adf321899c0d2a55076ce050e4c8c7842c7a5a4bf82c1c917362802719120471879faaa4c1c29daba26d5a2a1d5480106c5491212a48b7c2f50895619d4ba34b101b9cebeecffd7c5fc9880856d78ac0ac4c130539aee341c869a11ac668d2bebee7fa31505cbd859e2a191298c79c6327f0b0d349870617f9f53cdbf3a41944622dd5dcb446eee44e59e9c1a6448209ce3851ca199812d2be09a336734ba3e11e9b9e2b32dd37097450aeb51c61ad2ab173a1a05862b756224b52ce3e691a4a327ab2256d720020a7ba0735e261d10ff0fecd1662f1d37479f470fd21978992b12ba8b8b8c22086b6e12f993876f0b21a6bb8aff4b8ad32bbf914a34fce1683a0912f9003fcadc0d7a4a008675791e191b90a98f9be8a5a7b71b5a929aa1731f59c915d72ee8fe4d6d723a4717ce2682ba5c400cd4f0beb8eda61937ec3afc1c261d5c32267a82b07be052ea7d46b838c5b5f963c02695e36000f486813e7191fbd5da3b935dab8566f198041dd5aeaf632f9ac767e45efe67999c5c99eb3b0f3e2becc8e611183a9904ce5a30d13da82068c6aacad182b1fa3b7aaaf9e25d0ba5a2cefd99a2db7c603f086f66c2fa48774301ba775510ebb7bcf2c8815ea4394168890605c28e63fed0a31532a624ed4029468716f5532151cb91cbf35004c58e4a91623d02a299237ed4488b35a9b342a4d2433d6638bc836e9456312d2b7be837afa59fd7741841bf3145d02bf2ce67969394ed230c48d50d2b2db5c7e502def718292a4df3223768ae639d5ca5fccc6821b1ee3b55b9cd860defa5c9a5fc9ed44a8b91709d65b0febe137f9cc83182454871e60b531873411a1bed92589876bd7fe6a42b89a3c0a13a03cbdd0c62d117699505edc8229620a48de78f59c7137da7f4a58ad9d9aabd4838c84e8ce8a3fb88c5e70716532f3d4d5d6bc9825c80c427dc2609d0af5fbf05096c824608e485edddd49af627a6955d5fd3c7f7843a3aa27117a4cdb0511058cefe817117278f5016134b1bb6a0101cf35fbd116fadf1dafffffcfd7547f2c0aaf2534ab7a34dd6157254327b0e7a449c0285f97192d0bf8060f6f649e86b2c814d76273dab600b35f6b47cbfbe0530c7fb443f071e94cd3ca662a200862845ec35841ca7908f9a56ae1ea74f4569443d639e1ffaa051f40e1340e3e9790d8e9fbd275f082cd2cbd91b37b2b5cb4c918fbb0a477e115d3d157d2045f55cc67976b988b5ea72c271fdba2cd70b453262ce69be0e59327dd232f902875266c89a0ec52a9ef73decde3f420e1e5fc599f50ed8d0d668f0540a76d4ed889b58da42924ccb71875e6cd9af2c6ffd5f91bd2c1a9a4b06bb9dd51bac22d8c3c8d9a42ac6b578a77632f9e8d59635ff23c60711f638708f2e9cfcf88c4a8d0cfcf0d09b12b6c03cdafc0a52cdcdf61b4d3e04e9a5b9483bd5e4ca59dfd5efb76bebc3a37ec79325c306ff08da50ec5616a54cbac8e0bdb9132843bbdfe78b44441c965f42bc8877d87b7e4d04f576858dadd32943119fc20b004eb4190485edf4d10d7eba415e6ad4fdc006fa4dad07fa4134e9bd972bdab6c278c4e235c841b05495e1a8d063417a765f4a81c29490a0c23cb7fcdc97884774343c8a6b88a0496fb370945206f71d8ad63761239c52e1921cff6979b58f8fa17d9cb2cf9cf7ada19f93d1a806cfba5733a9426334354fc6f1a0e43018aca0a779b9d1ce094416efd0c7b368f8795acb976a3fc697e2481fbc3e90e257bc78c381132a89885929a8f70d0f2c798373a3cb8b49de4f37bdacf1276c1881f9efcf680f7da79e633ead75be31a8e1948bb7443b36b59689491fabfd90776f07583f115a88a6010bf307467b41f4c06992a9eac3941100487415357b00d3be59f0b7b9fb607e3f2860521b5521fc96f9cea90ba4790541c3ae1916d0e9cf2a5392d1a0eb4d07b162562b5e7f49256176391c241800edf4eeebbad0d3dc5c2bea3952ae4c7dc375c910e1ff302df4301d73415fdb89baa1c8e0d788fb34b1f7984b9d4807bcd2ad12b02063e423cf394624cba37f18aad0a829c0dfe59643eb1a08b0cd41bb9269e4e6b7eccbf405742538db4d4e0a5089ae44b52867e87ee343c40e7f850cb810928cc3f3164cb0abac102f87f83d805e1be574020cb4ff7eda363e2b338fe79597026e91e3f98117f6d47f576881408b51ca8234a7a4d107f714cd9ba60dee80ee0241107e0e3d9d6d62f22b90c72471e76d62eef15f826994eda0a180a72d8a18f49bbb2457571e734e38824b14b1fe6591c14ba77dd453bde21279c83734237027f1fa4bc18c5c98d923a405007435862e227eb259779fc44e849c87021c3c32b0454705d428ff76e369d1fc405cbb509118b79fde9351725602deacb654618ececbb1808b47bce39a4d7fc00c9b111052d783c60190cd1a606f70e2a5d46827ac56d3acdd5c9d03b0481a15a37f1e28d6696e54d6f45fdc3895ebb37bb0715b36b199c8dccf909abd183b01570eb5af48a1be390265bab7a53d870ead2f5ab5a24f575c4e13f8916088cf7bb01f1d06c362d184f70f718db1d1bc5f69500f19778b5c9a8302be0139a4e74ed223b38eee482bb15d1fc016324e5f5853904212435e3a9f43c5f18ec0e5c411473d4d5e87d7a68424aa6d86889b5f79f623a1923bdf454a7139c5c130cd7c4e2e89c183728b43aa5b7120c1da4bc97019c2acbaf3c8946964043792ac76a03eb10c1e4b44ae8074b1fc891cce23a2340a4be51d10d04b0de8379fe0e3c023c112d99190e9d011de193bc064c7a14146031c8f46c8018c81178cdeb182f002ccbc530c4fd916cf6cc0e23b953c307c289f2bae9237f304e540d885c837e682d55dc025e44cce8fd4f4340bd3e3dea74effec71556a4e9aa135ee3fd1014bbb10767280af17b23a5536e3c305badefb057bc6017510e99eba0f127ee0f339095a7565e37b36aa3fe3f1f8ffbf97dc19e9686c079aa703010305f6ed30929c7b26e30a2fdbc4f0a5ea1c6555ea47a1a2daf4c9247b200971be9a3d7f417005acc6ffd94e2a92e8777ea7766b101b49d0215416f70a48db8c405b6f1be81a06a04fcc73394d8a5ba5d46f86ce313e2b8bc074038bcb3c6534de5b0257bb6fec9c6d15df6b8c210918ab75bce8590d518782e34ab0381455958887f4d8d8ff925dd6768b2c2e49911d5a586de28bbf55c162038d5932af5a13adff71c9f73efa09dcaaa33100385cd9ba255d14c8387a61f14522cdbde79b4cbef49a1daa14f7a3e031f37ab61bff5cb59c916452bce11ae56aef943a7686b8dc890876037b778fe69e565a92a470e356c4c1da1d51aead4a72e7ec0843781c7dd2ea400151b9a7466578f55d596fe45467ac0aa02a2252c0ec415b2d7aad04d89a577b1deb09bf9b38c599d1729b57cd6f2fe1fb0ba41b4125ab7b11c8a43d5c1d2d4d59fa016484d90fa4a44dd2b00960cfee0c156b00ea64d2241a1e9b78083f2e041996301854c9c1b1a45472077f31bdcb85f6cc2849323266a24744e778a45b80099c69ca459b8c64c4e1d5fa26cdb530ed79e1440cb2f3e3f8d00814f66d4b8403c18bcc67a235fedc7c8aebb14e0f53c5acea34d39d0c36b180329248bc1890b14b8103626dd853699926dc8060953f27ea7b87974fd93b8c41819917db0b399fe8385b31080f034cbbd0828dc9e47614b999cea1b5640c37f3f15b4837e44a3cf7210ddda65e71efc6e4f5caf6ff5eb160f0ddbf77df7b425add0d417d20697c9b54d8a8ce4d4451c26513723d808930f5a70a84e3783ae7254fe3d94f47b910f62d4d0b122a39ce0e72cc6f6aec1d8019037058b37ef7e66395257a9ece51c441c048abb99d0d684eb2f15789b673982ebc1409ed445813a91fdb5db65410b1d0335f9b0c3ab4fd81097c3e9a5502370fa157f915b6cdaf83fb340c0bc8829a7fb2de1edb323222eee47ac1ff549b8611b96fc1037d80c913859d7ddb9a329ade8c45f0148a7f1d25350893e2d07ef0036dfd0c87b5b18acee86e29744d9bafb3423362a734e43ac1e15b15e7175976d972825319b73b56c799fc34600c07a2e023075bc713e22c69e67989cd47581cb00f79c16e3f0f9cb663845fe428de378f2e494a87913a19436a2b0eccf1dcf911ce5fb2f0c229bdd8d53e86ff8c785af214598ba72c58750c8d5714432f47759ac42b7cb95e699b253f63ac89c6b008b087999f629c99d4030cfd3f7acc70844ba7d4ca0f5050b8239ddf939661b6406e946e22bf81bf140b471f56a54ee3e1c63dfc8cde738f5365ad139b6f4a6c098f9cf5a5545cee4318bf1dc9846bf5039ddd479a8e00a986a9fb511c355241cd393686bb1b5229400d05faa7802e5d54c800438dca926aaea5dd8536d8777c3bc14fa61026745dc155a2d5e860a9fc4c0af32ff190107909a01a7cfbd8e654a44ff254d26455feb2f1f68dbc2e6f32949fd141c8fc4ac7daf1c2ef570f6da195e92eb7c038ba2c4295ef71c5ac6c6129c5d1b182af100ed6d8d7ef5ce16a96ca7ed85bee9c534f4b1b4a40b3ba4c26878f92506e0f4ba31727bc76de4cd602f0a9a1cad0b4d430e322d37ae0d8ce64f1e1d46a9901f1147555f827224b5c4976415dcc931bc7ee48a8e31b00e2df119fc212861ac78c0bf26c8509d5f645fd556f3660ec964650e3d84fab50f27a88fbd5bca73eb5db198c710903375c0906bc2212e4a0473be944262830d99359b9bd58fdc48b0b004e095e08e9728a67ae99f5c757436cd2aca3df379c4665869dfc080a115cbf2dd7d766db27cc9500ec935a4bb01e60935b5776ac4782ac5df2ce71ffcc263ff9a83e4cbd991c82ea3c90b6285966ed226c9b064bb19e2686ce6f68475e0c981dcc92be1212e6942bbb9a20067b448e4080d89c599c91e9b671cc4862fcd6a48cfd3778f504527a350b16cac0e9a4c66dea579600e513650a12e4eec0f30db07f52ed7f9a89a82054a9cd1dbb5d71721e195b66721f533e690d5511658553f3ad6dd6cb0764f4fa31d5d45f5aab8a1ae71e3b71eb451beefc76f72340f3a6fb5e91bbab76ddd3ba9abc2f879f39bea934f92af6d557a4d6b429ff4a674af73dd009f2ef2bc292275a310d77725b64e521f29cc575aba038a1394387511b8cf0fb9c2c7c774de976a2869f5e57f914e444dcc84114d63dd37668f5075f8357800c2ac0c1440e3a422bda89c53297359202cb1c33bd021d34464e825eab676b995b6cebea41fe68a769777c30bbaf489391da7eb6f9ec373bade1a553b9bc4ee2f1732d78015a7c1e15f078b46862b9fddf3508a68fb215348e4f3f2c3533f0f4a09bb765e8fa3eeaeb0b0334de37e7459d5c499b312111086b3df7f3cd14e579cf6087e15ffd1bd73e71c65d9797cae56096893787895016c48b85160ac16dff19ab1701b1d6a2b09030e9902c5ff0fe7f48fd70b1de555c210748b1c76f090b596281d6fdbd5e10ebf67110de35e66e098ff01af0c316a9929c870f23dad0427bd2b9682299bf2494dc1e707d0599f58cf9e41256bf6d52d66cfe0ffd80816f7d109bc7529495e7202bc58238b11c39cf4f7373fd7f59a9e7381a02bb4a90e809e1310e39e1c726810287bcf521b2845bc07fec415ef73df26d0c296003390e2fbcf2eba7efa2932240feea00ba36b9ec161da86272f0cf997afea5f4beb128f829c80b657d45c6aa30a5dd233be8e82ce7375891ad4aa3c051a9d33cae0e1ae327f7b4337eee9d3f08d47d5812c77667f9410c103c7877f202c134c6ad630b4bfdc636a45caedd023399ce8a3cf989a442a82278a4b8ab2d6c7ad953bda31dfd7aaa29ba27454612496887ec6a760cbfca915af900bcdddeab80c8e4628bd4223c830447d87ee0226177f99bbd3501fa25edf3c4480e5e0f1cbd998d68c1ba3b80a662e8e6d5d85d18b45b56fac84b3f94380f5e2646797bb0926ec35f421e91b729e19c0e77018d175b02d5408f30f66b952b4be9f0cb6905469263c971ec281997868b8b9d174f904aafbec84aa5dbdb4b48a3505f0285ac6b1a2c317a0cbc0b5d2fc8cfd836584e6a59c3b597f51c29cccc7f6a2d860f58d1b50899b494220822072f083437469487cee3e035421fe651c818aed7ec4626b3c217c4bc85d06d85b7c470b9fc04a3b291ca169a8361715783accb44a7bdeb7ff5db366f5a629c968a6c495656dfa2baeff0b80ec91d650783a9cba0ac390aaf03aa20d12d339705d10663033152ecf8bfd0a51cd04a23f1dbbb670af8f4704de26a935d88cdb27dd5c6503c78274d2fb633e314e465793ee06d0c0ba0e2945236f3d7b2cd4034addf4fe70fe1fdd43b8907aeff6af5a45c4195dfa62f8efa87e1e9dbc8b5ebd9d37b672b4ae144c40ab85f9cc36a378d1da1dc32fa9205141cafede3e2ba9d533637db5a3eba7d0fc3f754219b96402a8b95779a3dd9b9a72bf4484c0bf31a8578e341241a61afe85441eb19a9c2f07b264c98bb044921abff978d8912db404c40f10c60aad049e5219aed4831aa753029d0dc6b11ae8cd47e30552284c5bb203b2a3d54ee84da3f106026d7cca9821898f287fe911b50345c862f261b4f9b7dcf1cb2b9db7ead228565fce539ceab967da3c6356d59bbf664e9becb036967465da540eeab82f67c0e53ce191d244516ada38f9df66e0d671e6a0d15df29899df662c2f835683465d6b5a6141b998a11c58e7993449a47c8ff755f3d1adb8ca33f14a441dfb999865c310f2c5da2accca7f74512925d6f4d2cebd016e748163571743aca791becd98396cfb08a92c1333770c5ea27b3d8d2b11ba748c2e5fde376caf23778bc0bf34d5427991959383dc7ce477b61ca8db03eccfccb1a9a8dccc30e98ac1a5ba635ddecbb0e7784173dc7980606a5be78abcb84a816ad90a27807730ce8977f7530d4ed81dc4962369191bc1749f370f5dea532701a04d75fdf95306e5aba6989834f31d3fb7616c83da38dae56d441502f83e7d7e62ef437ee7bf1a2ab8aa81e5eccd7ba3624590562eb03bb9edc53328847d68b7abca139fbdf5c5423148dbe21cbeac76d01cf2a707f0c8ac2c9cfd77a0a05a3181c6574b2d2b065d10d479eadcc4e4767c172c81606adc8f0259ddb52223e3cc7ec91e121b36329f68b827f14bef928778a15a9692cf56da201d805741b4f867c7244703275fd78e581610ef40920b41bd4b47761b313af0a93a96face7c5065652ed72de477f80e233e12082196ec0e1ab72e31ee65bc9044515d3c49d513474b2b2acd2114f15993ef8855dfd6a7bf4054c1f11590f6c4bd5ea102840322eaf2f716285404fd232fe53e42f32263aad8f03acc12e5a9a15674ee7f243e279b09591ee62fba193695bc46f8b43188ca16adb0adab15a2a82e225b757f82b291f7da23b4e30fdb664fe3ad874c20a5865eb340951fda49c337d41d6d33a97de380778be104aa5192f39c8680c3b4bec6c16924fa39c980c243c90f95931ba08d63531eccf3262916273651a8b144d49bbdc378a3ff6bc1fef574722d3b131854d187c5b117d600a8771a9dc1c0bd05486078674f82d2c5c88ccb70639d97af4eba909e2129574df6adbdc74f788ae94ceaee2d58af102b56ce4701b9fc69a188d18f49b7d87da0ed3e9f66de9cac64f48762d3d4ab8ac31de031cc846dd32e79101f7311155eac0b3a060f3a6aae5472549925ac2e5b6276af34fc7548c8335559082c8f477d21036dd6489a648abf422b61570831f307dee4db93831d37014d6522a8da14ab6994a79d88f8dcbf642568ccfe5d79376d125d4f2592f6c890f0e177cf20c912d4bd151be6a0161c4ff6dc017828957fbc28b787e627b80d4667bae52bf7574be282958fd8513d1ae08a2854b7958bab57273cdc5c4b7123cc20daf52ad8b315a00c8526aff97d61f7828f2aa5ebad94c59aee88b75bd0186211dabe591b0e88aadfd6a65c033a8aa6297eef74e2f62c9c7346baeadde4d3f2f89157db2a0f2f18ddda774d49014ca1835771025f0673777502a7eef02fc708cf407a4982748978caf7f32dfcdf69ceb71d0d37bc72ba93ea12453d43a2f82df760cb47f53045eafc698e27eea82e4961e4f98d3b6302d7cbb3496735b2aedd2fba44917c702448aed45dfedcf105199388c62b284ef40a2dedd182df35d5d147d3e36ca9669323dfe230f60d9b0ecffda49b82499789c8d754619458943d314ed195190170bfad600ff055b8b69f4effa86cb7d8d22db5f4ce27b7889d9d66beaec6f52b6919e95d633d19ffd04c2c7c59daf3d2082d2eaca9e2bcd1982dd00a3bec22b371575a7fac28e704c42ade73177b162ae48555c917b922b2e504842c2956ffd798f3b03c394777b159f3a6bd31b14acec7f9ba0e25caa98c5aec4889f9d13f1351ae7ba408477f4e95eafe6f377d719f3b368660f6f6c01bb90aeec2a54b10b1b3c516abc878030a4b52b34e567d4b62bd416ae90f29431c41d881efa96a47fef6490576c0111cfeb8c2ae061c132fef735b49712481d568420515c5fadc31df2a2060b19d69c1477994ee65d7d7918ea7d0c9eda27bc425858ad6f9e0bf9232af7dbbdcb78ca4aa3093ff4ee4a4a462e497af8aacad2ca82136175206e8819a685de7099a95d97aaa8ff0b9a8da1e7acb5b828b7fa15f7db5a6755260bf99cbf66ab6a32523ff003db9349d9c112c0d281d83e8c8edcf3e68cbcecc345fa83e8c3fc3e617d4959c74ddf3dbaa5feb14d19ca3fc3c2833fa93f869bb9712bbaadaba3ec2349d3c5b1d87bf0723d9ba6e48a5b104ccd7d35c311ca7a655729c9ffde9ede6c0eba8db45f3ae8620d57afa9e615bb40beb1ab1e00b8c20dd9caa556ac0581ee81406802781c4fb48292508eb2693ffd670aafdbb23d562d9609e38cdaa50832369376dc9bb38639e9ac0fd7c80762e08f6e75d0dbef9a789e512c77596c52744dd57bf4715d081558345485262b6cc5ff878e65bcbc94de73727a6351d261b33106d84aed7b25359ad8bb4f70028c1107d07de32ebcf3c24ef675e9536291445481e54311e5c580cd89f37f5f25d500ffc11a93460bc1ce8956abe55b79f0fa3df773a56a0d0fe7b8e90065799c510ff5fb24a97f286c13d04a811dbcfe8a7004a014553c97260d6daf9b09859533440dc0d82abbf29667f494a6dac83795ab6f14f8c15e8e8c7f9e48bbbcf2fe801a42edd98a8d63a6913da88c17033c24068326b87d9fec63f2e9e68d1cc06c4263c3c5cb8a441dd1689c70c2e4500aefee80eacdc01693e52e44e1f28888651b902e1af3031d13c2248aabfd74897a28fe130826a58da3cc270a526bdfc036ee55c4f68cede0ba212ee24fbc0073995f227cd49200a8060667dca31846cb240b5aac6466e7f3642e1f48d2cea93de485fd1e23eb7db35404928f4ab95e4b2ec5b9f527033c6d1b2b97d2fd3a4faec2f61203a151c173c14c9dab218aa20dbdd390223fb7f9f7fc3cd01df98de0ded41e92f727adb389498cfe4a23e6a3da0a9eca09a70899532f6589b86449b1ef8f9e10908253bc69f9fa5c42311fac2eec22937cb9caed55d733eed191972c729fe6a74846bb69729965061449aa1058c76e9909ffd63fc294c344a43a1a19a797ceb6017fa15517e62ebf7ea7b7b99832fa6a14920dfdd5e6e2b4de1cdd0a4445a0e8e671a821ec468e8bd525cdc2a90e37cef00cbc3c8a281a62894a4139e14b893b10fdabc9c17bdff6b326b7ed2829e8d5356412f023d7546f557bf477e7dffe60a87a970f3e0f4c882e234537ba346f2f57695d2be6baa8f4183917b49403e0d821906d4f74cfdba683ce163d973c94401b66bd66fdb6867496fe46902f66b06325b10bb6eab7ed03aa794f30646a5a79bbfd95f0e23aa3f76ae9dcec4354f937b82f6a5a3568c8f7183a9eb675574e00e86c9e82c8f7bc1f531fa61fd7a9cc7f98de217bb9185cbb9957480d6d039b51e3d81182270dca86f5c457bdeec896f78f82ca3fd62bdfcb1cdf927aad93a856a9959dcccbab020a5eb37e4a9a657dab2475e0e3d749b41dfff5b988000668dc7718a23f2ca7d917508837584ee27e3abbddb8a9071276a7a420c3f4fa8c4f766915150979db08b1125d3f3c19384ed56659eb9d5d0cf38a1f2cc1d23c7abcf22b37de6c1884daa01f1125aea302549ec12f0ddd9979975bc71f39371fc608a913accf2e28c756cf5a77a5061715835262669385b3e3755e35add7801943fe84339511449604f99c9a604f592b9c87d464e5509e74e4d5730da87bc7e05b9c399ab79e03082946ec8c302caab9f136a0e1414b4cfd314b67f6f2888775a5070f0166a6ada9ad20f2d8d08cf5e444e7b6fc9cee04e9386951d1170d524caf73b10a54ad17f75c8f6b674de55313defe50aa338e29aa12fc009eabcf0d01fa960a25cc97254d3cacb41cb94922effe304d6e49bdf27261cb425c557681c6ea220a0179b647323bd77ee330357213572ef6b6c562b094aa8d2eb2fee85b8595c4f87556690285b78f67278eb186bdfc977c2b60e6644690aad2f17de5f325ebcaa537a2af8d1fc3afd3581f2ea1245d1f2a6a08e2f194003f7f3ff8eb84fce3f4b4319333ee03595850e8365c7ecc8a0fb46f6d3d8678c32be22d99ab8c7279724cde32c852c9f68da12076eabbc0619c3f82621657dc26d067aa0cfedc269a7a3482969d4122d72cae010ebb35e4ab69b3e020a45e8daef96b81e77fcc2a9f2ef079be17bcb1755eb9d2e0c34361f4329bab986af04672bf29c7bb7a1d25055b813354031d5545f9760adb9dd558ec3cb63be1b1cb7ebf75851c3421af9837fc0dbcbbc1f6fa9f524f64b7f8e5276f0ba8fcb77c6ce2de792d2c8759a68d1a6da8a0c979a8ac747026301c03ba15b9f4db3336f32e61e6a05bf571d06f215628df89901bc5fec1243f8d537773c946544c34a0428011b4208cf2a2a3bb49e9934e68707d314bc197787c0961cccc235b56c770c6d33c8fc1fd70e6fea9b4f3277b6cc3d1c05183b2c3f5818a77a720f8c6670121cefddd4fb011f5fd37851b710d9c9e986e213fd6852d2e3baf514946e6c6334e4353fdc034a52320f137b072a2d23393032024cb13d72ddd8bf1250b67b470895742be68196fbc934762a3e97db9f93f9535ec9abcda5f6c731069d6546a6373d54b0e363bf65056278f498a6192afe0c00a32e1c3d7af618369c78e67e58b2d8ca58b9f89b391218a6cb3d7313bafda957e51c02c5fd1f6babd5a82dfdb5b88986622da45fdca2ee679557331677c223ab2bbe62b8e8af90c4b77946e8fcaf38bf3074a065bc31f1d57ec9bf3025ee14fbb7ad21fd710a739c9ae1c18d70892a7b323095f32ce83762bbb8a92f4655db208c89d709182fb1e12caec076cc63781103870d0d7d992180a04f74edb2803a89416768a98821ba5efaa0f102958968877195fddf41bf1183b8006797570ecb5cf53d8ac66d0a76d05c0eb866bc12386a81851e336ab97d37fa07da65396af221e1af0cae64bacddbe3526e24ecd6bdb80374dd628b816148e073eff1ac8bd4d3a67b73ac85ea26a983cdc7e451d09ded7eade5fa4896386266f5a22f560ef469a15d17203d63bb242d08fbd69a7754d2c0002333891709352c7063e76edcae1b1c09f68901c98685424f6c4164b5ed50e40f240474ddf7dfefd78d102503cdea1dbcaa36b03cb5e6dfbf9a54ed042ad2fd734a56c0b80d6657b51954f15ee381e2103162560952c2364c84d4116739336cdf28e417ec448626640d6a41f1822a752db5e37ecbd3396f23a0f1a1e8542d591d2e31055d2d33b1f24e5fedf5fda84be91b3e0e5b3e4d99d1a2472abde440528bcd43f51ea26f60dcac68b99cc38d57a3351cfa8b40230b32f632c569c67a044fd6b84dc56cc68858ba637cb36594f6fd5442cfc71817ccebe6db1f381f558d846d3d858897fd4db2a24fc29d73f6b514b63b66d122ffdbe24d6c0e50f25929ef6facb5f356076e94cfddde56425a765fa66653ca0173b567574354a313827e1c500d62e10935d6bacfd519d7bdcb343a8a93edfe1849b8e9f1ee066a1f1b69d5731a6a907295be580b2d89c7cb6fbd14ebd9fc64924fdf563c45bfdabaa0c00a49561f96a34cc1937415b828b9f990bb99804c4518917b4e64f84ac435fa50edb882241e4aa3e49aad782934b9c00036e458bc535321ada6bae7e5f1bace3a523c3da24d8498b08932d021ca4e5f7679c67d9ceb0de2b5deaafd3f310c6c3d5acfb7ded705f60b27aa6835fbcd22a2bfd66516366e4a61fe2a77f84ecde577f03064962f099b8912aa383b95b1b216040a0da3db0a8ef697b91c2dee833237c86162da2c07a999abf7763cc3d655cd8b16e979fa7c21686a2021982a0a1d10a7d2a74607d1b481d1e5c7fd32322f927c906cadcc4c9f5f39af0b9e418cbadfe9c43ba4834676eb63e9be9153dddbad91a2431d39d2e040ba8d1f2713706f12b2b10b3fd2d063af830cc9c6ff5e0cf4d853d187e790c85388576e0f5d22feae04600eb243c6510e3bfc023590b685e968a2a898b180888245f3783c1c029092362641de963bd0040c6671e820227a9597c5fe10ef01119fb7d6f9ae5c2b6146a3ba1fad5a14d64ab9a6d62a63d586524e44f695fec48d901dfd5a8c007a21c9090d34fd04ddfd346ca78c35d611e7466238f4901dbcd88a5e3a9c1560439ac5757a5895647d2b7ccfdeb5ce64a978c0c641db69e8a347aae7033f08fb505c910439d0760fc4e3c70589efb39fb45953ee1ca872bf4470ba54f0bf2076691ca0df67aaff7030fbc0e055a536683f593876bbb4b7236b308fbf4e4d8e51eb0cea319fb88941e82be03f3bfdf51e93f39f9a0451f898e53a38d5e0c290987b72dc5866604b06c5a5dbe2ea62575f3a5a0c8b9cbfb34f7bebda8ce44b53e05fadc2edae7af66b9af130ec7f5dc203a01ae68cd5723b313fd7f021f359afb7563442e4ee6cf5f04811a1debbf6f1a37762a25827f46e787a588ba06b755089dccdeca9a6e40ff19e6286502d9a03a2bdaafe07680f331da0ed532b727f75e4de50d821139fdcf07bd562e45777038939a88e836c7bb18a08034479f864c3e0baaeebce5fa93d6dc55406e5aa9af9cc853ac6bbd81418452edb9ea9a7078193d0134632eba0f55e958b3cd643a128a37fd044dc2c943a1abde90129084f6fa1fb961a768bb6e4c346e3a09d7bb1a20e1aa9115271818b2799fc8b1fc4289513380eee615f361075ea733c91e1a9fcc64e426a0f940228394f4ffd36f6b1b59653f6b3390cf6b3c3a604afa85650f792d644db97fb4c367a1b1b718a0bdb72d913199731402dfd9f1378241b290508f583955ecda5beac5ed160f304a4b6453ce44ada890289a98baea69dd89409d3d9a7d93713a35b4d0cb49da1ae737738e04634a04af49208b679d40bf80a1fc1cc1c2b64aa1a3d0693819cd051d88bb100493226598f44153708e6763c4dce01ad64801eddade07493c23da73dc91465376160125937850ecca063a9c82c34e88ea7e479c41d5907b6e85187977a6720ad1c0fb4075d882b2fdba3bb969b2f582d500f5cd139db86a1a872f997679099f08887fc03fe2187f23de788f8cf28e7ee9c46f279a40ed095fd143dbf6c355fa1759164941380d299cbadf14142638d6fd0d6da709b648340788a777e894f827d90d0709bc010ad125b1e3c723c0d6a8471dd55a58f72087156dd985deb9f1aac6a498cbde69d3decbde1c31bcf9213dffc0d5928b7136ee773e7042b6bcfae008dce89306468409271e7ec161b57f96886373ee34a70bc0780132ba803fe8526662da1202d8ed2c9a15276d20fd9184a17daf89d0592e597f44fbf2d0c81211bdd197f4c73c5f04de07e91e408e74e7f9f4140e9eceb781130f30b9d2e8bcd080769e1d41bf93025365d92b4b788d87ad2e0d4726f9bf666522e559e5dd60a3d17493c7fa270355b96905ec9f1e6dbb8fb4f03b13d6b8a35b5683218f9368d0ee4739e968d130326632d2dce3bbe2da3589f63c6026f5e434f9aa2f7a05afc3de5f65418ee7a7b464260b05d9444a3bed6f099777f69cf8a1ce7f68ade48bc35044248596ea5127a99ff34bf80bd302cf670b3869d51d19a2df1e1737eb0966e3971b96a466c860ac27af226e31101fc17d7bfb08522b08e5657d648563445d1ce733f8243ed05e20396a5b7cbf7000aa20a7d22a2d4fdd3f8f9bc1194873db4669d5945a7bdccdcba3db3dc5eb2bec450fa2fb939c62b0c7b0dd7a00513fcb0b07d315c6289af12585d60afc54c197b9b2da8c80ac93ecb367b6eae893dea6e33e01e81fcce6c9751f5ce26082b2e7f55620ce7097e4ae4b96c7595f5d0dccf05fac8cd04298bff7fa215de88fb19901ee975b1c8e82478714a2754ea8efd13477326bc51bbed736ee189b696653502f151547dee9450bc873b5eaf1705eecb64f9bc5ee1c6d61b94ebf30939948d7188d713f3448dc805fe56aac8abc0be543bca8c7e6c840200705057b70ee87486a7b03aedc91acfd3cfe04ebbc6d16d4b49f3f4de140aeb2cda6d284f1bf3bbea9b0d5d852530cd4cc54740c3810ed9c5b3cdec9c24b4788b7741338d2baba8dcfe9662e47bcde4a119e3d08cbcac4e63f893abf84bc58971321de17dce2ef2261436deb62a9c5467bfbe711bea79d7f622c10cfc422e76e6b2990c3641368a28be51729ae0d951232fe89c81bb19fb309abf8d1ee3f31f05cb22f552d711dc8d1e826f6f443a4e43d5950a3846824bc4be0865fafd39ddbb0e66aa2b697784cc5b104f538e9e00024e173140d01bd5e926df7bbb45a59842ec9473355caa5f288bc709808e73ab35208ae0c18ec1fcdc77db1e8fd41f32f145639e4ae5f8a95bd0d61e88078f3b93afc3346a490d070f4f051873144360025b276cfdf5b452a34a4b04b03759a72e3ef83784928cdffa270abffa1956a15c1849799b238575a4fe924e8d2039476d3ebbc827812baac1ba7071ceb03210c4161bfe45b1589a47bc47210c4d4f510fab901ba02ce0111da2ab506adfd53df31a3c169cf3b801137ce2cba448d136743915b41d338487e72af1c193eb1b1ebbd9c4bec62a2198d2b22634eba1ed9e9dd4829b7a8b06e83efd69a8e0c351156b67dad3762b51e9218be2aa76fdf8102fcd11bce0e99fe9e4ef4a62d16287a75b24ae2ba142318ae80129afb7d85e434691177cfa2a24b73a015b45df3b9885e838abbcc345d2816d42e4cb6db5e0195d6e1006af720d5aae875102efbc8b33f3ad78523b0ed64dd855c36044ecc424deec2054d4ec9afb136aad0361e282e57b6e1a9ab0ba59f7d9034cd6bfbd1f78d47db43680abe0318a3de84b0b93d4579fa7f4ad4faf543ce5a112b753b5d09c2d0451e66f8af4be38afff724969aa1a6c62bb0bcf019941f701c96b4b3c55288afbd45f8df84a01ec53934424b7f6d5f9a4e3faccf26f7064635cbe5b306e72e294e2c0f361134f95e684eaeea788bc13bd6cd46370fbcb3963d8f3aebec1a2fa52f6b644cf0975108581f7ce92b75e4533c6dfac1bb8d58f528d7c83b235629c455ddb2fe0a46773323cc81d72e25d5a946de5dd3ff7eeec3d506f8887b7af823b2d398e4dfd09d788ea64d312eabbbbd8912ccfac8c3e8d7771186034fa63da0d93d5ea4f23b44200a13f755b0fabbc5a2c54fcb00ee1eadfc48541f516bcc82a92b1fb3339c5b5f90902d92e206428776b2a808911921d010f538bcf2d8f7983b6dfb789eb482685f039e05afc6f29fa75cda664306eb8c05693e6e33e076d010c9e40ec931b9cbbab3ed709ea93d69bfa38b25f90aaf626b56e87dcf869435283bae393e9ae90ad13455a2db00f35f83cfa4879fb4b7e87d2f47a32e70b967b7ee08e54ffcd91c35448d181e1c933a3080a5e1869cca5f8e541b86fa1d5bbcbbad1e801c547797cc428b0dbe8b9f98c94b21e1e233b9a1098bac2ffbe45ec0c308e160c2ac043e914bb8e02fe636e3214ba4b6ac71180f42cca7ac877f959de3fd716a2d2abbaf9c0964fc1c266a3d88bc90484a6801edbdbf7e9516849000c291e6967968812297301aaa2d88bbf1bd0dafb93f4336600e3d0f513e312ed99cfeddbaf9edbbbda0ea7e79eec6749cadc323cea7f488a619ae3592ecd05036ba3508a89d8b0b8951ed23a04dcab839a12f970328b063b90f59cf78fe2fcdf7a36a9ad05d4b524b0f27284035175da17c792e595fc8d45cde29e56bb57d6de828da6d19f879243920948d7ff1258508f54426c705b47f7458bc2b56814c2817f0274eb1b81d82cd440234e9e8400","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
