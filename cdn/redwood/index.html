<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc00cac05a1b1ff8f661a14810d8f22e4eef575ea9c7c645dfaf98496c7b5a069bacdc2a10896bd2d71693089e9920b54493b433f9d3d20ba201d95aa487a309c5c2467e6bc77c8226fe210b72cdc0ac4603c9cc78952a3f733926d3e871d8b47b4f2355f7838c0a8069041ee6256393ed3e9197d3cb43b8359894e6ec76c693175cb14905a0f92283847d92c06eaeb14cfd06daac971b5d7b5d0c826d11b9354ea6f7d9741fa2d72f9a282ec4fce037b197b276fafa72715637f2dc8fcefff208f7a2d1f42cb5d86e0271416827d7020321e1d48f93782c3c92bf85f9638049cc7475303c615864f691d14435569af9e888dc2de23e6f4dd4465ebb3c91242c958803783065fdee0b2ffc4da278a1ead7b2a8d48aaa6c4bb2f37d284d987d0fb78e089c1fe22b41480cb0205b590316f80ab998dded05c841002871fea91adbcef084a8f910581af38cb71227d217094a0ee07bd57e657b2a5e97c8e80b6d28dd7e1e19700fd53d9e32f08eb0a5f2e0c097e784ca4b3cdd262d38180e4dcf4b5d447d2120c0ef858ba2fb71e5dfc3c90b7ec7c17d3cf982e4ca6ed7d5e86d23c10f86787087304beca994122347237212d105c19668b85c4c2364c3d2eb594ab8420f6d377812573a3f4ae9b83bf23fecde1cd198c68a19953c3f513035baa54c61a5548b7878c89281a2242ce6d3575851a405cb179933add15f4bcc08059427a36a120b7d347be3f21a7b24fb01e51a6b39054e88305fe255f29d0b3fd8599236b3bf6b67e77f147e5ba40b59ba7ddc840922449ca4e3011a62394a183460ef2e520ad87dfd098f3713998170725f9ca641e2e7e0194c0143dba3d3d4b018e919d3b3fe119fa18cb55bbcd6c832c2165d258ef09d58e3a45b8b013a9bf8d1e618e3ab7de369a1c32ee0e6d02691f80fe2fc3cc5901156f95f68da7a94debbfcb21f33a2f00afdcb4c1f57ccc258cada0ad1352f5f2db8743d58c00a9a84c1493347aa23ba7773aca20b3fe78b2b1769fe5dc0b90b8fd90be439500ed4011886556d0ea284b2b9c49390265d030ceeb01b7d1887cfb89bc7509ff6c43b81577d3a3781e9e356a34e5b7ebd01167f5491311617a544aa6b66b6a69aaa7ae73186e4eb05d77c0018848ef40042563673b02d20d38ae99394844d49fbdda8e658d109ed239407e17523b4b770381e9c3341514048de324a478e34d157d4743cdcea980964f8d75ddc29ecdae8b5d122b30df770d0eb94b122cc20f1f31fe9ac882c86fcf7325047f1adcd15e59405acac92cad2e51d42dadb2c999390d02a54b4f59df4487967c6d90415bd58d9744f6eabb4d7f2a6b28442e7f9ce204bd1920706c6ecdae951d07e6700be44b4e55481336a6dd029510607f6866583d2d8b6a6e6e3e4f235a2aa1a89f4a8c0e38d84f7cc04bee060098ba2b0b53a0545af8ec3d8e80eb701e66f86a681e04ad98806a268cbd25de8a21200398a23e86c8fadb1c15c5088be215636f43e16299db02c70b12250e6f976ca27c7a2aaf7e5ba71fe4181224f14fc669bdafeb380a901c294cb5d47311f0633adb190839284597aada326bbad6bad44e9b8373489075c2657a272925b566776eba5cef62d03afb3d0df538263b7bf1abae227de471d29a3eac0db57e196480069b0e6ad747c00a44dada20eec853bdfb4ab35a2fe94409b1987dfdbb6d36bf36e0d1b279fd82eb9f5413e218697ea52ec67202cb2faf3ce21bdfdf940967e533444b4da80cc50aa91ba6636201b4da4c9d7926cfbfde054144a7de8af66ecb96d5c4e0302b349f66b3a19dbdea8398fb932f31c4fc18120909aa369a78a9070d03dff39c97300ff7e2468ed248d82c0d44cfcfc35969132573cad4fcd6bf0345807a3d6a684582d9f22daaeb1420ff3ccd9a5601fa820dd5420d8ea3d375c38a5975dd62226a55dd3467daeac73d537a2aef1545c8da89bc6da1c517feb477b8543fd48c04a7ad2b76ad219a404aec632349c0fe3478525b100fe885ad89daf1185787a9709974a2fb3ae144d1eaa52d2e11ccdaa7642d5d92e61bf25b8e9aa273808b13e0d62ad94d175ba2db1e3fe927e14a6229eb6f5e8559f5625877505145402fdc4cc181fdf8797954352b13a98ed64e84af905cc334f5b3f9392561ed9bdf0005cc68d5ba5e2528746c77ba0a4f7ca4a93108a48d5b56ad03e047ca43bc12c74253cabc3a5e1bd5d96d103b90f3864cb37d92336114dd355d42f1d5cf9630e668ad21628f52392c8a7f9699b610cd1e885736c81d43fa0d9a850c72fb88b05ac3da40de2b5c8137c1e71034787e94a672d240b27478c43de909860f15cb9ed4f4d8eec176a8c0f27167c421b1848bfa22e850fdc1c26a0ea99cd3245ee5522c77edaa267861ca8474b2ab234116570b03addc1012fb0d474e5c95ddef7971e641157baa0a42c549109ac1d23ea2100f786601dbcb06d144f661d7c271d04438168b177baaad8ccecea8e744d5c2f08e8865c6d42e4d28c92341f16a649ab6ac0cf41cfa22581a9941021e86f0ef687f92b1fe8d2ea03728304c3eb77075f179d1d3419afcfc73d6d5920b38139792aac4e0bd0d3873b0a208f4c4d3002af4ce240d71aaa93e897ed44fe27396cb07d951c5373609c4a448b8c06b07f9d881dab079e26a83ec4d231bed436f3340416ec2efde4cd023cffffbb39602f478a67e190c0d93da1f87d2a61c51561c1aeebfd5620c3f4ec83d42dd08bbefac62a8d8684f3a68b0845ee76196dfe5184970798fa251bd604cc9a688af2793b2b9ede76d0f8cc64bdb6632e14e69db3e4044599c756eda036c0ae5bc7b619da3f83f2cfe45f225d828ecab8d26ccd1eda8e5e5a8bbfaf098a734ffa0b8a2e47ec178ef71bca596199873d6fb25f0d22cfbfd81261ea2c6b687188e69804f399f81483102d1d10568710358686552ad6f311f6dffd9cdf04162a139a9ad9a2de08a5dd8f98f500cad402a45d330b65a5ca241cc28e32d3f5753971334e07648f8f72408e2b384ae4651ada90515bdcf4234c8b196d7ec951f3332dd97567f0de6b8ad1df51ef79c35d8691919ff2b2c515ac4caa3dac8505aea260f49abed6b358a7c3aa0e8600616dc0c786c26cf9002f5cf5bbdb0089dd570e9dc1486dde745da81f68820889ab5c308de7dd5ce0171153ea501a09d4417ebff1532b686bb766885cae1338f618bb4115f8f36362c4168bc35e400524404a71711bf359b28fd9ab2d33b7527f664de777b76272ca8ad3a66190b03b8b4e48dbb3397e288dbc20b72493e47173d2bdbc53b37e859873df0bc3057fa2a67275047d0d9c6d9338b359dd12f79fda32836b2fa78a133ee75ef98dd1f44182f6f9f8b749987ff2da286524093106a6f0a25f650a7145fa6661ba8383d2e08e7cdc0eca3620bb5e263fcf8ec0a46ce09c595e4afccff55be39e54e505788a8a1503ce300e0a56014631fd38b1420074e2c1b1e08070181795226a6f619ccd4219915ce4bd4fdd81f2f633eef34be8841d2840298d817322e6060fe3425770073132e55df1c8294389dbd2bcbaacc67bf2c91a1f30d1651f1831ddc37257d15fc9a3d2c43a39ec0c63665b33676bec3eb6574dab15f9f51f51daf53f1f436f02ae4b94519a2e494f5e2dddac5b03b1ebb996be66b0200b611b1bd833b5d482aab4f8ed6cf0fcbbc155fc268b61f95010bc830bd40d7a243a529e6e0efeb0b0fb1b3e1bb864cc2482755c353354c745623748b4aa9435799d593df66443727d11301656a919ee0ae038d842d7bbb3953bdc207c37bf23cbd22e2a6504da76a1c94eb5f3f7f4e96b17de5106b70e9618bf68fcf812fcc2727ef9bdd0d5bc9757d0995e682236c5a063a30c7bed60e07cceaaf87dfd8aa88bbba2bf8d209f433267ea84e6195ff101526d694a903f5fd0cb712c12f665d418308477c2f1e697f1ea0a9e99d3a0005807513bfcdcb8bd94b6b7b58109906884de449ba106c975ddb5e964c5583a6ae4675c5dfbbb157083d203aa5e685279f4d7cf18436a5e854d2e2446d44b46bfa84becab2a79a517f0aae5b0b5edab8404ce2413432c5ad23f8b00e50bee77e8b0d8d909b9afc2e7fa9bf86d613cac0e74022536586dd12f43d26ceb0e55852d5a488292169afcd5e90a05b61d01b343780a5ed29b2ce61dae2b4ba842e2e5bde9df6242cfad432dc8758fd5d3b5f54fed398ea6f0a83a9c290e2ed3a268390ab314338e4f77a38c7769309012927197e327d91e308587b253d0b73df4845ea0aab807a5de61bd544a542acac7d0a833cde4c9402e390945eb9d2526fea231976e3502d4a282b4c45289af1bfa57414a0875543025022a364839fb6044c27db8b12e11494a46c9d8faca671bf7d33f370098770fc490fdb8f619dadfdb9799956fd777347e46a8de2c78dce336718bf6bceaf98521af5dfc2ae98565624f99cbb2288936c312728561f5d5a9de8bca739f2ba17a59078ea9542e620b46b1aeacd75f69c8ba59751b9fc8d9f8e28f998e2439abeb5094d1213890af3d6c767115bb1f2c5594e799c887cc34eaf0c4c7a2fee3922522db5ad8fdf5c04494f53333af4bf5e89ab6888f0a1d04ba6b6f1560abc6d098344ca390333248bf5b4ef03a8ae6c117e1169f6b7aa33f6c17911c5e1c5ab11d65c8cea4cd6fb6451c0b6a0053ad93ee728002e6979d2944270d4cf6dfef3c6d670c3dd66eee15c29e6c5c79986f808fd5f1fadfedadd3db32237f72d9639b11a95ab1b48ee5a444a4af0a7013e0cc2373595e64e27ed7108ee0010271c2637274d5d2db23b0906c4003b67b21f31f66e8e8a6da0acc703bf2a2cd504e10e499b38584e6a0659595262ad1c1b896fd71ef9990bf773f88b16afc6bc744e39a4115b78d08a365440d5a1dc4b9107c84355a87e47d72c10a930efec2bc3f6f194c5ac2cffbb2e95f0e14fad7866929c03a4a8b8dfe82050b8c6f7c2161cab9d99c135621601038b9259126e7f80e9f7433e6b5d7b8fc7c0720198e6c72f66bc858e14fe52fb008dd18e6154667beec31002c7264b9deaf9699599b3c538f8e8add2cf45d013a8ee66bc34d9c8724e5e55213ef5ceeb42685ae30d10d9df656307a935a21b6e52276d91b7130b85f96ddd5283eac5c2114c6e74426a4a455f6a2df0795cb798f74ba9cc70d9308016f14c2cd09233f7f90d6feb37a5a508015e5912f66814c2b727ec50e23a03a905b035faecb58a635c950bf474def1d2c1fb0bb05dba49d9d654788c05d80b7b13ed25b86b11efdb4eaac0991785b42d26dea992185965eca6f8f75314b11a01ede442a62ac61328e00f412fa4809c47eaa525d3169952193127e353fa419bada6db8f3b6ba87c41e4f96bcce76e55a492f93ec86c946f308c01efb6c76829a93b626050b4551be92534f32a06430ee1b6321fd02f228918de25f4e322cc88ce8adef4241ffe0e635b0d483957638524114c89e479ed9bf3165fa02d35e9d3a53fc23b55de83667fd46ae2e696f249f3303c7ef65f7802f01fa7354d5854f9a3aac73cc1d6b402ad42ed7b71919f313997d2e427296923a9274f7a8bb8a4938e043954961f311c07973ea35294e6441ef986940c577ecc716fce8c5c4b6cf9b5babfb46c9e28b91bf49a9fa03ea12ef89fb9bd510d94b8634d73f741d130320195c8d7894b777dff56fc5a31d3505618c92f1b77cf3679515595f484178f8b6d9f7f53445ec3ae3c06c1806963672a617602b3b161b55f1649f60a94a22f91570012ab134c71e088b4cdbd9e75d2ad3424e3fd2f32b4d38662f314fb29d7a27e8302ad474a0818da81601e1c783dc9c97afc4bbb0d79682707843ed4046c8beecc8f2f06d773a71be89f61cc1898b859960d4d8f68f6e26826712dbfa7467cca33c454fee25df1c38bfe2a9d09cdbc11e9eb9bb27b373063ce926f08827116a08e2e8f96b7670ff93efe073fdb9a1ee3be6160f544c9a9e6cd4de6d8d2f8665b58f5200f1e289cd638ed64f1b27b92dc59be87f041d17e95deb2ea4a479bec3ac9295beab4a818d5d3557488d7658447c01dee1edcf998b1fb4f5cf77a7458f987a559287b42aa917263acfaeea2388795b48152c7ec9c3aaf52059b9e437c66ca2bc39ba8674c8161a5f9061e776115be1bfc0509e83c4fb39866e5537b59c36ae3697b9a4fe72f9ae9af746f4c485ffc8ff129b58c99dc308483cfe578397ddf04b3a50cef768d76e4ab3bad63ffe607ad3581c82296e6462c4e65d15ecb7514fcc93ab8c48a3db0032e5490d234bfb15f1b102b62c57f2f6f2c255d87696f7fdfdaf816168d322ef72878ac5a43c63c4693082594c6217e34bbea80750a9f4eb5d92306e8613994302f95a019a941e67efa84a399bc91fda5ab6b59d82c3e116f58340ba9e8273e7cea4f1201181d877c2058e414a1a03b81a082747eb5d0ff72753d64e9fd0392895c45df9b0dd454b7bbe8944e6633dce01d834f7c9be8269986ac7661994f49419fcbd212a757153569cdfab113f26065eada54a8e5d70b48a1ed345bd9c158c01152d24767f6208319b141c81f3cc9584563cbb3609e5a3b3e55d2b5fe62b5b54cf5146b2c0f211177761db4ddc229171612e2fa5710f198bd191949f66b2be6b1188b270fb8b8bc8f2f4d5d6e8e241c545fd704bfe2200f196b07a6612e335a52b8d008c1c4a4232cf7a58cb308c17778d0f84e60342b5a0b9c4cde11f306c58740b3be943fb6d939a45ec160e42cadd51bc66a84355969e321361eb1a88506b2ad071d6d01a73fe21df8487cabeda5cf2380db5519f531f6ac726c5165429b85879773c9743cd728a6c2dfcd33f25ba58bdfd7eccecce00510f0bbee86e009853430a8109c5eb2e06857cbfd035a6781296113cae01b15a8b101ed910bad0538f37597af62a0c07022519e91db37b70a12655fb1ee1e4a3594a90f6a22cd6e49638e0190cdd26b42497b994f519c937eb388a71b522762e5b2e14d2edb2fa12696e26a447437f4ead52b98e48d55bc401fda4f70df53fa6688e984bf081188a7642baed3a97560b62039b07c5f6beb770d063656752322f39788aa29c2e293db2f9c8eb00682740b64072d2a3b9d943d71c03b2c6f36b6990338a699cf3a4fb7d4606e89e8369068e8d7548a034a0e3fd263cd0589986e34cfd0784ebc6a803f3e4333db3ca83e59dc3e80cd8944f9c5b22fa716ded280835a250438de1ff115511d09b079acd8b6e0ef734ecdb482b1e6ecb479070a73b2d61d116d1bffe49e0b4e050d57972f4573b83d6fe9d864db5ad7fcd321aaed531d6eed73909c92810c5f72cb5159059d89caf27b4151e2174b636ba16063314461ee36c8a0d24042bad85e70c593760179b8216c371d5139b3a11343d02501d73ef2efc03609f1f9b68555acd30a5442ecb46332b4296e82aee0cbb8340f0636eea11ef1e849bd683567c9e3df95620f4725ee0718d10d7f7688ce90788580a443a9bc66421c5ff5571e72041a85a145dbe895dc701616e219d451974a9c9ce2c466891eb376d3b9e0c0ac6443867c1d2d697522b6c6a9255b6db8a01b52d20ae57fdf285d8a4832ea9de3484efaf2e792a7a9592f4eec803cf8034309ac7d5cbdc2a67ef175bcfa99e9fd9a832ee8547c8df1952d2518ed46d973ea72ecce28ac83e000e260f77a34207c9f50e889b978639eb3e4710824e69ac2360959ba0c6f908c5d87ee673fd3497df87a3a5cc079d5c2b704a0c0391b5d6c4961c5d1b4fe6ec0289df1c380aab6dfe1d21b7577a5786ad3d4b1005275ddf592c9d8c8b403b97301dbbb1070776ef79a2cc716aa45447e1aeb8a5551459d90bfbf367624b4f9be5ec542ad0da876f11d9d31fe9b2deab079a10880f504f46c71e058f4bd99f4ed0327b00edf868bdc57f68da8c6e18bdcfd6799bd758bcfc66df1530ba11a9edd73fb2fd20e8a32648e2cef8a9e861a0f9cac2910f91d411efbda8f37f39b2f5a60cc7cb3d3117231b85c0ab33dd415e5290d59a51ba9cc8a7b464d1e1871d76f8c91a62c83d73419b27f521b5f3e4f76afdef5888919c820bacefaabb52bc1dfc927408fbc8aadf64f428313cb8b73329bc39dc02a233300603c43b6cad9847cd08fc8404acb5c7ee48478b087ff80916e60ddc51440e722a7b1955ef0bad6d6933c6cc1690cafe35c1f4deb50406062f026e29e295894704a82c08d1c185c8aab86f7a1bc6c6877b2757cfe26b924ea62f51da5bdd93bf37fa0d4a0bc67f4fe9f643ebf00105a9304767276ea7a31105a334d72e67a3c617069f0717de9866486f399cc1b018b59a0688704c5fffd2482f79aa85ba9d144a6706bc7b32cc84bfcaf9d41209d32732d4534bccbaa32a4d65153765f50d31b327fa1b1d1259e3386d5465ba6971dd84018a5c5b38cc02a2d4c336a732bae603edb2d58dd5a6b2ee04c7d4cc77654db38698b75ec00ef6f71c375b066452c951524db9ab0649d44bcbcb5c3e37c3784925c2a1e63c1b26142ee212b4d44aab143f010cd5129d19105c93f35924de3917bd8e9df0a33a5d842a8980c971fd25e7fc3d1e64f47b94624f592bb2330acd6ed89c1c8caae9476f1221509e18eddbb11bdd1d25098035e17159a06fec57f5cb489c76f92af94d74579c866cfda98120a68b5a4f4a3020aa3583029232b25da930e988c99f9ec6bb81897b94ff89c603aee7c895ba4f0f4ea25f151f1bbf87fe3fe4b8507da59f829145e464c7eb5ab780ab5ed5b43fed203da76e3a30dd4dfcda2d2125d06d02ca019c6a57d57662837fa320fbc5bbf05e09cac07ac1aba698846d13176ee3681e8856bae34f45bcfca74402d0c94e7e3b1a20e7fda476609609313d471ff4e78d73f977b1e7cb04c598b48a5cbc6c821f215bd644e40c21e2425d01939c8939f285abd1dedfa694c158161ae7e795c3cb6abab706f45fa076dc8a7b33bed21f17a477b20229652402fa6d9aaaf6ba4c07fcc235bd4e1af134ab076e3dd3dbc3d8298d98af16e292e9f652b36002ca5dc9cb96dd93ea76d95e6fa3d23266fb6ec78716d4e5d19964159f0ed4df511626b4113fdb4afe818416f8aec131ac9d1b8611a40afd1448bba454e0545b9f3f9c42d32f5f9f3a93b200ff29f464bd349906c61c7aa995ba7b207755f51c89f984196639de75290c82382b11f7a4318714d161935ba692aac316ead4920c6dc0b21845ddf53ac02163aa902d3caa9d961968b89fb20e24e90b764d892e4f1ffe13876bcbc38648ffaec6be1d1c54080b818a0d7ba2c265bdc4b44e03caa4f837d31a1f26fccc75cf63b9bf5a6c766a7e524c1853b79f2b9c5a0801f2bce2b6eabdbd156ae835a8284fc98f08b7b736aed8ff9d9ae69ae30020495c26fdcf49259b0aeac600babeefad67caf38176a0227a2f3d880f5dc34d5b750eb4d1cc0892ab7c954060a00e1110e218ddb1d7bfa228a3f15e3caf8da26eac732b4dc47deb874c5cdd0e89e83adf0f9328406975b545357148ede2f34c02f40b6d50466f9c542199c31580508c99b677cfa46c62480cfd2533f8be971433390793fabf3380b31d218c739a03f7dc3c5bf2bf63964d56e997c4d3f615c997c4739726aeeb53347b7f0f1ce22b01dfce93eaf6998e4ef6a709b2872eebfa37118cf32d1ccafc88e18d8b45a1146b82cdf08bbad8360de0eca1f21540dc1f88b29a91479e9a8c683b83fba70479472167bc2528b644a96bbb981c94fd303faac24501443f96b40d40b2c87e70381d8b42082d006bf4899a9ef2e071a2c2c861c802c7ea7d2bf2b34b81d8765aace89a971ede1bf34b0f67176549b814062dd6859d5591f2e805450d34b22f4efd13458a9edeefa7e659047164e7c273fb895ba51024db78ff96a4d762544a18b00c75a6b35ed79b25a863352b8d5c3dd35a0049007705a79e95df5c7e27fa9c6d46b8b6d69323d3439504f2d33256bf1695ecc9452661c1daad0a2286af47983f91913c7b106177e8fc5646f37bba9f37054f48cdb34a97d8193d689fc38f0dce68f599d8176724a215df8e5b47a9ec437b7fca3751ca3b99908e9328f91a0c4ea2549aba58d57cde3066f33fc8c18792ebccc3de4025d56b1ecd81d408ab4aa04fa3b9beaaa64d1bf7302a17015c7b06f509bcfeee21a39ba7b8bf65ca470aa48ebdbd1f9875975249e4410c9613d75ceea95802b7983a6a8b68b121609dfd5907d62fef57047d703ff789a50cc6340b64f26256e839334a02e977e88a53f13a339c9265a0485a41dc1ed64c588faf9ef57479f2844fb6f1ac3a84134130c1837b27be79e319280ded9d200bef3e5232abb149adf9493e2165404288f4cfe69b9d95dd111e98d8df951559659cb9e2fddd6ec5240c1582477731b966321563f1324fcdb858fda1feb8181dd86670bd14d02a188760e0cb1f262e4207a58dd83c63c4085f61bd3b24e365eb8a441089b0ea695235308a9a200fdf0cd31aa4b1fc95eb90d0025d037e034dc2c5d2083b381a64aea71ec5ddf8b47620f5b2d00616a603ca6b5874cc55ed3f7804ad2ba65dcab6d3bdabda51644507c3bfc0ddaa5df0cbda4ad640d0ccac4d1421d0b828c3b84ba12f90a1388c7d6d2f998fd0461e6c3c0b77b2d4e50d60998107a915cb4b08bcfe79ed6c9c684864a1e2c9d372c6658b7dbb3ba2c0887ba3db8f1cdc9d1d7fa4251f1ac0f775179a70dc2559d40e68f5d98bd47f64b74dfbcf5d7a37d3fd0768c34c8a2dbdf20935be4acdeb60cdd2f01121341de423e4ea1b45b2437898aabe872cadba152c76b32ba67d3849b95b690ddbcec6a77b12c3f400b62b00f03b6f86227b8ea33b697bc9e8fdba2d53deeb582bcac58ebf5ea96da58fad88af50d26c655a2733db1f1252835eaa014a431cd13dd0f73b2486919ad1de190c62ee6d154bcd1a631f8036c2855dc8ef31c08b70e73df95af28042e9945d309bba51952a99f19d4e00f1a9ef03bdaf365b845279640d874f59b14ad188a718d32f0a17f7ca9f0aa69aad7438768fc42dc20cbc00d6e00cfc97f3b020b00307fcf43cfb30deb9e3aa19e663947e24f2cafa5cddc69b366741a1aede2a0c2b389f2b5a836cdb15f60f03b6ba51841ef8a571e6d19c4fba6d6e79f47d3aadb507d5626e18f7c8842e695641295e513466621b783c02e147234a1c87610c5122b11955320d3f2c9d4ec342514a1180d1514d3bcfce6dd5277e57a5fd5c38a1006bceec26e62adc95cda8815f654ebf2ab9d4eab718573e73db940e4119eb7262497d77c25cf7f3c8fb3198c8db1e3938b0bfa53d84ce9b8f4c447816fa8ecaecc473e7e7f5697d964107d6bc97f282bf06fc2a740198e66e5e8a15f2410964d3fd60fc7e803403c3a74b37f5123419f0e8d9b294d8eb14f7e72cf5590471507f21bd17a831cf50f1780adc617b149f92127434854a2e4eb8db9fe900f9d57f8cedd60ab4aaad5af99568a1e61f8f6c404c5134994b48d7a1f8ed40e948e856da78605c600797a2f7d33cec5c804445dd33f8e51246f4be5184836b39e81ee8d94742d7295bb0f2528b85a4d45985c805a1e8e10a76b30030c51c8b98191a16293cb8b40dd77c704f03cbea449eada752455c546b02855476374d99ea0891851cb61b2d0ab4df2042eca8a7dc5665eef426ddff585f56100d4ed419c6d13aac7be7d5a8545260420f87fa17cb1f30abfd7eedce2c79916590615bc45257b45728865e98bc0cea23f03e92bec105a9f231cec36224415757d070c07e913b85a7b8d0e6d1ad9f52fa755189e556137e4a32ce34887a6de7e6f7ad7f72f841258706e41eb1af3f8ea70721bae741044f67213f6489dcb712c43602d22a2e219854c76bcb26f49ba224a88ff70930d00737138f29467685a25d405cc265dd19c93c774e37baff735c64cca4aade54c2c96e9f7a8b4da9e342105eade69e43e158624aaf5f6937537c91c9840a78a1aa77420a611ffd3696312afa94f6591794c4e6beee03e3786619e6af6a8e8402cae8a3498acce72043436162757c2c5b8bec6b0bd8e04fa379dad9f3e4394b62d7adf9d063eeee714f7c06958691020466ce8579bdfd0623ff48f9b9a4fe703f12794c4539e4e6346fd9f15772cc073e3f11fa1dc720aa2080c501297c9e4d4f1619a905b37593c37d7183f2810ccee7ae09cca020612b9646e828ed65477d31a7a18d42ced7a09f2b1db3826af0c45ea679febd539f04600a0ef7dae57526f891d97be6536ded69cdbe1314caea03fcad43919e252d4d7c61cb54094b064bd8ef6d31f1d7176cb4988cee56ae49df44f33dcefa4111bfba19935a3eafc6c5bc10b936cab3853561e0befa2b47c855a07a3de7acc91c1cfd8a90328cdbda11b13cdbe0a609a573454a8ff632abac7108287d92f69c10163f0101337b6a0f5809adf263bc16291a45e85bce6742fbc36d35bd1ab517d5b0b20b38804eab6daccc04906b7ba11d71090d31cb63753a7cd54ec7b1227e11e722378079a4d7c8ce9c844996c34ebf59963e6d3cb2b4b51d4943f95e28e4c3a9651a757b46fc0c58c9352aaa35fabce2cea352ed5efe5721a3072d6c5c4b1c2274c8bcf00aad5ad961f5e75b1df083228cc5f015dc05ece71308ed68e5d2232d5b91e6f7229181cf284b7d7bc6a17c5dcff92c1993b733c5ccc4072c61a0bd3a4fe0cccc1385873632ad9b7f4225d4675fd0b7d85704d12350d67d6c113cc627d57c259ceaae89e1c24dc2b7a8d5a1e14e11e13ef8295b3e7e8a01be7c4ce7d10a05ce7cc688c87236b2d5826fc25fb5dea851c9d738c44ebdb8b74843f862c09e255a79739b702569a7c2ee8ee07e435b8446f43ba225075bcdfcde9d34552c586d155a76f2c3a30bebe8046d52d0a1cd4c5e5a73a577d5fefa38a3c6b69d0cf4081d58dc4449881a7f33a1ece72e2de88e537c1130040cfd849fd043ffb06a9229f9b93df0c318878f4e03ddb13926334fac11ae8d5c5d154625098d947b7ad229ddff842339a8dfb7f81af057b8b30246e004e172f2b51ad61e9dcd92ab647449aec6630c17b9bc82cf170cf723f2ba79569d319e032273768dafab57fd6210f162755bd452800afde8475939df5387d5262cdf934b374197fd32997d7ec79b078fc1d7de1bdc7a712b66ea824dff5fc27e8a8a4cad4d4d42630db5dc724f0986d6a8d6d113ad6962ddd5f580c323b679f3cfd651fb4fa01045fa4ffdd93930045713ec8d37e41443f4c5631ee9d248586ec7cb526b4a1927910757d97e8db0e45fb5407c11a343919642c8c302b0ec877ab9bb390800f56ffca78846b063186f15e0f29fb892fe550b5db3316570d02a8e7d08f043b668f25acd45df3bac30d213d7640e9795ecb628fb004ce1af0262e1f1599568f1e074ede28633e54b6702cb66244906c11862e024ba0fca8f7dc2059861911105c934cbab33b05e6e2e1f0ccd8d9db78ec87a801dda110fda35f405815706301105d56db47b6c6d29e68ca67979f3ab116c22c314dff5f009ef117bb836aca0f2a95eba89c4cd41b9cfaba799ad6b140d8c1b8a8fdceb13e484ab440bbff753274475bc9f16a17b8b39b982b1331d4ca9cf4f240d5a76d26ca4c2e29c48f8f735eb7880255b48a0c6f3469272700f223b3008cb71e9b31413de570cf00e27f7af19adaabbf1533c3484dc81c1d1d11ba26699d88094defc0b03c75f7496beff6c67eeb46cf7744d5c04fe224ca165c484f8de986a44ae10010cbeb98e3efbd3124f835aca199b2ce317ba09c5d82472064ceb3c32d1001a4a0f62b395fa872dde222a0c18413b87c0561170b14cb2293583d01d9c20b5e27153763de3556ff0dd783a773248bb3fa12a456f329e772e37d60b49f8d62d561b9ec5bcf8a0dbc63b6fb328e9758af619e6ea454495fbc7996f6eb8fd7e947fe5de22274f064596ce0109a97721570d7a99e50381b9f8cfdbc345784a22d32467caeabe7f8fe3a8b83dc6c700b9c7d5f84db7ed5c5b8eb2c6daff5455cf87d7ca08d3bee5757cfa9a94831fbd88407ac5b3ed4db52cbd2e899aa42a50ded0f92fec934e2afd48c95789deb7f7e35fae541e017c5d94382310e4b7b52a8e14289e2a0a2b56368031cfcc7967975ba7c2589624c9ca08a6a830ac4d4f419936b2e9513bc19d551b424c5815a89fa3357e986a66affe08e15cf755aa9ba86d06a9b82df6afac82b1e7bcd6cef5c6be1c97440c83aa531ef9fe4ca93624e016e2b208d7feaa84055ccf1a9fe17218982afe864260303d5f30e5e2e5b5f8e59eab6ced4c0ae900e3690881c1be536a5c78729c3a9e372b1ec9f88fa5105a78b1a989d2d6a0c2d8c4deb5aa6dcafcd39b6185eab61e0df1ce6a6f06c979264ee982724f552c2e7c58dc051937563f9c85bbc441d75caec52bc6b8d089ca434bd49087844210175803a7f67c9bf5b502f49978eb9c5c8d62d80a94c0e8421a05e83d62f009ba92fdde69bdb9758bbccb1caf1b34f930b87d22678e73c81919cd2b97d5f8fd2cf8d1da0ea7c75ee64d98d1d72809a63fcb2147e25ed98f88cb0aef797e4f7df32f6dfaa913a97936b7d2c6f882ea986d4cb0055ebd95144624e79f09b7b19a60fa67ff96b7ca7535f2845c93258e9d48eb45194f0e54fa4c28798491db9d11917f7e819f1fd76816dcc60c94ad37764f9a4bdaf4ce63fc79095698b7b94d13106a64ec0961b9d7a28ad0c8e6d4d2080e58ff57f17f5481687729f00b97339b728890e21239e586eb274a2a6a7c0465a62ff63347cb4c73440532329d0338ebf74177d83ce69bec242d94fbe3fa9662af62ea77c6383ff61836b2092e865127aede96597bdf4ce79924b8a7fd155106ee0939fee7b1ac80959d0659406c51021b6bc07d3f564dc929438d884aac2a063d8859750fd617b97995b82d6c658542bb0a5a4733f4b7efc1b4d7c6136802aa4479f375e226c7594cebfe425469e5cd94b90302c7fbef015878935a4f2a86c90356270225e653fffde403db63b10b1f688c8f72e55d1cf2a9bfdeddd33c8aec73ae30e7be0b00480fa97f0df918766c068945ba857e0d6323675639e4292cafb062bb837c0ef9e13810d4fda3ae0ad2a5c8e7129696ffced81b395ed47f5ac00c4300898ba76303fb528ea2c4f8618d28138c929a3a15a9477fb243f690d2130b8b20d746404370d19e0bb6639529d2f3bbeb220b14efeb35522a2cc67cfe2f7a5cc466234807c0081a8fac46d914067f0ceee4662f2c0afb46b0628e33fa7e4ae0b0fb7b8d98a1058b74ebebb9f64cd755726c5af858de240f0876c389230f9f3f2dd08eece06f103615620688097e29530b9f70ffecdbbcacc931ed5835dcbc5191cf225394408434baade5f6a55e879f73b34045258e17107f84d68431007199ccb299d50e11c70501f6358a015968bdb49e0caa2ed3bce370c856b7c55270924080da040de137e7afc22cd3b9d5c0e5780f77a22cbb7e3000711dc384bdd262f9996757073088b7e13e88115c6b19cf4a925d9aaf58ee1cafe4a35d1b0a6df884f2dec84db7aa43bd3cd3a4f311d7ee197fa799f7b887e5abf524349311853b6028b3d0fbd3293258f5889a44e0e3fdf6b78ca858a3e59bc8b82ac4cd4fab5a699149737df9e121d12138ad11336820cb1a9698dbc43e40f58dbefe3f1479bac4f4f48b39a28422af4c936a931dbc13bc0cb4667dcd0668ef0f1400e3017a996d92c6d2464292308b8e16907b002088526c8d491152d9711e4fe8c57b0305dc28f5e879535c8920518b4268b67e6bb0d4b3da953d57723064106bd32262d8f288b19aee89fcfdf1f82371d7d2943656e5bac3013b8a6e8821c6e9e2e534bc24c8e5eb275996a1001877732a0a1ab0c94999f42da2fea8ddeacb1631b4ebf737b3a17ac90da61e53b46ef32fe36db3a47d4c39f4c00cfbd68a98912e5ef86d1d3dea5e247841994a237b784a2f3b77b8f53305623dfa13b9f890f520873f1d0193106fc4b57d4ea95e87260cd03410c69d331116ce0b95a8b07e45b4c475c263e88340064e9e4787e7964d288a2917ff0b5f6f3558ea54792f00d0ff3d8b57037fd49e0d27f34d40cd180169f456633a29a4702dffb4c87a36b00b857ad84a016c71a44b3c4265fddee0e9a489a31ffa4605bee33d17a06e32b2bccd12cc5dc8e27fc9d58a46d943373a821772df333e46fc4a9d453f76c9560ec031d804858a592c7b0672863bc4159e9409bd1712443fed45f930e56c61111f02184e9ce0bc9a34851c7d4fba106e732004ce4e6706a251b5df5cbf5fbae5dc41ed2bb7a39e2bb94a0dd0bec1c3878058b37b4836e73f2f5c4683331d2d136ccf6337ef542767ede0805e554330f7e5988a9a620c6a667a1db1e3b9d6e002c507b9da3e150dfa1fd697305afc886ac05181bd6cb2b3d363441ecc5532a4e3cd38430ab4a8dab62926b0bf9c280057a345b4b9465b0e37ee77eaa06575e7bd28c724507f7467cc8ac868bacb11c8e721b72a49e7c403c8c334ceb7ca887ee6a01a1b13e60036fcb191be974635d536ec617bd2d818c1993458442e16420e6f05cfa55618f0d7bb2f8582a938bb37e7859bdf087abb59270665c0ed6f9f58492d2096e06c0749b8d7f3a242f924888ac445ebc6043a7499a70d408ceba34684dc6e51ba2be67c1977b72925132cba780df4628d501e8896daeea0594ee1bb8a8b7ccd500a65a54ffd66d2dae1e36da10a8694f9e6f690df6c4c99f402740e2b134b4760240fb255b1b144ec37eefa7e784ba177d5e747e7890abedbc902bfd6dd9fc3bec0d3cbc13f0900101fae0354a9436ba2d767ee39bb4989b5b6e3470e1905bfea4989db8d565ac9d27f16e508087fe74b8ac4d7bb04f38c07af77bcc1eb1edf1aef863ac7237be58c258df341ee3c793cdf3117782b58ab85f08c136e087fe5ab90df59e03d04674bf2b10ebc18e13bdcbaf7ecef9538c444d8d3b41042e496b998eb6f2889d384c3f47da281ccbc0c69360d0a13b2d49542aac7274b423696dd468d293f387af463d98bb7e794741955fedf08523aedc65c97537dd4f14cfbc245436cab71177cc897d3469683b87990cdc6a208358773218445ea4a86884167404a31879973647fb963bd90327935c069b544ac7e396399569a9c93350226822730f1df55205c208823222c8611a5d199c58abc293c0457a7f604cc6848ff9ccdc4df23868510aab67c16abae027c4afc64b6147d9e503f8aa112958b777c7447c3988b8d30085d52e3016da0756bcd218ad8c808e4cd1cc45967b497ebe10a247f07931c8e5043efa2bc9628a38f380a6841d0972cf90660f07445cd01e1d1f335656950865a574b5f177bbfc0b7055445c3395225e308b9cb79bf2301ea2a71c1e3c4e8a160db24888af4867de5eae2207f04fb4fe5cb5680ef40b44560767b960ae2fca45ab51686187bc056aa73fc3599c431d64697ab9f47364edb66785df4ac91ec245ebf19d84e332ec6f5d199be9738de4d1b90cc9c08ce81524c10317dbdb4f014a27beb166e736e103428285ed5002f1bef1ee8de5c075b2bd834bcc3ca6527e2698967e5d22cf2bdd122e5951e9bdc13d0b37e4bc485621e32df0c43cf30e9e4ca83548fcb62e53679a021f00f61d855410b330b5784d9697b3f449f16aa6e016c9a4223a586a1c7854b2159e9daa5dca54e5eca541ecad7c2c691a95ecec644ca49aed8fd808821ae7d7dd6908f8c099db73614eb6e3fed91a5a007dde6a56f79ab55ed738403f2b559381b25098f4012cb4216ca3c35b8abbc3537da4f62747669aee4dcd393eb73f9798c9e495b6fdef792613865377ac521f409c35988d62f8a32f04c124887206bdacc4b371d7261bc0dd7ade8330caccc6a5db7a64ada30f9ea0bfc2005833ca46b1281b5f0e46d1ec08642f7f60b6d0124ab50531dd7334d0ade11266ec4ed7b6109f197ac92c671e40dc83f72cdc7fbb8c1045a73b9f88e7d801daa79d748a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
