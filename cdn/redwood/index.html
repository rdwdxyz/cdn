<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9fd1c9b6c52b2bf15708bfcd9aa5f14c647bfd35e9a2783fa2e1771079207095edbe1a67cf75ce041e64b3b5086728c3ccdde6a27d76df924bebe0d0e9f7285118e4b7c196065893e299f5b5ef7da7b425ef1072645a01df9bb2b4ee9e911f841e4355018660421f480bb9e965670f37bb66bd2587482224e4b207a69d27bdf22eef1e2fcb40649263a08e1a741776a4d7ccf59159497f3a9c9c8c094bdcd7234a89a215177a2f96e6c38bf444a361b563c1fcf15781773dd502ec822a9bc8b801b3efb0e486d368f162d5faa54554b76a3778ef0660bca955a43c206ab612943866bc867a880abbaeaaf8f0afe2ae5e641b7565b2b1f5853bcbc2bc0d48454ff3d3117291caa32102be7cd2f10d9e6e705b157380dac3591f5201cde42878cc51cda7a0dc8ab22b66a5dc328d0eaf0f13acd09e73018957a84e84061d7d4f1c98510581165dea99b6e60d61d82b09919786a07ce1fe17e63537b9a61905118fa22083e53fb7bd2ee3ba28cbc8bf8e94eb92fd73e10847224edf50f81d54705dcfe8fa6dbb54df5c8ce92e4625dad6ecbad46fd74944397dab483f711a4354e15cf78e8f239c3014115e1b67d13de9a7b3418e38dfa04eb308b1c71af54ef2746c4b192353759f6a3cde299dc4c2a413a0b9a2310f15a0de645df5115e3b88c412101d7edb79e4553a195adb37c66c20e50c535ab7ec56b6c38861108b194da82083eab48451d732c37608d080dabe32eda349749381b73986b0183392f376ed14df1fe412683e3b7d3648f045666d1c7403ba0ac015a48a2ee46249a29e0f322867c18ed5b42713a22227616dc5da561096a4cf71e44aa9e887dfaced791ae9894062833613f468ef49a0c2b6cf3e83f96b8b99be0d59480432a56a9039cbfdd3a0b819ba6baee285aa6d8a9b1cdaf1bd886d038f215f0c7e2d369ce43903053e3df0cfdd30cbae0346829912ede5d0ecf36f5750f96fd7f6b59b98413974b0ab81eb9a4716f266f8a87b30293b7f00731e160f29fce9e335bac7d80d871c57a98f7da8da395041d65923ef3fe6c33f55d9fa9220a12c594159dc68df9656a36c0515d5a2b117f048266ba6362fa9514216ff803eca0ef98120d1b54c830c29a4479678368aa14d27122fce7b95cc8012576987be5028a858a0287c7130d636a1bf59c1d7dab0cd76396eedc6733e7289cd1a2902a0f809b96495843f5e9748b088cba2871e02cb0f4aee9a8db39d3a7f8a9b96e784757864393c8ddacf1856b16d7718f29eb885461cdb1da7b57be63e1d3217bc1f6885267b42efcaaec5973588a5e7b9e63cb71638b396d77e07b5dae0ecc1473b164359258bd9c9139f4331d3356c50fb9aadf8d2a6943bdc87309408714331bd9af06a1510c3deda50b89dbf2cb4e82f1c42f8b2d1adf9c15481e5db429b7da4cfceba287c7da3f7323da3cbe964d8bbe31e24c81214409b4fafb4e33c90c07586f1926dcad6f835c2f6998e8c9672cfa2ce0977e910c33f9a6aec53d17560a1f999615a8b2e48de59e3797f48a7f90da76ab868e0c29707e47ca5fd81c502b1d841fe559b86a9fa0966e7422dfca927916e1743d46d3b0b8535cf5d771e1292fc2b5d84e52662936b0044f82ca9816922cd3659ab4b21522e17356d971187b25f703d50db0e529c673d8b22cba75f0af8e442fb6536a821391e544a9650602e3d6b29086fa849e9a39a7bbc86799a936ef193318e47f5bd0b6259565c2d29c9513c85bef75173e19d685c7d700a12f4a0b1f52255b4af83d6169b3fcfd8a1e2590b3e8c8d0beb0664d42dbf25734f647bbe92c101298c723a4aad8352f469134a09fbfa1ca1edca5a91b0aa0ffe3027a18d982a17c47f3ac37930ca5eeb35d062ae2fe4b9ae846b52b0c52f8b2dfd70ef2acacbc3d1385fbd89d866056f5dc42a27efbd280b6d54a35ba301fb5b9b2fed8c34d62c95dab3878a47d11363608ba86f59870359bec9df7b2551434bb7a416c2421893aeb2be10e753f4942330ac630ca28439563687d951a4c4286c97455dc2d45cf034cb09cbd00c02b0136abcfcaaa8be15cc59547b20a0bc6375157257d4da12b5116e47be547803884096e519aa49b9f9bad3adb584fb4433a59069556af628080adebf8559b49b0f7825d143afd635b2361e7308990553d73ae0594c298cb20cee528a359fa76cddc4e808aba3620be609ec09f9792eaeb4755ef7349423dc6bdf5de7b0eaaa5c8aa1abd9b93841b0b0eba4ec1aed08d0c058be793c88aedde6f9f49c3ca42af97b44ec9799a01f6c5e25f95a1be972e599d84c50341032007473ab603906d657ff6d6dc9a459f1d6ea901bc9fb2158055b6a5b584e87bf21e9260e29da39c83a2f841f672e67fe40be57f3bccf6ab819c17481142ef204dae609e2145493495aa5e4eea3bca8278c62adb15f72fb9ce15552b8a4c4c5f67828637a3aabd7b36ad6ecfce02d7575738280a526443f793ebd22fe4b6547cccc45b6fade2f98c572ae6cdb56e6ea49d22a421c175cd79be1184ad66fd29775bbef2e693d6fde8c50f772da138cdfaaa30cb9ac13e6b6eb756e5d980366cb3c573d26af2032c976fbbf04b32a953c5506b513b7d7ea26a158965b1b61d1c8b071db9d5a7c5a9351463c11983bd110f10157dc431b66457d26df965158d25b047566c516bdf3fcfa001d1de1d50e3bee765a1fa98191a6e11bd3ed2e502be6003ada98d5d5dcdb63d9f48051d03e95cdf69cca54dfc74cf2a88c0dc4703305e71728ea863f137618179a6301a4f7f3c85ea1d7bb15d8030988cfb24d91354d5f033d80d0f3d5500c8988088a44b23d5030d729af04d8d183f5122e33bb905d52797bc707d251312c72c257dd2afd8ff95d0504d2b4de8a1a3bfb5149b3bb54d97dd5cad9d32e5d56ad1be1f1625471c4654c84280fa8f67ca8900369e03ebe7561900ed797c70b5d3f2c4c3d503d646a5896e062f354413300ba02f07b769047d79b1ed61d6d6ada98660a5c7bb5d37a122e2d3578b8d38098ad5c3178f5c9669dc832df00a994857657bb0fa147892df4d2747797f29fcc34bbfe87b349b38215faef3fe637ddffbeaf7dcaedcffee42539da16a2e9da6b08b64ed375f26bce8c545ddb25f6fcdb88dbc46ca8eab785aa08d3aeb6d77ba7b0212417bd812f645021e9b15bba8d197f1d4d9ca1be3d30f006a341bb993fe01968b17a074762fc9d7a156e566fb3d10cb424c133ee0700487f8d360fea75bec86d589b856db0f610a862f039db28dd8ea9b7e85596fecccd0af79dc024100a8dc1f9d762e4ddfa1bf2adbed9585a0195afe91f2e628fea86c2f67b11741dbde32a7b097c6e899c483add22a973d36f96437966e6bdfd3115cb5c5f2756e7b00e8c3bfac94e47688ecea6928dbd3c33cd00cefb3ef101d5d49030ec97bf5df1c6f69ab9a69e9669a34307092e76556481ed2e567865054b3adb8d18f2750829f6ce1637d76736183f8864fada6c24cae94bc84bc22e80d2b2873cb29d847bc404760b4487502ffed17212878bc472a5a06eb49115c740d944548e6a8296cc119e1c768883ea1b7cb0c2d6c63c0a22c15a76f0f6e93972ecbd5e44c9ad2c82d6e64343d06277b09c952b81204a28772f977fe32a66cca26b50998f888b303c7b050d64c37be897ae627bffc3f8c8fb5d7bfee4b17deaf7d9195fa6d87dad45999514fe5d643bc3297ccc081d3c137637d63c4a5e0a9779c9cb3ac99a9ae2436562682d59fcb04cf9f7ca527086ddbddfb7aec9556375ad16ac5c156fb6a367e9ff065cd3593017a798812ba1afe93332ace7c01ab98ba7be7349c0709d1cd91141fc5778dc70795df7371b2791fa6dacfbeaf3200ea570ba5d42cc665f95ad00362414e0f6773b587bc5e327b38016af8baa6c6dfae37f2d0c50145e37516fb6df855e9d675de8f14c3be156703ffef40974529451bc41348218b4339b66e6ae58d2328170cb11efea70dccdba67ce934b4a18a0d3d6b24274b5309d5c5374d1a2a13aa592341ba50d57e6379063228962563bc9966dcd7b2b7f6d0e6c610e28bcc5d5ad3e91e490f8936de8b04586fa77488d8df458142c43774d573ffc0d9c701e4e23c6fdc19f0bdc5bf8eb407d5d5cac153d385ca1d28b09d77642a4fe4976bd221e4e9dd2df44ecc5f16eb81afd7ddf21e6a91fd21d33d3ccca7e9f09ef833edb046af11492686de41fdc58ce2369a92bb424d6aeb95a5e0160ffa336ca9a65ceae5fe33362e295c904b195c818e2cd6832e8eb9bc64f0685bd0259e71cef63d03a4627f904ec8815d6a878ab8677b253121c2352fa3d4414816c09cbe04ee2375edea50d8c0a0c0c253f260d2dd8cf40e0373514cc0c82c59547dab0fbd0d8720608b1e0bf5e3aebe49b11f443118a5faa22f1fc5d605696f96d94d31f1a4d7f26d503bc34c84d9730b7d6e07ebe53c323187ccf67947b9a427d0c67a83b871320ac05f656400024242a6d293c15dbf60e631bdd3183d2201e2e600e89e0cc358363fc00cfe96096fd2845b0d8de33a23edeb4c74866d644219f3cb0641ef8132b4e22cc8b80cc784b60025ee8746ca3d74dd70f1ea63268c933c4cc868f5c0c09b950b99dad7e2f7e1c50fb36e14fe1deca6dc31300ba84de875b2ea0617859a19cd9e8aa04f5914a021327bf0cb7ed0a8c3fb5ca2bc1edd334621e0f73a7624ab7d0a8e4c8aedded1cf75cc1431d5abd2cd8ab2bbfc0784a75b4a460e3fcdf7ab31153c6b7bd1910464f6eaf470caa347fee7d37ff3427c2d365842d3449817edce091cddff07279045e352951e235d756cb533f7613d70e3d897adf06b5c513f6a10925ce8df8008e8ed08dd5a78635ecd7c012a6b81a3745c5ab9e0faee236021b89b131c6e4df075a0ead9bb80e3129693b509475bcb91b23d7ce07dd252d951cd847df2dd7d585009277ffec99c1a1b41f3877055339b28c94ef11c49f3b59430eebfd4bb6122ff02c8f33e01d9e12bbb8edc76dd602475d9c906eaa02d8b93776d7857639f3fe4911c303a005972d575a092c0878cdb6441ac4a42ea00d4b2a91e0bf1cac1d07949ee7b819756013e87492f01a0d9c60b093d8b3eeba1ab932831888367804903877ca1cd6bcd44e4bf8e28e324070171bed7e8b9d45d419d1a7ed125018e0003c48283bf34c90167abe38f5275c4c77cb2a12487743114b8012da402cbab6e404672a9de0750e677b7017b6762f1c1856c83cd83a07c1d7a394727d7502fa68756680a05cbaecf99404fd7fcfb5a73c89aaf9eb1c451a81ff3dcea75f80ce69fa9816afe72429b6485fcd75c0517d8cac8905241d30b05708d00042d41fb880922f769430f1f9417df40f83179585bfb14b4177b27551e3ee829afca1d102a84b0cf0c2173d2f480caac8f908c5fd919c0c645ed939c6000d484902054ce69dee3d97b14aa8e102a6b4e4398418e0525d9228e0f1b15945e50f133741ac801675edcc5fc3885227903394e8ae502887444622324e04b6463b805896bcd3e4b4746bf0ba070994d432e8afe5f2cb2220d193752f99b293a7909118e8e83dce18ae740530a00f81089f687ec4ddac71d77805efcdf8ae0880d21306f7b69fda4bc75ed9bce774edd9232f58f1e363578a5f8d45d2c65e6f1965412170d5bddd7f6396232410996b868d61156b32c1851ee9f881db296c8b2c8d1d8df87f9538e50684b37aa4fdd59c6874ff3b6b8c3e6404ae5ee8022ebd02415e4338a3f6b75b5115dea5ffc92c7eadd84f315ec8cf3953733f317d39a4af98c5036d70b5ef0667003ab80b0f891bf7c08fe82b6186484ea1eb62703b59da554bc9ebc157f5e5e6d7d652c31dad3ab872fe75085c73273b8c33a755bdd7c3336246bd2ada571c36977fb34d3639fe6dcae95b97e022cfaf85baeeed87ce72898cb5169bdc70b045de882ee390e4b1bd3af73ce197713d5660797ad142d1d215905f2291cea1e0fc697a89978263a5ef4d3f623b58ffcab578b57c2a1dcf76fcd95959f8b85f1f392dd9b22f7c1d44ce532a1e3517e3ec0f93c8d98164fd4daf09d9c6be433ad030bbb86001a9ff6ca6258e67a2839e9499220bda5deb8e808fa2aca1fe13b933d76e10fffb3c1a97012b228e006bd59c58ea7b5fb794d4c3a5e542dca663984aeb3b68a1aada951ad617d0f8e0d226b564d1ff0589e61dac7dc4771b800246731c7ca03b7064d488471bd5e89369b447ef28043d9763fe2781ee42ec9b704ba2dea074f50221d192d56910f28567e8899a2087b888b04d98157ef45e500de8ccb8506bf89ef63bac2c0d0b069ee5ec943c1f07f5a578da93556cea5ec4673db5a47ce558943635b99d93417a081f963cb2b482deccb845f0b0e0d7e10f998032adfb74be778a62617daaed0b106aab6b79d9f477bff2cb4ed70dd920882c8bd346de8adb438dd25a26d2cd9277081d5d512d65c966da0fd463b09dd205213c43087d89e43b822d169588ac6cd83304af31bd4ba7b41a4b0b2561fce206e7257a2b3b4a8c9135a626b9c8b12576f732028f17f9e3a6df0f454b7a4034758c45f8e66d133c3213153f66c20af026b256bad4fb8b44200c10e50ae53f8e5c15b43502638c24f33b476c2012accdf30da983893b1c3c4bc705183ceed5a8a70ebae342ad0116249f2d01b373092c858fa9f1279c5d0e26d625db9d23a707a47281b50ba2e8b87bd5fda936bd788422d34efbf39b7cde0b099f794370d3c0748d1c37549c9038360fa49d2acede050eac609503b6b8b2628798ab7f708a63810fc6e467c34057a49d2241d74672def61591ec161350cb5d45e1460e5bd1e30d988fc5498005fd718c8b518e6ed60996fa673292ffe9f1bc1de9d3def26bc429584aa9efde5a983f421cbbe4b9c0e88709a8d689ccfe68a222b2342d92d14b2f7c8f35543d8ee04f143dd4439210451494df2ae4acfb917a346191093aa764e295bc28429b21da75ebd2a7a9b9ae47255176138ab052440eb09a7858b4a59f9edc7acc0194cfafbe0552c5d8d9fb45add33c2b9286f7096bc4eeb7fd42aaaed07dce107377f56d8d3a356e148918d5e4c51436b2520f821b588f15e079a9e64bbde3a0ed0f1d1bf7d978ca42f6a86ffb18fc71763ba7a7c53cbc86358854241740421cc4c790f8be578b74868472d7297bd444bfd3e52752e84b85c25301ef253ff9fdd76482e4ae27f1dcc12e2b288c52714c71a3d067b2f940550c1f8864392bdfd8781eea9b5f271f783fc00055ecaaf6ef6719480f100bc7b5c3b1d816f6ee2ca97f8d76a33290db3895d4ea0969813eb5e524c750852336c5cf9e7fbda855ef09315e86ba25a8704608db940cab7ad4c9eeb72c5315c297cd370844656900a7812e23bee39761b734d1242219a19fc51cd3c6a091b91653956743a6ee34e268208f08f030e4ce20938e1bab31cce1a19c5e09e482b743cecfec4d9a288e4d695ec07870fdc0f182faf6d3749c1178192e4f74e3fbc7a7915c088100544b02f95381a752bc5424eb3ad2d9be16521a376ac8a606802996ff86ed3d89afce614242e99d9de99414f5a24339f7387dea4508904a36e4a1fe384b8052b3d772964631eec7dcd938ecc7aa38f3c280e3cfbb92328f160dc641096673398cefe3039e28def4a16bb5db7d36aefbfa1024d4ec61c438d913a4590b1d48329eac98f56d69339e00c1a0f0a4b843a35df4ec5c3626a2dbe861cd665a8190e38f43ea19f12da978e6ad77654a9fc8d551eeb7044f10fa31ad5068587a108b79ee501e3c03aaabd8bd3fb44b0374099995b6ebdf2ca47d3806660eaab24e16212863096f1204b566cf6b4240668f0f255aa5c7426478f675cb97bf57099ba2eddb930ff9e81ea2c86d92c24d8978797fea33ae4f92229253290bc341582ce200451443856768bf64d05a53959724de44c7e4195d24f930c0d5c770b0df68efbc1cc35ab89efea7f87e19666e582a8c0ab54d93abfb3226a0995f7d7b15317ef1534a4e8932a44970185043ebbe18ed7e5cadc7a978a0f73dfc07a1927b2939aee403f3171d53078aca042f79d39b8de0803359ab2ace84a367a438fef85d908093e2c23d160c2423f7e1bcc8394419e76953930ca1a406ac09f17e9fbdd32f0ec6735758081470cbb6fa19b3f867cc1bfb4db8c013ae115781d5713d7ef9994412e7af45c58ab5d02bd9c676fb01177cacc7910448cc2bb3c712713e7c9a8b6a452056f7150c71925c2a42a37af20b8f053319cc6d80052b27e1011312e1e0de00ab5eb9693f9375819560c93af9ca8f50539e589bc8761a46470c90a99a8224aeb6a8762cf7c54511c65ef79163463c77bd04f308fa39c7bf47a6fefd60328bce110f857a50a0ed55c25aaa5fd89bc5f3d38dbc8c07df354c023b5719fae8eaef52843142412d85465774037932b88d26b778537737d5a8883da2c525c3bf71e7becab6bd95dd27cb4852f71758d8bd23fa0dcf418adce9460581ffc21de8fd19b73b8ff1ec0a3d3b9450c5b94461bb4b531cd959890c54bc7b7aa18f3b8ee189bda140d9221ee43e724aef4c54c2174c3baa417ca2d60f56326f9c2411144a0f6165f0a1d82d309e778d6e056085598bb46a470557d251ef51267804230fd0a3f4296d18f5da29282a79e0540a53e41c8111a8d99667160e5bfc09a7487845c7a20cd01b9f266a00a4efd56e3ca8ec3937e55beff52e49368884664a357635bc1b43ec6c80f334ca5d7e5ead69ec2600a52a5fc6cd00f5d8c6e0be9365356c145e9c3e3eb121095afca64a99b16690a829216e9592c381e05fc95334f7f6f73dfa549c3f9ed965164747022cb4d96ad011157a95d3769da99dec70880b36c565875e8a6b12c1e1227e63c2de8d0532aa7f72c7361bcd9dd5419461f679483bb75f72286308418ca1f79fddd1104d25f3bf2c600f599a9a0ab59a688ce6c39e979c36e0c3387c1d50e00f1401ca574b51059d95098d9cdd88ca2539bf1b4ca0210a7ef01db7973598b9bc39d2e8c1419061adb7f469a4673c3f9e3d18308bff11dd8d37aab4572694335745d0cce2f585cf77072af73a385dd7218ad8047e42a422c614260ee857efd8828a4caddf27585c9ff27fc187b6c07392c7177d8b99bdd66da35a3153a7922127045649840a765a3c97ebea1aaeafc110d8e47dfb8ba02d37576cb0f99d39e6e958a0dabfc8972da95f6fde7990392488dc0fb1db70340dac09104157173e6e12e15a756ff45bd76b123f5cb8987a42c166686ad31bca2991aac00043accb236165cd04fa786408b8b038467f0d0273335dc587ad21b5b66333d28567337f542cbf17ed6218e300fdc617d84e6f78c99564392676e1ecc47f3a0ab3607e20e2b953e172da8bcb473044456dffee53e93ab0f3e8efda763fb1fb1efe1022eb2f12d1fce921bf3c08a360c6a4284b036e7c780bf8dcf97273babfc5f96c035c1acb0e8601bd43deaeb7c1eecb9aee35b29e21988e13e6ddd98c789219b5c456408f5337347fa1e4d632f5986aee2bb4cbd1d3b28a99143fa82f785491a89f49f637fa97f8055d2ae758f677a2f5098ae178636749db41d52c607cdd02da128654195e48aecf9dbd25814404ec5c400aed83c32e8f6a570bd694ca35e58e0d92b62adc5e24704689e9d96544c16561048a74b4dd2199d97793e7ffcdd317c74667532a9ff5826d99a3378763695fabe5e02a18807f73d1aefdd3fd55b8d619d89dc54e1c0f24f207c085b70100d91ce08a3e5608d6509f7a299255f45a60befd4c5f320566707b603904935316b2f8088056440f71f70f09cfde5bffe9a75ddd8794c77a0f8f281641b352c4c66f265057446e8178b98d1b56ab51d0fa1aa786ea8b7f1ad8d0ad857eb91ece6929cdfe49d2da9d1e792d68545a42429c98bfd8e710ed159857d148dd24c7959ee7ce36c6ef9bc67d1513beaafe7557317a5ac9292480eef0bfdc2d06228fa3b41e25ed8fd40d8cf7ca2b000465038a524b741b2f0a3416c557be90438fe56d8bc4e65da39b770ad16b1c5e769166821da4963c5ae98115db8b2b891949078ece1134c93e3b2c48c653b2ec97041cc8f4e4123e21775262a0be67a61d1c929d675bb161d9b5a44423252c5e35fe74bfb65039b01c6a23140f24d2854c0d4faa18fb52b4b230a73c587e409135fe373688d5e66095204f503752d62c50ee1d916b5da1faf1bd548cedfc9ef870ce6425f4e80d996a8f26abda8859bd933e8396e9dfbc51cd2a926d8e6eb8c28dd2e1b757d8da45126eb200eb5ba87c2a1a7a1637b0577bb48cdce409ab629ecae0855fef0926dfc483d39eca71c812aa63659d602cb3abdeeb63cce0f00a6ef261f228e4429df9b32c89d8fb27732e76af41a14df1614c2925c4565fabad7c86087db5e797e9c7021b92f2c3e7002a5b28024fd62d53e404bda59713f473acd94eb1f7772b8cfdb076d7f1e37331be7f65a9f37fe1c09c05b38e9d76a2ab5ddb7bb09d79082fe5e7a42e3d2e196cfead67ebecd17f38f109569fa9f698ca1bbd740f54e0409f609a33c3210e7de044e3af0cb4a85209a3d1e68862765edab21d6345101b51bfd1da84bef6d8ed6ce57346422d477298d7612eecbeef53e4fc77264873bee3a2ab2ac383bfd5bf55b9b8a7b47132899d70621f264044555138907fb9e387a54e15ff187f9f19719a20c23073703b7ab6876c43586f49d1679af0c66aa91ee4bfce04af0e313704029ff61e5561415e8d2870d7e8214a112b4e7af242180373e45557d9d560e704dec93adbee6d270e2c94a9822a35f0a9a3ca8b751b0367a84b3c6f626aa41eceb198f93c94c27c302c02eb79297b20e1d8be30b003c9414c3af7ec3f3b588adedfb73b42bb0db08ba53d5ab23f2dee847d8b5d198ac8f2b2925392d77805af25110abe5a122ff1e9263efb66cde64de9a530103cc9fb43078ee43f3fe55a660f0b6aebb484f97907f47cc1f7fc684c7a5669c21467c97b712bdb46559dd61f06333cabfc9cef7fb0532d79d8bab6acc077f7c404407b501e626e6d7cf0450a4a3073f32f5499c07741806197ebd959937f0269712a80e135e19769954377b6e88b8725438fb056410e2941a9f8b7e456efb0bb337d94ba48010ba86c71b7cb0012843537ac5611ffa80deb22994041c892a1bdcf1f007c442f19fea1b199cc546ab02d14268ac937c941662e70fc3a1008961e166839a67dda3c461c41aca1e124d044fc9bccfa4615ec3d7f4206f122a86bb7d016d23dd84ba442af660826102d1875b9422c0ffd22e785ecaddb8cbd6654b46bbd405eb30f29cd3937a03d92d38da72384ad2d4b0172cf9e491838c8f9e0c49987e4d13e946c6ec40d87719373ae8861f958c89e85ecdbd6cffe8b288ee6ba0f22d7ea4f168f811640a664ec50355d366a86fdf874283d3342db8985448b3d2163567eb83a49d08180622da0fd4a7b6b9d75946f7d56453928a0aba400ad413da3e354e6967da14a914d6420edd210fd7d607490dcbeb2456857be228f7edc44697fcee7eaedc1e1616348077b54790c5ce76d51214281539a22afb8ecab75071beaa39ec5eaef09c29a827f3e982aea5f28d8c0bc9ca08ae77ca3d6b32db8ee016b7b9da4ce19a042e5c7dea9807d91972f2c61e7387c231fa4872959b86a537e032229b0b0b258e443c1e6d869c43c3c6b47febf1c851cbf2c00b63a453e85d850a0fa9cbb3f3700cdd05fb467ed610d6b87248da607c1733eb4635d9986a6f5b3572bca716f2bd7d4e5bc0c57ca66de6e3abde87d7e6cbd9db1bbeb5723fa883efb607d3a3f548aef8a3db38486ba7b8eaf20b89c896afc9025498364946d3ee15fd20b1c8c8accc7e62948e80afa7a93c0df59bdb404d3e6e1c889032bdd1a920d118d5fff2cec3414fff06e79ec7bbf0e19f1a63169f0fac90c49b0142031507e687bfa81597ca28216b0f96123bc87f0220c614e211434e837a222fb1783d68872e2f754b58bbb0fc7fa86b713b0c306708750a2bbc2ff4c57e841a44a139178572e817f78f912ad878319221c9fa1b4d4ce2fc42d5d78eb58986394e77fb7a7255f30f9d675ca092ab5993a2f6a809163e7a827b1734625fe3894875f5c6e64319c5b6e6349ce279953a334c16b5380226430a88fde0904f2215eb8041a0ae62e733a57ee31b6319bd9d048f20730c98b1b47ad411e18b51b08a8662cc23962d524ae3ec63cb19a2601951e73437795a86bbbafdfbcf1a513e2c3a184255f99eaa1024de6df002ac99935c931ecbc7521b46b08196b0463babf405ddb547f2a917b4e959a923f06ef84b081ce5ba80ca3d14e829739a2ab099221ddeb41926fc5ba18010f401a8f0969cdaf8670cd2ef85aa7e9dd626df1987e88f872b0660ad7f9a1a4d2e2b897fe0ca9e9f4d20c671ec0db7a366af94824a26ac81bdb6e84885fcfe882e31bc1b74f2f3c1d6962980354db855e6adbeb9a3ba8e3115b94686cdcb098c9c20dd4b3509800926ccf0772ef2f295076b02da8a8daee7e0ad9627a458a18eb961f2ca340de9ab7eb832c4adc5742a0194a3e102747bc0651bd7b825f71757376d49ce851f4e0d16416854406bc48c9aba888eb0c89b57fdaec17b24b2d1974ae72bfcb105173fea7e42588709a38cf9bd36b6bc704cd94ce3bea2e6c8eeccaee0964700c7e97af328c3defa94f386049ea47a71beff03d6c74f35e85b3e92b193eaaa9e81fa653d3474cd4e6a77d49323a1f8e35c0bb24616f5d42f71539e5bb437da5cd6d44f51adfba0f5a92be14d214adabc6c0b70fbfe70f389d8b9982fc25574cc29868d8761b8a219f07a01b8da67ff600c7f88cc028070b7cb5aada75109e776f83670913fed20afec083dc279a0e2bf054cf0a26c1f5320c4033083c9b54f7179936be06c4f5ede14cabd2dfe6c24b1b5330ab1fab49077f5cd8ae7c60d855dd8a9e8c7c5244587bdf5e58e18acc0ce57e5fd155790aa55b25bb16e4f3c01d707bd11dd03599fe588c441abaa12ba605bb1e6c290d944badf2cdf81128b1fca89bfec054ef49427d3eb00a3738cabae5e5f0f3cf3b2ed4b202fd24b222482585de22693f1b3d3f1a6b2f5fee6256ba7bf008bb3406a54c541cb1db0b684cd5c97889c74a8c0ef9ba38d2a88c18a4a903811585c7051e07c13033cf909bf01a7421a121664af257c36f437595660febb29293aea6bc09e1f45c65af311e832e163578b733a1eeb645ff28ec1ab06ae65264fc51b344b155b16618dde1e0fcc7aeff195ae3037196ef0874081992ebf044f93f2d5d41513bbce3be94c6a6266bb55fd5e1572c47b869b366e137b1419a57c91baac23b88370007b13e14ced5b2d222a705c430e1a24680da8d7a4a9117e9fb3d1d4e8655a91b7880ec605bc73b8f01c5277be390f5a8067b371b6a7980b11db6782e724b14c3642b4299fd67c0944a4198820498d0a0f806aa34696a60fd2e9e76229faa00ea9033da6113195b8ef99ba331c46dfab05f1577dba721f3205cf787bcb6a85528c6cb3fae33292b94fd2a62370d5a0825887a73c24be7674aa789ef97b70962e015388d94ecd30a8fae96a6dd309745752a7268d435fc6cac25d47bef53aaedbdbd5f2e104d288671858fd3fc842d67b684cc15b02c25bc5146cc2ce4c598cdefe21a45904c5140b4186d11a17ec60064e6f23650f0534593cbdee617bdb9cd94a73275dbe2ef75f79c3c5c0449c5d4e69cc27b0be0b99ab7348e7b94da30ce8ddd41d20f17d1b5cc1a4caa25c2498124a93d2791e8a11c9b8c6fe82d77222d429881b44a645cab9541b15fd199b0405c96cc099364393ea4fe15a1682a221585aff8454cd87e351003c9f1578d228b45f4157724b1a675fa6efb2831017630a907311ba2ae07f573d49ec0861aea19acd7116ad4d59ae3d258463dae32301c1b11ad55d1692d55cf7b00ef62a5960b955e0f9354d7562f5af57ae184b26fcd914b25efd223481e8a6bfb5ef5183c0531fa1c1a215940045589e492dddf6dc945a0d9ad1b375ff057e5264ad842241b7e414d1d8f205e4b3b97326a94eb846d3fe1e6f08010c91eee0674acd00a32d240fa95f7c0656a5d354cf7f56803960cc38e4f29a6c72c50f6a74437f740e50879ae9dc790e08eafd9c78711d6199ef78efb0cb6dff2cf74e1d8bc322bfadabf75ca0e80a51dd0b2791b0263a0774284b0c62ae58a89eee546aed639f5867d2344ea309436822f320cac6a43c0468955ba3f269d89431bb2d16798868050fc356435b9b893d85a92338cd3c1e1801c0e2d8c82c3ff8adb32e39d7ea08361a661e0e8f16dfbd9ceca58bcf0798585a072ef12febdffe515346da903cad20aa141cad711bcd2fdeaf7b9b57a10a82909e7f9460d7df9d8d19a7d4d130dafca5c7e2eaebae110f3b9419c360315da35ead840f53a0a2586ab856f0d52b116c792c483bf92fd2fea1f732084a1db2f11798d2d509a4b037e791c0bf1360d822ace3c60831ad68dbff2d723ab274a8baf1ea42a60330818defe8b98f8aff296bbc94f0c3ce305a7f03d34e491ed46847f3dcdb6670f1718734d4dbbb170eec42749a9419bb25e63b96acfee4674a3f52ba2b1f7b2bce2df48b713af0ca92c24dc42f2cb2ccbf1c0c3d1d2faa1790eb894fbcbed272c1aaa8bced0bf4661625c91e9de396f066fb6dd76aed90dcd01d68f515544fa55b2533d7391feee02b23585a96ef3b271155f74c26f2d6091ac8fbb776c83a61b304bc4b2ae3ddc42a3b699b32aadf63c76b970af6ef038eae6d3f6bc107c02cfb00c79cb0ec5bec5546c617a60f25abfa2ef21a219543df41a13889ef67685aa03cfbf920727f58c841dd5f650ab7043b313c3b6f0b7810c76e1e86339a7270b762dcc44c2fc192b6025ab6f36f1aa0235061d39d33838750bea2f29192ab1fa4c55bb998f40a99f29683f7a61e756d49752477982d48d36e60e7af12507d6a397d589719e9529936cf887c40be3215a894509d0a1c4e576fd599648a6106aa50670d6b665d145054dc6190f043bcdb0d66e021c4beb401b2850a0043997853eab72bf4ebbd4d26ead27d2c8818","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
