<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2037da393a0ffe6090b14a8e41f02c3d2924e1ef32964f308f59c91c81498f9fe86ac76e019302e72d063faadb2c76be2465ff495c858ffbbeb50557c5f880d836d9221fe2bbd03e7078b808489ed335fc350cebb656a8c24d7bc5a8b49ab9350e5127be0440590b2e5c06978ea145a570ea97622cab76561e87d90b0a08d25413a1c6b9570d89185a799c7f3f94f9e462d8760b2f3c317e3af05d98592d04a9eb2954800985065987949bb1a67eb977a5f627aabf7684842151f79e306c9bf2ecacb653b735e9f2448483a3d58f4c13f418f3782756f062f33db3a20a80487c4a8a88310515c0cc3dd394ff26433714fecd5698a488a5bfbb1a77b7709e688d748b212e8539e3695633d58dc1d3dd6699cbd950aa6d9ce5bfa4117a631c15bf685fa254257976992500058c3b0b6ee3178fc5244ec793e9049b3b624468d0638b8e22b5815e6487cca70fa49eebf2744b12e4f3b5d0a49df8f673495b8c3dbd3bd1c3d43a3f6bf9a2296f36fd94e55259842a75b2bda724af656d09a7bd937f110e70b70da8be4df4d466e5169e833ff47ed726db0d93691452fc83527939875d36624301048e4741e40620299d9e719de4902e5ed853636fad8b1e88b34c85587206bba3141f54b5f14b08033c783fc6019a9dcf40eac8fe7992abaa47ece4d188e5d032c799e83d3c3cce31f5b7014085f60269e9268c8f7b448a1e2c9bc11617df3251c9fb7c1b5308bb2dee6bac066b57c2cc695f9883abe18aa32c1e0a704ffe4964a8591eb7d70181b7f810fcd3b808f2ed7f96d73837973898fd15ccc98d20c4f6acad751b10e148ce12195a56a8cadd02989dbc34203c2df0c79c99b34a41d1205ade70a0990c9ec2426fb9d6b31d335376462ffe64fda1596af8f511c3edeca3e5fbbffd207b82cb61faeeec8cd41d436b0982f6437e78ef9b2e2f7b88529454cd2a8d47369d2e3931c4a9d06976a5cf1416ca0b7249e7e71c3dae031a50a87ea220b2026db649ea4eec10043dae566a77897b5e993328d728d6681e0cde0f5af136b722e0b33f160804df7b239e04121dd35fd430336781ff97218a5f8b8d64e7e207800593884d29c062040913aea1e64200aa09c042332b4bfa6e83930a1f1010ad12ca4ffd2a541bdd4bd2b5965eee088950faf31626b63a2f86aed1211f270aac44920b06d35bdefdd876cc1408816726d5eccfb8906741df410e0e5959751ebdf2ab394c2f6e62d55b100dd1056d7d99266e6b02f86cd71ee3d5cb86acdf1b63a269f29dc5f0a9ac86818f9baab23e4a397dba6e7409a14216247300fafeb8288373574f1236deda1a36c53a1135d0a6735f2c4fda0403a15d851add7f50d2bfa744cad534334d3c6ce2a13ace02709467af77b5cdb52f8f6d5cb2aa66194107a5853cc0b975b53c40e034ba09d279af0890dc7c055abaa4ddbf18c9ee2a140cf34de45b35c9d17eb5e82eb468e801738ab16cf2b55c04468d97e9c4ae7278c4a1cbd5f9aa091044cde3eeb413513a358b344790f0c6296a4a65c0b9b15d9bb7e5ccf4ae6e98dca33538a2cf89454659bae44b8333eff2ad3cf9d20be5664d7a99e38a3a6fe60a9e81b8933c9e1618f87199a25b7f9bf53494dc9aa68aa2bb564e7234a8dde28e067216b6d080ad952f768916050234c2a72388bd162469f0837a0b3ae7c0bb66239bbda27ae324fb02ae3f2ba161c5b33a40186c6e433151bb5e2cac6e7645641610488c95bb784b069250811f151a61fc564ca673ee1c25a2e0a38c68fd91f588f0f62c10ee09a337c0f7168c02a339213e1e5a4a64a8c6401fae7de56dc66e18d2c3de8d582218a2a4a93f869800e88472d9a6a4693e0895f698400f779219901b119e73bcff59cdbd7e6e37f7f43ffd12175290904d83fec62d7cfde7741781324c5ea1d7808e181df580df5a3ba724d71ca460b77c9a3ed7f1fb792a80973311be1775a11a20d6426c71e52b93301721d81421fd31d1d7a2c147dd2552b391d396b1ead44af14e9302ab09f47335982e96b658c5dc90dbc104db38060164c17a135e75ac4204a2d6227df2eb132841edc1a521282f70af6ac5403bdde017d36911cc2e70e2bd57b979c8bf53d429e56a40dfe0dbc9accd8b8928cf73c7a24263eb487f2f0e728f4f870d33f6e689c896495db7aa35eeff8d2575e02a3aaeab12d11cced0629186fe65d31e6fb0aacc98e5cf1de86e14f51eb95f6f1c02e9b3cb0483b3466b5990e7ffc7345ce80e32f61c6e3c8067b555515cbf5a0be1d891b75deacd61a77aac82becf8721613299568ee977219304e5a194f291fdbf0abe4fe3db4e1caf27af25695831af63b26f3b20ef5903dc928b73735ab0eb34bc0b81ba8acf896500f91261a6fd446b2ff588256bfc2fda23c09bfebea5b31e11facd8a41756a780aef9ec340b897a9278ef20599393e457b1a65b3b7a521ca2a7c7d4249e53e1cc11ba3ada27f380149855430ac7f18fb469726584201cd20213ecfdda62f11725032f54a3e0a77c528cf437e5e9990e1f02e1a185d75723c4f1acd9cba2cb1a235f9dfdf7a2d82112af40e9d84da4b51136bd7668d232b6b7e1fa3e784e60687a2740ab59020a2680628b491024371328ce324173e7afad60840e17deb25cb236aa591a08e8ba74b2ed7b7fe5b74545b85701c7250e6059b637f0618840b2b29acdf7e5a6e9c6853a2b1940075f30b4b9bbfea1907a6042a5ec2f2c00b9cfcbbeb9e020db74817e5ccb829c4d2b44850fa4d4f4f6895622429c2f62fbc905bbe6e4f0c784690a96c9c784eaf6f193e5069723ec68d07e8660da84172d4355d5cfbe34efebe84d0a75fe1e9019bed22080b283f3af700f8de0ef205ebd16cc86bf7d365e2ff0779b54370f27e8a79535f46210ac33c83a865c074128d92f8af03426c635fc7036288598ff77e8e3399c4582b3b73712e0cdd41e36dc7944e6a96eecc6f5a4e0563682b4598767a9112ee97f05bebbec4b8142f005a2d162a81daa9d0743f372cb1c2c9a7c1fd446924fdb6cd3ed52844c4315e73c6b52fa57738019c657cf70ef0ff02bd4c7c384e8564fd9ce27fd062282e9476d4eaad4e3a2fed259f1cdba8d44c204cfe68c75560e5b895b4383a3dbd4511ffe8ac8b0b75bc729ba756b12be599e2614fea8d63a413795464d5dd299ef03f37d04def2efa843bb6d4b1a0995837659d3682630835edb4260882e02fc96542f3ecea0fdf1e16b85fa29473e29b6c9153e47ebb430882d2bd90e3cff066831954ae0b62a136efe5100d9fc7c0065c864ed30235240ae0e2278e50d2f315fd162497e11713eb5dab1711aa3e04ceb5a6739c63d38603ac1f5d222ee1ba3ac5ec4e0386a155fb2019eaf48a123bbcae4770b91802ead0672ab7fa16ec6dbf5d3ab2b500b42b31da9225825feaa9645c3aabb755a8f968c28aababf39ea61814c20a0ece99d412bb12e7a7b923ba8574231b8f1dcd32322dcfcb753f0eb35125925f3d63c03d75dc7bf5950ac5212d4cbc31c82008907fa83faca8a308ad89d1aafcbae7684f7c6cc7d11de08c72baa6205ba608d7ff9064bf4dcb87d2a6ba2e50f12fc426b9785d37caec82f820cff570a1838375e34261a0fe29a0109b1b6f98f05f3affe4853b08e669f8648069342e02dca0310a80da395e77d1000f2c7124e6959c294d28a3ecaa074658184eb593606d3ee0bd46f8b6d8b6d7d23f79c708d5aaad80d1966bd1d4a80988dee32c22b8db35bb1e2beb7223a2ed64ac958d6e9209b739d2862026cb574da4309eb06f7928d320097e9994e0003172c4f1ec62f5d14ce96091edca617ea507b6f6d9f457d505feb557559d1f29aa28d1da5e3a2554503d7524a3e8d6bb443533c076e187f38b25ea1ea2518f654e3ab4a90de98ba576cb6157aeea1171d2d72c47db3489fb77db047aa2bd65810b1d41c12be033661a141975082ca8ef5b38b93a2a1d79e6cf6fd344a084d94030eb00b11c8c6b721feff0287f3fdc6f8988d14ab2b7a79f22328f225cbb8296086d002ed4071c673175c579a7dae6b2da685d607dc2e837e150bc6cd99d42222b2af4ffbb7bee5a2d3ac1d55ff2e2f5091884f9e4839744aaad3ee7030208414322113969a938646c14c2fa1f5bed611c7a37a3ee0db09639344c3eef2891221b55b672a622bd35b1a7bb22d08526a484bbd934893cb61be7f744753af6acade2f2d72dc529e171669e4a0ed86c0dfdb8af52eabc6c7127182c39745774de78b065cf9abeaa379a0f9636662faadbfe97327f9156c12b264f8e4a608fc260e8445c440b3754860f13947f686e10555db7d63b7c9857b8ad258ef01dcaec63fe34d1b91776b18bb29447a3e11647eebaccae6def937e3c4e814423a81c6f579fb924fb8f40955629dcb8116a6e455586736ba7bc9af68def0e5dabf58445c3c8c26e95a47ee911b8d6eac01d71aec0f5c336c28e2d342aa85bb8c708749e5dd1d13a119231abc4a78f2a0fdbdb1d0ece892ab3b164bc61c411c9b0682aa523dcb86bbc39f437d6611f3f55fe987f238a07d1e776135851d66ef9eef945cd8b856de3dde9dc5902116f29c1d5e0d7641d12d02ed64fe34d5270ead007783a5ff9a6533aac5419ebce6645f70084a8f8f4a080ca75f7b3b493f59e2aaf0c64f103f3b23ffe65783bfd61e853f1f8b4ad043cfa76bb2d5e08296c329b61df51b26ae6692ff30834787f1ff6140bb73967a73ff212ba4c5a4b8006967047966968f71d9d4c876b97387256df51438f965a7bbe50c1d725fe86e391d0eb29119b2fd79dd4b0ff5530f222c91fe8de656cf8c01258f733b89a899e644a4220c771fe76eeb98bd0bb42df8fa6f563bb23e4bc439725a1787e32cc7d60e7e66bf91432d717786db3a6b291f3fd87b3bcb78ac205b55947720dc03479d816de3b1b37081f56b0aa251f9ae363de0fb19494eed81d291a6135714e3d7fa256dbd5648e88b8764325a9b5279e93de0589f0078eec01f5cdcae31ed033b0591a3f83448c95f23292a5b69faaffd973f4770b17404d4d2575a5a8fe6bd63051f9545332d1d9817da7daf6728bbceb97cc75c1cfa1eea9087839742610ca59026ebc071158a366f4be24508e77fb91c1855605243efcbb9fd5eb22a878102436909661f797c788480d6aa49339a17b8644cdb0736cbc84736e169311e7137323e5fa1de55ddb8033a46f141269a8fd174d0d98cd40c180c11ee1cd94d63bf6329ade3594e60e892d8dc94bec30a3af24684945274b82c8fa0b3670f0e797c279d67938d544e777be646db2691fee16be26a0684782c098014cc2cad2800b0403f63a34ecf42abbb05fb1f93f0c14e3afa23d320fa3acd8b405196012d823e2ec4eabc99870f43c71ceed251e8d08b3fa45adbb986426b6de1d62584fc390e2915b0e567dd8de653b48bbe27a32ca4ac319d3b8058c2c98911f853867aad5a5e3ebcb89906af2614ab998bd11cf46ec2739c314f1d2ca720f78969d8b4927403f9a0691d902ec4c69510d044fe8a3b1740fee707cecfa4d54ed20b0070d5fcf2a74d575042446da564434aa65c69788f6370222653b1575da8374dccb8aca1a7b6697a10e52aa1e1c781edce52ec5c65423978d216c4c880db0dc0d66d31d408361c49c60b3ccfa08dabae1da25689fd602bfb093bf0b0c0535d364f475a834d4dc5e840550855d94200bb1f0ecb8a53b2f2bf9c3b58cbf836d2f6b79cc8019fb64dca7942d7e3ff8518e7c8d5c44c0a8ea157238c1ff2fedd33c98f7b6af0ba79646d3be803c64c33cb1c182dea77daf7af90805ee705e8aac12d4253b3b0710024a45d11d349417c4ef1ab2d14c662120d8ac25c4aa7d9e9bc9a8b08b58cc9826bc4bb4950c07bf29c810075db8df33304d845f99a484059d5787de5501d142127d14d9053f3291ce30ce8029e96a3cb33811af9d0a924804a81b1e6ffa78aac4ab451983b802f704cb276295f2c968c40c4c2dd6868764a548fe7c010d4abbb944ee1e08735da3dffc51feb54d9a73f76fbbab3bc9e6bcc3140817749617a3288b81af9bcd12817acbe3a294535c018264b1017bae8715372ca2c36e94fa9f413d1915401a51e1d511c3692d70dca9cb9a07001a20a3ccfc1fed94909bfe676605d0ea7cfc209e7d0102ef8321c0d1e201ffebd7d2060a77a54339c198eb866aeefdaf10ce3f9f7b46f9e0679e5082bbefa53f31d8a42bcee8c806ff329bcc0f9a3c6bd96deddbf89565d4583d76b20d466c8b5596543482b16f7ecf823af4bcc41a94d3bdc6711ae6790f7b0b212cc9724a650b68339e413635d127b38a512fadcbb3d79d45b1fd2901f894906e21e93df7fbfbfb66639b54f29b986facb1bb2d28a6118f7e10eab1cad27de51de28fe0d299fb4c8fd3b8f33757bb649f0dbd3c5cfd1333f1cf9a644160d485eeab9fa016d0fe4255c8df9269113f8ff2973a3951ac9b69fd55d5a9ca279e4f37d6ddcbee519972c530bd4b4d4ffc0d39977d30aa851bcfee4ec1f68d4a6e8b40605dcbf4bfd122862188f69b7178dea3adbbac6772e4937d3e87c28d3cb3db6ea8bef1f10a2b3be2a43b80d87d73cf189264a2cebf9f373bf1b43c0761d26d89901732f1b3ac002dda7fbfc297d50549d8ca97fb499ee8f5f7e620d3a8211f8edb1e054da6d6797c14e8f62821f0484c450b8e806384c0a9fdf82c4a9c1a16598fb8905afa0bff5c6e83d2ba6cdfde78c1c2359ff3805044fddef669e74b8de4c5c11068839f07af4f4cd62a67dc7cea10d8aaae85d3461b023c5348874d9f4db640cf1cf74f2c1beebd08a1d7c24d2e0f70682ad52eb4612dc1742d83d01efd2aca9b84cbbe57d109293a4d8914db032d560c32ad25bf31b5d7b552ccb9095b7f25f5ae28022e1e0b40d3edfc3ef9570153fc1492233e53959c6118559b3064a886a1f8e0747a5b50b9ad5b9872b1d26d36fa51057d19d7bee8a27660f12824678b63b9981a0c66e8dbece3f8bfcb06b9a0c050c088387bbe1dd6b5093accd09979674f55b31ec032717bd0e015a697ad04fce432528558725d56169559bad1f7872a25475c158899161ee0cdfaa97ae00336633ff48efed096b4d170f60340106e13c4807f0e8c46c17adc1308572f1f76e7316ec78cf545c7a6422cea03defead2b40799d8dca2909e66b51f199daaf6a47025588b6fe4fa87cd49c5ca34d88492fa4239ba2c08ab65bd51c675980a2883102fca2ee95feb7fdfb56e5687375ad8f895928ecfeadc5d5465e3f184a98df11556069ca1a4a7b62ebbaf45e9f2da45c3bb31fcabef81119735fbc741ea6ebe20885eb18db43573e07cdb2945923c65ce1c9d80e99bbea3dedf5e9ccd0fb90ae302490cfdb6c188a4b8d2d9df2e2ebb261b4124f07ce4fe3a1370aff928d5cdc18a75b7583b0e31a5dea250eb696f8dbaa16cc04c9c60697254ae2d54770e7ca2db047bed6a9866080c21d1262563f525f7cff14829612b1457d49d12624c1204e846295def99256562d8ae6c4cbf445957f937e5e82a92df7bbe112ea01ff459ec46a14ffe25057d4fb650c452d4d1fb648a3a57ffbad5d7e9a1aebe27812ff67391488342435f18a0bf3751cc2141826c9442705613dd3b90181eb8aa40428a89c5663cfb75151d2485ab1f218984b2225b90c1766a9011053afcf53694c1c593d6d04e2518cd08321497d2829b550c2f46041f3f4ce02d7ecf8c6f60c1160ffd3600962fc610aaaa90fb3bbdbff4af46a706042f8cba0e4545772d8727b6cfa38af0b9ab9c3a4ba23a2eda775c42bffd03a82124fce1082c8afa83ffb26c72f8f12b31f0200ab845522d75909e3fab716920c5075ee3561d02f68c9f275f015c8a35fef1792153023760fcaf3c10f21d4467c4b5106179dbe8ee8446cb7ba2b4457830129e698feaa7f22dcbb903b665ce1ce6b3f9695a0c3d037ee22b41c36bca7149257b961f19dbf4733ff5cfe280503b07d00bf5ae169f6f97a036d1b74908fac615eecb1e52e0959143677cad3610e4bf2f9b2992bdd951e89f7a9b052992c47501aa8e192b4ae8bd507c9db3c20cbf98d246061acf150f009a74547fff351c1b856268df7009d711b520bbb697be27a347d9b2902d073503ba89668243d2dc63d5435af39a7a91edadd852cfa860e2d4d149cbac51a570a58b27dd4b3956b20843618c86f3797fec16c5f586e7a38d75c53d19bc7e14f5782f081a438d8875379287b417455f5e0e3d894ce271b5fa3b40561fb3ff5a5b0d5bbb3681190c80362aa96b42d77254431c42ea0032b84612b79de8f6e59d21844736975d09fb8fb6b529b50d725568b5519661ffd760598e1b787f550f547899ced5cbd79498433db0d87bbaef3bea5cfd33b7d1cec49b572ab957676612a014a5f59cc10a93826ffea4774eed9ddfd38d7d541cebafbc3bc0706ede169a73e53fe3d5a04ef89eda4bb5537e31efcd8a787847fe8eec9f9e3a680936a0236cf718f592f85da81e039b8b8fdbde69586a20f16bbada794911690f5c4b7c52fda3adc3e59e1e59c232b527b632fcf10e902267e70f9be87cad77592168d3311025fff3e9f6e5a35e574e2c0aa5efa0630a58962326fc001d313fdda5eac6d8764368b6ac80cc1a457578c655995cdb1fea0903c5828bee78720cf4b93827d5384378372393e7caaae3be97287ee190f522beeb7b2cdfc00835e75d81d8f76ce00734d0fa64f06db7affe6945ae1ea765225e27b41b63af679154005d1564c58fad1f394c8404c4d435625580e13095ac0f131d37c3024a3f8d3a0d4a8d996e8004c5ee75adcb95c6ac27019676ed5c68fac417a41febd55b3059c92fff84e51fbe0bd6b83fd12cab3fffbddc14624ff0d9ea09fd24e3b669556bb32c21f89cdaa4d250086da4e12d14d1a1a57d1b0399e7ff7b0168d71c659a071b21dcdef775df695f291bff3af4b6ae5f060ca1e873f65d1686de39e197845bd66146ebfdf306ca97fa9688262d70bac29da49fd17099a7de44904335deae898a2bc2808fc1b2ea2fd01132320d4545d95260202a7f0ecba8773a3630545ff1f8926b532f48ad5d95e6f999118be25cf502a13ea4a08eb810313667ef8f43e9d0f46594a5d8bb405b7739be59509a643bcda725cbc49e743232fe375bb361c739e9612d04ce74db22adf61fbdc82e73c0ce94a276c9f2450643ec271d699a3104fbb885ea727f62250e0f263f2d38e311d1f860a111c7ac72d28e6025e5b31f6b536fa68a26a3967c4e07f0d90a45a4c52c1078ac0e021e2ff396e471ec0ccc21701a7fd65ac4a8d4d8cfa80f2f96138e364d534b76f3ab332b7c561fb3b129451a1e7312bd65b03a5e11564d0efed4130ddc7c29b72e1577a9294543f4771c20756be679bc96040b1ad9d76f1aac99cbf3d4ef94966c023c572051058c9f2dfa715f7d27e03dc3b3fd63bb1f08d7051bf96d25167f0ec42a0256e4e864f9bea3bf10a97d421827d497f7afdb57988dfbc58582568d5e0b9227df62752d24456e6331430a495a59fea096a95898638e6490794cbfc3478838fed464137256c136a4da82b5e3d4d7d4b50d251b86bb8d56cd281edc7070fa355bc65c8de16a7860f3417fbe17e6dbbbbd75d47fe7caf81a4e26cda0f6214f5013d78bbd8663ee6ca739c19f9de776436dd480e76216b30ff8c3f2c01865ef037f42d2cabe63562313ca5c703e79f89d78231a0e11ba78084ce9d38914c3b981a9b90bf67460eda3461bd9a6ac9dd68299cb19177e2ec462bf997caeff26f777b76b37c6ac6b55e65bf7d54ffd4bbda4022573cdab10769d5b28f1ab79330ed63162fbfa35ac8ffc597294c561068058bef66f0e3ad49ffcc3dc37e2c2d0150fccb4fa09d567249c84a80dc691217c827c08221cb51c6110165d2b5fedc7e06c14d967d8948cdbcb3d5108baa1e5c55a3e42770ff6cf5aef2d7fe01c27658f486477e4d99c29a72ae3a8ee7652ddc9c55e5f427c515902cc5766e7a5869a77a886fd417594d4f8fda4c895964a69f034911dd617571f2a704e10063bcccb2d5e2e38027d2d2565714c030418ec455ab3d615cf0e429ec9436f78632148fd06d1de94fa7a6b6bab5d4f5056b4e57389bd89a98b2f47de10b82cd61f46966c86b687b19762583088213924eedddbb154891a4fd6859eefc86ca42c402ff10830beba84039046788fa49a1f7ff728da458ed31e805676cc51c0c99668040a5a1fb6883635984c8340ac1297bca0eae6c988779ac2bbb83d90174366a4c518e17b6a9e3c29a2815a456ab1ca3b2e98bff5d3e50328808de7771cb9b0ab345976cec1f0cb6fc1b9fda8e745aa1daff85f5037b2fc2056d122db258803b5201234b89087560b50e79b51f8f4241b021768c6d52a6188edbf43eb4de03892bb2245b3a01809e795805e88019dec97aa75838139dba99f943d31a92197bc1fe72517e9215da71772ebabffbe56d84abecebdac0da71b023153fc9ac1d486ce54f1ac5f8a846cce66a0d3299b965e51bca4d4c4c609b1ccb8b9fd6445a389c8bc884fa9573107d3d15cab6b55606c660f85b48dde5357bc76d79f9aefedef2280eac4af056fed45bc90a0a31a25a296cdbebae83980d89513f351942d0c145eb33142cb693aa145e50a397067ff0fd51fb9abb359ab43584e50b78e4ba3b3ce3726eed18fca2173c32f9e9ab7dd0df65f4f0dc24b7f63501b1cb12a4ab81ce637ce04adcb993f6c65a9657817e93e77a739488174319cb5e03d97ba6037f985bce8c3104176de15ef9f5cc0018cf49db244bc509fdce626b2433aa637ce936af9dc1d0d34b877addab4ed0fe4d0c2aa6153db72fab886cf46506fe1edf50450e60694d6e5dccf192b7f2b17a8c93c6580e9467f6fb5d9f787e66f11207ff988bcaa563f1f5f8b7c23af9803f330c9210741da66a3e92a0c9bcda2fdd714bc643204c267c8bfe83035b6becbdd380e75dbfb0981f8ff1e245f36653ec7856c77f986eb703593db345bd307705a7ffcd31708b83b663194daf4a4770a1935af6bf69db1adbfec6d42adc30f03e9ff78de41ddcfe10f281350de8436e409a5254fd10f96b79b39036d693d546f922b5fdf858e11d3c70cd2d087763cc4350f96f548aa3e80028fe817c02be1f08d18c6fc598abc5161140880f1bbc6f4d76a85a038ef437413c3e8a90b8c50de20b4c3a3ea23d357ff12781944741cf01dc340b1bec61ddda1d764a190608495ea4b98d3ed532c2b1ce1641c1cf126cce8ccf0665ef59b81d9239b1eac8f217202df60e8b3c9dae5dae73991774d51343b6ba8588738dc0228f0c0653faf5b807087258d9e9042628da2962b072c2920b35aa640e449a6a6901a07f05d188ef0b8b6e8c4b36ecf926774a9674201b9f18563213967f25c8fab1ba216c0ffc29741a3dac2fafbdd006bc02e9cf203301dcb83736c751ffff2455471b0ba48b31001a27f12cbd632b0ed677270aa298901adf9c9d143adf9d8260848bb3eef53e8b872ab3c5583392a96ff7609695e5c26d9c5f3be55101609a5d398c220fb9a68870eefc3b89aee6ccfab9a9ed089846da8d7d8892b43bdf40ab1a5d8ddb23a005ead793c0a046e0d0a94e8edec82078f026dce6ecfa9387a3ba8fc7f5416adc484f339168ef0e9399ad380a96813bac0a052c6e8dc1361721b0b132fab8ab2e3f78081e838c995dd12c5b920c4a27af3789351cb583df4901c285564593a26aaa54352c4d76ceb42c1b08fe93496b52eb806100ce5d60c5b4aba1424b45097ad51395f949e1a33518cb13c0edb1fcd1fbd86c37b1e7ae50dd8029d0227c58139ae077fae95fe4b23ebd1a86eda1c135789571a414f2716094d3bf3a744f2a46fdee4cdc88cbb22fd8bb06d000209578b002f88ac9ab3891b97b1ef78fc5af2ee6b3ab335b5ee0c06060101015a625bf5df05c8deb6e1e789a99346af56d13f70c7c4ebc603cd59ce68d81115a0220f861f7d4a13da3729310d37d7cd4c536b68e52a4ac871851c8ee016cd0533fe19f4df7aec5d29f27300f62ccb3c269e52b2b84492d8d24eec2cc8b0b3bd9f387382f827e4becee33fd25a28ed6dd5ec9a81a3041f68ca2960e9ad6fb56bc6d723774a279fdcea8d77500d78044b99cdaa1c2e1d1693be8c63b00ad77ed3d5854a4b2df50edd2d31b4807f00cdaedc95b1368d983eff5ce986d7034135dac5179fd73fb9cd66994831117365135e7dafe4becb80d9046929e9b6b7fd3f0cfab2e0616800d5b8ad783c1479ffeddc52f8677e40b39728d8ae0fcf29da7567be3ff870a61b0c80e2bebfe3bb1b86c8a1eaeb62346510a2a4b228bbbaf87e9ccb00116bf085dbe7d8aa391e6dabf8fafd15a6bf8307db70bfb96597959a39f4967f73c3ad98689c1839ab4ee0148ede8bdfe46516db55a1205c68e3266a84083a6b6a9dfdae0c8a14492c25bcc17eefdea4e379417231f839d619c16bc096c761da814f438e870118736ea104c89892b45b9f0f60f7d72c76c99a0c3941257c793efa0dabc2f7813b7da756eae870cbedf42425fc11d35a9b84cba32831b32b330913a57389f47a446e9d256bb31d0dce816f3b13757dc23bf51b9b741596040518eef29b7dec7ff26c0a034f1e112c05ef1970be9f2da92913b7a98b3164aa8b43b7e0737d2bb97c0fe5307b4ef77f1d3a02cfd592a189a6b3012d0e43830c247449ab8abb1a74e09855b3e3c4f8780fd3ce7fb12de3a8575b8f3ceeafa6a0795ffdcae5193e2cec6a3da6ac559ad0ca9caac8ffb0fcb92ead9bcbb6ba4551e84878be139ab0192c12907bcbf41f4f8976334c251bd3356faa140ecc547b18e5c4f5d56657a04278809b0626d7ae72e5d96626d487c321e262becef9eef38486c80dd8fe870508664bb75f5b7dc8b1ef9f9486de8eaa475ad609536d94a81e51ada377988a9e6e907cf82495fd180d97b58dac63350abe6728cc670ef4c86fd1faf3a3c0f6a4060a7b4241e39a8795681d23c3c04f86eb30b510385e6ef5444775a15ceedecf2cbf01f270cf0c437bef40b6964ff8f1dd221d36df0b7733bbdcf2749f8849acd0654b11d5394215952865a618dd8576ef8f52b62ba84243c42f67b7a106bb223c59eec8fc08ef0df2be6c9f424d71301962966b513000684061f3a64f89567aa2d09bbf4c784012bbec321bcf554df3e83332fadaf88773c525831a6db3434ce206a3b03ee8a491aa49b7fdca39123b2d35269104c738f501dd4a12a54edea6da11f203492f1c2fc96f36c682bb8997081f11ff4aeeb848e22f99b84d4272fb64d08668858dd1362a1b8377f93377b97161ee9d13cbd93c4a1ce62289226ccdf84691fad642cb17828a65b570c975ab3f6dc6c26a73b168c24609f3b9de2c9840e37a937ab04b56397ef426858079a3c4219a21562752ba7b3340266d589cec334376c12339a533f9616d71173b4292c443c0e24de356e54f2c90fd1ee10d36ff0585922ff3472848d21a20a6d88be3d6bfca78ecb5c8e49d6457d4f71491674dcbd55b8ff341ca2aabf97aa60ac1c72bc13dca5ce530bb0f4cecbd48f062f7bd5974c734c0eabf5b597443c699db0f55932509c7f1bec3bfbf21772c0232ad8ff6e7731bcad125d2d676e837582f1f4cfc518d1e716f174f29c587464884f78c6ec92050864fe3d01b5228bec48710b0cf172f863a163d4ed9ff827dce557de955f7c435814eb5706f3a672405718378133821b5cac0c91c2a33f9016bf2467d6dfe4f19f9ad853c5f8186a851e0a6db3167c8f6d2f47f51e7ba38af8440316962f9ce045ea24c06a23c7993fa1616e10989db2f0a6d4ebc9c402917d99b4c1a8693c780e51fd5c3759a0b7db11662c69fa99136cae1286db9bb6d633212daf8b0b6508fe115346bcb35fe02471590b147b3e2faad34fd7fedcf813a322e8cdf91a46dba524fa5bdc2be1ee2dca29ad4301ba58f8d4429071c0e9d70e1348bf63d12a92d55948f2d765b193d17188f36af6b9d5a02583ef3bb999232cc042d9c911c66e0748fdf3b2b9820f5dd4b91ea7cac21ec2f1015412669ddbd1f62d44a7df24d99f7bdd5e0b41a471fffbdfea0120a608505cb678123cbd78494c8c6cf737b81fc52fe51151fe4991396ca80a0a987f56c622291fbebef2880011f20965e7dd6841993cb6c37b77d72a01215281884ef86c8e34bdda1afd969ab4327eca7c73a55b5aad18a0f2094d02d417788660123d5a8265195d9cf4b39d48484a75a395048b7d122c73bc58802bb20f784075e25674ba4b9b90c1b36ef6ece0e4de49479f6c29def217e66be8b2efbd79ccbfda1b671ecf2f04ef71367bf50c0aad90fcacf9acc90b53c2bc7daaab6be184d6795f4a09da6d0b1d3e86541ca557d999d187884c75ad5cae86d657bc4c303493d823faf70a032202bcf1005fcf670ec357c67d6e38a8294ac3605daea055ff1dbffbfff3b04b002f2b239c9cee2d31a2bf8888ba99fb62ad5344c7d3d87d4ee15f2ba5a832462e5ec0272197be8e9063b1886d647d001e037aa77edc229e62f6ee4f0a752cd63406bf9f83ecdbcf7a124a910b636f7f98d8527c7ef3402a707af7b041972cc13552131a9af24891c9b6d5d0e5cb9206831d38d165f5ad9ae06fffc1209d1b5104300a2d60dfa95e2ab0ba90a71a47a3d0b8d8dc2a8be975f9a0a68e07a0b289d2e17a292f19988eeaaabf5356907553ef1ecac43c9e0f47b0fae913b040dde6b6af877c030c98b1819303f4542c0fdd1e2bb8f149417fe51f78e70d6b297b0a67f1609c1ec7942ade9c06b0735e2761686d5c946a740d4a463febdd7db346636b07aa2cd53ff0bc095f212d7385d4743482b2b236b9d43a774242af1217ca72684caf84d6a08f1a322885a7496a88059c5da71719828ed7e9d41d57daa95a8aaf4aae436cda14be344e2315623c699285420ca0ce973e8b89ddb939e574fd90244817ce8787576d8d52f089b0756d7a4d3e32ad3977e4216a5945e55287f3e01c3b3f63d1f1bbdf94dfb0abeb2ca6fb47c54fa42d5bc022e26149d83817c48ede6a7c21c994d29296aed34e45f92d8027fc589f2b91d77ba3183fc6cfb1f09db58aee408c575085157a8d18e100f79d6e3e491f76142932187691f12ab5330d21e687f92df1a3bc17f75ef07b6565b5b893d8d818dd7785625f2a9d89f774d059b91a1a88c60ea832f686313598a81c9f5a2824bec4f003bbf6691da3ecbb7780467242f98efab0875aedca87e0bf20d071acd5466643a928929d36bfc9107d50e9b9861384bddca427387a6a1b76d8baeb5699efc358d7b93a76f047bae0ce7230155d63ad6c8d078e812bca2d527fd72abf6b9081816c1f0bf6662f8dae12746788184b8fbaf2946236a96bab48eb3ea87e5b03e8c0cc8ba233ed691eefd6f9de88affe9ab1c49142cb69c74cbe82f5546786bcb5ed2bae68f13653e40c3bc0816c57a927c8b4b9c2a239f96018a559a69328f5ff5076fe8c00d97a6f6a41d8e9c16083c24b9aac0f1c7e45008b2d2d4bbeeeceffd5f30fbf5a06bf18906c461333c04602d2fefe23c112cb8c0f320e235a73146b402a2e7028e2dedace91f2df20c7bf05a0f6f63ea7b81f81e8adaa1dab10ace9059cb65dcd42dc82e0681bacefb84d092c117f30b78e92e4ec9c01c4054ffbd40ecd10a6c709010d2c1abb821c9f6e7dbecf92c0061c70b7480b7207b16b36c7954f2fda5794fe7013d65c11fd55f22ad5e597d31c5be59507df3851b2a332d23db7237ad402afb073886627444f7e33c37b2b4cb9bb84e31cf4af999241eebe59b184765c13fa03b5eb90ac6bae99ed872838c1d3b86cdd44dd637bbe72b8da45eee572e8032e7294c7c4a2cd863f4142f90032728956cfd5fd01656ff87920e48b41f2f358aed272b0436a885f0575f77233357b22cd7451e1bb2b2555dcd15911a3941fae53af9674eb48273c91e17b04285868dfe12f2e3ee55fdc65f88479f11122106e515033cadcc192244c26f106a63b87ccac81a26351cdb9f8aa8a24e743141e8c54672fdf1eb68383cbd04e09edd5d567b5a1383028143e000cc83e7816bb1301e7af56733f06c0e8932bcb92300d5f2c27ae25ae485841cc0ad01de9a86967618e7acd91126b2c82dfd35fdbaff529ea7deb9946207b7c7fe6bdcecdaaebbc86311866cb9c0538198486560d6adf5b87d9c065180bacfe8af6398fdafc996a8ba7a0001a6e7fda2e6dd6056af0d22cd60d52d235df33c4ca203f49ef10a807261fce93182eada1919eb2ad73d95c94e494a14158b7a3a3a84ab14e2538f3d9c91b423c420eb96e5a74bac9e9826aa3c5d00e9c11bed4d86d7d61358aa9ba3f01cca4b1093de1217d14eb35eaa7c8da14f14bbb6f1698d13d78a5c6a3bd2c6d567ee5ae9a224df3fde5ee4ac0ae34c8e521eb39d9caa0a3050164f218ffbb68ecc5c6289cdbdfb672ac839eb9d099a9949cf94e144fdb70b44212fe325bbd6f58019d57a3a7915fb022dbb14c88983d540a45de5d4c5d41f86c136315c65bf261ee53bab09bb48764c227bd9ae00d8a0b2396703d3f0930fd271b61828952b3046b1890920f2180dad5a3712c4250f064a7ea8283fdf94a2e533a3d38f9c9183abada5e92bfef2ca4c011736ac333b7c1935e6678330ce10bff6fa23bff3082af096288922631fa6f4216c39765ece718e1072c7057493e2fa03c5edc18a172965f3b07a60bca6c23f6c822bc6c77e58bf94a519ef155c3071c6f9d4875b669ae2e06857932df8e0588cb9f56666f4a42c7171d4787b72a6571a4728ab7a8fd5b00c1939aa6d28078fe95c47bddd1fe2c8e97d9aed826cc024b7b8208de1baee2c5ca1ff75400c11371f6fdb3450cccbdb3a4e7eaf6d814a57fdbd6cafb272d9a52cc9f4108d34150bb9468d66a64ffa5e258b5ab528340de22b795cd6265c87b55030961fb2c03f873f201f5efdbf7081f36103ca050a376106cf618bd16cb63f886639fb236d0474204eb159b9627045a11d360ebbeb395c9d924dabe2539dbacd1ce486ab0ab2f673b64f51460cb6e5e8ddfebda12589e3c9d8e560ea3129be7730364c3ea2c4ff0a837b97d2a3ae450b9de116fe365616a963296f428f19064635f0c0bacad03ab42a91dcd72ea79d968ab2f242edd2be9fef75f4e52bb8eb93b4c35b02b15fe65e9c0538b78489cf782654616348119f98c3692c296ef9d11d0aff9cf6c5e9620884b0e68f6931e599c80f1f004c566b804181a7e4ff0163c6c7284b28696b9edc13cada7853e6e2b1115e66918c21c8016c3a8b40dcb4a918446e669c0d8f65788f2f601305ea0c826505c0ee15d1fa869f4d879395c74d55ddf2fc2472d25c91614499063fe13bdda5d4c0c1e07ec0ca2ab2c167602ad2dfbfaaf3f5c603982824d3d9ecb7f3b5f4f690f8a7a1fc1443221a749db6d04d83155591bb27994e2631f1ce58e4fdb80797db4ab08e5c710a63bc6d51b51b8db984b513d063e218811fdbabf0700cf57bab280096148be0cc201f27a6095630463fc8cd653d176f231db982bfe9ebaadd1440f6ba35beca5ea7b84dee76b63f204650c160f651725122a889afeb0988bfbd423290d82a92c3d873921ea7e72175ecb5851545daf2318b7c4a9cc72ade0a8f4cad746e01b7af5240e8c2c9d52df5e43c3d28a34c010c1db719327aff3ebfca789cbcd16a11123d2429761cfdcd265d3eaa76ff7804b8abe830f3efee0363bc3c0891cafce28a9796610820421e43fc6181886c7c1e0c54f928cc92a1f490059d98603759838f12dd430b4d44affb35b2990cfc3d8e6f4401b4c23f606b21b6509036cbea81f6daf3acc182911a2716109a892fd4f663187a212219053aecbf73a46e79987fdf005aa72f4a7fc90be40f7459c33e894185168fde2545ae2ead61eb0f66c7fc8665963abf31a92087c97ae15fa3e98194199c42148b74eeec227c669f6d7e03af8887c5127aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
