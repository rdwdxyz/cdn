<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4df8540d628e25fca35c17cbe123ee4a3056816fc9391c66f4f5bc88b6e9536d3b57d3bea3d11764e266c5423d069e872ed487358eda2f165c39206a6d92e25b05392e82c881b013e5233b61cb248cbd879e973fd59b67889cffe542aefab118f8947729f90dc83e4db2fe090bdfd06cefdf24abf2fb6fc5358c66ad800bcd16021b379ec7cdfa3a483d31b7b0d380297851f1e4589234d1298830f4f96a74372ede695ed616192593dda2600fbfd97f3c72ee6ddf5fddc96ddd1708769f8297659d69f46b85bad00e479594bcc10d44a5d6f4de2bbd15101f4465193fe2f929fc9e3149b701b3f42a0d9064631b03c0eeea27fa1e1880535b8fbc7dc28d83911c3561cf4c0caec9ce2041c36585a5936f581efa8721a014ccee0caaeb734fc49bde96d9cb110a770d3bef549703901cbf0475ca20a078eac489bba78316785aa6a3ebd832d097b24df7c4543f0a717d99131cb6d1bb01f9b360651657aaa97091af84c84b64feb0a0b2ed4dee4d6d40c7611bb4c4d5b13f78313833d6915e82ff63fcbacf8dfe9ff35067bdc93741b1e607096bf465544e114b020103c13a7ec97940fc8e5a3f1ef5d544fe89f62249545fb6f9755664593a784c9757dedd76ce01233e9bfe93fedbf05c84bbdae297b43cff2ff6cf5c5596f6eaefb30cf7ea07f49ba6a684db094e5f104906ccaba1cf83e775ee6c687bc96d7471bdd47e1579a3c09b92acc51b44bd0067af8b91e14d20cfad3ee1a2168233facade1f51796ec9684f70a0babba105f4ce49dda13de2d1a4865898cefb2a5fd0df48a8cc1ca478fd8deccb5df9146c999787c93bfd68b6a8f25e4b4748288517d956810e569fa98066f0b0ffc658bb9847a3229e05d3c7c8f13c91c485454e86eef419094b2884bcc624d321de498d5a907d6ae22dced044c10a368ce69383f69e2b798f1dd0ed61b7eadd001fd203ad218d6ab541d849d09ccf18ec6d1f07cf877c3dff889fc4b29f26edfa90218e942c5b8dba254982c18b7543aa0b06e0271ffe87b00984f3cb19bef5947119b6fa438b61250b0ebae23ea0a15d6cedd0b59de92d023661b5b33b88f16a77b0354dd074e69764808ed26c22955794775d33e96a033c8bf82105413994d8b85615c00dc12b077a722939376828e37db3b682e9fbe3c8d65574617efce69f199685c7bd3cf1deb603c46cc44c596a09190dcaf229f39c527f47166095ca16c58f14d0eecb54e72b0eb720f8e4d8b1822db41cf39eb70c9e0a2050c2b6408c7f585561a8a95a32c4c1ded62bed06a2a43caccf0357d61e091551bc334660a2175e239d1d4545e5cb410cae51124e87a0f0442a56aa7602c420e645569f9dc540413b2ee269314829f54b11fb4b225ee529e329cdc559835fb9d6456ace748206e0cbb7484402ca4285a57d4d88ba5246e23687d71fb1d758e7b196ca96cc050510505a54451c9927b3202c1cbb38b685f84940cb312c199d2af34f2f9d238534098da2abc253f17b9c435a3269d4ad35474efb22d67a8bbd99c78d0aebc6bb9da0676fca37d50066974de8a23c16f33877151cf8e175818c2f5f02d10e56d6c7ccf8482904e76ca31ff71eddd1c4b53c4ff91bf99ef23abfe4901303edc61b0c672510ae7297b1632c056771e236c6dede5bfeaf432266d7a21541619206f2b2cdc19d30a6feca45da88607861dfc056663c4a68d618cab19c3a0fae3410562f5e327d22e4a80c69b051e41542a11bfbf9da6d39f3686a8ac6843df9d2d80d14aeef6ce8dcf2a68282e1337f28bfd12563f1c551970fe6ba27f9219565fb0b118ee9ed0905221e419d60d05bbeca08828c7caee18c67c98dbc0c34fc80e02cc06ce640c91ffb8452ccbebe6533e5d339c2357bf696671ab0d4a3639f8e8ade21240894408917a8d194d107dd8b821d109ee20b343ae8be0d06a2017098e9ee8f5a91aecd1f9c6e08793a55a99cf47e02e7922e01af2b34937a50f721e9d4f1b81f4262d2cd56cf827a27f87d1bc3f91b8b6514be959a40cca69964ac013f12a2c9a570899bb6ac87627eb747cb17c9fa608c9080d2db7ea9b94621893fd9212c4f1b12bdfcc177afcb4f97faa1ffbec4910727f374fb4623bfbce91781af8b344c4f832356c62693874036e89392b155abdac60d2df4f6aa35d836ea31cc7eedd16bd141ed0fcabde9ea50b45efd74544601160510d6fd06e5f728e1e197078550d3c5de7b960e4eb4b49836d64d72528353602438d521a0144a90e6cd6cc8d77108eda03913d27bb0144148c134a6d43e8d87d47a78ffdaa80d736671b68f37a74c1f3a6eef42caaedf16abf025b86207d6c1d28ecaa2a194f557a283745b7b5b7eac78955f6ccc9af687ecdbdbd2649449744266be70d6f9ae90eb813fec3922d8beab78b3911fc37b41658703e0336ea43cb3038fd4eaa49e4a81f74922bcac2f7d76ce6e0b79ec5e2939e27303957057a92b11452702c65af022e15b77bdaa253e186d7aa3ef67dd72117909fc9cc04a0739ccd2c9610186561f31104ab035741d9208dd1e5b5200d8ab11d3dafbff9700d590827560adeeb11914e5e28e29aca8fb0fd184baaa3255e50518793b0ef298de352b65f861df0f90e490c381c31318880f07b6ba7ad8bcdc41c0877844ebd281b487755b2cf9d2e393ffadbc5d47cf83841f730cb8bd7bf705a5e14e372c64caa88533ce4f6bbfe87917a7e8b880b7816ba5bb38c97dbb50382aa937eba1df33e1dc890dd0b8774df3ce69efe5ce666fd9d375e373c22c41a1558b0e3db8cd7caede6e6d279da792f0de7734c2755ec85fba8693f1575f1e8febda25a605a11c185ce771a756a6241a50efd3dcf4f8cbf465721bfed9e4651789e2513d446a817e79ffbcdae9119d650a29659feb65bd95e290528edccd73c955ee301018dfb927ad497acf8dae7ae24c5e07e1770dd7d23d2e4d938471fb9b88cc827e21b290b7110383d2b042f1ee644e95f1deb66e9370681644241b825570db37dc2ed28d25dfced27cd985351457b1304be70f70739d3281629364fa9966d5f0dcd1576a1432f04ef63d6949d57b080a831a49290fe6dac0055fb5727295e9aad0a20be1d4026d139d2227fb888b92ceb497c3dffbe512cb56fabf6ef17c1d6a6fdc0b322cb6c7f07178d745acd2ee3a703f5939bcdc0e9bdc5e5298823aa276f8a413814e4588bb3e536d627cde186d5564099ebaf9bf3aa8ee02f749cdc016adb4286c98b46606177a4d21c22229d39d089035f6bece9d990cd93894d31c01dbadea0f1199a24d067f62321bffdd72238657312f6a69f4f36f3f79d4289c013066bc0db75141e0b2cf015dfe40026a65cd4292a7230baa10b1783014663837b4dd07674a5c1c9e09534359c372748297b2556e23e06079a1abd8cd6b7e0f80b4128c5c438a9ebaa3b40b0fc1307194012303039bacad8d0684a22ac2e3488f35061fae411f7a801f3011fd519b29bce0b51cdb9edc2f7f182611594dbb16cd6f5cb8959b7e2efd554408da914f8c31c8c165027c13a0594e126fd29a29a5115a762acdb41faa25c7b04c450d07b3c728913acf9f4b44326f42c98912bc05c1f0158c6c8bf188b600de5b547726bf2f6af56850abae4f3cef7893775f58d7d20f1e44a1a5aa95d2465faff1b420a99a2eafb69a86a9678cfea2dbcf8fc2bf408a9b5a811ea61c28d8717531f261267a36f1d397de5ae91e8cac4e866b766522c150774b38e31c61d07f83b3f7f7fbe79146d348015ddac76603d9b918b56ffae58062c26f2135983827c52d0ff8a3f248c91a56dfdc584e3875a86637be4c31cd5cf6351d0bcd1bf8477c1d054b9a8728b3d97a13da26aa4610b30885bc6b9192c2296702a8a92c320620224b79777019c9c2f40a29221cea36cea2f06cbcc8d37221e7cbcdb99f6cc5aac23aa68a64d5fc7a3356fed7d8f10c78886566e5eb9d7f4995533a2e2f4c7239a3779f5c39995178e91272e834a8fa4080d181bea8087bcf8992e48b731a430b9219155ffc116e77cc2e914d2d3aa47a4656e6e407c81269e04cf0fe55f5c39b0d5ead6b6b8cdd2639525ae17cd029c89c30225fca40e91ddd69d575a1a284b76bd1a61b3947e8e87d6b7715648fe433e574f163f5d88f40b34e8a6907bc0c92ae73e987f81512a80a590afa825876e13d8385a734b82e8e3d700234952d5bc7d1d864a76fbd0cd2a2002ad955ba5d8fba46fffee15b746306212f1f8b0b6fe5a34718e423df7c5d58afc42d55ab4ee59d738085ddb371cf91fe29d5ff3bd03447deeaa7d03bf82980b80c28a46ade5e2daa470aab2f7d3a0384761e54e3056e0efb636d67bdaff7240552c8a59312fe3c357e7622789a4bac49a3f3d815883b66180301efb45dbb09c821850ea3f455ed73f117fd9feec0f04930a52aca366e41842c8cdecb2776f1b525d8da6213af8c860f2af35a6a6b7544f10be04ffe729f92bc77f451880446e2b670c8336fd6e2ff5b4b23197f35bf13648b2d35843fab9526b3590db60c0cdb305ecb671986cfc3fae0aae981556c327947a880b709cccf1dc1e63c27b67796f78c7903896f325c2799751a9f7fd76227270e068d6d16edd60fc12953b830d9e21f07b31633293984952456467258e3f2c12fe63fba3d9c1033c2371c5af77a7621b86902318c9e64eed50fb85466b4c3982eb1c653e2e1e20f2437d9812230d9cf4eb596868ae32285974b0d68ce051512c012af0539527a1bc657c2fd42b7b1d67f55bc4ec41e336f325926b11dba4416d57d2b798c1ab2f87ac410f104827d65a25b5f7c1f86d6f0876773b0448d92eb461c994ae73d9af4363b04be140eb2144749961fe43f666a7247610c6735823f71c6bd676b3e3d2359ac3051ccb4a3e78fbb46485eda58a79560c9d20b5d92b5319bb29275d1de77fdf85022d61db9479fa045403abc698cc38515f8a1f2162c111d2250610c27f259ac4d6c1a2c5f2f18f125fbff31b0a514bbde74645bfc7e1047b89aae569d9bfe94582f16cfd718043f07f61cbe3e65022d90891764ed51d69055e6bff8104b64c9e1fde82aa8a61b751e7259aebf1db06548238e23c4633a4814a8f0fe38833effa14d106bae6406f51626f65ff71007d3406fef9daaec7baf605ad7a4c116a465276733f9db8620a38f60210bd9342cfd7bc1eead3af54ac129382b769c28180bc13b26ddc675e35e26beb24d42be9954e2e01e584f1208dd71373bbcad8030e540008cfd8e798dde2e4e0d8b8fe07455778efc64858ed67e9794f02f0bafecce25b4b6d901a415623776d8a208eaae3676ed6ed1c2d2b2b662663833880ce018c03fd5f79ee58c70220d1e5a41b0dbeb7b359c0569330032bceca22ee25aa40cf958f478805ce3af606d3bb10cb8310fa338a1e7db917ec9ab742007df9c8aa0a294ada5a120b15768e75b63e4d292531af5dd3d8d415368861bf4aeceffe5d4e2a61c94537c703d8b46b5c00a78a6a6577b234e996ce7da1d5dd242c20de570e92c17787dfeb6e52216596cf034915183a00e978e48b191b335d03a7e94171a7f978dfc5240e54269e85f92a8648cbecc7f3cf78bd69127e4cb0cec916a8b94c17e9b9d2e88769a150009d728296f3cfc66f9ab53bba857aca07825dc6762ade88c512f926893bc29aa7567b072c71426b535f015205d86ea2ccddf5083e286a631a67fbbfe3cf7b5d3984fd8a72f8780d50d28e62557f4ffbe54d4ea803bc23192afd3bb7c7590cdacfd7181d0f2126c097ad82bdb9015b08f96108bc14171a5f21126b6909b7d54f6766f5981bce0e0954ceacee971af0ffc91fc8b8ad811292843df047948f473e73f7254d57485ed0f00c4aea8951a36f5b27273de742dcd187cf7b4b2d5b93134d89ad89f731be6347b6fdf38bbfa2df6b5a66de1eb29e861c5a562429af9aed0987bfe03d91df3580d599a361355ee7c232428d02f635557897094865b134f7bd0505739d01ed5132ac93537060ecf0c5c96ed9baf2ef19713d3322435781f98f6297914c695c5bcc589201c51dc5ce5a8c7c2339600d8d30b678b23b50ae917125bbfd34e2093546418a2619fb3ed6675f21d20402c3afb17ca6ebd77e94352a11530bcc7a1e0b03c479ebb27053ffac5c9ad5d731bdb0c32694968acceada9c29b8cea25735614bb886ac50996521750863729ee3c734491f1bfa1427aefd296a8f6f16e68251ff7602a32dc0f3d0a61d1b7cba73c20db60ef6c6ab704baea263e552eec028ece1672e24a42441a942045b81fac017694ab3d090ce23e5648a57019d6d4d41061c7b4f36699726e73c4c09f9c4b46383ea5c6fcc7be7a5a11ba253f7a4b1effd7b50963b501b2e8c69164077f10955539969aa222bc8cf8ebc02d449331a4581c7b8c560e6208309302fd1199a346b88e8dfc9cea4e072a4cf52a8aff1b1a96002656abe37dbd42b898cc90280b091e2ee5e61e294ebbfed7d3800995854a06f96d1456db90b32a275635800d433521eff05109f464a25ad0e7a64a98e9517c73959114cb903028ba2f1fa775a1bfd269ffe92b9163aac646890c88b29090ee66e8c29b7681db91ea7302adc39ff3c2729d34e8013ac4d7c1e55379829800f869695a49dd5ed5a4b5d1c187df3958cb0ceb83cbc4e33d3f402f5eded01ad53a9a48592d3b9069411fb8bef10843e0f7c7059d927e85fc40361b806e23dafb0056bc6a385b13e009da6ae8acc3d6b1e68baef45e2353c292b9a101bf3ebdfc5efa4ac3e1f51225a72f81ba183027186fa81017727f059d5859dce5e939be98eff95510d8855ac96c3b40897dede01e357c1e7c17d6d6827060b4aec4b74db9dee3067121742dc3aaaa3e98b21b33802923f6e74c102eb8573be034ad74d3954d63abfae1978de8c0347d0339013b618ef69fab3b48efe64d365ae76d854947d786387cc12718da97c8d340cead558a93016da9af37ec60cbdeb010947a7fa3dee5edba186c5b61d458c6d02b8e8aad24e7d1a01071984bdd6488edf96b16614e16cb07a2fdf5d5028b30a8b9ecc93c0235331deafb6ecc2b287af77172b451d4bfab0c9f1faa5ceb83451b026ad0f68bc196e3342d87bca8c2b29789f40b1eaf68ccff8a2839cc71f3d7d49f360a448a0d181440054028b5977c389da4e6500fa9759fb0424adada62adf6fb340c39f198333bebbda9b6199eb232f9e8bf292f1c57176dccd7461ef3aaba9802b80b70b3952991c05d05579e2f30ebf440fa3cb849b0dbe46202ce5f9cbb4fe980e2b76decab5ed1e6919d485b1904756b2daf5c54680a3e3eef4bba806c68b92c1422f5a9ca0fe5dd8b56bbf29c5cdaddf9caaeee848142c64e6add7536793bcd5949c05bdecdf6f42b9f79485581e800c3ee553b8044889913ae45ad56cd7c4cbbe7c6cab1bc2f72c8cfc55823498776aaf37bdf4fa0fec5b0aa4c685dc04473bb4f28f5e20a87a0a8576e32b1c68186b8d21a39f6b996b78b2965439b94a9aeaf3e2d0e1a2980920a4f5bb1dc66a50d41e7192f0d12fd67f2b7af052392d3967d1b690833d999dc8fd77aa00ae1f162ddb03334d2bdd772ce52101936970ffb79ced64d02ef7b3409d2f37a7c174558a49914b752696b2935915f0e4f701587a76617aa9084ea34cbaf90119d7d9b4192206c79be32670d2202a469339beda2a80bc8ee45a161fae5ac69163887a496a93276949d783664d5c30213f7315085bbe908189dfa08f7bbef6fa24d19d8b7bc00c0badef9317dec056909c3b0cea40e4925a79cdb47a41405f2b3b27fbb506d04c486ef34dfd814fb9fda92dd3d7c88b28b89176e49c07561acc162b8ad2e0907bb230fafb6feef1786f458d87ff33d5756025971a9bcc1f8fbfce68d92fd14381b1f30efeefc8ac0b4783164c6cedefc51e3099e253837a46e36f9c5739740c78284e3e2f63160216e1e29aa999b0790dec93a56392c1575d99637ef70f8dbc107a42a9e2cd090a293f47a940b24b5ca33553d6ac79e66b3aef4d90ceddf1a33d383a0255c2edeefe7c31ffbac95191e56d569e13a7a20d76a8766ac221c02fd6a287a09d7d9015f57716166a3cb92a56bbeb067246fe1da5ae38ef066e5ebc85ec9090924fdbe097580e57f6634df01c08326fb8c134e484b85becbd58bd19cc4464289cc8637fa33170a817afd4ddcba9296560de7647f871c4b18c5753adb1215846633244301abac13f2ae1d9d33dff3e1fd9b13a69e11837a871b3d94ac3ec42414968b592d1fd58754d7d88b5d977c67381b11852205f14db5ba5398e34ebb8673637a7500696c524a28c0ad72a38a05f0fc5973df1a0f8bf0e0878d222c6401d0977485f436c185af59933bebd60a2021b3795021e5234040b25e154538a54bad09ffff82efbbc2feb9df1bc42d653d119a2864d4add6e01c944b890e1c3d5a8fc9f2bbef2554c2b585c6e85f35060ae25216da9e2c871b78b1809d7b3d45cf9d248bedc5a6082b1de779e88e5d5fd8aa332411d76e29e9701e05ebb226fa32ae7330c37bfd829929878a4ef1f302385cfe5313e2354f3aca26ab234583b459b044ca0417278cfaa4dcfe550b843b602104065eede7e787cf0f470733030bcf1b9f8725ae07ab8f61262768a3ef6742ff6e675ec6e289a97cb52ce19f9cd97f32b00ac4871e6633a17948f30771a4c0f97a2c58fb7a0752655db4f334b5ebaa6d46c796c856562192f1ce6286813aec792520050b78fc204d2e50bd13ddfe04ff10905eab364f367a4314f4f6a851317222a947e993c8fde003a0fa379f00eeef0ee4f7c30ec0e070b5ef20d34be8de0dc0b7a8ef2bf44ad8bb1a1374ac71bed31f32a103e154d4446c1b3f65514c90437dc3d087cb2ba3184c485688706b8360afcfa9cb85321d79cd89cfb81a1fc146cfa1af33d558192ffeaa0d28e54a5748e105aed70aba2ebce0f2158a9ac149c8eaa105cace6ed1cb9550451fab032dc520240eabe936e33393d78fbfad1974f73a4fed6d7afa8ca7c080eeead0f0041666dd3e6ca1ee7c775978f9a1f70133908f1dfc5675729bdbac4e122290ab386ce186be970ce7c6fd910898a3c1a69dc6aa7fe851ebff59221869ddf405da3d66d3ae328afd14a27b07de681fdca1fa729fe1fcca2c370d588f89f1e0e8703afcbdc4a48d181ef245ca33d4fd42a7c76f77e2854b7d91bbb146937a8af6032006035cd120d6320cf8ee60e9c1a2aff0bda9335dd0632cc42791ad09be4136f4584e6a60a1b6aef7f507fb1257a38969d8fe6a0c56df3b343988246a84c50462a892a9b63b977c7420c37ee8afce53ea80bb242c2224154e812fdf535ae2048737912360016b2fa4c944c497b6931c5673fafefa7d436ee020778dd5e31b27aa7d185f08ecdec1991bb94a6b73aef915e3ec225d17d33bcb117c3ff5238858414e7b2cec32b0c88d4fa793ef7424c24053bd8ed011c3682ae4869201d128f38ccaeb98e9c2381671f99b2dc9df3441c00fb618b27dd5259d67b8af65838d91ee00152b7ff50ab41c655ac5621cb3a617e32f5a4fd35f97afe941ea2a5a77aa2e37ea6dd59ce0ef7d61e867903b267c2ef33b376f22be7ccd69b48d6be2ade2362e612d47de125779243f899b105a17cda3d01a3fe25bffd1ecff237f377f74875f5d96c84eea093a7b80414e89d197684b7775d83d1441cb88a59e006abff37a966a39fb1055e5c268d3e02964268d4dffea0e17b817f60df6e639578c3c3f37b5779bdb9049b162b4bd26b8554f17f81a0c88b3fa0fb2ffbbdfb3a610fc06a3d6884dda3eb464276f4c5d4bf98955287966a2e1bbfe52d8dfcae6c272be258932a6d66067dfc6fecc0501a2d1459c926eac5aeeb15d06d904d9d1e2d6d338165466025e568b50ba137a82636781165c242337eaa5ecb6e1b9e58d6aaf6977ab3557cd069c809de4dbefc4b2f6808f638eef8d8bf643c3cad2fc3e91720f37b407567a7e59c97f098928855c7196ab8dbda7e394f0bf815618a85cb9300cf7e91a68404d77575adcc20cafd4cca9a6488dee047123ab9e0ab13327a32fa58ddc01f698af37f309556ecc8a28716da0dbfc80b40b02732fb25e70441616c8ecc155f4f7806d6cba3d1ec61889d0162741d2c631f70f99b93d2dc9d4362c4f65259f93e42597bf3723008c79c7255502510c5e0b2def999324aa7caaf07c5c8fa2944a832622bd20a918989f259ce3d545d6464c391ca97b3ea6d0e8631be0b7b12439345fb29b6bac717148e933a422a3de9f4a7afeeec21b3117dcce9fd3b759690cbe239bddc37596e6e04679320803c1cf2ba6f19b367c5bf9e28da050fc9241597a566e1fc494b1c33f66b9257007c5f427576a80761097c8e5914a8f606663e85849ab1541bc2ae522678d4ac7588f32c971d7cc69e81632c8c621cc935c202e2fc29258975fda5ea2e533c683818ff79070d00249716a6ed0e4db42b1eeb6a183cd5a03d2db10032e59a92925f218d1fe08de0d8b06871b5dfe41e0b1f67b9995364a8afecb97b1c38fb0c25cd1bf25c65171cf72819f9b058b40c1986b3b1147b9e45f191c1fac12c5359ce7c42898fecddd6f038214dda3619c83ba577003d9820a7d38f28797e7d919f628cc6fad584e460a6f965c093bbd8e1add153cc5ed44943fdb3ed85d98e17395b30f9ca2948534bd370fb698694e6e05aa3be7efab641ded9ff0644782d1e1826403d54544188338f242b4c0e759715ad820a699b398cb3233df5bbbfdadf88244497f1fa413baf87041d2bbe53c1a0e94e7bc90af385c44713dbee67c17043f022fac7cfc4ac93234a745f31d1ec0f25eb8b7566af57250264e1fe1d25cc3dc5233cacd5ac65dbb336158fc2d7568a6e1794de314ddd32490a9bf27180bd219a792a5f2a26070085e54a0151517cba28173b5095939df1b3a678edd3371da750d81407967a0816e68c369136473e19f7d674ee69e97986bc26a7f47a3333bf365edf9c22861b44971311ebefbb6ab611e0ffa3a84f0b225a0da210c77cdade426b5ec318dbca3297d3b8e85725021b3a7cd1821459925e86ae162f4383ecde4c52d9847ef12c99838cbe0ec4ebc84f3b7b31ca0fc0a24dd36dd91661ee6d79faa849f9034dbf52085ffcaeeb7319bcbbf4df380807340adffd29f32f3502aa058b59ddc836e7a4caf3d9aaf189c46d79e215d86bce0dd65254ccd230a3b27081aea8961f9ce1f039d6963747a3366cc40b333570a6077dd60520db8bdc149282e300b824efd5004cbb6f749d4e50d8c97cd9e6fa23511632dba122018ecb3c01154c09e9b531e3750ed149c102a0f8c3da57bb445a443ddb9d465bc110f25019da2df1a5b36ac4db15106964279c06aef5c72bd54c76d311069d937c4f061c525fda8ddd7adda487dd431c7d8d05c6fd44a30bfbfe13a91f3fb4c0358a15391349425911481f8a2590a1aa2763630061e92c1524840a8f9f8decfdbba92859f3bb5e1e494484e848bd0d65780cd7764d9c710a8182b944ad7a5d2229c3f7510229e57535c8774f869b3fe3e79b3028a0df9b5e7776be7dd628860d5e0105fb37ea0e7a2051d280fb3a6551d0d67186d1ba4830e3e6d569f5583aed55d4300c3dc412a1ef871619288d7aa1dd08471d469b60cedb00d06c7ec656ea44e1327c60c7dfd249b86f963aaff0fcb0d8aa80eed0a23ef7c7866b459105222d2772094b8ca49d4928dc1407d5efa4751b7eb97e9111431c7164991f4b9aa76614e229655261ec3b7f4e2ba4bbefc38e765c11136162a6b16e2088dfc072b64748117cd27dba0fb7521f2e409138a04c481cbcf8fa3b419dbd97068eb4443253a788d7c85eaa9f6bb1e7dcb905c450b50c6dcc22503a1eb409f29a90e9862354a42d297cb9abe8e5aa975fae3f99a3623cdba03d9639744ada202d59acca840132d144269d802bf1ea69617aef4c9bdc833aa3c33dd0321f1204b80dde1e017779e0daa8ff843b6e80f84583ae815982a6e9713008e4664e5da955c81d558dc17c7a0f5df9aeba3811643cb85807696b2827a95a09c0878a6c640ef72cda55c7e64f6c4b47bb96c1759049669dceca0ab20250525025a134503926db8515f65206c09749d3844003f5ea2ab9e4b343589504a2fb70ae824180f59aa93a05005c7e6c686926eca3e672318548672ef5666e035a30c173c7ca58df9cb9897c6a5ed1c487bf18a5e2cee082f587b8ec07ddbfd6aeb0e3e8c97f8dbe86d2e2f63f5381d027a2c785138448d64200e781edc84162be7e60fea80bc6fa595374ad4326a464d481579df6150c54444cc4782644c89d19e155df2ff20a8718054944e437d7e2c0441d95fb8ae50d5d8e88e293ca1b7f055be800abd6b5a672f8f11cd70b1c99fc1217d3066dd6e012870bae177b2ae70c795cd4f1dc1384089c6ce480b485edef76b13507229479b6f1c97f27ee5c2e3157da73b9e37eb041e4928f2d1fef230417e4ca649085f6503eb105521c8bd3d0569961f82cd1f685a3a80d53ccd008910cf54182aca089f39a15fd658626fb76e64f175e5b5de141a4def129f749fd2d7cc510f4bfdc583ebbb31d18f1c59526f84d561e4ede461748130853cdbf135a8c63bd3945fe228603311164dca3d4281170c8d6486d53e912a3cdfd9ce0b7392ce167f0b75758af27e5f194041718ffbf6cb795daf0db831d80b83e5f71789ddc0f17d4aa07e3b21a7507b5244d1a546e1a96dec9082c74d2531cb7ee1cc4197d4619d845f67ce84e702cb6c4fd366a41b5fa4613b6400fae1693a3505adbb4c7cc274f671546709f5d7aae1420db3fc4e925b7bd5d133eef9b2b2b860f0fbfdb8aad4d0afc67464860f3c72fdb5fc27cdd832d554b0e9e1e53ab278ce62a3b81249981c708078a6e82cbf60f14666f51b98716b3034f4945f25b31924f2985bb40d55ca93c61b40acdc0e585602ae1bc4a1ab61ae8a69ed7fb57b0ef789098d378aed26f5ae71633aae2709c1720cc78a9ad783c9670d34211cc9ce10aca48570dc445141aae712692b36f7b626054b10bc9c244ae28649994929d6d6c81e42b6e49d31d44cfd612ce1cb36b662b4481ffd2058fd2867b0a39e4a7393b49c48ce83ccfb2aec74b944f875b72838bcc83ad6135a2c2fca4e4bbbdf35451df3494c07f126cba100aa0e448b120046108bdf1c176b1a46aba1f2c476ded768c3e32dc0626a5d7dbff05a5945fcbfcfef627094a4a770c468f32c68d2834237fae92f34b352b18525a48b17f79c9aae1ddffff5c00906d4adbe50a0abaab442fe505fed1df7873f69a8333dd5d985db5dd3fed6d2140f57ad436963846a0c413aca98f4f5de111584392e609ec175c864954b1634556fae3af3e61fda96cecbcc2ea80d18c8e8068445f5a614b627114669e086002de6bea835adb94e8052ad2581309b30c41dd4c300a03753b1dbe3b3ca5ae81c2cce8bbdc2be7b8614da62caf4d98cc148c172c7d908ddb437e2b62be5b333a42fa6ecca1c16f0e675a0bc41b232a0dd5559bf265e798ddf16080542f155bd14fe0e567e2e327cda66399e66f170db05197282e5d0588ae6b66328bc6ab65124af4591eca4d7ddfa84aab6b6fef7dac477478d02fe3ee64615b979337b10808cfddc292f13a4491ca14b4d7af77ce78a237b82a2eac9b1015b2880b3de04f83f515e15e4b2ee781176d8115dc659f7e0ba1f70e68ee98971704ea25e678b2533c957fdc55646a1f60040ecdb74d71b9cfeff04899715357e5b3459158ee5842f6cb59e9c0d18ddb27aefdcea46150f9c9e54dbafbf932437a1309557751f5be08db4abac4bc7c70313ca38586a89b083eb450e8b67cbae3bd3ced29b3e97155ab3e8037376880d9c88ea74b12c929b45ef24d737ba5e90be02140ce56b0aa35f75b945eb12313001fde4404e5adbc6b5a8bc9992408fb915e5aa78e41c9fddeb30fda5924a289417c1a70b558d7e8f0f3b37b76c453025fed9beb60ced0779c332610ed7e114d3acfa2bd91ece86d9c4c5fe7fc49d2b4c730920d9172ca7e2462b948e7a0c4d242837fa3d331341d12100f2eb7c7b8b3b8a4f4ff47bc03b7cb03cf439a7bb968631275246ce6df72f4d00ef9af6f34c726c95f27f775e2f755801166194eeda7254e430c6539e38e994e473515e0aa96c6297ec535529eaab24ae5b5aed5f017e4b62bc5352d248f6bb4dba52279abc3fe4f7199ac52a213de1e87db36a080bbde3c4e608b1a10fdc9ff1aeb7993f09eafb814feee292b49cabbae6ef550ff31d87729cea5b721da9e5026293fa1eeacb9d5f810f694ca384c68a8f79866d323389602df2371579294a75fa663b6df3c9bff8ebd7c31926af664343a91e020eb22618b415add7e20b307875638075ea309cc13f22613afd753a5bf435da93fedbf7708de63874c3464a8ffdc7fd0fb1c96cbc2a358bb4b4fc0f7c6ff5e2f66e101dbb7ccc0072dee746252bdfbdf3aa897580c90a106bdcd66b316f731ac3b13a78232cad98fd43163bed8396d1556e564cad9cb4f571ae5d4381aa5a2c4f69a48d3288e540aedee67711ea2cbcec7ac4da963e4ca61e34426f15be0acb6c3b0b95c59062d99529e0d2b4889ae114562b420821dfdf708b1dcf2faa42a1c93f5abea5c81bb5a0227c9391bbc8b6cd04b903703f54287883582aee694a06e7e22fa090b743ecd0442ac5c7f49f1337b7dbf80a4c1a6b0b343faaa89d9e5d5d66dfd98db7a4cbdb4fb6ed7f903a76a3148fef02be71b67fcc5d0f3327959b34802e82cf947787c4999ce028378007ee5951562a72fcb5b2015bc157ac82aa27519b6fadedfd4ef2574a3a941b4b310eb0e74701d6062c04ee37595c9eb762517e39adf8704f5ad3bc3446cc19638df21be02fe64f194aae559461bbcb59da989a1bea866bc08bd0f18911d81d46bc671767228edb6317ede55d75d225ec4bbc40a36775f230a9a481ea2daa21c41cb68a1ec0ced949e6f38853278c6722cdc5967b983904ac3fdea64891b9b9bb7c1b432b96b53305c635430bbbc748f5bd2704c95226d5e9b519bb8205de7da60c1e29d4ef2f68b19aff30757897733f720b5abae440737b78644e542c2115b0c146a31ec1aef371fe6ef3b6a4a0833547c5d94c2ee40a59a6e05d6708e1c132216566660b78d2fdc5338d19079491f58f5122763c29820c30c44cc8790ba30d4583874e8f40244c35f0eae0d9f69097a3ad22914fd71d6607051ba6dbf42b5482a649984924ac0df2d0b05468fb4d8885baca3017c753ea0cb3c4b0fece5139e02ff061c63326fcbf719d542cafc6519eae5a07b5667656d45d5fea381fd834f619fa9fe4c32d806428b2941758c1b39c63ceb44ea406c95d84830d2a93e9e1827c8cc832b788f152520edbb1151db5a95d3bd8565e5e3a10106616de5c2a926477c53a8042ea25bdf2a1f5c736a59c0df5d197a08b5b05e6c3ef3d0db72379c16acae8e6fa20584cedaf94aacdccc8c41bf25a8b3b57dd35a7fb13764e264b589a75a923f78d46e1350f468568265ae208d549eb3348c195c75fae22034cba4dabf98a176c6dbe33a294210b6088e5bb6904f3b249141921aa7a4b1fe9b1bcba2d95e9d26e5864bba9b5a155bec033e524ca84a1be97e7350504a3f641a1e927e9a5ccdd2df4abe40df937867285e12c2130b8b758d09033eb3df572be67603093222b5a8bccbc267fd9ec5f689518d2ca19aa64ede4c10c48ea55b0f44d7eba5c0a1332906b4f8c2660404fe5e9e04904521328cab0cc6d650f2de13c4a2a7537d8cfe852d2e12a10ad0e04899cbd2530a7c0f7468ac874ac74980957f93ece78d4d96080d572b0f5218a861d8e2895cb7d92071d0eb9a8eb5d675fab40ca920d546ab7fcf8fbf16df8c9473d9037a9ab4650c0b9a551129fcfdf3b82ef23f9a3c6ab3a550585b385d39819e6324808c60eaff5a9bf375b2509d3af0d51aafa2b0cf67a8920f466a29e003e19663eb39b0a10218582cbffe82547f0d4682299625cad19a35fb91e0cf54e9a393d7cd47eeda6e4e5926af46bce739b1ca9f4049c77ab4b8448e9c228bce7143464ffed6b126ed58c1687f65cb4068f840d753ccbb2ca0c4ef9b4b62746b418a93e58d5f9249f3e27aae181a31b83f71ff3cafaadd3e6cece76fb23b77208ade924b405e15ec645ace8a3dbd790b8bae461660c00014a6f84f69410dd424caaa6a7b3307fef75172a5052b2156d33b83bd451547b0c79570933cf004593d13cfb6396f6ee1a074c15e4c82c4f4175c6fd300845a7d5528d1d2e540c67bf9f4daeea9c4df32949bb7953a63d193560f692d1f87819847f00a8671f78e583826451ac06c53e6301a79b7c328e2a2993cf20044f0d74a139376cdc36d82064cc37e28c22c983fa2c94682acb5fb236a2865b137e0baed2a5e03dedb96b8f6ad7ea150240f9b8fc93a0991f905771d88674c29c35ef39f1774fa877cc7a7445114626b9a21b306eb8e496d4dd70636fa4ba251c481edf4f04a670a21aabf82552a13523656ae0decdddf81377206abff1d1062899722f3959d011a44c916ba9ea849d6802585e154f354bc215c76d3ee49410a271ac99ffe5255bebda37dcf7ad2cd8c6d168ac3baad97690ff89e61491b085811b86abb1c28d05e0950391225acf284b81baf9a69e5296c9c05057e51d59fe80bc8e8295fa226c80b318de5e3e13a508b52ad587ad83c1df0578d2479bfc66c59a57b109eba7b073d813b1c17039c651ffa8bbf80c75d11d62fb533707265a64773a4250dd56259a532eaa45e206b74d1cb2c18f8c286d62dcd711d49d785819830169d53dc0f83b5c5a8b23d2188dd9d6f6792927b85b8bc0b6edc8409e9a73cfccc4747ed05581ce628cce139458769c11d0e77ee73769f1354b6514e51680e1413400af86273703a1b1da7a8a1d6f2cb866b3e6992863ef8c1af3b9628022affef81d8d12e4b4f6e969257fd203910dd9ff8c898e087ea8b06e8c7c836d86084e16e70a8aa6fabb94e6315a4c1c46f93dccabc1e02582d7db78db8ee0fc7b977738fade47a5338734f36b134a97f279f552688ba65d4326c204a8c6770ba75c5ed87e4a77e1fb44d67066cd74b6d4a4b559fec94f97f67eb21f44382741531cd69f2ee6210d11ebed3770666f34122b2a5b56adfcd1b333f6ae2ac3df9303272b638a919173aca6debacb1f54e71b4ab500ab2ac9ae70b4287787aab6c8fd53cf9af5e3928a5e5a5813fdadbddbb93700ee72010d8519390dbb0b73890ac8705a8f425259bc48e729fbbe0ed0234b797e6821421a8d5f8af0bfb35f1111f57e2c58e900f70ef99416861f1b3c2467afa2029dd37d5b80699b38e3c91ca6a2250a2a5cc13997e19a903b8acc5b66e1ebd3a1667f13d9d97c48e10d5220e7f9a91991f3e4d9030196b495b67120b8d7b8fbe8b4185652ae0d3ea4ac8f6fde2961696169d500d65a4adeb9ec44b3acec1d6782afb2aae093261f396e35fa4b8d77af770e0622742bb4f73bc4ce7ab3918c442475e2b7b72ca9cb8a3c6fc90c2db035da1716c08be09a8947453d73f4c38f5aa002f8117f2bad9d0208cca5e51e150f4f1c86ef083ab26bd5b875daa0c9c3e49d3c80cc5486fb7b54485fc48ca90641f8e8447fdf5229ea3a7c9077775ee488a33482eef8ffaaeb63be65f2c055ab84217b29252bd6149fc91b31b04ac511726157283d223a6afe799efd8b6c012dd88cd839b43ce136ab6f78c677ded94146a50806aa80bdfa2bef2eac3545de4004137e11375a615f05f1ef688481e88f1d19a35ab0c40bfab0ecf3e1380bb72e9eadf3d5c5b304b3482754c04cd8ea47a5994621a14de0a2e9b83f9fa6f122d382fbac388547d40737f57f0770af11f5bdee9d2b823fc958208b6be3fb5a095256f8df731e7b163358aff38881ec2b4a9939d3eb8133e1ab150cb9e511d6074ab6114fcd30f14c40f47874dcd58b90","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
