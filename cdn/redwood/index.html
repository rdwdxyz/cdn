<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e6f2c57f6db600d83b62ed5f0e2f01ff0efa40c057b6f3a343a96e52d20465da4bdd883fdf16c52fcf06ba5f2c89488fcd42d49ee97e44c02fa0808dc33e074d3cad0d64ef655c68f2972dec8249e379ed1de214500a836ec3e1d5fb12613f15a5b51ceb72c0f9e462c08bfe1209cb6c472b555589be21874185983e19e3b2c906cd2c34ec36d632cbba120d75bd379907efac72690e8eeb413cf0159cdf730dafa2d8aec1ca49cc2185c3c06215d5cb0d7ae48f37694f128438425151d51efafd275c0cb5b82b9618e54985df2b4710b729f2860cfd66c274dcfeea4b7ff6dc9912422e07d4c17d821320fe71809d849ebc8a00c3e43afd3f2801122da8464b28a253b1d028b232fb76473479df6175f81a903404d31c5f04ba73990fc7fd0f663960118ec632cd969df474af09abdbbf9850d240c0e26f7815b81a43d25b33e4d403d071d0238c34a0f10fce9aa6734e5c31e08c5d19111c6f4c420fa9df482d1a28947c291e30fe8698852515b69f9d93addc0319b875d203b7d6a7f3c85fd3762d509f8b254f873a613ae9f8c35cb628029814edfbec0031135ba58b4b5590ca113218550abe68998da7fec378fdf5e52fe1dd0a0b800c34114a03b23f3b52d9bacaf41a1839290245e76730b64b8d81897ed621ccf446eceb1be8267b31bc9ffc0266b16d95ac01e39c15bf842ae8ecd22d62832384bb3146d1392f81e85f1a7bff05e18ca034c44de494b9eb5a3236d63808d194c1f1d46e1431807ee64d25ba64a66fe85bda6c5666cf0aa267e5e9057bec951df753abbf37f6b52b82426dc6908d39a996bea296a7d8c208fe0aa70fa98cff862ddaece77cdf315c5f5f17a42ab55743d5f92582d0e2370d004ebbf49f7cea28451920352df5328d58777e04d7d5e0dd564ce79280e1af3230177f32aae456d9e02f1a75bf91e8d2867fb618dbb404279373a4e956239eef585a5a6c7904ed30dfc27bedd441fc2e53b5dec91ce9c5c7eeb32a505a2d66c1881e84b1311d9bea3e791cc7bf41aa1319f820d154dd2e961afbe0978e460c234fa9ca7cb471f0a26fa56d4b616d815306f4b383159f0963238b3cb5629250ec1ae0cf08d439492b36ba2579e686af5d9d176c2547dca8c694a5b70d9112eca84f4da35f31b66096d866bdd1f850dbae51ba43b165e03cd80fe8af53b206d61595af6fdb095d6594ec3e1e7df5a515e51a1d2d0f2b8fedd8c5366fd73dea8b2a43fc833ad08de3d767fdd6586081546e410e34c010fdaae645d28d27cd2d0268f58dacda09b5f3fe89736ca357a4f04497a6dc28aa4e485adfaaa53dac709d62fee731f959dacebcb23c5be6a9772c25497823eb44236fc59c5be308327276bc8211af62e72e190aeb171f4369cc53fbad429f38205b30e7c3fe93e31136e487692c8c2071406da5b4afd14b845551835c9ad7d6d36bf609668966616d285750d9af1bb4ba0bdcfcf01821eef11c4f4f8825232f89cccf809f8adda0b3ba6c26c675fc854098f198378e77ca53213066a18f143ff2b9023d7a16801c1120c764e977b898977f0538f1b03c7ff5cf4d0bd32f156c5469a9cac678cdef01cef0dfbebbaea7a3def2df4bceaae4a584025dd97f834b2dd04d986478d1c930fbd819551d041a64c28e6bc41d049867f00d7464376c2dd36fe3bc1b63bbedcb1bdd3720eaa936143a0df533ce6731c9818cce797caf622cb359ca80b04070bd6937efac9bbde1a599e98e12f012eacec8b1c6ca679d2bf8b96450c7dfa1d17c4d9b8c4f0b5ca3f5af67b60c0e66335aa32dc8f9fa5daf99330e714240b2299cdc1cc28aeed9c51e57e8711fe52beb44c7a5a550af27653b7d709281a6f4e4512d15f3148dd03b6727e347d434cd8ae1f5cf5a62e26391acc96fd8c3e5b76c65e8ec99d995ea8bd4b1a1a45ee05968cd84229543a66711b11df93f8131559f839cc8a71586bced61e054a1ff65d25376a2a8a13b3c665eaa8a4f8be966849c21867c4927d644970ca6f1a8407fd24e32fc25eb065097eb95c9b67defa284a8dfaefb0f0c3d309693c8b445d98feb0625746b5415aa2d80fe162a3ab5601c541b1fc837033f93a725524f61413b24327f9c1ccc5662fc695773251a1d9c8d17e25a3ebdea123aad90e8e750a961c4d512c5026b7742b5ed55ef5cacbcc136a36ff8ba22cd00b443573bfc80fb8dad8a5c35f8e43b424d6cbb8f1da9a2ecd916ce21e4e8ea1053c877d915363853af6424a27e2be177ed5e4e78db5964943eb88080a5e28361f95bba50edd4d99913c43e49420d532cf5e5b112755bea0b40c052cea113ab7c2eca7b9f6a1bf595e05356b9ab7b2b3b15dc64a971b8907795aa573d87eb93e37c69155ed03ecd846c5d1dec8a9dd386d631bbf317a9a2ba634caa5998393f627c66518ea211972e1fc6999c9596d0e537514885f4ca8bf1a9fd0be84750b5481bf1bcb5b69e56ef44fbdf7115b0495701637adbaf56d87a10fe9ae97451b7121900815444ddea6bf06d91ca4389252af66b5724b9b4eee17e9f39ebcd3242bdb163ceae1fffde09241c39946538b0ae97b7128e32d79e7e2377a16de4fc36d46b9889b766031cd5365bcdd77905c1b11453b10dce0d3e77b872506954e783267fb19968622b2ad86bd19a9718cfcba15c5170f57a6c9b77df9aa2491b70c88e77d329447364c3300294054877de8287a5dfcb71543b08a0943bee06915c3f956d6030ff056d128259eeefeb1ed943289beb864f16d30f0c0bf4d11438e5facff33f70dbf879ad2c4730b89c4d92d2efa648cc18b18d2fd9a036a202b7ac8d0a6b637ffb706126d4b56afafa3c246788486b10a54c71e688ccb2ebce324a3f8c1aa48c71adb8b9ae098c0c9bd72ffb62c44595c001ee09f94a688544ffa195f12a78be014f63adff85a12fd4c0ff60e4953122ae13a4300bf1f812ccdde0a2ec13154b29fbda8d27f36b7e8f54db359f2dc114b93ff25601fd936f353d28070ccca73c006a9bbf900e55e7fb9c5ad545d6a1b70619931f8e614ac31ffb3865db5bb97e1da1d8d7a4dc46aacd09884f197e2e7fd4c117bfd2efa4a3a86ea7e7aeb92cf8d00412fe2af8768a9a0211a691b437eb1e3f92296ac13f2fb97120c9574c4b897b735201bf1947f9a5dd1e67b4407e7f0eacdf09fbf1f08a559149b0284f25937b9071aef490d560860e194a979eec5492459eb7a09946285d852213ac3adc7a7b425cec51fdd22051ccf1fb93443748ae45928488e658570a29a933baa29d2ba15555ec3a274aa2f146f2e7592751a3c3d9a5ab41fdc63e363bcac8d2ecda8b9aee1b9c74bb0b14b8328e5171c2c3a59682652e901966da19e2a21ca49e0c95f86ad68052cbbea6aba7af6bf580164f0fe55bac05513d89ba56bed381d89025c791d641e50d199d3bb7b5b092891372e1a0d363608ced5e3a4b72e8fed2d772c78f496ecdd65439bb3e00598eacaf073d3df3550f770317c94f166c2b76ff92e82beaedc7333144c3fb3443064eee849a5d9883bcc2a1530fd2dca8c667ef7e9b19f480ccd810b082be3c2178f044c5699d6efc1962e1ba8d5e30cd2a8e9197c63afd34e9f0c38e8c4ace631beaf70467d6ea4529d1318a383dd9a3be5a85150d87584452a79a2f262db3870de686c58463235f71fd167b3a4e76effa10c3a29340461f59801eb49fa94de6e636030a09116efde796ea31c435a3a246d27cc566a71e9791b9f7a811998116b7c918d19faffbf4ac0c4786df62041b6ada2f711c4137b8d7216eee18828731b8c33fd33147c0db7ab9266d7abe7f5eb45b239926c00bb9820ac11887081e5ce209662d828e02533c19d9179051cd72281e504d7b7ccc7b7a2e4e105551ef1ef63d4fb738247a4da69cec808aa6c46a6e69c8f63215fb11fd6092714ece4b90b4b87ae1cdaa8b00c03dad6b6188f3079f65b786ad6b676a3dbdd12d58b5aeb625664aea3666f73f48b73d80db3d86d372dd5395dc248b31bb395c209be9e3334480a5d685d2b6ebece0fa9f38d19c86d735c6b725809ddb811e7ed40616d5fcf5c083cd185625c1be2078f158bf0c1f9036504d7bd911c1042d1600ed043158cb68097069517d546e77614eb9b609f83e6d6d07c3ac5befcecd539a74e456573f47ab5215b6178965b82d3251f95e720af061f90a04632418d550aef8121a289811792382069f31944bc5440d0ddf424294a3d7623c5ad2ade5f53ff3f612ae798f1c5cc5cd7356d6134123a2b10e5f5da88b1051394272d883b2030a253e939f4c1afaeceb8984f80d033450d08efdc1b48c5b7dd033a7fc75d3748f683a74029b4e2ac7f1325e7f4d055ea483f80f47d0d6722b2c61dc4ae7ab4b7960c08c439b08e7a0aca1b09dd1cfd44e8b30d8dfb1cea2da45d30377c42f1e59ae903fa56349b04d27552abe3f17cf33ed1cde086c268038d831735a09007746a558a21fc96760108f5c51fe823ecd31c9f55c827c648a57b2aa2e0a2d8aa9ecf333c69f3e58bfe130c40b22533f5f042ffa363d0a74b7e6920542d454813175d51b3b0d69f08f176a4eb8ade3c4709155b1baf0bd67a9bb74c49ed088a3ac5d22d7af410e7a73fadfd04abcf97658340961c16a96e0cb5b79b27d674205a11736c8376d03db3c2db7eb477e5c0f5be6e62105ac9658bf1bf080d92e0e0ace977a274d6cf49fa700b2ade4f998e533d5329ed0bcefeb7e264cbd525f8bc045254414d66977b4d541bac8099a1353ba85ff2458920a1afad756bd30ee906f600806be98caa3c1c9e2a0f9a9e94e25109921392c5c4c8728ad42c11181a4e1b6ccd37314501bc43c210e9935ac30dc0a7b9ed62a470da8635c69a2bdaa5acd3d94556a025b48dc7f3480d76a28a5701da9a6f8ebbf0a7c1f9a148479529b51838935f6079199be9a3b9ef2f3d9b9e326bc04d636aaab8c6582b76c018db5731df49d85928dd7acdd6e7f03c344b95d999b334bfe0bc9956e10145e2e2c897369acfa3d60c1196ddff352d4598be1ddb61468c2e52e690b1f1a4da0e51b002f95fa356d55a1e2261c0c6eaa2a089f3483f2c8992a90aba8b73443f7db56f034dec7e108774fb3533693d8fc3956a3fa3e144a8bc315eb3850813cbc2223cce8ca9d0b933d98db1bbf759c17f0189b57463051f99aafa720f6a5b11595b1b4c48935d96275dac90ec3992910ec762f808ff930820c6a1899e30034e8506404c715bae12353c9de79abf44dd459030e4348a8782e2a5f8fa7f0029abe6d98a9b01195c4023b573f933f36a3eaa071718de11ebaeeb2ae20b4e12a59a4f4bcfc4ee73a37c0f91b9809bb5baf334b322d53924531d8ad71209ec6c83323590d7a2d08d76429dc7bda8a4c2fe2b14c48545bea2a948dac0830f578fd3d18eec8412497443dfaf57c7ec17e7dac1e5d3107fae0d67cf5964d6a61931df6a4e462495f706fa2bd2dc38605ae298c53d0e0454d24ba9c743f5b8e20883bf6db9131538e67e7158b2355350936bdbb8a8617ecf590e718b5e65dce9862308b19d6b194d4290fc601176e44c8e405ff822440d56d290c7eaa54be75cac56a2f511405e07266251cc14ceb427598a1ce81c6f4315e978b66f5d361593a515786f83387cb8e874520f607643b9d163b050d90ee8dcf2b60e7c6e83ddad0722c018f97ded8365b778171387cb8d145f3cd1b27010deef7e281f66e341dd0c4e83f1d33c34c35304ad608d3dc45e71c52f56f07a1a446f28da5117276af1af6c446024702f61bdc8135e0a1856c6835059cc6751ef7ec0c5f63231b6da4325a8ec726e43482740aaf8965678286b6ffa59f67d848d8c94d52b6b4429d6521724ca99a35a9ce1bdeda6cc2215a8978e937095fb9657894ca8a5f344e976b236e424aed445a76ed64455d075b9d4e69b44db8bd7072bb5fff3d29aa0056f80b13c69f58fd530340eaba08fae4c76f56810eb1a68646c720a560614ff820f0535abdbf6243bcddc175e8a63397f78cc54491a1d15a1534cc493e3fc2fe09d905e58037085bacc7eedd0f92e0dbdd8f41498dac430f868dcbed1f8862a45d6ee1381f88acf89ef4947dda30eb8d37b5966e9a5799f4b59cb62d256305c25edb063a16fa996936abc6460a86a51422e9726c73e5598b0683512c15b4acb128e4c4b85286cbe6ccb40706234d039f1a4574a0bfbafcb4b816696f8c23373b99a4c9ca3b1841847adff1bda6490a5ea15cf18321d7e4f72b04140b5563df6439ac4c29fad794e578f4fc4a95808a3fb5e569c76959eaba32bd2b75cfd1d2a848ba5be1bb55c64dd9b09bf1cdd4ba8410f60632222707016986f9c07544ed45bbc7e465775d3154ac7c2882d759b39ef4e753be639d8a34dca30200bbb20ead6a8896e2013b4b7031afe903e0c5abc509f89fd3166eb8420130bf018b2ac4be7fab9f3a428c00d37186bb10c702845735c0bc629283397c427f3149c7b4a99857a50908202e87441d59dca6b61139e700f961eb44d71171e20fdf608ce908696e929454b2e971a2f405ec5cfd0e6a4ba2b128e12bb1973cf49e59d6fdd8eb338477194ac7c6ce0e7790ae4f0d1199b562624e852919e90d50896f30eb8ba7ac69f66c79bf6521379bfbe6e69fe80b549e3cb444e30216d4d6f4642fafcab1e78c2757e24aa2c973d7364eb4c6f36fdd967a176338a66e3bd67027a218c5fe616cabe03504c0ef23f01ae3602f988a7a975c8202a7f960bb792d69d2e077504e76ff652d74deb13868cba7c5701e1087664c992631f5a4d3f4db6cfb0eaadd733453f274c00626c922ef5679efe917800765f80807b6462249ee7c10184655435cf3502dc5804ead47d5ba99b46c577076a63f8af48ab67f3c31eceac52c380ccb776763e9c8e69da201f531754d157d64da71173b55bb78bbfbd5e070aba44a7213dadfa58eaa5ad6a2a9b5d834a807f0dbeda1b80d8519b5f75dfc2b08fd8c0a0b35e8ab898bca5165e18166c7fac7110eded6f69802dff5d0921a40f0324014f2202478dc23a5c143ac385ca9da789546dc997f3d3b5ee7bf100f59700c28d2a98fda3efa8123f1c875016822cba9f9145baa26f080b2b8d0ff03c1b2f165a9f6f01744f43269f6c7359ece6fe513640aeaf604ad0a67f53cde658ab5c23f885feb2c7dd94e22b3eab76f7d96c9c771b2e34badf680a1c93c9a65ab963c1d40ce3e0cbd677362c2e2b192fc1dbb24f1e43095dfd66a77f2be9f8f5ccc4583faf74e815fab325a7e88e85eb25ed77836a1471de942aa8f4a909edbebcad22b5b8307efaead3ff4379543ffc0f7755bf4e102ec2cc09131dd93a50326b2d3124f43ea7eb68afd1fb9c0ea03795e0e167c65412fb133079b1444d946e0e5bd67b7b5277205e01be5953d074ed2a546dd31842ebd2485fa3a7f8e9f4c533fb850f448c79b9cf61e1f52013187a0b834170ddd8c45223e3fd252ec1ad3c5a73f4d084803d7dd784870aacaf79e02be58e27b0a29ae324589dfffcb523b6ac33f7736b9b8916fdda4f3b0fa1d1d10d90923eb2ab7de4650777f21718b7b237564ae0a9658b63cbcddf27be641606f03e0564365b91ede2b5ecfc0bc2c2c3ca765da8984c82e665153355819ad409c65355510ab897e51373323eb9c8bb5f9ba461a4e70918bcdee2e51fd18678fa645952a5144f627a91e9db8e3eac3b117aecefc80f35723fba917d78720695f223423b21d53e74072b7c0aab70af22cf38e86fa9957bdadcef1be5f29473e47599be1f0d29a96de79cdb9cf30b5b68f7d7c8f0b90f418cae55237b17fb7cc2de14af190b718bf4bf513f4653c687bc9a45543fa4fca8eab01f2f3926a32caca339dd51c4145d0bac1785e7214723247f965b7967ac7d260dd51747a0850f596abcf6a437572bca7d0c38f0ce20a6eb121b0ac0855050f5607d65a35506b0475c157bf8a6cda69c9146f53b8b3d73f9c45e7eb3c33affb695e5a45f3c9ee131c008469d966c0317c7a9d2008744e2d5eac09c0e58586f4895479b105401dd9d29aa5378d9e0b1f1544053e33b05c433b407179b4cf54104e41e7c7d197e8b57d36d70404b663c23c6c4213f17fcf0801341c8fbba56f159bcf4822a5c9f0fd1c74f8c61dcc01eb21dc468179070862e27e45c951d8490990a41ce4125c25fd507f156ef33f54e808c5459f28b321c931e232e396607a5c2a8b35157a4e80b0e93f27658a2e063f6c1259d3adfa90df2f474b6995269f42feeac1b59c22aab79c0e3ac3add4688aeaffe76067b8d7d03b87ab6e110f17fe28ce0b6b7345f7d109258caf3d1cd840009411331aaf56c843534be3e9fda3bf680f67e26b4d218bb48a88cfc6dc66b3ea245a399588d7fdde6e01198b43c52d6466dade6cf974613b6480cae0f47ffe91c0317a8b269e85e1fae58b643d6371aa5d698246a21814976d4ba6cee4b8b78a62192aa2d8a01928c4995e6160a2fa0915b6b17658216cbac5a1ab134c8db364a1c9cd8b6de7b6516ba77e54de0c1b121351ea92f95a492e5c2557dfa55e80e76a3ab79aa4e79af1f8662194b2de41461baae4d08a28f3659cc8e11d9668c1a2561e5d65601087c69c38581f5513e7a0cfb376788dc4516107529c8d06d02552eefc41a01b2d9978f3e1088dfeeb4780c2643f0b1c0c514922fe178300a78a8b51270a3fd21882c57d465752954fce5ddd481a110cc3fd82a41cb2fc9577c379916b7e527b2a25427b074ed81fead0cafafa8246a753992a3ce8ef5beb575f5bdc76e544c3f1f6cfbab7d3efd05a7927ac3ca205c6df34c961d3662b4959f1b2427374ef72ea3a2aa671ebeb6c9001f38755b6cd767a1f589d4f02e8b0920937e358451bf9c6ead9723a99ca8c350ad5b7ea0874861273ec2cf02c9402d5ceb204bb3c752b13e1ae9961185d45b6059f68c0bbed49f34a334ea5c5f6f0ed1454e0cf48893b3a914b5a0385c366f51e4c031315ebc81d017f0caa3cb85c5adfc185568d326edeff6d7a554a7e27f10d073b88de3d9027415f9fbe0a3b80cf381bab5ea7183658e3d730f14c9072c1fb602f5d08e5c028590d957cc3aa262b11af735cae989cab1a1aec9bc594e23c24128ad2b125e602ab05ea274ef312f520a9cf56b82720d301483f96ee730784b25f593de846f3df018a24c3945ab2858d487e7940b485bc38d60689a0566ea40eb491e5f0ca70ae24fead8a2c32603d79abe6fc307b0c69464547975474f1ff7896052e55d7b7abd21e191d50778953cd7412629fd7d7eb7752a4ca363d179e11a2e2a6cbc8a00caffd0400cb936ad01b8aa97b4aee33dde8ad559d1f6b75896fd311e365375b53a374fc110c1e0380103eb89305a3ac145763badf6cc49c80c60483e8661310c2034f04d17018d566df1a6b9f2305b8473dea9c94febc74aa05a947211412f9fd8d4f05529e28a432df857bd0faef742d2dff61618c4457284d253ebe91db2fcebd5f901dd1f0667e54c497e9ad6b27432bb997a69888ceb0e5ce50fdcb40cfedb84afd20ebde595496676daf36922db679158a0271539d0bb6c3b075b3e623b7f84984a897005604cbc0cca0a5b970160f0b1b7cdf747f547438e1bc2fa957a2deb1ed03c2cbb1df987bbd732532368cdef8d997a57ce11a35dd7314dbe9e2c991b18c65196d9caea5936068d6df0a0fe37e7f874dcec29f5616a3b141ec5d644484bd8145b54bd25bab8c7e2bacbd01bf090c13a398c9a5fa1ddbacf2dd808682499477b08cb79688eac02fb0f2bcc221d5a372dd5b0d5e793f90ee3221e1b7e005e6f57fc85b870e11cdd5a848b6fda92cf556838ebc03b01206f360e3067c5e700f6ec224026b1f530e998bdfe0b7603b8c8e209ca4a6e0238013a8215bc32ff38a1142a8a2e69d5b3def0616dff5d023e43ca2fe8fe4fb377641695b2c6ca5d482903d341444a30eaf2f599c3058f09446a0d0e5f58198bdd5db5caf807787b2441e1fc927534c8c9ab9779b9bac8f6271d17cc610a61aa8e843e0745ed1b2e56e0bd5492d5c12655e9da32da4ca7a59c47ee42bd048ae11d80ff4aa325e6b5eeb5ca0b27775e4105d146de2f1ff01e19b145245b8f5a9038255ee7c7feeaa71e3cf9e141e4ac49c5fcbb9a1c6677d74a5b2212c531ffec61b72d648c9245905c8c90b1d5aaedc33c93f270d40b3fdddb80da7c6329b296f8ba42c34a6487c11c96ceba35a101a18ca67a5de75aa4021791ce3f2b858dc4fe182f57fd60ac9c42d7988541666ebce260c6ed12faae036941ab26779a3d2636b85157b7938f06b2d1863d731e15cb6249ce64a19645a2b122a6c6f5a1c6261e21298702beaaa7b6ac038424dd2eb501816b8e3adadee4891f5c6325fbc3634d5c697b51b2330943a99d128e5412f24188e25ea91060cf64033f181a6bedc46aa0ad9235f007ba389fd4d1d12f99eda0aec83e7603be82b5e2033aece9d2592630491558314154c7b098f1e767cf81b05b38002fd25c930cc813f7f4cc2a0cf259cd60e9321315f247e0186f30f9139048f4e7bffc6fc8f4009b352f141be019fe74ec5d08909e36fdf6347b9df51e2b6508b1d984b09ccace2e8bc4c0fb79eb04ebd8485fbbbb1701f706a91a5889b21612c8fbfc347383d7b1a670610f98780f027c4a12bfb9af65d3fb04daa426198421b8d05e0b5bc6cfa84c0599dcab0e5ea31d798c093a16eb192a69cda12afd65ffc68376f600ef76cd148ce19191b8193199bb98d8c6d7de8e93ffdf25daaad34e588845638f743ee2030ff8ab164368ee9b98fec32ebc29608f169dbdd788c5b63977505e15cad117e536490b69b2a591e6003c694c9c3f8bc84b1b6e9dfacdcdb5f1a22e1bfb6947ad724c7bfbd32d10085c1b29261a0dbe87db84aec50a1ba5d92130cddae236bea136cce208eed489e5880663ccaaeb6691c394cc72894f9a7775f7b5df802f49b4f2645209c192a10ed1e3486b1bd3d0154a74e4fa11df2cb978710bf6c73f37133e3672fb8cd46b4fc6e4003431cdd97654fcf935657bf6cc85865840d34796e8d808a87b237e09ce31ae88ffaaa346b63df0e9f36eac7f35abee628d553df0714e9230737c5aca8fe5734a754af0e93f915cf63d3582a8f125af09d35ef7a6c514cc72d92a48b8ccfd21c0833e320ebb78141781ef0189ec992eabc9bbc441f246005026289467be38ba09a6dbdaf73744cd5257aa097afbab7bd7a352c85b5cb3ae52a908c6c4420de6baec4c0b3e04b3154bcab5019efd2d145635b54f91eee44f660cbde56162f547ebbbe7f9cb8da8f7ae30eab6cd9e4ca44fca5ac5cc4bb4332c9368dbf9e1df5d8a0dbdc3299ffd7f3b8b35348b7f0fb6eb143b39083ef2b5f480cb2d0f8a9f70e6c29b9025a9093e794f9d22914447c2a6fc10278d22160b4b90518bc9e4ebc62d956cbce8386f049bc85f71b3f8e0aa479c5a9a91afa634df106b486930977ac2d3ac6b1c7b6bc2d2ac37e0b61d1a20280a81a956e0b225968c28417b3b5148a91a86980b9da077620bd791cd93bf795d8f1e492ade7694f3f0fe91047c81f69278762d247d746733464256b5ffc68772f398ec7ef66749801c897de095c64604b1f56014823b402bdf00ee0c61d9921e9b08354aedd22dc47d318f05193d354f456ba922b28ae697c0dd0f33acc09840bd9cafb26453b29c1bbbb312611c60f8eb50788f530e9ed8a29c86031b390e630ee0dd0a68afa6c18e3abd4685a1832bdc567cc4aec6f4c61afdd0d87c75fde71d14176a2613a125853ffe3448bb606ac93ff762920d77c0678137d6e98855c36a8f9567326f19e7c67cae9c162fcc5704dc8ee6d7291ffc6dd3e58cdf0c20d700c33397cb4f7c571eccac9c3d2ab32d0e6882025df4caf5a470ead9f05287929275771695e9d0a036569e45f352a423f76fed65a17081d4644eac4da9849e9c92063b59baf57a8cd6287ec32cb1812b905b9e40f03ee87238772e0ea422f75ca48d73f535138081029dea8a5445217ff756b21748dc7eab05c1c4bcdc87383bdc4569fbecaf737ce77893104f229cbc98c70a32645ab21063e14a066e61b391a8e80b0068b3af2cefcee0699ed920f07910bd36934d219825561a8a867d4707fc8bc4a9dc96cf1a343e32587d0ba9a50fd77359468e8e6c8fadfb0f9b723cfdaf7385170d98df10a506de028a1df1843f6dadd326d84b5724ae702ae013dc994e18475aab1e474f01fadd2fbe76316785b9f732a2a3864353fb20343d957ec45852025d5116f8a53e545ea131c50ddaa18e9940823b1db8d380712a5e930547157256f7324c982cba619bb2c55e796a83d8e5b1c120b40ccccfe257e86348ebec8c1179ab4b693a255e4a15369ae7ccbd8fd6cdd719bfeb206d70abc0d4c5c8b7fca78eaf2a7e9397ead77ac90d4bb190eda1db90cfe772ff814903b8005bcb49c9495a3bc335f5777a72c8a63e8cf75c96930d089b7fb68fd5aa9b904db5efa072de3ac28abccbb3f0482d176665ccb50a3d88b3a63b0181f6a1fa801121ac3deb2ba49558c311fafa5fff0a26018015ddb3553bd9c071c456224f8840e93beca82eeea14a637cbba9c601840fa7ca6a197ad5f2478e050375858d129f42a6899091227e04a3974f5cfc1b2f48599acc3d6497b939a1d262567928f56c4967cf37bb83e0eabfa1b2579d29c98970444b4f212527ea09f337e63ef4bdce49c45373e58119bd6a4d18a76b23cfb98c5c2be6c3a39d3aeb58c1bdfcf16b552db6d90caee60f712290fa41a16a59d997f262e03dbcce0c04db299a7f424bf111d9c7282ea9d8a98fbf59e615a8f915aead369ea7b18c5ac38a7d14b453a2612170db1677fe67e15046c6721efafc8442db0467bba77f6cbcf690daff213f6094ddf0c943e23a6f5c0feb46132feeeaa117e2caa3c5d8bf45f02e693973d71a973edffd507a5785dbaf4cf0ac7badccfe1cb0c4d0fc5393cafabb57c6484601157f7ed7a25005a21e71d14004811f0a3f84048d115861758675dd776f58a403a8f7288a23dde7d01c8580dcf094865a72a012cb6805528167015a74860bcacb12712d8d166fa12b45eb0d98d340361975b7bb6e4a39724b556540d5868be6615f04c5f9bcac4096cdbada3962c7c265d0e57485965e83f6e97db021071c3fdce8b301e09a3a701b23bbc4dc1b0811f4eab1ef8a7124c21fae270fe3ebc89dfa1889b7b053b6b1837a29fc200f577849b290e6d149e69836596b80f464d821632ce5d3a6e15e919784b68c55cd8e7727492b0df15aac7469923d3b97f453a86d06439cf4d2145c4852f5a431c42bd8c0aa859afcb293bec28610b919f431503c7d1cbe92a5230a2d7850a30f9d0eaddb9c6ebee7d25d76ac0e72f61a20cceb64715ff6ff5d31afc691cad564303d12e73ae35fae233059bce16e586d290661299bbe9670b6e02b23b358e05b589b0d2272fb60028847b55c7aa92fcace4b3248e4767b4d6437634f29f4db54e04fd8fd199a9200309cadd3ac31dd7e66e926771f7df5515c751a9f7423ca525e9a37e7b6a066af0f5528393c62cc10d4fbf91a0a6ef88199198b119b20d57528e2d1b503a2649afe27f6fa2704bbba09f95128d7ba2ebefd5c5ba64cf3a85e8ef5eaf1e0e62cafc4b60c04d7a1b16791d495526199c6fa719e226ed8043005d69cdfcb2358518c5bdfb763e75b1fe01303091558e2a9d0c556fc5110379f532832eb3e1974a5d4134cd7d6ba927e2041fc7f943b5f33444bb63377c1c1cf6cd34f3a4de71a6f25e31d48b3bf3f9e29c84cc4e5955d0583a974b660032eab5e223610624b6b26c432fd78727fd8efac052104e8bd39f841947737f43183b188bf1c1776f5a29f371b9213922160d78cd98710760c6be98881eed4fb8d772c28480d650abfb23fb9d5bf6bd6cbf97db7b4c3ae25ee0255cba497a6df133512c69d625005b60bb61bdefc4a142fee4318cd8051828a89397e64aa66ead64d021c85d2bf91354f1c8667e0580653b58f5d10b7cb3fb073ed625f34a4543e8800d79570146ac7169af09dc008b6b966075bb696238cace5f423ea80d9312d41ec02e15560d705c4c49e0bdc456d381621257f44bff316c5869003dcafa75d81f267278b52221398b80ab2d0099581e487a9e3e7cce7770360527bbcb6117313521dac5667b450300b435aad47a2f87dc99b8f173be2bca2577fa30466a000ed2b8bdf5cef6f1b86d4340871816848438542d4a0b4bf75c134c730928a32225fd9c2df409fd5df4050e963ece179c23deff26ce7076dc6942fafdb9fc458d971f11a07210adc3a431bc2e187bd794c1d22fb080328583d627ec56ec804bd548c457c12da4772ffa2871ab991eab05ac5b810b20a84fcee551136a9855c7be72e01fbc4ae58b431ee5a382946753d108da44932d40380b992845de617c6927d5b94c5e093f4795b75c5d62675f8a2b8f342b18273e92d72727edbc32d6b71e2c984984f7827c49beab17afcbd567a8e00a9fb0b833385254244e5d4cb18afe8aacbdd74670feaa7b510e3a2f8fd926c54e8c07b9be448315f6a938184f43da4fda9a83148a4fb838cf784e7d1916778ded731a76702a2874ddc29a01530b64edf7295ae78f03dded00ceb7ba9e3748026282dc3addea9aa705a59ded81809434d5a6a049f2d1fb0943ff3737a04297ce183c8e47403316ec9faa54773376079241c719e65862862056fd4ee70e53101c044675b29e4200c451922ecf9c4ee270d7ff5fb634abbe44454322d7447c9b08499750536639686b2d162f92d7081b377690438f00cf8fa52cdc823a6fe2f93549ff9fa07fa8fd02b7240151ddcf9293ec528393dbe4adbb467a0e0185226dbae14fae7d27d784a1412a8c8e871d7ead47d659998a6b38ace2c830233011fe099fb56342a39117a1802f72eeb013c6f380c8fe35094417ecf19eda2d5dc129eb92cf986e09bc5fb48ca831c370b7a217040d87c3434b46abd46266fcf3f6aec27dae416b38a15cb4e19315d2c3ba22bab59865b3a7fda916fcc8f59bc146b999e9ea246d244116d5b207e365c5f96d35b11e0ef7eeba41380adbf45ad3a34f80016fb49d696c9d179b22d14943772e10e9ad4d7a339d37e55088facbfc0ef1f0ca9c238fa7ff79e4aff7fc18acfca50d70fbcc5eb9e1e7bd70b9cb984695af2d2c9687afac13b8519c1e0efd491f43f19c8f38a070c278620d3091abdaeb85849ae5e37f266d032b96670cd31808faeaa62b0c034e48940e556a36b5c11ea763e3ce1ba78382dcbe8fe99ba3a0bfc97163fe7630a5484ae029fea232ba69dcb65c610958807cf752f391bb587f7b480ebadade10540c3a9f156e82fdce4cbcdf1b7b1e2df03ff427c7770d75982c11cf8f798230feecb1fdf9ea875457626a0bcb2d29c0ac8aa29586128ea0fdd898ec56714c38ced3bfccb9d0ff8208e494520cc70f78e9c5beef5ab422d7c676440fdfc602240294340cf25ba389955e47adb188d7cb8bde821d1bf1054e14584a36bbe5bfdabb355ec25d5ced474af2d9535b4c05308bf3d325e831fadf7a7bb3b86e80f69bdbf9a7ce545af98de01cd952e438580de12f6be03032ab2b949a9aa457ae8578e2bf0a15e27b7e2fd891ea4db2b2c46d784ae7147621e33369345d8609c175d0977568ad7bc29823a37dc0d03a5f54591ff60a2b7d6ec9aac19d8ae5555b8aad84c36fb0b74daf1663c3a5ecb532bf17dabc794e308593bad23c97dfb651d61e7867171f0773fcc4f57060d651333f7ef3e4af89c20aacfdb471288960a4560ed587c34257a07aa93e103d94a995b2360e5ec2dfe3347f87d3d2a6d45ea628aca6525f842ec9e2364955e8c074ebcb95939cdc8ff938172f646aaabd95af6b966116d7bf4f70d0bcecb0d9aa5ac9b41ca7b6d889a5fcae36d67f6922e53e30f2b0f548dacee99babe3616e29040cbefe18a56eaa2e8682d2cd92e2bb51b1f518b55d567c680b3eb7616965739573008aac54a031ea283a8c4485854ea3dd20852e24fc349a7f4078795b5a18ae4f6a753f10b255af03f598180af6fbb97127dbaa704d139b211a1c60172611fe3893f7a1cb37a592057d0dd5b1abf0f14b01160975fbc0c00aac0aa38b391d5ff1f960404ffd7b7d485612c249167577ee3ea09407ff0a3e511c6eba68aaf02715db8a5a60d7a3b1eec820d4a447a63513620d6e8d7671b4ffdb906379aac8c30ed1c6ed1b0cb0664c502da7076f4425c74fdd094d567b0f6ed89ae06bb7faff761303614696e8a268b41e750a6384962282a848310060bedad727602afb9ae9149bcc8c8ce30c9630b9b609c0fc5386dcf332225952ce9ecd8446bf512b05398409d9d9beed90a2fca2b25bf520371f2776a2e8c2aab91e8c00753fdb7afe2afdf9c8a8c0656513285caba78f739982153330b3daf9bf4cd1a1bb67b100b02974d5600476bd61b4670b5a97119eb860e6a3588b7cde63635e8e0bcd0f6b3565d7a2290b6317a241133a25de9e3e1b5d222bf6c2109b3108a1cbe1df64e75cd51511594a167f189e0ba7646569b380eda3033200a428b84c3a6ce654d19967c864f0ae74904669eb268075a508a145d29063abb22f6506f34d64188b64066fe892bb02ff6616625046d2e5c296916192409a947d0e83495ff8f41ddb1cfc2caaa6762c3583feeb1e5b83f23abe515c567f7cca61ae95bdc50885592ed93ed48e56a1653a7f1f8ffd50428763d69fad67e058291665cdd3e7426844074e2390a4d6c489aca07955e615d843ab1a6bbc0a52e4e0597f682e7b58e1c1021b9a130e9b6a8ceeab33da6e3078a64abc414159a0ca088955726bb8567a042379c369c60960779707ca3f8aed1406fd97eceba5a56906b5bc49adbb6159b2dd8adb1d6af95546f0fde33c9a92fe0fe0209d6db298057cd25c520187f0635b45528ff47fe733462f71cbcc71a9b7ecc69a4af303bc0b1590723ce4f71208682bbff836f2544b2d20d3cdf8dc4f7ce62024695da0653c92f2ca91f1503f142e7b7fe89521404f850d89a437b0d7388a646a6041d07f31e55e965cd0dcbec663b0bf01bb2f0f744ab3c84aea3974244d2960e4b0ff15e368b438d0a7a24e94ea755c6c60bb0772fb75db98fc8a79e2f0fb7b4451abbc799e755689bb7a7e2f04be192053d81ad81a3a283bcf459624c7f3463c73050f4cce854a63462ef12cc610c9086c7620bdb08f3ace1a0eef812b9f51a529b7bab7ef29ae5eeadf504cdca0ed00cb7315e949f76301b0c218087a2402892e9a1ccfca84c9e05c686bebedd2ffe0b14cb6dca17420d37a4c3bf7d8b07fd596e4e6b58503071b4bfa30ab2354e2bdb2d4d4c8f2688c9004f9e38490ad50d13655b790f2b628171d392fd866855f59bc4b0e33736943fba14738de621f40cbe8e78c6056b63ed72ad5ddf2e1989a3867cdd443a06ec035067e8f06aeb30703cd5925d1f1cb0719ecf76db9db881a95ffb4dd1cd260bbae7ed797d740158291ff66979ee29e36f97cea85867c32fe93db851f9c34a4610b644504453c64809990d209c1b525e1696271c076803d9326654278d496e398a406e648f87a8bcc4617e6fdbd847c476f6b91e3a9a9a20a37e57f3a71bc842c0ec76f84f98064916e0376e724d50429dc28756146584dc5f0d5adfbf5a609d89efdc3d1b015f30913861779a5517cda92122febf9a6fa4e74172935e2298f8effaa1ca7a25beaa07c9ddcd35cc6c91f2534e0874573c43c3b7bb3b5137885b2b194621b77a31d22e2c10f04af03e95d20e6a4b98222d01f01411a902717e1e9ce9b4dc50d34c9024618f0b2bc3feff0eb07d60eb627210d9fdda18cb98395993b192f7153b1c14746c29db420330a8a806b62149807b7bdcd30a928514ef698fb0c80dc965f7d88acb4fb9c7d30de2209e4568af92635dd05ade86048612d4c4c0df2f330913b8a69b4dd6b53f9453b9239c4077642100","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
